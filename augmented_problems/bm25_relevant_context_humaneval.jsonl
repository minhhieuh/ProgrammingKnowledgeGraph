{"task_id": "HumanEval/0", "problem": ["def find_furthest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Extract two float numbers from the given array (at minimum contains two) that possess the maximum numerical difference. Remember to present them in ascending order (minor, major).\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (1.0, 5.0)\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (1.0, 5.0)\n    \"\"\"\n    return min(numbers), max(numbers)", "def rescale_vectors_to_unit(vectors: List[List[float]]) -> List[List[float]]:\n    \"\"\"\n    Accepting a compilation of N-dimensional vectors, an independent linear transform is applied to each dimension,\n    in such a way that the smallest measurement per dimension reduces to 0, and the uppermost rises to 1.\n\n    >>> rescale_vectors_to_unit([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0], [3.0, 4.0, 5.0]])\n    [[0.0, 0.0, 0.0], [0.5, 0.5, 0.5], [1.0, 1.0, 1.0]]\n    \"\"\"\n    dimension = len(vectors[0])\n    min_max = [[float('inf'), float('-inf')] for _ in range(dimension)]\n    \n    # Find the min and max value for each dimension\n    for vector in vectors:\n        for i in range(dimension):\n            if vector[i] < min_max[i][0]:\n                min_max[i][0] = vector[i]\n            if vector[i] > min_max[i][1]:\n                min_max[i][1] = vector[i]\n\n    # Rescale the vectors\n    for vector in vectors:\n        for i in range(dimension):\n            vector[i] = (vector[i] - min_max[i][0]) / (min_max[i][1] - min_max[i][0])\n    \n    return vectors", "def rescale_vectors_to_unit(vectors: List[List[float]]) -> List[List[float]]:\n    \"\"\"\n    Accepting a compilation of N-dimensional vectors, an independent linear transform is applied to each dimension,\n    in such a way that the smallest measurement per dimension reduces to 0, and the uppermost rises to 1.\n\n    Ex: rescale_vectors_to_unit([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0], [3.0, 4.0, 5.0]])\n    [[0.0, 0.0, 0.0], [0.5, 0.5, 0.5], [1.0, 1.0, 1.0]]\n    \"\"\"\n    dimension = len(vectors[0])\n    min_max = [[float('inf'), float('-inf')] for _ in range(dimension)]\n\n    # Find the min and max value for each dimension\n    for vector in vectors:\n        for i in range(dimension):\n            if vector[i] < min_max[i][0]:\n                min_max[i][0] = vector[i]\n            if vector[i] > min_max[i][1]:\n                min_max[i][1] = vector[i]\n\n    # Rescale the vectors\n    for vector in vectors:\n        for i in range(dimension):\n            vector[i] = (vector[i] - min_max[i][0]) / (min_max[i][1] - min_max[i][0])\n\n    return vectors", "def test_1():\n    start_x = 1.0  # [m]\n    start_y = 1.0  # [m]\n    start_yaw = 0.0  # [rad]\n    end_x = 5.0  # [m]\n    end_y = 3.0  # [m]\n    end_yaw = 1.57  # [rad]\n    px = [1.0, 2.0, 3.0, 4.0, 5.0]\n    py = [1.0, 1.5, 2.0, 2.5, 3.0]\n    pyaw = [0.0, 0.5, 1.0, 1.25, 1.57]\n    check_edge_condition(px, py, pyaw, start_x, start_y, start_yaw, end_x, end_y, end_yaw)", "def derivative_and_integral(xs: list, C: int):\n  \"\"\"\n  xs - coefficients of a polynomial (xs[0] + xs[1]*x + xs[2]*x^2 + ...)\n  This function returns the derivative and integral of the given polynomial, includes the constant C, and removes trailing zeros.\n\n  >>> derivative_and_integral([3, 1, 2, 4, 5], 2)\n  ([6, 4, 12, 20], [2.0, 3.0, 0.5, 0.5, 0.8, 1.0])\n  >>> derivative_and_integral([1, 2, 3], 4)\n  ([2, 6], [4.0, 1.0, 1.0, 1.0])\n  \"\"\"\n  derivative = []\n  integral = [C]\n\n  for i in range(len(xs)):\n    if i != 0:\n      derivative.append(i * xs[i])\n    if i+1 != 0:\n      integral.append(xs[i] / (i+1))\n\n  # Remove trailing zeros\n  while integral[-1] == 0:\n    integral = integral[:-1]\n  while derivative and derivative[-1] == 0:\n    derivative = derivative[:-1]\n\n  return derivative, integral"]}
{"task_id": "HumanEval/1", "problem": ["def separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    This function is designed to process a string that contains multiple nested groups of round, square, and curly brackets, which are frequently encountered in mathematical computations. \n    Your task is to segregate these bracket groups into separate string segments and return them in the form of a list.\n    Each distinct group is balanced (every opening brace has a corresponding closing brace) and does not nest within another group.\n    Disregard any white spaces present in the input string.\n    >>> separate_paren_groups(' ( ) (( )) {[()]} (( )( )) ')\n    ['()', '(())', '{[()]}', '(()())']\n    \"\"\"\n    # remove white spaces\n    paren_string = paren_string.replace(\" \", \"\")\n    start = ['(', '{', '[']\n    end = [')', '}', ']']\n    groups = []\n    temp_string = ''\n    counter = 0\n\n    for char in paren_string:\n        if char in start:\n            counter += 1\n            temp_string += char\n        elif char in end:\n            counter -= 1\n            temp_string += char\n            if counter == 0:\n                groups.append(temp_string)\n                temp_string = ''\n    return groups", "def separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    The function receives a string of multiple sets of nested parentheses. Your task is to\n    segregate these groups into distinct strings and return a list containing them.\n    Each separate group is balanced (every opening brace is duly closed) and not embedded within another group.\n    \"\"\"\n    paren_string = paren_string.replace(\" \", \"\")\n    groups = []\n    start = 0\n    bal = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            bal += 1\n        else:\n            bal -= 1\n        if bal == 0:\n            groups.append(paren_string[start:i+1])\n            start = i+1\n    return groups", "def separate_paren_groups(paren_string: str) -> List[str]:\n    stack = []\n    groups = []\n    group = \"\"\n    for ch in paren_string.replace(' ', ''):\n        if ch in ['(', '{', '[']:\n            if stack:\n                group += ch\n            stack.append(ch)\n        elif ch in [')', '}', ']']:\n            group += ch\n            stack.pop()\n            if not stack:\n                groups.append(group)\n                group = \"\"\n    return groups", "def separate_paren_groups(paren_string: str, complete_sets: bool= True) -> List[str]:\n\n    stack = []\n    result = []\n    last_open = {}\n\n    brackets = {'(':')', '[':']','{':'}'}\n\n    for index, char in enumerate(paren_string):\n        if char in brackets.keys():\n            # Char is an open bracket\n            stack.append(index)\n            last_open[brackets[char]] = len(stack) - 1\n        elif char in brackets.values():\n            # Char is a close bracket\n            if stack and last_open.get(char, -1) == len(stack) - 1:\n                start = stack.pop()\n                result.append(paren_string[start:index+1])\n                last_open.pop(char)\n            elif not complete_sets:\n                result.append(char)\n        elif not char.isspace():\n            # Char is not a bracket or whitespace; treat it as part of the last group\n            if result:\n                result[-1] += char\n            else: \n                result.append(char)\n\n    if not complete_sets:\n        # Include any remaining unbalanced brackets as separate groups\n        while stack:\n            start = stack.pop()\n            result.append(paren_string[start:])\n\n    return result", "def separate_paren_groups(paren_string: str, complete_sets: bool = True) -> List[str]:\n    stack = []\n    result = []\n    last_open = {}\n    \n    brackets = {'(':')', '[':']', '{':'}'}\n    \n    for index, char in enumerate(paren_string):\n        if char in brackets.keys():\n            # Char is an open bracket\n            stack.append(index)\n            last_open[brackets[char]] = len(stack)-1\n        elif char in brackets.values():\n            # Char is a close bracket\n            if stack and last_open.get(char, -1) == len(stack) - 1:\n                start = stack.pop()\n                result.append(paren_string[start:index+1])\n                last_open.pop(char)\n            elif not complete_sets:\n                result.append(char)\n        elif not char.isspace():\n            # Char is not a bracket or whitespace; treat it as part of the last group\n            if result:\n                result[-1] += char\n            else:\n                result.append(char)\n\n    if not complete_sets:\n        # Include any remaining unbalanced brackets as separate groups\n        while stack:\n            start = stack.pop()\n            result.append(paren_string[start:])\n    return result"]}
{"task_id": "HumanEval/2", "problem": ["def extract_integer(number: float) -> int:\n    \"\"\" Upon providing a positive floating-point number, it can invariably be segregated into\n    an integer component (the largest integer that is less than the input number) and the decimal\n    component (the remainder which is always less than 1).\n\n    Deliver the integer part of the number.\n    >>> extract_integer(4.7)\n    4\n    \"\"\"\n    return int(number)", "def extract_integer(number: float, precision: int) -> float:\n    \"\"\" Given a float, it breaks down into\n    an integer component (largest integer less or equal to the number) and decimals\n    (remainder always less than 1 and greater than -1).\n\n    The function should return the integer part of the number preserving precision up to a specified decimal point.\n    >>> extract_integer(4.70, 2)\n    4.70\n    >>> extract_integer(-3.200, 3)\n    -3.200\n    \"\"\"\n    decimal_point = Decimal(10) ** -precision  # Defines the decimal point up to the specified precision\n\n    if isinstance(number, (int, float)):\n        number = Decimal(number)  # Create a Decimal instance of the number\n    elif isinstance(number, str):\n        number = Decimal(number.replace(',', '.'))\n\n    return float(number.quantize(decimal_point, rounding=ROUND_DOWN))  # Return the number as a float, rounded to the specified precision", "def extract_integer(number: float) -> int:\n    \"\"\" Given a float, it separates into an integer component (\n    the largest integer less than or equal to the given number) and decimals (\n    remaining part always less than 1 and greater than -1).\n    \n    If the input is zero, return zero.\n    If the input number is very large, return an error message instead.\n    Provide the integer segment of the positive or negative number.\n    >>> extract_integer(4.7)\n    4\n    >>> extract_integer(-3.2)\n    -4\n    >>> extract_integer(0)\n    0\n    >>> extract_integer(1.7e308)\n    'Error: Number too large.'\n    \"\"\"\n    \n    if number == 0:\n        return 0\n    elif number == float('inf') or number == -float('inf'):\n        return 'Error: Number too large.'\n    else:\n        return math.floor(number)", "def extract_integer(number: float) -> int:\n    \"\"\"\n    A floating-point number can be bifurcated into an integer part (the largest integer no greater\n    than the input number) and a fraction part (the residual fragment, persistently less than 1 \n    but more than -1). \n\n    Architect this function in such a way that it unravels the integer sector of a number, whether \n    it is positive or negative.\n    \"\"\"\n    return math.floor(number)", "def extract_integer(number: float) -> int:\n    \"\"\"\n    A floating-point number can be bifurcated into an integer part (the largest integer no greater\n    than the input number) and a fraction part (the residual fragment, persistently less than 1 \n    but more than -1). \n\n    Architect this function in such a way that it unravels the integer sector of a number, whether \n    it is positive or negative.\n    \"\"\"\n    return math.floor(number)"]}
{"task_id": "HumanEval/3", "problem": ["def below_zero(operations: List[int]) -> bool:\n    \"\"\"\n    You're provided with a set of banking account transactions which consist of \n    deposit and withdrawal actions, starting from a null balance. Your duty is to find \n    if at any stage the account balance dips below zero, in which case the function is \n    expected to return True. Otherwise, the requirement is that it should yield False.\n\n    Example usages:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n    \n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False", "def below_zero(operations: List[Union[int, str]], case_insensitive: bool = False) -> bool:\n    \"\"\"\n    Given are deposit and withdrawal operations on a bank account which starts from zero balance. The operations may include integers or string representations of integers. Determine if the account balance dips below zero at any point. If it does, return True, otherwise, return False. If the case_insensitive flag is triggered, return True even when the balance is exactly zero.\n\n    Examples:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, \"-4\", 5])\n    True\n    >>> below_zero([1, \"2\", -3], True)\n    True\n    \"\"\"\n\n    balance = 0\n\n    for op in operations:\n        balance += int(op) # convert string to int if required and update the balance\n\n    if balance < 0 or (case_insensitive and balance == 0):\n        return True\n\n    return False", "def below_zero(operations: List[int], case_insensitive: bool = False) -> bool:\n    \"\"\"The function consumes a queue of deposit and withdrawal activities for a financial account inaugurating with a zero equilibrium. Your task involves identifying if the account's balance descends below zero at any juncture. If it does, the function must return True; on the contrary, it should return False. An optional case_insensitive flag exists that, when set to true, will return True when equilibrium touches zero.\n\n    Examples:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    >>> below_zero([1, 2, -3], True)\n    True\n    \"\"\"\n    balance = 0\n    for op in operations:\n        balance += op\n        if case_insensitive and balance <= 0:\n            return True\n        elif not case_insensitive and balance < 0:\n            return True\n    return False", "def below_zero(operations: List[Union[int, float]], handle_float: bool = False, balance_limit: int = 10):\n    \"\"\"\n    Your task is to monitor a series of bank transactions starting from a zero balance. If the account balance goes below zero at any point, return True; otherwise, return False. Your function should also include an optional flag for handling floating point values. Additionally, it should handle situations where withdrawals or negative payments take the account past a preset balance limit.\n\n    Examples:\n    >>> below_zero([1, 2, -4, 5])\n    True\n    >>> below_zero([1, 2, -3.5], True)\n    True\n    \"\"\"\n\n    balance = 0\n    for op in operations:\n        if not handle_float and isinstance(op, float):\n            continue\n        balance += op\n        if balance < 0 or balance > balance_limit:\n            return True\n    return False", "def below_zero(operations: List[Union[int, float]], handle_float: bool = False, balance_limit: int = 10):\n    \"\"\"\n    Given a list of deposit and withdrawal operations on a bank account starting with a balance of zero, \n    determine if the balance ever goes below zero during the operations and return True if it does. If not, return False. \n    Include an optional handle_float flag to cater for floating point numbers. The function should prohibit negative deposits \n    and withdrawals that exceed the balance limit.\n\n    Examples:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    >>> below_zero([1, 2, -3.5], True)\n    True\n    \"\"\"\n    balance = 0\n\n    for op in operations:\n        if (not handle_float and isinstance(op, float)) or op < 0 or op > balance_limit:\n            raise ValueError('Invalid operation: ' + str(op))\n        \n        balance += op\n\n        if balance < 0:\n            return True\n\n    return False"]}
{"task_id": "HumanEval/4", "problem": ["def find_furthest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Extract two float numbers from the given array (at minimum contains two) that possess the maximum numerical difference. Remember to present them in ascending order (minor, major).\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (1.0, 5.0)\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (1.0, 5.0)\n    \"\"\"\n    return min(numbers), max(numbers)", "def calculate_mean_std(numbers):\n    \"\"\"\n    Calculate the mean and standard deviation of a given list of numbers.\n\n    Args:\n    numbers: A list of numbers.\n\n    Returns:\n    A tuple containing the mean and standard deviation of the input numbers.\n    \"\"\"\n    mean = np.mean(numbers)\n    std_dev = np.std(numbers)\n    return (mean, std_dev)", "def calculate_standard_deviation(num_array):\n    # Calculate the mean\n    mean = sum(num_array) / len(num_array)\n    \n    # Calculate the deviation from the mean\n    deviation = [x - mean for x in num_array]\n    \n    # Calculate the squared deviation\n    squared_deviation = [d ** 2 for d in deviation]\n    \n    # Find the average of these squared deviations\n    average_squared_deviation = sum(squared_deviation) / len(squared_deviation)\n    \n    # Finally, take the square root of the average squared deviation to get the standard deviation\n    standard_deviation = math.sqrt(average_squared_deviation)\n    \n    return standard_deviation", "def rolling_avg_median(numbers: List[int]) -> List[Tuple[float, float]]:\n    result = []\n    for i in range(1, len(numbers) + 1):\n        sublist = numbers[:i]\n        mean, median = np.mean(sublist), np.median(sublist)\n        if not result or (mean, median) != result[-1]:\n            result.append((mean, median))\n    return result", "def rescale_vectors_to_unit(vectors: List[List[float]]) -> List[List[float]]:\n    \"\"\"\n    Accepting a compilation of N-dimensional vectors, an independent linear transform is applied to each dimension,\n    in such a way that the smallest measurement per dimension reduces to 0, and the uppermost rises to 1.\n\n    >>> rescale_vectors_to_unit([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0], [3.0, 4.0, 5.0]])\n    [[0.0, 0.0, 0.0], [0.5, 0.5, 0.5], [1.0, 1.0, 1.0]]\n    \"\"\"\n    dimension = len(vectors[0])\n    min_max = [[float('inf'), float('-inf')] for _ in range(dimension)]\n    \n    # Find the min and max value for each dimension\n    for vector in vectors:\n        for i in range(dimension):\n            if vector[i] < min_max[i][0]:\n                min_max[i][0] = vector[i]\n            if vector[i] > min_max[i][1]:\n                min_max[i][1] = vector[i]\n\n    # Rescale the vectors\n    for vector in vectors:\n        for i in range(dimension):\n            vector[i] = (vector[i] - min_max[i][0]) / (min_max[i][1] - min_max[i][0])\n    \n    return vectors"]}
{"task_id": "HumanEval/5", "problem": ["def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n    result = []\n    for i, num in enumerate(numbers):\n        if i > 0:\n            result.append(delimeter)\n        result.append(num)\n    return result", "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Embeds 'delimeter' among consecutive elements of `numbers` and acknowledges absolute values of negative delimeter.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], -2)\n    [1, 2, 3]\n    \"\"\"\n    result = []\n    for i, num in enumerate(numbers):\n        if delimeter < 0 and i == abs(delimeter):\n            continue\n        result.append(num)\n        if i != len(numbers) - 1:\n            result.append(abs(delimeter))\n    return result", "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function inserts a number 'delimeter' between each consectute elements of the input list `numbers` and deals with scenarios where the delimeter is negative.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], -2)\n    [1, 2, 3]\n    \"\"\" \n    result = []\n    abs_delimeter = abs(delimeter)\n    for i in range(len(numbers)):\n        result.append(numbers[i])\n        if i != len(numbers)-1:\n            # Exempt the index locations that matches absolute of negative delimeter\n            if i+1 != abs_delimeter:\n                result.append(delimeter)\n    return result", "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"\n    Insert 'delimeter' between each pair of consecutive elements in 'numbers'. Check if 'numbers' is strictly increasing.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n    # Check if numbers is strictly increasing\n    if not verify(numbers):\n        return \"Numbers list is not strictly increasing!\"\n    \n    result = []\n    for num in numbers:\n        result.append(num)\n        result.append(delimeter)        \n    return result[:-1]  # Deletes the last unwanted delimeter", "def intersperse(numbers: List[Union[int, List[int]]], delimeter: Union[int, float]) -> List[int]:\n    \"\"\"\n    Introduce the 'delimeter' digit amongst every couple of sequential numbers in the supplied 'numbers' list.\n    Moreover, make sure to manage scenarios that involve a negative or non-integer `delimeter`.\n    Also handles nested list within numbers list.\n    For example:\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], -2)\n    [1, 2, 3]\n    >>> intersperse([1, [2, 3]], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], 4.5)\n    [1, 2, 3]\n    \"\"\"\n    outcome = []\n    flattened_numbers = []\n\n    # This block is to handle nested arrays and flatten them.\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimeter))  # recursive flatten\n        else:\n            flattened_numbers.append(num)\n\n    # This block is to place the delimeter (if it's a non-negative integer) in between the numbers.\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i < len(flattened_numbers) - 1 and isinstance(delimeter, int) and delimeter >= 0:\n            outcome.append(delimeter)\n\n    return outcome"]}
{"task_id": "HumanEval/6", "problem": ["def separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    This function is designed to process a string that contains multiple nested groups of round, square, and curly brackets, which are frequently encountered in mathematical computations. \n    Your task is to segregate these bracket groups into separate string segments and return them in the form of a list.\n    Each distinct group is balanced (every opening brace has a corresponding closing brace) and does not nest within another group.\n    Disregard any white spaces present in the input string.\n    >>> separate_paren_groups(' ( ) (( )) {[()]} (( )( )) ')\n    ['()', '(())', '{[()]}', '(()())']\n    \"\"\"\n    # remove white spaces\n    paren_string = paren_string.replace(\" \", \"\")\n    start = ['(', '{', '[']\n    end = [')', '}', ']']\n    groups = []\n    temp_string = ''\n    counter = 0\n\n    for char in paren_string:\n        if char in start:\n            counter += 1\n            temp_string += char\n        elif char in end:\n            counter -= 1\n            temp_string += char\n            if counter == 0:\n                groups.append(temp_string)\n                temp_string = ''\n    return groups", "def all_prefixes_with_lengths(string: str) -> List[Tuple[str, int]]:\n    \"\"\" \n    Function that returns a list of tuples which include all prefixes of an input string from smallest to largest and their corresponding lengths\n    E.g. all_prefixes_with_lengths('abc') should return [('a', 1), ('ab', 2), ('abc', 3)]\n    \"\"\"\n    return [(string[:i], i) for i in range(1, len(string)+1)]", "def encode_cyclic(s: str):\n    \"\"\"\n    This function is intended to encode a string by cycling groups of three characters,\n    and then shifting them three positions further in the alphabet using a Caesar cipher.\n    \"\"\"\n    groups = [s[(3 * i)+3: min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    groups = [''.join(chr((ord(c) - 65 + 3) % 26 + 65) for c in group) if group.isalpha() else group for group in groups]\n    return \"\".join(groups)", "def cyclic_encode(s: str):\n    \"\"\"\n    Encodes the string by cycling groups of three characters.\n    \"\"\"\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)", "def decode_cyclic(s: str):\n    \"\"\"\n    accepts a string encoded with the above encode_cyclic function, decodes, handling special characters, whitespace and numbers.\n    \"\"\"\n    # split the string into groups of three\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    \n    # if length of group is 3, move the last character to the front, otherwise leave as is\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    \n    return \"\".join(groups)"]}
{"task_id": "HumanEval/7", "problem": ["def filter_by_prefix_and_suffix(strings: List[str], prefix_suffix: Tuple[str, str], min_length: int) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix, end with a given suffix, and have a minimum length.\n    \n    Example:\n    >>> filter_by_prefix_and_suffix([], ('a', 'z'), 3)\n    []\n    \n    >>> filter_by_prefix_and_suffix(['abc', 'bcd', 'cdez', 'arrayz'], ('a', 'z'), 5)\n    ['arrayz']\n    \n    >>> filter_by_prefix_and_suffix(['abc', 'azy'], ('a', 'z'), 3)\n    ['abc']\n    \"\"\"\n    pass", "def filter_by_prefix_and_suffix(strings: List[str], prefix_suffix: Tuple[str, str]) -> List[str]:\n    \"\"\" Meticulously filter an input collection of strings for sole instances that inaugurate with a specified prefix and terminate with a distinctive suffix.\n    >>> filter_by_prefix_and_suffix([], ('a', 'z'))\n    []\n    >>> filter_by_prefix_and_suffix(['abc', 'bcd', 'cdez', 'arrayz'], ('a', 'z'))\n    ['arrayz']\n    >>> filter_by_prefix_and_suffix(['abc', 'azy'], ('a', 'z'))\n    ['azy', 'abc']\n    \"\"\"\n    pass", "def pattern_match(strings: List[str], pattern: Tuple[List[str], str, str]) -> Tuple[List[str], int, int]:\n    \"\"\" \n    - Filter an input list of strings only for ones that contain a given pattern,\n    - Strings should start with a given prefix, and end with a given suffix \n    - Calculate the Levenshtein distance between the pattern and string found in the list\n    - And count occurrence of the given prefix and suffix in all strings from the list\n\n    >>> pattern_match([], (['a', 'b', 'c'], 'a', 'z'))\n    ([], 0, 0)\n    >>> pattern_match(['abc', 'bcd', 'cdez', 'arrayz'], (['b', 'c', 'd'], 'a', 'z'))\n    (['arrayz'], 1, 2)\n    >>> pattern_match(['abc', 'azy'], (['b', 'c'], 'a', 'z'))\n    (['abc'], 1, 1)\n    \"\"\"\n\n    result, distance, prefix_count, suffix_count = [], 0, 0, 0\n    for string in strings:\n        if string.startswith(pattern[1]):\n            prefix_count += 1\n        if string.endswith(pattern[2]):\n            suffix_count += 1\n        if all(x in string for x in pattern[0]) and string.startswith(pattern[1]) and string.endswith(pattern[2]):\n            result.append(string)\n            distance += leven_dist(''.join(pattern[0]), string)\n    return result, distance, prefix_count, suffix_count", "def all_prefixes_with_lengths(string: str) -> List[Tuple[str, int]]:\n    \"\"\" \n    Function that returns a list of tuples which include all prefixes of an input string from smallest to largest and their corresponding lengths\n    E.g. all_prefixes_with_lengths('abc') should return [('a', 1), ('ab', 2), ('abc', 3)]\n    \"\"\"\n    return [(string[:i], i) for i in range(1, len(string)+1)]", "def shortest(strings: List[str]) -> Optional[str]:\n    \"\"\"From a list of strings, return the shortest string. If multiple strings have the same length, return the first one with the least consonants. For an empty list, return None.\n    >>> shortest([])\n    None\n    >>> shortest(['a', 'b', 'c'])\n    'a'\n    >>> shortest(['a', 'ab', 'cc'])\n    'a'\n    >>> shortest(['a', 'bc', 'bbc'])\n    'a'\n    >>> shortest(['a', 'ba', 'bb'])\n    'a'\n    \"\"\"\n    if not strings:\n        return None\n\n    # create a list of tuples, each containing a string and its length and no of consonants\n    strings = [(s, len(s), count_consonants(s)) for s in strings]\n\n    # sort by length and no of consonants\n    strings.sort(key=lambda x: [x[1], x[2]])\n\n    return strings[0][0]"]}
{"task_id": "HumanEval/8", "problem": ["def sum_of_even_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers: A list of integers.\n\n    Returns:\n    The sum of all even numbers in the list.\n    \n    Examples:\n    >>> sum_of_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    30\n    >>> sum_of_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_of_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)", "def prime_digit_product(x):\n    \"\"\"Given a list of positive integers x, return a sorted list of all \n    _distinct_ elements wherein the product of its digits is a prime number.\n\n    Note: The resulting list should be sorted in ascending order. \n\n    >>> prime_digit_product([15, 33, 1422, 1, 15])\n    [1, 15]\n    >>> prime_digit_product([152, 323, 1422, 10])\n    [323]\n\n    \"\"\"\n    return sorted(set([i for i in x if is_prime(prod([int(d) for d in str(i)]))]))", "def sum_even_numbers(numbers):\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The sum of all even numbers in the list.\n\n    Examples:\n    >>> sum_even_numbers([1, 2, 3, 4, 5, 6])\n    12\n    >>> sum_even_numbers([10, 11, 12, 13, 14, 15])\n    36\n    >>> sum_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)", "def sum_even_numbers(numbers):\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The sum of all even numbers in the list. Returns 0 if the list is empty or does not contain any even numbers.\n\n    Examples:\n    >>> sum_even_numbers([1, 2, 3, 4, 5, 6])\n    12\n    >>> sum_even_numbers([1, 3, 5, 7])\n    0\n    >>> sum_even_numbers([])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)", "def odd_sum_elements(x):\n    \"\"\"Given a list of positive integers x, return a sorted list of all \n    _unique_ elements where the sum of their digits is an odd number.\n\n    Note: The returned list should be sorted in ascending order. \n\n    >>> odd_sum_elements([15, 33, 1422, 1, 15])\n    [1, 15]\n    >>> odd_sum_elements([152, 323, 1422, 10])\n    [323]\n\n    \"\"\"\n    odd_sum_digits = []\n    for i in set(x):\n        if sum(int(digit) for digit in str(i)) % 2 != 0:\n            odd_sum_digits.append(i)\n    return sorted(odd_sum_digits)"]}
{"task_id": "HumanEval/9", "problem": ["def rolling_max(numbers1: List[int], numbers2: List[int]) -> Tuple[List[int], List[int]]:\n    \"\"\" From two given lists of integers, generate a list of rolling maximum element found until given moment \n    in the sequence and store them as maximum of each list.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2], [1, 4, 2, 4, 1, 5, 1])\n    ([1, 2, 3, 3, 3, 4, 4], [1, 4, 4, 4, 4, 5, 5])\n    \"\"\"\n    pass  # Your implementation here", "def uncommon_elements(sequence):\n    '''\n    Design a function that accepts a non-empty list composed of positive integers and returns a list of distinct integers whose frequency surpasses half of the integer's numerical value. Here, 'frequency' denotes the number of times a specific integer appears within the list.\n    If no integers satisfy these conditions, the function should return an empty list.\n    Examples:\n        uncommon_elements([4, 1, 2, 2, 3, 1]) should yield [2, 3]\n        uncommon_elements([1, 2, 2, 3, 3, 3, 4, 4, 4]) should yield [2, 3, 4]\n        uncommon_elements([5, 5, 4, 4, 4]) should yield [4]\n    '''\n    from collections import Counter\n    count = Counter(sequence)\n    result = []\n    for num, freq in count.items():\n        if freq > num/2:\n            result.append(num)\n    return result", "def sum_of_even_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers: A list of integers.\n\n    Returns:\n    The sum of all even numbers in the list.\n    \n    Examples:\n    >>> sum_of_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    30\n    >>> sum_of_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_of_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)", "def intersperse(numbers: List[Union[int, List[int]]], delimeter: Union[int, float]) -> List[int]:\n    \"\"\"\n    Introduce the 'delimeter' digit amongst every couple of sequential numbers in the supplied 'numbers' list.\n    Moreover, make sure to manage scenarios that involve a negative or non-integer `delimeter`.\n    Also handles nested list within numbers list.\n    For example:\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], -2)\n    [1, 2, 3]\n    >>> intersperse([1, [2, 3]], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], 4.5)\n    [1, 2, 3]\n    \"\"\"\n    outcome = []\n    flattened_numbers = []\n\n    # This block is to handle nested arrays and flatten them.\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimeter))  # recursive flatten\n        else:\n            flattened_numbers.append(num)\n\n    # This block is to place the delimeter (if it's a non-negative integer) in between the numbers.\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i < len(flattened_numbers) - 1 and isinstance(delimeter, int) and delimeter >= 0:\n            outcome.append(delimeter)\n\n    return outcome", "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n    result = []\n    for i, num in enumerate(numbers):\n        if i > 0:\n            result.append(delimeter)\n        result.append(num)\n    return result"]}
{"task_id": "HumanEval/10", "problem": ["def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix,\n    \"\"\"\n    palindromic_postfix = longest_palindromic_postfix(string)\n    prefix = string[0:len(string) - len(palindromic_postfix)]\n    return string + prefix[::-1]", "def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    palindromic_postfix = longest_palindromic_postfix(string)\n    prefix = string[0:len(string) - len(palindromic_postfix)]\n    return string + prefix[::-1]", "def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    if is_palindrome(string):\n        return string\n\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            reversed_prefix = string[:i][::-1]\n            return string + reversed_prefix\n\n    return string + string[::-1]", "def make_palindrome(string: str) -> str:\n    \"\"\"\n    Find the shortest palindrome that begins with a supplied string, considering spaces between words, and ignoring case, \n    and ignoring non-alphanumeric characters.\n    \n    Algorithm idea is simple:\n    - Find the longest suffix of the supplied string that is a palindrome.\n    - Append to the end of the string the reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    filtered_string = ''.join([char for char in string.lower() if char.isalnum()])\n    string_length = len(filtered_string)\n    \n    if is_palindrome(string):\n        return string\n    \n    for postfix_start in range(string_length):\n        postfix = filtered_string[postfix_start:]\n        if is_palindrome(postfix):\n            non_palindronic_part = filtered_string[:postfix_start]\n            return string + non_palindronic_part[::-1]", "def make_palindrome(string: str) -> int:\n    \"\"\" Find the minimum number of characters that need to be added at the end of the supplied string to make it a palindrome, ignoring case, non-alphanumeric characters, and spaces between words.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Compute the length of the string prefix that comes before the palindromic suffix.\n    - Return the length of the prefix as the minimum number of characters needed to create the shortest possible palindrome.\n    \"\"\"\n    filtered_string = ''.join(char.lower() for char in string if char.isalnum())\n    \n    for i in range(len(filtered_string)):\n        if is_palindrome(filtered_string[i:]):\n            return i"]}
{"task_id": "HumanEval/11", "problem": ["def string_xor(a: str, b: str) -> str:\n    \"\"\" Input: two individual string parameters a and b, constructed exclusively from binary digits i.e. 1s and 0s.\n    Conduct a binary exclusive OR operation on the specified inputs and yield the result as a string output.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n    # convert the binary strings to integers\n    a = int(a, 2)\n    b = int(b, 2)\n    \n    # Conduct a binary exclusive OR operation on the inputs\n    result = a ^ b\n    \n    # Format the result as a binary string and return it\n    return format(result, 'b')", "def reverse_binary(a: str) -> str:\n    \"\"\" Input: a single string `a` made up only of 1s and 0s.\n    Perform a binary reverse on the input and return the result as a string format.\n    >>> reverse_binary('010')\n    '010'\n    \"\"\"\n    return a[::-1]", "def string_and(a: str, b: str) -> str:\n    \"\"\"\n    Inputs: two distinct string parameters a and b, only from hexadecimal digits i.e. 0-9 and A-F, of length between 10^3 and 10^5. \n    Perform AND operation on these inputs, validate strings are formatted correctly in hexadecimal and output the result as a string.\n\n    >>> string_and('A3F','B2E')\n    'A2E'\n    \"\"\"\n    # Check if strings are hexadecimal\n    try:\n        int(a, 16)\n        int(b, 16)\n    except ValueError:\n        raise ValueError('Input must be hexadecimal string')\n\n    # Perform AND operation\n    and_result = int(a, 16) & int(b, 16)\n\n    # Convert to hexadecimal string (removing '0x' prefix) and return\n    return hex(and_result)[2:].upper()", "def string_xor(a: str, b: str) -> str:\n\n    # First we check if the strings are not exceeding length 10^3, and if they do, we raise an exception\n    if len(a) > 10**3 or len(b) > 10**3:\n        raise ValueError(\"Input strings length should not exceed 10^3 characters.\") \n\n    # Then we check if the strings are comprised only of 1s and 0s. If not, we raise an exception\n    if not set(a).issubset(set('01')) or not set(b).issubset(set('01')):\n        raise ValueError(\"Input should only contain binary digits (i.e., 1s and 0s).\")\n\n    # If the strings are of different lengths, we pad the shorter one with 0s at the beginning\n    if len(a) != len(b):\n        if len(a) < len(b):\n            a = a.zfill(len(b))\n        else:\n            b = b.zfill(len(a))\n\n    # Then we conduct the XOR operation\n    result = ''\n    for i in range(len(a)):\n        # XOR operation\n        if a[i] == b[i]:\n            result += '0'\n        else:\n            result += '1'\n\n    return result", "def string_xor(a: str, b: str) -> str:\n\n    # First we check if the strings are not exceeding length 10^3, and if they do, we raise an exception\n    if len(a) > 10**3 or len(b) > 10**3:\n        raise ValueError(\"Input strings length should not exceed 10^3 characters.\") \n\n    # Then we check if the strings are comprised only of 1s and 0s, if not, we raise an exception\n    if not set(a).issubset(set('01')) or not set(b).issubset(set('01')):\n        raise ValueError(\"Input should only contain binary digits (i.e., 1s and 0s).\")\n    \n    # If the strings are of different lengths, we pad the shorter one with 0s at the beginning\n    if len(a) != len(b):\n        if len(a) < len(b):\n            a = a.zfill(len(b))\n        else:\n            b = b.zfill(len(a))\n\n    # Then we conduct the XOR operation\n    result = ''\n    for i in range(len(a)):\n        # XOR operation\n        if a[i] == b[i]:\n            result += '0'\n        else:\n            result += '1'\n\n    return result"]}
{"task_id": "HumanEval/12", "problem": ["def longest(strings: List[str]) -> Optional[str]:\n    \"\"\"\n    Return the longest string in a list. If more than one string has the same \n    length, return the first one. If the list is empty, return None.\n\n    Examples:\n\n    >>> longest([])\n    >>>\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n    if not strings: return None\n    return max(strings, key=len)", "def longest(strings: List[str]) -> Optional[str]:\n    \"\"\" In a given list of strings, identify and return the string having the longest length. If there are several strings with the same lengths, return the one that appeared first. If the list has no elements, return None.\n\n    >>> longest([])\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n\n    if not strings: # check if the list is empty\n        return None\n\n    longest_string = strings[0]\n    for string in strings:\n        if len(string) > len(longest_string):\n            longest_string = string\n\n    return longest_string", "def shortest(strings: List[str]) -> Optional[str]:\n    \"\"\"From a list of strings, return the shortest string. If multiple strings have the same length, return the first one with the least consonants. For an empty list, return None.\n    >>> shortest([])\n    None\n    >>> shortest(['a', 'b', 'c'])\n    'a'\n    >>> shortest(['a', 'bb', 'ccc'])\n    'a'\n    >>> shortest(['a', 'Ccc', 'bbb'])\n    'a'\n    >>> shortest(['a', 'ba', 'bb'])\n    'a'\n    \"\"\"\n    if not strings:\n        return None\n\n    # create a list of tuples, each containing a string and its length and no of consonants\n    strings = [(s, len(s), count_consonants(s)) for s in strings]\n\n    # sort by length and no of consonants\n    strings.sort(key=lambda x: (x[1], x[2]))\n\n    return strings[0][0]", "def shortest(strings: List[str]) -> Optional[str]:\n    \"\"\"From a list of strings, return the shortest string. If multiple strings have the same length, return the first one with the least consonants. For an empty list, return None.\n    >>> shortest([])\n    None\n    >>> shortest(['a', 'b', 'c'])\n    'a'\n    >>> shortest(['a', 'ab', 'cc'])\n    'a'\n    >>> shortest(['a', 'bc', 'bbc'])\n    'a'\n    >>> shortest(['a', 'ba', 'bb'])\n    'a'\n    \"\"\"\n    if not strings:\n        return None\n\n    # create a list of tuples, each containing a string and its length and no of consonants\n    strings = [(s, len(s), count_consonants(s)) for s in strings]\n\n    # sort by length and no of consonants\n    strings.sort(key=lambda x: [x[1], x[2]])\n\n    return strings[0][0]", "def longest(strings: List[str], n: int) -> Optional[str]:\n    \"\"\" From a list of strings, find and return the nth lengthiest string. If several strings share the same length, return the first one in order of appearance. If the list contains less than n strings, return None.\"\"\"\n    strings.sort(key=len, reverse=True)\n    return strings[n - 1] if n <= len(strings) else None"]}
{"task_id": "HumanEval/13", "problem": ["def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" \n    Return the highest common factor of the two integers a and b.\n    It uses Euclidean Algorithm to find the GCD.\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Return the highest common divisor of the two given non-negative integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    >>> greatest_common_divisor(0, 0)\n    0\n    >>> greatest_common_divisor(0, 5)\n    5\n    \"\"\"\n    if a < 0 or b < 0:\n        raise ValueError(\"Both numbers must be non-negative\")\n    \n    # Optimization: Return early when one of the inputs is zero  \n    if a==0: \n        return b \n    if b==0: \n        return a \n\n    # Use Euclidean Algorithm to return the gcd\n    while a % b != 0:\n        temp = a\n        a = b\n        b = temp % b\n    return b", "def calculate_gcd(a: int, b: int) -> int:\n    \"\"\"\n    Returns the greatest common divisor of 'a' and 'b'.\n\n    Parameters:\n    a (int): The first input integer\n    b (int): The second input integer\n\n    Returns:\n    int: The greatest common divisor of 'a' and 'b'\n\n    >>> calculate_gcd(3, 5)\n    1\n    >>> calculate_gcd(25, 15)\n    5\n    >>> calculate_gcd(0, 5)\n    5\n    >>> calculate_gcd(5, 0)\n    5   \n    \"\"\"\n\n    # inputs must be integers\n    if not all(isinstance(i, int) for i in [a, b]):\n        raise TypeError(\"Both inputs must be integers.\")\n\n    # inputs must be non-negative\n    if a < 0 or b < 0:\n        raise ValueError(\"Inputs must be non-negative integers.\")\n\n    # special case when both inputs are zero\n    if a == 0 and b == 0:\n        raise ValueError(\"At least one input must be non-zero.\")\n\n    # main gcd calculation using Euclidean algorithm\n    while b != 0:\n        a, b = b, a % b\n\n    return a", "def calculate_gcd(a: int, b: int) -> int:\n    \"\"\"\n    Returns the greatest common divisor of 'a' and 'b'.\n\n    Parameters:\n    a (int): The first input integer\n    b (int): The second input integer\n\n    Returns:\n    int: The greatest common divisor of 'a' and 'b'\n\n    >>> calculate_gcd(3, 5)\n    1\n    >>> calculate_gcd(15, 15)\n    15\n    >>> calculate_gcd(0, 5)\n    5\n    >>> calculate_gcd(5, 0)\n    5   \n    \"\"\"\n\n    # inputs must be integers\n    if not all(isinstance(i, int) for i in [a, b]):\n        raise TypeError(\"Both inputs must be integers.\")\n\n    # inputs must be non-negative\n    if a < 0 or b < 0:\n        raise ValueError(\"Inputs must be non-negative integers.\")\n\n    # special case when both inputs are zero\n    if a == 0 and b == 0:\n        raise ValueError(\"At least one input must be non-zero.\")\n\n    # main gcd calculation using Euclidean algorithm\n    while b != 0:\n        a, b = b, a % b\n\n    return a", "def highest_common_factor(a: int, b: int) -> int:\n    \"\"\" Return a highest common factor of two non-negative integers a and b\n    >>> highest_common_factor(3, 5)\n    1\n    >>> highest_common_factor(25, 15)\n    5\n    \"\"\"\n\n    # Validate the input parameters\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise ValueError(\"Input parameters must be integers\")\n    if a < 0 or b < 0:\n        raise ValueError(\"Input parameters must be non-negative\")\n\n    # GCD computation using Euclid's Algorithm\n    while b != 0:\n        a, b = b, a % b\n    return a"]}
{"task_id": "HumanEval/14", "problem": ["def all_prefixes_with_lengths(string: str) -> List[Tuple[str, int]]:\n    \"\"\" \n    Function that returns a list of tuples which include all prefixes of an input string from smallest to largest and their corresponding lengths\n    E.g. all_prefixes_with_lengths('abc') should return [('a', 1), ('ab', 2), ('abc', 3)]\n    \"\"\"\n    return [(string[:i], i) for i in range(1, len(string)+1)]", "def filter_by_prefix_and_suffix(strings: List[str], prefix_suffix: Tuple[str, str]) -> List[str]:\n    \"\"\" Meticulously filter an input collection of strings for sole instances that inaugurate with a specified prefix and terminate with a distinctive suffix.\n    >>> filter_by_prefix_and_suffix([], ('a', 'z'))\n    []\n    >>> filter_by_prefix_and_suffix(['abc', 'bcd', 'cdez', 'arrayz'], ('a', 'z'))\n    ['arrayz']\n    >>> filter_by_prefix_and_suffix(['abc', 'azy'], ('a', 'z'))\n    ['azy', 'abc']\n    \"\"\"\n    pass", "def filter_by_prefix_and_suffix(strings: List[str], prefix_suffix: Tuple[str, str], min_length: int) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix, end with a given suffix, and have a minimum length.\n    \n    Example:\n    >>> filter_by_prefix_and_suffix([], ('a', 'z'), 3)\n    []\n    \n    >>> filter_by_prefix_and_suffix(['abc', 'bcd', 'cdez', 'arrayz'], ('a', 'z'), 5)\n    ['arrayz']\n    \n    >>> filter_by_prefix_and_suffix(['abc', 'azy'], ('a', 'z'), 3)\n    ['abc']\n    \"\"\"\n    pass", "def shortest(strings: List[str]) -> Optional[str]:\n    \"\"\"From a list of strings, return the shortest string. If multiple strings have the same length, return the first one with the least consonants. For an empty list, return None.\n    >>> shortest([])\n    None\n    >>> shortest(['a', 'b', 'c'])\n    'a'\n    >>> shortest(['a', 'ab', 'cc'])\n    'a'\n    >>> shortest(['a', 'bc', 'bbc'])\n    'a'\n    >>> shortest(['a', 'ba', 'bb'])\n    'a'\n    \"\"\"\n    if not strings:\n        return None\n\n    # create a list of tuples, each containing a string and its length and no of consonants\n    strings = [(s, len(s), count_consonants(s)) for s in strings]\n\n    # sort by length and no of consonants\n    strings.sort(key=lambda x: [x[1], x[2]])\n\n    return strings[0][0]", "def pattern_match(strings: List[str], pattern: Tuple[List[str], str, str]) -> Tuple[List[str], int, int]:\n    \"\"\" \n    - Filter an input list of strings only for ones that contain a given pattern,\n    - Strings should start with a given prefix, and end with a given suffix \n    - Calculate the Levenshtein distance between the pattern and string found in the list\n    - And count occurrence of the given prefix and suffix in all strings from the list\n\n    >>> pattern_match([], (['a', 'b', 'c'], 'a', 'z'))\n    ([], 0, 0)\n    >>> pattern_match(['abc', 'bcd', 'cdez', 'arrayz'], (['b', 'c', 'd'], 'a', 'z'))\n    (['arrayz'], 1, 2)\n    >>> pattern_match(['abc', 'azy'], (['b', 'c'], 'a', 'z'))\n    (['abc'], 1, 1)\n    \"\"\"\n\n    result, distance, prefix_count, suffix_count = [], 0, 0, 0\n    for string in strings:\n        if string.startswith(pattern[1]):\n            prefix_count += 1\n        if string.endswith(pattern[2]):\n            suffix_count += 1\n        if all(x in string for x in pattern[0]) and string.startswith(pattern[1]) and string.endswith(pattern[2]):\n            result.append(string)\n            distance += leven_dist(''.join(pattern[0]), string)\n    return result, distance, prefix_count, suffix_count"]}
{"task_id": "HumanEval/15", "problem": ["def string_sequence(n):\n    # Initialise an empty list to hold the sequence\n    sequence = []\n    # Iterate from 0 to n inclusive\n    for i in range(n + 1):\n        # Add each number to the sequence list, converting it into a string\n        sequence.append(str(i))\n    # Join all elements in the list into a string separated by spaces and return\n    return ' '.join(sequence)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"Determine the frequency of a given substring in the initial string. Include overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Determine the frequency of a given substring in the initial string. Include overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count", "def classify_number(n):\n    \"\"\"\n    This function returns 'square' for perfect square numbers, 'prime' for prime numbers, and 'neither' for the rest.\n    >>> classify_number(4)\n    'square'\n    >>> classify_number(101)\n    'prime'\n    >>> classify_number(6)\n    'neither'\n    >>> classify_number(11)\n    'prime'\n    >>> classify_number(1)\n    'neither' # 1 is neither prime nor composite\n    \"\"\"\n    import math\n\n    # Check if number is a perfect square\n    sqrt = math.sqrt(n)\n    if sqrt == int(sqrt):\n        return 'square'\n\n    # Check if number is a prime\n    elif n > 1:\n        for i in range(2, int(sqrt) + 1):\n            if (n % i) == 0:\n                return 'neither'\n        return 'prime'\n\n    else:\n        return 'neither'", "def classify_number(n):\n    \"\"\"\n    This function returns 'square' for perfect square numbers, 'prime' for prime numbers, and 'neither' for the rest.\n    >>> classify_number(4)\n    'square'\n    >>> classify_number(101)\n    'prime'\n    >>> classify_number(6)\n    'neither'\n    >>> classify_number(11)\n    'prime'\n    >>> classify_number(1)\n    'neither' # 1 is neither prime nor composite\n    \"\"\"\n    import math\n\n    # Check if number is a perfect square\n    sqrt = math.sqrt(n)\n    if sqrt == int(sqrt):\n        return 'square'\n\n    # Check if number is a prime\n    elif n > 1:\n        for i in range(2, int(sqrt) + 1):\n            if (n % i) == 0:\n                return 'neither'\n        return 'prime'\n\n    else:\n        return 'neither'"]}
{"task_id": "HumanEval/16", "problem": ["def how_many_times(string: str, substring: str) -> int:\n    \"\"\"Determine the frequency of a given substring in the initial string. Include overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Determine the frequency of a given substring in the initial string. Include overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count", "def count_distinct_characters(string):\n    distinct_characters = set(string)\n    return len(distinct_characters)", "def is_isogram(string: str) -> bool:\n    \"\"\"\n    Verify if a string is an isogram, considering case and non-alphanumeric characters\n    \"\"\"\n    if len(string) > 200:\n        raise ValueError(\"String length exceeds maximum limit of 200 characters.\")\n    return len(string) == len(set(string))", "def longest_palindromic_postfix(string: str) -> str:\n    \"\"\" \n    Find the longest palindrome present at the end of the supplied string, \n    while ignoring case and non-alphanumeric characters\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string)-1):\n            return string[i:]"]}
{"task_id": "HumanEval/17", "problem": ["def parse_music(music_string: str) -> List[int]:\n    notes_map = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    notes = music_string.split()\n    beats = [notes_map[note] for note in notes]\n    return beats", "def parse_music(music_string: str) -> List[int]:\n    notes = music_string.split(' ')\n    beat_duration = []\n    for note in notes:\n        if note == 'o':\n            beat_duration.append(4)\n        elif note == 'o|':\n            beat_duration.append(2)\n        elif note == '.|':\n            beat_duration.append(1)\n    return beat_duration", "def parse_music(music_string: str, tempo_multiplier: float = 1) -> Tuple[List[List[float]], int]:\n    beats = []\n    measure = []\n    total_beats = 0\n    measures_count = 0\n\n    # Split the given string into individual notes\n    notes = music_string.split()\n\n    # Traverse each note\n    for note in notes:\n        # get the note value and apply the tempo_multiplier\n        note_value = NOTE_VALUES[note] * tempo_multiplier\n\n        # If the new note makes total beats exceed 1, start a new measure\n        if total_beats + note_value > 1:\n            beats.append(measure)\n            measure = []\n            total_beats = 0\n            measures_count += 1\n\n        # add the note to the current measure and update total beats\n        measure.append(note_value)\n        total_beats += note_value\n\n    # Append remaining notes in the last measure\n    if measure:\n        beats.append(measure)\n        measures_count += 1\n\n    return beats, measures_count", "def parse_music(music_string: str, tempo_multiplier: float = 1) -> Tuple[List[List[float]], int]:\n    beats = []\n    measure = []\n    total_beats = 0\n    measures_count = 0\n    \n    # Split the given string into individual notes\n    notes = music_string.split()\n    \n    # Traverse each note\n    for note in notes:\n        # get the note value and apply the tempo_multiplier\n        note_value = NOTE_VALUES[note] * tempo_multiplier\n        \n        # If the new note makes total beats exceed 1, start a new measure\n        if total_beats + note_value > 1:\n            beats.append(measure)\n            measure = []\n            total_beats = 0\n            measures_count += 1\n            \n        # Add the note to the current measure and update total beats\n        measure.append(note_value)\n        total_beats += note_value\n    \n    # Append remaining notes in the last measure\n    if measure:\n        beats.append(measure)\n        measures_count += 1\n    \n    return beats, measures_count", "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    >>> advanced_custom_sort([1, 2, 3], 1, 2, 'asc', 1, 'square')\n    [4, 3, 1]\n    >>> advanced_custom_sort([5, 6, 3, 4, 8, 9, 2], 2, 5, 'desc', 2, 'cube')\n    [81, 4, 2, 5, 6, 720, 64]\n    >>> advanced_custom_sort([8, 7, 4, 1, 3, 2, 5], 1, 4, 'asc', 2, 'cube')\n    [4, 27, 3, 6, 5, 8, 1]\n    \"\"\"\n    \n    transform = {'square': lambda x: x*x,\n                 'cube': lambda x: x*x*x}\n\n    transformed = [transform[f](x) if n<=i<m else x for i,x in enumerate(l)]\n    sorted_l = sorted(transformed[n:m], reverse= s == 'desc') + transformed[m:]\n    return sorted_l[-r:] + sorted_l[:-r]"]}
{"task_id": "HumanEval/18", "problem": ["def how_many_times(string: str, substring: str) -> int:\n    \"\"\"Determine the frequency of a given substring in the initial string. Include overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Determine the frequency of a given substring in the initial string. Include overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"Calculate the frequency of a given substring in a source string, including overlapping instances.\"\"\"\n    count = start = 0\n    while True:\n        start = string.find(substring, start) + 1\n        if start > 0:\n            count += 1\n        else:\n            return count", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"Calculate the frequency of a given substring in a source string, including overlapping instances.\"\"\"\n    count = start = 0\n    while True:\n        start = string.find(substring, start) + 1\n        if start > 0:\n            count += 1\n        else:\n            return count", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"Identifying the incidence rate of a specified substring within the primary string. Includes overlapping instances.\"\"\"\n    return sum(1 for i in range(len(string)) if string.startswith(substring, i))"]}
{"task_id": "HumanEval/19", "problem": ["def get_decimal_sum(decimal_digit_words):\n    decimal_words = {'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'}\n    american_number_system = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n\n    decimal_number_sum = 0\n    for dec_word in decimal_digit_words:\n        if dec_word not in decimal_words:\n            return 0\n        else:\n            decimal_number_sum += american_number_system[dec_word]\n\n    return float(decimal_number_sum)", "def num_to_words(num):\n    # Your logic to convert number to words goes here\n    # For simplicity, let's assume this function\n    return ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'][int(num)]", "def num_to_words(n):\n    if n == 0:\n        return 'zero'\n    num_to_word = {\n        1: 'one',\n        2: 'two',\n        3: 'three',\n        4: 'four',\n        5: 'five',\n        6: 'six',\n        7: 'seven',\n        8: 'eight',\n        9: 'nine',\n        10: 'ten'\n    }\n    return num_to_word.get(n, '')", "def to_english(n):\n    num_to_english = {\n        0: 'Zero',\n        1: 'One',\n        2: 'Two',\n        3: 'Three',\n        4: 'Four',\n        5: 'Five',\n        6: 'Six',\n        7: 'Seven',\n        8: 'Eight',\n        9: 'Nine'\n    }\n    \n    if n in num_to_english:\n        return num_to_english[n]\n    else:\n        return ''", "def numberToWords(num: int) -> str:\n    ones = ['','one','two','three','four','five','six','seven','eight','nine']\n    tens = ['','ten','twenty','thirty','forty','fifty','sixty','seventy','eighty','ninety']\n    hundreds = ['','one hundred','two hundred','three hundred','four hundred','five hundred','six hundred','seven hundred',\n           'eight hundred','nine hundred']\n    thousand = ['','one thousand','two thousand','three thousand','four thousand','five thousand','six thousand','seven thousand',\n           'eight thousand','nine thousand']\n\n    if num == 0:\n        return \"zero\"\n\n    result = \"\"\n    if num // 1000 > 0:\n        result += thousand[num // 1000] + \" \"\n        num %= 1000\n    if num // 100 > 0:\n        result += hundreds[num // 100] + \" \"\n        num %= 100\n    if num >= 20:\n        result += tens[num // 10] + \" \"\n        num %= 10\n    if num > 0:\n        result += ones[num]\n\n    return result.strip()"]}
{"task_id": "HumanEval/20", "problem": ["def find_furthest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Extract two float numbers from the given array (at minimum contains two) that possess the maximum numerical difference. Remember to present them in ascending order (minor, major).\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (1.0, 5.0)\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (1.0, 5.0)\n    \"\"\"\n    return min(numbers), max(numbers)", "def rescale_vectors_to_unit(vectors: List[List[float]]) -> List[List[float]]:\n    \"\"\"\n    Accepting a compilation of N-dimensional vectors, an independent linear transform is applied to each dimension,\n    in such a way that the smallest measurement per dimension reduces to 0, and the uppermost rises to 1.\n\n    >>> rescale_vectors_to_unit([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0], [3.0, 4.0, 5.0]])\n    [[0.0, 0.0, 0.0], [0.5, 0.5, 0.5], [1.0, 1.0, 1.0]]\n    \"\"\"\n    dimension = len(vectors[0])\n    min_max = [[float('inf'), float('-inf')] for _ in range(dimension)]\n    \n    # Find the min and max value for each dimension\n    for vector in vectors:\n        for i in range(dimension):\n            if vector[i] < min_max[i][0]:\n                min_max[i][0] = vector[i]\n            if vector[i] > min_max[i][1]:\n                min_max[i][1] = vector[i]\n\n    # Rescale the vectors\n    for vector in vectors:\n        for i in range(dimension):\n            vector[i] = (vector[i] - min_max[i][0]) / (min_max[i][1] - min_max[i][0])\n    \n    return vectors", "def rescale_vectors_to_unit(vectors: List[List[float]]) -> List[List[float]]:\n    \"\"\"\n    Accepting a compilation of N-dimensional vectors, an independent linear transform is applied to each dimension,\n    in such a way that the smallest measurement per dimension reduces to 0, and the uppermost rises to 1.\n\n    Ex: rescale_vectors_to_unit([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0], [3.0, 4.0, 5.0]])\n    [[0.0, 0.0, 0.0], [0.5, 0.5, 0.5], [1.0, 1.0, 1.0]]\n    \"\"\"\n    dimension = len(vectors[0])\n    min_max = [[float('inf'), float('-inf')] for _ in range(dimension)]\n\n    # Find the min and max value for each dimension\n    for vector in vectors:\n        for i in range(dimension):\n            if vector[i] < min_max[i][0]:\n                min_max[i][0] = vector[i]\n            if vector[i] > min_max[i][1]:\n                min_max[i][1] = vector[i]\n\n    # Rescale the vectors\n    for vector in vectors:\n        for i in range(dimension):\n            vector[i] = (vector[i] - min_max[i][0]) / (min_max[i][1] - min_max[i][0])\n\n    return vectors", "def test_1():\n    start_x = 1.0  # [m]\n    start_y = 1.0  # [m]\n    start_yaw = 0.0  # [rad]\n    end_x = 5.0  # [m]\n    end_y = 3.0  # [m]\n    end_yaw = 1.57  # [rad]\n    px = [1.0, 2.0, 3.0, 4.0, 5.0]\n    py = [1.0, 1.5, 2.0, 2.5, 3.0]\n    pyaw = [0.0, 0.5, 1.0, 1.25, 1.57]\n    check_edge_condition(px, py, pyaw, start_x, start_y, start_yaw, end_x, end_y, end_yaw)", "def find_closest_elements(numbers: List[int]) -> Tuple[int, int, int]:\n    \"\"\"\n    In the given list of numbers, find and return the two closest numbers firstly the smaller number, \n    then the larger number and the frequency of the smallest difference.\n    For example:\n    find_closest_elements([1, 2, 3, 4, 5, 2])\n    Returns: (2, 2, 2)\n    find_closest_elements([1, 5, 2, 7, 6, 3])\n    Returns: (2, 3, 1)\n    \"\"\"    \n    numbers.sort()\n    pairs = [(numbers[i], numbers[i + 1]) for i in range(len(numbers) - 1)]\n    minimum = min(pair[1] - pair[0] for pair in pairs)\n    result = [pair for pair in pairs if pair[1] - pair[0] == minimum]\n    return result[0][0], result[0][1], len(result)"]}
{"task_id": "HumanEval/21", "problem": ["def find_furthest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Extract two float numbers from the given array (at minimum contains two) that possess the maximum numerical difference. Remember to present them in ascending order (minor, major).\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (1.0, 5.0)\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (1.0, 5.0)\n    \"\"\"\n    return min(numbers), max(numbers)", "def rescale_vectors_to_unit(vectors: List[List[float]]) -> List[List[float]]:\n    \"\"\"\n    Accepting a compilation of N-dimensional vectors, an independent linear transform is applied to each dimension,\n    in such a way that the smallest measurement per dimension reduces to 0, and the uppermost rises to 1.\n\n    >>> rescale_vectors_to_unit([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0], [3.0, 4.0, 5.0]])\n    [[0.0, 0.0, 0.0], [0.5, 0.5, 0.5], [1.0, 1.0, 1.0]]\n    \"\"\"\n    dimension = len(vectors[0])\n    min_max = [[float('inf'), float('-inf')] for _ in range(dimension)]\n    \n    # Find the min and max value for each dimension\n    for vector in vectors:\n        for i in range(dimension):\n            if vector[i] < min_max[i][0]:\n                min_max[i][0] = vector[i]\n            if vector[i] > min_max[i][1]:\n                min_max[i][1] = vector[i]\n\n    # Rescale the vectors\n    for vector in vectors:\n        for i in range(dimension):\n            vector[i] = (vector[i] - min_max[i][0]) / (min_max[i][1] - min_max[i][0])\n    \n    return vectors", "def rescale_vectors_to_unit(vectors: List[List[float]]) -> List[List[float]]:\n    \"\"\"\n    Accepting a compilation of N-dimensional vectors, an independent linear transform is applied to each dimension,\n    in such a way that the smallest measurement per dimension reduces to 0, and the uppermost rises to 1.\n\n    Ex: rescale_vectors_to_unit([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0], [3.0, 4.0, 5.0]])\n    [[0.0, 0.0, 0.0], [0.5, 0.5, 0.5], [1.0, 1.0, 1.0]]\n    \"\"\"\n    dimension = len(vectors[0])\n    min_max = [[float('inf'), float('-inf')] for _ in range(dimension)]\n\n    # Find the min and max value for each dimension\n    for vector in vectors:\n        for i in range(dimension):\n            if vector[i] < min_max[i][0]:\n                min_max[i][0] = vector[i]\n            if vector[i] > min_max[i][1]:\n                min_max[i][1] = vector[i]\n\n    # Rescale the vectors\n    for vector in vectors:\n        for i in range(dimension):\n            vector[i] = (vector[i] - min_max[i][0]) / (min_max[i][1] - min_max[i][0])\n\n    return vectors", "def find_closest_elements(numbers: List[float]) -> Tuple[float, float, float]:\n    \"\"\"\n    In a given list of numbers (with a minimum length of two), identify and return the\n    two elements with the smallest difference between them, with the lower value first,\n    then the higher value, plus the actual difference.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError('Invalid input! The input list must include at least two numbers.')\n    \n    numbers.sort()\n    \n    # Start with the first pair of values in the list.\n    smallest_diff = numbers[1] - numbers[0]\n    best_pair = (numbers[0], numbers[1], smallest_diff)\n    \n    for i in range(1, len(numbers) - 1):\n        # Compute the difference between the current pair of elements.\n        diff = numbers[i+1] - numbers[i]\n        # Track the pair with the smallest difference.\n        if diff < smallest_diff:\n            smallest_diff = diff\n            best_pair = (numbers[i], numbers[i+1], smallest_diff)\n    \n    return best_pair", "def test_1():\n    start_x = 1.0  # [m]\n    start_y = 1.0  # [m]\n    start_yaw = 0.0  # [rad]\n    end_x = 5.0  # [m]\n    end_y = 3.0  # [m]\n    end_yaw = 1.57  # [rad]\n    px = [1.0, 2.0, 3.0, 4.0, 5.0]\n    py = [1.0, 1.5, 2.0, 2.5, 3.0]\n    pyaw = [0.0, 0.5, 1.0, 1.25, 1.57]\n    check_edge_condition(px, py, pyaw, start_x, start_y, start_yaw, end_x, end_y, end_yaw)"]}
{"task_id": "HumanEval/22", "problem": ["def filter_by_prefix_and_suffix(strings: List[str], prefix_suffix: Tuple[str, str], min_length: int) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix, end with a given suffix, and have a minimum length.\n    \n    Example:\n    >>> filter_by_prefix_and_suffix([], ('a', 'z'), 3)\n    []\n    \n    >>> filter_by_prefix_and_suffix(['abc', 'bcd', 'cdez', 'arrayz'], ('a', 'z'), 5)\n    ['arrayz']\n    \n    >>> filter_by_prefix_and_suffix(['abc', 'azy'], ('a', 'z'), 3)\n    ['abc']\n    \"\"\"\n    pass", "def rolling_max(numbers1: List[int], numbers2: List[int]) -> Tuple[List[int], List[int]]:\n    \"\"\" From two given lists of integers, generate a list of rolling maximum element found until given moment \n    in the sequence and store them as maximum of each list.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2], [1, 4, 2, 4, 1, 5, 1])\n    ([1, 2, 3, 3, 3, 4, 4], [1, 4, 4, 4, 4, 5, 5])\n    \"\"\"\n    pass  # Your implementation here", "def diffList(numList: List[int], absolute_difference: bool = False) -> List[int]:\n    \"\"\" Return the difference of each pair of consecutive numbers from `numList'\n    >>> diffList([1, 2, 3])\n    [1, 1]\n    >>> diffList([2, 5, 9, 16])\n    [3, 4, 7]\n    >>> diffList([2, 5, 9, 16], absolute_difference=True)\n    [3, 4, 7]\n    \"\"\"\n    diff_list = []\n    \n    for i in range(1, len(numList)):\n        difference = numList[i] - numList[i-1]\n        \n        if absolute_difference:\n            difference = abs(difference)\n        \n        diff_list.append(difference)\n    \n    return diff_list", "def pattern_match(strings: List[str], pattern: Tuple[List[str], str, str]) -> Tuple[List[str], int, int]:\n    \"\"\" \n    - Filter an input list of strings only for ones that contain a given pattern,\n    - Strings should start with a given prefix, and end with a given suffix \n    - Calculate the Levenshtein distance between the pattern and string found in the list\n    - And count occurrence of the given prefix and suffix in all strings from the list\n\n    >>> pattern_match([], (['a', 'b', 'c'], 'a', 'z'))\n    ([], 0, 0)\n    >>> pattern_match(['abc', 'bcd', 'cdez', 'arrayz'], (['b', 'c', 'd'], 'a', 'z'))\n    (['arrayz'], 1, 2)\n    >>> pattern_match(['abc', 'azy'], (['b', 'c'], 'a', 'z'))\n    (['abc'], 1, 1)\n    \"\"\"\n\n    result, distance, prefix_count, suffix_count = [], 0, 0, 0\n    for string in strings:\n        if string.startswith(pattern[1]):\n            prefix_count += 1\n        if string.endswith(pattern[2]):\n            suffix_count += 1\n        if all(x in string for x in pattern[0]) and string.startswith(pattern[1]) and string.endswith(pattern[2]):\n            result.append(string)\n            distance += leven_dist(''.join(pattern[0]), string)\n    return result, distance, prefix_count, suffix_count", "def lowest_common_multiple(x: List[int], y: List[int]) -> List[int]:\n    \"\"\" Returns the LCM of each pair of positive integers x and y\n    >>> lowest_common_multiple([3, 5], [5, 15])\n    [15, 75]\n    \"\"\"\n    return [abs(a*b) // gcd(a, b) for a, b in zip(x, y)]"]}
{"task_id": "HumanEval/23", "problem": ["def double_up(str_list):\n  double_list = []\n  for string in str_list:\n    double_str = string + string\n    strlen = len(string)\n    char_at_index = double_str[strlen]\n    if char_at_index.islower():\n      char_at_index = char_at_index.upper()\n    double_list.append(double_str)\n    double_list.append(char_at_index)\n  return double_list", "def double_up(str_list):\n  double_list = []\n  for str in str_list:\n    double_str = str + str\n    strlen = len(str)\n    double_list.append(double_str[strlen - 1])\n  return double_list", "def double_up(input_str):\n  double_str = input_str + input_str\n  strlen = len(input_str)\n  return double_str[strlen - 1]", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"Determine the frequency of a given substring in the initial string. Include overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Determine the frequency of a given substring in the initial string. Include overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count"]}
{"task_id": "HumanEval/24", "problem": ["def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, yet, is smaller than n\n    >>> largest_divisor(-15)\n    5\n    \"\"\"\n    # convert the number to absolute\n    n = abs(n)\n    if n < 2:\n        return None\n    # Check for all divisors starting from half of the number\n    for i in range(n//2, 0, -1): \n        if n % i == 0:\n            return i", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, yet is smaller than n\n    >>> largest_divisor(-15)\n    5\n    \"\"\"\n    # convert the number to absolute\n    n = abs(n)\n    if n < 2:\n        return None\n    # check for all divisors starting from half of the number\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i", "def largest_divisors_of_list(numbers: List[int]) -> List[int]:\n    \"\"\" For a given list of integers, find the largest absolute divisors for each integer and return a new list with these values\n    >>> largest_divisors_of_list([15, -20, 25])\n    [5, 10, 5]\n    \"\"\"\n    # check for null list\n    if not numbers:\n        return None\n    largest_divisors = []\n    # for each number in the list, find the largest divisor and append to the output list\n    for num in numbers:\n        largest_divisors.append(largest_divisor(num))\n    return largest_divisors", "def largest_divisors_of_list(numbers: List[int]) -> List[int]:\n    \"\"\" For a given list of integers, find the largest absolute divisors for each integer and return a new list with these values\n    <<< largest_divisors_of_list([15, -20, 25])\n    [5, 10, 5]\n    \"\"\"\n    # check for null list\n    if not numbers:\n        return None\n    largest_divisors = []\n    # for each number in the list, find the largest divisor and append to the output list\n    for num in numbers:\n        largest_divisors.append(largest_divisor(num))\n    return largest_divisors", "def largest_divisor(n: int) -> int:\n    \"\"\""]}
{"task_id": "HumanEval/25", "problem": ["def factorize(n: int) -> Tuple[List[int], Dict[int, int], Dict[int, bool]]:\n    \"\"\"\n    Returns a prime factor list and a dictionary displaying the frequency of each factor in the decomposition process. \n    Perform primality testing on each factor.\n\n    Factors should be listed according to their frequency of appearance in the decomposition process.\n    The entered number (2 \u2264 n \u2264 10^6) should be the product of all factors.\n\n    factorize(8)\n    ([2, 2, 2], {2: 3}, {2: True})\n    \n    factorize(25)\n    ([5, 5], {5: 2}, {5: True})\n    \n    factorize(70)\n    ([2, 5, 7], {2: 1, 5: 1, 7: 1}, {2: True, 5: True, 7: True})\n    \"\"\"\n    factors = []\n    freq = {}\n    primes = {}\n    \n    # Prime factorization\n    while n % 2 == 0:\n        factors.append(2)\n        n = n / 2\n    for i in range(3,int(math.sqrt(n))+1,2):\n        while n % i== 0:\n            factors.append(int(i))\n            n = n / i \n    if n > 2:\n        factors.append(int(n))\n\n    # Count the frequency of each factor\n    for factor in factors:\n        if factor not in freq:\n            freq[factor] = 1\n        else:\n            freq[factor] += 1\n\n    # Perform primality check on each factor\n    for factor in freq.keys():\n        primes[factor] = is_prime(factor)\n\n    return (factors, freq, primes)", "def factorize(n: int) -> Tuple[List[int], Dict[int, int], Dict[int, bool]]:\n    \"\"\"\n    Returns a prime factor list and a dictionary displaying the frequency of each factor in the decomposition process,\n    Perform primality testing on each factor.\n\n    Factors should be listed according to their frequency of appearance in the decomposition process.\n    The entered number (2 \u2264 n \u2264 10^6) should be the product of all factors.\n\n    factorize(8)\n    ([2, 2, 2], {2: 3}, {2: True})\n\n    factorize(25)\n    ([5, 5], {5: 2}, {5: True})\n\n    factorize(70)\n    ([2, 5, 7], {2: 1, 5: 1, 7: 1}, {2: True, 5: True, 7: True})\n    \"\"\"\n    \n    factors = []\n    freq = {}\n    primes = {}\n\n    # Prime factorization\n    while n % 2 == 0:\n        factors.append(2)\n        n = n / 2\n    \n    for i in range(3, int(math.sqrt(n))+1, 2):\n        while n % i == 0:\n            factors.append(int(i))\n            n = n / i\n    if n > 2:\n        factors.append(int(n))\n\n    # count the frequency of each factor\n    for factor in factors:\n        if factor not in freq:\n            freq[factor] = 1\n        else:\n            freq[factor] += 1\n\n    # perform primality check on each factor\n    for factor in freq.keys():\n        primes[factor] = is_prime(factor)\n\n    return [factors, freq, primes]", "def sum_of_even_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers: A list of integers.\n\n    Returns:\n    The sum of all even numbers in the list.\n    \n    Examples:\n    >>> sum_of_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    30\n    >>> sum_of_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_of_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)", "def prime_digit_product(x):\n    \"\"\"Given a list of positive integers x, return a sorted list of all \n    _distinct_ elements wherein the product of its digits is a prime number.\n\n    Note: The resulting list should be sorted in ascending order. \n\n    >>> prime_digit_product([15, 33, 1422, 1, 15])\n    [1, 15]\n    >>> prime_digit_product([152, 323, 1422, 10])\n    [323]\n\n    \"\"\"\n    return sorted(set([i for i in x if is_prime(prod([int(d) for d in str(i)]))]))", "def sum_even_numbers(numbers):\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The sum of all even numbers in the list.\n\n    Examples:\n    >>> sum_even_numbers([1, 2, 3, 4, 5, 6])\n    12\n    >>> sum_even_numbers([10, 11, 12, 13, 14, 15])\n    36\n    >>> sum_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)"]}
{"task_id": "HumanEval/26", "problem": ["def remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"Remove duplicates while maintaining order.\n    Given a list of integers, remove any number that occurs more than once,\n    while keeping the order of the remaining numbers the same as the original list.\n    Determine the number of times each number occurs, and remove the numbers that occur more than once.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count_map = {}\n    result = []\n    for num in numbers:\n        if num not in count_map:\n            count_map[num] = 1\n            result.append(num)\n        else:\n            count_map[num] += 1\n            if count_map[num] > 1 and num in result:\n                result.remove(num)\n    return result", "def remove_duplicates(numbers: List[int], threshold: int) -> Tuple[List[int], List[int]]:\n    \"\"\"From a list of integers, remove duplicate elements, elements that occur more than a specified number of times, prime numbers, and negative integers.\n    Keep order of elements the same as in the input.\n    Return two lists, one with the remaining elements and one with the removed elements, both in the original order.\"\"\"\n    counts = Counter(numbers)\n    removed = []\n    left = []\n    for num in numbers:\n        if counts[num] > threshold or is_prime(num) or num < 0:\n            if num not in removed:\n                removed.append(num)\n        else:\n            left.append(num)\n            counts[num] = threshold + 1\n    return left, removed", "def common_elements(list1: List[int], list2: List[int]) -> List[int]:\n    \"\"\" From two lists of integers, find all elements that occur in both lists.\n    Keep order of elements the same as in the first list.\n    >>> common_elements([1, 2, 3, 4], [2, 4, 6, 7])\n    [2, 4]\n    \"\"\"\n    set2 = set(list2) # convert list2 to set for faster lookup\n    return [value for value in list1 if value in set2] # use list comprehension to find common elements", "def remove_duplicates(numbers: List[int], threshold: int) -> List[int]:\n    \"\"\" From a list of integers, remove duplicate elements, elements that occur more \n    than a specified number of times and prime numbers.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    frequency = Counter(numbers)\n    non_duplicates = [number for number in numbers if frequency[number] <= threshold and not is_prime(number)]\n    return non_duplicates", "def remove_duplicates(numbers: List[int], threshold: int) -> Tuple[List[int], List[int]]:\n    \"\"\" From a list of integers, remove duplicate elements, elements that occur more than a specified number of times, prime numbers, and negative integers.\n    Keep order of elements left the same as in the input.\n    Return two lists, one with the remaining elements and one with the removed elements, both in the original order. \"\"\"\n    counts = Counter(numbers)\n    removed = []\n    left = []\n    for num in numbers:\n        if counts[num] > threshold or is_prime(num) or num < 0:\n            if num not in removed:\n                removed.append(num)\n        else:\n            left.append(num)\n            counts[num] = threshold + 1\n    return left, removed"]}
{"task_id": "HumanEval/27", "problem": ["def invert_case_special(string: str) -> str:\n    \"\"\"\n    For a given string, reverse the string, flip lowercase characters to uppercase and uppercase characters to lowercase,\n    make numbers even by subtracting one from odd numbers, quadruple special characters, \n    and count the occurrences of each modified character.\n\n    >>> invert_case_special('H\u20acll0!')\n    '!00ll3h': {'!': 2, '0': 1, 'l': 2, '3': 1, 'h': 1}\n    \"\"\"\n    rev_str = string[::-1]\n    transformed_str = \"\"\n    char_count = {}\n\n    for char in rev_str:\n        if char.isalpha():\n            # Swap case\n            new_char = char.swapcase()\n        elif char.isdigit():\n            # Make numbers even\n            num = int(char)\n            new_char = str(num - 1 if num % 2 != 0 else num)\n        else:\n            # Quadruple special characters\n            new_char = char * 4\n\n        transformed_str += new_char\n\n        # Count occurrence of each character\n        if new_char not in char_count:\n            char_count[new_char] = 0\n        char_count[new_char] += 1\n\n    return transformed_str, char_count", "def lowercase(string):\n    \"\"\"\n    Converts a string from all uppercase to all lowercase.\n    Parameters:\n        str string: The string to convert.\n    Returns:\n        str: The converted string.\n    \"\"\"\n    return string.lower()", "def generate_random_string(length: int) -> str:\n    \"\"\"\n    Generate a random string of specified length consisting of uppercase letters, lowercase letters, and digits.\n    \"\"\"\n    characters = string.ascii_letters + string.digits\n    return ''.join(random.choice(characters) for _ in range(length))", "def flip_case_and_modify(string: str) -> str:\n    \"\"\" For an inputted sequence of characters, invert lowercase to uppercase and vice versa, substitute odd numerals with its succeeding even numeral, and duplicate any peculiar symbols. \n    >>> flip_case_and_modify('Hello4!')\n    'hELLO6!!'\n    \"\"\"\n\n    modified_string = ''\n    for char in string:\n        if char.isalpha():\n            modified_string += char.swapcase()\n        elif char.isdigit():\n            if int(char) % 2 != 0:\n                modified_string += str(int(char) + 1)\n            else:\n                modified_string += char\n        else:\n            modified_string += char * 2\n\n    return modified_string", "def countLetters(s): \n   uppercase, lowercase = 0, 0\n   for x in s: \n      if x.islower(): \n         lowercase += 1\n      elif x.isupper(): \n         uppercase += 1\n   print(\"No. of Upper case characters:\", uppercase) \n   print(\"No. of Lower case Characters:\", lowercase) "]}
{"task_id": "HumanEval/28", "problem": ["def custom_string_manipulation(strings: List[str]) -> str:\n    \"\"\"Combine a list of strings into a single string using a complicated method of intertwining and reversing the characters.\n    >>> custom_string_manipulation([])\n    ''\n    >>> custom_string_manipulation(['a', 'b', 'c'])\n    'cba'\n    >>> custom_string_manipulation(['ab', 'cd', 'ef'])\n    'fedcba'\n    \"\"\"\n    # Join all the characters in the input list of strings into one string.\n    all_chars = ''.join(strings)\n    # Use slicing to reverse the combined string.\n    return all_chars[::-1]", "def filter_by_prefix_and_suffix(strings: List[str], prefix_suffix: Tuple[str, str]) -> List[str]:\n    \"\"\" Meticulously filter an input collection of strings for sole instances that inaugurate with a specified prefix and terminate with a distinctive suffix.\n    >>> filter_by_prefix_and_suffix([], ('a', 'z'))\n    []\n    >>> filter_by_prefix_and_suffix(['abc', 'bcd', 'cdez', 'arrayz'], ('a', 'z'))\n    ['arrayz']\n    >>> filter_by_prefix_and_suffix(['abc', 'azy'], ('a', 'z'))\n    ['azy', 'abc']\n    \"\"\"\n    pass", "def filter_by_prefix_and_suffix(strings: List[str], prefix_suffix: Tuple[str, str], min_length: int) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix, end with a given suffix, and have a minimum length.\n    \n    Example:\n    >>> filter_by_prefix_and_suffix([], ('a', 'z'), 3)\n    []\n    \n    >>> filter_by_prefix_and_suffix(['abc', 'bcd', 'cdez', 'arrayz'], ('a', 'z'), 5)\n    ['arrayz']\n    \n    >>> filter_by_prefix_and_suffix(['abc', 'azy'], ('a', 'z'), 3)\n    ['abc']\n    \"\"\"\n    pass", "def pattern_match(strings: List[str], pattern: Tuple[List[str], str, str]) -> Tuple[List[str], int, int]:\n    \"\"\" \n    - Filter an input list of strings only for ones that contain a given pattern,\n    - Strings should start with a given prefix, and end with a given suffix \n    - Calculate the Levenshtein distance between the pattern and string found in the list\n    - And count occurrence of the given prefix and suffix in all strings from the list\n\n    >>> pattern_match([], (['a', 'b', 'c'], 'a', 'z'))\n    ([], 0, 0)\n    >>> pattern_match(['abc', 'bcd', 'cdez', 'arrayz'], (['b', 'c', 'd'], 'a', 'z'))\n    (['arrayz'], 1, 2)\n    >>> pattern_match(['abc', 'azy'], (['b', 'c'], 'a', 'z'))\n    (['abc'], 1, 1)\n    \"\"\"\n\n    result, distance, prefix_count, suffix_count = [], 0, 0, 0\n    for string in strings:\n        if string.startswith(pattern[1]):\n            prefix_count += 1\n        if string.endswith(pattern[2]):\n            suffix_count += 1\n        if all(x in string for x in pattern[0]) and string.startswith(pattern[1]) and string.endswith(pattern[2]):\n            result.append(string)\n            distance += leven_dist(''.join(pattern[0]), string)\n    return result, distance, prefix_count, suffix_count", "def write_to_csv(strings: List[str]) -> None:\n    # Concatenate all the strings into a single string separated by commas\n    csv_content = ','.join(strings)\n    \n    # Write the resulting string to a CSV file\n    with open('outcsv.csv', 'w') as outfile:\n        outfile.write(csv_content)"]}
{"task_id": "HumanEval/29", "problem": ["def filter_by_prefix_and_suffix(strings: List[str], prefix_suffix: Tuple[str, str], min_length: int) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix, end with a given suffix, and have a minimum length.\n    \n    Example:\n    >>> filter_by_prefix_and_suffix([], ('a', 'z'), 3)\n    []\n    \n    >>> filter_by_prefix_and_suffix(['abc', 'bcd', 'cdez', 'arrayz'], ('a', 'z'), 5)\n    ['arrayz']\n    \n    >>> filter_by_prefix_and_suffix(['abc', 'azy'], ('a', 'z'), 3)\n    ['abc']\n    \"\"\"\n    pass", "def filter_by_prefix_and_suffix(strings: List[str], prefix_suffix: Tuple[str, str]) -> List[str]:\n    \"\"\" Meticulously filter an input collection of strings for sole instances that inaugurate with a specified prefix and terminate with a distinctive suffix.\n    >>> filter_by_prefix_and_suffix([], ('a', 'z'))\n    []\n    >>> filter_by_prefix_and_suffix(['abc', 'bcd', 'cdez', 'arrayz'], ('a', 'z'))\n    ['arrayz']\n    >>> filter_by_prefix_and_suffix(['abc', 'azy'], ('a', 'z'))\n    ['azy', 'abc']\n    \"\"\"\n    pass", "def pattern_match(strings: List[str], pattern: Tuple[List[str], str, str]) -> Tuple[List[str], int, int]:\n    \"\"\" \n    - Filter an input list of strings only for ones that contain a given pattern,\n    - Strings should start with a given prefix, and end with a given suffix \n    - Calculate the Levenshtein distance between the pattern and string found in the list\n    - And count occurrence of the given prefix and suffix in all strings from the list\n\n    >>> pattern_match([], (['a', 'b', 'c'], 'a', 'z'))\n    ([], 0, 0)\n    >>> pattern_match(['abc', 'bcd', 'cdez', 'arrayz'], (['b', 'c', 'd'], 'a', 'z'))\n    (['arrayz'], 1, 2)\n    >>> pattern_match(['abc', 'azy'], (['b', 'c'], 'a', 'z'))\n    (['abc'], 1, 1)\n    \"\"\"\n\n    result, distance, prefix_count, suffix_count = [], 0, 0, 0\n    for string in strings:\n        if string.startswith(pattern[1]):\n            prefix_count += 1\n        if string.endswith(pattern[2]):\n            suffix_count += 1\n        if all(x in string for x in pattern[0]) and string.startswith(pattern[1]) and string.endswith(pattern[2]):\n            result.append(string)\n            distance += leven_dist(''.join(pattern[0]), string)\n    return result, distance, prefix_count, suffix_count", "def all_prefixes_with_lengths(string: str) -> List[Tuple[str, int]]:\n    \"\"\" \n    Function that returns a list of tuples which include all prefixes of an input string from smallest to largest and their corresponding lengths\n    E.g. all_prefixes_with_lengths('abc') should return [('a', 1), ('ab', 2), ('abc', 3)]\n    \"\"\"\n    return [(string[:i], i) for i in range(1, len(string)+1)]", "def shortest(strings: List[str]) -> Optional[str]:\n    \"\"\"From a list of strings, return the shortest string. If multiple strings have the same length, return the first one with the least consonants. For an empty list, return None.\n    >>> shortest([])\n    None\n    >>> shortest(['a', 'b', 'c'])\n    'a'\n    >>> shortest(['a', 'ab', 'cc'])\n    'a'\n    >>> shortest(['a', 'bc', 'bbc'])\n    'a'\n    >>> shortest(['a', 'ba', 'bb'])\n    'a'\n    \"\"\"\n    if not strings:\n        return None\n\n    # create a list of tuples, each containing a string and its length and no of consonants\n    strings = [(s, len(s), count_consonants(s)) for s in strings]\n\n    # sort by length and no of consonants\n    strings.sort(key=lambda x: [x[1], x[2]])\n\n    return strings[0][0]"]}
{"task_id": "HumanEval/30", "problem": ["def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n\n    result = []\n    for num in l:\n        if num > 0:\n          result.append(num)\n    return result", "def get_positive_and_sort(l: list):\n    \"\"\"Return only positive numbers in the list, sorted in ascending order.\n    >>> get_positive_and_sort([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive_and_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n\n    return sorted([num for num in l if num > 0])", "def get_positive_and_sort(n: list):\n    \"\"\"\n    Discard only the positive numbers in the list and arrange them in incremental order.\n    >>> get_positive_and_sort([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive_and_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n\n    positive_nums = [num for num in n if num > 0]  # Filter out positive numbers.\n    return sorted(positive_nums)  # Sort the positive numbers.", "def get_positive_and_sort(input_list):\n    \"\"\"\n    Return only positive numbers in the_list, sorted in ascending order.\n    >>> get_positive_and_sort([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive_and_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n\n    # Filter the positive numbers\n    l = [num for num in input_list if num > 0]\n\n    # Implement a bubble sorting algorithm\n    for i in range(len(l)):\n        for j in range(len(l) - i - 1):\n            if l[j] > l[j+1]:\n                # Swap elements\n                l[j], l[j+1] = l[j+1], l[j]\n    \n    return l", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))"]}
{"task_id": "HumanEval/31", "problem": ["def is_prime(n):\n    \"\"\"Returns true for prime integers, false for non-prime integers.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, math.isqrt(n)+1): \n        if n % i == 0:\n            return False\n    return True", "def is_prime(n):\n    \"\"\"Returns true for prime integers, false for non-prime integers.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n\n    if n == 2:\n        return True\n\n    if n % 2 == 0:\n        return False\n\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n\n    return True", "def is_prime(n):\n    \"\"\"Returns true for prime numbers, false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(0)\n    False\n    >>> is_prime(-101)\n    False\n    >>> is_prime(2.5)\n    False\n    \"\"\"\n    if isinstance(n, (float, complex)) or n < 2: #negatives & floats are not primes\n        return False\n    for i in range(2, math.isqrt(n) + 1): #only check up to square root of n\n        if n % i == 0:\n            return False\n    return True", "def is_prime(n):\n    \"\"\"Manifests as true for integers that are prime, reveals false for those that aren't.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    \n    if n in (2, 3):\n        return True\n    if n == 1 or n % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "def is_prime(n):\n    \"\"\"Returns true for prime integers, false for non-prime integers.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Check if the number is 2 (2 is the only even prime number)\n    if n == 2: \n      return True\n    # Check for less than 2 and even numbers\n    elif n < 2 or n % 2 == 0: \n      return False\n    # Check for divisibility by any other number up to sqrt(n)\n    for current in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % current == 0:\n            return False\n    return True"]}
{"task_id": "HumanEval/32", "problem": ["def derivative_and_integral(xs: list, C: int):\n    \"\"\" \n    xs denotes the coefficients of a given polynomial. xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Function should output the derivative and integral of this polynomial in an identical format, incorporating C.\n    It should also return an error if the polynomial or constant C is invalid.\n    \"\"\"\n    \n    # Check if the polynomial is an empty list\n    if len(xs) == 0:\n        return \"Invalid polynomial\"\n    \n    # Check if the coefficients of the polynomial are integers\n    for coeff in xs:\n        if not isinstance(coeff, int):\n            return \"Invalid polynomial\"\n            \n    # Check if constant C is an integer\n    if not isinstance(C, int):\n        return \"Invalid constant\"\n        \n    # Calculate the derivative of the polynomial\n    derivative = [i*x for i, x in enumerate(xs)][1:]\n    \n    # Calculate the integral of the polynomial\n    integral = [C] + [x/(i+1) for i, x in enumerate(xs)]\n    \n    return derivative, integral", "def compute_derivative_integral(xs: list, C: int):\n    \"\"\"\n    Assumptions broken: (xs = coefficients of a polynomial in order: xs[0] + xs[1] * x + xs[2] * x^2 + ....)\n    Compute both the derivative and integral of the given polynomial, incorporate constant C and remove any surplus zeros. Ensure correctness with edge cases.\n    \"\"\"\n    if not xs:\n        return [], [C]\n    \n    derivative = []\n    integral = [C]\n\n    for i in range(len(xs)):\n        if i > 0:  derivative.append(i * xs[i])\n        if i > 0:  integral.append(xs[i-1] /(i))\n        \n    integral.append(xs[-1] / len(xs))\n\n    while derivative and derivative[-1] == 0:\n        derivative.pop()\n        \n    while len(integral) > 1 and integral[-1] == 0:  # retain the constant term even if it's zero.\n        integral.pop()\n\n    return derivative, integral", "def derivative_and_integral(xs: list, C: int):\n    \"\"\"\n    Violations: (xs = coefficients of a polynomial.     xs[0] + xs[1] * x + xs[2] * x^2 + ....)\n    Return derivative and integral of this polynomial, include constant C and remove any trailing zeros. Ensure this works for edge cases.\n    >>> derivative_and_integral([3, 1, 2, 4, 5], 2)\n    ([1, 4, 12, 20], [2, 3, 0.5, 0.6666666666666666, 1, 1])\n    >>> derivative_and_integral([1, 2, 3], 4)\n    ([2, 6], [4, 1, 1, 1])\n    \"\"\"\n\n    derivative = []\n    integral = [C]\n\n    for i in range(len(xs)):\n        if i != 0:\n            derivative.append(i * xs[i])\n            integral.append(xs[i-1] / i)\n        else:\n            # The derivative of a constant is 0\n            derivative.append(0)\n    integral.append(xs[-1] / len(xs))         \n    # All the trailing zeros are removed from the derivative.    \n    while derivative and derivative[-1] == 0:\n        derivative.pop()\n\n    return derivative, integral", "def derivative_and_integral(xs, C):\n    \"\"\"\n    Given xs: coefficients of a polynomial: xs[0] + xs[1] * x + xs[2] * x^2 t....\n    Return derivative and integral of this polynomial, including constant C and remove any trailing zeros.\n    Ensure this works for edge cases.\n\n    >>> derivative_and_integral([3, 1, 2, 4, 5], 2)\n    ([1, 4, 12, 20], [2, 3, 0.5, 0.6666666666666666, 1])\n    >>> derivative_and_integral([1, 2, 3], 4)\n    ([2, 6], [4, 1, 1, 1])\n    \"\"\"\n\n    derivative = []\n    integral = [C]\n    \n    for i in range(len(xs)):\n        if i != 0:\n            derivative.append(i * xs[i])\n            integral.append(xs[i-1] / i)\n        else:\n            # The derivative of a constant is 0\n            derivative.append(0)\n            integral.append(xs[0])\n\n    # All the trailing zeros are removed from the derivative.\n    while derivative and derivative[-1] == 0:\n        derivative.pop()\n\n    return derivative, integral", "def derivative_and_integral(xs: list, C: int):\n    \"\"\"\n    xs = coefficients of a polynomial (xs[0] + xs[1] * x + xs[2] * x^2 + ....)\n    This function returns the derivative and integral of the given polynomial, includes the constant C, and removes trailing zeros.\n\n    >>> derivative_and_integral([3, 1, 2, 4, 5], 2)\n    ([1, 4, 12, 20], [2.0, 3.0, 0.5, 0.5, 0.8, 1.0])\n    >>> derivative_and_integral([1, 2, 3], 4)\n    ([2, 6], [4.0, 1.0, 1.0, 1.0])\n    \"\"\"\n    derivative = []\n    integral = [C]\n\n    for i in range(len(xs)):\n        if i != 0:\n            derivative.append(i * xs[i])\n        if i+1 != 0:\n            integral.append(xs[i] / (i+1))\n\n    # Remove trailing zeros\n    while integral[-1] == 0:\n        integral = integral[:-1] \n    while derivative and derivative[-1] == 0:\n        derivative = derivative[:-1]\n  \n    return derivative, integral"]}
{"task_id": "HumanEval/33", "problem": ["def advanced_sort(l: list, n: int):\n    \"\"\"\n    This function accepts a list l, an integer n and returns a new resultant list l' that satisfies the next conditions:\n    l' equates l at indices not divisible by n; however at indices divisible by n, values parallel l's corresponding indices, but with the uniqueness of being multiplied by 2 and arranged in reverse.\n\n    >>> advanced_sort([1, 2, 3], 2)\n    [1, 2, 3]\n    >>> advanced_sort([5, 6, 3, 4, 8, 9, 2], 3)\n    [5, 6, 3, 2, 8, 9, 1]\n    >>> advanced_sort([8, 7, 4, 1, 3, 6, 5], 3)\n    [8, 7, 4, 5, 3, 6, 1]\n    \"\"\"\n\n    sublist = [val * 2 for i, val in enumerate(l) if i % n == 0]\n    sublist.sort(reverse=True)\n\n    new_list = l.copy()\n    index = 0\n    for i, val in enumerate(new_list):\n        if i % n == 0:\n            new_list[i] = sublist[index]\n            index += 1\n\n    return new_list", "def sort_special(l: list):\n    \"\"\"\n    This function takes in a list l and returns a modified list l' that follows these conditions:\n    l' aligns with l at indexes not exactly divided by five; however, for indexes fully divisible by five, the values equal relative positions in list l,\n    but in a reverse order, while middle elements should also be sorted in ascending order.\n    In addition, the 3rd element of every triple (i.e., the element at index 2 and every 3rd spot thereafter) needs to be multiplied by \n    the index it is in. If after multiplication, the value of the element is greater than the last element,\n    the value of the element becomes the average of the entire list (integer division).\n\n    >>> sort_special([1, 2, 3])\n    [1, 2, 6]\n    >>> sort_special([5, 6, 3, 4, 8, 9, 2])\n    [5, 6, 9, 2, 4, 27, 1]\n    >>> sort_special([8, 7, 4, 1, 3, 6, 5])\n    [8, 7, 12, 1, 15, 5, 6]\n    \"\"\"\n    return l", "def sort_and_transform_even_indices(l: list) -> list:\n    \"\"\"\n    This function accepts a list l and generates a new list l'. This new list preserves the odd indices from l. At the even indices,\n    it creates a list from the corresponding positions in l, sorts it in ascending order, and transforms the sorted data using the square function before placing \n    them in the new list.\n\n    >>> sort_and_transform_even_indices([1, 2, 3])\n    [1, 2, 9]\n    >>> sort_and_transform_even_indices([5, 6, 3, 4, 8, 9, 2])\n    [4, 6, 9, 4, 25, 9, 64]\n    >>> sort_and_transform_even_indices([8, 7, 4, 1, 3, 6, 5])\n    [1, 7, 9, 1, 16, 6, 64]\n    \"\"\"\n\n    even_indices_list = sorted([l[i] for i in range(0, len(l), 2)])\n    return [square(even_indices_list.pop(0)) if i % 2 == 0 else l[i] for i in range(len(l))]", "def sort_and_transform_even_indices(l: list) -> list:\n    \"\"\"\n    This function accepts a list l and generates a new list l'. This new list preserves the odd indices from l. At the even indices,\n    it creates a list from the corresponding positions in l, sorts it in ascending order, and transforms the sorted data using the square function before placing \n    them in the new list.\n\n    >>> sort_and_transform_even_indices([1, 2, 3])\n    [1, 2, 9]\n    >>> sort_and_transform_even_indices([5, 6, 3, 4, 8, 9, 2])\n    [4, 6, 9, 4, 25, 9, 64]\n    >>> sort_and_transform_even_indices([8, 7, 4, 1, 3, 6, 5])\n    [1, 7, 9, 1, 16, 6, 64]\n    \"\"\"\n\n    even_indices_list = sorted([l[i] for i in range(0, len(l), 2)])\n    return [square(even_indices_list.pop(0)) if i % 2 == 0 else l[i] for i in range(len(l))]", "def sort_and_transform_even_indices(l: list) -> list:\n    \"\"\"\n    This function accepts a list l and generates a new list l'. This new list preserves the odd indices from l. \n    At the even indices, it creates a list from the corresponding positions in l, \n    sorts it in ascending order, and transforms the sorted data using the square function before placing \n    them in the new list.\n\n    >>> sort_and_transform_even_indices([1, 2, 3])\n    [1, 2, 9]\n    >>> sort_and_transform_even_indices([5, 6, 3, 4, 8, 9, 2])\n    [4, 6, 9, 4, 25, 9, 64]\n    >>> sort_and_transform_even_indices([8, 7, 4, 1, 3, 6, 5])\n    [1, 7, 9, 1, 16, 6, 64]\n    \"\"\"\n    even_indices_list = sorted([l[i] for i in range(0, len(l), 2)])\n    return [square(even_indices_list.pop(0)) if i % 2 == 0 else l[i] for i in range(len(l))]"]}
{"task_id": "HumanEval/34", "problem": ["def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # convert the list to a set to remove duplicates, then convert it back to a list\n    l = list(set(l))\n\n    # sort the list in increasing order\n    l.sort()\n\n    return l", "def unique_count(l: list):\n    \"\"\"Return sorted unique elements in a list and their count\n\n    >>> unique_count([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [(0, 1), (2, 1), (3, 3), (5, 2), (9, 1), (123, 1)] \n    \"\"\" \n    l_counter = Counter(l)\n    result = sorted(l_counter.items())\n    return result", "def get_positive_and_sort(l: list):\n    \"\"\"Return only positive numbers in the list, sorted in ascending order.\n    >>> get_positive_and_sort([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive_and_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n\n    return sorted([num for num in l if num > 0])", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n\n    result = []\n    for num in l:\n        if num > 0:\n          result.append(num)\n    return result"]}
{"task_id": "HumanEval/35", "problem": ["def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n\n    result = []\n    for num in l:\n        if num > 0:\n          result.append(num)\n    return result", "def get_positive_and_sort(l: list):\n    \"\"\"Return only positive numbers in the list, sorted in ascending order.\n    >>> get_positive_and_sort([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive_and_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n\n    return sorted([num for num in l if num > 0])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "def get_positive_and_sort(n: list):\n    \"\"\"\n    Discard only the positive numbers in the list and arrange them in incremental order.\n    >>> get_positive_and_sort([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive_and_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n\n    positive_nums = [num for num in n if num > 0]  # Filter out positive numbers.\n    return sorted(positive_nums)  # Sort the positive numbers.", "def sorted_absolute_values(numbers: list):\n    \"\"\"Return sorted list of absolute values\n    >>> sorted_absolute_values([-5, 3, -2, 2, 3, -3, 9, 0, -123])\n    [0, 2, 2, 3, 3, 3, 5, 9, 123]\n    \"\"\"\n    abs_numbers = [abs(num) for num in numbers]\n    abs_numbers.sort()\n    return abs_numbers"]}
{"task_id": "HumanEval/36", "problem": ["def fib(n):\n    a, b = 0, 1\n    for _ in range(n):\n        fizz_buzz = \"\"\n        if a % 2 == 0:\n            fizz_buzz += \"Fizz\"\n        if a % 5 == 0:\n            fizz_buzz += \"Buzz\"\n\n        if fizz_buzz == \"\":\n            print(a)\n        else:\n            print(fizz_buzz)\n        \n        a, b = b, a + b", "def is_prime(n):\n    \"\"\"Returns true for prime integers, false for non-prime integers.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Check if the number is 2 (2 is the only even prime number)\n    if n == 2: \n      return True\n    # Check for less than 2 and even numbers\n    elif n < 2 or n % 2 == 0: \n      return False\n    # Check for divisibility by any other number up to sqrt(n)\n    for current in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % current == 0:\n            return False\n    return True", "def is_prime(n):\n    \"\"\"Returns true for prime integers, false for non-prime integers.\n    \n    >>> is_prime(-3)\n    False\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Check if the input is of the correct type (integer)\n    if type(n) != int:\n        return False\n\n    # Check for negative numbers and numbers less than or equal to 1\n    if n <= 1:\n        return False\n\n    # Check if n is divisible by any number up to the square root of n\n    for i in range(2, int(n**0.5)+1):\n        if (n % i) == 0:\n            return False\n\n    # If no factors found, then n is prime\n    return True", "def sum_of_squares(arr):\n    \"\"\"Calculate square sum of numbers divisible by 3 or 7.\n    \n    This function takes a list of integers and strings, converting \n    strings to integers where possible, and returns the sum of the squares \n    of all positive elements divisible by either 3 or 7. Non-convertible \n    strings and negative numbers are ignored.\n\n    Args:\n        arr (list): A list containing integers and strings.\n\n    Returns:\n        int: The sum of squares of all positive elements divisible by 3 or 7.\n\n    Examples:\n        >>> sum_of_squares([])\n        0\n        >>> sum_of_squares(['3', 7, -1, '11', 'not-an-int'])\n        58\n        >>> sum_of_squares([4, '9', 7, '3'])\n        130\n    \"\"\"\n    return sum(int(i)**2 for i in arr if str(i).isdigit() and int(i) > 0 and (int(i) % 3 == 0 or int(i) % 7 == 0))", "def is_prime(n):\n    \"\"\"Manifests as true for integers that are prime, reveals false for those that aren't.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    \n    if n in (2, 3):\n        return True\n    if n == 1 or n % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True"]}
{"task_id": "HumanEval/37", "problem": ["def sort_special(l: list):\n    \"\"\"\n    This function takes in a list l and returns a modified list l' that follows these conditions:\n    l' aligns with l at indexes not exactly divided by five; however, for indexes fully divisible by five, the values equal relative positions in list l,\n    but in a reverse order, while middle elements should also be sorted in ascending order.\n    In addition, the 3rd element of every triple (i.e., the element at index 2 and every 3rd spot thereafter) needs to be multiplied by \n    the index it is in. If after multiplication, the value of the element is greater than the last element,\n    the value of the element becomes the average of the entire list (integer division).\n\n    >>> sort_special([1, 2, 3])\n    [1, 2, 6]\n    >>> sort_special([5, 6, 3, 4, 8, 9, 2])\n    [5, 6, 9, 2, 4, 27, 1]\n    >>> sort_special([8, 7, 4, 1, 3, 6, 5])\n    [8, 7, 12, 1, 15, 5, 6]\n    \"\"\"\n    return l", "def sort_and_transform_even_indices(l: list) -> list:\n    \"\"\"\n    This function accepts a list l and generates a new list l'. This new list preserves the odd indices from l. At the even indices,\n    it creates a list from the corresponding positions in l, sorts it in ascending order, and transforms the sorted data using the square function before placing \n    them in the new list.\n\n    >>> sort_and_transform_even_indices([1, 2, 3])\n    [1, 2, 9]\n    >>> sort_and_transform_even_indices([5, 6, 3, 4, 8, 9, 2])\n    [4, 6, 9, 4, 25, 9, 64]\n    >>> sort_and_transform_even_indices([8, 7, 4, 1, 3, 6, 5])\n    [1, 7, 9, 1, 16, 6, 64]\n    \"\"\"\n\n    even_indices_list = sorted([l[i] for i in range(0, len(l), 2)])\n    return [square(even_indices_list.pop(0)) if i % 2 == 0 else l[i] for i in range(len(l))]", "def sort_and_transform_even_indices(l: list) -> list:\n    \"\"\"\n    This function accepts a list l and generates a new list l'. This new list preserves the odd indices from l. At the even indices,\n    it creates a list from the corresponding positions in l, sorts it in ascending order, and transforms the sorted data using the square function before placing \n    them in the new list.\n\n    >>> sort_and_transform_even_indices([1, 2, 3])\n    [1, 2, 9]\n    >>> sort_and_transform_even_indices([5, 6, 3, 4, 8, 9, 2])\n    [4, 6, 9, 4, 25, 9, 64]\n    >>> sort_and_transform_even_indices([8, 7, 4, 1, 3, 6, 5])\n    [1, 7, 9, 1, 16, 6, 64]\n    \"\"\"\n\n    even_indices_list = sorted([l[i] for i in range(0, len(l), 2)])\n    return [square(even_indices_list.pop(0)) if i % 2 == 0 else l[i] for i in range(len(l))]", "def sort_and_transform_even_indices(l: list) -> list:\n    \"\"\"\n    This function accepts a list l and generates a new list l'. This new list preserves the odd indices from l. \n    At the even indices, it creates a list from the corresponding positions in l, \n    sorts it in ascending order, and transforms the sorted data using the square function before placing \n    them in the new list.\n\n    >>> sort_and_transform_even_indices([1, 2, 3])\n    [1, 2, 9]\n    >>> sort_and_transform_even_indices([5, 6, 3, 4, 8, 9, 2])\n    [4, 6, 9, 4, 25, 9, 64]\n    >>> sort_and_transform_even_indices([8, 7, 4, 1, 3, 6, 5])\n    [1, 7, 9, 1, 16, 6, 64]\n    \"\"\"\n    even_indices_list = sorted([l[i] for i in range(0, len(l), 2)])\n    return [square(even_indices_list.pop(0)) if i % 2 == 0 else l[i] for i in range(len(l))]", "def advanced_sort(l: list, n: int):\n    \"\"\"\n    This function accepts a list l, an integer n and returns a new resultant list l' that satisfies the next conditions:\n    l' equates l at indices not divisible by n; however at indices divisible by n, values parallel l's corresponding indices, but with the uniqueness of being multiplied by 2 and arranged in reverse.\n\n    >>> advanced_sort([1, 2, 3], 2)\n    [1, 2, 3]\n    >>> advanced_sort([5, 6, 3, 4, 8, 9, 2], 3)\n    [5, 6, 3, 2, 8, 9, 1]\n    >>> advanced_sort([8, 7, 4, 1, 3, 6, 5], 3)\n    [8, 7, 4, 5, 3, 6, 1]\n    \"\"\"\n\n    sublist = [val * 2 for i, val in enumerate(l) if i % n == 0]\n    sublist.sort(reverse=True)\n\n    new_list = l.copy()\n    index = 0\n    for i, val in enumerate(new_list):\n        if i % n == 0:\n            new_list[i] = sublist[index]\n            index += 1\n\n    return new_list"]}
{"task_id": "HumanEval/38", "problem": ["def encode_cyclic(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of three characters.\n    \"\"\"\n\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)", "def encode_cyclic(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of three characters - including numbers.\n    \"\"\"\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)", "def decode_cyclic(s: str):\n    \"\"\"\n    Given a string encoded with the encode_cyclic function, this function returns the original (decoded) string.\n    \"\"\"\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)", "def encode_cyclic(z: str):\n    \"\"\"\n    Returns encoded string by cycling groups of three characters.\n    \"\"\"\n    groups = [z[3 * i:min(3 * i + 3, len(z))] for i in range((len(z) + 2) // 3)]\n    groups = [group[1:] + group[0] if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)", "def decode_cyclic(s: str):\n    \"\"\"\n    Accepts a string encoded with the above encode_cyclic function and returns the decoded string, handling special characters and whitespace.\n    \"\"\"\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"]}
{"task_id": "HumanEval/39", "problem": ["def get_prime_fibonacci(p):\n    fib_series = get_fibonacci(p)\n    prime_fib = [num for num in fib_series if is_prime(num)]\n    return prime_fib", "def prime_fib(n):\n    # Check if the input is an integer\n    if type(n) != int:\n        raise TypeError(\"Input must be an integer.\")\n    # Check if the input is greater than 0\n    if n <= 0:\n        raise ValueError(\"Input must be greater than 0.\")\n \n    a, b = 0, 1\n    primes = []\n    for i in range(n):\n        # calculate next fibonacci number\n        a, b = b, a + b\n        # exit if next fib number is greater than 150\n        if a > 150:\n            break\n        # check if next fib number is prime\n        if a < 2: continue\n        is_prime = all(a % num != 0 for num in range(2, int(a**0.5) + 1))\n        if(is_prime):\n            primes.append(a)\n    return primes", "def is_prime(n):\n    \"\"\"Returns true for prime integers, false for non-prime integers.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Check if the number is 2 (2 is the only even prime number)\n    if n == 2: \n      return True\n    # Check for less than 2 and even numbers\n    elif n < 2 or n % 2 == 0: \n      return False\n    # Check for divisibility by any other number up to sqrt(n)\n    for current in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % current == 0:\n            return False\n    return True", "def lcm(x: int, y: int, z: int):\n  \"\"\" \n  LCM determination function for x, y and z. \n\n  Constraints: x, y, z are prime numbers; 1 <= x, y, z <= 10^9\n\n  >>> lcm(3, 5, 7)\n  105\n  >>> lcm(2, 11, 13)\n  286\n  >>> lcm(2, 23, 89)\n  4094\n  >>> lcm(5, 7, 11)\n  385\n  >>> lcm(31, 37, 41)\n  46957\n  \"\"\"\n  temp_lcm = (x * y) // gcd(x, y)\n  return (temp_lcm * z) // gcd(temp_lcm, z)", "def is_prime(n):\n    \"\"\"Returns true for prime integers, false for non-prime integers.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:   # 0 and 1 are not prime\n        return False\n    if n <= 3:   # 2 and 3 are prime\n        return True\n    if n % 2 == 0 or n % 3 == 0:  # eliminate multiples of 2 and 3 \n        return False\n    i = 5\n    while (i * i <= n):\n        if (n % i) == 0 or (n % (i + 2)) == 0: # increment the counter in steps of 6\n            return False\n        i += 6\n    return True"]}
{"task_id": "HumanEval/40", "problem": ["def sum_of_even_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers: A list of integers.\n\n    Returns:\n    The sum of all even numbers in the list.\n    \n    Examples:\n    >>> sum_of_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    30\n    >>> sum_of_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_of_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)", "def diffList(numList: List[int], absolute_difference: bool = False) -> List[int]:\n    \"\"\" Return the difference of each pair of consecutive numbers from `numList'\n    >>> diffList([1, 2, 3])\n    [1, 1]\n    >>> diffList([2, 5, 9, 16])\n    [3, 4, 7]\n    >>> diffList([2, 5, 9, 16], absolute_difference=True)\n    [3, 4, 7]\n    \"\"\"\n    diff_list = []\n    \n    for i in range(1, len(numList)):\n        difference = numList[i] - numList[i-1]\n        \n        if absolute_difference:\n            difference = abs(difference)\n        \n        diff_list.append(difference)\n    \n    return diff_list", "def sort_and_transform_even_indices(l: list) -> list:\n    \"\"\"\n    This function accepts a list l and generates a new list l'. This new list preserves the odd indices from l. At the even indices,\n    it creates a list from the corresponding positions in l, sorts it in ascending order, and transforms the sorted data using the square function before placing \n    them in the new list.\n\n    >>> sort_and_transform_even_indices([1, 2, 3])\n    [1, 2, 9]\n    >>> sort_and_transform_even_indices([5, 6, 3, 4, 8, 9, 2])\n    [4, 6, 9, 4, 25, 9, 64]\n    >>> sort_and_transform_even_indices([8, 7, 4, 1, 3, 6, 5])\n    [1, 7, 9, 1, 16, 6, 64]\n    \"\"\"\n\n    even_indices_list = sorted([l[i] for i in range(0, len(l), 2)])\n    return [square(even_indices_list.pop(0)) if i % 2 == 0 else l[i] for i in range(len(l))]", "def sort_and_transform_even_indices(l: list) -> list:\n    \"\"\"\n    This function accepts a list l and generates a new list l'. This new list preserves the odd indices from l. At the even indices,\n    it creates a list from the corresponding positions in l, sorts it in ascending order, and transforms the sorted data using the square function before placing \n    them in the new list.\n\n    >>> sort_and_transform_even_indices([1, 2, 3])\n    [1, 2, 9]\n    >>> sort_and_transform_even_indices([5, 6, 3, 4, 8, 9, 2])\n    [4, 6, 9, 4, 25, 9, 64]\n    >>> sort_and_transform_even_indices([8, 7, 4, 1, 3, 6, 5])\n    [1, 7, 9, 1, 16, 6, 64]\n    \"\"\"\n\n    even_indices_list = sorted([l[i] for i in range(0, len(l), 2)])\n    return [square(even_indices_list.pop(0)) if i % 2 == 0 else l[i] for i in range(len(l))]", "def sort_and_transform_even_indices(l: list) -> list:\n    \"\"\"\n    This function accepts a list l and generates a new list l'. This new list preserves the odd indices from l. \n    At the even indices, it creates a list from the corresponding positions in l, \n    sorts it in ascending order, and transforms the sorted data using the square function before placing \n    them in the new list.\n\n    >>> sort_and_transform_even_indices([1, 2, 3])\n    [1, 2, 9]\n    >>> sort_and_transform_even_indices([5, 6, 3, 4, 8, 9, 2])\n    [4, 6, 9, 4, 25, 9, 64]\n    >>> sort_and_transform_even_indices([8, 7, 4, 1, 3, 6, 5])\n    [1, 7, 9, 1, 16, 6, 64]\n    \"\"\"\n    even_indices_list = sorted([l[i] for i in range(0, len(l), 2)])\n    return [square(even_indices_list.pop(0)) if i % 2 == 0 else l[i] for i in range(len(l))]"]}
{"task_id": "HumanEval/41", "problem": ["def advanced_concurrent_collision_detector(n: int, left_lane_autos: List[Tuple[float, float]], right_lane_autos: List[Tuple[float, float]]) -> List[Tuple[int, int, float, float]]:\n    \"\"\" Detects the concurrent collisions between cars in both lanes.\n    Returns a list of tuples where each tuple represents a collision.\n    The first two elements are the index of the collided cars in left and right lanes and the other two elements are the overlapping distance.\n\n    :param n: Number of automobiles in each lane\n    :param left_lane_autos: List of tuples indicating the start and end points of automobiles in left lane\n    :param right_lane_autos: List of tuples indicating the start and end points of automobiles in right lane\n    :return: A list of tuples indicating the collided automobiles and their overlapping distance\n    \"\"\"\n    collisions = []\n    for i in range(n):\n        for j in range(n):\n            if left_lane_autos[i][0] < right_lane_autos[j][1] and left_lane_autos[i][1] > right_lane_autos[j][0]:  # Check if ranges of left and right cars overlap\n                overlap_start = max(right_lane_autos[j][0], left_lane_autos[i][0])\n                overlap_end = min(right_lane_autos[j][1], left_lane_autos[i][1])\n                collisions.append((i, j, overlap_start, overlap_end))\n    return collisions", "def advanced_concurrent_collision_detection(n: int, left_lane_autos: List[Tuple[float, float]], right_lane_autos: List[Tuple[float, float]]) -> List[Tuple[int, int, float, float]]:\n    \"\"\"\n    Detects the concurrent collisions between cars in both lanes.\n    Returns a list of tuples where each tuple represents a collision.\n    The first two elements are the index of the collided cars in left and right lanes and the other two elements are the overlapping distance.\n\n    :param n: Number of automobiles in each lane\n    :param left_lane_autos: List of tuples indicating the start and end points of automobiles in left lane\n    :param right_lane_autos: List of tuples indicating the start and end points of automobiles in right lane\n    :return: A list of tuples indicating the collided automobiles and their overlapping distance\n    \"\"\"\n    collisions = []\n    for i in range(n):\n        for j in range(n):\n            if left_lane_autos[i][0] <= right_lane_autos[j][1] and left_lane_autos[i][1] > right_lane_autos[j][0]:  # Check if ranges of left and right cars overlap\n                overlap_start = max(right_lane_autos[j][0], left_lane_autos[i][0])\n                overlap_end = min(right_lane_autos[j][1], left_lane_autos[i][1])\n                collisions.append((i, j, overlap_start, overlap_end))\n    return collisions", "def product_except_self(nums):\n    length = len(nums)\n    # Initialize an array named \"output\" with all 1s.\n    output = [1]*length\n    \n    # Define two variables left and right and initialize them to 1.\n    left = right = 1\n    \n    # Traverse the input array from left and right corners in such a way that from left,\n    # we are calculating the product of all the elements to the left and from right,\n    # we are calculating the product of all the elements to the right.\n    for i in range(length):\n        output[i] *= left\n        output[length-1-i] *= right\n        left *= nums[i]\n        right *= nums[length-1-i]\n    \n    # Return the output.\n    return output", "def simulate_motion():\n    S = 50 # Speed of the slower car in km/h\n    D = 340 # Maximum distance between the cars in km\n    time_interval = 1 # Time interval in seconds\n\n    t = 0 # Initial time\n    distance = 0 # Initial distance between the cars\n\n    while distance < D:\n        speed_slow = S\n        speed_fast = F(S, A(t))\n\n        position_slow = speed_slow * t\n        position_fast = speed_fast * t\n\n        distance = abs(position_slow - position_fast)\n\n        print(\"Time:\", t, \"seconds\")\n        print(\"Position of slower car:\", position_slow, \"km\")\n        print(\"Position of faster car:\", position_fast, \"km\")\n        print(\"Speed of slower car:\", speed_slow, \"km/h\")\n        print(\"Speed of faster car:\", speed_fast, \"km/h\")\n        print(\"Total distance between the cars:\", distance, \"km\")\n        print(\"\")\n\n        t += time_interval", "def find_all_electric_cars(cars, index=0, electric_cars=None):\n    if electric_cars is None:\n        electric_cars = []\n\n    if index >= len(cars):\n        electric_cars.sort()\n        return electric_cars\n\n    car = cars[index]\n    if car['type'] == 'electric' and car['range'] >= 200:\n        electric_cars.append(car['name'])\n\n    return find_all_electric_cars(cars, index + 1, electric_cars)"]}
{"task_id": "HumanEval/42", "problem": ["def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n\n    result = []\n    for num in l:\n        if num > 0:\n          result.append(num)\n    return result", "def get_positive_and_sort(l: list):\n    \"\"\"Return only positive numbers in the list, sorted in ascending order.\n    >>> get_positive_and_sort([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive_and_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n\n    return sorted([num for num in l if num > 0])", "def advanced_sort(l: list, n: int):\n    \"\"\"\n    This function accepts a list l, an integer n and returns a new resultant list l' that satisfies the next conditions:\n    l' equates l at indices not divisible by n; however at indices divisible by n, values parallel l's corresponding indices, but with the uniqueness of being multiplied by 2 and arranged in reverse.\n\n    >>> advanced_sort([1, 2, 3], 2)\n    [1, 2, 3]\n    >>> advanced_sort([5, 6, 3, 4, 8, 9, 2], 3)\n    [5, 6, 3, 2, 8, 9, 1]\n    >>> advanced_sort([8, 7, 4, 1, 3, 6, 5], 3)\n    [8, 7, 4, 5, 3, 6, 1]\n    \"\"\"\n\n    sublist = [val * 2 for i, val in enumerate(l) if i % n == 0]\n    sublist.sort(reverse=True)\n\n    new_list = l.copy()\n    index = 0\n    for i, val in enumerate(new_list):\n        if i % n == 0:\n            new_list[i] = sublist[index]\n            index += 1\n\n    return new_list", "def test_quick_sort():\n    assert quick_sort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10]\n    assert quick_sort([3]) == [3]\n    assert quick_sort([]) == []\n    assert quick_sort([9, 8, 7, 6, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert quick_sort([1, 2, 3, 4, 5, 6, 7, 8, 9]) == [1, 2, 3, 4, 5, 6, 7, 8, 9]", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))"]}
{"task_id": "HumanEval/43", "problem": ["def diffList(numList: List[int], absolute_difference: bool = False) -> List[int]:\n    \"\"\" Return the difference of each pair of consecutive numbers from `numList'\n    >>> diffList([1, 2, 3])\n    [1, 1]\n    >>> diffList([2, 5, 9, 16])\n    [3, 4, 7]\n    >>> diffList([2, 5, 9, 16], absolute_difference=True)\n    [3, 4, 7]\n    \"\"\"\n    diff_list = []\n    \n    for i in range(1, len(numList)):\n        difference = numList[i] - numList[i-1]\n        \n        if absolute_difference:\n            difference = abs(difference)\n        \n        diff_list.append(difference)\n    \n    return diff_list", "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Authoritatively yield manually ordered, non-repetitive intersecting elements for two lists. \n    This function is constructed to handle integer arrays including negative integers, without depending \n    on inherent Python list functionalities. The function returns a well-ordered list eliminating any duplicates.\n    If one of the lists is empty, the function returns an empty list. \n    \n    :param l1: The first list of integers.\n    :type l1: list\n    :param l2: The second list of integers.\n    :type l2: list\n    :returns: A list containing ordered intersecting elements from both lists, without duplicates.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    >>> common([-2, -3, 0, 2, 5], [-5, 2, 0, -3])\n    [-3, 0, 2]\n    >>> common([-2, -3, 0, 2, 5], [])\n    []\n    \"\"\"\n    common_set = set()\n    ordered_set = set()\n    \n    # Traverse through lists and add common elements to common_set\n    for num in l1:\n        if num in l2 and num not in common_set:\n            common_set.add(num)\n            \n    # Traverse through common_set and add elements into ordered_set in sorted order.\n    # This step ensures the elimination of duplicate elements and correct ordering.\n    for num in sorted(common_set):\n        ordered_set.add(num)\n    \n    return list(ordered_set)", "def sum_of_even_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers: A list of integers.\n\n    Returns:\n    The sum of all even numbers in the list.\n    \n    Examples:\n    >>> sum_of_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    30\n    >>> sum_of_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_of_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)", "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Authoritatively yield manually ordered, non-repetitive intersecting elements for two lists.\n    This function is constructed to handle integer arrays including negative integers,without depending \n    on inherent Python list functionalities. The function returns a well-ordered list eliminating any duplicates.\n    If one of the lists is empty, the function returns an empty list. \n\n    :param l1: The first list of integers.\n    :type l1: list\n    :param l2: The second list of integers.\n    :type l2: list\n    :returns: A list containing ordered intersecting elements from both lists, without duplicates.\n\n    >>> common([1, 4, 3, 34, 86, 2, 5], [5, 7, 1, 8, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    >>> common([-2, -3, 0, 2, 5], [-5, 2, 0, -3])\n    [-3, 0, 2]\n    >>> common([-2, -3, 0, 2, 5], [])\n    []\n    \"\"\"\n    common_set = set()\n    ordered_set = set()\n\n    # Traverse through lists and add common elements to common_set\n    for num in l1:\n        if num in l2 and num not in common_set:\n            common_set.add(num)\n\n    # Traverse through common_set and add elements into ordered_set in sorted order.\n    # This step ensures the elimination of duplicate elements and correct ordering.\n    for num in sorted(common_set):\n        ordered_set.add(num)\n\n    return list(ordered_set)", "def pattern_check(l: list, even: bool = False) -> bool:\n    \"\"\"\n    Returns True if the list follows an alternated pattern (number, letter, number, and so on) heeding the even requirement and a supplementary condition - the list should not carry any even numbers when 'even' parameter is True. \n    If even is True, numbers in the list must be even; otherwise, they may be any.\n    \n    >>> pattern_check([1, 'a', 3, 'b', 5])\n    True\n    >>> pattern_check([2, 'b', 4, 'd', 6], even=True)\n    True\n    >>> pattern_check([1, 'c', 2, 'd', 3])\n    False\n    >>> pattern_check([2, 'c', 4, 'd', 6], even=False)\n    False\n    \"\"\"\n    for i in range(len(l)):\n        if i % 2 == 0:\n            if even:\n                if not(isinstance(l[i], int) and l[i] % 2 == 0):\n                    return False\n            else:\n                if not isinstance(l[i], int):\n                    return False\n        elif not isinstance(l[i], str):\n            return False\n    return True"]}
{"task_id": "HumanEval/44", "problem": ["def number_to_binary(x: str, base: int):\n    \"\"\"Switch an input number -- submitted as a string -- with a declared base (as integer) into the respective binary interpretation, represented as a string. \n    The base may be 8 (indicating octal), 10 (reflecting decimal), or 16 (representing hexadecimal).\n    >>> number_to_binary('8', 16)\n    '1000'\n    >>> number_to_binary('F', 16)\n    '1111'\n    >>> number_to_binary('1A', 16)\n    '11010'\n    >>> number_to_binary('10', 8)\n    '1000'\n    >>> number_to_binary('7', 8)\n    '111'\n    >>> number_to_binary('12', 8)\n    '1010'\n    >>> number_to_binary('9', 10)\n    '1001'\n    >>> number_to_binary('15', 10)\n    '1111'\n    >>> number_to_binary('26', 10)\n    '11010'\n    \"\"\"\n    return bin(int(x, base))[2:]", "def number_to_binary(x: str, base: int):\n    \"\"\"Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent as a string.\n    The base can be either 8 (indicating octal), 10 (indicating decimal), or 16 (for hexadecimal).\n    Examples are provided below for better understanding:\n    >>> number_to_binary('8', 16) => '1000'\n    >>> number_to_binary('F', 16) => '1111'\n    >>> number_to_binary('1A', 16) => '11010'\n    >>> number_to_binary('10', 8) => '1000'\n    >>> number_to_binary('7', 8)  => '111'\n    >>> number_to_binary('12', 8) => '1010'\n    >>> number_to_binary('9', 10) => '1001'\n    >>> number_to_binary('15', 10) => '1111'\n    >>> number_to_binary('26', 10) => '11010'\n    \"\"\"\n    # Convert the input to an integer with the specified base\n    x = int(x, base)\n\n    # Convert the integer to binary\n    binary = bin(x)\n\n    # Return the binary value, omitting the first two characters ('0b')\n    return binary[2:]", "def number_to_binary(x: str, base: int):\n    \"\"\"Convert an input number, represented as a string of a specified base (integer) into its binary equivalent as a string.\n    The base can be either 8 (indicating octal), 10 (indicating decimal), or 16 (for hexadecimal).\n    Examples are provided below for better understanding:\n    >>> number_to_binary('8', 16) => '1000'\n    >>> number_to_binary('F', 16) => '1111'\n    >>> number_to_binary('1A', 16) => '11010'\n    >>> number_to_binary('10', 8) => '1000'\n    >>> number_to_binary('7', 8)  => '111'\n    >>> number_to_binary('12', 8) => '1010'\n    >>> number_to_binary('9', 10) => '1001'\n    >>> number_to_binary('15', 10) => '1111'\n    >>> number_to_binary('26', 10) => '11010'\n    \"\"\"\n    #Convert the input to an integer with the specified base\n    x = int(x, base)\n\n    # Convert the integer to binary\n    binary = bin(x)\n\n    # Return the binary value, omitting the first two characters ('0b')\n    return binary[2:]", "def number_to_binary(x: str, base: int):\n    \"\"\"Convert a number from a specified base into its binary equivalent, both represented as strings. \"\"\"\n    if not isinstance(x, str):\n        raise ValueError(\"Input x must be a string.\")\n        \n    if not isinstance(base, int):\n        raise ValueError(\"Input base must be an integer.\")\n    \n    if base not in (8, 10, 16):\n        raise ValueError(\"Base must be 8 (octal), 10 (decimal), or 16 (hexadecimal).\")\n        \n    # convert to integer in the specific base, then convert to binary,\n    # slice the '0b' prefix of binary representation\n    binary = bin(int(x, base))[2:]\n    return binary", "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    \n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    \n    if '.' in x:\n        integer_part, fractional_part = x.split('.')\n        \n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / (base ** len(fractional_part))\n        \n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        \n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            \n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n                \n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"]}
{"task_id": "HumanEval/45", "problem": ["def triangle_area(a, h):\n    \"\"\"Given length of a side and height, return the triangle's area.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n    return 0.5*a*h   # Corrected formula", "def triangle_area(a, h):\n    \"\"\"Using side length and height, compute the triangle's area.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n\n    # step 1: validate input\n    if a <= 0 or h <= 0:\n        raise ValueError(\"Side length and height must be positive\")\n\n    # step 2: compute the area using the formula\n    area = 0.5 * a * h\n\n    return area", "def triangle_area(a, h):\n    \"\"\"\n    Utilizing input values representing the side length and height, \n    accurately calculate the triangle's area if inputs form a valid triangle.\n    It considers a and h as the base and height of a right triangle.\n    \n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n    # validation for non-positive inputs\n    if a <= 0 or h <= 0:\n        raise ValueError('Input values must be positive numbers.')\n        \n    # calculation of the triangle's area\n    return 0.5 * a * h", "def triangle_area(a, h):\n    \"\"\"Given length of a side and height, return the triangle's area.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n    # Data validation\n    if not isinstance(a, (int, float)) or not isinstance(h, (int, float)):\n        return \"Error: both side-length and height need to be numbers\"\n      \n    if a < 0 or h < 0:\n        return \"Error: side-length and height values can't be negative\"\n        \n    if a == 0 or h == 0:\n        return \"Error: side-length or height can't be zero\"\n\n    # Calculation\n    return 0.5 * a * h", "def triangle_area(a, h):\n    \"\"\"Utilizing input values representing the side length (a) and height (h), accurately calculate the triangle's area.\"\"\"\n    area = 0.5 * a * h\n    return area"]}
{"task_id": "HumanEval/46", "problem": ["def fibfib(n: int, memo = {}):\n    \"\"\"\n    This function exemplifies the FibFib sequence, a reflection of the Fibonacci sequence but subject to this distinctive set of regulations:\n    - fibfib(0) == 0\n    - fibfib(1) == 0\n    - fibfib(2) == 1\n    - fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3) where n > 2\n    - fibfib(n) = fibfib(n+3) - fibfib(n+2) - fibfib(n+1) where n < 0\n\n    The application of dynamic programming and memoization techniques is imperative for optimizing the function.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    >>> fibfib(-1)\n    1\n    >>> fibfib(-5)\n    -4\n    \"\"\"\n    if n in memo:\n        return memo[n]\n\n    if n == 0:\n        result = 0\n    elif n == 1:\n        result = 0\n    elif n == 2:\n        result = 1\n    elif n > 2:\n        result = fibfib(n-1, memo) + fibfib(n-2, memo) + fibfib(n-3, memo)\n    else: # where n < 0\n        result = fibfib(n+3, memo) - fibfib(n+2, memo) - fibfib(n+1, memo)\n\n    memo[n] = result\n    return result", "def fibfib(n: int, memo = {}):\n    \"\"\"\n    This function exemplifies the FibFib sequence, a reflection of the Fibonacci sequence but subject to this distinctive set of regulations:\n    - fibfib(0) == 0\n    - fibfib(1) == 0\n    - fibfib(2) == 1\n    - fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) where n > 2\n    - fibfib(n) == fibfib(n+3) - fibfib(n+2) - fibfib(n+1) where n < 0\n\n    The application of dynamic programming and memoization techniques is imperative for optimizing the function.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    >>> fibfib(-1)\n    1\n    >>> fibfib(-5)\n    -4\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        result = 0\n    elif n == 1:\n        result = 0\n    elif n == 2:\n        result = 1\n    elif n > 2:\n        result = fibfib(n-1, memo) + fibfib(n-2, memo) + fibfib(n-3, memo)\n    else: # when n < 0\n        result = fibfib(n+3, memo) - fibfib(n+2, memo) - fibfib(n+1, memo)\n        \n    memo[n] = result\n    return result", "def fibfib(n: int, memo = {}):\n    \"\"\"\n    This function encapsulates the FibFib sequence that mirrors the Fibonacci sequence but with this specific set of rules:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) where n > 2\n    fibfib(n) == fibfib(n+3) - fibfib(n+2) - fibfib(n+1) where n < 0\n\n    Applying dynamic programming and memoization is essential for function optimization.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(6)\n    2\n    >>> fibfib(-1)\n    1\n    >>> fibfib(-5)\n    -4\n    \"\"\"\n    if n in memo:\n        return memo[n]\n\n    if n >= 0:\n        if n < 3:\n            result = n % 2\n        else:\n            result = fibfib(n - 1, memo) + fibfib(n - 2, memo) + fibfib(n - 3, memo)\n    else:\n        result = fibfib(n + 3, memo) - fibfib(n + 2, memo) - fibfib(n + 1, memo)\n\n    # Store the result in the memo dictionary for future reference\n    memo[n] = result\n\n    return result", "def fibfib(n: int, memo = {}):\n    \"\"\"\n    This function encapsulates the FibFib sequence that mirrors the Fibonacci sequence but with this specific set of rules:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) where n > 2\n    fibfib(n) == fibfib(n+3) - fibfib(n+2) - fibfib(n+1) where n < 0\n\n    Applying dynamic programming and memoization is essential for function optimization.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    >>> fibfib(-1)\n    1\n    >>> fibfib(-5)\n    -4\n    \"\"\"\n    if n in memo:\n        return memo[n]\n\n    if n >= 0:\n        if n < 3:\n            result = n % 2\n        else:\n            result = fibfib(n - 1, memo) + fibfib(n - 2, memo) + fibfib(n - 3, memo)\n    else:\n        result = fibfib(n + 3, memo) - fibfib(n + 2, memo) - fibfib(n + 1, memo)\n\n    # store the result in the memo dictionary for future reference\n    memo[n] = result\n\n    return result", "def fibfib(n: int):\n    \"\"\"\n    The FibFib sequence mirrors the Fibonacci sequence, as defined below:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) for n > 2\n    fibfib(n) == fibfib(n+3) - fibfib(n+2) - fibfib(n+1) for n < 0\n\n    Implement dynamic programming and memoization for function optimization.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    elif n > 2:\n        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n    elif n < 0:\n        return fibfib(n+3) - fibfib(n+2) - fibfib(n+1)"]}
{"task_id": "HumanEval/47", "problem": ["def median(l: list):\n    \"\"\"Return median of elements in the list l without sorting it or using built-in functions.\n    Handles tuples with even and odd number of elements, and duplicates.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    >>> median([1, 2, 2, 4, 5])\n    2\n    \"\"\"\n    length = len(l)\n    if length % 2 == 0:\n        return (quickSelect(l, 0, length - 1, length // 2 - 1) + quickSelect(l, 0, length - 1, length // 2)) / 2\n    else:\n        return quickSelect(l, 0, length - 1, length // 2)", "def median(l: list):\n    \"\"\"Return median of elements in the list without sorting it or using built-in functions.\n    Handles tuples with even and odd number of elements, and duplicates.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    >>> median((1, 2, 2, 4, 5))\n    2\n    \"\"\"\n    length = len(l)\n    if length % 2 == 0:\n        return (quickSelect(l, 0, length - 1, length // 2 - 1) + quickSelect(l, 0, length - 1, length // 2)) / 2\n    else:\n        return quickSelect(l, 0, length - 1, length // 2)", "def median(l: list):\n    \"\"\"\n    Computation of the median of a set of numeric elements encompassed within a specified list, bypassing the need for any sorting layer. \n    Accommodates tuples of varying counts, either odd or even, coupling with negative integers and floating-point figures.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    >>> median([2.5, -3.7, 5.1])\n    2.5\n    \"\"\"\n    length = len(l) \n    mid = length // 2\n\n    if length % 2 == 1:\n        return _quickSelect(l, mid, 0, length - 1)\n    else:\n        return (_quickSelect(l, mid - 1, 0, length - 1) + _quickSelect(l, mid, 0, length - 1)) / 2.0  ", "def median(l: list) -> float:\n    \"\"\"\n    Return median of elements in the list l without sorting or using built-in functions.\n\n    Handles collections including negative numbers and floating point numbers \n    using the QuickSelect algorithm for linear time complexity.\n\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    10\n    \"\"\"\n    num_list = l if isinstance(l, list) else list(l)\n    length = len(num_list)\n\n    if length % 2 == 1:\n        # If list has odd number of elements, the median is the middle element\n        return quick_select(num_list, length // 2)\n    else:\n        # If list has even number of elements, the median is the average of the two middle elements\n        return 0.5 * (quick_select(num_list, length // 2 - 1) + quick_select(num_list, length // 2))", "def median(l: list) -> float:\n    \"\"\"\n    Return median of elements in the list l without sorting or using built-in functions.\n\n    Handles collections including negative numbers and floating point numbers \n    using the QuickSelect algorithm for linear time complexity.\n\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    10\n    \"\"\"\n    num_list = l if isinstance(l, list) else list(l)\n    length = len(num_list)\n\n    if length % 2 == 1:\n        # If list has odd number of elements, the median is the middle element\n        return quick_select(num_list, length // 2)\n    else:\n        # If list has even number of elements, the median is the average of the two middle elements\n        return 0.5 * (quick_select(num_list, length // 2 - 1) + quick_select(num_list, length // 2))"]}
{"task_id": "HumanEval/48", "problem": ["def is_palindrome(input_string):\n    \"\"\"Returns positive response for palindrome strings, negative response for non-palindrome strings.\n    >>> is_palindrome('racecar')\n    True\n    >>> is_palindrome('python')\n    False\n    >>> is_palindrome('madam')\n    True\n    >>> is_palindrome('civic')\n    True\n    >>> is_palindrome('hello')\n    False\n    >>> is_palindrome('wow')\n    True\n    \"\"\"\n    return input_string == input_string[::-1]", "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)", "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)", "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Validate if delivered string emulates a palindrome using an iterative mechanism \"\"\"\n    if (l >= r):\n        return True\n    else:\n        return (string[l] == string[r]) and is_palindrome(string, l + 1, r - 1)", "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Validate if delivered string emulates a palindrome using an iterative mechanism \"\"\"\n    if (l >= r):\n        return True\n    else:\n        return (string[l] == string[r]) and is_palindrome(string, l + 1, r - 1)"]}
{"task_id": "HumanEval/49", "problem": ["def is_prime(n):\n    \"\"\"Manifests as true for integers that are prime, reveals false for those that aren't.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    \n    if n in (2, 3):\n        return True\n    if n == 1 or n % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "def is_prime(n):\n    \"\"\"Returns true for prime integers, false for non-prime integers.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n\n    if n == 2:\n        return True\n\n    if n % 2 == 0:\n        return False\n\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n\n    return True", "def is_prime(n):\n    \"\"\"Returns true for prime integers, false for non-prime integers.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n\n    # Start from 3 and step through odd numbers up to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "def LCM(a: int, b: int, c: int):\n    \"\"\"\n    Compute LCM of a, b, and c.\n\n    Constraints: 1 <= a, b, c <= 10^9\n\n    >>> LCM(3, 5, 8)\n    120\n    >>> LCM(21, 14, 31)\n    9578\n    >>> LCM(7, 11, 25)\n    1925\n    >>> LCM(12, 15, 18)\n    180\n    >>> LCM(9, 3, 1)\n    9\n    \"\"\"\n    # Compute LCM of a, b, and c as LCM(a, LCM(b, c))\n    return a * b * c // math.gcd(a, math.gcd(b, c))", "def lcm(x: int, y: int, z: int) -> int:\n    \"\"\"\n    Ascertain the LCM of x, y, and z using a resource-efficient technique.\n\n    Constraints: 1 <= x, y, z <= 10^9\n\n    >>> lcm(4, 6, 8)\n    24\n    >>> lcm(21, 14, 7)\n    42\n    >>> lcm(10, 25, 5)\n    50\n    >>> lcm(12, 15, 3)\n    60\n    >>> lcm(9, 3, 1)\n    9\n    \"\"\"\n    lcm_two = (x * y) // gcd(x, y)\n    return (lcm_two * z) // gcd(lcm_two, z)"]}
{"task_id": "HumanEval/50", "problem": ["def encode_semantic_diff(s: str) -> str:\n    \"\"\"\n    Returns encoded string by shifting every character \n    based on its Unicode difference with its next character.\n    \"\"\"\n    encoded = []\n    \n    for i in range(len(s) - 1):\n        diff = ord(s[i]) - ord(s[i + 1])\n        encoded.append(chr((ord(s[i]) + diff) % 256))\n    encoded.append(s[-1])  # add the last character (unchanged)\n\n    return ''.join(encoded)", "def decode_semantic_diff(s: str) -> str:\n    \"\"\"\n    Accepts a string that is encoded with the above encode_semantic_diff function and returns the decoded string, capably handling unique characters, empty spaces, and special symbols.\n    \"\"\"\n    decoded = [s[0]]  # first character remains unchanged\n\n    for i in range(1,len(s)):\n        prev_diff = ord(s[i - 1]) - ord(decoded[-1])\n        decoded.append(chr((ord(s[i]) - prev_diff) % 256))\n\n    return ''.join(decoded)", "def rot13(message):\n    encoded = \"\"\n\n    for ch in message:\n        if ch.isalpha():\n            if (ch.isupper()):\n                encoded += chr((ord(ch) - 65 + 13) % 26 + 65)\n            else:\n                encoded += chr((ord(ch) - 97 + 13) % 26 + 97)\n        else: \n            encoded += ch\n\n    return encoded", "def decode_cyclic(s: str, shift: int = 3) -> str:\n    \"\"\"Decode a string that has been encoded using a Caesar Cipher. The shift varies based on the character position.\"\"\"\n    result = \"\"\n    for i in range(len(s)):\n        char = s[i]\n        if char.isalpha():\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            result += chr((ord(char) - ascii_offset - (i % shift) + 26) % 26 + ascii_offset)\n        else:\n            result += chr((ord(char) - (i % shift) + 256) % 256)\n    return result", "def decode_cyclic(s: str):\n    \"\"\"\n    Accepts a string encoded with the cyclic_encode function and returns the decoded string. \n    \"\"\"\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"]}
{"task_id": "HumanEval/51", "problem": ["def remove_vowels(string):\n    if len(string) == 0:\n        return \"\"\n\n    first_char = string[0]\n\n    if first_char.lower() in \"aeiou\":\n        return remove_vowels(string[1:])\n    else:\n        return remove_vowels(string[1:]) + first_char", "def remove_vowels(strings):\n    '''This function takes a list of strings and returns a new list without any vowels.'''\n    vowels = ('a', 'e', 'i', 'o', 'u')\n    return [s.lower().replace(c, '') for s in strings for c in vowels]", "def remove_vowels(string):\n    vowels = 'aeiou'\n    for i in string.lower():\n        if i in vowels:\n            string = string.replace(i, \"\")\n    return string", "def remove_vowels(string):\n    \"\"\"Remove all the vowels from the given string.\"\"\"\n    return re.sub(r'[aeiouAEIOU]', '', string)", "def remove_vowels(string):\n    return re.sub(r'[aeiouAEIOU]', '', string)"]}
{"task_id": "HumanEval/52", "problem": ["def below_threshold(l: list, t: int) -> bool:\n    \"\"\"Return True if every integer in list l is below the threshold t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for i in l:\n        if i >= t:\n            return False\n    return True", "def below_threshold(l, t):\n    \"\"\"\n    Provide a boolean return stating whether every integer in a collection labelled 'l' is less than a specific, predetermined limit 't'.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    return all(e < t for e in l)", "def below_threshold(l: list, t: int) -> bool:\n    \"\"\"\n    Indicates if all integers in list l do not exceed the specified threshold t.\n    If the element is not an integer type, it will be ignored.\n    \"\"\"\n    for item in l:\n        if isinstance(item, int) and item > t:\n            return False\n    return True", "def above_limit(l: list, lim: int) -> bool:\n    \"\"\"Return True if every integer in list l is above the limit lim.\n    >>> above_limit([10, 20, 30, 50], 5)\n    True\n    >>> above_limit([1, 5, 8, 15], 10)\n    False\n    \"\"\"\n    return all(i > lim for i in l)", "def below_threshold(l: list, t: int):\n    \"\"\"The function determines if all integers contained in list l are within the specified threshold t. A situation where the list may include non-integer data types is also accounted for.\n    \"\"\"\n    for i in l:\n        if isinstance(i, int) and i > t:\n            return False\n    return True"]}
{"task_id": "HumanEval/53", "problem": ["def lcm(x: int, y: int, z: int):\n  \"\"\" \n  LCM determination function for x, y and z. \n\n  Constraints: x, y, z are prime numbers; 1 <= x, y, z <= 10^9\n\n  >>> lcm(3, 5, 7)\n  105\n  >>> lcm(2, 11, 13)\n  286\n  >>> lcm(2, 23, 89)\n  4094\n  >>> lcm(5, 7, 11)\n  385\n  >>> lcm(31, 37, 41)\n  46957\n  \"\"\"\n  temp_lcm = (x * y) // gcd(x, y)\n  return (temp_lcm * z) // gcd(temp_lcm, z)", "def lowest_common_multiple(x: int, y: int) -> int:\n    \"\"\" Return the lowest common multiple of two integers x and y\n    >>> lowest_common_multiple(3, 5)\n    15\n    >>> lowest_common_multiple(25, 15)\n    75\n    \"\"\"\n    return (x * y) // math.gcd(x, y)", "def smallest_common_multiple(x: int, y: int) -> int:\n    \"\"\" Return the least common multiple of the two integers x and y\n    >>> smallest_common_multiple(5, 3)\n    15\n    >>> smallest_common_multiple(15, 25)\n    75\n    \"\"\"\n    return (x*y) // math.gcd(x, y)", "def lcm(x: int, y: int, z: int) -> int:\n    \"\"\"\n    Ascertain the LCM of x, y, and z using a resource-efficient technique.\n\n    Constraints: 1 <= x, y, z <= 10^9\n\n    >>> lcm(4, 6, 8)\n    24\n    >>> lcm(21, 14, 7)\n    42\n    >>> lcm(10, 25, 5)\n    50\n    >>> lcm(12, 15, 3)\n    60\n    >>> lcm(9, 3, 1)\n    9\n    \"\"\"\n    lcm_two = (x * y) // gcd(x, y)\n    return (lcm_two * z) // gcd(lcm_two, z)", "def calculate_lcm(x: int, y: int) -> int:\n    \"\"\" Return the LCM of two integers x and y\n    >>> calculate_lcm(3, 5)\n    15\n    >>> calculate_lcm(25, 15)\n    75\n    \"\"\"\n    if x == 0 or y == 0:  # Prevent zero division error\n        return 0\n    else:        \n        return abs(x * y) // math.gcd(x, y)"]}
{"task_id": "HumanEval/54", "problem": ["def same_chars(s1, s2):\n    # Removes all the special characters and convert to lower case\n    s1 = re.sub(r'\\W+', '', s1).lower()\n    s2 = re.sub(r'\\W+', '', s2).lower()\n\n    # Sorts the strings and compare them\n    return sorted(s1) == sorted(s2)", "def custom_merge_strings(strings: Tuple[str, str]) -> str:\n    \"\"\" Merge two strings by alternately taking characters from each string and then reversing the merged string.\n    >>> custom_merge_strings('', '')\n    ''\n    >>> custom_merge_strings('a', 'b')\n    'ba'\n    >>> custom_merge_strings('abc', 'def')\n    'fedcba'\n    \"\"\"\n    s1, s2 = strings\n    result = []\n\n    for c1, c2 in zip(s1, s2):\n        result.extend([c1, c2])\n\n    if len(s1) > len(s2):\n        result.extend(s1[len(s2):])\n    else:\n        result.extend(s2[len(s1):])\n\n    return ''.join(result[::-1])", "def pattern_check(l: list, even: bool = False) -> bool:\n    \"\"\"\n    Returns True if the list follows an alternated pattern (number, letter, number, and so on) heeding the even requirement and a supplementary condition - the list should not carry any even numbers when 'even' parameter is True. \n    If even is True, numbers in the list must be even; otherwise, they may be any.\n    \n    >>> pattern_check([1, 'a', 3, 'b', 5])\n    True\n    >>> pattern_check([2, 'b', 4, 'd', 6], even=True)\n    True\n    >>> pattern_check([1, 'c', 2, 'd', 3])\n    False\n    >>> pattern_check([2, 'c', 4, 'd', 6], even=False)\n    False\n    \"\"\"\n    for i in range(len(l)):\n        if i % 2 == 0:\n            if even:\n                if not(isinstance(l[i], int) and l[i] % 2 == 0):\n                    return False\n            else:\n                if not isinstance(l[i], int):\n                    return False\n        elif not isinstance(l[i], str):\n            return False\n    return True", "def duplicate_detector(values: list[tuple[int, str]], show_duplicates: bool = False) -> bool:\n    \"\"\"Evaluate someone's series of logical access code operations, determining whether there are any duplicate entries. If there are, return True; if not, return False. Additionally, invent an optional show duplicates flag that, when on, allows the function to mark '1234' and '1234' [similar to '5678' and '5678'] as duplicates, thereby returning True if a duplicate entry is detected in any instance.\n\n    Argument list consists of tuples laid out as (Access Code, Operation).\n\n    Examples:\n    >>> duplicate_detector([(1234, 'ADD'), (5678, 'ADD'), (9101, 'DELETE')])\n    False\n    >>> duplicate_detector([(1234, 'ADD'), (5678, 'ADD'), (5678, 'DELETE'), (1234,'DELETE')])\n    True\n    >>> duplicate_detector([(1234, 'ADD'), (5678, 'ADD'), (5678, 'DELETE'), (1234, 'ADD')], True)\n    True\n    \"\"\"\n    seen_values = set()\n    duplicates = []\n\n    for value in values:\n        if value in seen_values:\n            duplicates.append(value)\n        else:\n            seen_values.add(value)\n\n    if show_duplicates and duplicates:\n        print('Duplicates: ', duplicates)\n\n    return bool(duplicates)", "def same_chars(str1, str2):\n    if len(str1) != len(str2):\n        return False\n    for i in range(len(str1)):\n        if str1[i] != str2[i]:\n            return False\n    return True"]}
{"task_id": "HumanEval/55", "problem": ["def fibonacci_sequence(x: float):\n    \"\"\"Return the number at position 'x' in the Fibonacci sequence, which can be both a positive or negative floating-point number. Assume that 'x' is not 0 and not a prime number. Structure an efficient method of identifying the fibonacci sequence.\n    >>> fibonacci_sequence(9.1)\n    34\n    >>> fibonacci_sequence(20.9)\n    6765\n    >>> fibonacci_sequence(-9.1)\n    34\n    \"\"\"\n    pos = round(abs(x)) # convert x to an absolute rounded int as fibonacci sequence calculations are generally for positive integers\n\n    if pos == 0:\n        return 0\n    else:\n        fib = [0,1]\n        for i in range(2, pos + 1):\n            fib.append(fib[-1] + fib[-2])\n    return fib[pos]", "def prime_fibonacci(start = 1, end = 100):\n    if end < start or start < 0 or end < 0:\n        print(\"Invalid range\")\n        return\n    for fib in fibonacci_numbers():\n        if fib > end:\n            break\n        if fib >= start:\n            if is_prime(fib):\n                print(fib)", "def fib_sequence(n):\n    if isinstance(n, int) and n >= 0:\n        fib = [0, 1]\n        for i in range(2,n):\n            fib.append(fib[-1] + fib[-2])\n        return fib\n    else:\n        raise ValueError(\"Invalid input. Please enter a non-negative integer.\")", "def prime_fib_product(start, end):\n  if start > end or start < 0:\n    return \"Invalid Range\"\n  product = 1\n  i = 0\n  while fib(i) <= end:\n    if fib(i) >= start and is_prime(fib(i)):\n      product *= fib(i)\n    i += 1\n  return product", "def fib(n): \n    if n == 1 or n == 2: \n        return 1\n    elif n > 2: \n        return fib(n-1) + fib(n-2)"]}
{"task_id": "HumanEval/56", "problem": ["def correct_bracketing(brackets):\n    s = []\n    for bracket in brackets:\n        if bracket == '<':\n            s.append('<')\n        else:\n            if not s:\n                return False\n            else:\n                s.pop()\n    if not s:\n        return True\n    else:\n        return False", "def is_valid_brackets(sequence: str) -> bool:\n    stack = []\n    for c in sequence:\n        if c in \"({[<\":\n            stack.append(c)\n        elif c in \")}]>\":\n            if not stack:\n                return False  # More closing brackets than opening brackets\n            opening = stack.pop()\n            if (c == \")\" and opening != \"(\") or (c == \"}\" and opening != \"{\") or (c == \"]\" and opening != \"[\") or (c == \">\" and opening != \"<\"):\n                return False  # Mismatched opening and closing brackets\n    return not stack  # True if stack is empty, False if there are unmatched opening brackets", "def correct_bracketing(brackets):\n    stack = []\n    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        elif bracket == ')':\n            if not stack or stack.pop() != '(':\n                return False\n    return not stack", "def is_valid_brackets(s: str) -> bool:\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n    for char in s:\n        if char in mapping.values():  # If the character is an opening bracket\n            stack.append(char)\n        else:  # If the character is a closing bracket\n            if not stack or stack.pop() != mapping[char]:\n                return False  # Unmatched closing bracket or no opening bracket to match\n    return not stack  # Return True if stack is empty (all brackets matched and closed properly)", "def check_prime(n):\n    \"\"\"Augments performance via a seldom-used optimization technique, providing true for prime numbers and false for non-prime numbers.\n    >>> check_prime(6)\n    False\n    >>> check_prime(101)\n    True\n    >>> check_prime(11)\n    True\n    >>> check_prime(13441)\n    False\n    >>> check_prime(61)\n    True\n    >>> check_prime(4)\n    False\n    >>> check_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True"]}
{"task_id": "HumanEval/57", "problem": ["def monotonic(l: list, strict: bool = False):\n    \"\"\"\n    This function determines if the sequence of elements in the list is either monotonically increasing or decreasing, considering the strictness criterion put in place.\n    If the strict parameter is assigned to be True, consecutive elements are not allowed to be identical; however, if it's False, they may be the same.\n\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 1, 0, -10], strict=True)\n    False\n    >>> monotonic([1, 1, 1, 1], strict=False)\n    True\n    \"\"\"\n    # Initialize flags for increasing and decreasing\n    increasing = decreasing = True\n\n    # Loop through the list to check sequence\n    for i in range(len(l) - 1):\n        # If strict is True\n        if strict:\n            if l[i] <= l[i + 1]:\n                increasing = False\n            elif l[i] >= l[i + 1]:\n                decreasing = False\n        # If strict is False\n        else:\n            if l[i] < l[i + 1]:\n                increasing = False\n            elif l[i] > l[i + 1]:\n                decreasing = False\n\n    # If list is not increasing and not decreasing, return False\n    if not increasing and not decreasing:\n        return False\n\n    # If the function has not returned yet, it means the list is either increasing or decreasing.\n    return True", "def monotonic(l: list, strict: bool = False):\n    \"\"\"\n    This function determines if the sequence of elements in the list is either monotonically increasing or decreasing, considering the strictness criterion put in place.\n    If the strict parameter is assigned to be True, consecutive elements are not allowed to be identical; however, if it's False, they may be the same.\n\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 1, 0, -10], strict=True)\n    False\n    >>> monotonic([1, 1, 1, 1], strict=False)\n    True\n    \"\"\"\n    # Initialize flags for increasing and decreasing\n    increasing = decreasing = True\n\n    # Loop through the list to check sequence\n    for i in range(len(l) - 1):\n        # If strict is True\n        if strict:\n            if l[i] > l[i + 1]:\n                increasing = False\n            elif l[i] < l[i + 1]:\n                decreasing = False\n        # If strict is False\n        else:\n            if l[i] >= l[i + 1]:\n                increasing = False\n            elif l[i] <= l[i + 1]:\n                decreasing = False\n\n        # If list is not increasing and not decreasing, return False\n        if not increasing and not decreasing:\n            return False\n\n    # If the function has not returned yet, it means the list is either increasing or decreasing.\n    return True", "def below_threshold(l: list, t: int) -> bool:\n    \"\"\"Return True if every integer in list l is below the threshold t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for i in l:\n        if i >= t:\n            return False\n    return True", "def monotonic(l: list, strict: bool = False) -> bool:\n    \"\"\"\n    Check if array is monotonically increasing or decreasing with strictness option, and without prime numbers.\n    \"\"\"\n    if any(is_prime(i) for i in l):\n        return False\n\n    if len(l) < 2: \n        return True\n    \n    if strict: \n        return all(x < y for x, y in zip(l, l[1:])) or all(x > y for x, y in zip(l, l[1:]))\n    else: \n        return all(x <= y for x, y in zip(l, l[1:])) or all(x >= y for x, y in zip(l, l[1:]))", "def complex_median(l: Union[list, set]):\n    \"\"\"\n    Return median including complex numbers of elements in the list or set l without sorting or using built-in functions.\n    Handles even and odd number of elements, duplicates and returns 'None' for non-list or non-set inputs.\n    >>> complex_median([3, 1, 2, 4, 5])\n    3\n    >>> complex_median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    >>> complex_median([1, 2, 2, 4, 5])\n    2\n    >>> complex_median([(1+2j), (3+4j), (5+6j), (7+8j), (9+10j)])\n    (5+6j)\n    >>> complex_median(\"12345\")\n    None\n    \"\"\"\n\n    if not isinstance(l, (list, set)):\n        return None\n        \n    l = list(l)\n\n    if len(l) == 0:\n        return None\n        \n    # sort the list\n    l.sort(key=complex_sort)\n\n    middle_index = len(l) // 2\n\n    # if length is even\n    if len(l) % 2 == 0:\n        return (l[middle_index - 1] + l[middle_index]) / 2\n    else:\n        return l[middle_index]"]}
{"task_id": "HumanEval/58", "problem": ["def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Authoritatively yield manually ordered, non-repetitive intersecting elements for two lists. \n    This function is constructed to handle integer arrays including negative integers, without depending \n    on inherent Python list functionalities. The function returns a well-ordered list eliminating any duplicates.\n    If one of the lists is empty, the function returns an empty list. \n    \n    :param l1: The first list of integers.\n    :type l1: list\n    :param l2: The second list of integers.\n    :type l2: list\n    :returns: A list containing ordered intersecting elements from both lists, without duplicates.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    >>> common([-2, -3, 0, 2, 5], [-5, 2, 0, -3])\n    [-3, 0, 2]\n    >>> common([-2, -3, 0, 2, 5], [])\n    []\n    \"\"\"\n    common_set = set()\n    ordered_set = set()\n    \n    # Traverse through lists and add common elements to common_set\n    for num in l1:\n        if num in l2 and num not in common_set:\n            common_set.add(num)\n            \n    # Traverse through common_set and add elements into ordered_set in sorted order.\n    # This step ensures the elimination of duplicate elements and correct ordering.\n    for num in sorted(common_set):\n        ordered_set.add(num)\n    \n    return list(ordered_set)", "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Authoritatively yield manually ordered, non-repetitive intersecting elements for two lists.\n    This function is constructed to handle integer arrays including negative integers,without depending \n    on inherent Python list functionalities. The function returns a well-ordered list eliminating any duplicates.\n    If one of the lists is empty, the function returns an empty list. \n\n    :param l1: The first list of integers.\n    :type l1: list\n    :param l2: The second list of integers.\n    :type l2: list\n    :returns: A list containing ordered intersecting elements from both lists, without duplicates.\n\n    >>> common([1, 4, 3, 34, 86, 2, 5], [5, 7, 1, 8, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    >>> common([-2, -3, 0, 2, 5], [-5, 2, 0, -3])\n    [-3, 0, 2]\n    >>> common([-2, -3, 0, 2, 5], [])\n    []\n    \"\"\"\n    common_set = set()\n    ordered_set = set()\n\n    # Traverse through lists and add common elements to common_set\n    for num in l1:\n        if num in l2 and num not in common_set:\n            common_set.add(num)\n\n    # Traverse through common_set and add elements into ordered_set in sorted order.\n    # This step ensures the elimination of duplicate elements and correct ordering.\n    for num in sorted(common_set):\n        ordered_set.add(num)\n\n    return list(ordered_set)", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "def get_positive_and_sort(l: list):\n    \"\"\"Return only positive numbers in the list, sorted in ascending order.\n    >>> get_positive_and_sort([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive_and_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n\n    return sorted([num for num in l if num > 0])", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n\n    result = []\n    for num in l:\n        if num > 0:\n          result.append(num)\n    return result"]}
{"task_id": "HumanEval/59", "problem": ["def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Provide the most significant prime divisor of a positive or negative 'n'. \n    It is to be assumed that abs(n) is greater than 1 and not prime in nature. \n    Look to exploit the process by scrutinizing only the odd factors subsequent to 2.\n\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    >>> largest_prime_factor(-13195)\n    29\n    \"\"\"\n    # Handling the negative input\n    n = abs(n)\n\n    # The largest prime factor of n\n    largest_prime = 2\n\n    # Factor out all 2's that divide n\n    while n % 2 == 0:\n        n = n // 2\n\n    # n must be odd at this point, thus a skip of 2 can be used\n    i = 3\n    while i * i <= n:\n        # While i divides n, factor i and divide n\n        while n % i == 0:\n            largest_prime = i\n            n = n // i\n        i += 2\n\n    # This condition is to handle the case when n is a prime number\n    # greater than 2\n    if n > 2:\n        largest_prime = n\n\n    return largest_prime", "def largest_prime_factor(n: int) -> int:\n    \"\"\"Provide the most significant prime divisor of a positive or negative 'n'. It is to be assumed that abs(n) is greater than 1 and not prime in nature. \n    Look to expedite the process by scrutinizing only the odd factors subsequent to 2.\n\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    >>> largest_prime_factor(-13195)\n    29\n    \"\"\"\n    # Handling the negative input\n    n = abs(n)\n\n    # The largest prime factor of n\n    largest_prime = 2\n\n    # Factor out all 2's that divide n\n    while n % 2 == 0:\n        n = n // 2\n\n    # n must be odd at this point, thus a skip of 2 can be used\n    i = 3\n    while i * i <= n:\n        # While i divides n , factor i and divide n\n        while n % i == 0:\n            largest_prime = i\n            n = n // i\n        i = i + 2\n\n    # This condition is to handle the case when n is a prime number\n    # greater than 2\n    if n > 2:\n        largest_prime = n\n\n    return largest_prime", "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime divisor of the integer 'n',\n    Both positive and negative integers are handled\n    Prime factor identification is optimized by checking divisors up to sqrt(n)\n    \"\"\"\n    n = abs(n)  # ensures handling of negative integers\n    factor = 2  # smallest prime factor\n    while factor * factor <= n:\n        if n % factor:\n            factor += 1\n        else:\n            n //= factor\n    return n", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of a positive or negative n. Assume abs(n) > 1 and is not prime.\n    Optimize the procedure by only scrutinizing odd factors succeeding 2.\n    \"\"\"\n    n = abs(n)\n    last_factor = 1\n    # get rid of 2's\n    while n % 2 == 0:\n        last_factor = 2\n        n = n / 2\n    factor = 3\n    max_factor = n ** 0.5\n    while n > 1 and factor <= max_factor:\n        if n % factor == 0:\n            n = n / factor\n            last_factor = factor\n            while n % factor == 0:\n                n = n / factor\n            max_factor = n ** 0.5\n        factor += 2\n    if n == 1:\n        return last_factor\n    else:\n        return n", "def prime_sum_and_largest_factor(n):\n    primes = [i for i in range(n, 0, -1) if is_prime(i)]\n    primes_sum = sum(primes)\n    largest_prime_factor = next((x for x in primes if n % x == 0), None)\n\n    print(\"Prime numbers:\", primes)\n    print(\"Sum of prime numbers:\", primes_sum)\n    print(\"Largest prime factor:\", largest_prime_factor)"]}
{"task_id": "HumanEval/60", "problem": ["def sum_to_n(n):\n    if n == 1:\n        return 1\n    else:\n        return n + sum_to_n(n-1)", "def sum_to_n(n):\n    total = 0\n    for i in range(1, n+1):\n        total += i\n    return total", "def sum_to_n(n):\n\n    # Edge cases\n    if n < 0: \n        return 0\n    if n == 0:\n        return 0\n\n    # Binomial sum formula \n    return (n * (n+1)) / 2 ", "def sum_to_n(n):\n    # Initialize the sum\n    total = 0\n\n    # The loop continues as long as n is greater than 0\n    while n > 0:\n        total += n\n        n -= 1\n\n        # A sophisticated loop termination command\n        if total > 10000:  # Supposing we want to stop the loop when the sum exceeds 10000\n            print(\"The sum exceeded the limit!\")\n            break\n\n    # Return the total sum\n    return total", "def square(n: int) -> int:\n    \"\"\"\n    This function accepts an integer n and returns the square of n.\n\n    >>> square(2)\n    4\n    >>> square(3)\n    9\n    >>> square(4)\n    16\n    \"\"\"\n    return n * n"]}
{"task_id": "HumanEval/61", "problem": ["def correct_bracketing(brackets):\n    stack = []\n    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        elif bracket == ')':\n            if not stack or stack.pop() != '(':\n                return False\n    return not stack", "def correct_bracketing(brackets):\n    s = []\n    for bracket in brackets:\n        if bracket == '<':\n            s.append('<')\n        else:\n            if not s:\n                return False\n            else:\n                s.pop()\n    if not s:\n        return True\n    else:\n        return False", "def is_valid_brackets(sequence: str) -> bool:\n    stack = []\n    for c in sequence:\n        if c in \"({[<\":\n            stack.append(c)\n        elif c in \")}]>\":\n            if not stack:\n                return False  # More closing brackets than opening brackets\n            opening = stack.pop()\n            if (c == \")\" and opening != \"(\") or (c == \"}\" and opening != \"{\") or (c == \"]\" and opening != \"[\") or (c == \">\" and opening != \"<\"):\n                return False  # Mismatched opening and closing brackets\n    return not stack  # True if stack is empty, False if there are unmatched opening brackets", "def is_valid_brackets(s: str) -> bool:\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n    for char in s:\n        if char in mapping.values():  # If the character is an opening bracket\n            stack.append(char)\n        else:  # If the character is a closing bracket\n            if not stack or stack.pop() != mapping[char]:\n                return False  # Unmatched closing bracket or no opening bracket to match\n    return not stack  # Return True if stack is empty (all brackets matched and closed properly)", "def isolate_balanced_bracket_groups(bracket_sequence: str, manage_syntax_errors: bool) -> List[str]:\n    stack = []  # Stack to keep track of brackets level\n    result = []  # Resultant list of groups\n    curr_group = \"\"  # Current group of brackets\n\n    for bracket in bracket_sequence:\n        # Ignore white spaces\n        if bracket.isspace():\n            continue\n        # Push to stack if it's an opening bracket\n        elif bracket == '(':\n            if curr_group:\n                stack.append(curr_group)\n                curr_group = \"\"\n            stack.append(bracket)\n        # Pop from stack if it's a closing bracket\n        elif bracket == ')':\n            if not stack or stack[-1] != '(':\n                if manage_syntax_errors:\n                    print(\"Syntax error: unbalanced closing bracket.\")\n                    continue\n                else:\n                    raise SyntaxError(\"Unbalanced closing bracket.\")\n            else:\n                stack.pop()\n                curr_group += bracket\n                if not stack or stack[-1] != '(':\n                    # If the stack becomes empty or the top of stack is not opening bracket,\n                    # It means we have a balance group of brackets\n                    result.append(curr_group)\n                    curr_group = \"\"\n                    if stack:\n                        curr_group = stack.pop()\n        else:\n            raise ValueError(\"Invalid character: expected brackets or white space.\")\n    # If there are still remaining brackets in the stack, then it's an error\n    if stack:\n        if manage_syntax_errors:\n            print(\"Syntax error: unbalanced opening bracket.\")\n        else:\n            raise SyntaxError(\"Unbalanced opening bracket.\")\n\n    return result"]}
{"task_id": "HumanEval/62", "problem": ["def derivative_and_integral(xs, C):\n    \"\"\"\n    Given xs: coefficients of a polynomial: xs[0] + xs[1] * x + xs[2] * x^2 t....\n    Return derivative and integral of this polynomial, including constant C and remove any trailing zeros.\n    Ensure this works for edge cases.\n\n    >>> derivative_and_integral([3, 1, 2, 4, 5], 2)\n    ([1, 4, 12, 20], [2, 3, 0.5, 0.6666666666666666, 1])\n    >>> derivative_and_integral([1, 2, 3], 4)\n    ([2, 6], [4, 1, 1, 1])\n    \"\"\"\n\n    derivative = []\n    integral = [C]\n    \n    for i in range(len(xs)):\n        if i != 0:\n            derivative.append(i * xs[i])\n            integral.append(xs[i-1] / i)\n        else:\n            # The derivative of a constant is 0\n            derivative.append(0)\n            integral.append(xs[0])\n\n    # All the trailing zeros are removed from the derivative.\n    while derivative and derivative[-1] == 0:\n        derivative.pop()\n\n    return derivative, integral", "def derivative_and_integral(xs: list, C: int):\n    \"\"\"\n    Violations: (xs = coefficients of a polynomial.     xs[0] + xs[1] * x + xs[2] * x^2 + ....)\n    Return derivative and integral of this polynomial, include constant C and remove any trailing zeros. Ensure this works for edge cases.\n    >>> derivative_and_integral([3, 1, 2, 4, 5], 2)\n    ([1, 4, 12, 20], [2, 3, 0.5, 0.6666666666666666, 1, 1])\n    >>> derivative_and_integral([1, 2, 3], 4)\n    ([2, 6], [4, 1, 1, 1])\n    \"\"\"\n\n    derivative = []\n    integral = [C]\n\n    for i in range(len(xs)):\n        if i != 0:\n            derivative.append(i * xs[i])\n            integral.append(xs[i-1] / i)\n        else:\n            # The derivative of a constant is 0\n            derivative.append(0)\n    integral.append(xs[-1] / len(xs))         \n    # All the trailing zeros are removed from the derivative.    \n    while derivative and derivative[-1] == 0:\n        derivative.pop()\n\n    return derivative, integral", "def derivative_and_integral(xs: list, C: int):\n    \"\"\"\n    xs = coefficients of a polynomial (xs[0] + xs[1] * x + xs[2] * x^2 + ....)\n    This function returns the derivative and integral of the given polynomial, includes the constant C, and removes trailing zeros.\n\n    >>> derivative_and_integral([3, 1, 2, 4, 5], 2)\n    ([1, 4, 12, 20], [2.0, 3.0, 0.5, 0.5, 0.8, 1.0])\n    >>> derivative_and_integral([1, 2, 3], 4)\n    ([2, 6], [4.0, 1.0, 1.0, 1.0])\n    \"\"\"\n    derivative = []\n    integral = [C]\n\n    for i in range(len(xs)):\n        if i != 0:\n            derivative.append(i * xs[i])\n        if i+1 != 0:\n            integral.append(xs[i] / (i+1))\n\n    # Remove trailing zeros\n    while integral[-1] == 0:\n        integral = integral[:-1] \n    while derivative and derivative[-1] == 0:\n        derivative = derivative[:-1]\n  \n    return derivative, integral", "def derivative_and_integral(xs: list, C: int):\n  \"\"\"\n  xs - coefficients of a polynomial (xs[0] + xs[1]*x + xs[2]*x^2 + ...)\n  This function returns the derivative and integral of the given polynomial, includes the constant C, and removes trailing zeros.\n\n  >>> derivative_and_integral([3, 1, 2, 4, 5], 2)\n  ([6, 4, 12, 20], [2.0, 3.0, 0.5, 0.5, 0.8, 1.0])\n  >>> derivative_and_integral([1, 2, 3], 4)\n  ([2, 6], [4.0, 1.0, 1.0, 1.0])\n  \"\"\"\n  derivative = []\n  integral = [C]\n\n  for i in range(len(xs)):\n    if i != 0:\n      derivative.append(i * xs[i])\n    if i+1 != 0:\n      integral.append(xs[i] / (i+1))\n\n  # Remove trailing zeros\n  while integral[-1] == 0:\n    integral = integral[:-1]\n  while derivative and derivative[-1] == 0:\n    derivative = derivative[:-1]\n\n  return derivative, integral", "def compute_derivative_integral(xs: list, C: int):\n    \"\"\"\n    Assumptions broken: (xs = coefficients of a polynomial in order: xs[0] + xs[1] * x + xs[2] * x^2 + ....)\n    Compute both the derivative and integral of the given polynomial, incorporate constant C and remove any surplus zeros. Ensure correctness with edge cases.\n    \"\"\"\n    if not xs:\n        return [], [C]\n    \n    derivative = []\n    integral = [C]\n\n    for i in range(len(xs)):\n        if i > 0:  derivative.append(i * xs[i])\n        if i > 0:  integral.append(xs[i-1] /(i))\n        \n    integral.append(xs[-1] / len(xs))\n\n    while derivative and derivative[-1] == 0:\n        derivative.pop()\n        \n    while len(integral) > 1 and integral[-1] == 0:  # retain the constant term even if it's zero.\n        integral.pop()\n\n    return derivative, integral"]}
{"task_id": "HumanEval/63", "problem": ["def fibfib(n: int):\n    \"\"\"\n    The FibFib sequence mirrors the Fibonacci sequence, as defined below:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) for n > 2\n    fibfib(n) == fibfib(n+3) - fibfib(n+2) - fibfib(n+1) for n < 0\n\n    Implement dynamic programming and memoization for function optimization.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    elif n > 2:\n        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n    elif n < 0:\n        return fibfib(n+3) - fibfib(n+2) - fibfib(n+1)", "def fibfib(n: int, memo = {}):\n    \"\"\"\n    This function exemplifies the FibFib sequence, a reflection of the Fibonacci sequence but subject to this distinctive set of regulations:\n    - fibfib(0) == 0\n    - fibfib(1) == 0\n    - fibfib(2) == 1\n    - fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) where n > 2\n    - fibfib(n) == fibfib(n+3) - fibfib(n+2) - fibfib(n+1) where n < 0\n\n    The application of dynamic programming and memoization techniques is imperative for optimizing the function.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    >>> fibfib(-1)\n    1\n    >>> fibfib(-5)\n    -4\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        result = 0\n    elif n == 1:\n        result = 0\n    elif n == 2:\n        result = 1\n    elif n > 2:\n        result = fibfib(n-1, memo) + fibfib(n-2, memo) + fibfib(n-3, memo)\n    else: # when n < 0\n        result = fibfib(n+3, memo) - fibfib(n+2, memo) - fibfib(n+1, memo)\n        \n    memo[n] = result\n    return result", "def fibfib(n: int, memo = {}):\n    \"\"\"\n    This function exemplifies the FibFib sequence, a reflection of the Fibonacci sequence but subject to this distinctive set of regulations:\n    - fibfib(0) == 0\n    - fibfib(1) == 0\n    - fibfib(2) == 1\n    - fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3) where n > 2\n    - fibfib(n) = fibfib(n+3) - fibfib(n+2) - fibfib(n+1) where n < 0\n\n    The application of dynamic programming and memoization techniques is imperative for optimizing the function.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    >>> fibfib(-1)\n    1\n    >>> fibfib(-5)\n    -4\n    \"\"\"\n    if n in memo:\n        return memo[n]\n\n    if n == 0:\n        result = 0\n    elif n == 1:\n        result = 0\n    elif n == 2:\n        result = 1\n    elif n > 2:\n        result = fibfib(n-1, memo) + fibfib(n-2, memo) + fibfib(n-3, memo)\n    else: # where n < 0\n        result = fibfib(n+3, memo) - fibfib(n+2, memo) - fibfib(n+1, memo)\n\n    memo[n] = result\n    return result", "def fibfib(n: int, memo = {}):\n    \"\"\"\n    This function encapsulates the FibFib sequence that mirrors the Fibonacci sequence but with this specific set of rules:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) where n > 2\n    fibfib(n) == fibfib(n+3) - fibfib(n+2) - fibfib(n+1) where n < 0\n\n    Applying dynamic programming and memoization is essential for function optimization.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    >>> fibfib(-1)\n    1\n    >>> fibfib(-5)\n    -4\n    \"\"\"\n    if n in memo:\n        return memo[n]\n\n    if n >= 0:\n        if n < 3:\n            result = n % 2\n        else:\n            result = fibfib(n - 1, memo) + fibfib(n - 2, memo) + fibfib(n - 3, memo)\n    else:\n        result = fibfib(n + 3, memo) - fibfib(n + 2, memo) - fibfib(n + 1, memo)\n\n    # store the result in the memo dictionary for future reference\n    memo[n] = result\n\n    return result", "def fibfib(n: int, memo = {}):\n    \"\"\"\n    This function encapsulates the FibFib sequence that mirrors the Fibonacci sequence but with this specific set of rules:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) where n > 2\n    fibfib(n) == fibfib(n+3) - fibfib(n+2) - fibfib(n+1) where n < 0\n\n    Applying dynamic programming and memoization is essential for function optimization.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(6)\n    2\n    >>> fibfib(-1)\n    1\n    >>> fibfib(-5)\n    -4\n    \"\"\"\n    if n in memo:\n        return memo[n]\n\n    if n >= 0:\n        if n < 3:\n            result = n % 2\n        else:\n            result = fibfib(n - 1, memo) + fibfib(n - 2, memo) + fibfib(n - 3, memo)\n    else:\n        result = fibfib(n + 3, memo) - fibfib(n + 2, memo) - fibfib(n + 1, memo)\n\n    # Store the result in the memo dictionary for future reference\n    memo[n] = result\n\n    return result"]}
{"task_id": "HumanEval/64", "problem": ["def vowels_count(s):\n    \"\"\"\n    This function, named as vowels_count, \n    takes a string representing a word as an argument and \n    returns the total number of all vowels it contains.\n    The vowels considered here are 'a', 'e', 'i', 'o', 'u', and 'y' if it appears at the end of the word.\n    The function ignores case sensitivity and carefully handles unusual characters within the input string.\n\n    Test Cases:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"\u00e9xampl\u00eb\")\n    3\n    \"\"\"\n    \n    # Checking for empty string\n    if not s:\n        return 0\n\n    s = s.lower()  # convert string in lower case to remove case sensitivity\n    pattern = re.compile(r'[aeiou]|y$')  # pattern to match vowels and y at the end\n\n    return len(pattern.findall(s))  # return count of matched vowels ", "def vowels_count(s):\n    \"\"\"Compose a function 'vowels_count', accepting a string representing\n    a word as input, returning the number of vowels in the string.\n    Vowels, in this case, are 'a', 'e', 'i', 'o', 'u', and 'y' ONLY when\n    found at the end of the input word. Ignore case and include special\n    characters, numbers, blank spaces, and empty strings within the input word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDy\")\n    3\n    >>> vowels_count(\"\u00e9xampl\u00eb 42\")\n    4\n    \"\"\"\n    count = 0;\n    if s == '':\n         return count;\n    s = s.lower()\n\n    for char in s:\n        if char == 'a' or char == 'e' or char == 'i' or char == 'o' or char == 'u':\n            count += 1\n    if s[-1] == 'y':\n        count += 1\n\n    return count", "def vowels_count(s):\n    \"\"\"\n    Compose a function 'vowels_count', accepting a string representing\n    a word as input, returning the number of vowels in the string.\n    Vowels, in this case, are 'a', 'e', 'i', 'o', 'u', and 'y' ONLY when\n    found at the end of the input word. Ignore case and include special\n    characters, numbers, blank spaces, and empty strings within the input word,\n    \n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEUv\")\n    3\n    >>> vowels_count(\"example a2\")\n    4\n    \"\"\"\n    count = 0\n    if s == '':\n        return count\n    s = s.lower()\n\n    for char in s:\n        if char == 'a' or char == 'e' or char == 'i' or char == 'o' or char == 'u':\n            count += 1\n        if s[-1] == 'y':\n            count += 1\n\n    return count", "def vowels_count(s):\n    \"\"\"Design an operation termed vowels_count, which accepts a string symbolising\n    a term as input and generates the sum of vowels found in the string.\n    Vowels entail 'a', 'e', 'i', 'o', 'u', together with 'y' SOLELY when unveiled\n    at the closing of the provided term. Overlook the letter casing and consider\n    unique characters within the term.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"\u00e9xampl\u00eb\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    s = s.lower()\n    count = 0\n    for i in s:\n        if i in vowels:\n            count+=1\n    if s[-1] == 'y':\n        count+=1\n    return count", "def vowels_count(s):\n    \"\"\"\n    This function takes a string, disregards its case, and counts the number of vowels \n    it contains. The vowels are 'a', 'e', 'i', 'o', 'u', and 'y' if it is at the end of \n    the string. It also allows for unusual characters in the string.\n\n    Test Cases:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"\u00e9xampl\u00eb\")\n    3\n    \"\"\"\n\n    # The regular expression pattern matches all vowels irrespective of case and 'y' when it occurs \n    # at the end of the string. Other unusual characters are also taken care of.\n    pattern = r'[aeiou]|[yY]$'\n    \n    # The flags argument is used to enable various special features and syntax variations.\n    # re.IGNORECASE performs case-insensitive matching; expressions like [A-Z] will match lowercase letters, too.\n    matches = re.findall(pattern, s, re.IGNORECASE)\n    \n    return len(matches)"]}
{"task_id": "HumanEval/65", "problem": ["def circularShift(x, shift):\n    # Initialize 2 variables to store the length of 'x' and the result\n    lengthOfX, result = 0, 0\n    \n    # Store a copy of 'x' to calculate the length\n    tempX = x\n    while tempX != 0:\n        tempX //= 10\n        lengthOfX += 1\n\n    # If the shift is greater than the number of digits, return the digits reversed\n    if shift >= lengthOfX:\n        while x != 0:\n            result = result * 10 + x % 10\n            x //= 10\n    else:\n        rightPart = x % 10**shift\n        leftPart = x // 10**shift\n        multiplier = 10**(lengthOfX-shift)\n        result = rightPart * multiplier + leftPart\n    return result", "def encrypt_caesar(plaintext, shift):\n    \"\"\"\n    Encrypts a plaintext string using the Caesar cipher.\n\n    Args:\n        plaintext: The plaintext to encrypt.\n        shift: The number of characters to shift by.\n\n    Returns:\n        The ciphertext.\n    \"\"\"\n    alphabet = string.ascii_lowercase\n    shifted_alphabet = alphabet[shift:] + alphabet[:shift] \n    table = str.maketrans(alphabet, shifted_alphabet) \n    ciphertext = plaintext.translate(table)\n    return ciphertext", "def circular_shift(matrix):\n    try:\n        # Convert input list to numpy array\n        arr = np.array(matrix)\n\n        # Check if the array is 2D\n        if arr.ndim != 2:\n            raise ValueError('Input matrix should be a 2D list.')\n\n        # Check if all sub-lists (rows) have the same number of elements (columns)\n        if len(set(map(len, arr))) != 1:\n            raise ValueError('All sub-lists (rows) should have the same number of elements (columns).')\n\n        # Perform circular shift on each row\n        shifted_rows = np.roll(arr, shift=-1, axis=1)\n\n        # Perform circular shift on the columns\n        shifted_matrix = np.roll(shifted_rows, shift=-1, axis=0)\n\n        # Return the shifted matrix as a nested list\n        return shifted_matrix.tolist()\n\n    except Exception as e:\n        # Logging the error\n        logging.error(\"An error occurred: %s\", str(e))", "def applyVerticalShift(image, mask, max_shift=0.05, p=0.5):\n    \"\"\"Apply random vertical shift to the input image based on the mask.\"\"\"\n    if np.random.rand() < p:  # Apply the shift with probability p\n        max_shift_pixels = int(max_shift * image.shape[0])\n        shift = np.random.choice(np.arange(-max_shift_pixels, max_shift_pixels+1))\n        shifted_image = np.roll(image, shift, axis=0) * mask  # Apply shift based on the mask\n        return shifted_image\n    else:\n        return image  # Return the original image if shift is not applied", "def base_10_to_base_12(num):\n    \"\"\"Convert a number from base 10 to base 12.\"\"\"\n    \n    # List of numbers for base 12\n    digits = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\"]\n    \n    # Initialise the result\n    result = \"\"\n    # Loop while the number is greater than 0\n    while num > 0:\n        # Find the remainder after dividing the number by 12\n        remainder = num % 12\n        # Divide the number by 12\n        num //= 12\n        # Add the remainder to the result\n        result = digits[remainder] + result\n    \n    return result"]}
{"task_id": "HumanEval/66", "problem": ["def digitSum(m):\n    digitSum = 0\n    while m:\n        digitSum += m % 10\n        m //= 10\n    return digitSum", "def digitSum(n):\n    digitSum = 0\n    while n:\n        digitSum += n % 10\n        n //= 10\n    return digitSum", "def digitSum(n):\n    if n == 0: \n        return 0\n    else:\n        return (n % 10) + digitSum(int(n / 10))", "def primeWithPrimeDigitSum(lst):\n    maxPrime = 0\n    sumDigits = 0\n    for i in lst:\n      if isprime(i):\n        digit_sum = digitSum(i)\n        if isprime(digit_sum) and i > maxPrime:\n          maxPrime = i\n          sumDigits = digit_sum\n    if maxPrime == 0:\n      return None\n    else:\n      return (maxPrime, sumDigits)", "def primeWithPrimeDigitSum(lst):\n    maxPrime = 0\n    sumDigits = 0\n    for i in lst:\n        if isprime(i):\n            digit_sum = digitSum(i)\n            if isprime(digit_sum) and i > maxPrime:\n                maxPrime = i\n                sumDigits = digit_sum\n    if maxPrime == 0:\n        return None\n    else:\n        return (maxPrime, sumDigits)"]}
{"task_id": "HumanEval/67", "problem": ["def fruit_distribution(s, n, fruits, max_quantity):\n    \"\"\"\n    You have a string list containing various fruit quantities such as \"apples\", \"oranges\", \"mangoes\", etc.\n    The format of the list will be: [\"X apples\", \"Y oranges\", \"Z mangoes\"...]\n    Given such a list, an integer representing the total number of fruits in the basket, another list with all possible fruits, \n    and an integer representing the maximum allowed quantity for each fruit, generate a dictionary showing the quantity of \n    each type of fruit not specified in the list and ensure the total distributed quantity of each fruit doesn't exceed \n    the maximum limit.\n\n    For example:\n    fruit_distribution([\"5 apples\", \"6 oranges\"], 19, [\"apples\", \"oranges\", \"mangoes\"], 10) -> {\"mangoes\": 8}\n\n    If the total distributed quantity of a fruit exceeds the maximum quantity, raise a ValueError.\n    \"\"\"\n    result = {}\n    total_specified = 0\n\n    for fruit in s:\n        quantity = int(fruit.split(\" \")[0])\n        total_specified += quantity\n\n    remaining_fruits = n - total_specified\n    for fruit in fruits:\n        if fruit not in s:\n            if remaining_fruits > max_quantity:\n                raise ValueError(\"Total quantity exceeds maximum allowed quantity for fruit type.\")\n            else:\n                result[fruit] = remaining_fruits\n\n    return result", "def fruit_distribution(s, n):\n    fruits = list(map(int, re.findall(r'\\d+', s)))\n    apples, oranges = fruits[0], fruits[1]\n    return n - apples - oranges", "def test_issue_30():\n    cases = [\n        (\"The value is: {}\", [(10, \"The value is: 10\"), (20, \"The value is: 20\")]),\n        (\"{} apples and {} oranges\", [(3,  \"3 apples and 5 oranges\"), (5, \"5 apples and 7 oranges\")]),\n        # Add more test cases as needed\n    ]\n\n    for case in cases:\n        val = case[0]\n        for fmt, expected in case[1:]:\n            actual = custom_format(fmt, val)\n            assert actual == expected", "def count_fruits(apples, oranges):\n    if apples < 0 or oranges < 0:\n        return \"Error: The counts cannot be negative.\"\n    \n    total_count = apples + oranges\n    \n    if total_count % 3 == 0:\n        return \"Error: The total count should not be divisible by 3.\"\n    \n    return total_count", "def fruit_distribution(s, n, fruits, servings, exp_dates):\n    \"\"\"\n    You will receive a list of strings representing the quantity of various fruits\n    in a basket (e.g., [\"X apples\", \"Y oranges\", \"Z mangoes\"...]).\n\n    You'll also receive a dictionary with the number of servings per fruit and another \n    dictionary with the fruits' expiration dates (format: YYYY-MM-DD).\n\n    Given these inputs, return a dictionary reflecting the quantity of servings \n    of each fruit not mentioned in the list and not expired yet.\n\n    Outcome must be a dictionary including only the fruits with a non-zero count of servings.\n    Some syntax or semantic errors may exist in the provided code.\n    \"\"\"\n\n    result = {}  # Initialized here but not being used.\n\n    today = datetime.date.today()  # Get today's date\n\n    not_in_fruit_basket = set(servings.keys()) - set(fruits)  # Fruits not in basket\n\n    # Try to update the servings for each fruit and catch errors\n    for fruit in servings.keys():\n        try:\n            servings_this_fruit = servings[fruit]\n            date_string = exp_dates[fruit]\n            fruit_exp_date = datetime.datetime.strptime(date_string, '%Y-%m-%d').date()\n\n            # Get fruits not in the basket and not expired yet\n            if (fruit not in fruits and fruit_exp_date >= today):\n                result[fruit] = servings_this_fruit\n        # If error caught, prints it and continues with the next fruit \n        except Exception as e:\n            print(f\"Error occurred with fruit {fruit}: {e}\")\n            continue\n\n    return result"]}
{"task_id": "HumanEval/68", "problem": ["def heapify(array, index, heap_size):\n    smallest = index\n    left = 2 * index + 1\n    right = 2 * index + 2\n    if left < heap_size and array[left] < array[smallest]:\n        smallest = left\n    if right < heap_size and array[right] < array[smallest]:\n        smallest = right\n    if smallest != index:\n        array[index], array[smallest] = array[smallest], array[index]\n        heapify(array, smallest, heap_size)", "def heapify(array, index, heap_size):\n    smallest = index\n    left = 2 * index + 1\n    right = 2 * index + 2\n    if left < heap_size and array[left] < array[smallest]:\n        smallest = left\n    if right < heap_size and array[right] < array[smallest]:\n        smallest = right\n    if smallest != index:\n        array[index], array[smallest] = array[smallest], array[index]\n        heapify(array, smallest, heap_size)", "def strange_sort_list_bst(lst):\n    '''\n    This function should accept a list of integers and decimal numbers and return the list in a specific pattern, leveraging the principles of a binary search tree. The steps for this peculiar sorting pattern should be:\n    - Commence with the smallest number.\n    - Next, identify the highest value from the remaining elements.\n    - Then, ascertain the lowest value among the untouched output, and continue in this manner.\n    \n    Examples:\n    strange_sort_list_bst([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list_bst([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list_bst([]) == []\n    strange_sort_list_bst([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n    \n    # First, we will sort the list in ascending order.\n    lst.sort()\n\n    output = []\n\n    # Then, while lst is not empty, we will remove and append to output the smallest\n    # and largest element alternatively.\n    while lst:\n        output.append(lst.pop(0))  # smallest\n        if lst:\n            output.append(lst.pop(-1))  # largest\n\n    return output", "def strange_sort_list_bst(lst):\n    '''\n    This function should accept a list of integers and decimal_numbers and return the list in a specific pattern, leveraging the principles of a binary search tree. The steps to this peculiar_sorting pattern should be:\n    - Commence with the smallest number.\n    - Next, identify the highest value from the remaining elements.\n    - Then, ascertain the lowest_value among the untouched output, and continue in this manner.\n\n    Examples:\n    strange_sort_list_bst([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list_bst([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list_bst([]) == []\n    strange_sort_list_bst([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # First, we will sort the list in ascending_order.\n    lst.sort()\n\n    output = []\n\n    # Then, while lst is not empty, we will remove and append to output the smallest\n    # and largest element alternately.\n    while lst:\n        output.append(lst.pop(0))  # smallest\n        if lst:\n            output.append(lst.pop(-1))  # largest\n\n    return output", "def sift_down(arr, current, size):\n    while current < size:\n        smallest = current\n        left = 2 * current + 1\n        right = 2 * current + 2\n\n        # Compare with left child\n        if left < size and arr[left] < arr[smallest]:\n            smallest = left\n\n        # Compare with right child\n        if right < size and arr[right] < arr[smallest]:\n            smallest = right\n\n        # If the smallest is not the current node, swap and continue sift-down\n        if smallest != current:\n            arr[current], arr[smallest] = arr[smallest], arr[current]\n            current = smallest\n        else:\n            break"]}
{"task_id": "HumanEval/69", "problem": ["def uncommon_elements(sequence):\n    '''\n    Design a function that accepts a non-empty list composed of positive integers and returns a list of distinct integers whose frequency surpasses half of the integer's numerical value. Here, 'frequency' denotes the number of times a specific integer appears within the list.\n    If no integers satisfy these conditions, the function should return an empty list.\n    Examples:\n        uncommon_elements([4, 1, 2, 2, 3, 1]) should yield [2, 3]\n        uncommon_elements([1, 2, 2, 3, 3, 3, 4, 4, 4]) should yield [2, 3, 4]\n        uncommon_elements([5, 5, 4, 4, 4]) should yield [4]\n    '''\n    from collections import Counter\n    count = Counter(sequence)\n    result = []\n    for num, freq in count.items():\n        if freq > num/2:\n            result.append(num)\n    return result", "def rolling_max(numbers1: List[int], numbers2: List[int]) -> Tuple[List[int], List[int]]:\n    \"\"\" From two given lists of integers, generate a list of rolling maximum element found until given moment \n    in the sequence and store them as maximum of each list.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2], [1, 4, 2, 4, 1, 5, 1])\n    ([1, 2, 3, 3, 3, 4, 4], [1, 4, 4, 4, 4, 5, 5])\n    \"\"\"\n    pass  # Your implementation here", "def strange_sort_list_bst(lst):\n    '''\n    This function should accept a list of integers and decimal_numbers and return the list in a specific pattern, leveraging the principles of a binary search tree. The steps to this peculiar_sorting pattern should be:\n    - Commence with the smallest number.\n    - Next, identify the highest value from the remaining elements.\n    - Then, ascertain the lowest_value among the untouched output, and continue in this manner.\n\n    Examples:\n    strange_sort_list_bst([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list_bst([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list_bst([]) == []\n    strange_sort_list_bst([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # First, we will sort the list in ascending_order.\n    lst.sort()\n\n    output = []\n\n    # Then, while lst is not empty, we will remove and append to output the smallest\n    # and largest element alternately.\n    while lst:\n        output.append(lst.pop(0))  # smallest\n        if lst:\n            output.append(lst.pop(-1))  # largest\n\n    return output", "def strange_sort_list_bst(lst):\n    '''\n    This function should accept a list of integers and decimal numbers and return the list in a specific pattern, leveraging the principles of a binary search tree. The steps for this peculiar sorting pattern should be:\n    - Commence with the smallest number.\n    - Next, identify the highest value from the remaining elements.\n    - Then, ascertain the lowest value among the untouched output, and continue in this manner.\n    \n    Examples:\n    strange_sort_list_bst([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list_bst([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list_bst([]) == []\n    strange_sort_list_bst([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n    \n    # First, we will sort the list in ascending order.\n    lst.sort()\n\n    output = []\n\n    # Then, while lst is not empty, we will remove and append to output the smallest\n    # and largest element alternatively.\n    while lst:\n        output.append(lst.pop(0))  # smallest\n        if lst:\n            output.append(lst.pop(-1))  # largest\n\n    return output", "def unique_BST_sort(lst):\n    '''\n    Upon a mixed assemblage of integers and real numbers, restore the list arrayed in a peculiar order employing Binary Search Tree (BST) tactic.\n    The arraying sequence should adhere to the following progression:\n    - Initiate with the least number.\n    - Subsequently recognize the apex numeric from the remaining.\n    - Proceed to decipher the least numerical not yet included from the remaining, and maintain this sequence.\n    \n    Demonstrations:\n    unique_BST_sort([1, 2, 3, 4]) == [1, 4, 2, 3]\n    unique_BST_sort([5, 5, 5, 5]) == [5, 5, 5, 5]\n    unique_BST_sort([]) == []\n    unique_BST_sort([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n    \n    # sort values in ascending order\n    lst.sort()\n    result = []\n    \n    while lst: \n        # Pop the smallest value and append it to the result list\n        result.append(lst.pop(0))\n        \n        # If there are values remaining, pop the largest value and append it to the result list\n        if lst:\n            result.append(lst.pop())\n            \n    return result"]}
{"task_id": "HumanEval/70", "problem": ["def strange_sort_list_bst(lst):\n    '''\n    This function should accept a list of integers and decimal numbers and return the list in a specific pattern, leveraging the principles of a binary search tree. The steps for this peculiar sorting pattern should be:\n    - Commence with the smallest number.\n    - Next, identify the highest value from the remaining elements.\n    - Then, ascertain the lowest value among the untouched output, and continue in this manner.\n    \n    Examples:\n    strange_sort_list_bst([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list_bst([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list_bst([]) == []\n    strange_sort_list_bst([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n    \n    # First, we will sort the list in ascending order.\n    lst.sort()\n\n    output = []\n\n    # Then, while lst is not empty, we will remove and append to output the smallest\n    # and largest element alternatively.\n    while lst:\n        output.append(lst.pop(0))  # smallest\n        if lst:\n            output.append(lst.pop(-1))  # largest\n\n    return output", "def strange_sort_list_bst(lst):\n    '''\n    This function should accept a list of integers and decimal_numbers and return the list in a specific pattern, leveraging the principles of a binary search tree. The steps to this peculiar_sorting pattern should be:\n    - Commence with the smallest number.\n    - Next, identify the highest value from the remaining elements.\n    - Then, ascertain the lowest_value among the untouched output, and continue in this manner.\n\n    Examples:\n    strange_sort_list_bst([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list_bst([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list_bst([]) == []\n    strange_sort_list_bst([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # First, we will sort the list in ascending_order.\n    lst.sort()\n\n    output = []\n\n    # Then, while lst is not empty, we will remove and append to output the smallest\n    # and largest element alternately.\n    while lst:\n        output.append(lst.pop(0))  # smallest\n        if lst:\n            output.append(lst.pop(-1))  # largest\n\n    return output", "def hybrid_sort_list_heap(lst):\n    '''\n    Given a list of integers and decimals, use a heap sort combined with binary insertion sort to arrange the list in a special order. The ordering should start with the smallest value, then the largest, then the smallest of the remaining values not yet included in the output, and continue doing this until all elements are sorted.\n\n    Examples:\n    hybrid_sort_list_heap([1, 2, 3, 4]) == [1, 4, 2, 3]\n    hybrid_sort_list_heap([5, 5, 5, 5]) == [5, 5, 5, 5]\n    hybrid_sort_list_heap([]) == []\n    hybrid_sort_list_heap([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # Make input list to a heap\n    heapq.heapify(lst)\n\n    # If the size of the list is less than 10 use Binary Insertion Sort\n    if len(lst) < 10:\n        sorted_lst = binary_insertion_sort(lst)\n    else:\n        # Else use Heap Sort\n        sorted_lst = [heapq.heappop(lst) for _ in range(len(lst))]\n\n    # Create a resultant list as per special order\n    result = []\n    while sorted_lst:\n        result.append(sorted_lst.pop(0))  # pop the smallest\n        if sorted_lst:\n            result.append(sorted_lst.pop(-1))  # pop the largest\n\n    return result", "def hybrid_sort_list_heap(lst):\n    '''\n    Given a list of integers and decimals, use a heap sort combined \n    with binary insertion sort to arrange the list in a special order. \n    The ordering should start with the smallest value, then the largest, \n    then the smallest of the remaining values not yet included in the output, \n    and continue doing this until all elements are sorted.\n\n    Examples:\n    hybrid_sort_list_heap([1, 2, 3, 4]) == [1, 4, 2, 3]\n    hybrid_sort_list_heap([5, 5, 5, 5]) == [5, 5, 5, 5]\n    hybrid_sort_list_heap([]) == []\n    hybrid_sort_list_heap([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # Make input list to a heap\n    heapq.heapify(lst)\n\n    # If the size of the list is less than 10 use Binary Insertion Sort\n    if len(lst) < 10:\n        sorted_lst = binary_insertion_sort(lst)\n    else:\n        # Else use Heap Sort\n        sorted_lst = [heapq.heappop(lst) for _ in range(len(lst))]\n\n    # Create a resultant list as per special order\n    result = []\n    while sorted_lst:\n        result.append(sorted_lst.pop(0))  # pop the smallest\n        if sorted_lst:\n            result.append(sorted_lst.pop(-1))  # pop the largest\n\n    return result", "def unique_BST_sort(lst):\n    '''\n    Upon a mixed assemblage of integers and real numbers, restore the list arrayed in a peculiar order employing Binary Search Tree (BST) tactic.\n    The arraying sequence should adhere to the following progression:\n    - Initiate with the least number.\n    - Subsequently recognize the apex numeric from the remaining.\n    - Proceed to decipher the least numerical not yet included from the remaining, and maintain this sequence.\n    \n    Demonstrations:\n    unique_BST_sort([1, 2, 3, 4]) == [1, 4, 2, 3]\n    unique_BST_sort([5, 5, 5, 5]) == [5, 5, 5, 5]\n    unique_BST_sort([]) == []\n    unique_BST_sort([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n    \n    # sort values in ascending order\n    lst.sort()\n    result = []\n    \n    while lst: \n        # Pop the smallest value and append it to the result list\n        result.append(lst.pop(0))\n        \n        # If there are values remaining, pop the largest value and append it to the result list\n        if lst:\n            result.append(lst.pop())\n            \n    return result"]}
{"task_id": "HumanEval/71", "problem": ["def triangle_area(side1, side2=None, side3=None):\n    \"\"\"\n    Given the sides of the triangle, compute the triangle's area.\n    For triangle_area(a) => a is the side of an equilateral triangle\n    For triangle_area(a, h) => a is the base and h is the height of isosceles triangle\n    For triangle_area(a, b, c) => a, b, c are the sides of the scalene triangle\n    \"\"\"\n    if side2 == None and side3 == None:\n        # equilateral triangle\n        # area = (sqrt(3)/4) * a^2\n        area = (math.sqrt(3) / 4) * pow(side1, 2)\n    elif side3 == None:\n        # isosceles triangle\n        # area = 1/2 * base * height\n        area = 0.5 * side1 * side2\n    else:\n        # scalene triangle\n        # from the sides, get the semi-perimeter (s = (a+b+c)/2)\n        # then plug it in Heron's formula: area = sqrt(s*(s-a)*(s-b)*(s-c))\n        # which gives the formula for the area of a triangle from its sides\n        semi_perimeter = (side1 + side2 + side3) / 2\n        area = math.sqrt(semi_perimeter * (semi_perimeter-side1) * (semi_perimeter-side2) * (semi_perimeter-side3))\n    \n    return area", "def triangle_area(side1, side2=None, side3=None):\n    \"\"\"\n    Given the sides of the triangle, compute the triangle's area.\n    For triangle_area(a) => a is the side of an equilateral triangle\n    For triangle_area(a, h) => a is the base and h is the height of isosceles triangle\n    For triangle_area(a, b, c) => a, b, c are the sides of the scalene triangle\n    \"\"\"\n    if side2 is None and side3 is None:\n        # equilateral triangle\n        # area = (sqrt(3)/4) * a^2\n        area = (math.sqrt(3) / 4) * pow(side1, 2)\n    elif side3 is None:\n        # isosceles triangle\n        # area = 1/2 * base * height\n        area = 0.5 * side1 * side2\n    else:\n        # scalene triangle\n        # from the sides, get the semi-perimeter (s = (a+b+c)/2)\n        # then plug it in Heron's formula: area = sqrt(s*(s-a)*(s-b)*(s-c))\n        # which gives the formula for the area of a triangle from its sides\n        semi_perimeter = (side1 + side2 + side3) / 2\n        area = math.sqrt(semi_perimeter * (semi_perimeter - side1) * (semi_perimeter - side2) * (semi_perimeter - side3))\n    \n    return area", "def triangle_area(a, b, c):\n    # Check to see if the sides are positive and create a valid triangle\n    if a <= 0 or b <= 0 or c <= 0:\n        print(\"Sides of a triangle must be positive.\")\n        return None\n    if a + b <= c or a + c <= b or b + c <= a:\n        print(\"The sum of any two sides of a triangle must exceed the third side.\")\n        return None\n\n    # Calculate the semi-perimeter\n    p = (a + b + c) / 2\n\n    # Calculate the area using Heron's formula\n    area = round(math.sqrt(p * (p - a) * (p - b) * (p - c)), 4)\n\n    # Check for minuscule area\n    if area < 0.0001:\n        return \"Warning: The area of the triangle is very small.\"\n\n    return area", "def validate_and_compute_area(a, b, c):\n    sides = sorted([a, b, c])\n    if sides[2] >= sides[0] + sides[1]: \n        # The triangle inequality theorem states that for any triangle, the sum of the lengths of any two sides must be greater than or equal to the length of the remaining side.\n        raise ValueError(\"The provided values do not form a valid triangle\")\n    \n    # Check the isosceles condition\n    if not (a == b or b == c or a == c):\n        raise ValueError(\"The provided values do not form an isosceles triangle\")\n\n    s = (a + b + c) / 2.0   # compute the semi perimeter\n    return math.sqrt(s * (s - a) * (s - b) * (s - c))", "def triangle_area(a, b, c):\n    \"\"\"Compute and return the area and the altitude of a triangle from its three side lengths\"\"\"\n    \n    # check if the sides can form a valid triangle\n    if a + b <= c or b + c <= a or a + c <= b:\n        return -1\n    \n    # check if the triangle is equilateral\n    if a == b == c:\n        return -1\n\n    # calculate semi-perimeter\n    s = (a + b + c) / 2\n\n    # calculate area using Heron's formula\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    area = round(area, 2)\n\n    # calculate altitude\n    # altitude = 2 * area / base\n    # assume c is the base for computing the altitude.\n    # for isosceles triangle, any side can be considered as base.\n    # for scalene triangle, the altitude varies with the chosen base.\n    altitude = 2 * area / c\n    altitude = round(altitude, 2)\n\n    return (area, altitude)"]}
{"task_id": "HumanEval/72", "problem": ["def will_it_fly(q,w):\n    '''\n    The function's purpose is to discern q's flight potential, return True if achievable, and False if not. For q to fly, it must fulfil two prerequisites: it must be palindromic and the total weights of its elements should not go beyond the maximum acceptable weight w.\n\n    Implement the function with error handling mechanisms. It should return a \"Non-numeric input\" error if it receives a non-numeric input, and a \"Non-sequence input\" error if it receives a non-sequence input.\n\n    Examples:\n    will_it_fly([1, 2], 5) \u279e False \n\n    will_it_fly([3, 2, 3], 1) \u279e False\n\n    will_it_fly([3, 2, 3], 9) \u279e True\n\n    will_it_fly([3], 5) \u279e True\n    \n    Error Cases:\n    will_it_fly([\"a\",\"b\",\"c\"], 5) \u279e \"Non-numeric input\"\n    \n    will_it_fly(123, 5) \u279e \"Non-sequence input\"\n    '''\n    # Handle Non-sequence input error\n    if not isinstance(q, (list, tuple, str)):\n        return \"Non-sequence input\"\n    \n    for i in q:\n        # Handle Non-numeric input error\n        if not isinstance(i, (int, float)):\n            return \"Non-numeric input\"\n    \n    return is_palindrome(q) and sum(q) <= w", "def will_it_fly(q, w):\n    # Check if list q is palindrome by comparing it to its reverse.\n    if q == q[::-1]:\n        # If it is, check if sum of elements of q is less than or equal to w\n        if sum(q) <= w:\n            return True\n        else:\n            return False\n    else:\n        return False", "def will_it_fly(q, w, n):\n    # Check if the list is a palindrome.\n    if q != q[::-1]:\n        return False\n\n    # Check if the sum of numbers is less than or equal to w.\n    if sum(q) > w:\n        return False\n    \n    # Check if the size of unique smallest numbers is equal to n.\n    if len(set(sorted(q)[:n])) != n:\n        return False\n    \n    return True", "def will_it_fly(q, w):\n    q_len = len(q)\n    \n    # Check if the list is palindromic\n    for i in range(q_len // 2):\n        if q[i] != q[q_len - 1 - i]:\n            return False\n    \n    # Check if the sum of its elements is less than or equal to w\n    if sum(q) > w:\n        return False\n    \n    return True", "def will_it_fly(q, w):\n    # Check if list is palindrome\n    if q == q[::-1]:\n        # Check if sum is less than or equal to w\n        if sum(q) <= w:\n            return True\n    return False"]}
{"task_id": "HumanEval/73", "problem": ["def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n        1. Perform rightward shifting operation as required.\n        2. Swap at most three pair of balls.\n        3. After the operations, elements smaller than the first element in the array should be odd in number.\n\n    Return True, if the array could be sorted, otherwise False. \n\n    Examples:\n    move_three_balls([3, 4, 5, 1, 2, 6]) => True\n    move_three_balls([1, 3, 5, 4, 2, 6]) => True\n    move_three_balls([1, 2, 3, 5, 4, 6]) => True\n    move_three_balls([5, 4, 3, 1, 2, 6]) => False\n\n    \"\"\"\n    if not arr:\n        return True\n\n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False", "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n    1. Perform rightward shifting operation as required.\n    2. Swap at most three pair of balls.\n    3. After the operations, elements smaller than the first element in the array should be odd in number.\n    \n    Return True, if the array could be sorted; otherwise, False. \n    \n    Examples:\n    move_three_balls([5, 4, 5, 1, 2, 6]) -> True\n    move_three_balls([1, 3, 5, 4, 2, 6]) -> True\n    move_three_balls([1, 2, 3, 5, 4, 6]) -> True\n    move_three_balls([5, 4, 3, 1, 2, 6]) -> False\n    \"\"\"\n    \n    if not arr:\n        return True\n    \n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False", "def test_bubble_sort():\n    # Empty array\n    arr = []\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != []:\n        print(\"Error: Bubble Sort failed on empty array.\")\n\n    # Array with duplicate values\n    arr = [4, 3, 2, 2, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 2, 3, 4]:\n        print(\"Error: Bubble Sort failed on array with duplicate values.\")\n\n    # Sorted array in descending order\n    arr = [5, 4, 3, 2, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 3, 4, 5]:\n        print(\"Error: Bubble Sort failed on sorted array in descending order.\")\n\n    # Random unsorted array\n    arr = [5, 3, 2, 4, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 3, 4, 5]:\n        print(\"Error: Bubble Sort failed on random unsorted array.\")", "def sort_by_binary_len(arr):\n    \"\"\"\n    Reorders an array of strictly positive integers according to\n    the length of their binary representations, in increasing order.\n    In instances of overlapping binary lengths, the array uses\n    decimal numerical values as the basis for establishing order.\n\n    The output produced should conform to the examples provided:\n    >>> sort_by_binary_len([1, 31, 15, 2, 7]) == [1, 2, 7, 15, 31]\n    >>> sort_by_binary_len([14, 58, 39, 41, 61]) == [14, 39, 41, 58, 61]\n    >>> sort_by_binary_len([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n\n    # Sort the array based on binary length and then value\n    return sorted(arr, key = lambda x: (bin(x)[2:], x))", "def test_unique_elements():\n    # Test case 1: Empty array\n    assert unique_elements([]) == []\n\n    # Test case 2: Array with all elements being the same\n    assert unique_elements([5, 5, 5, 5, 5]) == [5]\n\n    # Test case 3: Array with mix of positive and negative integers\n    assert unique_elements([1, 2, 3, 4, 5, 4, 3, 2, 1, -1, -2, -3, -4, -5]) == [1, 2, 3, 4, 5, -1, -2, -3, -4, -5]\n\n    # Test case 4: Array with no repeated elements\n    assert unique_elements([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\n    print(\"All test cases pass\")"]}
{"task_id": "HumanEval/74", "problem": ["def total_match(lst1, lst2, case_sensitive=False):\n    '''\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n    \n    The function also drop duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case_sensitive parameter to True.\n    \n    Should both iterables have an equal total character length, the function returns the first iterable.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    total_match(['hi world'], ['hi', ' w', 'or', 'ld']) \u279e ['hi', ' w', 'or', 'ld']\n    '''\n    import re\n\n    # Remove non-alphanumeric characters and possibly convert to lower case\n    lst1 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst1]\n    lst2 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst2]\n\n    # Eliminate duplicates, preserving the original order\n    lst1, lst2 = list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2))\n\n    # Determine which list has a less or equal total character count\n    return lst1 if sum(len(s) for s in lst1) <= sum(len(s) for s in lst2) else lst2", "def total_match(lst1, lst2, case_sensitive=False):\n    \"\"\"\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n\n    The function also drops duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case sensitive parameter to True.\n\n    Should both iterables have an equal total character length, the function returns the first iterable.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['HI', 'HI']) \u279e ['HI', 'HI']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'hi']) \u279e ['hi', 'hi']\n    total_match(['A'], ['1', '2', '3', '4', '5']) \u279e ['A']\n    total_match(['hi world'], ['hi', ' w', 'or', 'ld']) \u279e ['hi', ' w', 'or', 'ld']\n    \"\"\"\n\n    # Remove non-alphanumeric characters and possibly convert to lower case\n    lst1 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst1]\n    lst2 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst2]\n\n    # Eliminate duplicates, preserving the original order\n    lst1, lst2 = list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2))\n\n    # Determine which list has a less or equal total character count\n    return lst1 if sum(len(s) for s in lst1) <= sum(len(s) for s in lst2) else lst2", "def get_greeting():\n    current_time = datetime.datetime.now()\n    if current_time.hour < 12:\n        return random.choice(['Good morning', 'Hello', 'Hi there'])\n    elif 12 <= current_time.hour < 18:\n        return random.choice(['Good afternoon', 'Hello', 'Hi there'])\n    else:\n        return random.choice(['Good evening', 'Hello', 'Hi there'])", "def greeting_response(user_input):\n    greeting_inputs = ['hi', 'hello', 'hey', 'hola', 'greetings', 'wassup']\n    greeting_responses = ['Hello!', 'Hi there!', 'Hey!', 'Hi!', 'Hola!', 'Greetings!']\n    \n    for word in user_input.split():\n        if word.lower() in greeting_inputs:\n            return random.choice(greeting_responses)\n        \n    return None", "def greeting_response(user_input):\n    greeting_inputs = ['hi', 'hello', 'hey', 'hola', 'greetings', 'wassup']\n    greeting_responses = ['Hello!', 'Hi there!', 'Hey!', 'Hi!', 'Hola!', 'Greetings!']\n    \n    for word in user_input.split():\n        if word.lower() in greeting_inputs:\n            return random.choice(greeting_responses)\n        \n    return None"]}
{"task_id": "HumanEval/75", "problem": ["def is_multiply_prime(n):\n    \"\"\"Check if a number is the product of four distinct prime numbers.\"\"\"\n    # Generate a list of primes smaller than square root of n\n    primes = list(primerange(2, int(n**0.5) + 1))\n\n    # Check all possible combinations of four primes\n    for combo in combinations(primes, 4):\n        if combo[0]*combo[1]*combo[2]*combo[3] == n:\n            return True\n\n    return False", "def is_multiply_prime(a):\n    \"\"\"\n    Improved function to check if the acquired numeric value stems \n    from the product of three distinct prime integers. \n    \"\"\"\n    primes = get_distinct_primes(a)\n    return len(primes) == 3", "def is_multiply_prime(a):\n    \"\"\"Return if the input number is the product of five distinct prime numbers.\"\"\"\n\n    # List of factors\n    factors = []\n\n    # Factorization\n    for i in sympy.primerange(2, 5001):\n        if a % i == 0:  # if i is a factor of a\n            while a % i == 0:  # while i is still a factor of a\n                a /= i  # divide a by i to \"remove\" this factor from a\n            factors.append(i)  # it's guaranteed that i is a prime number here\n            if len(factors) > 5:  # no need to try further, a has too many different prime factors\n                return False\n\n    return len(factors) == 5", "def is_multiple(n):\n    \"\"\"\n    Function to check if a given number is a multiple of 3 or 5.\n    \n    Parameters: \n    n (int): The given number to check.\n    \n    Returns: \n    bool: True if number is a multiple of 3 or 5, False otherwise.\n    \"\"\"\n    return n % 3 == 0 or n % 5 == 0", "def is_divisible_by_3_and_5(number):\n    \"\"\"This function checks whether a number is divisible by 3 and 5.\n\n    Parameters: \n        number (int): The number to be checked.\n\t\n    Returns: \n        True if the number is divisible by both 3 and 5, False otherwise.\n    \"\"\"\n    if (number % 3 == 0) and (number % 5 == 0):\n        return True\n    else:\n        return False"]}
{"task_id": "HumanEval/76", "problem": ["def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n        1. Perform rightward shifting operation as required.\n        2. Swap at most three pair of balls.\n        3. After the operations, elements smaller than the first element in the array should be odd in number.\n\n    Return True, if the array could be sorted, otherwise False. \n\n    Examples:\n    move_three_balls([3, 4, 5, 1, 2, 6]) => True\n    move_three_balls([1, 3, 5, 4, 2, 6]) => True\n    move_three_balls([1, 2, 3, 5, 4, 6]) => True\n    move_three_balls([5, 4, 3, 1, 2, 6]) => False\n\n    \"\"\"\n    if not arr:\n        return True\n\n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False", "def exponential_diff(l: list, k: int, x: int, strict: bool = False) -> bool:\n    \"\"\"\n    Check if the difference between every two successive elements\n    in the list is the k'th power of x. \n    If the option 'strict' is true, no two neighboring elements can be the same; \n    otherwise, they can be. \n    The function returns true only when the difference between every two \n    successive elements is k raised to the power of x.\n\n    >>> exponential_diff([1, 2, 4, 8], 2, 1)\n    True\n    >>> exponential_diff([1, 2, 4, 16], 2, 2)\n    False\n    >>> exponential_diff([1, 3, 6, 27], 3, 2)\n    False\n    >>> exponential_diff([1, 1, 1, 1], 0, 0, strict=True)\n    True\n    \"\"\"\n    last = l[0]\n    for el in l[1:]:\n        if strict and el == last:\n            return False\n        if el - last != x ** k:\n            return False\n        last = el\n    return True", "def exponential_diff(l: list, k: int, x: int, strict: bool = False) -> bool:\n  \"\"\"\n  Check if the difference between every two successive elements \n  in the list is the k'th power of x. \n  If the option 'strict' is True, no two neighboring elements can be the same; \n  otherwise, they can be. \n  The function returns True only when the difference between every two \n  successive elements is k raised to the power of x.\n\n  >>> exponential_diff([1, 2, 4, 8], 2, 1)\n  True\n  >>> exponential_diff([1, 2, 4, 16], 2, 2)\n  False\n  >>> exponential_diff([1, 3, 9, 27], 3, 2)\n  False\n  >>> exponential_diff([1, 1, 1, 1], 0, 0, strict=False)\n  True\n  \"\"\"\n  last = l[0]\n  for el in l[1:]:\n    if strict and el == last:\n      return False\n    if el - last != k ** x:\n      return False\n    last = el\n  return True", "def is_prime(n: int) -> bool:\n    \"\"\"Return True if n is a prime number, False otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n%2 == 0:  # Exclude the even numbers > 2\n        return False\n    for x in range(3, int(sqrt(n)) + 1, 2):\n        if n % x == 0:\n            return False\n    return True", "def miller_rabin(n, k=5):  # number of tests to run\n    if n == 2 or n == 3:\n        return True\n    if n <= 1 or n % 2 == 0:\n        return False\n    \n    # write (n - 1) as 2^r * d\n    r, d = 0, n - 1\n    while d % 2 == 0:\n        r += 1\n        d //= 2\n    \n    # run k tests\n    for _ in range(k):\n        a = random.randint(2, n - 1)\n        x = pow(a, d, n)\n        if x == 1 or x == n - 1:\n            continue\n        for _ in range(r - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                break\n        else:\n            return False\n    return True"]}
{"task_id": "HumanEval/77", "problem": ["def Iscube(a):\n    a = abs(a)  # We are interested in the absolute value because cube root of both positive and negative numbers can be an integer.\n    root = round(a**(1/3)) # Calculate the cube root and round it to the nearest integer\n    return root**3 == a  # Return True if the cube of the nearest integer is equal to 'a'", "def check_if_prime(integer):\n    '''\n    This function takes an integer input and checks if it is a prime number or not.\n    '''\n    if integer > 1:\n        for i in range(2, integer):\n            if (integer % i) == 0:\n                return False\n        else:\n            return True\n    else:\n        return False", "def is_perfect_square(x):\n    \"\"\"Generates an affirmation for integers that are perfect squares, and a negation for integers that aren't.\n    >>> is_perfect_square(9)\n    True\n    >>> is_perfect_square(144)\n    True\n    >>> is_perfect_square(25)\n    True\n    >>> is_perfect_square(169)\n    True\n    >>> is_perfect_square(2)\n    False\n    >>> is_perfect_square(-9)\n    'Invalid input, please enter a positive integer.'\n    >>> is_perfect_square(0)\n    True\n    >>> is_perfect_square(1)\n    True\n    \"\"\"\n\n    if not isinstance(x, int) or x < 0:\n        return 'Invalid input, please enter a positive integer.'\n    \n    return int(x ** 0.5) ** 2 == x", "def is_prime(n: int) -> bool:\n    \"\"\"\n    Check if an input number is a prime number.\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(1)\n    False\n    >>> is_prime(0)\n    False\n    \"\"\"\n    if n == 0 or n == 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "def is_prime(n: int) -> bool:\n    \"\"\"\n    Check if an input number is a prime number.\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(1)\n    False\n    >>> is_prime(0)\n    False\n    \"\"\"\n    if n == 0 or n == 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"]}
{"task_id": "HumanEval/78", "problem": ["def enhanced_solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are at even positions.    \n\n    Examples\n    enhanced_solution([5, 8, 7, 1]) => 5\n    enhanced_solution([3, 3, 3, 3, 3]) => 9\n    enhanced_solution([30, 13, 24, 321]) => 30\n    \"\"\"\n    return sum(num for i, num in enumerate(lst[::2]) if num % 2 == 1)", "def is_prime(number):\n    if not isinstance(number, int) or number <= 1:\n        raise ValueError(\"Invalid input: Number must be a positive integer.\")\n    \n    # Check for small prime numbers\n    small_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    if number in small_primes:\n        return True\n    \n    # Check for divisibility by small primes\n    for prime in small_primes:\n        if number % prime == 0:\n            return False\n    \n    # Run probabilistic primality test (Miller-Rabin)\n    k = 5  # Number of iterations for accuracy\n    d = number - 1\n    s = 0\n    while d % 2 == 0:\n        d //= 2\n        s += 1\n    \n    for _ in range(k):\n        a = random.randint(2, number - 1)\n        x = pow(a, d, number)\n        \n        if x == 1 or x == number - 1:\n            continue\n        \n        for _ in range(s - 1):\n            x = pow(x, 2, number)\n            \n            if x == number - 1:\n                break\n        else:\n            return False\n    \n    return True", "def is_hex_color(s):\n    if len(s) != 7 and len(s) != 4:\n        # A valid hexadecimal color starts with '#' and followed by 3 or 6 hexadecimal numbers, so the length should be 4 or 7\n        return False\n\n    if s[0] != \"#\":\n        # A valid hexadecimal color starts with '#'\n        return False\n\n    # Check if all the other characters are hexadecimal\n    hex_chars = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f'}\n    return all(c in hex_chars for c in s[1:])", "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n        1. Perform rightward shifting operation as required.\n        2. Swap at most three pair of balls.\n        3. After the operations, elements smaller than the first element in the array should be odd in number.\n\n    Return True, if the array could be sorted, otherwise False. \n\n    Examples:\n    move_three_balls([3, 4, 5, 1, 2, 6]) => True\n    move_three_balls([1, 3, 5, 4, 2, 6]) => True\n    move_three_balls([1, 2, 3, 5, 4, 6]) => True\n    move_three_balls([5, 4, 3, 1, 2, 6]) => False\n\n    \"\"\"\n    if not arr:\n        return True\n\n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False", "def print_prime_numbers(start, end):\n    if start < 0 or end < 0:\n        raise ValueError(\"Both start and end numbers should be non-negative.\")\n    if end < start:\n        raise ValueError(\"End number should be greater than or equal to start number.\")\n    prime_numbers = []\n    for num in range(start, end + 1):\n        if is_prime(num):\n            prime_numbers.append(num)\n    if prime_numbers:\n        print(\"Prime numbers between\", start, \"and\", end, \"are:\")\n        for prime in prime_numbers:\n            print(prime)\n    else:\n        print(\"There are no prime numbers between\", start, \"and\", end)"]}
{"task_id": "HumanEval/79", "problem": ["def decimal_to_binary(n):\n    \"\"\"\n    Converts a decimal number to its binary representation.\n    \n    Args:\n        n (int): The decimal number to be converted.\n    \n    Returns:\n        str: The binary representation of the input decimal number.\n    \"\"\"\n    return bin(n).replace(\"0b\", \"\")", "def decimal_to_binary(num):\n    \"\"\"\n    This function will return a binary representation of a given decimal number.\n    \n    Parameters:\n    num: decimal number\n    \n    Returns:\n    binary representation of the number\n    \"\"\"\n    if num == 0:\n        return 0\n    \n    binary = \"\"\n    while (num > 0):\n        rem = num % 2\n        binary = str(rem) + binary\n        num = num//2\n    \n    return binary", "def find_index_of_first_occurrence(string, character):\n    '''\n    This function will find the index of the first occurrence of a given character in a string.\n\n    Args:\n        string (str): the string to be searched\n        character (str): the character to be searched for\n\n    Returns:\n        int: the index of the first occurrence of the character\n    '''\n    return string.find(character)", "def isPalindrome(string):\n    '''This function will return whether or not a string is a palindrome.'''\n\n    # Ensure that the input is a string and has at least one character\n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string.\")\n    if len(string) < 1:\n        raise ValueError(\"Input string must have at least one character.\")\n\n    # Ensure that the input string only contains alphabetic characters\n    if not string.isalpha():\n        raise ValueError(\"Input string must only contain alphabetic characters.\")\n\n    # Create a stack to store the characters in reverse order\n    stack = []\n\n    # Iterate through each character in the string and push it onto the stack\n    for char in string:\n        stack.append(char)\n\n    # Create a new string by popping each character from the stack\n    reversed_string = \"\"\n    while stack:\n        reversed_string += stack.pop()\n\n    # Compare the original string and the reversed string\n    return string == reversed_string", "def check_anagram_segments(text: str) -> bool:\n    \"\"\"\n    Given an input string, the function is intended to determine whether it is possible to \n    divide the string into two or more segments that are anagrams of one another. \n\n    Anagrams are words or phrases formed by reordering the letters of a different word or phrase, \n    typically using all the original letters exactly once.\n\n    The function counts the frequency of each unique character in the string and stores it in a dictionary. \n    If all frequencies are even number then the function returns True as the string can be divided into \n    two or more segments that are anagrams of one another. \n    \n    But if there is more than one character with an odd count frequency, then the function returns False\n    as it is not possible to divide the string into segments that are anagrams of one another. \n\n    Parameters:\n    text (str): The string to check for anagram segments\n\n    Returns:\n    bool: True if the string can be divided into anagram segments, False otherwise.\n\n    Examples:\n    \n    >>> check_anagram_samples('abcdefabcdegf')\n    True\n    >>> check_anagram_samples('helloworld')\n    False\n    \"\"\"\n\n    # count the frequency of each unique character in the string\n    frequency = {}\n    for char in text:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n\n    # count characters with odd count frequency\n    count_odd = sum(1 for count in frequency.values() if count % 2)\n\n    return count_odd <= 1"]}
{"task_id": "HumanEval/80", "problem": ["def is_happy(s):\n    \"\"\"\n    You are assigned a string s.\n    Ascertain whether the string is happy or not.\n    A string is described as happy if it is at least 3 characters long, each consolidative set of 3 characters are individual, every unique character appears no less than twice, and no character appears thrice in a direct sequence.\n    Additionally, the string is happy if all character sets of 3 or more contains at least 1 vowel and the string should not start or end with the same character.\n\n    For instance:\n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => False\n    is_happy(aabb) => False\n    is_happy(adbbd) => True\n    is_happy(xyzz) => False\n    is_happy(aoa) => True\n    \"\"\"\n    from collections import Counter\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    if len(s) < 3 or s[0] == s[-1]:\n        return False\n    counter = Counter(s)\n    for k, v in counter.items():\n        if v < 2 or v > 2:\n            return False\n    for i in range(len(s)-2):\n        if len(set(s[i:i+3])) != 3 or len(set(s[i:i+3]).intersection(vowels)) < 1:\n            return False\n    return True", "def is_happy(s):\n    \"\"\"\n    You are assigned a string s.\n    Ascertain whether the string is happy or not.\n    A string is described as happy if it is at least 3 characters long, each consecutive set of 3 characters are individual, \n    every unique character appears no less than twice, and no characters appears thrice in a direct sequence.\n    Additionally, the string is happy if all character sets of 3 or more contains at least 1 vowel \n    and the string should not start or end with the same character.\n\n    For instance:\n    is_happy(4) => False\n    is_happy(aa) => False\n    is_happy(abc) => False\n    is_happy(aabb) -> False\n    is_happy(aabba) -> True\n    is_happy(kyzz) -> False\n    is_happy(aba) => True\n    \"\"\"\n    from collections import Counter\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    if len(s) < 3 or s[0] == s[-1]:\n        return False\n    counter_ = Counter(s)\n    for x, u in counter_.items():\n        if u < 2 or u > 2:\n            return False\n    for i in range(len(s) - 2):\n        if len(set(s[i:i+3])) != 3 or len(set(s[i:i+3]).intersection(vowels)) < 1:\n            return False\n    return True", "def is_happy(s):\n    \"\"\"You are given a string s.\n    Determine if the string is happy or not.\n    A string is happy if its length is at least 3, each set of 3 sequential characters are unique,\n    every distinct character occurs at least twice, no character appears three times in a row,\n    and there is no number in the string.\"\"\"\n\n    # If length of string is less than 3 or there's a digit in the string, it's not happy\n    if len(s) < 3 or any(char.isdigit() for char in s):\n        return False\n\n    # Create a dictionary to keep count of characters\n    count_dict = {}\n    for ch in s:\n        if ch in count_dict:\n            count_dict[ch] += 1\n        else:\n            count_dict[ch] = 1\n\n    # If any character occurs only once or more than twice in a row, string is not happy\n    for ch in count_dict:\n        if count_dict[ch] < 2 or s.count(ch*3) > 0:\n            return False\n\n    # If there's any three sequential characters are not unique, string is not happy\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] == s[i + 2]:\n            return False\n\n    # String is happy\n    return True", "def is_happy(s):\n    \"\"\"You are given a string s.\n    Determine if the string is happy or not.\n    A string is happy if its length is at least 3, each set of 3 sequential characters are unique,\n    every distinct character occurs at least twice, no character appears three times in a row,\n    and there is no number in the string.\"\"\"\n    \n    # If length of string is less than 3 or there's a digit in the string, it's not happy\n    if len(s) < 3 or any(char.isdigit() for char in s):\n        return False\n\n    # Create a dictionary to keep count of characters\n    count_dict = {}\n    for ch in s: \n        if ch in count_dict: \n            count_dict[ch] += 1\n        else: \n            count_dict[ch] = 1\n\n    # If any character occurs only once or more than twice in a row, string is not happy\n    for ch in count_dict: \n        if count_dict[ch] < 2 or s.count(ch*3) > 0: \n            return False\n        \n    # If there's any three sequential characters are not unique, string is not happy\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] == s[i + 2]:\n            return False\n\n    # String is happy\n    return True", "def is_happy(s):\n    \"\"\" This function takes a string s as input and returns True if it represents happiness and False otherwise.\"\"\"\n    \n    # Check if the string contains only alphanumeric characters\n    if not s.isalnum():\n        return \"Invalid input string! Only alphanumeric characters are allowed.\"\n    \n    n = len(s)\n    \n    # The string must have at least a length of 3 for it to be happy\n    if n < 3: return False\n    \n    # Check that every group of three successive characters are distinct\n    for i in range(n-2):\n        if len(set(s[i:i+3])) != 3:\n            return False\n    \n    # Check that each discrete character appears not less than twice\n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    if min(char_count.values()) < 2:\n        return False\n     \n    # Check that no character appears three times consecutively\n    if re.search(r'(.)\\1\\1', s):\n        return False\n    \n    return True"]}
{"task_id": "HumanEval/81", "problem": ["def gpa_to_letter_grade(gpa):\n  if gpa >= 4.0:\n    return \"A\"\n  elif gpa >= 3.7:\n    return \"A-\"\n  elif gpa >= 3.3:\n    return \"B+\"\n  elif gpa >= 3.0:\n    return \"B\"\n  elif gpa >= 2.7:\n    return \"B-\"\n  elif gpa >= 2.3:\n    return \"C+\"\n  elif gpa >= 2.0:\n    return \"C\"\n  elif gpa >= 1.7:\n    return \"C-\"\n  elif gpa >= 1.3:\n    return \"D+\"\n  elif gpa >= 1.0:\n    return \"D\"\n  else:\n    return \"F\"", "def convert_letter_grade(grade):\n    grades = {\n        'A': 4.0,\n        'B': 3.0,\n        'C': 2.0,\n        'D': 1.0\n    }\n    return grades[grade]", "def count_zeros(matrix: List[List[int]], strict_zero: bool = False) -> int:\n    \"\"\"The data input is a matrix of integers. The task at hand is to devise a function which can quantify the zero occurrences in the matrix. An optional parameter 'strict_zero' has been added to the function to increase the level of difficulty. If this parameter is turned on (strict_zero=True), the function counts only true zeros, discarding any units that could potentially qualify as false in a boolean context like '' or False. If off (strict_zero=False), these units should also be categorized as zeros.\n\n    Examples:\n    >>> count_zeros([[1, 0, 3], [4, 0, 0]])\n    3\n    >>> count_zeros([[1, '', 3], [4, '0', '-0']])\n    0\n    >>> count_zeros([[1, '', 3], [4, '0', '-0']], False)\n    3\n    \"\"\"    \n    zero_count = 0\n    for row in matrix:\n        for num in row:\n            if (strict_zero and num == 0) or (not strict_zero and not num):\n                zero_count += 1\n    return zero_count", "def count_zeros(matrix: List[List[int]], strict_zero: bool = True) -> int:\n    \"\"\"\n    The data input is a matrix of integers. The task at hand is to devise a function which can quantify the zero occurrences in the matrix. \n    An optional parameter 'strict_zero' has been added to the function to increase the level of difficulty. If this parameter is turned on \n    (strict_zero=True), the function counts only true zeros, discarding any units that could potentially qualify as false in a boolean context \n    like '' or False. If off (strict_zero=False), these units should also be categorized as zeros.\n\n    Examples:\n    >>> count_zeros([[1, 0, 3], [4, 0, 0]]) \n    3 \n    >>> count_zeros([[1, '', 3], [4, '0', '=0']]) \n    0 \n    >>> count_zeros([[1, '', 3], [4, '0', '-0']], False) \n    5 \n    \"\"\"\n    zero_count = 0\n    for row in matrix:\n        for num in row:\n            if (strict_zero and num == 0) or (not strict_zero and not num):\n                zero_count += 1\n    return zero_count", "def longest(strings: List[str]) -> Optional[str]:\n    \"\"\" In a given list of strings, identify and return the string having the longest length. If there are several strings with the same lengths, return the one that appeared first. If the list has no elements, return None.\n\n    >>> longest([])\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n\n    if not strings: # check if the list is empty\n        return None\n\n    longest_string = strings[0]\n    for string in strings:\n        if len(string) > len(longest_string):\n            longest_string = string\n\n    return longest_string"]}
{"task_id": "HumanEval/82", "problem": ["def prime_length(string):\n    '''Determine if the string's length is a prime number'''\n    length = len(string)\n    if is_prime(length):\n        return True\n    else:\n        return False", "def prime_length(string):\n    \"\"\"Check if length of a string is a prime number.\"\"\"\n    length = len(string)\n    return is_prime(length)", "def prime_length(string):\n    \"\"\"Accept a string, get its length, and verify if \n    the length is a prime number.\"\"\"\n    length = len(string)\n    return is_prime(length)", "def prime_length(string):\n    return is_prime(len(string))", "def check_strings(strings):\n    if len(strings) == 0:\n        print(\"The list is empty.\")\n        return False\n    \n    for string in strings:\n        if not is_palindrome(string) or not is_prime(len(string)):\n            print(f\"The string '{string}' does not meet the criteria.\")\n            return False\n    \n    print(\"All strings in the list are palindromes and have a length that is a prime number.\")\n    return True"]}
{"task_id": "HumanEval/83", "problem": ["def proper_code(*args):\n    \"\"\"\n    Given single or multiple positive integers, check if any of them is a perfect square.\n    If at least one is a perfect square, create and test a function that returns the number of n-digit positive integers that start or end with 1.\n    Also, these numbers must be divisible by any three distinct prime numbers.\n    Return 'Not a perfect square.' if none of them is a perfect square.\n    \"\"\"\n    # Find first three prime numbers\n    primes = list(sympy.primerange(0,100))[:3]\n    for i in args:\n        if is_perfect_square(i):\n            # n is taken as the number of digits in the first perfect square found\n            n = len(str(i))\n            return num_start_end_with_1(n, primes)\n    return 'Not a perfect square.'", "def proper_code(*args):\n    \"\"\"\n    Given single or multiple positive integers, check if any of them is a perfect square. \n    If at least one is a perfect square, create and test a function that returns the number of n-digit positive integers that start or end with 1. \n    Also, these numbers must be divisible by any three distinct prime numbers. \n    Return 'Not a perfect square.' if none of them is a perfect square.\n    \"\"\"\n    # Find first three prime numbers\n    primes = list(sympy.primerange(0, 100))[:3]\n    for i in args:\n        if is_perfect_square(i):\n            # n is taken as the number of digits in the first perfect square found\n            n = len(str(i))\n            return num_start_end_with_1(n, primes)\n    return 'Not a perfect square.'", "def one_ends_divisible(n):\n    \"\"\"\n    Given a positive integer n, check if it's a perfect square.\n    If it's a perfect square, return the number of n-digit positive integers that start or end with 1 and are divisible by three distinct prime numbers.\n    If it's not a perfect square, return 'Not a perfect square.'\n    \"\"\"\n\n    if not is_perfect_square(n):\n        return 'Not a perfect square'\n\n    numbers_with_one_ends = all_n_digit_numbers_with_one_ends(n)\n\n    counts = 0\n\n    for num in numbers_with_one_ends:\n        factors = prime_factors(num)\n        if len(set(factors)) >= 3:\n            counts += 1\n\n    return counts", "def one_ends_divisible(n):\n    \"\"\"\n    Given a positive integer n, check if it's a perfect square. If it's a perfect square, \n    return the number of n-digit positive integers that start or end with 1 and are divisible by three distinct prime numbers.\n    If it's not a perfect square, return 'Not a perfect square.'\n    \"\"\"\n\n    if not is_perfect_square(n):\n        return 'Not a perfect square'\n\n    numbers_with_one_ends = all_n_digit_numbers_with_one_ends(n)\n    \n    counts = 0\n\n    for num in numbers_with_one_ends:\n        factors = prime_factors(num)\n        if len(set(factors)) >= 3:\n            counts += 1\n\n    return counts", "def starts_one_ends(n, x, y):\n    \"\"\"\n    Given a positive integer n, and two non-negative integers x,y; return the count of n-digit positive \n    integers that start and end with 1, are divisible by both 3 and 5, and do not contain x or y anywhere in the sequence.\n    \"\"\"\n    if n < 2:\n        return 0\n\n    dp = [0] * (n + 1)\n\n    forbidden = {str(x), str(y)}\n\n    dp[2] = 3  # 15, 51, 11\n\n    for i in range(3, n + 1):\n        dp[i] = 8 * dp[i - 1] - dp[i - 2]  # exclude numbers with forbidden digits\n        if '1' not in forbidden:\n            dp[i] += 2 ** (i - 2)\n        if '5' not in forbidden:\n            dp[i] += 2 ** (i - 2)\n\n    return dp[n]"]}
{"task_id": "HumanEval/84", "problem": ["def calculate_numbers(n):\n    # Check if input is positive integer\n    if not isinstance(n, int) or n <= 0:\n        return \"Input should be a positive integer\"\n  \n    # Convert number to list of digits\n    digits = [int(x) for x in str(n)]\n  \n    # Calculate cumulative total of digits\n    total = sum(digits)\n  \n    # Calculate sum of factorials of digits\n    factorial_sum = sum(math.factorial(i) for i in digits)\n  \n    return total, factorial_sum", "def calculate_numbers(n):\n    # Check if input is positive integer\n    if not isinstance(n, int) or n <= 0:\n        return \"Input should be a positive integer\"\n  \n    # Convert number to list of digits\n    digits = [int(x) for x in str(n)]\n  \n    # Calculate cumulative total of digits\n    total = sum(digits)\n  \n    # Calculate sum of factorials of digits\n    factorial_sum = sum(math.factorial(i) for i in digits)\n  \n    return total, factorial_sum", "def digit_product_sum(n):\n    \"\"\"\n    Calculate the sum and the product of the digits of a number.\n\n    Args:\n    n (int): A positive integer.\n\n    Returns:\n    Tuple: A tuple containing the product and the sum of the digits.\n    \"\"\"\n    product = 1\n    digit_sum = 0\n    for digit in str(n):\n        product *= int(digit)\n        digit_sum += int(digit)\n    return product, digit_sum, n", "def check_armstrong(number):\n    # Check if input is an integer\n    if not isinstance(number, int):\n        return \"The input must be an integer.\"\n    # Check if input is in range 1 to 10000\n    elif number < 1 or number > 10000:\n        return \"The input must be a positive integer between 1 and 10,000.\"\n    else:\n        # Convert integer to string to facilitate iteration over digits\n        digits = str(number)\n        num_digits = len(digits)\n        # Calculate sum of digits to the power of the number of digits\n        armstrong_sum = sum(int(digit)**num_digits for digit in digits)\n        # Check if number is equal to Armstrong sum\n        if number == armstrong_sum:\n            return True\n        else:\n            return False", "def check_armstrong(number):\n    # Check if input is an integer\n    if not isinstance(number, int):\n        return \"The input must be an integer.\"\n    # Check if input is in range 1 to 10000\n    elif number < 1 or number > 10000:\n        return \"The input must be a positive integer between 1 and 10,000.\"\n    else:\n        # Convert integer to string to facilitate iteration over digits\n        digits = str(number)\n        num_digits = len(digits)\n        # Calculate sum of digits to the power of the number of digits\n        armstrong_sum = sum(int(digit)**num_digits for digit in digits)\n        # Check if number is equal to Armstrong sum\n        if number == armstrong_sum:\n            return True\n        else:\n            return False"]}
{"task_id": "HumanEval/85", "problem": ["def enhanced_solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are at even positions.    \n\n    Examples\n    enhanced_solution([5, 8, 7, 1]) => 5\n    enhanced_solution([3, 3, 3, 3, 3]) => 9\n    enhanced_solution([30, 13, 24, 321]) => 30\n    \"\"\"\n    return sum(num for i, num in enumerate(lst[::2]) if num % 2 == 1)", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)", "def multiply(lst):\n    \"\"\"Given a populated array of integers, lst, compute the product of all odd numerals located at even indices within the array that are simultaneously multiples of 3. The indices of the array start at 0 (even).\n\n    Illustrative scenario (Correct):\n        multiply([3, 5, 7, 8, 9]) yields 27  \n    \"\"\"\n    result = 1\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 == 1 and lst[i] % 3 == 0:\n            result *= lst[i]\n    return result", "def multiply(lst):\n    \"\"\"Given a non-empty list of integers lst, perform multiple steps calculation to find the product of odd elements located at even indices. Ensure none of the elements in the list exceeds 100 and that you handle possible exceptions. Additionally, guarantee the final product does not exceed 5000.\n\n    Example\uff1a\n    multiply([3, 5, 7, 8, 6]) ==> 21\n    \"\"\"\n    if not lst:    # if list is empty \n        return \"Input list should not be empty.\"\n    if not all(type(i) == int for i in lst):    # if list has non-integer elements \n        return \"All elements of the input list should be integers.\"\n    if not all(0 <= i <= 100 for i in lst):    # if list has elements exceeding 100\n        return \"Elements of the list should not exceed 100.\"\n    try:\n        product = 1\n        for i in range(0, len(lst), 2):    # skipping 1 element i.e., considering elements at even indices\n            if lst[i] % 2 != 0:    # if the element is odd\n                product *= lst[i]\n            if product > 5000:    # if the product exceeds 5000\n                return \"Product exceeded 5000.\"\n        return product\n    except Exception as e:\n        return str(e)", "def multiply(lst):\n    \"\"\"Given a non-empty list of integers lst, perform multiple steps calculation to find the product of odd elements located at even indices. Ensure none of the elements in the list exceeds 100 and that you handle possible exceptions. Additionally, guarantee the final product does not exceed 5000.\n\n    Example\uff1a\n         multiply([3, 5, 7, 8, 9]) ==> 21\n    \"\"\"\n    if not lst:    # if list is empty \n        return \"Input list should not be empty.\"\n    if not all(type(i) == int for i in lst):    # if list has non-integer elements \n        return \"All elements of the input list should be integer.\"\n    if not all(0 <= i <= 100 for i in lst):    # if list has elements exceeding 100\n        return \"Elements of the list should not exceed 100.\"\n    try:\n        product = 1\n        for i in range(0, len(lst), 2):    # skipping 1 element i.e., considering elements at even indices\n            if lst[i] % 2 != 0:    # if the element is odd\n                product *= lst[i]\n                if product > 5000:    # if the product exceeds 5000\n                    return \"Product exceeded 5000.\"\n        return product\n    except Exception as e:\n        return str(e)"]}
{"task_id": "HumanEval/86", "problem": ["def anti_shuffle(s):\n    \"\"\"\n    Function that accepts a string and produces an ordered variant using the custom_sort function.\n    The ordered variant of a string is a new phrase where every word (partitioned by space) \n    is replaced by a new word where every character adheres to the custom_sort methodology.\n    The word and blank space sequence in the sentence remains unchanged.\n\n    Args: \n        s: string\n\n    Returns:\n        The modified string with each word sorted according to the rules of custom_sort\n    \"\"\"\n    \n    sorted_words = [custom_sort(word) for word in s.split(\" \")]\n    return ' '.join(sorted_words)", "def anti_shuffle(s):\n    \"\"\"\n    Function that accepts a string and produces an ordered variant using the custom sort function.\n    The ordered variant of a string is a new phrase where every word (partitioned by space)\n    is replaced by a new word where every character adheres to the custom sort methodology.\n    The word and blank space sequence in the sentence remains unchanged.\n\n    Args:\n    s: String\n\n    Returns:\n    The modified string with each word sorted according to the rules of custom_sort\n    \"\"\"\n\n    sorted_words = [custom_sort(word) for word in s.split(\" \")]\n    return ' '.join(sorted_words)", "def analyze_string(input_string):\n    \"\"\"This function takes an input string, checks the occurrence of 'hello world', \n        transmutes the string into capital letters if 'hello world' is found, finds \n        the starting and ending indices of 'hello world', and stores the result in \n        a JSON file.\n    \n    Args:\n        input_string (str): The string to analyze.\n        \n    Returns:\n        str: The updated string if 'hello world' is found.\n    \"\"\"\n    # Specify search pattern\n    pattern = 'hello world'\n    \n    # Find all occurrences of the pattern in the string\n    matches = [match.span() for match in re.finditer(pattern, input_string)]\n    \n    # If the pattern is found, change the string to upper case\n    if matches:\n        # Form the array to be stored in JSON\n        array = [{'start': start, 'end': end, 'count': i+1} \n            for i, (start, end) in enumerate(matches)]\n        \n        # Store the array into a JSON file\n        store_to_json(array, 'output.json')\n\n        input_string = input_string.upper()\n\n    return input_string", "def join_with_dash(line):\n    \"\"\"\n    Joins the words in the input string with a dash.\n\n    Args:\n    line (str): The input string containing words separated by spaces.\n\n    Returns:\n    str: A new string where the words are joined with a dash (\"-\") instead of spaces.\n    \"\"\"\n    return \"-\".join(line.split())", "def arrange_string(s):\n    \"\"\"\n    This function takes a string 's', splits it into words, applies the custom_order function to each word to sort the characters in it,\n    and then rejoins the sorted words back together with a space in between. The function preserves the original order of words \n    and blank spaces in the sentence.\n    \"\"\"\n\n    # Split the string into a list of words\n    words_list = s.split(' ')\n\n    # Apply the custom_order function to each word in the list\n    ordered_words_list = [custom_order(word) for word in words_list]\n\n    # Join the ordered words back together with a space in between to form a string\n    ordered_s = ' '.join(ordered_words_list)\n\n    return ordered_s"]}
{"task_id": "HumanEval/87", "problem": ["def get_row(lst, x):\n    result = []\n    for row_index, row in enumerate(lst):\n        for column_index, element in enumerate(row):\n            if element == x:\n                result.append((row_index, column_index))\n    result.sort(key=lambda a: (a[0], -a[1]))\n    return result", "def find_closest_elements(numbers: List[int]) -> Tuple[int, int, int]:\n    \"\"\"\n    In the given list of numbers, find and return the two closest numbers firstly the smaller number, \n    then the larger number and the frequency of the smallest difference.\n    For example:\n    find_closest_elements([1, 2, 3, 4, 5, 2])\n    Returns: (2, 2, 2)\n    find_closest_elements([1, 5, 2, 7, 6, 3])\n    Returns: (2, 3, 1)\n    \"\"\"    \n    numbers.sort()\n    pairs = [(numbers[i], numbers[i + 1]) for i in range(len(numbers) - 1)]\n    minimum = min(pair[1] - pair[0] for pair in pairs)\n    result = [pair for pair in pairs if pair[1] - pair[0] == minimum]\n    return result[0][0], result[0][1], len(result)", "def hybrid_sort_list_heap(lst):\n    '''\n    Given a list of integers and decimals, use a heap sort combined with binary insertion sort to arrange the list in a special order. The ordering should start with the smallest value, then the largest, then the smallest of the remaining values not yet included in the output, and continue doing this until all elements are sorted.\n\n    Examples:\n    hybrid_sort_list_heap([1, 2, 3, 4]) == [1, 4, 2, 3]\n    hybrid_sort_list_heap([5, 5, 5, 5]) == [5, 5, 5, 5]\n    hybrid_sort_list_heap([]) == []\n    hybrid_sort_list_heap([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # Make input list to a heap\n    heapq.heapify(lst)\n\n    # If the size of the list is less than 10 use Binary Insertion Sort\n    if len(lst) < 10:\n        sorted_lst = binary_insertion_sort(lst)\n    else:\n        # Else use Heap Sort\n        sorted_lst = [heapq.heappop(lst) for _ in range(len(lst))]\n\n    # Create a resultant list as per special order\n    result = []\n    while sorted_lst:\n        result.append(sorted_lst.pop(0))  # pop the smallest\n        if sorted_lst:\n            result.append(sorted_lst.pop(-1))  # pop the largest\n\n    return result", "def hybrid_sort_list_heap(lst):\n    '''\n    Given a list of integers and decimals, use a heap sort combined \n    with binary insertion sort to arrange the list in a special order. \n    The ordering should start with the smallest value, then the largest, \n    then the smallest of the remaining values not yet included in the output, \n    and continue doing this until all elements are sorted.\n\n    Examples:\n    hybrid_sort_list_heap([1, 2, 3, 4]) == [1, 4, 2, 3]\n    hybrid_sort_list_heap([5, 5, 5, 5]) == [5, 5, 5, 5]\n    hybrid_sort_list_heap([]) == []\n    hybrid_sort_list_heap([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # Make input list to a heap\n    heapq.heapify(lst)\n\n    # If the size of the list is less than 10 use Binary Insertion Sort\n    if len(lst) < 10:\n        sorted_lst = binary_insertion_sort(lst)\n    else:\n        # Else use Heap Sort\n        sorted_lst = [heapq.heappop(lst) for _ in range(len(lst))]\n\n    # Create a resultant list as per special order\n    result = []\n    while sorted_lst:\n        result.append(sorted_lst.pop(0))  # pop the smallest\n        if sorted_lst:\n            result.append(sorted_lst.pop(-1))  # pop the largest\n\n    return result", "def intersperse(numbers: List[Union[int, List[int]]], delimeter: Union[int, float]) -> List[int]:\n    \"\"\"\n    Introduce the 'delimeter' digit amongst every couple of sequential numbers in the supplied 'numbers' list.\n    Moreover, make sure to manage scenarios that involve a negative or non-integer `delimeter`.\n    Also handles nested list within numbers list.\n    For example:\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], -2)\n    [1, 2, 3]\n    >>> intersperse([1, [2, 3]], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], 4.5)\n    [1, 2, 3]\n    \"\"\"\n    outcome = []\n    flattened_numbers = []\n\n    # This block is to handle nested arrays and flatten them.\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimeter))  # recursive flatten\n        else:\n            flattened_numbers.append(num)\n\n    # This block is to place the delimeter (if it's a non-negative integer) in between the numbers.\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i < len(flattened_numbers) - 1 and isinstance(delimeter, int) and delimeter >= 0:\n            outcome.append(delimeter)\n\n    return outcome"]}
{"task_id": "HumanEval/88", "problem": ["def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n        1. Perform rightward shifting operation as required.\n        2. Swap at most three pair of balls.\n        3. After the operations, elements smaller than the first element in the array should be odd in number.\n\n    Return True, if the array could be sorted, otherwise False. \n\n    Examples:\n    move_three_balls([3, 4, 5, 1, 2, 6]) => True\n    move_three_balls([1, 3, 5, 4, 2, 6]) => True\n    move_three_balls([1, 2, 3, 5, 4, 6]) => True\n    move_three_balls([5, 4, 3, 1, 2, 6]) => False\n\n    \"\"\"\n    if not arr:\n        return True\n\n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False", "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n    1. Perform rightward shifting operation as required.\n    2. Swap at most three pair of balls.\n    3. After the operations, elements smaller than the first element in the array should be odd in number.\n    \n    Return True, if the array could be sorted; otherwise, False. \n    \n    Examples:\n    move_three_balls([5, 4, 5, 1, 2, 6]) -> True\n    move_three_balls([1, 3, 5, 4, 2, 6]) -> True\n    move_three_balls([1, 2, 3, 5, 4, 6]) -> True\n    move_three_balls([5, 4, 3, 1, 2, 6]) -> False\n    \"\"\"\n    \n    if not arr:\n        return True\n    \n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False", "def test_bubble_sort():\n    # Empty array\n    arr = []\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != []:\n        print(\"Error: Bubble Sort failed on empty array.\")\n\n    # Array with duplicate values\n    arr = [4, 3, 2, 2, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 2, 3, 4]:\n        print(\"Error: Bubble Sort failed on array with duplicate values.\")\n\n    # Sorted array in descending order\n    arr = [5, 4, 3, 2, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 3, 4, 5]:\n        print(\"Error: Bubble Sort failed on sorted array in descending order.\")\n\n    # Random unsorted array\n    arr = [5, 3, 2, 4, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 3, 4, 5]:\n        print(\"Error: Bubble Sort failed on random unsorted array.\")", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)", "def advanced_sort(l: list, n: int):\n    \"\"\"\n    This function accepts a list l, an integer n and returns a new resultant list l' that satisfies the next conditions:\n    l' equates l at indices not divisible by n; however at indices divisible by n, values parallel l's corresponding indices, but with the uniqueness of being multiplied by 2 and arranged in reverse.\n\n    >>> advanced_sort([1, 2, 3], 2)\n    [1, 2, 3]\n    >>> advanced_sort([5, 6, 3, 4, 8, 9, 2], 3)\n    [5, 6, 3, 2, 8, 9, 1]\n    >>> advanced_sort([8, 7, 4, 1, 3, 6, 5], 3)\n    [8, 7, 4, 5, 3, 6, 1]\n    \"\"\"\n\n    sublist = [val * 2 for i, val in enumerate(l) if i % n == 0]\n    sublist.sort(reverse=True)\n\n    new_list = l.copy()\n    index = 0\n    for i, val in enumerate(new_list):\n        if i % n == 0:\n            new_list[i] = sublist[index]\n            index += 1\n\n    return new_list"]}
{"task_id": "HumanEval/89", "problem": ["def encrypt(s, shift):\n    # The 'encryption' function implements the Caesar cipher for encoding\n    result = \"\"\n\n    for v in s:\n        # Check if character is an uppercase letter\n        if v.isupper():\n            # Encrypt character and preserve case\n            # The ord function returns the number representing the unicode character\n            # The chr function returns a string representing a character whose Unicode code point is the integer\n            result += chr((ord(v) - 65 + shift) % 26 + 65)\n\n        # Check if character is a lowercase letter\n        elif v.islower():\n            # Encrypt character and preserve case\n            result += chr((ord(v) - 97 + shift) % 26 + 97)\n\n        # Leave non-alphabet characters as they are\n        else:\n            result += v\n            \n    return result", "def encrypt(s, shift, seed=0):\n    \"\"\"Create a function named encrypt that accepts two parameters, a string and an integer for rotation. The function should return an encrypted string using a shuffled alphabet based on the input integer. It should handle case sensitivity and preserve non-alphabetic characters. It should also handle exceptions due to rotations exceeding the length of the alphabet.\"\"\"\n\n    # Define alphabet\n    lower_alphabet = string.ascii_lowercase\n    upper_alphabet = string.ascii_uppercase\n\n    # Introduce seed manipulation for more complexity\n    shift = (shift + seed) % 26\n\n    result = \"\"\n\n    for c in s:\n        # Support for unicode characters\n        if not c.isascii():\n            result += chr(ord(c) + shift)\n        # Preserve non-alphabetical characters\n        elif not c.isalpha():\n            result += c\n        else:\n            # Handle upper/lower-case characters differently for case sensitivity\n            if c.isupper():\n                result += upper_alphabet[(upper_alphabet.index(c) + shift) % 26]\n            else:\n                result += lower_alphabet[(lower_alphabet.index(c) + shift) % 26]\n\n    return result", "def encrypt_caesar(plaintext, shift):\n    \"\"\"\n    Encrypts a plaintext string using the Caesar cipher.\n\n    Args:\n        plaintext: The plaintext to encrypt.\n        shift: The number of characters to shift by.\n\n    Returns:\n        The ciphertext.\n    \"\"\"\n    alphabet = string.ascii_lowercase\n    shifted_alphabet = alphabet[shift:] + alphabet[:shift] \n    table = str.maketrans(alphabet, shifted_alphabet) \n    ciphertext = plaintext.translate(table)\n    return ciphertext", "def cipher(s):\n    \"\"\"Derive a python function called 'cipher' that takes a string parameter and returns a ciphered string utilizing a rotated alphabet (the alphabet is shifted three positions ahead, using the modulo operator in Python to handle wrapping at the ends). This function should conserve the case of the characters (upper and lower), keep the non-alphabetical characters unchanged in the derived output, and work for all characters of the lower case and uppercase English alphabets. Here are some examples:\n    cipher('Hi') renders 'Lm'\n    cipher('aSdFgHjKl') tends to become 'dUgIjLmNpQr'\n    cipher('Zx112e_') translates to 'Ca!I23h_'\n    cipher('E.x + Uz') is turned into 'H.a + Xc'\n    \"\"\"\n    result = ''\n\n    for char in s:\n    # preserve the non-alphabetical characters\n        if not char.isalpha():\n            result += char\n            continue\n\n    # shift three positions ahead, with case consideration\n        shifted_char = chr((ord(char.lower()) - 97 + 3) % 26 + 97) if char.islower() else chr((ord(char.upper()) - 65 + 3) % 26 + 65)\n        result += shifted_char\n\n    return result", "def cipher(s):\n    \"\"\"Derive a python function called 'cipher' that takes a string parameter and returns a ciphered string utilizing a rotated alphabet (the alphabet is shifted three positions ahead, using the modulo operator in Python to handle wrapping at the ends). This function should conserve the case of the characters (upper and lower), keep the non-alphabetical characters unchanged in the derived output, and work for all characters of the lower case and uppercase English alphabets. Here are some examples:\n    cipher('Hi') renders 'Lm'\n    cipher('aSdFgHjKl') tends to become 'dVgIjKmNpQr'\n    cipher('Zx!123_') translates to 'Ca!123_'\n    cipher('E.T + Ux') is turned into 'H.Y + Xc'\n    \"\"\"\n    result = ''\n    \n    for char in s:\n        # preserve the non-alphabetical characters\n        if not char.isalpha():\n            result += char\n            continue\n\n        # shift three positions ahead, with case consideration\n        shifted_char = chr((ord(char.lower()) - 97 + 3) % 26 + 97) if char.islower() else chr((ord(char.upper()) - 65 + 3) % 26 + 65)\n        result += shifted_char\n\n    return result"]}
{"task_id": "HumanEval/90", "problem": ["def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    smallest = float('inf')\n    next_smallest = float('inf')\n    for i in range(0, len(lst)):\n        if lst[i] < smallest:\n            next_smallest = smallest\n            smallest = lst[i]\n        elif lst[i] > smallest and lst[i] < next_smallest:\n            next_smallest = lst[i]\n    return None if next_smallest == float('inf') else next_smallest", "def uncommon_elements(sequence):\n    '''\n    Design a function that accepts a non-empty list composed of positive integers and returns a list of distinct integers whose frequency surpasses half of the integer's numerical value. Here, 'frequency' denotes the number of times a specific integer appears within the list.\n    If no integers satisfy these conditions, the function should return an empty list.\n    Examples:\n        uncommon_elements([4, 1, 2, 2, 3, 1]) should yield [2, 3]\n        uncommon_elements([1, 2, 2, 3, 3, 3, 4, 4, 4]) should yield [2, 3, 4]\n        uncommon_elements([5, 5, 4, 4, 4]) should yield [4]\n    '''\n    from collections import Counter\n    count = Counter(sequence)\n    result = []\n    for num, freq in count.items():\n        if freq > num/2:\n            result.append(num)\n    return result", "def strange_sort_list_bst(lst):\n    '''\n    This function should accept a list of integers and decimal_numbers and return the list in a specific pattern, leveraging the principles of a binary search tree. The steps to this peculiar_sorting pattern should be:\n    - Commence with the smallest number.\n    - Next, identify the highest value from the remaining elements.\n    - Then, ascertain the lowest_value among the untouched output, and continue in this manner.\n\n    Examples:\n    strange_sort_list_bst([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list_bst([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list_bst([]) == []\n    strange_sort_list_bst([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # First, we will sort the list in ascending_order.\n    lst.sort()\n\n    output = []\n\n    # Then, while lst is not empty, we will remove and append to output the smallest\n    # and largest element alternately.\n    while lst:\n        output.append(lst.pop(0))  # smallest\n        if lst:\n            output.append(lst.pop(-1))  # largest\n\n    return output", "def strange_sort_list_bst(lst):\n    '''\n    This function should accept a list of integers and decimal numbers and return the list in a specific pattern, leveraging the principles of a binary search tree. The steps for this peculiar sorting pattern should be:\n    - Commence with the smallest number.\n    - Next, identify the highest value from the remaining elements.\n    - Then, ascertain the lowest value among the untouched output, and continue in this manner.\n    \n    Examples:\n    strange_sort_list_bst([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list_bst([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list_bst([]) == []\n    strange_sort_list_bst([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n    \n    # First, we will sort the list in ascending order.\n    lst.sort()\n\n    output = []\n\n    # Then, while lst is not empty, we will remove and append to output the smallest\n    # and largest element alternatively.\n    while lst:\n        output.append(lst.pop(0))  # smallest\n        if lst:\n            output.append(lst.pop(-1))  # largest\n\n    return output", "def enhanced_solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are at even positions.    \n\n    Examples\n    enhanced_solution([5, 8, 7, 1]) => 5\n    enhanced_solution([3, 3, 3, 3, 3]) => 9\n    enhanced_solution([30, 13, 24, 321]) => 30\n    \"\"\"\n    return sum(num for i, num in enumerate(lst[::2]) if num % 2 == 1)"]}
{"task_id": "HumanEval/91", "problem": ["def count_sentences(s):\n    \"\"\"Develop a function named 'count_sentences', that takes a string as an input,\n    and returns the count of sentences contained within that string. The function should assume that \n    sentences are separated by full stops ('.'). However, the full stops within abbreviations or decimal \n    numbers should not be considered as sentence endings.\n\n    Example:\n    >>> count_sentences(\"Hello. World.\")\n    2\n    >>> count_sentences(\"This is Dr. Smith.\")\n    1\n    >>> count_sentences(\"The cost is $2.5.\")\n    1\n    \"\"\"\n\n    try:\n      # Using regular expressions to count the number of sentences in a string.\n      # Ignore abbreviations or decimal numbers during counting.\n      count = len(re.findall(r\"[A-Z][^.!?]*[.!?]\", s, re.IGNORECASE))\n    except TypeError as e:\n      # Catching & handling the error if the input is not a string.\n      print(f\"TypeError: {e}\")\n      print(\"The input provided should be a string. Please provide a string input and try again.\")\n    except Exception as e:\n      # Handle other types of exceptions.\n      print(f\"An error occurred: {e}\")\n    else:\n      # If no exception is raised, then it returns the count of sentences.\n      return count", "def count_sentences(s):\n    \"\"\"Develop a function named 'count_sentences', that takes a string as an input,\n    and returns the count of sentences contained within that string. The function should assume that \n    sentences are separated by full stops ('.'). However, the full stops within abbreviations or decimal \n    numbers should not be considered as sentence endings.\n\n    Example:\n    >>> count_sentences(\"Hello. World.\")\n    2\n    >>> count_sentences(\"This is Dr. Smith.\")\n    1\n    >>> count_sentences(\"The cost is $2.5.\")\n    1\n    \"\"\"\n\n    try:\n        # Using regular expressions to count the number of sentences in a string.\n        # Ignore abbreviations or decimal numbers during counting.\n        count = len(re.findall(r\"[A-Z][^.!?]*[.!?]\", s, re.IGNORECASE))\n    except TypeError as e:\n        # Catching & handling the error if the input is not a string.\n        print(f\"TypeError: {e}\")\n        print(\"The input provided should be a String. Please provide a String input and try again.\")\n    except Exception as e:\n        # Handle other types of exceptions.\n        print(f\"An error occurred: {e}\")\n    else:\n        # If no exception is raised, then it returns the count of sentences.\n        return count", "def word_count(s):\n    \"\"\"Craft a function named word_count, which takes a string as input, \n    and computes the total quantity of words that the string contains. A word \n    is identified as a separate entity partitioned by whitespaces. Case sensitivity is ignored, \n    however, special characters within words are included. \n\n    Example:\n    >>> word_count(\"Hello World\")\n    2\n    >>> word_count(\"This is a sentence.\")\n    4\n    >>> word_count(\"\u00e1nother_ex\u00e4mple\")\n    1\n    \"\"\"\n    if type(s) != str:      # makesure the input is a string\n        return \"Error: Input should be a string\"\n        \n    if s.strip()==\"\":       # checks if the string is not empty or just whitespaces\n        return 0\n            \n    words = re.findall(r'\\S+', s)      # finds all the separate words using regular expression\n    return len(words)", "def word_count(s):\n    \"\"\"Define a function word_count, that accepts a string as an input, \n    provides the total count of words present within the string. Words \n    are identified as separate entities divided by whitespaces, including\n    leading, trailing and multiple consecutive whitespaces. The case is \n    disregarded but include special characters within the words. \n\n    Check for None and non-string input types and return appropriate \n    error message.\n\n    Example:\n    >>> word_count(\"Hello World\")\n    2\n    >>> word_count(\"This is a sentence.\")\n    4\n    >>> word_count(\"\u00e1nother_ex\u00e4mple\")\n    1\n    >>> word_count(\" Leading and trailing  white  spaces \")\n    5\n    >>> word_count(None)\n    'Error: Input is None'\n    >>> word_count(1234)\n    'Error: Input should be a string'\n    \"\"\"\n    if s is None:\n        return 'Error: Input is None'\n    elif type(s) != str:\n        return 'Error: Input should be a string'\n\n    # Removing leading and trailing whitespaces \n    # and replacing multiple consecutive whitespaces with a single space\n    s = ' '.join(s.split())\n                      \n    return len(s.split(' '))", "def is_bored(S):\n    # Splitting the string into sentences\n    sentences = [sentence.strip() for sentence in re.split('[.!?]', S) if sentence.strip()]\n    \n    # Initializing the counter variables\n    boring_count = 0\n    exciting_count = 0\n    \n    # Evaluating each sentence\n    for sentence in sentences:\n        if sentence.startswith(\"I\"):\n            boring_count += 1\n        if sentence.endswith(\"!\"):\n            exciting_count += 1\n    \n    return (boring_count, exciting_count)"]}
{"task_id": "HumanEval/92", "problem": ["def will_it_fly(q,w):\n    '''\n    The function's purpose is to discern q's flight potential, return True if achievable, and False if not. For q to fly, it must fulfil two prerequisites: it must be palindromic and the total weights of its elements should not go beyond the maximum acceptable weight w.\n\n    Implement the function with error handling mechanisms. It should return a \"Non-numeric input\" error if it receives a non-numeric input, and a \"Non-sequence input\" error if it receives a non-sequence input.\n\n    Examples:\n    will_it_fly([1, 2], 5) \u279e False \n\n    will_it_fly([3, 2, 3], 1) \u279e False\n\n    will_it_fly([3, 2, 3], 9) \u279e True\n\n    will_it_fly([3], 5) \u279e True\n    \n    Error Cases:\n    will_it_fly([\"a\",\"b\",\"c\"], 5) \u279e \"Non-numeric input\"\n    \n    will_it_fly(123, 5) \u279e \"Non-sequence input\"\n    '''\n    # Handle Non-sequence input error\n    if not isinstance(q, (list, tuple, str)):\n        return \"Non-sequence input\"\n    \n    for i in q:\n        # Handle Non-numeric input error\n        if not isinstance(i, (int, float)):\n            return \"Non-numeric input\"\n    \n    return is_palindrome(q) and sum(q) <= w", "def total_match(lst1, lst2, case_sensitive=False):\n    \"\"\"\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n\n    The function also drops duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case sensitive parameter to True.\n\n    Should both iterables have an equal total character length, the function returns the first iterable.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['HI', 'HI']) \u279e ['HI', 'HI']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'hi']) \u279e ['hi', 'hi']\n    total_match(['A'], ['1', '2', '3', '4', '5']) \u279e ['A']\n    total_match(['hi world'], ['hi', ' w', 'or', 'ld']) \u279e ['hi', ' w', 'or', 'ld']\n    \"\"\"\n\n    # Remove non-alphanumeric characters and possibly convert to lower case\n    lst1 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst1]\n    lst2 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst2]\n\n    # Eliminate duplicates, preserving the original order\n    lst1, lst2 = list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2))\n\n    # Determine which list has a less or equal total character count\n    return lst1 if sum(len(s) for s in lst1) <= sum(len(s) for s in lst2) else lst2", "def total_match(lst1, lst2, case_sensitive=False):\n    '''\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n    \n    The function also drop duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case_sensitive parameter to True.\n    \n    Should both iterables have an equal total character length, the function returns the first iterable.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    total_match(['hi world'], ['hi', ' w', 'or', 'ld']) \u279e ['hi', ' w', 'or', 'ld']\n    '''\n    import re\n\n    # Remove non-alphanumeric characters and possibly convert to lower case\n    lst1 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst1]\n    lst2 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst2]\n\n    # Eliminate duplicates, preserving the original order\n    lst1, lst2 = list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2))\n\n    # Determine which list has a less or equal total character count\n    return lst1 if sum(len(s) for s in lst1) <= sum(len(s) for s in lst2) else lst2", "def sum_even_numbers(numbers):\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The sum of all even numbers in the list. Returns 0 if the list is empty or does not contain any even numbers.\n\n    Examples:\n    >>> sum_even_numbers([1, 2, 3, 4, 5, 6])\n    12\n    >>> sum_even_numbers([1, 3, 5, 7])\n    0\n    >>> sum_even_numbers([])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)", "def sum_of_even_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers: A list of integers.\n\n    Returns:\n    The sum of all even numbers in the list.\n    \n    Examples:\n    >>> sum_of_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    30\n    >>> sum_of_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_of_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)"]}
{"task_id": "HumanEval/93", "problem": ["def vowels_count(s):\n    \"\"\"\n    A function that accepts a string that represents a word as an input parameter \n    and returns a count of all vowels it contains. The vowels include 'a', 'e', 'i', \n    'o', 'u', and 'y' (if it is at the end of the input word). It does not consider \n    case sensitivity and handles atypical characters contained in the input word.\n\n    The function has also been modified to handle cases where the input might not be \n    a string. In such situations, it raises a TypeError with an appropriate error \n    message. Moreover, it handles accentuated vowels.\n\n    Test Cases:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDV\")\n    3\n    >>> vowels_count(\"\u00e9xanpl\u00eb\")\n    5\n    >>> vowels_count(12345)\n    Traceback (most recent call last):\n    ...\n    TypeError: The input must be a string.\n    \"\"\"\n\n    if not isinstance(s, str):\n        raise TypeError('The input must be a string.')\n\n    vowels = \"aeiouyAEIOUY\"\n    accented_vowels = \"\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f2\u00f3\u00f4\u00f5\u00f6\u00f9\u00fa\u00fb\u00fc\u00fd\u00ff\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d2\u00d3\u00d4\u00d5\u00d6\u00d9\u00da\u00db\u00dc\u00dd\"\n    last_character = s[-1] if s else ''\n    return sum(1 for c in s if c in vowels or c in accented_vowels) + (1 if last_character == 'y' else 0)", "def vowels_count(s):\n    \"\"\"\n    A function that accepts a string that represents a word as an input parameter \n    and returns a count of all vowels it contains. The vowels include 'a', 'e', 'i', \n    'o', 'u', and 'y' (if it is at the end of the input word). It does not consider \n    case sensitivity and handles atypical characters contained in the input word.\n\n    The function has also been modified to handle cases where the input might not be \n    a string. In such situations, it raises a TypeError with an appropriate error \n    message. Moreover, it handles accentuated vowels.\n\n    Test Cases:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"\u00e9xampl\u00eb\")\n    5\n    >>> vowels_count(12345)\n    Traceback (most recent call last):\n      ...\n    TypeError: The input must be a string.\n    \"\"\"\n\n    if not isinstance(s, str):\n        raise TypeError('The input must be a string.')\n        \n    vowels = \"aeiouyAEIOUY\"\n    accented_vowels = \"\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f2\u00f3\u00f4\u00f5\u00f6\u00f9\u00fa\u00fb\u00fc\u00fd\u00ff\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d2\u00d3\u00d4\u00d5\u00d6\u00d9\u00da\u00db\u00dc\u00dd\"\n    last_character = s[-1] if s else ''\n    return sum(1 for c in s if c in vowels or c in accented_vowels) - (1 if last_character == 'y' else 0)", "def get_closest_vowel(word):\n    \"\"\"Insert a word, and then retrieve the nearest vowel that is ensconced amid a pair of consonants, \n    starting from the right section of the word, while being case-sensitive. \n    Bypass vowels at either the genesis or finale of the word. \n    Respond with a vacant string if such a vowel is nonexistent. \n    Presume that the input string is comprised strictly of English letters.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\n\n    vowels = 'aeiouAEIOU'\n    for i in reversed(range(1, len(word) - 1)): #not including the first and the last characters\n        if (word[i] in vowels) and (word[i - 1] not in vowels) and (word[i + 1] not in vowels):\n            return word[i]\n    return ''", "def get_closest_vowel(word):\n    \"\"\"Input a word and then find out the vowel closest from the right side of the word that is \n    between two consonants, distinguishing between upper and lower case. Ignore vowels at the \n    beginning or end of the word. If this kind of vowel does not exist, return an empty string. \n    Assume that the input string only contains English letters.\n\n    Examples:\n    get_closest_vowel(\"yogurt\") => \"u\"\n    get_closest_vowel(\"FULL\") => \"U\"\n    get_closest_vowel(\"quick\") => \"\"\n    get_closest_vowel(\"ab\") => \"\"\n    \"\"\"\n\n    # First, strip any vowels from the beginning and end of the word,\n    while len(word) > 0 and (word[0] in 'aeiouAEIOU' or word[-1] in 'aeiouAEIOU'):\n        if word[0] in 'aeiouAEIOU':\n            word = word[1:]\n\n        if len(word) > 0 and word[-1] in 'aeiouAEIOU':\n            word = word[:-1]\n\n    # Then, find the closest vowel sequence from the right side,\n    for i in range(len(word)-1, -1, -1):\n        if word[i] in 'aeiouAEIOU':\n            return word[i]\n    return \"\"", "def check_str(string):\n    '''\n    This function takes a string as input and checks if it contains all letters of the \n    English alphabet (a-z).\n    '''\n\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    for letter in alphabet:\n        if letter not in string.lower():\n            return False\n    return True"]}
{"task_id": "HumanEval/94", "problem": ["def get_product_array(lst):\n    # Initialize a variable to keep track of the product\n    right_product = 1\n    # Initialize an array of ones with the same size as the input\n    output = [1] * len(lst)\n    \n    # Calculate the product of the numbers before the current index\n    for i in range(1, len(lst)):\n        output[i] = output[i - 1] * lst[i - 1]\n   \n    # Calculate the product of the numbers after the current index\n    for i in range(len(lst) - 1, -1, -1):\n        output[i] *= right_product\n        right_product *= lst[i]\n    \n    return output", "def generate_comma_separated_string(lst):\n    # Selection sort\n    for i in range(len(lst)):\n        min_idx = i\n        for j in range(i+1, len(lst)):\n            # Compare lengths first\n            if len(lst[j]) < len(lst[min_idx]):\n                min_idx = j\n            # If lengths are equal, compare alphabetically\n            elif len(lst[j]) == len(lst[min_idx]) and lst[j] < lst[min_idx]:\n                min_idx = j\n        # Swap elements\n        lst[i], lst[min_idx] = lst[min_idx], lst[i]\n\n    # Generate comma-separated string\n    output = \"\"\n    for i in range(len(lst)):\n        output += lst[i] + \",\"\n    output = output.lower().strip(\",\")\n\n    return output", "def findMedian(lst):\n    # Checking if input is a list\n    if not isinstance(lst, list):\n        raise TypeError(\"Input should be a list of integers.\")\n    # Checking if list contains integers\n    for i in lst:\n        if not isinstance(i, int):\n            raise ValueError(\"All elements in the list should be integers.\")\n\n    # Sorting the list \n    lst.sort()\n\n    # Calculating median\n    n = len(lst)\n    if n % 2 == 0:  # if even\n        median1 = lst[n//2]\n        median2 = lst[n//2 - 1]\n        median = (median1 + median2)/2\n    else:\n        median = lst[n//2]\n\n    return median", "def sort_method(lst):\n    minHeap = []\n    maxHeap = []\n\n    # Push all elements into minHeap, this will cause an error in the final output\n    for num in lst:\n        heapq.heappush(maxHeap, num)\n    \n    # Note the deliberate error: minHeap.pop() should be maxHeap.pop() and vice versa\n    result = [heapq.heappop(minHeap) if i % 2 == 0 else -heapq.heappop(maxHeap) for i in range(len(lst))]\n\n    return result", "def array_to_dict(lst):\n    output = {}\n    for i in range(0, len(lst), 2):\n        output[lst[i]] = lst[i+1]\n \n    return output"]}
{"task_id": "HumanEval/95", "problem": ["def distorted_compare_word_sets(phrase1: str, phrase2: str):\n    \"\"\"\n    Determine if two phrases have the identical word set with multiple constraints including word duplicity, case sensitivity, and punctuation.\n    >>> distorted_compare_word_sets(\"Apple, Banana: Orange!\", \"orange apple Banana\")\n    False\n    >>> distorted_compare_word_sets(\"apple banana\", \"Apple, Orange BaNaNa!\")\n    False\n    >>> distorted_compare_word_sets(\"ApPle!\", \"appLE, Apple\")\n    True\n    >>> distorted_compare_word_sets(\"Banana?\", \"Apple BaNana!\")\n    False\n    >>> distorted_compare_word_sets(\"Apple BaNana Orange.\", \"Orange, BanaNa grape!\")\n    False\n    \"\"\"\n\n    # Remove punctuation, convert to lowercase and split by space\n    phrase1_words = set(phrase1.translate(str.maketrans(\"\", \"\", string.punctuation)).lower().split(\" \"))\n    phrase2_words = set(phrase2.translate(str.maketrans(\"\", \"\", string.punctuation)).lower().split(\" \"))\n\n    # Return comparison result\n    return phrase1_words == phrase2_words", "def verify_same_word_sets_freqs(phrase1: str, phrase2: str):\n    \"\"\"\n    >>> verify_same_word_sets_freqs(\"Apple Banana Orange\", \"Orange Apple Banana\")\n    True\n    >>> verify_same_word_sets_freqs(\"apple banana\", \"Apple Orange BaNaNa\")\n    False\n    >>> verify_same_word_sets_freqs(\"ApPle\", \"appLE Apple\")\n    False\n    >>> verify_same_word_sets_freqs(\"Banana Apple\", \"Apple BaNana\")\n    True\n    >>> verify_same_word_sets_freqs(\"Apple BaNana Orange\", \"Orange BanaNa grape\")\n    False\n    \"\"\"\n    map1 = Counter(phrase1.lower().split())\n    map2 = Counter(phrase2.lower().split())\n    return map1 == map2", "def validate_data_set(data):\n    required_keys = [\"country\", \"capital\", \"population\"]\n    for key in required_keys:\n        if key not in data:\n            print(f\"Key: {key} is missing in the data set.\")\n            return False\n\n    if not isinstance(data[\"country\"], str):\n        print(f\"Value of key: country should be a string.\")\n        return False\n    if not isinstance(data[\"capital\"], str):\n        print(f\"Value of key: capital should be a string.\")\n        return False\n    if not isinstance(data[\"population\"], str):\n        print(f\"Value of key: population should be a string.\")\n        return False\n    \n    return True", "def validate_data_set(data):\n    required_keys = [\"country\", \"capital\", \"population\"]\n    for key in required_keys:\n        if key not in data:\n            print(f\"Key: {key} is missing in the data set.\")\n            return False\n\n    if not isinstance(data[\"country\"], str):\n        print(f\"Value of key: country should be a string.\")\n        return False\n    if not isinstance(data[\"capital\"], str):\n        print(f\"Value of key: capital should be a string.\")\n        return False\n    if not isinstance(data[\"population\"], str):\n        print(f\"Value of key: population should be a string.\")\n        return False\n    \n    return True", "def construct_json(name, age, address=None, job_title=None, contact_details=None):\n    if not name or not age:\n        return json.dumps({'error': 'Name and Age parameters are required!'})\n\n    if not isinstance(name, str):\n        return json.dumps({'error': 'Invalid name. Name should be a string.'})\n\n    if not isinstance(age, int) or age < 0:\n        return json.dumps({'error': 'Invalid age. Age should be a non-negative integer.'})\n\n    data = {\n        \"Name\": name,\n        \"Age\": age,\n        \"Address\": address if address else \"Not provided\",\n        \"Job Title\": job_title if job_title else \"Not provided\",\n        \"Contact Details\": contact_details if contact_details else \"Not provided\",\n    }\n\n    return json.dumps(data, indent=4)"]}
{"task_id": "HumanEval/96", "problem": ["def count_up_to(n):\n    \"\"\"Implement a function that takes a non-negative integer and returns a list of prime numbers below n.\"\"\"\n    primes = []\n    for i in range(2, n):\n        if is_prime(i):\n            primes.append(i)\n    return primes", "def count_up_to(n):\n    primes = []\n    for possiblePrime in range(2, n):\n        isPrime = True\n        for num in range(2, possiblePrime):\n            if possiblePrime % num == 0:\n                isPrime = False\n        if isPrime:\n            primes.append(possiblePrime)\n    return primes", "def count_up_to(n):\n    \"\"\"Return all primes less than n and measure efficiency.\"\"\"\n    if n < 2: \n        return []\n\n    start_time = time.time()\n    primes = [2]\n    i = 3\n    while i < n:\n        if all(i % p != 0 for p in primes):\n            primes.append(i)\n        i += 2\n\n    print(f\"Time taken: {time.time() - start_time} seconds.\")\n\n    # validate the correctness\n    if not all(is_prime(p) for p in primes):\n        print(\"The algorithm is not correct.\")\n    else:\n        print(\"The algorithm is correct.\")\n\n    return primes", "def rearrange_list(lst):\n    \"\"\"\n    Rearranges an array of numbers such that the smallest numbers come first\n    \"\"\"\n    n = len(lst)\n    for i in range(n):\n        min_idx = i\n        for j in range(i+1, n):\n            if lst[min_idx] > lst[j]:\n                min_idx = j \n\n        lst[i], lst[min_idx] = lst[min_idx], lst[i]\n    \n    return lst", "def find_prime_numbers(n):\n    \"\"\"Return an array of all primes less than n.\"\"\"\n    sieve = np.ones(n//3 + (n%6==2), dtype=bool)\n    for i in range(1,int(n**0.5)//3+1):\n        if sieve[i]:\n            k = 3*i+1|1\n            sieve[       k*k//3     ::2*k] = False\n            sieve[k*(k-2*(i&1)+4)//3::2*k] = False\n    return np.r_[2,3,((3*np.nonzero(sieve)[0][1:]+1)|1)]"]}
{"task_id": "HumanEval/97", "problem": ["def multiply(lst, idx=0, prod=1):\n    \"\"\"Multiply prime numbers at prime indices.\"\"\"\n    if idx >= len(lst):\n        return prod\n    elif is_prime(idx) and is_prime(lst[idx]):\n        return multiply(lst, idx+1, prod * lst[idx])\n    else:\n        return multiply(lst, idx+1, prod)", "def multiply(lst):\n    \"\"\"Given a non-empty list of integers lst, perform multiple steps calculation to find the product of odd elements located at even indices. Ensure none of the elements in the list exceeds 100 and that you handle possible exceptions. Additionally, guarantee the final product does not exceed 5000.\n\n    Example\uff1a\n    multiply([3, 5, 7, 8, 6]) ==> 21\n    \"\"\"\n    if not lst:    # if list is empty \n        return \"Input list should not be empty.\"\n    if not all(type(i) == int for i in lst):    # if list has non-integer elements \n        return \"All elements of the input list should be integers.\"\n    if not all(0 <= i <= 100 for i in lst):    # if list has elements exceeding 100\n        return \"Elements of the list should not exceed 100.\"\n    try:\n        product = 1\n        for i in range(0, len(lst), 2):    # skipping 1 element i.e., considering elements at even indices\n            if lst[i] % 2 != 0:    # if the element is odd\n                product *= lst[i]\n            if product > 5000:    # if the product exceeds 5000\n                return \"Product exceeded 5000.\"\n        return product\n    except Exception as e:\n        return str(e)", "def multiply(a, b):\n    if b == 0:\n        return 0\n    return a + multiply(a, subtract(b, 1))", "def multiply(a, b):\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        print(\"Error: Inputs must be integers or floats.\")\n        return None\n    return a * b", "def multiply(lst):\n    \"\"\"Given a non-empty list of integers lst, perform multiple steps calculation to find the product of odd elements located at even indices. Ensure none of the elements in the list exceeds 100 and that you handle possible exceptions. Additionally, guarantee the final product does not exceed 5000.\n\n    Example\uff1a\n         multiply([3, 5, 7, 8, 9]) ==> 21\n    \"\"\"\n    if not lst:    # if list is empty \n        return \"Input list should not be empty.\"\n    if not all(type(i) == int for i in lst):    # if list has non-integer elements \n        return \"All elements of the input list should be integer.\"\n    if not all(0 <= i <= 100 for i in lst):    # if list has elements exceeding 100\n        return \"Elements of the list should not exceed 100.\"\n    try:\n        product = 1\n        for i in range(0, len(lst), 2):    # skipping 1 element i.e., considering elements at even indices\n            if lst[i] % 2 != 0:    # if the element is odd\n                product *= lst[i]\n                if product > 5000:    # if the product exceeds 5000\n                    return \"Product exceeded 5000.\"\n        return product\n    except Exception as e:\n        return str(e)"]}
{"task_id": "HumanEval/98", "problem": ["def count_upper(s):\n    \"\"\"\n    Example:\n    count_upper('aBCdEf') returns 1\n    count_upper('abcdefg') returns 0\n    count_upper('dBBE') returns 0\n    \"\"\"\n    upper_vowels = ['A', 'E', 'I', 'O', 'U']\n    \n    # count of uppercase vowels at even indices\n    count = sum(1 for i in range(len(s)) if i % 2 == 0 and s[i] in upper_vowels)\n  \n    return count", "def count_upper(s):\n    \"\"\"\n    count_upper('aBCdEfG') returns 2\n    count_upper('ABCDEF') returns 3\n    count_upper('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') returns 5\n    \"\"\"\n    assert 1 <= len(s) <= 1000, \"String length should be between 1 and 1000 characters\"\n    \n    vow = ['A', 'E', 'I', 'O', 'U']\n    count = sum(1 for i in range(len(s)) if i % 2 == 0 and s[i] in vow)\n    \n    return count", "def count_upper(s):\n    \"\"\"\n    Count uppercase vowels in even index positions.\n    Use the Python builtin isupper() to check for uppercase letters, and set() for O(1) membership lookup.\n    Params: s - string input\n    Returns: count - number of capitalised vowels in even-positioned indices\n    \"\"\"\n    assert 1 <= len(s) <= 1000, \"Invalid string length. It should be between 1 and 1000 characters\"\n    vowels = set(\"AEIOU\")\n    count = sum(1 for i in range(0, len(s)) if s[i].isupper() and s[i] in vowels and i % 2 == 0)\n    return count", "def count_upper(s):\n    \"\"\"\n    Counts the number of uppercase vowels present in even indices of an input string.\n    \"\"\"\n    vowels = ['A', 'E', 'I', 'O', 'U']\n    return sum(1 for i in range(0, len(s), 2) if s[i] in vowels)", "def count_upper(s):\n    \"\"\"Count the number of uppercase vowel characters present at the even indices within the input string\"\"\"\n    upper_vowels ='AEIOU'\n    return sum(1 for i in range(len(s)) if i % 2 == 0 and s[i] in upper_vowels)"]}
{"task_id": "HumanEval/99", "problem": ["def elite_truncation(figure, low, apex):\n    '''\n    Construct an operation that accedes to a figure (string) mimicking a digit along with two integers,\n    low and apex, which act as limiters of scope. The assignment involves returning the closest integer \n    to the input figure without the assistance of already available functions like round(). Furthermore, corroborate\n    that the supplied figure equates to a valid integer or float, and resides within the assigned boundaries.\n    If not, retrieve an error message. In a scenario where the digit finds itself at equal distance from two integers,\n    round it in the direction of zero.\n\n    Examples\n    >>> elite_truncation(\"10\", 0, 20)\n    10\n    >>> elite_truncation(\"15.6\", 10, 20)\n    15\n    >>> elite_truncation(\"out_of_range\", 5, 10)\n    \"Error: Invalid input.\"\n    >>> elite_truncation(\"25\", 0, 20)\n    \"Error: Out of range.\"\n\n    Note:\n    Rounding towards zero indicates that when the submitted number is halfway between two integers,\n    output the one that's nearest to zero. For instance, elite_truncation(\"14.5\", 10, 20) should\n    yield 14, whereas elite_truncation(\"-14.5\", -20, -10) should give -14.\n    '''\n    try:\n        num = float(figure)\n    except ValueError:\n        return \"Error: Invalid input.\"\n\n    if num < low or num > apex:\n        return \"Error: Out of range.\"\n        \n    if low<=num<apex:\n        if num>=0:\n            return int(num) if num-int(num)<0.5 else int(num)+1\n        else:\n            return int(num) if int(num)-num<0.5 else int(num)-1", "def elite_truncation(figure, low, apex):\n    '''\n    Construct an operation that access to a figure (string) mimicking a digit along with two integers,\n    low and apex, which act as limiters of scope. The assignment involves returning the closest integer \n    to the input figure without the assistance of already available functions like round(). Furthermore, \n    corroborate that the supplied figure equates to a valid integer or float, and resides within the assigned boundaries.\n    If not, retrieve an error message. In a scenario where the digit finds itself at equal distance from two integers,\n    round it in the direction of zero.\n\n    Examples\n    >>> elite_truncation(\"10\", 0, 20)\n    10\n    >>> elite_truncation(\"15.6\", 10, 20)\n    15\n    >>> elite_truncation(\"out_of_range\", 8, 10)\n    \"Error: Invalid input.\"\n    >>> elite_truncation(\"25\", 0, 20)\n    \"Error: Out of range.\"\n\n    Note:\n    Rounding towards zero indicates that when the submitted number is halfway between two integers,\n    output the one that's nearest to zero. For instance, elite_truncation(\"14.5\", 10, 20) should\n    yield 14, whereas elite_truncation(\"-14.5\", -20, -10) should give -14.\n    '''\n    try:\n        num = float(figure)\n    except ValueError:\n        return \"Error: Invalid input.\"\n\n    if num < low or num > apex:\n        return \"Error: Out of range.\"\n\n    if low <= num <= apex:\n        if num < 0:\n            return int(num) if num-int(num) < 0.5 else int(num) + 1\n        else:\n            return int(num) if int(num) - num < 0.5 else int(num) - 1", "def complex_rounding(value, low, high):\n    \"\"\"\n    Create a function that takes in a number represented as a string, value, and two \n    integers, low and high, establishing range parameters. This function should yield \n    the nearest integer to the input number without falling back on standard functions such\n    as round(). Alongside this, ascertain that the specified number is a valid integer or \n    floating-point number residing within the defined interval. Otherwise, \n    reciprocate with an error alert. For numbers at an equal distance from two integers, round it \n    towards zero.\n    \"\"\"\n    # Check if the input value is a valid number\n    try:\n        num_value = Decimal(value)\n    except InvalidOperation:\n        return \"Error: Invalid input.\"\n\n    # Check if the value is within the given range\n    if not (low <= num_value <= high):\n        return \"Error: Beyond range.\"\n\n    # Round according to the rules specified\n    decimal, integer = divmod(num_value, 1)\n\n    if decimal <= Decimal('0.5'):\n        return int(integer + 1)\n    elif decimal <= Decimal('-0.5'):\n        return int(integer - 1)\n    else:\n        return int(integer)", "def complex_rounding(value, low, high):\n    '''\n    Craft a function that takes in a number represented as a string, value, and two \n    integers, low and high, establishing range delimiters. This function should yield \n    the nearest integer to the input number without falling back on standard functions such \n    as round(). Alongside this, ascertain that the specified number is a valid integer or \n    floating-point number residing within the defined interval. Otherwise, \n    reciprocate with an error alert. For numbers at an equal distance from two integers, conform it \n    towards zero.\n    '''\n    # Check if the input value is a valid number\n    try:\n        num_value = Decimal(value)\n    except InvalidOperation:\n        return \"Error: Invalid input.\"\n    \n    # Check if the value is within the given range\n    if not (low <= num_value <= high):\n        return \"Error: Beyond range.\"\n      \n    # Round according to the rules specified\n    decimal, integer = divmod(num_value, 1)\n    \n    if decimal >= Decimal('0.5'):\n        return int(integer + 1)\n    elif decimal <= Decimal('-0.5'):\n        return int(integer - 1)\n    else:\n        return int(integer)", "def customize_rounding(number: float, round_down: bool = True, random_round: bool = False) -> int:\n    if random_round:\n        # if number is negative, rounding down means rounding towards zero and vice versa\n        if number < 0:\n            return math.floor(number) if random.randint(0, 1) else math.ceil(number)\n        else:\n            return math.floor(number) if random.randint(0, 1) else math.ceil(number)\n    elif round_down:\n        # if number is positive, rounding down means moving towards zero\n        # if number is negative, rounding down means moving away from zero\n        return math.floor(number) if number >= 0 else math.ceil(number)\n    else:\n        # if number is positive, rounding up means moving away from zero\n        # if number is negative, rounding up means moving towards zero\n        return math.ceil(number) if number >= 0 else math.floor(number)"]}
{"task_id": "HumanEval/100", "problem": ["def make_a_pile(n, pattern, offset=0):\n    if type(n) != int or n < 1:\n        return \"Please input a non-zero positive integer for 'n'.\"\n    if pattern not in ['odd', 'even']:\n        return \"Please input 'odd' or 'even' for 'pattern'.\"\n    if type(offset) != int:\n        return \"Please input an integer for 'offset'.\"\n\n    stones = [n + offset]\n    for i in range(1, n):\n        if pattern == 'odd':\n            stones.append(stones[-1] + 2)\n        elif pattern == 'even':\n            stones.append(stones[-1] + 2*i + offset)\n    return stones", "def make_a_pile(n, pattern, offset=0):\n    stones = [n]\n    for i in range(1, n): # Start the loop from 1 because the offset in the first round should be 1.\n        if pattern == 'odd':\n            stones.append(stones[-1] + 2*i+1)\n        elif pattern == 'even':\n            stones.append(stones[-1] + 2*i+offset) # offset added here\n    return stones", "def make_a_pile(n, pattern, offset=0):\n    stones = [n + offset]\n    for i in range(1, n):\n        if pattern == 'odd':\n            stones.append(stones[-1] + 2*i - 1)\n        elif pattern == 'even':\n            stones.append(stones[-1] + 2*i)\n    return stones", "def lastStoneWeight(stones):\n    # Convert all weights to negative so we can use Python's min-heap as a max-heap.\n    stones = [-x for x in stones]\n    \n    heapq.heapify(stones) # Create a heap\n\n    while len(stones) > 1: # While there's more than one stone...\n        # Take the two heaviest stones.\n        y = -heapq.heappop(stones)\n        x = -heapq.heappop(stones)\n        # If they're not equal, add the remaining stone back to the heap.\n        if y != x:\n            heapq.heappush(stones, -abs(y-x))\n\n    # Return the weight of the last stone, or 0 if there are no stones.\n    return -stones[0] if stones else 0", "def canCross(stones: List[int]) -> bool:\n    # Create a set to store the positions of the stones for quick lookup\n    stone_set = set(stones)\n    \n    # Create a dictionary to store the possible jumps from each stone\n    jumps = {stone: set() for stone in stones}\n    jumps[0].add(0)  # The frog starts at the first stone with a jump of 0\n    \n    for stone in stones:\n        for jump in jumps[stone]:\n            for next_jump in range(jump - 1, jump + 2):\n                if next_jump > 0 and stone + next_jump in stone_set:\n                    jumps[stone + next_jump].add(next_jump)\n    \n    # If the last stone has any valid jumps, the frog can cross the river\n    return bool(jumps[stones[-1]])"]}
{"task_id": "HumanEval/101", "problem": ["def int_to_string(num):\n    string_nums = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    return string_nums[num]", "def convert_number_words(text):\n    number_words_to_numbers = {\n        \"one\": \"1\", \"two\": \"2\", \"three\": \"3\", \"four\": \"4\",\n        \"five\": \"5\", \"six\": \"6\", \"seven\": \"7\", \n        \"eight\": \"8\", \"nine\": \"9\"\n    }\n    words = text.split(' ')\n    for i, word in enumerate(words):\n        if word in number_words_to_numbers:\n            words[i] = number_words_to_numbers[word]\n    return ' '.join(words)", "def transform_text(text):\n    digit_to_word = {\n        \"0\": \"ZERO\",\n        \"1\": \"ONE\",\n        \"2\": \"TWO\",\n        \"3\": \"THREE\",\n        \"4\": \"FOUR\",\n        \"5\": \"FIVE\",\n        \"6\": \"SIX\",\n        \"7\": \"SEVEN\",\n        \"8\": \"EIGHT\",\n        \"9\": \"NINE\"\n    }\n\n    words = [digit_to_word[character] if character.isdigit() else character for character in text.upper()]\n    return ' '.join(words)  # join the words with a space", "def text_to_number(input_str):\n    num_dict = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9,\n        \"ten\": 10,\n        \"hundred\": 100\n    }\n\n    words = input_str.lower().split(\" \")\n\n    number = 0\n    for i in range(len(words)):\n        if words[i] in num_dict.keys():\n            if words[i] == \"hundred\" and i > 0:\n                number *= num_dict[words[i]]\n            else:\n                number += num_dict[words[i]]\n\n    return number", "def complex_words_without_target(s, target):\n    \"\"\"\n    Given a string of words separated by various delimiters like commas, colons, semi-colons, spaces, or a combination. Your task is to split this string into words and create a dictionary. The dictionary keys will be the delimiters and the values will be lists storing the words in their original sequence after removing all instances of a given 'target' word and reversing the remaining words. If the 'target' appears in any word, eliminate that entire word.\n\n    For instance:\n\n    complex_words_without_target(\"Hello, how: are; you\", \"are\") \n    {\",\": [\"uoy\", \"woh\"], \":\": [\"woH\"], \";\": [\"olleH\"]}\n\n    complex_words_without_target(\"Cat, mouse: cheese; bread, butter; jam\", \"cheese\") \n    {\",\": [\"maj\", \"retub\"], \":\": [\"esuom\"], \";\": [\"taC\"]}\n    \"\"\"\n    \n    # Find the delimiters in the string\n    delimiters = re.findall(r'[^\\w\\s]', s)\n    # Split the string into words\n    words = re.findall(r'\\b(?:(?!{})\\w)+\\b'.format(target), s)\n    words = [word[::-1] for word in words]\n\n    # Create a dictionary with delimiters as keys and lists of words as values\n    result = {}\n    for delimiter, word in zip(delimiters, words):\n        if delimiter in result:\n            result[delimiter].append(word)\n        else:\n            result[delimiter] = [word]\n\n    return result"]}
{"task_id": "HumanEval/102", "problem": ["def choose_num(x, y, z):\n    \"\"\"\n    This function accepts three positive integers x, y, and z, and its objective is to return the\n    greatest even integer within the inclusive range of [x, y] that can be evenly divided by z. In the\n    absence of such a number, the function should yield -1.\n\n    Example cases:\n    choose_num(12, 15, 2) = 14\n    choose_num(13, 12, 3) = -1\n    choose_num(10, 20, 4) = 20\n    \"\"\"\n\n    # Start checking from the largest number in the range [x, y]\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0 and num % z == 0:\n            return num\n    return -1", "def choose_num(x, y, z):\n    \"\"\"This function should take three positive numbers x, y, and z. The function must return \n    the largest even integer number that is less than or equal to y and greater than or equal \n    to x, which is also a multiple of z. In case no such number exists, the function should return None.\n    \n    Validate your code with the added complexity of handling potential exceptions.\n    \"\"\"  \n    if not (type(x) == type(y) == type(z) == int):\n        return \"Error: Inputs must be integers.\"\n\n    if not (x >= 0 and y >= 0 and z >= 0):\n        return \"Error: Inputs must be positive.\"\n\n    if x > y:\n        return \"Error: x should be less than or equal to y.\"\n\n    #Initialize the largest number as None.\n    largest_num = None\n    \n    #Iterate from y to x both inclusive to find largest even multiple of z.\n    for i in range(y, x - 1, -1):\n        if i % z == 0 and i % 2 == 0:\n            largest_num = i\n            break\n        \n    #Return the largest number.\n    return largest_num", "def choose_num(x, y, z, n):\n    # Initialize an empty list to store the even numbers divisible by z\n    chosen_num_list = []\n\n    # If y is less than x, switch their values. This ensures x is the start of the range and y is the end.\n    if y < x:\n        x, y = y, x\n\n    # Scan every number in the range [x, y]\n    for num in range(x, y+1):\n        # If num is even and divisible by z, add it to the list\n        if num % 2 == 0 and num % z == 0:\n            chosen_num_list.append(num)\n\n    # Sort the list in descending order to get the nth largest number at index n-1\n    chosen_num_list.sort(reverse=True)\n\n    # If the length of the list is less than n (no nth largest number), return -1\n    if len(chosen_num_list) < n:\n        return -1\n    else:\n        return chosen_num_list[n-1]", "def choose_num(x, y, z, w, m):\n    # Create a list to store the found numbers\n    numbers_found = []\n\n    # Iterate over the range, from y down to x (inclusive), in steps of -1\n    for num in range(y, x-1, -1):\n        # Check whether the number is even, and whether it is divisible by z and w\n        if num % 2 == 0 and num % z == 0 and num % w == 0:\n            # If so, append the number to our list\n            numbers_found.append(num)\n\n            # If we have found m numbers, return the last one found\n            if len(numbers_found) == m:\n                return numbers_found[-1]\n\n    # If no number has been found or m is larger than the count of such numbers, return -1\n    return -1", "def least_common_multiple(x: Union[int, float], y: Union[int, float], z: Union[int, float]) -> Union[int, str]:\n    \"\"\" \n    Return the least common multiple of three positive integers x, y, and z\n    \"\"\"\n    try:\n        # checking if the number is integer and positive\n        if not (isinstance(x, int) and x > 0) or not (isinstance(y, int) and y > 0) or not (isinstance(z, int) and z > 0):\n            return 'Input should be positive integers.'\n\n        # gcd is a function in math module that \n        # returns the greatest common divisor of two numbers\n        # lcm formula = (x*y)/gcd(x,y)\n        gcd = math.gcd(x, y)\n        lcm = x * y // gcd\n\n        gcd = math.gcd(lcm, z)\n        lcm = lcm * z // gcd\n\n        return lcm\n\n    except Exception as e:\n        return f'An error occurred: {e}' "]}
{"task_id": "HumanEval/103", "problem": ["def convert_all_sums(n, m, start, base):\n    \"\"\"\n    You are provided two positive integers n and m (n <= m), and an additional starting number (start),\n    your task is to determine the sum of all the numbers from n through m (inclusive), starting from the 'start' number.\n    Then convert the sum into a custom base system. The custom base system will be another integer (base)\n    ranging from [2, 10] (inclusive). If n is greater than m, the start number is less than zero,\n    or the base is out of the given range, return -1. \n    \n    Example:\n    convert_all_sums(1, 5, 0, 2) => \"0b110\"\n    convert_all_sums(7, 5, 2, 2) => -1\n    convert_all_sums(10, 2, 10, 2) => \"0b10110\"\n    convert_all_sums(20, 33, 0, 2) => \"0b110101\"\n    convert_all_sums(15, 20, 10, 8) => \"0o25\"\n    \"\"\"\n    # Check for valid input\n    if n > m or start < 0 or not(2 <= base <= 10):\n        return -1\n    # Calculates the sum of the series\n    total = sum(range(n, m+1)) + start\n    # Converts the sum to the appropriate base\n    if base == 2:\n        return bin(total)\n    elif base == 8:\n        return oct(total)\n    elif base == 10:\n        return str(total)\n    else:\n        return \"Base not supported\"", "def convert_all_sums(n, m, start, base):\n    \"\"\"\n    You are provided two positive integers n and m (n <= m), \n    and an additional starting number (start), \n    your task is to determine the sum of all the numbers from n through m (inclusive), starting from the 'start' number,\n    Then convert the sum into a custom base system. The custom base system will be another integer (base)\n    ranging from [2, 10] (inclusive), If n is greater than m, the start number is less than zero,\n    or the base is out of the given range, return -1,\n\n    Example:\n    convert_all_sums(1, 5, 0, 2) => \"0b110\"\n    convert_all_sums(7, 5, 2, 2) => -1\n    convert_all_sums(10, 2, 10, 2) => \"0b1010\"\n    convert_all_sums(20, 33, 0, 2) => \"0b110101\"\n    convert_all_sums(15, 20, 10, 2) => \"0b25\"\n    \"\"\"\n    # Check for valid input\n    if n > m or start < 0 or not(2 <= base <= 10):\n        return -1\n    # Calculates the sum of the series\n    total = sum(range(n, m+1)) + start\n    # Converts the sum to the appropriate base\n    if base == 2:\n        return bin(total)\n    elif base == 8:\n        return oct(total)\n    elif base == 10:\n        return str(total)\n    else:\n        return \"Base not supported\"", "def square_nums(n, m):\n    # Check if n and m are positive integers\n    if n <= 0 or m <= 0 or type(n) != int or type(m) != int:\n        return \"n and m must be positive integers.\"\n    \n    # Check if m is greater than or equal to n\n    if m < n:\n        return \"m must be greater than or equal to n.\"\n    \n    # Calculate the squares of the numbers from n to m\n    result = [i ** 2 for i in range(n, m+1)]\n    return result", "def square_range(n, m):\n    # Validate that n and m are positive integers\n    if not isinstance(n, int) or not isinstance(m, int) or n <= 0 or m <= 0:\n        return \"Error: n and m must be positive integers\"\n    \n    # Ensure that n and m are within the range of 1 to 10^9\n    if n > 10**9 or m > 10**9:\n        return \"Error: n and m must be within the range of 1 to 10^9\"\n    \n    # Handle cases where n and m are equal\n    if n == m:\n        return [n**2]\n    \n    # Handle cases where m is less than n\n    if m < n:\n        return []\n    \n    # Calculate the squares of the numbers from n to m\n    squares = []\n    for i in range(m, n-1, -1):\n        squares.append(i**2)\n    \n    return squares", "def validate_input(n, m):\n    n = round(n)\n    m = round(m)\n    if n < 0 or m < 0:\n        raise ValueError(\"n and m must be positive integers.\")\n    return n, m"]}
{"task_id": "HumanEval/104", "problem": ["def odd_sum_elements(x):\n    \"\"\"Given a list of positive integers x, return a sorted list of all \n    _unique_ elements where the sum of their digits is an odd number.\n\n    Note: The returned list should be sorted in ascending order. \n\n    >>> odd_sum_elements([15, 33, 1422, 1, 15])\n    [1, 15]\n    >>> odd_sum_elements([152, 323, 1422, 10])\n    [323]\n\n    \"\"\"\n    odd_sum_digits = []\n    for i in set(x):\n        if sum(int(digit) for digit in str(i)) % 2 != 0:\n            odd_sum_digits.append(i)\n    return sorted(odd_sum_digits)", "def prime_digit_product(x):\n    \"\"\"Given a list of positive integers x, return a sorted list of all \n    _distinct_ elements wherein the product of its digits is a prime number.\n\n    Note: The resulting list should be sorted in ascending order. \n\n    >>> prime_digit_product([15, 33, 1422, 1, 15])\n    [1, 15]\n    >>> prime_digit_product([152, 323, 1422, 10])\n    [323]\n\n    \"\"\"\n    return sorted(set([i for i in x if is_prime(prod([int(d) for d in str(i)]))]))", "def odd_sum_elements(x):\n    \"\"\"\n    Accepts a list of positive numbers (x), returning a sorted list comprising unique elements, the sum of whose digits equals an odd number.\n\n    Note: The output list must be sorted in increasing order.\n\n    >>> odd_sum_elements([15, 33, 1422, 1, 15])\n    [1, 15]\n    >>> odd_sum_elements([152, 323, 1422, 10])\n    [323]\n\n    \"\"\"\n    unique_nums = set(x)  # create a set from the list to remove duplicates\n    odd_digits_sum_nums = [num for num in unique_nums if sum(int(digit) for digit in str(num)) % 2 != 0]\n    return sorted(odd_digits_sum_nums)  # return the sorted list", "def split_odd_totals(y):\n    \"\"\"In this function, given an array y of positive integers, generate two sorted arrays. One includes \n    _singular_ elements whose sum of their digits is odd and ends with an odd number, and other with \n    elements whose sum of their digits is odd and ends with an even number, both in ascending sequence.\n\n    >>> split_odd_totals([15, 33, 1422, 1, 15])\n    ([1, 15, 33], [1422])\n    >>> split_odd_totals([152, 323, 1422, 10])\n    ([323], [152, 1422])\n    \"\"\"\n\n    odd_ending = []\n    even_ending = []\n\n    for num in y:\n        digit_sum = sum(int(digit) for digit in str(num))\n        \n        if digit_sum % 2 != 0: # sum of digits is odd\n            if num % 2 != 0: # number ends with odd digit\n                odd_ending.append(num)\n            else: # number ends with even digit\n                even_ending.append(num)\n                \n    return sorted(odd_ending), sorted(even_ending)", "def unique_odd_digit_sum(x):\n    \"\"\"Given a list of integers x, return a sorted list of unique positive integers that have an odd sum of their digits. The same integer should not appear twice.  \n\n    Sort the final output list in ascending order. \n\n    E.g.:\n    >>> unique_odd_digit_sum([15, 38, 1420, 1, 15])\n    [1]\n    >>> unique_odd_digit_sum([154, 323, 1422, 10])\n    [323]\n    >>> unique_odd_digit_sum([-15, 38, -1420, -1, 15])\n    [15]\n    \"\"\"\n\n    # Create an empty list to store the resulting integers\n    result = []\n\n    # Loop over the input list x\n    for num in x:\n        # Exclude negative numbers\n        if num < 0:\n            continue\n\n        # Calculate the sum of the digits of num\n        digit_sum = sum(int(digit) for digit in str(num))\n\n        # Exclude integers with an even sum of digits\n        if digit_sum % 2 == 0:\n            continue\n\n        # Exclude integers that are already in the result list\n        if num in result:\n            continue\n\n        # Add the integer to the result list\n        result.append(num)\n        \n    return sorted(result)"]}
{"task_id": "HumanEval/105", "problem": ["def test_bubble_sort():\n    # Empty array\n    arr = []\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != []:\n        print(\"Error: Bubble Sort failed on empty array.\")\n\n    # Array with duplicate values\n    arr = [4, 3, 2, 2, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 2, 3, 4]:\n        print(\"Error: Bubble Sort failed on array with duplicate values.\")\n\n    # Sorted array in descending order\n    arr = [5, 4, 3, 2, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 3, 4, 5]:\n        print(\"Error: Bubble Sort failed on sorted array in descending order.\")\n\n    # Random unsorted array\n    arr = [5, 3, 2, 4, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 3, 4, 5]:\n        print(\"Error: Bubble Sort failed on random unsorted array.\")", "def word_to_num(word):\n    word_num = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4, \"five\": 5,\n                \"six\": 6, \"seven\": 7, \"eight\": 8, \"nine\": 9, \"ten\": 10}\n    return word_num[word]", "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n    1. Perform rightward shifting operation as required.\n    2. Swap at most three pair of balls.\n    3. After the operations, elements smaller than the first element in the array should be odd in number.\n    \n    Return True, if the array could be sorted; otherwise, False. \n    \n    Examples:\n    move_three_balls([5, 4, 5, 1, 2, 6]) -> True\n    move_three_balls([1, 3, 5, 4, 2, 6]) -> True\n    move_three_balls([1, 2, 3, 5, 4, 6]) -> True\n    move_three_balls([5, 4, 3, 1, 2, 6]) -> False\n    \"\"\"\n    \n    if not arr:\n        return True\n    \n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False", "def text_to_number(input_str):\n    num_dict = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9,\n        \"ten\": 10,\n        \"hundred\": 100\n    }\n\n    words = input_str.lower().split(\" \")\n\n    number = 0\n    for i in range(len(words)):\n        if words[i] in num_dict.keys():\n            if words[i] == \"hundred\" and i > 0:\n                number *= num_dict[words[i]]\n            else:\n                number += num_dict[words[i]]\n\n    return number", "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n        1. Perform rightward shifting operation as required.\n        2. Swap at most three pair of balls.\n        3. After the operations, elements smaller than the first element in the array should be odd in number.\n\n    Return True, if the array could be sorted, otherwise False. \n\n    Examples:\n    move_three_balls([3, 4, 5, 1, 2, 6]) => True\n    move_three_balls([1, 3, 5, 4, 2, 6]) => True\n    move_three_balls([1, 2, 3, 5, 4, 6]) => True\n    move_three_balls([5, 4, 3, 1, 2, 6]) => False\n\n    \"\"\"\n    if not arr:\n        return True\n\n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False"]}
{"task_id": "HumanEval/106", "problem": ["def fibfib(n: int):   # Define function fibfib that takes an integer n as an argument.\n    dp = [0]*max(3, n+1)  # Creates a list named dp, with size depending on max of 3 and n+1. Initially all elements are set to 0.\n    dp[0], dp[1], dp[2] = 0, 0, 1  # Set the first three numbers in dp to 0, 0, and 1, respectively.\n    for i in range(3, n+1):  # This loop starts from 3 (as we've already set the values of 0, 1 and 2 index elements) to n+1.\n        dp[i] = dp[i-1] + dp[i-2] + dp[i-3] #  Each new element at index i in dp is set as the sum of the three previous numbers. It suggests the sequence is something like 0, 0, 1, 1, 2, 4, 7, 13, 24 etc.\n    return dp[n]  # Finally, this function returns the nth number in the sequence.", "def f(n):\n  # Initialize an empty list\n  result_list = []\n  # Use a for loop that starts at 1 and ends at n\n  for i in range(1, n+1):\n    # Use a conditional statement to check if the number is even\n    if i % 2 == 0:\n      # If the number is even, call the factorial function and append the result to the list\n      result_list.append(factorial(i))\n    else:\n      # If the number is odd, call the sumOfSquare function and append the result to the list\n      result_list.append(sumOfSquare(i))\n  return result_list", "def factorial(n=5):\n    \"\"\"\n    Calculate the factorial of a given positive integer.\n\n    Args:\n    n: An optional integer for which the factorial needs to be calculated (default is 5).\n\n    Returns:\n    The factorial of the input integer n.\n    \"\"\"\n    f = 1\n    for i in range(1, n + 1):\n        f *= i\n    return f", "def proper_code(*args):\n    \"\"\"\n    Given single or multiple positive integers, check if any of them is a perfect square. \n    If at least one is a perfect square, create and test a function that returns the number of n-digit positive integers that start or end with 1. \n    Also, these numbers must be divisible by any three distinct prime numbers. \n    Return 'Not a perfect square.' if none of them is a perfect square.\n    \"\"\"\n    # Find first three prime numbers\n    primes = list(sympy.primerange(0, 100))[:3]\n    for i in args:\n        if is_perfect_square(i):\n            # n is taken as the number of digits in the first perfect square found\n            n = len(str(i))\n            return num_start_end_with_1(n, primes)\n    return 'Not a perfect square.'", "def sum_even_numbers(numbers):\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The sum of all even numbers in the list. Returns 0 if the list is empty or does not contain any even numbers.\n\n    Examples:\n    >>> sum_even_numbers([1, 2, 3, 4, 5, 6])\n    12\n    >>> sum_even_numbers([1, 3, 5, 7])\n    0\n    >>> sum_even_numbers([])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)"]}
{"task_id": "HumanEval/107", "problem": ["def multiply(lst):\n    \"\"\"Given a populated array of integers, lst, compute the product of all odd numerals located at even indices within the array that are simultaneously multiples of 3. The indices of the array start at 0 (even).\n\n    Illustrative scenario (Correct):\n        multiply([3, 5, 7, 8, 9]) yields 27  \n    \"\"\"\n    result = 1\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 == 1 and lst[i] % 3 == 0:\n            result *= lst[i]\n    return result", "def multiply(lst):\n    \"\"\"\n    An array of integers is provided, denoted as 'lst'. Calculate the product of those odd numbers positioned at even locations where these numbers are also multiples of the integer three.\n\n    Example:\n        multiply([3, 5, 7, 8, 9]) yields 27\n    \"\"\"\n    product = 1  # Initialize the product to be 1\n    for i, v in enumerate(lst):\n        if i % 2 == 0 and v % 3 == 0:  # Check if index is even and value divisible by 3\n            product *= v  # multiply product by v\n    return product", "def main():\n    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(\"Even numbers from the list are:\")\n    print_numbers(numbers)", "def count_even(n):\n    # Check whether given input is valid integer or not\n    if not isinstance(n, int):\n        return \"Error: Input should be an integer\"\n    \n    # handle the cases where n is less than 0\n    if n < 0:\n        return \"Error: Input should be non-negative integer\"\n    \n    # As number at odd indexes are even number in series 0 to n (since 0 is considered even),\n    # by integer division of n by 2, would directly derive count of non-negative even numbers less than n\n    return (n // 2)", "def sum_of_even_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers: A list of integers.\n\n    Returns:\n    The sum of all even numbers in the list.\n    \n    Examples:\n    >>> sum_of_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    30\n    >>> sum_of_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_of_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)"]}
{"task_id": "HumanEval/108", "problem": ["def count_nums(arr):\n    \"\"\"\n    >>> count_nums([]) == 0\n    >>> count_nums([-4, 15, -12]) == 2\n    >>> count_nums([2, 5, -1]) == 0\n    \"\"\"\n    count = 0\n    for num in arr:\n        total = 0\n        num_str = str(num)\n        # if num is negative, start from 2nd character, and subtract the 1st digit (considered as negative)\n        start = 0\n        if num < 0: \n            start = 1\n            total -= int(num_str[1])\n        for digit in num_str[start:]:\n            total += int(digit)\n        if total > 0 and total % 4 == 0:\n            count += 1\n    return count", "def count_nums(arr):\n    count = 0\n    for number in arr:\n        digits = map(int, str(abs(number)))\n        digit_sum = sum(digits)\n\n        # consider the leading digit negative if the number itself is negative\n        if number < 0:\n            digit_sum -= 2 * digits[0]\n\n        # check if the sum is both greater than zero and a multiple of 4\n        if digit_sum > 0 and digit_sum % 4 == 0:\n            count += 1\n    return count", "def count_nums(arr):\n    nums = []\n    max_sum = float('-inf')\n    max_sum_tuple = (-1, -1)\n\n    # Parsing array for finding relevant numbers\n    for num in arr:\n        temp = str(abs(num))  # Taking absolute for simplicity\n        digits = [int(digit) for digit in temp]\n\n        # Using list slicing [::] minus sign on first digit if original number was negative\n        digits_sum = -digits[0] + sum(digits[1:]) if num < 0 else sum(digits)\n\n        if digits_sum > 0 and digits_sum % 4 == 0:\n            nums.append(num)\n\n            # Check if this pair has the greatest sum so far\n            if len(nums) >= 2 and sum(nums[-2:]) > max_sum:\n                max_sum = sum(nums[-2:])  \n                max_sum_tuple = (nums[-2], nums[-1])\n\n    count = len(nums)\n    return count, max_sum_tuple if max_sum != float('-inf') else (-1, -1)", "def split_odd_totals(y):\n    \"\"\"In this function, given an array y of positive integers, generate two sorted arrays. One includes \n    _singular_ elements whose sum of their digits is odd and ends with an odd number, and other with \n    elements whose sum of their digits is odd and ends with an even number, both in ascending sequence.\n\n    >>> split_odd_totals([15, 33, 1422, 1, 15])\n    ([1, 15, 33], [1422])\n    >>> split_odd_totals([152, 323, 1422, 10])\n    ([323], [152, 1422])\n    \"\"\"\n\n    odd_ending = []\n    even_ending = []\n\n    for num in y:\n        digit_sum = sum(int(digit) for digit in str(num))\n        \n        if digit_sum % 2 != 0: # sum of digits is odd\n            if num % 2 != 0: # number ends with odd digit\n                odd_ending.append(num)\n            else: # number ends with even digit\n                even_ending.append(num)\n                \n    return sorted(odd_ending), sorted(even_ending)", "def sum_of_squares(arr):\n    \"\"\"Calculate square sum of numbers divisible by 3 or 7.\n    \n    This function takes a list of integers and strings, converting \n    strings to integers where possible, and returns the sum of the squares \n    of all positive elements divisible by either 3 or 7. Non-convertible \n    strings and negative numbers are ignored.\n\n    Args:\n        arr (list): A list containing integers and strings.\n\n    Returns:\n        int: The sum of squares of all positive elements divisible by 3 or 7.\n\n    Examples:\n        >>> sum_of_squares([])\n        0\n        >>> sum_of_squares(['3', 7, -1, '11', 'not-an-int'])\n        58\n        >>> sum_of_squares([4, '9', 7, '3'])\n        130\n    \"\"\"\n    return sum(int(i)**2 for i in arr if str(i).isdigit() and int(i) > 0 and (int(i) % 3 == 0 or int(i) % 7 == 0))"]}
{"task_id": "HumanEval/109", "problem": ["def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n        1. Perform rightward shifting operation as required.\n        2. Swap at most three pair of balls.\n        3. After the operations, elements smaller than the first element in the array should be odd in number.\n\n    Return True, if the array could be sorted, otherwise False. \n\n    Examples:\n    move_three_balls([3, 4, 5, 1, 2, 6]) => True\n    move_three_balls([1, 3, 5, 4, 2, 6]) => True\n    move_three_balls([1, 2, 3, 5, 4, 6]) => True\n    move_three_balls([5, 4, 3, 1, 2, 6]) => False\n\n    \"\"\"\n    if not arr:\n        return True\n\n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False", "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n    1. Perform rightward shifting operation as required.\n    2. Swap at most three pair of balls.\n    3. After the operations, elements smaller than the first element in the array should be odd in number.\n    \n    Return True, if the array could be sorted; otherwise, False. \n    \n    Examples:\n    move_three_balls([5, 4, 5, 1, 2, 6]) -> True\n    move_three_balls([1, 3, 5, 4, 2, 6]) -> True\n    move_three_balls([1, 2, 3, 5, 4, 6]) -> True\n    move_three_balls([5, 4, 3, 1, 2, 6]) -> False\n    \"\"\"\n    \n    if not arr:\n        return True\n    \n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False", "def advanced_sort(numbers):\n    \"\"\"\n    Given a list 'numbers' with N integers from 1 to 10^6 in random order. Determine if it's possible \n    to sort into non-decreasing order by the following operations:\n        1. Reverse any sublist any number of times.\n        2. Remove one element from the list.\n        3. Swap any two elements once.\n        \n    If possible, return 'True', if not, 'False'. If the list is empty, return 'True'.\n    Also, provide the sequence of operations taken to sort the list.\n\n    \"\"\"\n    N = len(numbers)\n    # If list is empty, return True\n    if N == 0:\n        return True, []\n\n    # If list is already sorted, return True\n    if numbers == sorted(numbers):\n        return True, []\n\n    # Else perform operations\n    i = 0\n    operations = []\n    while i < N - 1:\n        if numbers[i] > numbers[i + 1]:\n            numbers.pop(i)\n            operations.append('Remove ' + str(i))\n            N -= 1\n        else:\n            i += 1\n\n        if numbers == sorted(numbers):\n            return True, operations\n\n    # If after all operations, list is not sorted\n    return False, []", "def advanced_sort(numbers):\n    \"\"\"\n    Given a list 'numbers' with N integers from 1 to 10^6 in random order, determine if it's possible \n    to sort into non-decreasing order by the following operations:\n    1. Reverse any sublist any number of times.\n    2. Remove one element from the list.\n    3. Swap any two elements once.\n\n    If possible, return 'True', if not, 'False'. If the list is empty, return 'True'.\n    Also, provide the sequence of operations taken to sort the list.\n    \"\"\"\n    N = len(numbers)\n    # If list is empty, return True\n    if N == 0:\n        return True, []\n\n    # If list is already sorted, return True\n    if numbers == sorted(numbers):\n        return True, []\n\n    # Else perform operations\n    i = 0\n    operations = []\n    while i < N - 1:\n        if numbers[i] < numbers[i + 1]:\n            numbers.pop(i)\n            operations.append('Remove ' + str(i))\n            N -= 1\n        else:\n            i += 1\n\n    if numbers == sorted(numbers):\n        return True, operations\n\n    # If after all operations, list is not sorted\n    return False, []", "def insertion_sort(array, left=0, right=None):\n    if right is None:\n        right = len(array) - 1\n\n    # Loop from the left pointer to the right\n    for i in range(left + 1, right + 1):\n        # This is the element we want to position in its correct place\n        key_item = array[i]\n\n        # Initialize the variable that will be used to find the correct position of the element referenced by `key_item`\n        j = i - 1\n\n        # Run through the list of items (the left portion of the array) and find the correct position\n        # of the element referenced by `key_item`. Do this only if `key_item` is smaller than its adjacent values.\n        while j >= left and array[j] > key_item:\n            # Shift the value one position to the right and reposition j to point to the next element (from right to left)\n            array[j + 1] = array[j]\n            j -= 1\n\n        # When we finish shifting the elements, we can position `key_item` in its correct location\n        array[j + 1] = key_item\n\n    return array"]}
{"task_id": "HumanEval/110", "problem": ["def exchange(lst1, lst2):\n    # Check if total sum of lst1 and lst2 are both even numbers.\n    # If not, return \"NO\" directly because even number of swaps can't make uneven sum to be even.\n    if sum(lst1) % 2 != 0 or sum(lst2) % 2 != 0:\n        return \"No\"\n\n    # If the sum of both lists are even, then check if it's possible to make lst1 to be a list of even numbers.\n    # If an odd number in lst1 is found, then try to find an even number in lst2 to swap. If not found, return \"NO\" directly.\n    for i in range(len(lst1)):\n        if lst1[i] % 2 != 0:\n            has_swap = False\n            for j in range(len(lst2)):\n                if lst2[j] % 2 == 0:\n                    # Swap found, exchange the elements and break the loop.\n                    lst1[i], lst2[j] = lst2[j], lst1[i]\n                    has_swap = True\n                    break\n            if not has_swap:\n                return \"NO\"\n\n    # If all odd numbers in lst1 can find matched even numbers in lst2 to swap, return \"YES\".\n    return \"YES\"", "def exchange_with_floats_and_sci_notation(lst1, lst2):\n    \"\"\"\n    Example:\n    exchange([1.5e-1, 2.3e0, 3.7e1, 4.6e2], [1.1e1, 2.3e2, 3.4e-1, 4.5e-2]) => \"YES\"\n    exchange([1.1e2, 2.3e-1, 3.7e-2, 4.6e-3], [1.8e-2, 2.2e-1, 5.4e2, 4.5e1]) => \"NO\"\n    \"\"\"\n    # Change floats and scientific notation numbers to decimal for precise calculation\n    lst1 = [Decimal(str(n)) for n in lst1]\n    lst2 = [Decimal(str(n)) for n in lst2]\n\n    for i in range(len(lst1)):\n        # Convert floating-point numbers to integers by rounding them\n        n1 = round(lst1[i])\n        n2 = round(lst2[i])\n\n        # If both numbers are even or both numbers are odd, no need to swap\n        if (n1 % 2 == 0 and n2 % 2 == 0) or (n1 % 2 == 1 and n2 % 2 == 1):\n            continue\n        \n        # If one number is even and the other is odd, swap them\n        lst1[i], lst2[i] = lst2[i], lst1[i]\n\n    # Check if all numbers in lst1 are even and all numbers in lst2 are odd\n    for i in range(len(lst1)):\n        if round(lst1[i]) % 2 == 1 or round(lst2[i]) % 2 == 0:\n            return \"NO\"\n\n    return \"YES\"", "def exchange_with_floats_and_sci_notation(lst1, lst2):\n    \"\"\"\n    Example:\n    exchange([1.1e1, 2.3e0, 3.7e1, 4.6e2], [1.1e1, 2.3e2, 3.4e1, 4.5e2]) -> \"YES\"\n    exchange([1.1e2, 2.3e-1, 3.7e2, 4.6e2], [1.8e2, 2.2e-1, 5.4e2, 4.5e1]) -> \"NO\"\n    \"\"\"\n    # Change floats and scientific notation numbers to decimal for precise calculation\n    lst1 = [Decimal(str(n)) for n in lst1]\n    lst2 = [Decimal(str(n)) for n in lst2]\n\n    for i in range(len(lst1)):\n        # Convert floating-point numbers to integers by rounding them\n        n1 = round(lst1[i])\n        n2 = round(lst2[i])\n\n        # If both numbers are even or both numbers are odd, no need to swap\n        if (n1 % 2 == 0 and n2 % 2 == 0) or (n1 % 2 == 1 and n2 % 2 == 1):\n            continue\n\n        # If one number is even and the other is odd, swap them\n        lst1[i], lst2[i] = lst2[i], lst1[i]\n\n    # Check if all numbers in lst1 are even and all numbers in lst2 are odd\n    for i in range(len(lst1)):\n        if round(lst1[i]) % 2 == 1 or round(lst2[i]) % 2 == 0:\n            return \"NO\"\n\n    return \"YES\"", "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact.\n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n    # Separate primes and non-primes in both lists\n    primes1, nonprimes1 = [n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)]\n    primes2, nonprimes2 = [n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)]\n\n    # Check if all non-primes in lst1 can be replaced with primes from lst2\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for i, prime in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            # Replace non-prime with the smallest prime that is greater than it\n            i, prime = min(replaceable, key = lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            # If no prime in lst2 can replace the non-prime in lst1, return \"NO\"\n            return \"NO\"\n\n    # Check if the total sum across both lists remains the same\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return \"NO\"\n\n    return \"YES\"", "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n    # Separate primes and non-primes in both lists\n    primes1, nonprimes1 = [n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)]\n    primes2, nonprimes2 = [n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)]\n    \n    # Check if all non-primes in lst1 can be replaced with primes from lst2\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for i, prime in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            # Replace non-prime with the smallest prime that is greater than it\n            i, prime = min(replaceable, key = lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            # If no prime in lst2 can replace the non-prime in lst1, return \"NO\"\n            return \"NO\"\n    \n    # Check if the total sum across both lists remains the same\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return \"NO\"\n    \n    return \"YES\""]}
{"task_id": "HumanEval/111", "problem": ["def test_create_dict():\n    assert create_dict([\"a\",\"b\",\"c\"]) == {'a': 0, 'b': 5, 'c': 10}\n    assert create_dict([\"a\",\"b\",\"c\",\"a\"]) == {'a': 15, 'b': 5, 'c': 10}\n    assert create_dict([]) == {}\n    print(\"All test cases pass\")", "def sum_values(a, b, max_sum=100):\n    if not isinstance(a, (int, float)):\n        raise ValueError(f\"Error: Parameter 'a' must be a number. '{a}' is not a number.\")\n    if not isinstance(b, (int, float)):\n        raise ValueError(f\"Error: Parameter 'b' must be a number. '{b}' is not a number.\")\n    if isinstance(a, str):\n        raise ValueError(f\"Error: Parameter 'a' must be a number. '{a}' is a string.\")\n    if isinstance(b, str):\n        raise ValueError(f\"Error: Parameter 'b' must be a number. '{b}' is a string.\")\n    if a + b > max_sum:\n        raise ValueError(f\"Error: Sum of parameters exceeds the maximum allowed sum of {max_sum}.\")\n    return a + b", "def advanced_subword_check(a , b):\n    from collections import Counter\n\n    # Check if string b or its rotations are subwords in string a\n    for i in range(len(b)):\n        if b in a:\n            print(f\"'{b}' is a subword of '{a}'\")\n            return\n        else:\n            b = b[1:] + b[0]\n\n    # Check if string b can become a subword of string a\n    # by rearranging all its letters in any order\n    counterA = Counter(a)\n    counterB = Counter(b)\n    \n    for letter, count in counterB.items():\n        if letter not in counterA.keys() or count > counterA[letter]: # if letter of b is not in a or count is more than in a\n            print(f\"After rearranging, '{b}' cannot be a subword of '{a}'\")\n            return\n    \n    print(f\"After rearranging, '{b}' can be a subword of '{a}'\")", "def generate_dictionary(a, b, c):\n    # Check if the values are integers\n    if not all(value.isdigit() for value in (a, b, c)):\n        raise ValueError(\"All values must be integers\")\n\n    # Convert values to integers\n    a, b, c = int(a), int(b), int(c)\n\n    # Check if the values are prime numbers\n    if not all(is_prime(value) for value in (a, b, c)):\n        raise ValueError(\"All values must be prime numbers\")\n\n    # Check if the values are palindromic numbers\n    if not all(is_palindrome(value) for value in (a, b, c)):\n        raise ValueError(\"All values must be palindromic numbers\")\n\n    # Generate and return the dictionary\n    return {'a': a, 'b': b, 'c': c}", "def triangle_type(a, b, c):\n    '''This function detects triangle types (equilateral, isosceles, or scalene).'''\n    if a == b and b == c:\n        return 'equilateral'\n    elif a == b or b == c or a == c:\n        return 'isosceles'\n    else: \n        return 'scalene'"]}
{"task_id": "HumanEval/112", "problem": ["def convert_to_camel_case(s):\n    # Remove leading and trailing separators\n    s = s.strip(' -_')\n\n    # Initialize an empty result string\n    result = \"\"\n\n    # Variable to track if the next character should be capitalized\n    capitalize_next = False\n\n    # Iterate through each character in the string\n    for i, c in enumerate(s):\n        # If the current character is a separator, mark the next character to be capitalized\n        if c in ' -_':\n            capitalize_next = True\n        # If the current character is a letter or a digit, add it to the result string\n        elif c.isalpha() or c.isdigit():\n            # If the current character should be capitalized, convert it to uppercase\n            if capitalize_next:\n                result += c.upper()\n                capitalize_next = False\n            # Otherwise, add it as it is\n            else:\n                result += c\n\n    return result", "def string_validator(s):\n    count_upper = sum(1 for c in s if c.isupper())\n    count_digits = sum(1 for c in s if c.isdigit())\n    special_chars = \"!?_@\"\n    errors = []\n    if not 8 <= len(s) <= 12:\n        errors.append(\"Length should be between 8 and 12 characters\")\n    if count_upper < 2:\n        errors.append(\"Should contain at least 2 upper-case letters\")\n    if count_digits < 2:\n        errors.append(\"Should contain at least 2 digits\")\n    if not all(c in special_chars for c in s if not c.isalnum()):\n        errors.append(\"Only special characters allowed are !, ?, _, @\")\n    \n    if not errors: \n        return True\n    else: \n        print(f\"Failure for string '{s}': {', '.join(errors)}\")\n        return False", "def advanced_array_aggregation(lst, reverse=False):\n    \"\"\"\n    This function accepts a list of strings, filters the list by dropping strings of odd length or containing numbers,\n    and returns a sorted list based on the following criteria:\n    = All list entries must be strings; no grouping of numbers allowed\n    = Duplicates in the list are possible\n    = List is sorted in ascending order based on word length, and then alphabetically for words of the same length\n    = Ignore capitalization and special characters during sorting\n    Additionally, sorting order can be switched by initializing an optional logical 'reverse' parameter.\n\n    Furthermore, the function should also check for characters that appear more than twice in a single string and\n    discard these strings from the list.\n    \"\"\"\n\n    # We filter the strings of odd length or containing numbers\n    filtered = [s for s in lst if len(s) % 2 == 0 and not any(c.isdigit() for c in s)]\n    \n    # We check for characters that appear more than twice in a single string and discard these strings\n    filtered = [s for s in filtered if all(v <= 2 for v in Counter(s).values())]\n    \n    # Ignore capitalization and special characters during sorting\n    filtered = [\"\".join(ch for ch in s if ch.isalnum()) for s in filtered]\n    filtered = [s.lower() for s in filtered]\n\n    # Add some complexity by sorting the list according to length, and then by lexical order\n    filtered = sorted(filtered, key=lambda s: (len(s), s) , reverse=reverse)\n    \n    return filtered", "def is_palindrome(s):\n    \"\"\"\n    Checks if the given string is a palindrome\n\n    :param s: the string to be checked\n    :returns: True if the string is a palindrome, False otherwise\n    \"\"\"\n    # remove all non-alphanumeric characters\n    s = ''.join([c for c in s if c.isalnum()])\n    # convert to lower case\n    s = s.lower()\n    # compare reversed string to the original\n    return s == s[::-1]", "def encrypt(s, shift, seed=0):\n    \"\"\"Create a function named encrypt that accepts two parameters, a string and an integer for rotation. The function should return an encrypted string using a shuffled alphabet based on the input integer. It should handle case sensitivity and preserve non-alphabetic characters. It should also handle exceptions due to rotations exceeding the length of the alphabet.\"\"\"\n\n    # Define alphabet\n    lower_alphabet = string.ascii_lowercase\n    upper_alphabet = string.ascii_uppercase\n\n    # Introduce seed manipulation for more complexity\n    shift = (shift + seed) % 26\n\n    result = \"\"\n\n    for c in s:\n        # Support for unicode characters\n        if not c.isascii():\n            result += chr(ord(c) + shift)\n        # Preserve non-alphabetical characters\n        elif not c.isalpha():\n            result += c\n        else:\n            # Handle upper/lower-case characters differently for case sensitivity\n            if c.isupper():\n                result += upper_alphabet[(upper_alphabet.index(c) + shift) % 26]\n            else:\n                result += lower_alphabet[(lower_alphabet.index(c) + shift) % 26]\n\n    return result"]}
{"task_id": "HumanEval/113", "problem": ["def unusual_addition(lst):\n    \"\"\"This function accepts a list solely made up of strings containing numerical digits only and returns a list.\n    In the output, for each element, replace the 'i' with the true count of odd digits and 'e' with the true count of even digits in \n    the i'th string from the input.\n\n    >>> unusual_addition(['1234567'])\n    [\"the number of odd elements 4n the str3ng 3 of the 4nput.\"]\n    >>> unusual_addition(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str0ng 0 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for idx, str in enumerate(lst):\n        odd_count = sum(1 for s in str if int(s) % 2 != 0)\n        even_count = sum(1 for s in str if int(s) % 2 == 0)\n        replace_string = f\"the number of odd elements {odd_count}n the str{even_count}ng {even_count} of the {odd_count}nput.\"\n        output.append(replace_string)\n\n    return output", "def unusual_addition(lst):\n    \"\"\"Provided with a list, purely made up of strings containing numerical figures, deliver a return list.\n    Each index 'i' and the sum 's' of odd elements present in the i'th string of input, should transform into the actual sum of odd digits and their sum's square root respectively; also return the cumulative sum of all the peculiar digits.\n\n    >>> unusual_addition(['1234567'])\n    [\"the number of odd elements 4n the str4ng sqrt(4) of the 4nput.\", round(4**0.5), 16]\n    >>> unusual_addition(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng sqrt(1) of the 1nput.\", round(1**0.5), 3,\n     \"the number of odd elements 8n the str8ng sqrt(8) of the 8nput.\", round(8**0.5), 8]\n    \"\"\"\n    result = []\n    total = 0\n    for i in range(len(lst)):\n        sum_odds = sum([int(c) for c in lst[i] if int(c) % 2 == 1])\n        total += sum_odds\n        result.append(\"the number of odd elements %dn the str%2sng %d of the %dnput.\" % (sum_odds, \"sqrt(\"+str(sum_odds)+\")\", i, total))\n        result.append(round(sum_odds**0.5))\n        result.append(total)\n    return result", "def unusual_addition(lst):\n    \"\"\"\n    This function accepts a list solely made up of strings containing numerical digits only and returns a list.\n    In the output, for each element, replace the '1' with the true count of odd digits and 'e' with the true count of even digits in\n    the nth string from the input.\n\n    >>> unusual_addition(['1234567'])\n    [\"the number of odd elements are 3 of the string 1 of the input.\"]\n    >>> unusual_addition(['3', \"1111111\"])\n    [\"the number of odd elements are 1 of the string 1 of the input.\",\n    \"the number of odd elements are 7 of the string 0 of the input.\"]\n    \"\"\"\n    output = []\n    for idx, string in enumerate(lst):\n        odd_count = sum(1 for s in string if int(s) % 2 != 0)\n        even_count = sum(1 for s in string if int(s) % 2 == 0)\n        replace_string = f\"the number of odd elements are {odd_count} of the string {even_count} of the input\"\n        output.append(replace_string)\n\n    return output", "def unusual_addition(lst: list) -> list:\n    \"\"\"\n    Given a list consisting only of strings with numerical characters, return a list.\n    Each 'i' in the output statement for each element, \"+he number of odd elements present in the\n    i'th input string,\", should be replaced with the actual count of odd numbers.\n    \"\"\" \n    results = []\n\n    for i, string in enumerate(lst):\n\n        totals = [0, 0]  # [total odd_numbers, total_even_numbers]\n\n        # Count number of odd and even numbers within the string\n        for char in string:\n            if int(char) % 2 == 0:\n                totals[1] += 1\n            else:\n                totals[0] += 1\n\n        totals = [num**2 for num in totals]  # Square of counts\n\n        odd_squares = {el for el in range(totals[0])}\n        even_squares = [el for el in range(totals[1])]\n\n        odd_square_totals = sum([num**2 for num in odd_squares])\n        even_square_totals = sum([num**2 for num in even_squares])\n\n        output_string = f\"The number of odd elements {odd_square_totals} in the string {string} of the input.\"\n        results.append(output_string)\n\n    return results", "def ascii_check(lst):\n    \"\"\"\n    This function accepts a list of strings, returning a string indicating the count of ASCII characters in every individual string in the list. Each response should be part of a list, stating \"the number of ASCII characters in the i'th input string\" - \"i\" should be replaced with the actual count of ASCII characters present.\n    \n    >>> ascii_check(['Test%$','ASCII@!'])\n    [\"the number of ASCII characters is 6 in the string 1 of the input.\",\n     \"the number of ASCII characters is 7 in the string 2 of the input.\"]\n    >>> ascii_check(['123#','Hello_*'])\n    [\"the number of ASCII characters is 4 in the string 1 of the input.\",\n     \"the number of ASCII characters is 7 in the string 2 of the input.\"]\n    \"\"\"\n    result = []\n    for i, string in enumerate(lst, 1):\n        ascii_count = len([char for char in string if ord(char) < 128])\n        result.append(\"the number of ASCII characters is {} in the string {} of the input.\".format(ascii_count, i))\n    return result"]}
{"task_id": "HumanEval/114", "problem": ["def test_unique_elements():\n    # Test case 1: Empty array\n    assert unique_elements([]) == []\n\n    # Test case 2: Array with all elements being the same\n    assert unique_elements([5, 5, 5, 5, 5]) == [5]\n\n    # Test case 3: Array with mix of positive and negative integers\n    assert unique_elements([1, 2, 3, 4, 5, 4, 3, 2, 1, -1, -2, -3, -4, -5]) == [1, 2, 3, 4, 5, -1, -2, -3, -4, -5]\n\n    # Test case 4: Array with no repeated elements\n    assert unique_elements([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\n    print(\"All test cases pass\")", "def uncommon_elements(sequence):\n    '''\n    Design a function that accepts a non-empty list composed of positive integers and returns a list of distinct integers whose frequency surpasses half of the integer's numerical value. Here, 'frequency' denotes the number of times a specific integer appears within the list.\n    If no integers satisfy these conditions, the function should return an empty list.\n    Examples:\n        uncommon_elements([4, 1, 2, 2, 3, 1]) should yield [2, 3]\n        uncommon_elements([1, 2, 2, 3, 3, 3, 4, 4, 4]) should yield [2, 3, 4]\n        uncommon_elements([5, 5, 4, 4, 4]) should yield [4]\n    '''\n    from collections import Counter\n    count = Counter(sequence)\n    result = []\n    for num, freq in count.items():\n        if freq > num/2:\n            result.append(num)\n    return result", "def rolling_max(numbers1: List[int], numbers2: List[int]) -> Tuple[List[int], List[int]]:\n    \"\"\" From two given lists of integers, generate a list of rolling maximum element found until given moment \n    in the sequence and store them as maximum of each list.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2], [1, 4, 2, 4, 1, 5, 1])\n    ([1, 2, 3, 3, 3, 4, 4], [1, 4, 4, 4, 4, 5, 5])\n    \"\"\"\n    pass  # Your implementation here", "def sort_by_binary_len(arr):\n    \"\"\"\n    Rearrange an array of non-negative integers considering the lengths \n    of their binary notations. Sort the numbers by their decimal values \n    in case of binary length matches. \n\n    The expected output will be: \n    >>> sort_by_binary_len([1, 31, 15, 2, 7]) == [1, 2, 7, 15, 31]\n    >>> sort_by_binary_len([14, 58, 39, 41, 61]) == [14, 39, 41, 58, 61]\n    >>> sort_by_binary_len([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    \"\"\"\n    \n    sorted_arr = sorted(arr, key=lambda x: (bin(x)[2:].zfill(8), x))\n    return sorted_arr", "def enhanced_solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are at even positions.    \n\n    Examples\n    enhanced_solution([5, 8, 7, 1]) => 5\n    enhanced_solution([3, 3, 3, 3, 3]) => 9\n    enhanced_solution([30, 13, 24, 321]) => 30\n    \"\"\"\n    return sum(num for i, num in enumerate(lst[::2]) if num % 2 == 1)"]}
{"task_id": "HumanEval/115", "problem": ["def minesweeper(grid):\n    # Get the grid size.\n    n, m = len(grid), len(grid[0])\n\n    # Initialize an output grid with all values set to 0.\n    output = [[0]*m for _ in range(n)]\n\n    # Loop over each cell in the grid.\n    for i in range(n):\n        for j in range(m):\n\n            # If the cell is a mine, mark it as such in the output.\n            if grid[i][j] == '#':\n                output[i][j] = '#'\n                continue\n\n            # Check the neighboring cells.\n            for dx in [-1, 0, 1]:\n                for dy in [-1, 0, 1]:\n                    # If the neighbor is within the grid and it is a mine, \n                    # increment the output value of the current cell.\n                    if 0 <= i+dx < n and 0 <= j+dy < m and grid[i+dx][j+dy] == '#':\n                        output[i][j] += 1\n\n            # Convert the count to string.\n            output[i][j] = str(output[i][j])\n    # Return the output grid.\n    return output", "def well_emptying(grid, capacity):\n    # Get the number of rows and columns in the grid\n    rows, cols = len(grid), len(grid[0])\n\n    # Initialize the number of bucket lowerings to 0\n    lowerings = 0\n\n    # Iterate over the rows in the grid\n    for i in range(rows):\n        # Initialize the remaining capacity of the bucket\n        remaining_capacity = capacity\n\n        # Iterate over the columns in the row\n        for j in range(cols):\n            # If the current well has water\n            if grid[i][j] == 1:\n                # Decrease the remaining capacity of the bucket\n                remaining_capacity -= 1\n\n                # If the bucket is full, empty it and reset the capacity\n                if remaining_capacity == 0:\n                    lowerings += 1\n                    remaining_capacity = capacity\n\n        # If the bucket has water after finishing a row, empty it\n        if remaining_capacity != capacity:\n            lowerings += 1\n\n    return lowerings", "def minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all(isinstance(i, list) for i in grid):\n        return \"Invalid input. Input has to be a 2D grid.\"\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n*n:\n        return \"Invalid input. K has to be an integer and within range.\"\n    if any(not isinstance(i, int) for sublist in grid for i in sublist):\n        return \"Invalid input. Grid should only contain integers.\"\n\n    heap = [(grid[0][0], (0, 0))]   \n    sumCache = {(0, 0): grid[0][0]}   \n    pathCache = {(0, 0): [grid[0][0]]} \n\n    while heap:\n        curvalue, (curi, curj) = heapq.heappop(heap)\n        for nexti, nextj in getNeighbors(curi, curj, n):\n            newSum = sumCache[(curi, curj)] + grid[nexti][nextj]\n            newPath = pathCache[(curi, curj)] + [grid[nexti][nextj]]\n            if len(newPath) > k:   \n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[(nexti, nextj)]:\n                sumCache[(nexti, nextj)] = newSum\n                heapq.heappush(heap, [newSum, (nexti, nextj)])\n                pathCache[(nexti, nextj)] = newPath\n    return min((path for path in pathCache.values() if len(path)==k), key=sum)", "def move_character(grid, commands):\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    treasures = sum(row.count('T') for row in grid)\n    character_position = [(i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == 'C'][0]\n\n    for command in commands:\n        new_row = character_position[0] + directions[command][0]\n        new_col = character_position[1] + directions[command][1]\n\n        if 0 <= new_row < len(grid) and 0 <= new_col < len(grid[0]):\n            if grid[new_row][new_col] == 'T':\n                treasures -= 1\n            elif grid[new_row][new_col] == 'O':\n                return \"Game over!\"\n            grid[character_position[0]][character_position[1]] = '.'\n            grid[new_row][new_col] = 'C'\n            character_position = (new_row, new_col)\n\n        if treasures == 0:\n            return \"You win!\"\n\n    return \"You lose!\"", "def minTimeToEmptyWells(grid, bucket_capacity):\n    count = [0] * len(grid[0])\n    for row in grid:\n        for j in range(len(row)):\n            count[j] += row[j]\n    count.sort()\n\n    time = 0\n    while count:\n        i = len(count) - 1\n        while i >= 0 and count[i] > 0:\n            count[i] -= bucket_capacity\n            i -= 1\n        count = [x for x in count if x > 0]\n        time += 1\n\n    return time - 1 if len(grid[0]) > bucket_capacity else time"]}
{"task_id": "HumanEval/116", "problem": ["def test_unique_elements():\n    # Test case 1: Empty array\n    assert unique_elements([]) == []\n\n    # Test case 2: Array with all elements being the same\n    assert unique_elements([5, 5, 5, 5, 5]) == [5]\n\n    # Test case 3: Array with mix of positive and negative integers\n    assert unique_elements([1, 2, 3, 4, 5, 4, 3, 2, 1, -1, -2, -3, -4, -5]) == [1, 2, 3, 4, 5, -1, -2, -3, -4, -5]\n\n    # Test case 4: Array with no repeated elements\n    assert unique_elements([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\n    print(\"All test cases pass\")", "def get_positive_and_sort(l: list):\n    \"\"\"Return only positive numbers in the list, sorted in ascending order.\n    >>> get_positive_and_sort([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive_and_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n\n    return sorted([num for num in l if num > 0])", "def sort_by_binary_len(arr):\n    \"\"\"\n    Reorders an array of strictly positive integers according to\n    the length of their binary representations, in increasing order.\n    In instances of overlapping binary lengths, the array uses\n    decimal numerical values as the basis for establishing order.\n\n    The output produced should conform to the examples provided:\n    >>> sort_by_binary_len([1, 31, 15, 2, 7]) == [1, 2, 7, 15, 31]\n    >>> sort_by_binary_len([14, 58, 39, 41, 61]) == [14, 39, 41, 58, 61]\n    >>> sort_by_binary_len([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n\n    # Sort the array based on binary length and then value\n    return sorted(arr, key = lambda x: (bin(x)[2:], x))", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n\n    result = []\n    for num in l:\n        if num > 0:\n          result.append(num)\n    return result", "def get_positive_and_sort(n: list):\n    \"\"\"\n    Discard only the positive numbers in the list and arrange them in incremental order.\n    >>> get_positive_and_sort([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive_and_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n\n    positive_nums = [num for num in n if num > 0]  # Filter out positive numbers.\n    return sorted(positive_nums)  # Sort the positive numbers."]}
{"task_id": "HumanEval/117", "problem": ["def print_lyrics():\n    print(\"Mary had a little lamb, its fleece was white as snow;\")\n    print(\"And everywhere that Mary went, the lamb was sure to go.\")\n    print(\"It followed her to school each day, t'was even known to play;\")\n    print(\"And all the children shouted out, 'Oh, Mary, what a lamb!' \")", "def decode_cyclic(s: str):\n    \"\"\"\n    A function that handles a string encoded with the mischievous encode_cyclic function and returns the decoded string, handling singular characters, empty spaces, and punctuation.\n    \"\"\"\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)", "def all_prefixes_with_lengths(string: str) -> List[Tuple[str, int]]:\n    \"\"\" \n    Function that returns a list of tuples which include all prefixes of an input string from smallest to largest and their corresponding lengths\n    E.g. all_prefixes_with_lengths('abc') should return [('a', 1), ('ab', 2), ('abc', 3)]\n    \"\"\"\n    return [(string[:i], i) for i in range(1, len(string)+1)]", "def decode_cyclic(s: str):\n    \"\"\"\n    Should handle a string encoded with the encode_cyclic function and return the decoded string,\n    managing singular characters, empty spaces, and punctuation.\n    \"\"\"\n    groups = [s[3 * i:min(3 * i + 3, len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [group[-1] + group[:-1] if len(group) == 3 else group for group in groups]\n\n    return \"\".join(groups)", "def decode_cyclic(s: str):\n    \"\"\"\n    should handle a string encoded with the encode_cyclic function and return the decoded string, managing singular characters, empty spaces, and punctuation.\n    \"\"\"\n\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n\n    return \"\".join(groups)"]}
{"task_id": "HumanEval/118", "problem": ["def get_closest_vowel(word):\n    \"\"\"Input a word and then find out the vowel closest from the right side of the word that is \n    between two consonants, distinguishing between upper and lower case. Ignore vowels at the \n    beginning or end of the word. If this kind of vowel does not exist, return an empty string. \n    Assume that the input string only contains English letters.\n\n    Examples:\n    get_closest_vowel(\"yogurt\") => \"u\"\n    get_closest_vowel(\"FULL\") => \"U\"\n    get_closest_vowel(\"quick\") => \"\"\n    get_closest_vowel(\"ab\") => \"\"\n    \"\"\"\n\n    # First, strip any vowels from the beginning and end of the word,\n    while len(word) > 0 and (word[0] in 'aeiouAEIOU' or word[-1] in 'aeiouAEIOU'):\n        if word[0] in 'aeiouAEIOU':\n            word = word[1:]\n\n        if len(word) > 0 and word[-1] in 'aeiouAEIOU':\n            word = word[:-1]\n\n    # Then, find the closest vowel sequence from the right side,\n    for i in range(len(word)-1, -1, -1):\n        if word[i] in 'aeiouAEIOU':\n            return word[i]\n    return \"\"", "def get_closest_vowel(word):\n    \"\"\"Insert a word, and then retrieve the nearest vowel that is ensconced amid a pair of consonants, \n    starting from the right section of the word, while being case-sensitive. \n    Bypass vowels at either the genesis or finale of the word. \n    Respond with a vacant string if such a vowel is nonexistent. \n    Presume that the input string is comprised strictly of English letters.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\n\n    vowels = 'aeiouAEIOU'\n    for i in reversed(range(1, len(word) - 1)): #not including the first and the last characters\n        if (word[i] in vowels) and (word[i - 1] not in vowels) and (word[i + 1] not in vowels):\n            return word[i]\n    return ''", "def get_closest_vowel(word):\n    \"\"\"\n    Enter a word, proceeding to pinpoint the nearest vowel nestled between a \n    dual of consonants, initiating from the right portion of the word, whilst \n    honoring case-sensitivity. Overlook vowels situated at the word's inception \n    or termination. Relay an unoccupied string if such a character is absent. \n    Assume the input string to be constituted exclusively of English alphabets.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    for i in range(len(word) - 1, 0, -1):\n        if word[i] in vowels and word[i-1] not in vowels and word[i+1] not in vowels:\n            return word[i]\n    return \"\"", "def get_first_consonant_flanked_vowel(word):\n    \"\"\"Given a word, find the first vowel that is enclosed by consonants from the left side of the word (case sensitive). Do not include vowels at the initiation or cessation of the word. Return an empty string if no such vowel found. The input string must only have English characters.\n\n    Example:\n    get_first_consonant_flanked_vowel(\"umbrella\") ==> \"e\"\n    get_first_consonant_flanked_vowel(\"STRONG\") ==> \"O\"\n    get_first_consonant_flanked_vowel(\"grape\") ==> \"a\"\n    get_first_consonant_flanked_vowel(\"fly\") ==> \"\"\n    \"\"\"\n    vowels = 'AEIOUaeiou'\n    for i in range(1, len(word) - 1):  # Skip first and last characters\n        if word[i] in vowels and word[i - 1] not in vowels:\n            return word[i]\n    \n    return \"\"  # Return empty string if no vowel found", "def get_first_consonant_flanked_vowel(word):\n    \"\"\"\n    Given a word, find the first vowel that is enclosed by consonants from the left side of the word (case sensitive). \n    Do not include vowels at the initiation or cessation of the word. \n    Return an empty string if no such vowel found. \n    The input string must only have English characters.\n\n    Example:\n    get_first_consonant_flanked_vowel(\"umbrella\") --> \"e\"\n    get_first_consonant_flanked_vowel(\"STRONG\") --> \"O\"\n    get_first_consonant_flanked_vowel(\"grape\") --> \"a\"\n    get_first_consonant_flanked_vowel(\"fly\") --> \"\"\n    \"\"\"\n    vowels = 'AEIOUaeiou'\n\n    for i in range(1, len(word) - 1):  # Skip first and last characters\n        if word[i] in vowels and word[i - 1] not in vowels:\n            return word[i]\n\n    return \"\"  # Return empty_string if no vowel found"]}
{"task_id": "HumanEval/119", "problem": ["def advanced_bracket_sequence(arr):\n    '''\n    Accepting an array of minimum two singular strings containing only open parentheses '(',\n    closing parentheses ')', open curly braces '{' and closing curly braces '}'. \n    The function ought to determine if a possible concatenation sequence exists, \n    that when assembled results in a string with accurately nested brackets. \n    For example, '(()){}' is a valid sequence, while '()){)' isn't.\n    The function returns 'Yes' for a possible sequence, or 'No' otherwise.\n\n    Examples:\n    advanced_bracket_sequence(['(', ')(){', '((']) == 'Yes'\n    advanced_bracket_sequence([')', ')', '(', '{', '}', '(', '{']) == 'No'\n    '''\n    bracket_types = {'(': ')', '{': '}'}\n    open_brackets, closed_brackets = [], []\n\n    for cell in arr:\n        for char in cell:\n            if char in bracket_types:\n                open_brackets.append(char)\n            else:\n                if len(open_brackets) == 0:\n                    return 'No'\n                else:\n                    if bracket_types[open_brackets[-1]] == char:\n                        open_brackets.pop()\n                    else:\n                        return 'No'\n            \n    if len(open_brackets) > 0:\n        return 'No'\n\n    return 'Yes'", "def advanced_bracket_sequence(arr):\n    '''\n    Accepting an array of minimum two singular strings containing only open parentheses '(',\n    closing parentheses ')', open curly braces '{' and closing curly braces '}'.\n    The function ought to determine if a possible concatenation sequence exists \n    that when assembled results in a string with accurately nested brackets.\n    For example, '[()]{}' is a valid sequence, while '[(])(){' isn't.\n    The function returns 'Yes' for a possible sequence, or 'No' otherwise.\n    \n    Examples:\n    advanced_bracket_sequence(['(', ')(){', '((']) == 'Yes'\n    advanced_bracket_sequence([']', ')', '(', '{', '}', '(', '(']) == 'No'\n    '''\n    bracket_types = {'(': ')', '{': '}'}\n    open_brackets, closed_brackets = [], []\n\n    for cell in arr:\n        for char in cell:\n            if char in bracket_types:\n                open_brackets.append(char)\n            else:\n                if len(open_brackets) == 0:\n                    return 'No'\n                else:\n                    if bracket_types[open_brackets[-1]] == char:\n                        open_brackets.pop()\n                    else:\n                        return 'No'\n\n    if len(open_brackets) > 0:\n        return 'No'\n\n    return 'Yes'", "def match_braces(lst):\n    # Concatenate all the parentheses into a single string\n    opening_parentheses = ['(', '[']\n    closing_parentheses = [')', ']']\n    stack = []\n    s = ''.join(lst)\n    for i in s:\n        # If the character is an opening parentheses, push it onto the stack\n        if i in opening_parentheses:\n            stack.append(i)\n        # If the character is a closing parentheses, check if it matches with the last opening parentheses on the stack\n        elif i in closing_parentheses:\n            # If the stack is empty or there is no match, return 'No'\n            if not stack or opening_parentheses.index(stack.pop()) != closing_parentheses.index(i):\n                return 'No'\n    # If there are still unmatched opening parentheses in the stack, return 'No'\n    if stack:\n        return 'No'\n    return 'Yes'", "def check_nested_sequences(sequence):\n    '''\n    This function should take a string consisting of '(' and ')' characters, and check whether the parentheses in the string are correctly nested.\n    That is, each '(' must be eventually followed by a ')', and at any point in the string, there cannot be more ')' characters \n    preceding than '(' characters.\n    If the string is correctly nested, it should return 'Yes'. Otherwise, it should return 'No'.\n    '''\n    stack = []\n    for char in sequence:\n        if char == '(':\n            stack.append(char)\n        elif char == ')' and len(stack) > 0:\n            stack.pop()\n        else:\n            return 'No'\n    return 'Yes' if not stack else 'No'", "def check_nested_sequences(sequence):\n    '''\n    This function should take a string consisting of '(' and ')' characters, and check whether the parentheses in the string are correctly nested,\n    That is, each '(' must be eventually followed by a ')', and at any point in the string, there cannot be more ')' characters \n    preceding than '(' characters.\n    If the string is correctly nested, it should return 'Yes'. otherwise, it should return 'No'.\n    '''\n    stack = []\n    for char in sequence:\n        if char == '(':\n            stack.append(char)\n        elif char == ')' and len(stack) > 0:\n            stack.pop()\n        else:\n            return 'No'\n    return 'Yes' if not stack else 'No'"]}
{"task_id": "HumanEval/120", "problem": ["def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n        1. Perform rightward shifting operation as required.\n        2. Swap at most three pair of balls.\n        3. After the operations, elements smaller than the first element in the array should be odd in number.\n\n    Return True, if the array could be sorted, otherwise False. \n\n    Examples:\n    move_three_balls([3, 4, 5, 1, 2, 6]) => True\n    move_three_balls([1, 3, 5, 4, 2, 6]) => True\n    move_three_balls([1, 2, 3, 5, 4, 6]) => True\n    move_three_balls([5, 4, 3, 1, 2, 6]) => False\n\n    \"\"\"\n    if not arr:\n        return True\n\n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False", "def test_bubble_sort():\n    # Empty array\n    arr = []\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != []:\n        print(\"Error: Bubble Sort failed on empty array.\")\n\n    # Array with duplicate values\n    arr = [4, 3, 2, 2, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 2, 3, 4]:\n        print(\"Error: Bubble Sort failed on array with duplicate values.\")\n\n    # Sorted array in descending order\n    arr = [5, 4, 3, 2, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 3, 4, 5]:\n        print(\"Error: Bubble Sort failed on sorted array in descending order.\")\n\n    # Random unsorted array\n    arr = [5, 3, 2, 4, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 3, 4, 5]:\n        print(\"Error: Bubble Sort failed on random unsorted array.\")", "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n    1. Perform rightward shifting operation as required.\n    2. Swap at most three pair of balls.\n    3. After the operations, elements smaller than the first element in the array should be odd in number.\n    \n    Return True, if the array could be sorted; otherwise, False. \n    \n    Examples:\n    move_three_balls([5, 4, 5, 1, 2, 6]) -> True\n    move_three_balls([1, 3, 5, 4, 2, 6]) -> True\n    move_three_balls([1, 2, 3, 5, 4, 6]) -> True\n    move_three_balls([5, 4, 3, 1, 2, 6]) -> False\n    \"\"\"\n    \n    if not arr:\n        return True\n    \n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False", "def quicksort(arr):\n    \"\"\"\n    Sorts the input array in-place using the Quicksort algorithm with duplicate handling.\n    \"\"\"\n    if len(arr) <= 1:\n        return\n    # Choose two pivot elements\n    pivot1, pivot2 = arr[0], arr[-1]\n    i, j = 0, len(arr) - 1\n    k = 0\n    while k <= j:\n        if arr[k] < pivot1:\n            arr[i], arr[k] = arr[k], arr[i]\n            i += 1\n            k += 1\n        elif arr[k] > pivot2:\n            arr[j], arr[k] = arr[k], arr[j]\n            j -= 1\n        else:\n            k += 1\n    # Recursively sort the first and third sub-arrays\n    quicksort(arr[:i])\n    quicksort(arr[j+1:])", "def max_subarray_sum(arr, k):\n    length = len(arr)\n    # Handling edge cases\n    if not arr or length < k:\n        return \"Invalid input\"\n    if length == k and all(i < 0 for i in arr):\n        return \"All numbers in the array are negative\"\n    \n    # Create and initialize variables\n    window_sum, max_sum = sum(arr[:k]), sum(arr[:k])\n    start_index = 0\n    \n    # Slide the window\n    for i in range(k, length):\n        window_sum = window_sum - arr[i - k] + arr[i]\n        if window_sum > max_sum:\n            max_sum = window_sum\n            start_index = i - k + 1\n    end_index = start_index + k - 1\n    \n    # Return maximum sum and start and end index of that subarray\n    return max_sum, start_index, end_index"]}
{"task_id": "HumanEval/121", "problem": ["def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)", "def enhanced_solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are at even positions.    \n\n    Examples\n    enhanced_solution([5, 8, 7, 1]) => 5\n    enhanced_solution([3, 3, 3, 3, 3]) => 9\n    enhanced_solution([30, 13, 24, 321]) => 30\n    \"\"\"\n    return sum(num for i, num in enumerate(lst[::2]) if num % 2 == 1)", "def sum_even_numbers(numbers):\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The sum of all even numbers in the list.\n\n    Examples:\n    >>> sum_even_numbers([1, 2, 3, 4, 5, 6])\n    12\n    >>> sum_even_numbers([10, 11, 12, 13, 14, 15])\n    36\n    >>> sum_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)", "def sum_of_even_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers: A list of integers.\n\n    Returns:\n    The sum of all even numbers in the list.\n    \n    Examples:\n    >>> sum_of_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    30\n    >>> sum_of_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_of_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)", "def solve_system():\n    # System of Equations\n    A = np.array([[5, -2, 3], \n                  [2, 1, -1], \n                  [-1, 3, 1]])\n    B = np.array([11, 8, -2])\n    # Solving the System\n    solution = np.linalg.solve(A, B)\n    return solution"]}
{"task_id": "HumanEval/122", "problem": ["def max_sum_subarray(arr, k):\n    '''This function takes an array of integers and an integer k and returns the maximum sum of a subarray of size k.'''\n    \n    if len(arr) < k:\n        return 0\n    \n    max_sum = 0\n    sum = 0\n    for i in range(k):\n        sum += arr[i]\n    \n    max_sum = sum\n    i = 0\n    j = k\n    while j < len(arr):\n        sum = sum - arr[i] + arr[j]\n        if sum > max_sum:\n            max_sum = sum        \n        i += 1\n        j += 1\n    return max_sum", "def quicksort(arr):\n    \"\"\"\n    Sorts the input array in-place using the Quicksort algorithm with duplicate handling.\n    \"\"\"\n    if len(arr) <= 1:\n        return\n    # Choose two pivot elements\n    pivot1, pivot2 = arr[0], arr[-1]\n    i, j = 0, len(arr) - 1\n    k = 0\n    while k <= j:\n        if arr[k] < pivot1:\n            arr[i], arr[k] = arr[k], arr[i]\n            i += 1\n            k += 1\n        elif arr[k] > pivot2:\n            arr[j], arr[k] = arr[k], arr[j]\n            j -= 1\n        else:\n            k += 1\n    # Recursively sort the first and third sub-arrays\n    quicksort(arr[:i])\n    quicksort(arr[j+1:])", "def max_sum_subarray(arr, k):\n    # Check if the length of the array is less than 'k'\n    if len(arr) < k:\n        return \"Invalid\"\n\n    # Compute the sum of first 'k' elements  \n    window_sum = sum(arr[:k])\n\n    # This sum is the maximum sum so far\n    max_sum = window_sum\n    \n    # Slide the window over the array \n    for i in range(k, len(arr)):\n        # Subtract the element going out and add the element coming in \n        window_sum = window_sum - arr[i - k] + arr[i]\n        max_sum = max(window_sum, max_sum)\n\n    return max_sum", "def three_sum(arr, target):\n    \"\"\"\n    This function takes an array and an Integer and finds three elements of the array which sum up \n    to the given number.\n\n    Parameters\n    ----------\n    arr : list\n        list of numbers\n    target : int\n        target sum\n    \n    Returns\n    -------\n    list\n        list of three elements which sum up to the target\n    \"\"\"\n    # sort the list\n    arr.sort()\n    \n    # loop through the list from 0 to length-2\n    for i in range(len(arr)-2):\n        # set j to start from the next index and k to start from the last index\n        j, k = i+1, len(arr)-1\n        # find the target sum\n        while j < k:\n            s = arr[i] + arr[j] + arr[k]\n            if s == target:\n                return [arr[i], arr[j], arr[k]]\n            elif s < target:\n                j += 1\n            else:\n                k -= 1", "def max_subarray_sum(arr, k):\n    length = len(arr)\n    # Handling edge cases\n    if not arr or length < k:\n        return \"Invalid input\"\n    if length == k and all(i < 0 for i in arr):\n        return \"All numbers in the array are negative\"\n    \n    # Create and initialize variables\n    window_sum, max_sum = sum(arr[:k]), sum(arr[:k])\n    start_index = 0\n    \n    # Slide the window\n    for i in range(k, length):\n        window_sum = window_sum - arr[i - k] + arr[i]\n        if window_sum > max_sum:\n            max_sum = window_sum\n            start_index = i - k + 1\n    end_index = start_index + k - 1\n    \n    # Return maximum sum and start and end index of that subarray\n    return max_sum, start_index, end_index"]}
{"task_id": "HumanEval/123", "problem": ["def fib(n):\n    # checks if the input is below 0 which is invalid.\n    if n < 0:\n        return \"Invalid input. Please enter a positive number\"\n\n    # initializes a list to store the sequence\n    fib_sequence = [0, 1] + [0] * (n - 1)\n\n    # iterates from the 3rd term to nth term to fill the list\n    for i in range(2, n + 1):\n        fib_sequence[i] = fib_sequence[i - 1] + fib_sequence[i - 2]\n\n    # returns the full fibonacci sequence list and the nth term\n    return fib_sequence[:n+1], fib_sequence[n]", "def fibonacci_sequence(n):\n    sequence = [0, 1]  # Initialize the sequence with the first two terms\n    total_sum = sum(sequence)  # Initialize the sum of the sequence\n    \n    if n <= 2:\n        return sequence[:n], total_sum  # Return the sequence and sum if n is 1 or 2\n    \n    for i in range(2, n):\n        next_term = sequence[-1] + sequence[-2]  # Calculate the next term by summing the last two terms\n        sequence.append(next_term)  # Add the next term to the sequence\n        total_sum += next_term  # Add the next term to the sum\n    \n    return sequence, total_sum  # Return the complete sequence and the sum", "def generate_fibonacci(n):\n    # validate the input, it should only be positive integer\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"The number of terms should be a positive integer.\")\n\n    # generate the sequence\n    fib_sequence = []\n\n    # the sequence starts with 0 and 1\n    if n >= 1:\n        fib_sequence.append(0)\n    if n >= 2:\n        fib_sequence.append(1)\n\n    # calculate the rest of the sequence\n    for i in range(2, n):\n        next_term = fib_sequence[i-1] + fib_sequence[i-2]   # each term is the sum of the previous two terms\n        fib_sequence.append(next_term)\n\n    return fib_sequence", "def Fibonacci(n): \n    # If n is negative, return None\n    if n < 0: \n        return None\n    # Create an array to store Fibonacci sequence\n    fibo = [0, 1] \n      \n    # Append the next term until the n-th term\n    for i in range(2, n): \n        fibo.append(fibo[i-1] + fibo[i-2])\n    # Return the required term\n    return fibo[n-1]", "def fibonacci_sequence(n):\n    # Initializing first two Fibonacci numbers\n    # Fibonacci series is 0, 1, 1, 2, 3, 5, 8, 13, ...\n    fib_sequence = [0, 1]\n   \n    # Calculate the next Fibonacci term using the formula (nth-1 term + nth-2 term)\n    while len(fib_sequence) < n:\n        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])\n    \n    return fib_sequence"]}
{"task_id": "HumanEval/124", "problem": ["def send_warning(scheduled_date):\n    # Calculate the difference between the current date and the scheduled date\n    diff = scheduled_date - datetime.date.today()\n\n    # If the difference is less than or equal to 7 days, send a warning message\n    if diff.days <= 7:\n        print(\"Warning: Scheduled business trip approaching in\", diff.days, \"days.\")", "def convert_date(input_date):\n    # Split the input_date string into day, month, and year\n    date_parts = input_date.split('/')\n    \n    # Check if the input_date has three parts\n    if len(date_parts) != 3:\n        return \"Invalid date\"\n    \n    # Convert the day, month, and year strings into integers\n    day = int(date_parts[1])\n    month = int(date_parts[0])\n    year = int(date_parts[2])\n    \n    # Check if the month value is valid (between 1 and 12)\n    if month < 1 or month > 12:\n        return \"Invalid date\"\n    \n    # Check if the day value is valid for the given month and year\n    if day < 1 or day > 31:\n        return \"Invalid date\"\n    \n    # Check for months with 30 days\n    if month in [4, 6, 9, 11] and day > 30:\n        return \"Invalid date\"\n    \n    # Check for February\n    if month == 2:\n        # Check if it is a leap year\n        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):\n            if day > 29:\n                return \"Invalid date\"\n        else:\n            if day > 28:\n                return \"Invalid date\"\n    \n    # Convert the date to the required format (DD-MM-YYYY)\n    converted_date = str(day).zfill(2) + '-' + str(month).zfill(2) + '-' + str(year)\n    \n    return converted_date", "def is_valid_date(date):\n    # Mapping of month names to their respective number\n    month_map = {\n        'jan': 1, 'feb': 2, 'mar': 3, 'apr': 4, 'may': 5, 'jun': 6,\n        'jul': 7, 'aug': 8, 'sep': 9, 'oct': 10, 'nov': 11, 'dec': 12\n    }\n\n    # Mapping of month numbers to their respective number of days\n    month_days_map = {\n        1: 31, 2: 28, 3: 31, 4: 30, 5: 31, 6: 30,\n        7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31\n    }\n\n    # Remove any leading or trailing whitespaces\n    date = date.strip()\n\n    # Determine the separator used in the date\n    separators = ['/','-','.']\n    separator = None\n    for sep in separators:\n        if sep in date:\n            separator = sep\n            break\n\n    if separator is None:\n        return False\n\n    # Split the date into month, day, and year\n    parts = date.split(separator)\n\n    if len(parts) != 3:\n        return False\n\n    # Extract the month, day, and year from the parts\n    if separator == '.':\n        month, day, year = parts[0], parts[1], parts[2]\n    else:\n        month, day, year = parts[0], parts[1], parts[2][:4] # Handle case of year with more than 4 digits\n\n    # Convert the month to a number\n    if month.isdigit():\n        month = int(month)\n    else:\n        month = month_map.get(month.lower())\n\n    # Check if the month is valid\n    if month is None or month < 1 or month > 12:\n        return False\n\n    # Check if the year is valid\n    if not year.isdigit() or len(year) != 4:\n        return False\n\n    year = int(year)\n\n    # Check for dates before the adoption of the Gregorian calendar (October 4, 1582 and earlier)\n    if year < 1582 or (year == 1582 and month < 10) or (year == 1582 and month == 10 and day < 4):\n        return False\n\n    # Check if it's a leap year and adjust the number of days in February accordingly\n    if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n        month_days_map[2] = 29\n\n    # Check if the day is valid\n    if not day.isdigit() or int(day) < 1 or int(day) > month_days_map[month]:\n        return False\n\n    return True", "def sum_days(date1_str, date2_str):\n    dateFormat = \"%Y-%m-%d\"\n    try:\n        # Convert string to date\n        date1 = dt.strptime(date1_str, dateFormat)\n        date2 = dt.strptime(date2_str, dateFormat)\n        \n        # Check if date1 is later than date2\n        if date1 > date2:\n            print(\"Error: The first date is later than the second date.\")\n            return \"Invalid Input\"\n        \n        # Compute the cumulative sum of days\n        delta = date2 - date1\n        return delta.days\n    except ValueError:\n        print(\"Error: The date format is incorrect. Please use the 'YYYY-MM-DD' format.\")\n        return \"Invalid Input\"", "def is_valid_ipv4_address(ip_address):\n    # Check if the string is empty\n    if not ip_address:\n        return False\n    \n    # Check if the string contains any characters other than digits and periods\n    if not all(char.isdigit() or char == '.' for char in ip_address):\n        return False\n    \n    # Split the string into four decimal numbers\n    decimal_numbers = ip_address.split('.')\n    \n    # Check if there are more or less than four decimal numbers\n    if len(decimal_numbers) != 4:\n        return False\n    \n    for number in decimal_numbers:\n        # Check if the decimal number contains leading or trailing whitespace\n        if number.strip() != number:\n            return False\n        \n        # Check if the decimal number is within the range of 0 to 255\n        if not 0 <= int(number) <= 255:\n            return False\n    \n    return True"]}
{"task_id": "HumanEval/125", "problem": ["def generate_polymorphic_hello_world():\n    # Define a list of different ways to print \"Hello, World!\" in Python\n    print_statements = [\n        'print(\"Hello, World!\")',\n        'print(\"Hello,\" + \" World!\")',\n        'print(\"\".join([\"Hello\", \", \", \"World!\"]))',\n        'print(\"{}, {}!\".format(\"Hello\", \"World\"))',\n        'print(f\"{\"Hello\"}, {\"World\"}!\")'\n    ]\n\n    # Define a list of no-operation (NOP) instructions for obfuscation\n    nop_operations = [\"\", \"pass\", \"# no operation\"]\n\n    # Randomly select a print statement and NOPs\n    print_statement = random.choice(print_statements)\n    nop = random.choice(nop_operations)\n\n    # Generate a polymorphic function with the selected NOP and print statement\n    polymorphic_function = f\"\"\"def polymorphic_hello_world():\n    {nop}\n    {print_statement}\n    {nop}\n\"\"\"\n\n    return polymorphic_function", "def print_hello_world():\n    print(\"Hello, world!\")\n    print(\"Hello, world!\")\n    print(\"Hello, world!\")\n    print(\"Hello, world!\")\n    print(\"Hello, world!\")\n    print(\"Hello, world!\")\n    print(\"Hello, world!\")\n    print(\"Hello, world!\")\n    print(\"Hello, world!\")\n    print(\"Hello, world!\")", "def reverse_string_words(s, target):\n    # Firstly we replace commas and fullstops with space, \n    # to have just one delimiter for splitting the string\n    replaced = s.replace(\",\", \" \").replace(\".\", \" \")\n\n    # Then split the string by space to make a list\n    split_words = replaced.split()\n\n    # Remove target words from list\n    split_words = [word for word in split_words if word != target]\n\n    # Reverse the list\n    reversed = split_words[::-1]\n\n    return reversed", "def code_generator(language, instructions): \n    if language == 'Python': \n        code_string = 'print(\"Hello World!\")' \n    elif language == 'Java': \n        code_string = 'System.out.println(\"Hello World!\");' \n \n    return code_string", "def generate_polymorphic_payload():\n    \"\"\"Generate a polymorphic payload that prints \"Hello, World!\".\"\"\"\n    key = generate_random_key()\n    payload = \"print('Hello, World!')\"\n    encrypted_payload = encrypt(payload, key)\n    return encrypted_payload, key"]}
{"task_id": "HumanEval/126", "problem": ["def will_it_fly(q,w):\n    '''\n    The function's purpose is to discern q's flight potential, return True if achievable, and False if not. For q to fly, it must fulfil two prerequisites: it must be palindromic and the total weights of its elements should not go beyond the maximum acceptable weight w.\n\n    Implement the function with error handling mechanisms. It should return a \"Non-numeric input\" error if it receives a non-numeric input, and a \"Non-sequence input\" error if it receives a non-sequence input.\n\n    Examples:\n    will_it_fly([1, 2], 5) \u279e False \n\n    will_it_fly([3, 2, 3], 1) \u279e False\n\n    will_it_fly([3, 2, 3], 9) \u279e True\n\n    will_it_fly([3], 5) \u279e True\n    \n    Error Cases:\n    will_it_fly([\"a\",\"b\",\"c\"], 5) \u279e \"Non-numeric input\"\n    \n    will_it_fly(123, 5) \u279e \"Non-sequence input\"\n    '''\n    # Handle Non-sequence input error\n    if not isinstance(q, (list, tuple, str)):\n        return \"Non-sequence input\"\n    \n    for i in q:\n        # Handle Non-numeric input error\n        if not isinstance(i, (int, float)):\n            return \"Non-numeric input\"\n    \n    return is_palindrome(q) and sum(q) <= w", "def test_quick_sort():\n    assert quick_sort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10]\n    assert quick_sort([3]) == [3]\n    assert quick_sort([]) == []\n    assert quick_sort([9, 8, 7, 6, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert quick_sort([1, 2, 3, 4, 5, 6, 7, 8, 9]) == [1, 2, 3, 4, 5, 6, 7, 8, 9]", "def generate_rubik():\n    cube = [[[0 for i in range(3)] for j in range(3)] for k in range(3)]\n    initial_gates = [\n        [[6, 6, 6], [2, 0, 1], [3, 4, 5]],\n        [[0, 0, 0], [1, 1, 1], [2, 2, 2]],\n        [[7, 7, 7], [5, 4, 3], [2, 1, 0]],\n        [[7, 7, 7], [3, 4, 5], [1, 0, 2]],\n        [[5, 5, 5], [3, 0, 4], [2, 1, 7]],\n        [[5, 5, 5], [1, 0, 2], [4, 7, 3]]\n    ]\n    for i in range(6):\n        for j in range(3):\n            for k in range(3):\n                cube[i][j][k] = initial_gates[i][j][k]\n    return cube", "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n        1. Perform rightward shifting operation as required.\n        2. Swap at most three pair of balls.\n        3. After the operations, elements smaller than the first element in the array should be odd in number.\n\n    Return True, if the array could be sorted, otherwise False. \n\n    Examples:\n    move_three_balls([3, 4, 5, 1, 2, 6]) => True\n    move_three_balls([1, 3, 5, 4, 2, 6]) => True\n    move_three_balls([1, 2, 3, 5, 4, 6]) => True\n    move_three_balls([5, 4, 3, 1, 2, 6]) => False\n\n    \"\"\"\n    if not arr:\n        return True\n\n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False", "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n    1. Perform rightward shifting operation as required.\n    2. Swap at most three pair of balls.\n    3. After the operations, elements smaller than the first element in the array should be odd in number.\n    \n    Return True, if the array could be sorted; otherwise, False. \n    \n    Examples:\n    move_three_balls([5, 4, 5, 1, 2, 6]) -> True\n    move_three_balls([1, 3, 5, 4, 2, 6]) -> True\n    move_three_balls([1, 2, 3, 5, 4, 6]) -> True\n    move_three_balls([5, 4, 3, 1, 2, 6]) -> False\n    \"\"\"\n    \n    if not arr:\n        return True\n    \n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False"]}
{"task_id": "HumanEval/127", "problem": ["def convert_all_sums(n, m, start, base):\n    \"\"\"\n    You are provided two positive integers n and m (n <= m), and an additional starting number (start),\n    your task is to determine the sum of all the numbers from n through m (inclusive), starting from the 'start' number.\n    Then convert the sum into a custom base system. The custom base system will be another integer (base)\n    ranging from [2, 10] (inclusive). If n is greater than m, the start number is less than zero,\n    or the base is out of the given range, return -1. \n    \n    Example:\n    convert_all_sums(1, 5, 0, 2) => \"0b110\"\n    convert_all_sums(7, 5, 2, 2) => -1\n    convert_all_sums(10, 2, 10, 2) => \"0b10110\"\n    convert_all_sums(20, 33, 0, 2) => \"0b110101\"\n    convert_all_sums(15, 20, 10, 8) => \"0o25\"\n    \"\"\"\n    # Check for valid input\n    if n > m or start < 0 or not(2 <= base <= 10):\n        return -1\n    # Calculates the sum of the series\n    total = sum(range(n, m+1)) + start\n    # Converts the sum to the appropriate base\n    if base == 2:\n        return bin(total)\n    elif base == 8:\n        return oct(total)\n    elif base == 10:\n        return str(total)\n    else:\n        return \"Base not supported\"", "def maximumSizeOfSet(intervals):\n    # Initialize S as an empty priority queue\n    S = []\n\n    # Sort the intervals by the start point\n    intervals.sort()\n\n    # For each interval\n    for start, end in intervals:\n        if S and S[0] < start:\n            # If the smallest element in S is less than start,\n            # pop it until it is not smaller than start.\n            heapq.heappop(S)\n\n        if len(S) < 2:\n            # If the queue size is 0 or 1, then push end into the priority queue.\n            heapq.heappush(S, end)\n        elif S[0] < end:\n            # If the smallest element in S is less than end,\n            # then pop it and push end into the priority queue.\n            heapq.heappop(S)\n            heapq.heappush(S, end)\n\n    # Return the size of S\n    return len(S)", "def convert_all_sums(n, m, start, base):\n    \"\"\"\n    You are provided two positive integers n and m (n <= m), \n    and an additional starting number (start), \n    your task is to determine the sum of all the numbers from n through m (inclusive), starting from the 'start' number,\n    Then convert the sum into a custom base system. The custom base system will be another integer (base)\n    ranging from [2, 10] (inclusive), If n is greater than m, the start number is less than zero,\n    or the base is out of the given range, return -1,\n\n    Example:\n    convert_all_sums(1, 5, 0, 2) => \"0b110\"\n    convert_all_sums(7, 5, 2, 2) => -1\n    convert_all_sums(10, 2, 10, 2) => \"0b1010\"\n    convert_all_sums(20, 33, 0, 2) => \"0b110101\"\n    convert_all_sums(15, 20, 10, 2) => \"0b25\"\n    \"\"\"\n    # Check for valid input\n    if n > m or start < 0 or not(2 <= base <= 10):\n        return -1\n    # Calculates the sum of the series\n    total = sum(range(n, m+1)) + start\n    # Converts the sum to the appropriate base\n    if base == 2:\n        return bin(total)\n    elif base == 8:\n        return oct(total)\n    elif base == 10:\n        return str(total)\n    else:\n        return \"Base not supported\"", "def print_prime_numbers(start, end):\n    if start <= end:\n        print(\"The first integer must be greater than the second integer.\")\n        return\n    prime_numbers = [n for n in range(start, end - 1, -1) if is_prime(n)]\n    if prime_numbers:\n        print(\"Prime numbers between\", start, \"and\", end, \"are:\")\n        for prime in prime_numbers:\n            print(prime)\n    else:\n        print(\"There are no prime numbers between\", start, \"and\", end)", "def cubed_results(interval):\n    try:\n        #check if the input is a list and has at least two elements\n        if type(interval) is not list or len(interval) < 2:\n            raise ValueError('The input should be a list containing at least two elements (interval).')\n            \n        #check if the first two elements of the list are integers\n        if not all(isinstance(i, int) for i in interval[:2]):\n            raise ValueError('First two elements of the list should be integers.')\n            \n        # check if interval's start is less than its end\n        if interval[0] >= interval[1]:\n            raise ValueError('The interval is not correct, its start should be smaller than its end')\n        \n        numbers = np.arange(interval[0], interval[1])\n        cubed_values = numbers**3\n        cube_roots = np.cbrt(cubed_values)\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return None\n    return cubed_values, cube_roots"]}
{"task_id": "HumanEval/128", "problem": ["def prod_signs(arr):\n    \"\"\"\n    Given an array arr made up of non-zero integers (size between 1 to 500), return the product of the signs (represented as 1, -1, or 0) of all unique digits and the sum of their corresponding absolute values. If arr is empty or contains values greater than 500, return None.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == None\n    >>> prod_signs([]) == None\n    >>> prod_signs([501, 1]) == None\n    \"\"\"\n    if not arr or len(arr) > 500 or any(abs(x) > 500 for x in arr):\n        return None\n\n    arr = [x for x in arr if x != 0]  # remove zero\n    unique_arr = list(set(arr))  # remove duplicates\n\n    sign_product = 1\n    sum_ = 0\n\n    for x in unique_arr:\n        sign_product *= (1 if x > 0 else -1)\n        sum_ += abs(x)\n\n    return sign_product * sum_", "def prod_signs(arr):\n    \"\"\"\n    Given a list arr of non-zero integers, compute and return the sum of the absolute\n    values of unique integers and the combined product of signs (+1, -1) for each unique number in the list.\n    If the list is empty or only contains zero, return a dictionary indicating that zero and empty arrays are invalid.\n\n    Example:\n    >>> prod_signs([1, 2, -2, -4]) == {'Sum': 9, 'Sign_product': -1}\n    >>> prod_signs([0, 1]) == {'error': 'Invalid input. The list should not contain zero only or be empty.'}\n    >>> prod_signs([]) == {'error': 'Invalid input. The list should not contain zeros only or be empty.'}\n    \"\"\"\n\n    # remove zeros and duplicate values\n    unique_arr = list(set(arr))\n    if 0 in unique_arr: \n        unique_arr.remove(0)\n\n    # check if the array is empty or contains zeros only\n    if not unique_arr: \n        return {'error': 'Invalid input. The list should not contain zeros only or be empty.'}\n    else:\n        sum_arr = sum([abs(i) for i in unique_arr])\n        sign_product = 1\n        for i in unique_arr:\n            sign_product *= 1 if i > 0 else -1 \n        return {'Sum': sum_arr, 'Sign product': sign_product}", "def prod_signs(arr):\n    \"\"\"\n    Given a list arr of non-zero integers, compute and return the sum of the absolute values of unique integers and the combined product of signs (+1, -1) for each unique number in the list. If the list is empty or only contains zero, return a dictionary indicating that zero and empty arrays are invalid.\n    \n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == {'Sum': 7, 'Sign product': -1}\n    >>> prod_signs([0, 1]) == {'error': 'Invalid input. The list should not contain zeros only or be empty.'}\n    >>> prod_signs([]) == {'error': 'Invalid input. The list should not contain zeros only or be empty.'}\n    \"\"\"\n\n    # remove zeros and duplicate values\n    unique_arr = list(set(arr))\n    if 0 in unique_arr: unique_arr.remove(0)\n    \n    # check if the array is empty or contains zeros only\n    if not unique_arr: \n        return {'error': 'Invalid input. The list should not contain zeros only or be empty.'}\n    else:\n        sum_arr = sum(abs(i) for i in unique_arr)\n        sign_product = 1\n        for i in unique_arr:\n            sign_product *= 1 if i > 0 else -1 \n        return {'Sum': sum_arr, 'Sign product': sign_product}", "def prod_signs(arr):\n\n    if not arr:  # condition for empty array\n        return None\n    \n    val, sign = 0,1\n\n    for num in arr:\n        if num == 0:  # condition for existence of zero in array\n            return None\n        else:   # calculate sum of values multiplied by sign.\n            val += abs(num)*(1 if num>0 else -1)\n    return val ", "def sum_of_squares(arr):\n    \"\"\"Calculate square sum of numbers divisible by 3 or 7.\n    \n    This function takes a list of integers and strings, converting \n    strings to integers where possible, and returns the sum of the squares \n    of all positive elements divisible by either 3 or 7. Non-convertible \n    strings and negative numbers are ignored.\n\n    Args:\n        arr (list): A list containing integers and strings.\n\n    Returns:\n        int: The sum of squares of all positive elements divisible by 3 or 7.\n\n    Examples:\n        >>> sum_of_squares([])\n        0\n        >>> sum_of_squares(['3', 7, -1, '11', 'not-an-int'])\n        58\n        >>> sum_of_squares([4, '9', 7, '3'])\n        130\n    \"\"\"\n    return sum(int(i)**2 for i in arr if str(i).isdigit() and int(i) > 0 and (int(i) % 3 == 0 or int(i) % 7 == 0))"]}
{"task_id": "HumanEval/129", "problem": ["def maxSumPath(grid, k):\n    # Given each cell has distinct value, the maximum k cells will always be the maximum k values in the grid.\n    # Flatten the grid to a list and sort it in reverse order\n    values = sorted(sum(grid, []), reverse=True)\n    max_values = values[:k]\n    max_sum = sum(max_values)\n    # Compute path which is the value itself in this case\n    path = max_values\n\n    return [max_sum, path]", "def optimizedTraversal(grid, k):\n    N = len(grid)\n\n    # Store the directions of traversal (-1, 0) = Left, (1, 0) = Right, (0, -1) = Up, (0, 1) = Down.\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    # Initialize dict to store the maximal values for paths of length k starting from each cell.\n    dp = {(i, j, k): grid[i][j] for i in range(N) for j in range(N) for k in range(1, K + 1)}\n\n    for steps in range(1, K):  # For each possible number of steps\n        for i in range(N):  # For each row\n            for j in range(N):  # For each column\n\n                # Initialize current cell's value for paths of length (steps + 1) as negative infinity.\n                dp[(i, j, steps + 1)] = float(\"-inf\") \n\n                # For each direction of traversal\n                for dx, dy in directions:\n                    ni, nj = i + dx, j + dy  # Next cell's coordinates\n                    if 0 <= ni < N and 0 <= nj < N:  # If next cell is within grid\n\n                        # Update current cell's value for paths of length (steps + 1) as max value from current cell value or next cell's value.\n                        dp[(i, j, steps + 1)] = max(dp[(i, j, steps + 1)], grid[i][j] + dp[(ni, nj, steps)])\n\n    # Find the max total value and the starting cell for the optimal path.\n    max_val, max_cell = max((val, cell) for (cell, _, steps), val in dp.items() if steps == k)\n\n    # Backtrack to find the cells in the optimal path.\n    path = [max_cell]\n    while len(path) < k:\n        val = max_val - grid[max_cell[0]][max_cell[1]]\n        for dx, dy in directions:\n            ni, nj = max_cell[0] + dx, max_cell[1] + dy  # Next cell's coordinates\n            if 0 <= ni < N and 0 <= nj < N and dp[(ni, nj, len(path))] == val:\n                max_cell = (ni, nj)  # Update the current cell as the next cell\n                max_val = val  # Update the max value as the value at next cell\n                path.append(max_cell)  # Add the next cell to the path\n                break\n    return path", "def minesweeper(grid):\n    # Get the grid size.\n    n, m = len(grid), len(grid[0])\n\n    # Initialize an output grid with all values set to 0.\n    output = [[0]*m for _ in range(n)]\n\n    # Loop over each cell in the grid.\n    for i in range(n):\n        for j in range(m):\n\n            # If the cell is a mine, mark it as such in the output.\n            if grid[i][j] == '#':\n                output[i][j] = '#'\n                continue\n\n            # Check the neighboring cells.\n            for dx in [-1, 0, 1]:\n                for dy in [-1, 0, 1]:\n                    # If the neighbor is within the grid and it is a mine, \n                    # increment the output value of the current cell.\n                    if 0 <= i+dx < n and 0 <= j+dy < m and grid[i+dx][j+dy] == '#':\n                        output[i][j] += 1\n\n            # Convert the count to string.\n            output[i][j] = str(output[i][j])\n    # Return the output grid.\n    return output", "def minPath(grid: List[List[int]], k: int) -> List[int]:\n    #Checking for erroneous input\n    if not isinstance(grid, list) or not all(isinstance(i, list) for i in grid):\n        return \"Invalid input. Input has to be a 2D grid.\"\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n*n:\n        return \"Invalid input. k has to be an integer and within range.\"\n    if any(not isinstance(i, int) for sublist in grid for i in sublist):\n        return \"Invalid input. Grid should only contain integers.\"\n\n    heap = [[grid[0][0], [0, 0]]]   # value at cell, coords\n    sumCache = {(0, 0): grid[0][0]}   # Cache total path sum at each cell. Key is coords\n    pathCache = {(0, 0): [grid[0][0]]}   # Cache path at each cell. Key is coords\n\n    while heap:\n        curvalue, (curi, curj) = heapq.heappop(heap)\n        #Generate all paths from current cell to neighbours\n        for nexti, nextj in getNeighbors(curi, curj, n):\n            newSum = sumCache[(curi, curj)] + grid[nexti][nextj]\n            newPath = pathCache[(curi, curj)] + [grid[nexti][nextj]]\n            if len(newPath) > k:   # If path too long, skip\n                continue\n            #If cell not visited yet or new path is shorter than existing, update cell's path sum\n            if (nexti, nextj) not in sumCache or newSum < sumCache[(nexti, nextj)]:\n                sumCache[(nexti, nextj)] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[(nexti, nextj)] = newPath\n    #Return min path among all the paths of len k\n    return min((path for path in pathCache.values() if len(path)==k), key=sum)", "def minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    \n    # Mark blocked cells\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n\n    # Start from each cell on the grid\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n\n                # Four possible directions\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\n                # BFS\n                while not queue.empty():\n                    cur_i, cur_j = queue.get()\n                    for direction in directions:\n                        new_i, new_j = cur_i + direction[0], cur_j + direction[1]\n                        # check if it's within the boundary of the grid and not blocked\n                        if 0 <= new_i < N and 0 <= new_j < N and distances[new_i][new_j] != -1:\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n\n    # Return the cell values for the shortest path with length k\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    \n    # If no path of length k is found, return -1\n    if not path:\n        return -1\n\n    path.sort()\n    return path"]}
{"task_id": "HumanEval/130", "problem": ["def tri(n):\n    sequence = []\n    if n < 0:\n        return sequence\n    if n >= 0:\n        sequence.append(3)\n    if n >= 2:\n        sequence.append(2)\n    if n >= 3:\n        sequence.append(sequence[-2] + sequence[-1] + 1)\n    for i in range(4, n+1):\n        if i%2==0:\n            sequence.append(1 + i // 2)\n        else:\n            sequence.append(sequence[-2] + sequence[-1] + sequence[-3])\n    return sequence", "def tribonacci(n: int, memo = {}):\n    \"\"\"\n    The Tribonacci sequence adheres to the following rules:\n    tribonacci(0) = 0\n    tribonacci(1) = 1\n    tribonacci(2) = 1\n    tribonacci(n) = tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3) for n > 2\n    tribonacci(n) = tribonacci(n+3) - tribonacci(n+2) - tribonacci(n+1) for n < 0\n\n    Apply dynamic programming and cache intermediate results using memoization for optimization.\n    >>> tribonacci(1)\n    1\n    >>> tribonacci(5)\n    7\n    >>> tribonacci(8)\n    44\n    >>> tribonacci(-1)\n    1\n    >>> tribonacci(-5)\n    -7\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    elif n == 0:\n        return 0\n    elif n == 1 or n == 2:\n        return 1\n    elif n < 0:\n        result = tribonacci(n + 3, memo) - tribonacci(n + 2, memo) - tribonacci(n + 1, memo)\n    else:\n        result = tribonacci(n - 1, memo) + tribonacci(n - 2, memo) + tribonacci(n - 3, memo)\n        \n    memo[n] = result\n    return result", "def main():\n    print(tri(3))", "def fibfib(n: int, memo = {}):\n    \"\"\"\n    This function encapsulates the FibFib sequence that mirrors the Fibonacci sequence but with this specific set of rules:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) where n > 2\n    fibfib(n) == fibfib(n+3) - fibfib(n+2) - fibfib(n+1) where n < 0\n\n    Applying dynamic programming and memoization is essential for function optimization.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    >>> fibfib(-1)\n    1\n    >>> fibfib(-5)\n    -4\n    \"\"\"\n    if n in memo:\n        return memo[n]\n\n    if n >= 0:\n        if n < 3:\n            result = n % 2\n        else:\n            result = fibfib(n - 1, memo) + fibfib(n - 2, memo) + fibfib(n - 3, memo)\n    else:\n        result = fibfib(n + 3, memo) - fibfib(n + 2, memo) - fibfib(n + 1, memo)\n\n    # store the result in the memo dictionary for future reference\n    memo[n] = result\n\n    return result", "def generate_mesh(voxel_data):\n    # Create a 3D mesh from voxel data using Delaunay triangulation\n    x, y, z = np.where(voxel_data)\n    points = np.column_stack([x, y, z])\n    tri = Delaunay(points)\n    \n    # Plot the mesh using Mayavi\n    fig = mlab.figure()\n    mlab.triangular_mesh(x, y, z, tri.simplices, representation='wireframe')\n    mlab.show()"]}
{"task_id": "HumanEval/131", "problem": ["def numsManipulation(n):\n    \"\"\"Given a positive integer n, return the product of the cubes of odd digits and the sum of squares of the even digits.\n    If all digits are even, return the product of cubes of the first half of even digits.\n    If all digits are odd, return the sum of the squares of the first half of odd digits.\n    For example:\n    numsManipulation(1)   == 1\n    numsManipulation(4)   == 16\n    numsManipulation(235) == 31 (2^2 + 3^3*5^3)\n    \"\"\"\n\n    # List of odd and even digits\n    odd_digits = [int(digit) for digit in str(n) if int(digit) % 2 != 0]\n    even_digits = [int(digit) for digit in str(n) if int(digit) % 2 == 0]\n\n    # Determine the calculation based on the digits\n    if len(odd_digits) > 0 and len(even_digits) > 0:\n        # Both odd and even digits\n        return sum(d ** 2 for d in even_digits) + prod(d ** 3 for d in odd_digits)\n    elif len(odd_digits) > 0:\n        # Only odd digits\n        return sum(d ** 2 for d in odd_digits[:len(odd_digits)//2])\n    else:\n        # Only even digits\n        return prod(d ** 3 for d in even_digits[:len(even_digits)//2])", "def numsManipulation(n):\n    \"\"\"\n    Given a positive integer n, return the product of the cubes of odd digits and the sum of the squares of the even digits.\n    If all digits are even, return the product of cubes of the first half of even digits.\n    If all digits are odd, return the sum of the squares of the first half of odd digits.\n    For example:\n    numsManipulation(1) == 1\n    numsManipulation(4) == 16\n    numsManipulation(235) == 31 (2^2 + 3^3 + 5^3)\n    \"\"\"\n\n    # List of odd and even digits\n    odd_digits = [int(digit) for digit in str(n) if int(digit) % 2 != 0]\n    even_digits = [int(digit) for digit in str(n) if int(digit) % 2 == 0]\n\n    # Determine the calculation based on the digits\n    if len(odd_digits) > 0 and len(even_digits) > 0:\n        # Both odd and even digits\n        return sum(d ** 2 for d in even_digits) + prod(d ** 3 for d in odd_digits)\n    elif len(odd_digits) > 0:\n        # Only odd digits\n        return sum(d ** 2 for d in odd_digits[:len(odd_digits)//2])\n    else:\n        # Only even digits\n        return prod(d ** 3 for d in even_digits[:len(even_digits)//2])", "def digits(n):\n    n = [int(i) for i in str(n)]\n    odd = [i for i in n if i % 2 != 0]\n    even = [i for i in n if i % 2 == 0]\n\n    if len(odd) == 0:  # all digits are even\n        half = len(even) // 2\n        product = 1\n        for num in even[:half]:\n            product *= num\n        return product\n\n    elif len(even) == 0:  # all digits are odd\n        half = len(odd) // 2\n        return sum(odd[:half])\n        \n    else:  # mix of odd and even digits\n        product = 1\n        for num in odd:\n            product *= num\n        return product + sum(even)", "def digits(n):\n    s = str(n)  # convert the number to a string to iterate through the digits\n    evens = [int(d) for d in s if int(d) % 2 == 0]  # list of even digits\n    odds = [int(d) for d in s if int(d) % 2 == 1]  # list of odd digits\n\n    # if all digits are even\n    if len(evens) == len(s):\n        half = len(evens)//2\n        result = 1\n        for i in range(half):\n            result *= evens[i]\n        return result\n\n    # if all digits are odd\n    elif len(odds) == len(s):\n        half = len(odds)//2\n        return sum(odds[:half])\n\n    # the default case (n has both odd and even digits)\n    else:\n        return sum(evens) * prod(odds)", "def calculate_numbers(n):\n    # Check if input is positive integer\n    if not isinstance(n, int) or n <= 0:\n        return \"Input should be a positive integer\"\n  \n    # Convert number to list of digits\n    digits = [int(x) for x in str(n)]\n  \n    # Calculate cumulative total of digits\n    total = sum(digits)\n  \n    # Calculate sum of factorials of digits\n    factorial_sum = sum(math.factorial(i) for i in digits)\n  \n    return total, factorial_sum"]}
{"task_id": "HumanEval/132", "problem": ["def total_match(lst1, lst2, case_sensitive=False):\n    \"\"\"\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n\n    The function also drops duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case sensitive parameter to True.\n\n    Should both iterables have an equal total character length, the function returns the first iterable.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['HI', 'HI']) \u279e ['HI', 'HI']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'hi']) \u279e ['hi', 'hi']\n    total_match(['A'], ['1', '2', '3', '4', '5']) \u279e ['A']\n    total_match(['hi world'], ['hi', ' w', 'or', 'ld']) \u279e ['hi', ' w', 'or', 'ld']\n    \"\"\"\n\n    # Remove non-alphanumeric characters and possibly convert to lower case\n    lst1 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst1]\n    lst2 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst2]\n\n    # Eliminate duplicates, preserving the original order\n    lst1, lst2 = list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2))\n\n    # Determine which list has a less or equal total character count\n    return lst1 if sum(len(s) for s in lst1) <= sum(len(s) for s in lst2) else lst2", "def total_match(lst1, lst2, case_sensitive=False):\n    '''\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n    \n    The function also drop duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case_sensitive parameter to True.\n    \n    Should both iterables have an equal total character length, the function returns the first iterable.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    total_match(['hi world'], ['hi', ' w', 'or', 'ld']) \u279e ['hi', ' w', 'or', 'ld']\n    '''\n    import re\n\n    # Remove non-alphanumeric characters and possibly convert to lower case\n    lst1 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst1]\n    lst2 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst2]\n\n    # Eliminate duplicates, preserving the original order\n    lst1, lst2 = list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2))\n\n    # Determine which list has a less or equal total character count\n    return lst1 if sum(len(s) for s in lst1) <= sum(len(s) for s in lst2) else lst2", "def is_nested(string):\n    stack = []\n    brackets = {'(': ')', '[': ']', '{': '}', '<': '>'}\n    for i, char in enumerate(string):\n        if char in brackets:\n            stack.append((char, i))\n        elif len(stack) == 0 or brackets[stack.pop()[0]] != char:\n            return False, 'Position ' + str(i)\n    return (len(stack) == 0, None) if len(stack) == 0 else (False, 'Position ' + str(stack[0][1]))", "def will_it_fly(q,w):\n    '''\n    The function's purpose is to discern q's flight potential, return True if achievable, and False if not. For q to fly, it must fulfil two prerequisites: it must be palindromic and the total weights of its elements should not go beyond the maximum acceptable weight w.\n\n    Implement the function with error handling mechanisms. It should return a \"Non-numeric input\" error if it receives a non-numeric input, and a \"Non-sequence input\" error if it receives a non-sequence input.\n\n    Examples:\n    will_it_fly([1, 2], 5) \u279e False \n\n    will_it_fly([3, 2, 3], 1) \u279e False\n\n    will_it_fly([3, 2, 3], 9) \u279e True\n\n    will_it_fly([3], 5) \u279e True\n    \n    Error Cases:\n    will_it_fly([\"a\",\"b\",\"c\"], 5) \u279e \"Non-numeric input\"\n    \n    will_it_fly(123, 5) \u279e \"Non-sequence input\"\n    '''\n    # Handle Non-sequence input error\n    if not isinstance(q, (list, tuple, str)):\n        return \"Non-sequence input\"\n    \n    for i in q:\n        # Handle Non-numeric input error\n        if not isinstance(i, (int, float)):\n            return \"Non-numeric input\"\n    \n    return is_palindrome(q) and sum(q) <= w", "def isValidPhoneNumber(phoneNumber):\n    if len(phoneNumber) != 14:\n        return False\n    \n    if phoneNumber[0] != '(' or phoneNumber[4] != ')' or phoneNumber[5] != ' ' or phoneNumber[9] != '-':\n        return False\n    \n    areaCode = phoneNumber[1:4]\n    if areaCode[0] in ['0', '1']:\n        return False\n    \n    if areaCode[1] == '9':\n        return False\n    \n    if areaCode[0] == areaCode[1] == areaCode[2]:\n        return False\n    \n    if int(areaCode) in [int(areaCode[0]) + 1, int(areaCode[0]) - 1, int(areaCode[0]) + 2, int(areaCode[0]) - 2]:\n        return False\n    \n    if phoneNumber[6] in ['0', '1']:\n        return False\n    \n    if phoneNumber[7] == '9':\n        return False\n    \n    if phoneNumber[10] == phoneNumber[11] == phoneNumber[12] == phoneNumber[13]:\n        return False\n    \n    if int(phoneNumber[10:14]) in [int(phoneNumber[10:14][0]) + 1, int(phoneNumber[10:14][0]) - 1, int(phoneNumber[10:14][0]) + 2, int(phoneNumber[10:14][0]) - 2]:\n        return False\n    \n    return True"]}
{"task_id": "HumanEval/133", "problem": ["def find_lcm_in_array(lst):\n    # This function calculates the lcm for a list of numbers\n\n    try:\n        num1 = lst[0]\n        num2 = lst[1]\n        lcm = find_lcm(num1, num2)\n\n        for i in range(2, len(lst)):\n            lcm = find_lcm(lcm, lst[i])\n\n        print(\"The LCM of the list is: \",lcm)\n\n    except IndexError as e:\n        print(\"Error: List should have at least two numbers.\")\n    except TypeError as e:\n        print(\"Error: All elements of the list should be numeric.\")", "def get_product_array(lst):\n    # Initialize a variable to keep track of the product\n    right_product = 1\n    # Initialize an array of ones with the same size as the input\n    output = [1] * len(lst)\n    \n    # Calculate the product of the numbers before the current index\n    for i in range(1, len(lst)):\n        output[i] = output[i - 1] * lst[i - 1]\n   \n    # Calculate the product of the numbers after the current index\n    for i in range(len(lst) - 1, -1, -1):\n        output[i] *= right_product\n        right_product *= lst[i]\n    \n    return output", "def swap(lst, i, j):\n    \"\"\"\n    Swaps two elements in the given list.\n\n    Parameters:\n    lst (list): The list in which the elements should be swapped.\n    i (int): The index of the first element to be swapped.\n    j (int): The index of the second element to be swapped.\n\n    Returns:\n    list: The modified list with the elements swapped.\n    \"\"\"\n\n    # Step 1: Check if the indices are valid.\n    if i < 0 or i >= len(lst) or j < 0 or j >= len(lst):\n        raise ValueError(\"Invalid indices\")\n\n    # Step 2: Swap the elements using a temporary variable.\n    temp = lst[i]\n    lst[i] = lst[j]\n    lst[j] = temp\n\n    # Step 3: Return the modified list.\n    return lst", "def unusual_addition(lst: list) -> list:\n    \"\"\"\n    Given a list consisting only of strings with numerical characters, return a list.\n    Each 'i' in the output statement for each element, \"+he number of odd elements present in the\n    i'th input string,\", should be replaced with the actual count of odd numbers.\n    \"\"\" \n    results = []\n\n    for i, string in enumerate(lst):\n\n        totals = [0, 0]  # [total odd_numbers, total_even_numbers]\n\n        # Count number of odd and even numbers within the string\n        for char in string:\n            if int(char) % 2 == 0:\n                totals[1] += 1\n            else:\n                totals[0] += 1\n\n        totals = [num**2 for num in totals]  # Square of counts\n\n        odd_squares = {el for el in range(totals[0])}\n        even_squares = [el for el in range(totals[1])]\n\n        odd_square_totals = sum([num**2 for num in odd_squares])\n        even_square_totals = sum([num**2 for num in even_squares])\n\n        output_string = f\"The number of odd elements {odd_square_totals} in the string {string} of the input.\"\n        results.append(output_string)\n\n    return results", "def find_elements(lists: List[List[int]], x: int) -> List[int]:\n    all_elements = []\n    distinct_elements = []\n\n    for lst in lists:\n        all_elements.extend(lst)\n        distinct_elements.extend(set(lst))\n\n    output = [element for element in distinct_elements if all_elements.count(element) == x]\n    return output"]}
{"task_id": "HumanEval/134", "problem": ["def will_it_fly(q,w):\n    '''\n    The function's purpose is to discern q's flight potential, return True if achievable, and False if not. For q to fly, it must fulfil two prerequisites: it must be palindromic and the total weights of its elements should not go beyond the maximum acceptable weight w.\n\n    Implement the function with error handling mechanisms. It should return a \"Non-numeric input\" error if it receives a non-numeric input, and a \"Non-sequence input\" error if it receives a non-sequence input.\n\n    Examples:\n    will_it_fly([1, 2], 5) \u279e False \n\n    will_it_fly([3, 2, 3], 1) \u279e False\n\n    will_it_fly([3, 2, 3], 9) \u279e True\n\n    will_it_fly([3], 5) \u279e True\n    \n    Error Cases:\n    will_it_fly([\"a\",\"b\",\"c\"], 5) \u279e \"Non-numeric input\"\n    \n    will_it_fly(123, 5) \u279e \"Non-sequence input\"\n    '''\n    # Handle Non-sequence input error\n    if not isinstance(q, (list, tuple, str)):\n        return \"Non-sequence input\"\n    \n    for i in q:\n        # Handle Non-numeric input error\n        if not isinstance(i, (int, float)):\n            return \"Non-numeric input\"\n    \n    return is_palindrome(q) and sum(q) <= w", "def distorted_compare_word_sets(phrase1: str, phrase2: str):\n    \"\"\"\n    Determine if two phrases have the identical word set with multiple constraints including word duplicity, case sensitivity, and punctuation.\n    >>> distorted_compare_word_sets(\"Apple, Banana: Orange!\", \"orange apple Banana\")\n    False\n    >>> distorted_compare_word_sets(\"apple banana\", \"Apple, Orange BaNaNa!\")\n    False\n    >>> distorted_compare_word_sets(\"ApPle!\", \"appLE, Apple\")\n    True\n    >>> distorted_compare_word_sets(\"Banana?\", \"Apple BaNana!\")\n    False\n    >>> distorted_compare_word_sets(\"Apple BaNana Orange.\", \"Orange, BanaNa grape!\")\n    False\n    \"\"\"\n\n    # Remove punctuation, convert to lowercase and split by space\n    phrase1_words = set(phrase1.translate(str.maketrans(\"\", \"\", string.punctuation)).lower().split(\" \"))\n    phrase2_words = set(phrase2.translate(str.maketrans(\"\", \"\", string.punctuation)).lower().split(\" \"))\n\n    # Return comparison result\n    return phrase1_words == phrase2_words", "def total_match(lst1, lst2, case_sensitive=False):\n    \"\"\"\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n\n    The function also drops duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case sensitive parameter to True.\n\n    Should both iterables have an equal total character length, the function returns the first iterable.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['HI', 'HI']) \u279e ['HI', 'HI']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'hi']) \u279e ['hi', 'hi']\n    total_match(['A'], ['1', '2', '3', '4', '5']) \u279e ['A']\n    total_match(['hi world'], ['hi', ' w', 'or', 'ld']) \u279e ['hi', ' w', 'or', 'ld']\n    \"\"\"\n\n    # Remove non-alphanumeric characters and possibly convert to lower case\n    lst1 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst1]\n    lst2 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst2]\n\n    # Eliminate duplicates, preserving the original order\n    lst1, lst2 = list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2))\n\n    # Determine which list has a less or equal total character count\n    return lst1 if sum(len(s) for s in lst1) <= sum(len(s) for s in lst2) else lst2", "def check_if_substring(string1, string2):\n    \"\"\"This function checks if a given string (string1) is a\n    substring of the other given string (string2).\n\n    Args:\n        string1 (str): The string that might be a substring of string2.\n        string2 (str): The string to check if string1 is a substring.\n\n    Returns:\n        bool: True if string1 is a substring of string2, False otherwise.\n    \"\"\"\n    if string1 in string2:\n        return True\n    else:\n        return False", "def verify_same_word_sets_freqs(phrase1: str, phrase2: str):\n    \"\"\"\n    >>> verify_same_word_sets_freqs(\"Apple Banana Orange\", \"Orange Apple Banana\")\n    True\n    >>> verify_same_word_sets_freqs(\"apple banana\", \"Apple Orange BaNaNa\")\n    False\n    >>> verify_same_word_sets_freqs(\"ApPle\", \"appLE Apple\")\n    False\n    >>> verify_same_word_sets_freqs(\"Banana Apple\", \"Apple BaNana\")\n    True\n    >>> verify_same_word_sets_freqs(\"Apple BaNana Orange\", \"Orange BanaNa grape\")\n    False\n    \"\"\"\n    map1 = Counter(phrase1.lower().split())\n    map2 = Counter(phrase2.lower().split())\n    return map1 == map2"]}
{"task_id": "HumanEval/135", "problem": ["def can_arrange_v2(arr, limits, criterion):\n    \"\"\"Specify a function that not only locates an element suitable for a distinct role, but also its likely swap contender, according to a constraint that the swapping elements must be within specified limits. If the elements are inexistent, return {'index': -1, 'swap_with': -1}. The input array should not contain duplicate values, 'limits' is a tuple of two integers indicating a subarray to consider elements within, and 'criterion' is a unique condition that the found element must meet.\n\n    Examples:\n    can_arrange_v2([1,2,4,3,5], (2, 4), is_prime) = {'index': 3, 'swap_with': 2}\n    can_arrange_v2([1,2,3], (0, 2), odd_number) = {'index': -1, 'swap_with': -1}\n    \"\"\"\n    # Extract subarray\n    subarray = arr[limits[0]:limits[1]+1]\n    \n    # Find the index of the first element within limits that meets the criterion\n    index = find_index_of_element_meeting_criterion(subarray, criterion)\n    \n    # If no such element exists\n    if index == -1:\n        return {'index': -1, 'swap_with': -1}\n    \n    # If such an element exists, find the swap contender\n    swap_with_index = find_index_of_next_possible_swap(subarray, index)\n    \n    # If no such swap contender exists\n    if swap_with_index == -1:\n        return {'index': -1, 'swap_with': -1}\n    \n    # If a valid swap contender does exist\n    return {'index': index + limits[0], 'swap_with': swap_with_index + limits[0]}  #add lower limit to adjust index for the actual array as opposed to the subarray.", "def can_arrange_v2(arr, limits, criterion):\n    \"\"\"\n    Specify a function that not only locates an element suitable for a distinct role, but also its likely swap contender, according to a constraint where the swapping elements must be within specified limits. If the elements are inexistent, return {'index': -1, 'swap_with': -1}. The input array should not contain duplicate values, 'limits' is a tuple of two integers indicating a subarray to consider elements within, and 'criterion' is a unique condition that the found element must meet.\n    \n    Examples:\n    can_arrange_v2([1,2,4,3,5], (2, 4), is_prime) - {'index': 3, 'swap_with': 2}\n    can_arrange_v2([1,2,3], (0, 2), odd_number) - {'index': -1, 'swap_with': -1}\n    \"\"\"\n    # Extract subarray\n    subarray = arr[limits[0]:limits[1]+1]\n\n    # Find the index of the first element within limits that meets the criterion\n    index = find_index_of_element_meeting_criterion(subarray, criterion)\n\n    # If no such element exists\n    if index == -1:\n        return {'index': -1, 'swap_with': -1}\n\n    # If such an element exists, find the swap contender\n    swap_with_index = find_index_of_next_possible_swap(subarray, index)\n\n    # If no such swap contender exists\n    if swap_with_index == -1:\n        return {'index': -1, 'swap_with': -1}\n\n    # If a valid swap contender does exist\n    return {'index': index + limits[0], 'swap_with': swap_with_index + limits[0]}  ", "def find_max(arr):\n    \"\"\"\n    Function to find the largest numerical value in an array. \n\n    Parameters:\n    arr (list): The list of integers.\n  \n    Returns:\n    max_val (int): The largest numerical value in the array.\n  \n    \"\"\"\n    \n    # Step 1: Initialize a variable max_val with the value at the 0th index in the array\n    max_val = arr[0]\n\n    # Step 2: Iterate over each element in the array from 1 to n-1\n    for i in range(1, len(arr)):\n        # Step 3: If the value at the current index in the array is greater than max_val, update max_val\n        if arr[i] > max_val:\n            max_val = arr[i]\n\n    # Step 4: Return max_val, which now holds the largest numerical value in the array\n    return max_val", "def find_kth_largest(arr, k):\n    \"\"\"\n    Function to find the kth largest element in an array\n    \"\"\"\n    \n    # make a copy of the array\n    arr_copy = arr[:]\n    \n    # get the length of the array\n    length = len(arr_copy)\n    \n    # if k is greater than or equal to the length of the array, return the maximum element\n    if k >= length:\n        return max(arr_copy)\n        \n    # sort the array in descending order\n    arr_copy.sort(reverse=True)\n    \n    # get the kth element from the sorted array\n    kth_largest = arr_copy[k-1]\n    \n    return kth_largest", "def binary_search(arr, x):\n    \"\"\"\n    Perform a binary search of a sorted array.\n\n    Parameters:\n        arr(list): A sorted list of elements.\n        x(int): The element to be searched.\n\n    Returns:\n        int: The index of the element in the array, or -1 if not found.\n    \"\"\" \n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            # found the element\n            return mid\n        elif x > arr[mid]:\n            # element is greater than mid - search the upper half\n            low = mid + 1 \n        else:\n            # element is less than mid - search the lower half\n            high = mid - 1\n    \n    # element not found\n    return -1"]}
{"task_id": "HumanEval/136", "problem": ["def uncommon_elements(sequence):\n    '''\n    Design a function that accepts a non-empty list composed of positive integers and returns a list of distinct integers whose frequency surpasses half of the integer's numerical value. Here, 'frequency' denotes the number of times a specific integer appears within the list.\n    If no integers satisfy these conditions, the function should return an empty list.\n    Examples:\n        uncommon_elements([4, 1, 2, 2, 3, 1]) should yield [2, 3]\n        uncommon_elements([1, 2, 2, 3, 3, 3, 4, 4, 4]) should yield [2, 3, 4]\n        uncommon_elements([5, 5, 4, 4, 4]) should yield [4]\n    '''\n    from collections import Counter\n    count = Counter(sequence)\n    result = []\n    for num, freq in count.items():\n        if freq > num/2:\n            result.append(num)\n    return result", "def sum_of_squares(arr):\n    \"\"\"Calculate square sum of numbers divisible by 3 or 7.\n    \n    This function takes a list of integers and strings, converting \n    strings to integers where possible, and returns the sum of the squares \n    of all positive elements divisible by either 3 or 7. Non-convertible \n    strings and negative numbers are ignored.\n\n    Args:\n        arr (list): A list containing integers and strings.\n\n    Returns:\n        int: The sum of squares of all positive elements divisible by 3 or 7.\n\n    Examples:\n        >>> sum_of_squares([])\n        0\n        >>> sum_of_squares(['3', 7, -1, '11', 'not-an-int'])\n        58\n        >>> sum_of_squares([4, '9', 7, '3'])\n        130\n    \"\"\"\n    return sum(int(i)**2 for i in arr if str(i).isdigit() and int(i) > 0 and (int(i) % 3 == 0 or int(i) % 7 == 0))", "def hybrid_sort_list_heap(lst):\n    '''\n    Given a list of integers and decimals, use a heap sort combined with binary insertion sort to arrange the list in a special order. The ordering should start with the smallest value, then the largest, then the smallest of the remaining values not yet included in the output, and continue doing this until all elements are sorted.\n\n    Examples:\n    hybrid_sort_list_heap([1, 2, 3, 4]) == [1, 4, 2, 3]\n    hybrid_sort_list_heap([5, 5, 5, 5]) == [5, 5, 5, 5]\n    hybrid_sort_list_heap([]) == []\n    hybrid_sort_list_heap([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # Make input list to a heap\n    heapq.heapify(lst)\n\n    # If the size of the list is less than 10 use Binary Insertion Sort\n    if len(lst) < 10:\n        sorted_lst = binary_insertion_sort(lst)\n    else:\n        # Else use Heap Sort\n        sorted_lst = [heapq.heappop(lst) for _ in range(len(lst))]\n\n    # Create a resultant list as per special order\n    result = []\n    while sorted_lst:\n        result.append(sorted_lst.pop(0))  # pop the smallest\n        if sorted_lst:\n            result.append(sorted_lst.pop(-1))  # pop the largest\n\n    return result", "def hybrid_sort_list_heap(lst):\n    '''\n    Given a list of integers and decimals, use a heap sort combined \n    with binary insertion sort to arrange the list in a special order. \n    The ordering should start with the smallest value, then the largest, \n    then the smallest of the remaining values not yet included in the output, \n    and continue doing this until all elements are sorted.\n\n    Examples:\n    hybrid_sort_list_heap([1, 2, 3, 4]) == [1, 4, 2, 3]\n    hybrid_sort_list_heap([5, 5, 5, 5]) == [5, 5, 5, 5]\n    hybrid_sort_list_heap([]) == []\n    hybrid_sort_list_heap([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # Make input list to a heap\n    heapq.heapify(lst)\n\n    # If the size of the list is less than 10 use Binary Insertion Sort\n    if len(lst) < 10:\n        sorted_lst = binary_insertion_sort(lst)\n    else:\n        # Else use Heap Sort\n        sorted_lst = [heapq.heappop(lst) for _ in range(len(lst))]\n\n    # Create a resultant list as per special order\n    result = []\n    while sorted_lst:\n        result.append(sorted_lst.pop(0))  # pop the smallest\n        if sorted_lst:\n            result.append(sorted_lst.pop(-1))  # pop the largest\n\n    return result", "def strange_sort_list_bst(lst):\n    '''\n    This function should accept a list of integers and decimal_numbers and return the list in a specific pattern, leveraging the principles of a binary search tree. The steps to this peculiar_sorting pattern should be:\n    - Commence with the smallest number.\n    - Next, identify the highest value from the remaining elements.\n    - Then, ascertain the lowest_value among the untouched output, and continue in this manner.\n\n    Examples:\n    strange_sort_list_bst([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list_bst([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list_bst([]) == []\n    strange_sort_list_bst([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # First, we will sort the list in ascending_order.\n    lst.sort()\n\n    output = []\n\n    # Then, while lst is not empty, we will remove and append to output the smallest\n    # and largest element alternately.\n    while lst:\n        output.append(lst.pop(0))  # smallest\n        if lst:\n            output.append(lst.pop(-1))  # largest\n\n    return output"]}
{"task_id": "HumanEval/137", "problem": ["def will_it_fly(q,w):\n    '''\n    The function's purpose is to discern q's flight potential, return True if achievable, and False if not. For q to fly, it must fulfil two prerequisites: it must be palindromic and the total weights of its elements should not go beyond the maximum acceptable weight w.\n\n    Implement the function with error handling mechanisms. It should return a \"Non-numeric input\" error if it receives a non-numeric input, and a \"Non-sequence input\" error if it receives a non-sequence input.\n\n    Examples:\n    will_it_fly([1, 2], 5) \u279e False \n\n    will_it_fly([3, 2, 3], 1) \u279e False\n\n    will_it_fly([3, 2, 3], 9) \u279e True\n\n    will_it_fly([3], 5) \u279e True\n    \n    Error Cases:\n    will_it_fly([\"a\",\"b\",\"c\"], 5) \u279e \"Non-numeric input\"\n    \n    will_it_fly(123, 5) \u279e \"Non-sequence input\"\n    '''\n    # Handle Non-sequence input error\n    if not isinstance(q, (list, tuple, str)):\n        return \"Non-sequence input\"\n    \n    for i in q:\n        # Handle Non-numeric input error\n        if not isinstance(i, (int, float)):\n            return \"Non-numeric input\"\n    \n    return is_palindrome(q) and sum(q) <= w", "def compare_one(a, b):\n    # Convert to string, replace optional ',' by '.'\n    aC = str(a).replace(',', '.') if isinstance(a, str) else str(a)\n    bC = str(b).replace(',', '.') if isinstance(b, str) else str(b)\n\n    # Convert strings to numbers for comparison\n    aN = float(aC)\n    bN = float(bC)\n\n    # Compare values\n    if aN > bN:\n        return a\n    elif aN < bN:\n        return b\n\n    # If values are equal, return None\n    return None", "def total_match(lst1, lst2, case_sensitive=False):\n    \"\"\"\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n\n    The function also drops duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case sensitive parameter to True.\n\n    Should both iterables have an equal total character length, the function returns the first iterable.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['HI', 'HI']) \u279e ['HI', 'HI']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'hi']) \u279e ['hi', 'hi']\n    total_match(['A'], ['1', '2', '3', '4', '5']) \u279e ['A']\n    total_match(['hi world'], ['hi', ' w', 'or', 'ld']) \u279e ['hi', ' w', 'or', 'ld']\n    \"\"\"\n\n    # Remove non-alphanumeric characters and possibly convert to lower case\n    lst1 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst1]\n    lst2 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst2]\n\n    # Eliminate duplicates, preserving the original order\n    lst1, lst2 = list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2))\n\n    # Determine which list has a less or equal total character count\n    return lst1 if sum(len(s) for s in lst1) <= sum(len(s) for s in lst2) else lst2", "def compareOne(a, b):\n    try:\n        if isinstance(a, str):\n            a = float(a.replace(\",\", \".\"))\n        if isinstance(b, str):\n            b = float(b.replace(\",\", \".\"))\n\n        if a > b:\n            return isinstance(a, float) and str(a).replace(\".\", \",\") or a\n        elif b > a:\n            return isinstance(b, float) and str(b).replace(\".\", \",\") or b\n        \n        return None\n    except ValueError:\n        return None", "def cumulative_binomial_product(n):\n    if type(n) not in (int, float, complex, list, tuple):\n        return \"Invalid input. Please enter a positive integer, a floating point number, a complex number, a list or a tuple.\"\n\n    if type(n) in (float, complex):\n        return \"Binomial coefficients are not defined for floating point and complex numbers.\"\n\n    if type(n) == int and n < 0:\n        return \"Invalid input. Please enter a non-negative integer.\"\n\n    if type(n) in (list, tuple):\n        try:\n            cumulative_product = 1\n            for i in n:\n                if i < 0 or type(i) != int:\n                    return \"Invalid input in list/tuple. Please ensure all elements are non-negative integers.\"\n\n                if i > 0: \n                    cumulative_product *= functools.reduce(operator.mul, (math.comb(i, j) for j in range(i+1)), 1)\n            return cumulative_product\n        except TypeError:\n            return\n    elif type(n) == int:\n        return functools.reduce(operator.mul, (math.comb(n, i) for i in range(n+1)), 1)"]}
{"task_id": "HumanEval/138", "problem": ["def is_prime(n):\n    \"\"\"Returns true for prime integers, false for non-prime integers.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Check if the number is 2 (2 is the only even prime number)\n    if n == 2: \n      return True\n    # Check for less than 2 and even numbers\n    elif n < 2 or n % 2 == 0: \n      return False\n    # Check for divisibility by any other number up to sqrt(n)\n    for current in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % current == 0:\n            return False\n    return True", "def prime_factor_product(n):\n    \"\"\"Return true if n is a product of exactly four distinct prime numbers, false otherwise.\"\"\"\n    factors = []\n    for count in range(2, math.isqrt(n) + 1): \n        if n % count == 0: \n            if(is_prime(count)): \n                factors.append(count)\n            if(is_prime(n // count)): \n                factors.append(n // count)\n    factors = list(set(factors))\n    \n    return True if len(factors) == 4 else False", "def is_valid_ip(ip_str, N):\n    if N == 4:\n        try:\n            ipaddress.IPv4Address(ip_str)\n            return True\n        except ipaddress.AddressValueError:\n            return False\n    elif N == 6:\n        try:\n            ipaddress.IPv6Address(ip_str)\n            return True\n        except ipaddress.AddressValueError:\n            return False\n    else:\n        return \"Error: N must be 4 or 6\"", "def check_divisibility(number):\n    if not isinstance(number, int) or number <= 0:\n        print(\"Error: The input must be a positive integer\")\n        return\n\n    if number % 4 == 0 and number % 3 == 0:\n        print(\"both\")\n    elif number % 4 == 0:\n        print(\"even\")\n    elif number % 3 == 0:\n        print(\"odd\")\n    else:\n        print(\"neither\")", "def check_divisibility(n):\n    if isinstance(n, int) and n > 0:\n        if n % 4 == 0 and n % 3 != 0:\n            print(\"even\")\n        elif n % 3 == 0 and n % 4 != 0:\n            print(\"odd\")\n        elif n % 4 == 0 and n % 3 == 0:\n            print(\"both\")\n        else:\n            print(\"neither\")\n    else:\n        print(\"Error: Input must be a positive integer\")"]}
{"task_id": "HumanEval/139", "problem": ["def factorial(n):\n    \"\"\"\n    Calculates the factorial of an integer (n \u2265 0) and returns None for negative values.\n    The factorial function is not defined for negative integers. Instead of returning an error or exception, \n    this function returns None and prints out a message.\n    The function proves to be internally consistent with the known factorial function for non-negative integers \n    (i.e., n! = n*(n-1)*(n-2)*...*3*2*1 for n\u22650).\n    \"\"\"\n    if n < 0:\n        print(\"The factorial function isn\u2019t defined for negative integers\")\n        return None\n    elif n == 0:\n        return 1\n    else:\n        fact = 1\n        for i in range(1, n + 1):\n            fact *= i\n        return fact", "def factorial(n):\n    try:\n        # Check if the number is valid i.e. non-negative integer\n        if not n >= 0:\n            raise ValueError(\"Invalid input! Please, input a non-negative integer.\")\n\n        # Check the type of input i.e. integer\n        if not isinstance(n, int):\n            raise TypeError(\"Invalid input type! Please, input an integer.\")\n\n        # Base case: factorial of 0 is 1\n        if n == 0:\n            return 1\n\n        # Recursive case: n! = n * (n-1)!\n        else:\n            return n * factorial(n-1)\n    except (ValueError, TypeError) as e:\n        return e", "def factorial(n):\n    try:\n        # Check if the number is valid i.e. non-negative integer\n        if not n >= 0:\n            raise ValueError(\"Invalid input! Please provide a non-negative integer.\")\n\n        # Check the type of input i.e. integer\n        if not isinstance(n, int):\n            raise TypeError(\"Invalid input type! Please provide an integer.\")\n\n        # Base case: factorial of 0 is 1\n        if n == 0:\n            return 1\n\n        # Recursive case: n! = n * (n-1)!\n        else:\n            return n * factorial(n-1)\n    except (ValueError, TypeError) as e:\n        return e", "def factorial(n):\n    # Check that the input is a positive integer\n    if not n >= 0:\n        print(\"Input must be a positive integer\")\n        return None\n    # The base case: 0! = 1\n    elif n == 0:\n        return 1\n    # Recursive case: n! = n * (n-1)!\n    else:\n        return n * factorial(n-1)", "def factorial(n):\n    # Check that the input is a positive integer\n    if not n >= 0:\n        print(\"Input must be a positive integer\")\n        return None\n    # The base case: 0! = 1\n    elif n == 0:\n        return 1\n    # Recursive case: n! = n * (n-1)!\n    else:\n        return n * factorial(n-1)"]}
{"task_id": "HumanEval/140", "problem": ["def erroneous_solution(input_string):\n    \"\"\"\n    Given a string called input_string, perform the following modifications:\n    1. Replace all instances of white space with an underscore.\n    2. Substitute any occurrence of two or more successive white spaces with a hyphen.\n    3. Transform all words in the string to be fully capitalized.\n\n    erroneous_solution(\"example\") should return \"EXAMPLE\"\n    erroneous_solution(\"example 1\") should return \"EXAMPLE_1\"\n    erroneous_solution(\" example 2\") should return \"_EXAMPLE_2\"\n    erroneous_solution(\" example   3\") should return \"_EXAMPLE-3\"\n    erroneous_solution(\"this is a sample\") should return \"THIS_IS_A_SAMPLE\"\n    \"\"\"\n\n    # Capitalizes all words in the string first\n    input_string = input_string.upper()\n\n    # Replace all instances of white space with an underscore\n    input_string = input_string.replace(\" \", \"_\")\n\n    # Substitute any occurrence of two or more successive underscores with a hyphen\n    input_string = input_string.replace(\"__\", \"-\")\n\n    return input_string", "def fix_spaces(text):\n    text = re.sub(r' {2,}', '-', text) # replaces instances of two or more consecutive spaces with a dash\n    text = re.sub(r' $', '!', text) # replaces a single space at the end of the string with an exclamation mark\n    text = text.replace(\" \", \"_\") # replaces all other single spaces with underscores\n    text = re.sub(r'-\\b', '_', text) # replaces a dash followed by word boundary with underscore\n    text = re.sub(r'-{2,}$', lambda m: '!'*len(m.group()), text) # replaces ending dashes with exlamation marks.\n    \n    return text", "def replace_space(original_string, character):\n    # First replace all spaces with given character\n    new_string = original_string.replace(\" \", character)\n    \n    # Then find all occurrences of more than two consecutive characters and replace them with two characters\n    new_string = re.sub(character + \"{3,}\", character*2, new_string)\n    \n    return new_string", "def normalize_text(text):\n    # Convert all characters to lowercase\n    text = text.lower()\n    \n    # Remove all punctuation marks\n    text = text.translate(str.maketrans(\"\", \"\", string.punctuation))\n    \n    # Remove all numbers\n    text = ''.join([i for i in text if not i.isdigit()])\n    \n    # Remove any leading or trailing white spaces\n    text = text.strip()\n    \n    # Replace all consecutive spaces with a single space\n    text = ' '.join(text.split())\n    \n    return text", "def intricate_text_transformation(input_text):\n    \"\"\" \n    Given a string called input_text, the function carries out the transformations \n    including transforming text to uppercase, replacing blank spaces with underscores\n    and replacing two or more sequential spaces with a hyphen. \n    \"\"\"\n    input_text = input_text.replace(\" \", \"_\") # replacement of blank space with underscore\n    while \"__\" in input_text:\n        input_text = input_text.replace(\"__\", \"-\") # replacement of sequential underscores with a hyphen\n    return input_text.upper() # transforming all expressions to their uppercase equivalents"]}
{"task_id": "HumanEval/141", "problem": ["def file_name_check(file_name):\n    # Check if the file's name length is within the allowed range\n    if not 5 <= len(file_name) <= 50:\n        return \"No\"\n\n    name, dot, extension = file_name.rpartition('.')\n\n    # Check if the file's name has exactly one dot and a valid extension\n    if not dot or extension not in ['txt', 'exe', 'dll', 'pdf', 'jpeg']:\n        return \"No\"\n\n    # Check if the file's name has valid alphanumeric characters, and has at least\n    # one uppercase, one lowercase, and maximum of three consecutive digits\n    if not (re.search(r'[A-Za-z].*', name) and\n            re.search(r'[A-Z]', name) and\n            re.search(r'[a-z]', name) and\n            not re.search(r'\\d{4,}', name)):\n        return \"No\"\n\n    # Check if the file's name has exactly two latin alphabet letters\n    if len(re.findall(r'[A-Za-z]', name)) != 2:\n        return \"No\"\n    \n    return \"Yes\"", "def file_name_check(file_name):\n    # Check if the file's name length is within the allowed range\n    if not 5 <= len(file_name) <= 50:\n        return \"No\"\n    \n    name, dot, extension = file_name.rpartition('.')\n    \n    # Check if the file's name has exactly one dot and a valid extension\n    if not dot or extension not in ['txt', 'exe', 'dll', 'pdf', 'jpeg']:\n        return \"No\"\n    \n    # Check if the file's name has valid alphanumeric characters, and has at least\n    # one uppercase, one lowercase, and maximum of three consecutive digits\n    if not (re.match(r'[A-Za-z].*$', name) and\n            re.search(r'[A-Z]', name) and\n            re.search(r'[a-z]', name) and\n            not re.search(r'\\d{4,}', name)):\n        return \"No\"\n    \n    # Check if the file's name has exactly two latin alphabet letters\n    if len(re.findall(r'[A-Za-z]', name)) < 2:\n        return \"No\"\n    \n    return \"Yes\"", "def file_name_check(file_name):\n    # Check the length\n    if len(file_name)<5 or len(file_name)>50:\n        return 'No'\n\n    # Split the file name based on '/' to get nested names\n    list_of_file_names = file_name.split('/')\n\n    # Iterate for every file in the path\n    for name in list_of_file_names:\n        # Split the extension from the file name using '.'\n        # Check if the file name is empty\n        # Check if there are more than one dots present\n        split_name = name.split('.')\n        if len(split_name) != 2 or not split_name[0] or not split_name[1]:\n            return 'No'\n\n        # Check the extension\n        if split_name[1].lower() not in [\"txt\", \"exe\", \"dll\", \"pdf\", \"jpeg\"]:\n            return 'No'\n\n        # Check if file name starts with a letter and has no more than three digits \n        # Search for the regular expression which satisfies the condition\n        if not re.search('[a-zA-Z].*(a-zA-Z)', split_name[0]) or len(re.findall('\\d', split_name[0])) > 3:\n            return 'No'\n\n    return 'Yes'", "def file_name_check(file_name):\n    # Check the length  \n    if len(file_name)<5 or len(file_name)>50:\n        return 'No'\n  \n    # Split the file name based on '/' to get nested names\n    list_of_file_names = file_name.split('/')\n  \n    # Iterate for every file in the path\n    for name in list_of_file_names:\n        # Split the extension from the file name using '.'\n        # check if the file name is empty\n        # check if there are more than one dots present\n        split_name = name.split('.')\n        if len(split_name) != 2 or not split_name[0] or not split_name[1]:\n            return 'No'\n        \n        # Check the extension\n        if split_name[1].lower() not in [\"txt\", \"exe\", \"dll\", \"pdf\", \"jpeg\"]:\n            return 'No'\n        \n        # Check if file name starts with a letter and has no more than three digits \n        # Search for the regular expression which satisfy the condition\n        if not re.search('[a-zA-Z].*[a-zA-Z]', split_name[0]) or len(re.findall('\\d', split_name[0])) > 3:\n            return 'No'\n  \n    return 'Yes'", "def file_name_check(file_name):\n    # Check for the reserved Windows characters\n    reserved_chars = ['<', '>', ':', '\"', '/', '\\\\', '|', '?', '*']\n    if any(c in file_name for c in reserved_chars):\n        return 'No'\n    # Check for the length requirement\n    if not (5 <= len(file_name) <= 50):\n        return 'No'\n    # Check if the file name has exactly one dot and get the name and extension parts\n    parts = file_name.split('.')\n    if len(parts) != 2:\n        return 'No'\n    name, extension = parts\n    # Check the conditions for the name part\n    if not re.match(r'^[a-zA-Z][a-zA-Z0-9]*$', name) or not any(c.isupper() for c in name) or not any(c.islower() for c in name) or len(re.findall(r'\\d{4,}', name)) > 0:\n        return 'No'\n    # Check the conditions for the extension part\n    if extension not in ['txt', 'exe', 'dll', 'pdf', 'jpeg']:\n        return 'No'\n    return 'Yes'"]}
{"task_id": "HumanEval/142", "problem": ["def strange_sort_list_bst(lst):\n    '''\n    This function should accept a list of integers and decimal numbers and return the list in a specific pattern, leveraging the principles of a binary search tree. The steps for this peculiar sorting pattern should be:\n    - Commence with the smallest number.\n    - Next, identify the highest value from the remaining elements.\n    - Then, ascertain the lowest value among the untouched output, and continue in this manner.\n    \n    Examples:\n    strange_sort_list_bst([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list_bst([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list_bst([]) == []\n    strange_sort_list_bst([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n    \n    # First, we will sort the list in ascending order.\n    lst.sort()\n\n    output = []\n\n    # Then, while lst is not empty, we will remove and append to output the smallest\n    # and largest element alternatively.\n    while lst:\n        output.append(lst.pop(0))  # smallest\n        if lst:\n            output.append(lst.pop(-1))  # largest\n\n    return output", "def strange_sort_list_bst(lst):\n    '''\n    This function should accept a list of integers and decimal_numbers and return the list in a specific pattern, leveraging the principles of a binary search tree. The steps to this peculiar_sorting pattern should be:\n    - Commence with the smallest number.\n    - Next, identify the highest value from the remaining elements.\n    - Then, ascertain the lowest_value among the untouched output, and continue in this manner.\n\n    Examples:\n    strange_sort_list_bst([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list_bst([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list_bst([]) == []\n    strange_sort_list_bst([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # First, we will sort the list in ascending_order.\n    lst.sort()\n\n    output = []\n\n    # Then, while lst is not empty, we will remove and append to output the smallest\n    # and largest element alternately.\n    while lst:\n        output.append(lst.pop(0))  # smallest\n        if lst:\n            output.append(lst.pop(-1))  # largest\n\n    return output", "def multiply(lst):\n    \"\"\"Given a non-empty list of integers lst, perform multiple steps calculation to find the product of odd elements located at even indices. Ensure none of the elements in the list exceeds 100 and that you handle possible exceptions. Additionally, guarantee the final product does not exceed 5000.\n\n    Example\uff1a\n         multiply([3, 5, 7, 8, 9]) ==> 21\n    \"\"\"\n    if not lst:    # if list is empty \n        return \"Input list should not be empty.\"\n    if not all(type(i) == int for i in lst):    # if list has non-integer elements \n        return \"All elements of the input list should be integer.\"\n    if not all(0 <= i <= 100 for i in lst):    # if list has elements exceeding 100\n        return \"Elements of the list should not exceed 100.\"\n    try:\n        product = 1\n        for i in range(0, len(lst), 2):    # skipping 1 element i.e., considering elements at even indices\n            if lst[i] % 2 != 0:    # if the element is odd\n                product *= lst[i]\n                if product > 5000:    # if the product exceeds 5000\n                    return \"Product exceeded 5000.\"\n        return product\n    except Exception as e:\n        return str(e)", "def multiply(lst):\n    \"\"\"Given a non-empty list of integers lst, perform multiple steps calculation to find the product of odd elements located at even indices. Ensure none of the elements in the list exceeds 100 and that you handle possible exceptions. Additionally, guarantee the final product does not exceed 5000.\n\n    Example\uff1a\n    multiply([3, 5, 7, 8, 6]) ==> 21\n    \"\"\"\n    if not lst:    # if list is empty \n        return \"Input list should not be empty.\"\n    if not all(type(i) == int for i in lst):    # if list has non-integer elements \n        return \"All elements of the input list should be integers.\"\n    if not all(0 <= i <= 100 for i in lst):    # if list has elements exceeding 100\n        return \"Elements of the list should not exceed 100.\"\n    try:\n        product = 1\n        for i in range(0, len(lst), 2):    # skipping 1 element i.e., considering elements at even indices\n            if lst[i] % 2 != 0:    # if the element is odd\n                product *= lst[i]\n            if product > 5000:    # if the product exceeds 5000\n                return \"Product exceeded 5000.\"\n        return product\n    except Exception as e:\n        return str(e)", "def create_dictionary(keys, values):\n    # Check if the length of the keys list is a multiple of 2\n    if len(keys) % 2 != 0:\n        return \"Length of keys list should be a multiple of 2.\"\n\n    # Check if the length of the values list is a multiple of 3\n    if len(values) % 3 != 0:\n        return \"Length of values list should be a multiple of 3.\"\n\n    # Check if the lengths of keys and values lists are the same\n    if len(keys) != len(values):\n        return \"Lengths of keys and values lists should be equal.\"\n\n    # Create an empty dictionary\n    dictionary = {}\n\n    # Iterate over the keys and values lists simultaneously\n    for key, value in zip(keys, values):\n        # Check if the key is unique\n        if key in dictionary:\n            return \"Keys should be unique.\"\n        \n        # Check if the value is of type string\n        if not isinstance(value, str):\n            return \"Values should be of type string.\"\n\n        # Add key-value pair to the dictionary\n        dictionary[key] = value\n\n    return dictionary"]}
{"task_id": "HumanEval/143", "problem": ["def detect_hate_speech(sentence):\n    # Define a list of hateful words or phrases\n    hateful_words = ['offensive_word1', 'offensive_word2', 'offensive_word3']\n\n    # Preprocess the sentence by removing non-alphabetic characters and converting to lowercase\n    processed_sentence = re.sub(r'[^a-zA-Z\\s]', '', sentence.lower())\n\n    # Split the processed sentence into characters\n    characters = list(processed_sentence)\n\n    # Check if any hateful words are present in the sentence\n    for word in hateful_words:\n        if word in characters:\n            return \"The sentiment of the sentence is: Hateful. The sentence contains hate speech.\"\n\n    # If no hateful words are found, the sentence is non-hateful\n    return \"The sentiment of the sentence is: Non-Hateful. The sentence does not contain any hate speech.\"", "def check(sentence):\n    words = sentence.split()\n    words = [normalize(word) for word in words]\n\n    for word in words:\n        if not is_palindrome(word):\n            return \"The sentence is not composed of palindromes.\"\n\n    if len(set(words)) < 2: \n        return \"The sentence is composed of palindromes. However, the words are not anagrams of each other.\"\n    \n    first_word = words[0]\n    remainder_words = words[1:]\n\n    if is_anagram(first_word, remainder_words):\n        return \"The sentence is composed of palindromes and every word is an anagram of each other.\"\n    else:\n        return \"The sentence is composed of palindromes. However, the words are not anagrams of each other.\"", "def shorthand_notation(sentence):\n    \"\"\"\n    Develop an algorithm for converting a given sequence of words into its equivalent shorthand notations.\n    \n    Parameters:\n    sentence (string): the sentence to be converted\n    \n    Returns:\n    string: the converted sentence\n    \"\"\"\n    words = sentence.split(\" \")\n    result = \"\"\n    for word in words:\n        result += word[0]\n    return result", "def delete_words_at_end(sentence):\n    # Define regular expression to match \"at the end\" phrases\n    at_the_end_regex = re.compile(r'\\bat the end\\b')\n    # Find all \"at the end\" phrases in the sentence\n    at_the_end_matches = at_the_end_regex.finditer(sentence)\n    # Loop through each \"at the end\" phrase\n    for match in at_the_end_matches:\n        # Prompt the user to select which words to delete\n        words_to_delete = input(f\"Which three words would you like to delete from '{match.group(0)}'? \")\n        # Split the words to delete into a list\n        words_to_delete_list = words_to_delete.split()\n        # Delete the selected words from the sentence\n        sentence = sentence[:match.start()] + sentence[match.end():]\n        for word in words_to_delete_list:\n            sentence = sentence.replace(word, '', 1)\n    # Return the revised sentence\n    return sentence", "def kebab_case(sentence):\n    # If input is not of string data type, return an error message\n    if not isinstance(sentence, str):\n        return 'Input must be a string.'\n\n    # If input is an empty string return an empty string\n    if sentence == '':\n        return ''\n\n    # Replace non-alphabetic characters with a space\n    modified_sentence = re.sub(r'[^A-Za-z0-9 ]', ' ', sentence)\n\n    # Split the sentence into words\n    words = modified_sentence.split()\n\n    # Join the words with hyphen and convert to lower case\n    kebab_case = \"-\".join(words).lower()\n\n    return kebab_case"]}
{"task_id": "HumanEval/144", "problem": ["def divide_numbers(numerator, denominator):\n    try:\n        quotient = numerator / denominator\n        print(\"The quotient is:\", quotient)\n    except ZeroDivisionError:\n        print(\"Error: You are attempting to divide by zero.\")\n    except TypeError:\n        print(\"Error: Invalid input. Both the numerator and denominator should be numbers.\")\n    finally:\n        print(\"This is the end of the division operation.\")", "def add_up_fractions(lst):\n    \"\"\"\n    Given a list of numerical items in the form of fractions, the function aims to return \n    the summation of these fractions, but only tackles the fractions whose bottom value is an even number.\n    \"\"\"\n    total = Fraction(0, 1)\n    for fraction in lst:\n        if fraction == '0':\n            continue\n        \n        numerator, denominator = map(int, fraction.split('/'))\n\n        if denominator % 2 == 0:\n            total += Fraction(numerator, denominator)\n\n    return str(total)", "def mixed_to_improper(mixed_fractions):\n    improper_fractions = []\n    for fraction in mixed_fractions:\n        parts = fraction.split()\n        whole = int(parts[0])\n        numerator, denominator = map(int, parts[1].split('/'))\n        if whole < 0:\n            numerator = -numerator + (abs(whole) * denominator)\n        else:\n            numerator = numerator + (whole * denominator)\n        improper_fractions.append(f\"{numerator}/{denominator}\")\n    return improper_fractions", "def calculate_denominator(A, c, dual, b):\n    \"\"\"\n    Calculate the denominator of a fraction.\n\n    Args:\n    A: numpy.ndarray, the constraint matrix with shape (m, n)\n    c: numpy.ndarray, the coefficients of the objective function with shape (n,)\n    dual: numpy.ndarray, the dual variables with shape (m,)\n    b: numpy.ndarray, the right-hand side of the constraints with shape (m,)\n\n    Returns:\n    float, the calculated denominator value\n    \"\"\"\n    m, n = A.shape\n    denominator = 0\n    for i in range(m):\n        denominator += np.dot(c, A[i]) * dual[i]\n    return denominator", "def divide(numerator, denominator):\n    if denominator == 0:\n        raise ZeroDivisionError(\"Denominator cannot be zero.\")\n    \n    sign = -1 if (numerator < 0) ^ (denominator < 0) else 1\n    numerator = abs(numerator)\n    denominator = abs(denominator)\n    \n    quotient = 0\n    while numerator >= denominator:\n        numerator -= denominator\n        quotient += 1\n    \n    return sign * quotient"]}
{"task_id": "HumanEval/145", "problem": ["def odd_sum_elements(x):\n    \"\"\"Given a list of positive integers x, return a sorted list of all \n    _unique_ elements where the sum of their digits is an odd number.\n\n    Note: The returned list should be sorted in ascending order. \n\n    >>> odd_sum_elements([15, 33, 1422, 1, 15])\n    [1, 15]\n    >>> odd_sum_elements([152, 323, 1422, 10])\n    [323]\n\n    \"\"\"\n    odd_sum_digits = []\n    for i in set(x):\n        if sum(int(digit) for digit in str(i)) % 2 != 0:\n            odd_sum_digits.append(i)\n    return sorted(odd_sum_digits)", "def unique_odd_digit_sum(x):\n    \"\"\"Given a list of integers x, return a sorted list of unique positive integers that have an odd sum of their digits. The same integer should not appear twice.  \n\n    Sort the final output list in ascending order. \n\n    E.g.:\n    >>> unique_odd_digit_sum([15, 38, 1420, 1, 15])\n    [1]\n    >>> unique_odd_digit_sum([154, 323, 1422, 10])\n    [323]\n    >>> unique_odd_digit_sum([-15, 38, -1420, -1, 15])\n    [15]\n    \"\"\"\n\n    # Create an empty list to store the resulting integers\n    result = []\n\n    # Loop over the input list x\n    for num in x:\n        # Exclude negative numbers\n        if num < 0:\n            continue\n\n        # Calculate the sum of the digits of num\n        digit_sum = sum(int(digit) for digit in str(num))\n\n        # Exclude integers with an even sum of digits\n        if digit_sum % 2 == 0:\n            continue\n\n        # Exclude integers that are already in the result list\n        if num in result:\n            continue\n\n        # Add the integer to the result list\n        result.append(num)\n        \n    return sorted(result)", "def unique_odd_digit_sum(x):\n    \"\"\"\n    Given a list of integers x, return a sorted list of unique positive integers\n    that have an odd sum of their digits. The same integer should not appear twice.\n    Sort the final output list in ascending order.\n\n    E.g.:\n    >>< unique_odd_digit_sum([15, 38, 1420, 1, 15])\n    [1]\n    >>< unique_odd_digit_sum([154, 323, 122, 10])\n    [323]\n    >>< unique_odd_digit_sum([-15, 38, 1420, -1, 15])\n    [15]\n    \"\"\"\n    \n    # Create an empty list to store the resulting integers\n    result = []\n\n    # Loop over the input list\n    for num in x:\n        # Exclude negative numbers\n        if num < 0:\n            continue\n\n        # Calculate the sum of the digits of num\n        digit_sum = sum(int(digit) for digit in str(num))\n\n        # Exclude integers with an even sum of digits\n        if digit_sum % 2 == 0:\n            continue\n\n        # Exclude integers that are already in the result list\n        if num in result:\n            continue\n\n        # Add the integer to the result list\n        result.append(num)\n\n    return sorted(result)", "def split_odd_totals(y):\n    \"\"\"In this function, given an array y of positive integers, generate two sorted arrays. One includes \n    _singular_ elements whose sum of their digits is odd and ends with an odd number, and other with \n    elements whose sum of their digits is odd and ends with an even number, both in ascending sequence.\n\n    >>> split_odd_totals([15, 33, 1422, 1, 15])\n    ([1, 15, 33], [1422])\n    >>> split_odd_totals([152, 323, 1422, 10])\n    ([323], [152, 1422])\n    \"\"\"\n\n    odd_ending = []\n    even_ending = []\n\n    for num in y:\n        digit_sum = sum(int(digit) for digit in str(num))\n        \n        if digit_sum % 2 != 0: # sum of digits is odd\n            if num % 2 != 0: # number ends with odd digit\n                odd_ending.append(num)\n            else: # number ends with even digit\n                even_ending.append(num)\n                \n    return sorted(odd_ending), sorted(even_ending)", "def prime_digit_product(x):\n    \"\"\"Given a list of positive integers x, return a sorted list of all \n    _distinct_ elements wherein the product of its digits is a prime number.\n\n    Note: The resulting list should be sorted in ascending order. \n\n    >>> prime_digit_product([15, 33, 1422, 1, 15])\n    [1, 15]\n    >>> prime_digit_product([152, 323, 1422, 10])\n    [323]\n\n    \"\"\"\n    return sorted(set([i for i in x if is_prime(prod([int(d) for d in str(i)]))]))"]}
{"task_id": "HumanEval/146", "problem": ["def split_odd_totals(y):\n    \"\"\"In this function, given an array y of positive integers, generate two sorted arrays. One includes \n    _singular_ elements whose sum of their digits is odd and ends with an odd number, and other with \n    elements whose sum of their digits is odd and ends with an even number, both in ascending sequence.\n\n    >>> split_odd_totals([15, 33, 1422, 1, 15])\n    ([1, 15, 33], [1422])\n    >>> split_odd_totals([152, 323, 1422, 10])\n    ([323], [152, 1422])\n    \"\"\"\n\n    odd_ending = []\n    even_ending = []\n\n    for num in y:\n        digit_sum = sum(int(digit) for digit in str(num))\n        \n        if digit_sum % 2 != 0: # sum of digits is odd\n            if num % 2 != 0: # number ends with odd digit\n                odd_ending.append(num)\n            else: # number ends with even digit\n                even_ending.append(num)\n                \n    return sorted(odd_ending), sorted(even_ending)", "def enhanced_solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are at even positions.    \n\n    Examples\n    enhanced_solution([5, 8, 7, 1]) => 5\n    enhanced_solution([3, 3, 3, 3, 3]) => 9\n    enhanced_solution([30, 13, 24, 321]) => 30\n    \"\"\"\n    return sum(num for i, num in enumerate(lst[::2]) if num % 2 == 1)", "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Authoritatively yield manually ordered, non-repetitive intersecting elements for two lists. \n    This function is constructed to handle integer arrays including negative integers, without depending \n    on inherent Python list functionalities. The function returns a well-ordered list eliminating any duplicates.\n    If one of the lists is empty, the function returns an empty list. \n    \n    :param l1: The first list of integers.\n    :type l1: list\n    :param l2: The second list of integers.\n    :type l2: list\n    :returns: A list containing ordered intersecting elements from both lists, without duplicates.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    >>> common([-2, -3, 0, 2, 5], [-5, 2, 0, -3])\n    [-3, 0, 2]\n    >>> common([-2, -3, 0, 2, 5], [])\n    []\n    \"\"\"\n    common_set = set()\n    ordered_set = set()\n    \n    # Traverse through lists and add common elements to common_set\n    for num in l1:\n        if num in l2 and num not in common_set:\n            common_set.add(num)\n            \n    # Traverse through common_set and add elements into ordered_set in sorted order.\n    # This step ensures the elimination of duplicate elements and correct ordering.\n    for num in sorted(common_set):\n        ordered_set.add(num)\n    \n    return list(ordered_set)", "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Authoritatively yield manually ordered, non-repetitive intersecting elements for two lists.\n    This function is constructed to handle integer arrays including negative integers,without depending \n    on inherent Python list functionalities. The function returns a well-ordered list eliminating any duplicates.\n    If one of the lists is empty, the function returns an empty list. \n\n    :param l1: The first list of integers.\n    :type l1: list\n    :param l2: The second list of integers.\n    :type l2: list\n    :returns: A list containing ordered intersecting elements from both lists, without duplicates.\n\n    >>> common([1, 4, 3, 34, 86, 2, 5], [5, 7, 1, 8, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    >>> common([-2, -3, 0, 2, 5], [-5, 2, 0, -3])\n    [-3, 0, 2]\n    >>> common([-2, -3, 0, 2, 5], [])\n    []\n    \"\"\"\n    common_set = set()\n    ordered_set = set()\n\n    # Traverse through lists and add common elements to common_set\n    for num in l1:\n        if num in l2 and num not in common_set:\n            common_set.add(num)\n\n    # Traverse through common_set and add elements into ordered_set in sorted order.\n    # This step ensures the elimination of duplicate elements and correct ordering.\n    for num in sorted(common_set):\n        ordered_set.add(num)\n\n    return list(ordered_set)", "def odd_sum_elements(x):\n    \"\"\"Given a list of positive integers x, return a sorted list of all \n    _unique_ elements where the sum of their digits is an odd number.\n\n    Note: The returned list should be sorted in ascending order. \n\n    >>> odd_sum_elements([15, 33, 1422, 1, 15])\n    [1, 15]\n    >>> odd_sum_elements([152, 323, 1422, 10])\n    [323]\n\n    \"\"\"\n    odd_sum_digits = []\n    for i in set(x):\n        if sum(int(digit) for digit in str(i)) % 2 != 0:\n            odd_sum_digits.append(i)\n    return sorted(odd_sum_digits)"]}
{"task_id": "HumanEval/147", "problem": ["def get_max_triples(n, p):\n    # calculate the array 'a' according to formula\n    a = [(i * i - i + p) + (i % p) for i in range(1, n+1)]\n    \n    # initialize count of triples to 0\n    counters = 0\n\n    # consider all triples a[i], a[j], a[k] such that i < j < k\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                # calculate modulus of product a[i]*a[j] by a[k]\n                product_modulus = (a[i] * a[j]) % a[k]\n\n                # check if the result is a multiple of n or p, increment the count\n                if product_modulus % n == 0 or product_modulus % p == 0:\n                    counters += 1\n\n    return counters", "def get_max_triples(n):\n    # Create an array 'a' of length 'n' with elements as per the given formula\n    a = [(i * i - i + 1) + (i % 3) for i in range(1, n + 1)]\n    triple_count = 0  # Initialize variable to count triples\n\n    #For all possible combinations of three items (a[i], a[j], a[k])\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                # Calculate the modulus of the product of any two elements by the third\n                product = (a[i] * a[j]) % a[k]\n                # Check if the result is a multiple of n\n                if product % n == 0:\n                    triple_count += 1  # Increment the counter if true\n\n    return triple_count  # Return the number of desired triples", "def lll_reduction(A):\n    \"\"\"\n    Implementation of the Lenstra-Lenstra-Lov\u00e1sz (LLL) algorithm for lattice reduction.\n\n    The LLL algorithm is a probabilistic polynomial-time algorithm for finding a short basis\n    of an integer lattice. It is based on the idea of Gram-Schmidt orthogonalization and\n    is a key component of many lattice-based cryptographic algorithms.\n\n    :param A: A matrix representing the basis of a lattice L.\n    :return: The reduced basis matrix B.\n    \"\"\"\n    n, m = A.shape\n    B = np.copy(A)\n    mu = np.array([np.linalg.norm(B[i]) ** 2 for i in range(n)])\n    k = 1\n\n    while k < n:\n        for j in range(k - 1, -1, -1):\n            mu[k] = mu[k] - (mu[j] * (B[k] @ B[j]) ** 2) / mu[j]\n            B[k] = B[k] - (B[j] * np.dot(B[k], B[j])) / mu[j]\n\n        if mu[k] < (0.75 - 0.5 * 0.5 ** k) * mu[k - 1]:\n            B[[k, k - 1]] = B[[k - 1, k]]\n            mu[[k, k - 1]] = mu[[k - 1, k]]\n            k = max(k - 1, 1)\n        else:\n            k += 1\n\n    return B", "def solve_linear_system(A):\n    n = len(A)\n\n    for i in range(n):\n        # Partial pivoting\n        max_row = i\n        for k in range(i+1, n):\n            if abs(A[k, i]) > abs(A[max_row, i]):\n                max_row = k\n        A[[i, max_row]] = A[[max_row, i]]\n\n        if A[i, i] == 0:\n            return \"Infinite solutions or inconsistent system\"\n\n        for j in range(i+1, n):\n            factor = A[j, i] / A[i, i]\n            A[j, i:] -= factor * A[i, i:]\n\n    if A[n-1, n-1] == 0:\n        return \"Infinite solutions or inconsistent system\"\n\n    x = np.zeros(n)\n    for i in range(n-1, -1, -1):\n        x[i] = (A[i, n] - np.dot(A[i, i+1:n], x[i+1:])) / A[i, i]\n\n    return x", "def gauss_elimination(a, b):\n    a = a.astype(float)\n    b = b.astype(float)\n    n = len(a)\n    for k in range(n):\n        # Pivot for column k\n        i_max = np.argmax(np.abs(a[k:,k])) + k \n        if a[i_max, k] == 0:\n            raise ValueError(\"Matrix is singular.\")\n        # Swap rows\n        a[[k, i_max]] = a[[i_max, k]]\n        b[[k, i_max]] = b[[i_max, k]]\n        # Gauss elimination\n        for i in range(k+1, n):\n            factor = a[i,k] / a[k,k]\n            a[i, k:] = a[i, k:] - factor * a[k, k:]\n            b[i] = b[i] - factor * b[k]\n    # Back substitution\n    x = np.zeros_like(b)\n    for k in range(n-1, -1, -1):\n        x[k] = (b[k] - np.dot(a[k, k+1:], x[k+1:])) / a[k, k]\n    return x"]}
{"task_id": "HumanEval/148", "problem": ["def greet(*planets):\n    valid_planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    for planet in planets:\n        if planet in valid_planets:\n            if planet == \"Earth\":\n                print(\"Greetings Earth\")\n            else:\n                print(f\"{planet} is a valid planet but the greetings is only for Earth\")\n        else:\n            print(f\"Error: {planet} is not a valid planet\")", "def planet_distance_from_sun(planets):\n    # Defined distance from the sun in astronomical units (AU where 1 AU = 149,597,870.7)\n    distances = {\n        \"Mercury\": 0.387,\n        \"Venus\": 0.723,\n        \"Earth\": 1.000,\n        \"Mars\": 1.524,\n        \"Jupiter\": 5.203,\n        \"Saturn\": 9.537,\n        \"Uranus\": 19.191,\n        \"Neptune\": 30.069\n    }\n\n    # Sorting the planets by distance from the sun\n    sorted_planets = sorted(list(distances.keys()), key=lambda x: distances[x])\n\n    return sorted_planets", "def bf(planet1, planet2, planet3):\n    if is_valid(planet1) and is_valid(planet2) and is_valid(planet3): \n    # Sort the planets based on their position in the solar system\n        planets = sorted([planet1, planet2, planet3], key=SOLAR_SYSTEM.index)\n        return get_neighbors(planets[-1])  # Return the neighbors of the furthest planet\n    else:\n        return ()", "def bf(planet1, planet2, planet3):\n    if is_valid(planet1) and is_valid(planet2) and is_valid(planet3): \n        # sort the planets based on their position in the solar system\n        planets = sorted([planet1, planet2, planet3], key=SOLAR_SYSTEM.index)\n        return get_neighbors(planets[-1])  # return the neighbors of the furthest planet\n    else:\n        return ()", "def bf(planet1, planet2):\n    if is_valid(planet1) and is_valid(planet2):\n        # Sorted list of planet names\n        sorted_planets = sorted(PLANETS, key=PLANETS.get)\n        \n        idx1, idx2 = sorted_planets.index(planet1), sorted_planets.index(planet2)\n        # Ensure idx1 is always less than idx2\n        if idx2 < idx1:\n            idx1, idx2 = idx2, idx1       \n        planets_between = sorted_planets[idx1+1:idx2]\n        \n        result = []\n        for planet in planets_between:\n            # Calculate time to travel from the sun to each planet at the speed of light\n            time_to_planet = PLANETS[planet]*10**6/SPEED_OF_LIGHT\n            result.append((planet, time_to_planet)) \n            \n        return tuple(result)\n    else:\n        return ()"]}
{"task_id": "HumanEval/149", "problem": ["def complex_sorted_list(lst, reverse=False, min_sum=0, max_sum=None, sort_function=None, secondary_sort_function=None):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter and performs the following:\n    - Delete strings with odd lengths or containing numerals.\n    - Sort the list based on the sum of the ASCII values of the characters in each string.\n    - The list may contain duplicates, ignore case, and special characters.\n    - Toggle sorting between ascending and descending order using an optional boolean `reverse` (default is False).\n    - Implement an optional minimum sum `min_sum` (default is 0) to return only strings with a sum greater or equal.\n    - Implement an optional maximum sum `max_sum` to return only strings with a sum less than or equal.\n    - Implement an optional custom sorting method `sort_function` to sort strings using a custom function.\n    - Implement an optional secondary custom sorting method `secondary_sort_function` to sort strings using a secondary function.\n    \n    E.g.:\n    assert complex_sorted_list([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert complex_sorted_list([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    assert complex_sorted_list([\"ab\", \"a\", \"aaa\", \"cd\"], True) => [\"cd\", \"ab\"]\n    assert complex_sorted_list([\"ab\", \"a\", \"aaa\", \"cd\"], min_sum=200) => [\"cd\"]\n    \"\"\"\n    \n    # Remove strings with odd lengths and strings containing numerals\n    clean_lst = [s for s in lst if len(s) % 2 == 0 and not any(c.isdigit() for c in s)]\n    \n    if not sort_function:\n        sort_function = lambda s: sum(ord(c) for c in s)\n    \n    if secondary_sort_function:\n        clean_lst.sort(key=secondary_sort_function)\n    \n    # Sort strings based on the sort_function\n    clean_lst.sort(key=sort_function, reverse=reverse)\n    \n    # Filter strings based on min_sum and max_sum\n    filtered_lst = [s for s in clean_lst if min_sum <= sort_function(s) <= (max_sum if max_sum else float(\"inf\"))]\n    \n    return filtered_lst", "def sorted_list_sum(lst, reverse=False):\n    \"\"\"\n    This function takes as input a list of strings, removes any string that contains a numerical digit or \n    an odd number of characters, sorts remaining strings in ascending order by both length and alphabetically, \n    and then returns the sorted list.\n    \n    Achieves this by using list comprehension to filter out unwanted elements, \n    and Python's built-in sorted function to sort the list. The sorted function uses a compound sorting key \n    consisting of the length of each element and the element itself, allowing for sorting by multiple criteria.\n    \n    The ordering of the sorted list can be reversed by supplying a second argument of True.\n\n    Parameters:\n    lst (list): A list of strings to be filtered and sorted.\n    reverse (bool): Optional parameter to reverse the order of the sorted list. Defaults to False.\n\n    Returns:\n    list: The sorted list of strings.\n    \"\"\"\n    \n    # Filter out any strings containing numerical digits or with odd length\n    lst = [i for i in lst if not any(j.isdigit() for j in i) and len(i) % 2 == 0]\n    \n    # Return the list sorted by length and then alphabetically, in ascending or descending order\n    return sorted(lst, key=lambda x: (len(x), x), reverse=reverse)", "def sorted_list(lst, reverse=False):\n    \"\"\"\n    This function takes a list of string literals, discards strings that are of odd lengths or contain digits, \n    and returns a sorted list according to the specified stipulations.\n    The list is sorted based on the length of each word in an ascending sequence. \n    For words of equivalent length, it is sorted in alphabetical order. \n    Case sensitivity and special characters are ignored during the sorting operation.\n    An optional boolean parameter `reverse`, with a default value set to False, can be used to toggle the sorting pattern \n    between ascending and descending.\n    Note:\n    The input will always be a list of string literals and can never be of numeric type.\n    The list can have duplicate elements.\n    \"\"\"\n    import re\n    \n    # Filter out string literals of odd length and those containing digits\n    filtered_list = [x for x in lst if len(x) % 2 == 0 and not bool(re.search(r'\\d', x))]\n    \n    # Sort the list first by length, then by alphabetical order (case insensitive), and optionally in reverse order\n    return sorted(filtered_list, key=lambda x: (len(x), x.lower()), reverse=reverse)", "def sort_strings(strings, descending=False):\n    \"\"\"\n    Sorts a list of strings according to their length, while also ensuring that strings with the same length are sorted\n    in alphabetical order. The function can sort the list in ascending or descending order based on user input.\n    \n    Args:\n        strings (list): A list of strings to be sorted\n        descending (bool, optional): If True, sorts the list in descending order. Defaults to False.\n    \n    Returns:\n        list: A sorted list of strings\n    \"\"\"\n    # Sort the strings by length and then by alphabetical order\n    sorted_strings = sorted(strings, key=lambda s: (len(s), s))\n    \n    # Reverse the list if descending is True\n    if descending:\n        sorted_strings.reverse()\n    \n    return sorted_strings", "def advanced_array_aggregation(lst, reverse=False):\n    \"\"\"\n    This function accepts a list of strings, filters the list by dropping strings of odd length or containing numbers,\n    and returns a sorted list based on the following criteria:\n    = All list entries must be strings; no grouping of numbers allowed\n    = Duplicates in the list are possible\n    = List is sorted in ascending order based on word length, and then alphabetically for words of the same length\n    = Ignore capitalization and special characters during sorting\n    Additionally, sorting order can be switched by initializing an optional logical 'reverse' parameter.\n\n    Furthermore, the function should also check for characters that appear more than twice in a single string and\n    discard these strings from the list.\n    \"\"\"\n\n    # We filter the strings of odd length or containing numbers\n    filtered = [s for s in lst if len(s) % 2 == 0 and not any(c.isdigit() for c in s)]\n    \n    # We check for characters that appear more than twice in a single string and discard these strings\n    filtered = [s for s in filtered if all(v <= 2 for v in Counter(s).values())]\n    \n    # Ignore capitalization and special characters during sorting\n    filtered = [\"\".join(ch for ch in s if ch.isalnum()) for s in filtered]\n    filtered = [s.lower() for s in filtered]\n\n    # Add some complexity by sorting the list according to length, and then by lexical order\n    filtered = sorted(filtered, key=lambda s: (len(s), s) , reverse=reverse)\n    \n    return filtered"]}
{"task_id": "HumanEval/150", "problem": ["def x_or_y(n, x, y):\n    return x if _is_prime(n) else y", "def choose_num(x, y, z):\n    \"\"\"\n    This function accepts three positive integers x, y, and z, and its objective is to return the\n    greatest even integer within the inclusive range of [x, y] that can be evenly divided by z. In the\n    absence of such a number, the function should yield -1.\n\n    Example cases:\n    choose_num(12, 15, 2) = 14\n    choose_num(13, 12, 3) = -1\n    choose_num(10, 20, 4) = 20\n    \"\"\"\n\n    # Start checking from the largest number in the range [x, y]\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0 and num % z == 0:\n            return num\n    return -1", "def lowest_common_multiple(x: int, y: int) -> int:\n    \"\"\" Reveals the lowest common multiple for a couple of positive integers, x and y\n    >>> lowest_common_multiple(3, 5)\n    15\n    >>> lowest_common_multiple(25, 15)\n    75\n    \"\"\"\n    return abs(x*y) // math.gcd(x, y)", "def lowest_common_multiple(x: int, y: int) -> int:\n    \"\"\" Reveals the lowest common multiple for a couple of positive integers, x and y\n    >>> lowest_common_multiple(3, 5)\n    15\n    >>> lowest_common_multiple(25, 15)\n    75\n    \"\"\"\n    return abs(x*y) // math.gcd(x, y)", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)"]}
{"task_id": "HumanEval/151", "problem": ["def positive_cubes_sum(lst):\n    '''\n    This function calculates sum of cubes of both odd and even positive integers in a list.\n    \n    positive_cubes_sum([1, 2, 3, 4]) == 1 + 8 + 27 + 64 = 100\n    positive_cubes_sum([-1, -2, 1, 2]) == 9\n    positive_cubes_sum([8, -3]) == 512\n    positive_cubes_sum([0]) == 0\n\n    If input is empty, function should return 0.\n    '''\n    return sum(i**3 for i in lst if i > 0)", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)", "def enhanced_solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are at even positions.    \n\n    Examples\n    enhanced_solution([5, 8, 7, 1]) => 5\n    enhanced_solution([3, 3, 3, 3, 3]) => 9\n    enhanced_solution([30, 13, 24, 321]) => 30\n    \"\"\"\n    return sum(num for i, num in enumerate(lst[::2]) if num % 2 == 1)", "def sum_of_even_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers: A list of integers.\n\n    Returns:\n    The sum of all even numbers in the list.\n    \n    Examples:\n    >>> sum_of_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    30\n    >>> sum_of_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_of_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)", "def sum_even_numbers(numbers):\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The sum of all even numbers in the list.\n\n    Examples:\n    >>> sum_even_numbers([1, 2, 3, 4, 5, 6])\n    12\n    >>> sum_even_numbers([10, 11, 12, 13, 14, 15])\n    36\n    >>> sum_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)"]}
{"task_id": "HumanEval/152", "problem": ["def chosen_ciphertext_attack(key_length, plaintext_length, num_samples):\n    # Generate a key\n    key = generate_key(key_length)\n    \n    # Generate a series of ciphertexts\n    ciphertexts = []\n    for _ in range(num_samples):\n        plaintext = generate_plaintext(plaintext_length)\n        ciphertext = encrypt(key, plaintext)\n        ciphertexts.append((plaintext, ciphertext))\n    \n    # Analyze the ciphertexts to infer information (this is the part you need to implement)\n    # For example, you could try to guess the key by analyzing the ciphertexts\n    # and then using the known plaintext to confirm your guess.\n    \n    # Let's try to guess the key by looking at the distribution of XORed bits\n    guessed_key = ''\n    for i in range(plaintext_length):\n        # Count the number of 0s and 1s at position i across all ciphertexts\n        ones_count = sum(1 for plaintext, ciphertext in ciphertexts if ciphertext[i] == chr(ord(plaintext[i]) ^ ord('1')))\n        zeros_count = sum(1 for plaintext, ciphertext in ciphertexts if ciphertext[i] == chr(ord(plaintext[i]) ^ ord('0')))\n        \n        # The most common bit at position i in the ciphertexts is likely the bit of the key at position i\n        if ones_count > zeros_count:\n            guessed_key += '1'\n        else:\n            guessed_key += '0'\n    \n    # Confirm the guessed key by XORing it with a known plaintext and comparing with the ciphertext\n    known_plaintext = ciphertexts[0][0]  # Use the first plaintext as the known plaintext\n    known_ciphertext = ciphertexts[0][1]  # Use the first ciphertext as the known ciphertext\n    confirmed_key = ''.join(chr(ord(p) ^ ord(k)) for p, k in zip(known_plaintext, guessed_key))\n    \n    # Check if the confirmed key is correct\n    if confirmed_key == known_ciphertext:\n        print(\"The key was successfully guessed:\", guessed_key)\n    else:\n        print(\"The key was not guessed correctly.\")", "def veggie_distribution(s, n, veggies, servings, exp_dates, time_in_rack):\n    \"\"\"\n    In this task, you are provided with a list of phrases indicating different quantities of vegetables\n    stored in a rack. The rack can hold potatoes, tomatoes, onions, and other varieties.\n    The list might be represented as follows: [\"X potatoes\", \"Y tomatoes\", \"Z onions\",...]\n\n    You are also given a hash map that displays the number of servings each vegetable can provide,\n    another hash map that depicts the expiration dates of the veggies (format: YYYY-MM-DD), and a hash map\n    that shows the duration each vegetable has been stationed in the rack.\n    \n    Given this list, an integer denoting the total vegetables in the rack, the servings hash map, \n    the expiration dates hash map, and the duration in the rack, return a hash map that displays the \n    quantity of servings of each vegetable that is not expired and has been in the\n    rack for a duration of two hours or less.\n    \n    Note that the result should be a hash map that includes only the vegetables with a non-zero count of servings\n    and have been stationed in the rack for a maximum of two hours.\n    \"\"\"\n    from datetime import datetime, timedelta\n    valid_veggies = {}\n    current_time = datetime.now()\n\n    for veg in veggies:\n        veg_name = veg.split()[1]  # extract vegetable name\n        # check if it's not listed and not expired, and in the rack for a maximum of two hours\n        if (veg_name not in servings or servings[veg_name] == 0 or datetime.strptime(exp_dates[veg_name], \"%Y-%m-%d\") < current_time or time_in_rack[veg_name] > timedelta(hours=2)):\n            continue\n        else:\n            valid_veggies[veg_name] = servings[veg_name]\n            \n    return valid_veggies", "def abs_larger(x: Union[int, float], y: Union[int, float]) -> Union[int, float]:\n    \"\"\"\n    This function calculates the absolute value of the larger input.\n\n    Args:\n        x (Union[int, float]): The first input value\n        y (Union[int, float]): The second input value\n\n    Returns:\n        Union[int, float]: The absolute value of the larger input\n\n    Raises:\n        TypeError: If any input value is not an integer or float\n    \"\"\"\n\n    # check if the inputs are integers or floats\n    if not isinstance(x, (int, float)) or not isinstance(y, (int, float)):\n        raise TypeError(\"Input values must be integers or floats.\")\n\n    # calculate the absolute value of x and y\n    abs_x = abs(x)\n    abs_y = abs(y)\n\n    # compare the absolute values of x and y and return the larger absolute value\n    if abs_x > abs_y:\n        return abs_x\n    else:\n        return abs_y", "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function inserts a number 'delimeter' between each consectute elements of the input list `numbers` and deals with scenarios where the delimeter is negative.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], -2)\n    [1, 2, 3]\n    \"\"\" \n    result = []\n    abs_delimeter = abs(delimeter)\n    for i in range(len(numbers)):\n        result.append(numbers[i])\n        if i != len(numbers)-1:\n            # Exempt the index locations that matches absolute of negative delimeter\n            if i+1 != abs_delimeter:\n                result.append(delimeter)\n    return result", "def compareStrings(str1, str2):\n    '''Function to compare two strings and return the index of the first different character.'''\n    \n    # We assume that both strings have the same length\n    l1 = len(str1)\n    l2 = len(str2)\n    \n    # If the lengths are not equal, return -1\n    if l1 != l2:\n        return -1\n        \n    for i in range(l1):\n        if str1[i] != str2[i]:\n            return i\n    \n    # Return -1 if there is no difference between the strings\n    return -1"]}
{"task_id": "HumanEval/153", "problem": ["def count_file_extensions(file_list):\n    \"\"\"\n    Counts the occurrences of unique file extensions in the given list of file names.\n\n    Args:\n    file_list: A list of strings representing file names.\n\n    Returns:\n    A dictionary where keys are unique file extensions and values are the count of their occurrences in the file_list.\n    \"\"\"\n    extension_count = {}\n    for file_name in file_list:\n        parts = file_name.split('.')\n        if len(parts) > 1:\n            extension = parts[-1]\n        else:\n            extension = ''\n        extension_count[extension] = extension_count.get(extension, 0) + 1\n    return extension_count", "def file_name_check(file_name):\n    # Check if the file's name length is within the allowed range\n    if not 5 <= len(file_name) <= 50:\n        return \"No\"\n\n    name, dot, extension = file_name.rpartition('.')\n\n    # Check if the file's name has exactly one dot and a valid extension\n    if not dot or extension not in ['txt', 'exe', 'dll', 'pdf', 'jpeg']:\n        return \"No\"\n\n    # Check if the file's name has valid alphanumeric characters, and has at least\n    # one uppercase, one lowercase, and maximum of three consecutive digits\n    if not (re.search(r'[A-Za-z].*', name) and\n            re.search(r'[A-Z]', name) and\n            re.search(r'[a-z]', name) and\n            not re.search(r'\\d{4,}', name)):\n        return \"No\"\n\n    # Check if the file's name has exactly two latin alphabet letters\n    if len(re.findall(r'[A-Za-z]', name)) != 2:\n        return \"No\"\n    \n    return \"Yes\"", "def file_name_check(file_name):\n    # Check if the file's name length is within the allowed range\n    if not 5 <= len(file_name) <= 50:\n        return \"No\"\n    \n    name, dot, extension = file_name.rpartition('.')\n    \n    # Check if the file's name has exactly one dot and a valid extension\n    if not dot or extension not in ['txt', 'exe', 'dll', 'pdf', 'jpeg']:\n        return \"No\"\n    \n    # Check if the file's name has valid alphanumeric characters, and has at least\n    # one uppercase, one lowercase, and maximum of three consecutive digits\n    if not (re.match(r'[A-Za-z].*$', name) and\n            re.search(r'[A-Z]', name) and\n            re.search(r'[a-z]', name) and\n            not re.search(r'\\d{4,}', name)):\n        return \"No\"\n    \n    # Check if the file's name has exactly two latin alphabet letters\n    if len(re.findall(r'[A-Za-z]', name)) < 2:\n        return \"No\"\n    \n    return \"Yes\"", "def peculiar_ordering(lst, d):\n    '''\n    Given a list of integers and a dictionary with integer keys and unique string values, return the list in a special order.\n    \n    normalize the input list to have a mean of zero and a standard deviation of one.\n    \n    For each element in the list, append its corresponding string value from the dictionary to a new list.\n    The peculiarity of ordering the string values extends to removing any duplicate string values in the new list no matter how often they appear in the original list.\n    \n    Then order this new list in a peculiar manner:\n    - Start with the string associated with the minimal value integer.\n    - Then, find the string associated with the maximum remaining integer.\n    - Next, find the string associated with the minimum remaining integer, and so on.\n    The function should also handle negative integers, and decimal numbers and there should be a mapping provided for them in the dictionary. \n\n    For example:\n    peculiar_ordering([1, 2, 3, 4, 5], {1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e'}) == ['a', 'b', 'c', 'd','e']\n    Note: In the example, 'a' represents 1, 'b' represents 2, etc.\n    '''\n    # normalize the input list\n    lst = [(i - np.mean(lst)) / np.std(lst) for i in lst]\n\n    value_order = []\n\n    for v in lst:\n        value = d.get(v)\n        \n        if value not in value_order:\n            value_order.append(value)\n\n    # sort the values in a peculiar order\n    value_order = sorted(value_order, key=lambda x: (value_order.index(x) % 2, x))\n\n    return value_order", "def veggie_distribution(s, n, veggies, servings, exp_dates, time_in_rack):\n    \"\"\"\n    In this task, you are provided with a list of phrases indicating different quantities of vegetables\n    stored in a rack. The rack can hold potatoes, tomatoes, onions, and other varieties.\n    The list might be represented as follows: [\"X potatoes\", \"Y tomatoes\", \"Z onions\",...]\n\n    You are also given a hash map that displays the number of servings each vegetable can provide,\n    another hash map that depicts the expiration dates of the veggies (format: YYYY-MM-DD), and a hash map\n    that shows the duration each vegetable has been stationed in the rack.\n    \n    Given this list, an integer denoting the total vegetables in the rack, the servings hash map, \n    the expiration dates hash map, and the duration in the rack, return a hash map that displays the \n    quantity of servings of each vegetable that is not expired and has been in the\n    rack for a duration of two hours or less.\n    \n    Note that the result should be a hash map that includes only the vegetables with a non-zero count of servings\n    and have been stationed in the rack for a maximum of two hours.\n    \"\"\"\n    from datetime import datetime, timedelta\n    valid_veggies = {}\n    current_time = datetime.now()\n\n    for veg in veggies:\n        veg_name = veg.split()[1]  # extract vegetable name\n        # check if it's not listed and not expired, and in the rack for a maximum of two hours\n        if (veg_name not in servings or servings[veg_name] == 0 or datetime.strptime(exp_dates[veg_name], \"%Y-%m-%d\") < current_time or time_in_rack[veg_name] > timedelta(hours=2)):\n            continue\n        else:\n            valid_veggies[veg_name] = servings[veg_name]\n            \n    return valid_veggies"]}
{"task_id": "HumanEval/154", "problem": ["def cycpattern_check(a , b):\n    \"\"\"Example usage:    \n    cycpattern_check(\"AbcD\",\"aBd\") => False\n    cycpattern_check(\"Hello\",\"ELl\") => True\n    cycpattern_check(\"Whas$sup\",\"pSUs\") => False\n    cycpattern_check(\"aB!ab\",\"BAa\") => True\n    cycpattern_check(\"EfEF\",\"EeFf\") => False\n    cycpattern_check(\"Hi^mensS\",\"sImen\") => True\n    \"\"\"\n    # Clean the strings: convert to lower case and remove special characters\n    a_clean = re.sub(r'\\W+', '', a).lower()\n    b_clean = re.sub(r'\\W+', '', b).lower()\n    \n    # Create all cyclic permutations of the second string\n    cyclic_permutations = [b_clean[i:] + b_clean[:i] for i in range(len(b_clean))]\n    \n    # Check if any of the permutations is in the first string\n    return any(permutation in a_clean for permutation in cyclic_permutations)", "def cycpattern_check(a , b):\n    # Preprocessing of strings\n    a = \"\".join(re.findall(\"[a-zA-Z0-9]*\", a)).lower()\n    b = \"\".join(re.findall(\"[a-zA-Z0-9]*\", b)).lower()\n\n    # Function for getting all the cyclic permutations\n    cycle = lambda s: [s[i:] + s[:i] for i in range(len(s))]\n\n    # Check for presence of b or its cyclic permutations in a\n    return any(c in a for c in cycle(b))", "def cycpattern_check(a , b):\n    a, b = clean_string(a), clean_string(b)\n    return any(is_subsequence(a, perm) for perm in cyclic_permutations(b))", "def find_max(words, case_sensitive=False):\n    \"\"\"This function accepts a list of distinct strings as an input. \n    It returns the string with the greatest number of unique characters. \n    If there is a tie, it provides the first word in lexicographical order. \n    Character cases are considered separate only if the parameter case_sensitive is set to True.\n\n    >>> find_max([\"name\", \"of\", \"String\"], True)\n    \"String\"\n    >>> find_max([\"name\", \"enam\", \"Game\"])\n    \"enam\"\n    >>> find_max([\"aaaaaaa\", \"BB\" ,\"cc\"])\n    \"aaaaaaa\"\n    \"\"\"\n    # Error handling for bad input types\n    if not isinstance(words, list) or not all(isinstance(i, str) for i in words):\n        raise ValueError('Invalid input type. Please enter a list of strings')\n\n    # If case_sensitive is False, convert all words to lowercase. \n    words_lower  = [word.lower() for word in words] if not case_sensitive else words\n\n    # Loop through the words and find the word with the most unique characters.\n    # In case of tie, return the word that comes first lexicographically.\n    max_unique_chars = 0\n    max_word = ''\n    for word in words_lower:\n        num_unique_chars = len(set(word))\n        if num_unique_chars > max_unique_chars:\n            max_unique_chars = num_unique_chars\n            max_word = word\n        elif num_unique_chars == max_unique_chars:\n            max_word = min(word, max_word)\n    return max_word", "def find_max(words, case_sensitive=False):\n    \"\"\"\n    This function accepts a list of distinct strings as an input, \n    It returns the string with the greatest number of unique characters.\n    If there is a tie, it provides the first word in lexicographical order. \n    Character cases are considered separate only if the parameter case_sensitive is set to True.\n\n    >>> find_max([\"name\", \"of\", \"string\"], True)\n    'string'\n    >>> find_max([\"name\", \"enam\", \"game\"])\n    'enam'\n    >>> find_max([\"aaaaaaa\", \"b13\" ,\"cc\"])\n    'aaaaaaa'\n    \"\"\"\n    \n    # Error handling for bad input types\n    if not isinstance(words, list) or not all(isinstance(w, str) for w in words):\n        raise ValueError('Invalid input type. Please enter a list of strings')\n\n    # If case_sensitive is False, convert all words to lowercase. \n    words_lower  = [word.lower() for word in words] if not case_sensitive else words\n    \n    # Loop through the words and find the word with the most unique characters.\n    # In case of tie, return the word that comes first lexicographically.\n    max_unique_chars = 0\n    max_word = ''\n    for word in words_lower:\n        num_unique_chars = len(set(word))\n        if num_unique_chars > max_unique_chars:\n            max_unique_chars = num_unique_chars\n            max_word = word\n        elif num_unique_chars == max_unique_chars:\n            max_word = min(word, max_word)\n    return max_word"]}
{"task_id": "HumanEval/155", "problem": ["def even_odd_count(num):\n    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):  # Converting the input to a positive string number\n        if int(digit) % 2 == 0:  # Checking if the digit is even\n            even_count += 1      # If even, increment the even_count\n        else:\n            odd_count += 1       # If odd, increment the odd_count\n    return (even_count, odd_count) # Return the counts as a tuple", "def numsManipulation(n):\n    \"\"\"Given a positive integer n, return the product of the cubes of odd digits and the sum of squares of the even digits.\n    If all digits are even, return the product of cubes of the first half of even digits.\n    If all digits are odd, return the sum of the squares of the first half of odd digits.\n    For example:\n    numsManipulation(1)   == 1\n    numsManipulation(4)   == 16\n    numsManipulation(235) == 31 (2^2 + 3^3*5^3)\n    \"\"\"\n\n    # List of odd and even digits\n    odd_digits = [int(digit) for digit in str(n) if int(digit) % 2 != 0]\n    even_digits = [int(digit) for digit in str(n) if int(digit) % 2 == 0]\n\n    # Determine the calculation based on the digits\n    if len(odd_digits) > 0 and len(even_digits) > 0:\n        # Both odd and even digits\n        return sum(d ** 2 for d in even_digits) + prod(d ** 3 for d in odd_digits)\n    elif len(odd_digits) > 0:\n        # Only odd digits\n        return sum(d ** 2 for d in odd_digits[:len(odd_digits)//2])\n    else:\n        # Only even digits\n        return prod(d ** 3 for d in even_digits[:len(even_digits)//2])", "def numsManipulation(n):\n    \"\"\"\n    Given a positive integer n, return the product of the cubes of odd digits and the sum of the squares of the even digits.\n    If all digits are even, return the product of cubes of the first half of even digits.\n    If all digits are odd, return the sum of the squares of the first half of odd digits.\n    For example:\n    numsManipulation(1) == 1\n    numsManipulation(4) == 16\n    numsManipulation(235) == 31 (2^2 + 3^3 + 5^3)\n    \"\"\"\n\n    # List of odd and even digits\n    odd_digits = [int(digit) for digit in str(n) if int(digit) % 2 != 0]\n    even_digits = [int(digit) for digit in str(n) if int(digit) % 2 == 0]\n\n    # Determine the calculation based on the digits\n    if len(odd_digits) > 0 and len(even_digits) > 0:\n        # Both odd and even digits\n        return sum(d ** 2 for d in even_digits) + prod(d ** 3 for d in odd_digits)\n    elif len(odd_digits) > 0:\n        # Only odd digits\n        return sum(d ** 2 for d in odd_digits[:len(odd_digits)//2])\n    else:\n        # Only even digits\n        return prod(d ** 3 for d in even_digits[:len(even_digits)//2])", "def split_odd_totals(y):\n    \"\"\"In this function, given an array y of positive integers, generate two sorted arrays. One includes \n    _singular_ elements whose sum of their digits is odd and ends with an odd number, and other with \n    elements whose sum of their digits is odd and ends with an even number, both in ascending sequence.\n\n    >>> split_odd_totals([15, 33, 1422, 1, 15])\n    ([1, 15, 33], [1422])\n    >>> split_odd_totals([152, 323, 1422, 10])\n    ([323], [152, 1422])\n    \"\"\"\n\n    odd_ending = []\n    even_ending = []\n\n    for num in y:\n        digit_sum = sum(int(digit) for digit in str(num))\n        \n        if digit_sum % 2 != 0: # sum of digits is odd\n            if num % 2 != 0: # number ends with odd digit\n                odd_ending.append(num)\n            else: # number ends with even digit\n                even_ending.append(num)\n                \n    return sorted(odd_ending), sorted(even_ending)", "def check_integer(number):\n    if number % 2 == 0:\n        if number % 3 == 0:\n            print(\"The given integer is even and a multiple of 3.\")\n        else:\n            print(\"The given integer is even and not a multiple of 3.\")\n    else:\n        if number % 3 == 0:\n            print(\"The given integer is odd and a multiple of 3.\")\n        else:\n            print(\"The given integer is odd and not a multiple of 3.\")"]}
{"task_id": "HumanEval/156", "problem": ["def convert_number(number, conversion_type):\n    \"\"\"\n    Converts a positive integer or roman numeral to each other.\n    Conversion types: 'int_to_roman' or 'roman_to_int'.\n    Limitations: 1 <= num <= 1000 for integers and valid roman numerals\n\n    Examples:\n    >>> convert_number(19, 'int_to_roman') == 'xix'\n    >>> convert_number(152, 'int_to_roman') == 'clii'\n    >>> convert_number('cdxxvi', 'roman_to_int') == 426\n    \"\"\"\n    # Define all unique symbols and corresponding values for roman numerals\n    VALUES = {\n    'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,\n    'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000\n    }\n    # A reversed map of above, for int to roman conversion\n    ROMANS = {v: k for k, v in reversed(sorted(VALUES.items()))}\n\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            raise ValueError(\"Input integer must be between 1 and 1000.\")\n        \n        result = ''\n        for value, numeral in ROMANS.items():\n            count = number // value\n            result += numeral * count\n            number -= value * count\n        return result\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str) or any(i not in VALUES for i in number):\n            raise ValueError(\"Invalid Roman Numeral.\")\n        \n        result = 0\n        i = 0\n        while i < len(number):\n            # If this is a subtractive combination, process both elements\n            if i + 1 < len(number) and number[i:i+2] in VALUES:\n                result += VALUES[number[i:i+2]]\n                i += 2\n            else:\n                # Else, process one element\n                result += VALUES[number[i]]\n                i += 1\n\n        if result < 1 or result > 1000:\n            raise ValueError(\"Result is out of range!\")\n        return result\n    else:\n        raise ValueError(\"Invalid conversion type!\")", "def convert_number(number, conversion_type):\n    \"\"\"\n    Converts a positive integer or roman numeral to each other.\n    Conversion types: 'int_to_roman' or 'roman_to_int'\n    Limitations: 1 <= num <= 1000 for integers and valid roman numerals\n\n    Examples:\n    >>> convert_number(19, 'int_to_roman') == 'xix'\n    >>> convert_number(152, 'int_to_roman') == 'clii'\n    >>> convert_number('cdxxvi', 'roman_to_int') == 426\n    \"\"\"\n    # Define all unique symbols and corresponding values for roman numerals\n    VALUES = {\n      'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,\n      'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000\n    }\n    # A reversed map of above, for int to roman conversion\n    ROMANS = {v: k for k, v in reversed(sorted(VALUES.items()))}\n\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            raise ValueError(\"Input integer must be between 1 and 1000!\")\n        result = ''\n        for value, numeral in ROMANS.items():\n            count = number // value\n            result += numeral * count\n            number -= value * count\n        return result\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str) or any(i not in VALUES for i in number):\n            raise ValueError(\"Invalid Roman Numeral!\")\n        result = 0\n        i = 0\n        while i < len(number):\n            # If this is a subtractive combination, process both elements\n            if i + 1 < len(number) and number[i:i+2] in VALUES:\n                result += VALUES[number[i:i+2]]\n                i += 2\n            else:\n                # Else, process one element\n                result += VALUES[number[i]]\n                i += 1\n        if result < 1 or result > 1000:\n            raise ValueError(\"Result is out of range!\")\n        return result\n    else:\n        raise ValueError(\"Invalid conversion type!\")", "def convert_number(number, conversion_type):\n    \"\"\"\n    Converts a positive integer or Roman numeral to each other.\n    Conversion types: 'int_to_roman' or 'roman_to_int'\n    Limitations: 1 <= num <= 1000 for integers and valid Roman numerals\n\n    Examples:\n    >>> convert_number(19, 'int_to_roman') == 'xix'\n    >>> convert_number(152, 'int_to_roman') == 'clii'\n    >>> convert_number('cdxxvi', 'roman_to_int') == 426\n    \"\"\"\n    # Define all unique symbols and corresponding values for Roman numerals\n    VALUES = {\n      'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,\n      'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000\n    }\n    # A reversed map of above, for int to Roman conversion\n    ROMANS = {v: k for k, v in reversed(sorted(VALUES.items()))}\n\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            raise ValueError(\"Input integer must be between 1 and 1000!\")\n        result = ''\n        for value, numeral in ROMANS.items():\n            count = number // value\n            result += numeral * count\n            number -= value * count\n        return result\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str) or any(i not in VALUES for i in number):\n            raise ValueError(\"Invalid Roman Numeral!\")\n        result = 0\n        i = 0\n        while i < len(number):\n            # If this is a subtractive combination, process both elements\n            if i + 1 < len(number) and number[i:i+2] in VALUES:\n                result += VALUES[number[i:i+2]]\n                i += 2\n            else:\n                # Else, process one element\n                result += VALUES[number[i]]\n                i += 1\n        if result < 1 or result > 1000:\n            raise ValueError(\"Result is out of range!\")\n        return result\n    else:\n        raise ValueError(\"Invalid conversion type!\")", "def int_to_mini_roman(number):\n    # Map of integers to their corresponding roman numerals\n    int_to_roman_map = [(1000, 'm'), (900, 'cm'), (500, 'd'), (400, 'cd'),\n                        (100, 'c'), (90, 'xc'), (50, 'l'), (40, 'xl'),\n                        (10, 'x'), (9, 'ix'), (5, 'v'), (4, 'iv'), (1, 'i')]\n\n    roman_numeral = ''\n    for i, numeral in int_to_roman_map:\n        while number >= i:\n            roman_numeral += numeral\n            number -= i\n    return roman_numeral", "def int_to_mini_roman(number):\n    mapping = [(1000, \"m\"), (900, \"cm\"), (500, \"d\"), (400, \"cd\"),\n               (100, \"c\"), (90, \"xc\"), (50, \"l\"), (40, \"xl\"),\n               (10, \"x\"), (9, \"ix\"), (5, \"v\"), (4, \"iv\"), (1, \"i\")]\n    result = \"\"\n    for arabic, roman in mapping:\n        while number >= arabic:\n            result += roman\n            number -= arabic\n    return result"]}
{"task_id": "HumanEval/157", "problem": ["def pythagorean_check_and_area(a, b, c):\n    # Sort the sides to make sure c is the longest side (hypotenuse)\n    sides = sorted([a, b, c])\n    \n    # Check right angled triangle condition\n    if sides[0]**2 + sides[1]**2 == sides[2]**2:\n        print(\"It's a right-angled triangle.\")\n        \n        # Area calculation for right angled triangle: 1/2 * base * height\n        area = 0.5 * sides[0] * sides[1]\n        print(\"Area of the triangle is\", area, \"square units.\")\n        \n    else:\n        print(\"It's not a right-angled triangle.\")", "def triangleType(a, b, c):\n  # First, let's check if the sides form a valid triangle\n  if (a + b <= c) or (a + c <= b) or (b + c <= a):\n    return \"Not a valid triangle\"\n\n  # Next, we'll check if all sides are equal, indicating an equilateral triangle\n  if a == b and b == c:\n    return \"Equilateral triangle\"\n\n  # If all sides are different lengths, it's a scalene triangle\n  if (a != b) and (b != c) and (a != c):\n    return \"Scalene triangle\"\n\n  # If it's not equilateral or scalene, it must be an isosceles triangle\n  return \"Isosceles triangle\"", "def compute_triangle_area(a, b, c):\n    # Check if sides are integers\n    if not isinstance(a, int) or not isinstance(b, int) or not isinstance(c, int):\n        raise InvalidTriangleError(\"Invalid triangle: the given sides are not integers.\")\n    \n    # Check if the given sides can form a triangle\n    if a + b <= c or b + c <= a or a + c <= b:\n        raise InvalidTriangleError(\"Invalid triangle: the given sides cannot form a triangle.\")\n    \n    # Compute the area using Heron's formula\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return area", "def triangle_properties(a, b, c):\n    # check if the sides can form a triangle\n    assert a + b > c and a + c > b and b + c > a, \"These sides do not form a triangle\"\n\n    # calculate the perimeter\n    perimeter = a + b + c \n\n    # calculate the semi-perimeter\n    s = perimeter / 2 \n\n    # calculate the area using Heron's formula\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c)) \n\n    # classifying the triangle based on its side lengths\n    if a == b == c:\n        shape = 'equilateral'\n    elif a == b or a == c or b == c:\n        shape = 'isosceles'\n    else:\n        shape = 'scalene'\n\n    # classifying the triangle based on its angles\n    sides = sorted([a, b, c]) \n    if sides[2]**2 > sides[0]**2 + sides[1]**2:\n        angle = 'obtuse-angled'\n    elif sides[2]**2 == sides[0]**2 + sides[1]**2:\n        angle = 'right-angled'\n    else:\n        angle = 'acute-angled'\n\n    return (perimeter, area, f'{shape}, {angle}')", "def triangle_area(side1, side2=None, side3=None):\n    \"\"\"\n    Given the sides of the triangle, compute the triangle's area.\n    For triangle_area(a) => a is the side of an equilateral triangle\n    For triangle_area(a, h) => a is the base and h is the height of isosceles triangle\n    For triangle_area(a, b, c) => a, b, c are the sides of the scalene triangle\n    \"\"\"\n    if side2 == None and side3 == None:\n        # equilateral triangle\n        # area = (sqrt(3)/4) * a^2\n        area = (math.sqrt(3) / 4) * pow(side1, 2)\n    elif side3 == None:\n        # isosceles triangle\n        # area = 1/2 * base * height\n        area = 0.5 * side1 * side2\n    else:\n        # scalene triangle\n        # from the sides, get the semi-perimeter (s = (a+b+c)/2)\n        # then plug it in Heron's formula: area = sqrt(s*(s-a)*(s-b)*(s-c))\n        # which gives the formula for the area of a triangle from its sides\n        semi_perimeter = (side1 + side2 + side3) / 2\n        area = math.sqrt(semi_perimeter * (semi_perimeter-side1) * (semi_perimeter-side2) * (semi_perimeter-side3))\n    \n    return area"]}
{"task_id": "HumanEval/158", "problem": ["def find_max(words, case_sensitive=False):\n    \"\"\"\n    This function accepts a list of distinct strings as input.\n    It outputs the word that contains the greatest number of unique characters.\n    In the event of a tie, the function will return the word that comes first lexicographically.\n    If case_sensitive is set to True, the function will treat different character cases as unique.\n    If the words list is empty, it raises a ValueError.\n\n    >>> find_max([\"name\", \"of\", \"String\"], True)\n    \"String\"\n    >>> find_max([\"name\", \"enam\", \"Game\"])\n    \"enam\"\n    >>> find_max([\"aaaaaaa\", \"BB\" ,\"cc\"])\n    \"aaaaaaa\"\n    >>> find_max([])\n    ValueError: 'words' list can't be empty\n    \"\"\"\n    if not words:\n        raise ValueError(\"'words' list can't be empty\")\n    max_count, max_word = 0, \"\"\n    for word in words:\n        unique_chars = set(word.lower()) if not case_sensitive else set(word)\n        if len(unique_chars) > max_count or (len(unique_chars) == max_count and word < max_word):\n            max_count = len(unique_chars)\n            max_word = word\n    return max_word", "def find_max(words, case_sensitive=False):\n    \"\"\"This function accepts a list of distinct strings as an input. \n    It returns the string with the greatest number of unique characters. \n    If there is a tie, it provides the first word in lexicographical order. \n    Character cases are considered separate only if the parameter case_sensitive is set to True.\n\n    >>> find_max([\"name\", \"of\", \"String\"], True)\n    \"String\"\n    >>> find_max([\"name\", \"enam\", \"Game\"])\n    \"enam\"\n    >>> find_max([\"aaaaaaa\", \"BB\" ,\"cc\"])\n    \"aaaaaaa\"\n    \"\"\"\n    # Error handling for bad input types\n    if not isinstance(words, list) or not all(isinstance(i, str) for i in words):\n        raise ValueError('Invalid input type. Please enter a list of strings')\n\n    # If case_sensitive is False, convert all words to lowercase. \n    words_lower  = [word.lower() for word in words] if not case_sensitive else words\n\n    # Loop through the words and find the word with the most unique characters.\n    # In case of tie, return the word that comes first lexicographically.\n    max_unique_chars = 0\n    max_word = ''\n    for word in words_lower:\n        num_unique_chars = len(set(word))\n        if num_unique_chars > max_unique_chars:\n            max_unique_chars = num_unique_chars\n            max_word = word\n        elif num_unique_chars == max_unique_chars:\n            max_word = min(word, max_word)\n    return max_word", "def find_max(words, case_sensitive=False):\n    \"\"\"\n    This function accepts a list of distinct strings as an input, \n    It returns the string with the greatest number of unique characters.\n    If there is a tie, it provides the first word in lexicographical order. \n    Character cases are considered separate only if the parameter case_sensitive is set to True.\n\n    >>> find_max([\"name\", \"of\", \"string\"], True)\n    'string'\n    >>> find_max([\"name\", \"enam\", \"game\"])\n    'enam'\n    >>> find_max([\"aaaaaaa\", \"b13\" ,\"cc\"])\n    'aaaaaaa'\n    \"\"\"\n    \n    # Error handling for bad input types\n    if not isinstance(words, list) or not all(isinstance(w, str) for w in words):\n        raise ValueError('Invalid input type. Please enter a list of strings')\n\n    # If case_sensitive is False, convert all words to lowercase. \n    words_lower  = [word.lower() for word in words] if not case_sensitive else words\n    \n    # Loop through the words and find the word with the most unique characters.\n    # In case of tie, return the word that comes first lexicographically.\n    max_unique_chars = 0\n    max_word = ''\n    for word in words_lower:\n        num_unique_chars = len(set(word))\n        if num_unique_chars > max_unique_chars:\n            max_unique_chars = num_unique_chars\n            max_word = word\n        elif num_unique_chars == max_unique_chars:\n            max_word = min(word, max_word)\n    return max_word", "def find_max(words, case_sensitive=False):\n    \"\"\"This function accepts a list of unique strings as its primary input.\n    Its output is the word with the greatest count of distinguished characters.\n    In the event of a tie, yield the word that appears first lexicographically.\n    If case_sensitive is specified as True, cases of characters are deemed distinct.\n    \"\"\"\n    if not case_sensitive:\n        # convert all words to lower case\n        words = [word.lower() for word in words]\n    \n    # create a list of tuples, with each tuple containing a word and its corresponding\n    # count of unique characters\n    words_and_counts = [(word, len(set(word))) for word in words]\n    \n    # sort the list of tuples lexicographically and by descending order of counts\n    words_and_counts.sort(key = lambda x: (-x[1], x[0]))\n    \n    # return the word with the maximum count of unique characters, or the\n    # lexicographically first word in case of a tie\n    return words_and_counts[0][0]", "def find_max(words):\n    \"\"\" Finds the word from a list with the maximum number of unique letters\n    \n    Args:\n        words (List[str]): list of words\n\n    Returns:\n        str : the word with maximum unique letters. \n        If there are multiple such words, the one appearing first alphabetically\n\n    \"\"\"\n\n    max_word = ''\n    max_unique_chars = 0\n    \n    for word in words:\n        unique_chars = set(word.lower())\n        num_unique_chars = len(unique_chars)\n\n        if num_unique_chars == max_unique_chars:\n            if word.lower() < max_word.lower():\n                max_word = word\n        elif num_unique_chars > max_unique_chars:\n            max_word = word\n            max_unique_chars = num_unique_chars\n\n    return max_word"]}
{"task_id": "HumanEval/159", "problem": ["def validateID(number):\n  \n  if (len(number) != 10):\n    return False\n    \n  weights = [2, 4, 8, 5, 10, 9, 7, 3, 6]\n  total = 0\n\n  for i in range(len(number) - 1):\n    total += weights[i] * int(number[i])\n    \n  return True if (total % 11 == int(number[9])) else False", "def calculate_coins(amount):\n    \"\"\"\n    This function takes an amount and returns the minimum number of coins \n    required to make the amount using coins of value 1, 5, 10, and 25.\n    \"\"\"\n    coins = [25, 10, 5, 1]\n \n    result = []\n    remaining = amount\n \n    for coin in coins:\n        if remaining >= coin:\n            number_of_coins = int(remaining / coin)\n            for i in range(number_of_coins):\n                result.append(coin)\n            remaining = remaining % coin\n \n    return result", "def convert_number(number, conversion_type):\n    \n    roman_to_int_mapping = {'i': 1, \n                            'v': 5, \n                            'x': 10, \n                            'l': 50, \n                            'c': 100, \n                            'd': 500, \n                            'm': 1000}\n    \n    int_to_roman_mapping = {1: 'i', \n                            4: 'iv', \n                            5: 'v', \n                            9: 'ix', \n                            10: 'x', \n                            40: 'xl', \n                            50: 'l', \n                            90: 'xc', \n                            100: 'c', \n                            400: 'cd', \n                            500: 'd', \n                            900: 'cm', \n                            1000: 'm'}\n    \n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            raise ValueError('Invalid value. Should be an integer between 1 and 1000.')\n        num = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        res = ''\n        for i in num:\n            while number >= i:\n                res += int_to_roman_mapping[i]\n                number -= i\n        return res \n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            raise ValueError('Invalid value. Should be a valid Roman numeral.')\n        number = number.lower()    \n        res, i = 0, 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i+2] in int_to_roman_mapping.values():\n                res += roman_to_int_mapping[number[i+1]] - roman_to_int_mapping[number[i]]\n                i += 2\n            else:\n                res += roman_to_int_mapping.get(number[i], 0)\n                i += 1\n        return res\n    else:\n       raise ValueError('Invalid conversion type. Should be \"int_to_roman\" or \"roman_to_int\".')", "def convert_number(number, conversion_type):\n\n    roman_to_int_mapping = {'i': 1,  \n                            'v': 5,  \n                            'x': 10, \n                            'l': 50,  \n                            'c': 100, \n                            'd': 500, \n                            'm': 1000}\n\n    int_to_roman_mapping = {1: 'i',  \n                            4: 'iv',\n                            5: 'v', \n                            9: 'ix', \n                            10: 'x', \n                            40: 'xl', \n                            50: 'l', \n                            90: 'xc',\n                            100: 'c',  \n                            400: 'cd', \n                            500: 'd', \n                            900: 'cm', \n                            1000: 'm'}\n\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            raise ValueError('Invalid value, should be an integer between 1 and 1000.')\n        num = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        res = ''\n        for i in num:\n            while number >= i:\n                res += int_to_roman_mapping[i]\n                number -= i\n        return res \n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            raise ValueError('Invalid value. Should be a valid Roman numeral.')\n        number = number.lower()\n        res, i = 0, 0\n        while i < len(number):\n            if i+1 < len(number) and number[i:i+2] in int_to_roman_mapping.values():\n                res += roman_to_int_mapping[number[i+1]] - roman_to_int_mapping[number[i]]\n                i += 2\n            else:\n                res += roman_to_int_mapping.get(number[i], 0)\n                i += 1\n        return res\n    else:\n        raise ValueError('Invalid conversion type, Should be \"int_to_roman\" or \"roman_to_int\".')", "def convert_all_sums(n, m, start, base):\n    \"\"\"\n    You are provided two positive integers n and m (n <= m), and an additional starting number (start),\n    your task is to determine the sum of all the numbers from n through m (inclusive), starting from the 'start' number.\n    Then convert the sum into a custom base system. The custom base system will be another integer (base)\n    ranging from [2, 10] (inclusive). If n is greater than m, the start number is less than zero,\n    or the base is out of the given range, return -1. \n    \n    Example:\n    convert_all_sums(1, 5, 0, 2) => \"0b110\"\n    convert_all_sums(7, 5, 2, 2) => -1\n    convert_all_sums(10, 2, 10, 2) => \"0b10110\"\n    convert_all_sums(20, 33, 0, 2) => \"0b110101\"\n    convert_all_sums(15, 20, 10, 8) => \"0o25\"\n    \"\"\"\n    # Check for valid input\n    if n > m or start < 0 or not(2 <= base <= 10):\n        return -1\n    # Calculates the sum of the series\n    total = sum(range(n, m+1)) + start\n    # Converts the sum to the appropriate base\n    if base == 2:\n        return bin(total)\n    elif base == 8:\n        return oct(total)\n    elif base == 10:\n        return str(total)\n    else:\n        return \"Base not supported\""]}
{"task_id": "HumanEval/160", "problem": ["def do_algebra(operator, operand, round_off):\n    # mapping the arithmetic operators to their respective functions\n    operators = {'+': op.add, '-': op.sub, '*': op.mul, '//': op.floordiv, '**': op.pow}\n\n    # error handling\n    if len(operand)-len(operator)!=1:\n        raise ValueError('The number of operators must be exactly one less than the number of operands.')\n\n    # initializing the result to the first operand\n    result = operand[0]\n\n    # going through each operator\n    for idx in range(len(operator)):\n         # updating the result based on the current operator and the next operand\n        result = operators[operator[idx]](result, operand[idx+1])\n    \n    # rounding off the result if needed\n    if round_off:\n        result = round(result)\n        \n    return result", "def evaluate_expression(expression: str) -> int:\n    tokens = expression.split()  # Split the expression into tokens\n    result = int(tokens[0])  # Initialize the result with the first operand\n\n    # Iterate through the tokens in pairs (operator, operand)\n    for i in range(1, len(tokens), 2):\n        operator = tokens[i]  # Get the operator\n        operand = int(tokens[i + 1])  # Get the operand\n\n        if operator == '+':\n            result += operand  # Perform addition\n        elif operator == '-':\n            result -= operand  # Perform subtraction\n\n    return result  # Return the final result", "def calculate_expression(operations, numbers):\n    # Dictionary that maps arithmetic operations to their equivalent python operator.\n    operators_map = {'+': operator.add, \n                     '-': operator.sub, \n                     '*': operator.mul, \n                     '/': operator.truediv, \n                     '%': operator.mod }\n\n    # First operand\n    result = numbers[0]\n\n    # Loop through the list of operations\n    for i in range(1, len(numbers)):\n        if operations[i-1] in operators_map: # Check if the operation is valid.\n            op = operators_map[operations[i-1]] # Get the python operator function.\n            result = op(result, numbers[i]) # Apply the operation.\n        else:\n            raise ValueError(f\"Invalid operation '{operations[i-1]}'\") \n\n    # The function should return the final result.\n    return result", "def needs_brackets(operand, order, explicit):\n    # Define the precedence of operators based on the given order\n    precedence = {'B': 0, 'O': 1, 'D': 2, 'M': 3, 'A': 4, 'S': 5}\n\n    # Check if the operand is a single variable or a complex expression\n    if len(operand) == 1:\n        return False  # Single variable does not need brackets\n\n    # If the operand is a complex expression, determine if brackets are needed\n    stack = []\n    for token in operand:\n        if token.isalnum():  # Operand is a variable\n            stack.append(token)\n        else:  # Operand is an operator\n            while stack and precedence[stack[-1]] <= precedence[token]:\n                stack.pop()\n            stack.append(token)\n\n    # Check if brackets are needed for explicit multiplication\n    if explicit and '*' in operand:\n        return True\n\n    # If the stack is not empty, brackets are needed\n    return len(stack) > 0", "def do_calculations(operator, operand):\n    result = operand[0]\n\n    for i in range(len(operator)):\n        if operator[i] == '+':\n            result += operand[i + 1]\n        elif operator[i] == '-':\n            result -= operand[i + 1]\n        elif operator[i] == '*':\n            result *= operand[i + 1]\n        elif operator[i] == '//':\n            result //= operand[i + 1]\n        elif operator[i] == '**':\n            result **= operand[i + 1]\n        elif operator[i] == 'sin':\n            result -= math.sin(math.radians(operand[i + 1]))\n        elif operator[i] == 'cos':\n            result -= math.cos(math.radians(operand[i + 1]))\n        elif operator[i] == 'tan':\n            result -= math.tan(math.radians(operand[i + 1]))\n            \n    return result"]}
{"task_id": "HumanEval/161", "problem": ["def is_palindrome(s):\n    \"\"\"\n    Checks if the given string is a palindrome\n\n    :param s: the string to be checked\n    :returns: True if the string is a palindrome, False otherwise\n    \"\"\"\n    # remove all non-alphanumeric characters\n    s = ''.join([c for c in s if c.isalnum()])\n    # convert to lower case\n    s = s.lower()\n    # compare reversed string to the original\n    return s == s[::-1]", "def complex_sorted_list(lst, reverse=False, min_sum=0, max_sum=None, sort_function=None, secondary_sort_function=None):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter and performs the following:\n    - Delete strings with odd lengths or containing numerals.\n    - Sort the list based on the sum of the ASCII values of the characters in each string.\n    - The list may contain duplicates, ignore case, and special characters.\n    - Toggle sorting between ascending and descending order using an optional boolean `reverse` (default is False).\n    - Implement an optional minimum sum `min_sum` (default is 0) to return only strings with a sum greater or equal.\n    - Implement an optional maximum sum `max_sum` to return only strings with a sum less than or equal.\n    - Implement an optional custom sorting method `sort_function` to sort strings using a custom function.\n    - Implement an optional secondary custom sorting method `secondary_sort_function` to sort strings using a secondary function.\n    \n    E.g.:\n    assert complex_sorted_list([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert complex_sorted_list([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    assert complex_sorted_list([\"ab\", \"a\", \"aaa\", \"cd\"], True) => [\"cd\", \"ab\"]\n    assert complex_sorted_list([\"ab\", \"a\", \"aaa\", \"cd\"], min_sum=200) => [\"cd\"]\n    \"\"\"\n    \n    # Remove strings with odd lengths and strings containing numerals\n    clean_lst = [s for s in lst if len(s) % 2 == 0 and not any(c.isdigit() for c in s)]\n    \n    if not sort_function:\n        sort_function = lambda s: sum(ord(c) for c in s)\n    \n    if secondary_sort_function:\n        clean_lst.sort(key=secondary_sort_function)\n    \n    # Sort strings based on the sort_function\n    clean_lst.sort(key=sort_function, reverse=reverse)\n    \n    # Filter strings based on min_sum and max_sum\n    filtered_lst = [s for s in clean_lst if min_sum <= sort_function(s) <= (max_sum if max_sum else float(\"inf\"))]\n    \n    return filtered_lst", "def classify_string(s):\n    # Remove spaces and punctuation marks from the string\n    modified_string = ''.join(c for c in s if c not in string.punctuation and c != ' ')\n\n    # Check if the modified string is a palindrome\n    if modified_string.lower() == modified_string.lower()[::-1]:\n        return \"Palindrome\"\n    \n    # Check if the modified string contains only alphabets\n    if modified_string.isalpha():\n        return \"Word\"\n    \n    # Otherwise, classify it as a phrase\n    return \"Phrase\"", "def format_sentence(s):\n    # Base case: if the string is empty, return an empty string\n    if not s:\n        return \"\"\n\n    # Recursive case: process the string\n    first_char = s[0]\n\n    # If the first character is a period, replace it with an exclamation point\n    if first_char == \".\":\n        first_char = \"!\"\n\n    # If the first character is an exclamation point, replace it with a question mark\n    elif first_char == \"!\":\n        first_char = \"?\"\n\n    # If the first character is a question mark, replace it with a period\n    elif first_char == \"?\":\n        first_char = \".\"\n\n    # If the first character is a letter and the previous character is a punctuation mark,\n    # capitalize the letter\n    elif first_char.isalpha() and (not s[1:] or s[1].isspace()):\n        first_char = first_char.upper()\n\n    # Recursively process the remaining string\n    return first_char + format_sentence(s[1:])", "def subset_sum(s, C):\n    \"\"\"\n    Design a program using a greedy algorithm to solve the subset sum problem.\n    \n    Parameters:\n    s (list): set of integers\n    C (int): target sum\n\n    Returns:\n    boolean: True if the sum is equal to C, False otherwise\n    \"\"\"\n    s.sort(reverse=True)\n    current_sum = 0\n\n    for i in range(len(s)):\n        if s[i] + current_sum <= C:\n            current_sum += s[i]\n\n    if current_sum == C:\n        return True\n    else:\n        return False"]}
{"task_id": "HumanEval/162", "problem": ["def string_to_md5(text):\n    # If 'text' is an empty string, return None\n    if text == '':\n        return None\n\n    # Create an md5 hash object\n    hash_object = hashlib.md5()\n\n    # Update the hash object with 'text', encoded into utf-8 bytes\n    hash_object.update(text.encode('utf-8'))\n\n    # Return the hexadecimal representation of the md5 hash\n    return hash_object.hexdigest()", "def hello(name=''):\n    try:\n        # Check if the variable 'name' is of type string\n        if type(name) is not str:\n            return 'The variable `name` should be a string.'\n\n        # Check if 'name' is an empty string\n        elif name.strip() == '':\n            return 'Hello!'\n\n        # If 'name' is not an empty string\n        else:\n            return 'Hello, ' + name.strip() + '!'\n    except Exception as e:\n        return str(e)", "def hello(name=''):\n    try:\n        # Check if the variable 'name' is of type string\n        if type(name) is not str:\n            return 'The variable `name` should be a string.'\n\n        # Check if 'name' is an empty string\n        elif name.strip() == '':\n            return 'Hello!'\n\n        # If 'name' is not an empty string\n        else:\n            return 'Hello, ' + name.strip() + '!'\n    except Exception as e:\n        return str(e)", "def extract_text_value(json_obj: dict) -> Union[str, None]:\n    if 'text' in json_obj and isinstance(json_obj['text'], dict):\n        return extract_text_value(json_obj['text'])\n    elif 'text' in json_obj and isinstance(json_obj['text'], str):\n        return json_obj['text']\n    else:\n        for key, value in json_obj.items():\n            if isinstance(value, dict):\n                result = extract_text_value(value)\n                if result is not None:\n                    return result\n    return None", "def longest(strings: List[str]) -> Optional[str]:\n    \"\"\" In a given list of strings, identify and return the string having the longest length. If there are several strings with the same lengths, return the one that appeared first. If the list has no elements, return None.\n\n    >>> longest([])\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n\n    if not strings: # check if the list is empty\n        return None\n\n    longest_string = strings[0]\n    for string in strings:\n        if len(string) > len(longest_string):\n            longest_string = string\n\n    return longest_string"]}
{"task_id": "HumanEval/163", "problem": ["def sum_of_even_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers: A list of integers.\n\n    Returns:\n    The sum of all even numbers in the list.\n    \n    Examples:\n    >>> sum_of_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    30\n    >>> sum_of_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_of_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)", "def main():\n    # Example array of 10 positive integers sorted in ascending order\n    my_array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    # Call the new function and print the result\n    even_sum = sum_even_numbers(my_array)\n    print(\"Sum of even numbers in array:\", even_sum)", "def sum_even_numbers(numbers):\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The sum of all even numbers in the list.\n\n    Examples:\n    >>> sum_even_numbers([1, 2, 3, 4, 5, 6])\n    12\n    >>> sum_even_numbers([10, 11, 12, 13, 14, 15])\n    36\n    >>> sum_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)", "def sort_and_transform_even_indices(l: list) -> list:\n    \"\"\"\n    This function accepts a list l and generates a new list l'. This new list preserves the odd indices from l. At the even indices,\n    it creates a list from the corresponding positions in l, sorts it in ascending order, and transforms the sorted data using the square function before placing \n    them in the new list.\n\n    >>> sort_and_transform_even_indices([1, 2, 3])\n    [1, 2, 9]\n    >>> sort_and_transform_even_indices([5, 6, 3, 4, 8, 9, 2])\n    [4, 6, 9, 4, 25, 9, 64]\n    >>> sort_and_transform_even_indices([8, 7, 4, 1, 3, 6, 5])\n    [1, 7, 9, 1, 16, 6, 64]\n    \"\"\"\n\n    even_indices_list = sorted([l[i] for i in range(0, len(l), 2)])\n    return [square(even_indices_list.pop(0)) if i % 2 == 0 else l[i] for i in range(len(l))]", "def sort_and_transform_even_indices(l: list) -> list:\n    \"\"\"\n    This function accepts a list l and generates a new list l'. This new list preserves the odd indices from l. At the even indices,\n    it creates a list from the corresponding positions in l, sorts it in ascending order, and transforms the sorted data using the square function before placing \n    them in the new list.\n\n    >>> sort_and_transform_even_indices([1, 2, 3])\n    [1, 2, 9]\n    >>> sort_and_transform_even_indices([5, 6, 3, 4, 8, 9, 2])\n    [4, 6, 9, 4, 25, 9, 64]\n    >>> sort_and_transform_even_indices([8, 7, 4, 1, 3, 6, 5])\n    [1, 7, 9, 1, 16, 6, 64]\n    \"\"\"\n\n    even_indices_list = sorted([l[i] for i in range(0, len(l), 2)])\n    return [square(even_indices_list.pop(0)) if i % 2 == 0 else l[i] for i in range(len(l))]"]}
