{"task_id": 0, "content": ["def find_index_of_first_occurrence(string, character):\n    '''\n    This function will find the index of the first occurrence of a given character in a string.\n\n    Args:\n        string (str): the string to be searched\n        character (str): the character to be searched for\n\n    Returns:\n        int: the index of the first occurrence of the character\n    '''\n    return string.find(character)", "def delete_last_char(string):\n    \"\"\"Delete the last character of a given string.\n\n    Args:\n        string (str): The string to remove the last character from. \n\n    Returns:\n        str: The string with the last character removed.\n    \"\"\"\n    return string[:-1]", "def delete_last_char(string):\n    \"\"\"Delete the last character of a given string.\n\n    Args:\n        string (str): A given string\n\n    Returns:\n        string: The string with the last character removed.\n    \"\"\"\n    return string[:-1]", "def find_first_occurrence(lst, el):\n    \"\"\"\n    Function to return the index of the first occurrence of a given element.\n    \n    Args:\n        lst (list): list of integers\n        el (int): integer element\n        \n    Returns:\n        int: index of the first occurrence of el\n    \"\"\"\n    try:\n        return lst.index(el)\n    except ValueError:\n        return -1", "def generate_advanced_histogram(test):\n    \"\"\" Assume test is a string.\n    Generate a list of tuples where the first element of the tuple is character from the string. \n    The second element of the tuple is the frequency of occurrence of that character in the string.\n    Treat uppercase and lowercase letters as the same letter, and include counts for digits and punctuation. \n    \"\"\" \n\n    # Initialize an empty dictionary to keep track of character frequencies\n    histogram = {}\n\n    # Iterate over each character in the input string\n    for char in test:\n        # Convert current character to lowercase to handle the case insensitivity\n        char = char.lower()\n        \n        # If the character is already in the dictionary, increment its count\n        # Otherwise, add it to the dictionary with a count of 1\n        histogram[char] = histogram.get(char, 0) + 1 \n    \n    # Convert the histogram dictionary to a list of tuples and sort it\n    histogram_list = sorted(histogram.items(), key = lambda x: x[0])\n\n    return histogram_list"]}
{"task_id": 1, "content": ["def sort(list):\n    \"\"\"\n    This function sorts a given list in ascending order.\n\n    Parameters:\n    list (List[int, float, str]): A list of numerical or string values to be sorted. This list should contain elements of the same datatype for the function to work correctly. \n    \"\"\"\n    list.sort()", "def sort_by_word_length(word_list):\n    \"\"\"\n    Function to sort a given list of strings \n    based on the length of the words in ascending order.\n    @param word_list: list\n    @return: list\n    \"\"\"\n    return sorted(word_list, key=lambda x: len(x))", "def sort_strings(strings, descending=False):\n    \"\"\"\n    Sorts a list of strings according to their length, while also ensuring that strings with the same length are sorted\n    in alphabetical order. The function can sort the list in ascending or descending order based on user input.\n    \n    Args:\n        strings (list): A list of strings to be sorted\n        descending (bool, optional): If True, sorts the list in descending order. Defaults to False.\n    \n    Returns:\n        list: A sorted list of strings\n    \"\"\"\n    # Sort the strings by length and then by alphabetical order\n    sorted_strings = sorted(strings, key=lambda s: (len(s), s))\n    \n    # Reverse the list if descending is True\n    if descending:\n        sorted_strings.reverse()\n    \n    return sorted_strings", "def sort_strings_alphabetically(strings):\n    # The sort() method sorts the elements of a given list in a specific order - Ascending or Descending.\n    strings.sort()\n    return strings", "def sort_table(table, col=1, order='asc'):\n    '''\n    Sorts the given table by the specified column and applies a randomized row shuffling algorithm after sorting.\n    \n    Args:\n    table: A list of lists containing the table data.\n    col: The index of the column to sort the table by.\n    order: The order in which to sort the table. Can be 'asc' for ascending or 'desc' for descending.\n    \n    Returns:\n    A new list of lists containing the sorted and shuffled table data.\n    '''\n    \n    # Sort the table by the specified column\n    table.sort(key=lambda x: x[col], reverse=(order=='desc'))\n    \n    # Shuffle the rows of the table randomly\n    random.shuffle(table)\n    \n    return table"]}
{"task_id": 2, "content": ["def get_most_common_words(text):\n    \"\"\"Find the most common words in the given text.\n\n    :param text: A sentence or multiple sentences as a single string\n    :returns: A list of the most common words in the given text\n    \"\"\"\n\n    # Split the text into a list of words\n    words = text.split()\n\n    # Count the occurrences of each word\n    word_count = {}\n    for word in words:\n        word = word.lower()\n        if word in word_count:\n            word_count[word] += 1\n        else:\n            word_count[word] = 1\n\n    # Get the most common words\n    most_common_words = []\n    max_count = 0\n    for word, count in word_count.items():\n        if count > max_count:\n            most_common_words = [word]\n            max_count = count\n        elif count == max_count:\n            most_common_words.append(word)\n\n    return most_common_words", "def find_most_common(lst):\n    # Create an empty dictionary to store the count of each element\n    counts = {}\n\n    # Iterate over each element in the list\n    for elem in lst:\n        # Check if the element is already present in the dictionary\n        if elem in counts:\n            # If yes, increment its count by 1\n            counts[elem] += 1\n        else:\n            # If not, initialize its count to 1\n            counts[elem] = 1\n\n    # Initialize variables to store the most common element and its count\n    most_common = None\n    max_count = 0\n\n    # Iterate over the counts dictionary\n    for elem, count in counts.items():\n        # Check if the current element has a higher count than the previous most common element\n        if count > max_count:\n            # If yes, update the most common element and its count\n            most_common = elem\n            max_count = count\n\n    # Return the most common element\n    return most_common", "def most_common_word(string):\n    '''\n    Return the most common word in a given string\n    '''\n    # Split the string into a list of words\n    words = string.split(\" \")\n\n    # Initialize a dictionary to store the count of each word\n    counter = {}\n\n    # Iterate over the list of words\n    for word in words:\n        # Check if word is in the dictionary\n        if word in counter:\n            # Increment the count\n            counter[word] += 1\n        else:\n            # Add word to dictionary with count of 1\n            counter[word] = 1\n\n    # Find the word with the highest count\n    max_count = 0\n    max_word = None\n    for word, count in counter.items():\n        if count > max_count:\n            max_count = count\n            max_word = word\n\n    return max_word", "def most_common_words(words, n):\n  # Create a dictionary to store the word and its count\n  words_dict = {}\n\n  # Count each word in the list and store them in the dictionary\n  for word in words:\n    if word not in words_dict:\n      words_dict[word] = words.count(word)\n\n  # Sort the dictionary based on the number of occurrences\n  sorted_words_dict = sorted(words_dict.items(), key = lambda kv: kv[1], reverse=True)\n\n  # Return the top-n most common words\n  return [sorted_words_dict[i][0] for i in range(n)]", "def auto_summarizer(text):\n    # Split the sentence into a list of words.\n    words = text.split(' ')\n    \n    # Create a dictionary to store the frequency of each word.\n    word_freq = {}\n    \n    # Iterate over the words in the list.\n    for word in words:\n        # If the word is already in the dictionary, increment the count.\n        if word in word_freq:\n            word_freq[word] += 1\n        # Else, add the word to the dictionary with a count of 1.\n        else:\n            word_freq[word] = 1\n            \n    # Create a list of the most frequent words.\n    sorted_freq = sorted(word_freq.items(), key=lambda x: x[1], reverse=True)\n    most_freq_words = [word for word, _ in sorted_freq[:2]]\n    \n    # Generate the summary.\n    summary = \" \".join(most_freq_words)\n    \n    # Return the summary.\n    return summary"]}
{"task_id": 3, "content": ["def triangular_prism_volume(a, b, c, h):\n    \"\"\"Return the volume of a triangular prism.\"\"\"\n    assert a >= 0 and b >= 0 and c >= 0 and h >= 0, \"Ensure non-negative prism dimensions\"\n    assert a + b > c and b + c > a and c + a > b, \"Ensure valid triangle dimensions\"\n\n    # Calculate volume\n    v = a * b * c / (4 * math.sqrt((a + b + c) * (-a + b + c) * (a - b + c) * (a + b - c))) * h\n    return v", "def calculate_prism_features(prism):\n    # Check the inputs for validity.\n    if not all(isinstance(i, (int, float)) for i in prism):\n        raise TypeError(\"Input should be an array of 3 numbers\")\n    if len(prism) != 3:\n        raise ValueError(\"Input should be an array of 3 numbers\")\n    if any(i <= 0 for i in prism):\n        raise ValueError(\"Sides of the prism should be positive non-zero numbers\")\n        \n    # Make sure inputs form a right triangle.\n    prism_sorted = sorted(prism)\n    if not math.isclose(prism_sorted[0]**2 + prism_sorted[1]**2, prism_sorted[2]**2, rel_tol=1e-5):\n        print(\"Warning: The given sides do not form a right triangle\")\n    \n    # Calculate the surface area and volume.\n    base, height, hypotenuse = prism_sorted\n    area = 1/2 * base * height\n    surface_area = hypotenuse * height + 2 * area\n    volume = area * hypotenuse\n    \n    return surface_area, volume", "def calculate_volume(length, breadth, height):\n    # calculate the volume of the right rectangular prism\n    volume = length * breadth * height\n    return volume", "def inject_payload(pid, payload):\n    # This function would need to be implemented to attach to the process,\n    # find the system call table, and modify it to point to the custom handler.\n    # This is a complex task that typically requires kernel-level access and\n    # is beyond the scope of a simple Python script.\n    pass", "def recip_vol(volume):\n    \"\"\"\n    Calculates the reciprocal of the volume of a geometric shape.\n\n    Args:\n    volume: Positive real number representing the volume of a geometric shape.\n\n    Returns:\n    The reciprocal of the volume.\n    \"\"\"\n    reciprocal = 1 / volume\n    return reciprocal"]}
{"task_id": 4, "content": ["def next_greatest_letter(letters, target):\n    # checking if letters is a list and not empty\n    if not isinstance(letters, list) or not letters:\n        raise ValueError(\"Invalid input. Input letters should be a non-empty list.\")\n  \n    # checking if target is a single character and lowercase\n    if not isinstance(target, str) or len(target) != 1 or not target.islower():\n        raise ValueError(\"Invalid input. Target should be a lowercase letter.\")\n  \n    # checking if all elements in list are single character and lowercase\n    if not all(isinstance(e, str) and len(e) == 1 and e.islower() for e in letters):\n        raise ValueError(\"Invalid input. List should only contain lowercase letters.\")\n  \n    # checking if list contains at least 2 unique elements\n    if len(set(letters)) < 2:\n        raise ValueError(\"Invalid input. List should contain at least 2 unique letters.\")\n\n    pos = bisect.bisect(letters, target)\n    # If letter is found return the letter. if not found, return the first letter\n    return letters[pos % len(letters)]", "def count_distinct_lowercase_letters(string):\n    # Create a set to store distinct lowercase letters\n    distinct_letters = set()\n\n    # Iterate through each character in the string\n    for char in string:\n        # Check if the character is a lowercase letter\n        if char.islower():\n            # Add the lowercase letter to the set\n            distinct_letters.add(char)\n\n    # Return the number of distinct lowercase letters\n    return len(distinct_letters)", "def sort_letters(string):\n    # Create an empty list to store the lowercase letters\n    letters = []\n\n    # Iterate over each character in the string\n    for char in string:\n        # Check if the character is a lowercase letter\n        if char.islower():\n            # Add the lowercase letter to the list\n            letters.append(char)\n\n    # Remove duplicate letters from the list\n    letters = list(set(letters))\n\n    # Sort the letters based on their ASCII values in ascending order\n    sorted_letters = sorted(letters, key=lambda x: ord(x))\n\n    # Create a new string with the sorted letters\n    new_string = ''.join(sorted_letters)\n\n    # Return the new string\n    return new_string", "def toLowerCase(str):\n    \"\"\"\n    Convert a given string to all lowercase letters.\n\n    :param str: The string to be converted.\n    :type str: str\n    :return: The converted string.\n    :rtype: str\n    \"\"\"\n    return str.lower()", "def next_greatest_letter(letters, target):\n    # checking if letters is a list and not empty\n    if not isinstance(letters, list) or not letters:\n        raise ValueError(\"Invalid input. Input letters should be a non-empty list.\")\n        \n    # checking if target is a single character and lower case\n    if not isinstance(target, str) or len(target) != 1 or not target.islower():\n        raise ValueError(\"Invalid input. Target should be a lowercase letter.\")\n    \n    # checking if all elements in list are single character and lowercase\n    if not all(isinstance(e, str) and len(e) == 1 and e.islower() for e in letters):\n        raise ValueError(\"Invalid input. List should only contain lowercase letters.\")\n    \n    # checking if list contains at least 2 unique elements\n    if len(set(letters)) < 2:\n        raise ValueError(\"Invalid input. List should contain at least 2 unique letters.\")\n    \n    pos = bisect.bisect(letters, target)\n    # If letter is found return the letter, if not found, return the first letter\n    return letters[pos % len(letters)]"]}
{"task_id": 5, "content": ["def find_invariant_sections(code_sections):\n    # Analyze the code sections to find invariant sections\n    # This could involve looking for patterns like repeated sequences of instructions,\n    # control flow patterns, and data manipulation patterns.\n    # For simplicity, we'll assume that this function returns a list of opcode sequences.\n    # This is a placeholder function.\n    pass", "def write_rfid_data(rfid_writer, data):\n    # This function would interface with an RFID writer to write RFID badge data.\n    # Writes the data to a blank RFID badge.\n    print(f\"Cloned RFID badge with data: {data}\")", "def generate_code():\n    '''This function will generate an 8-character string with uppercase letters, lowercase letters, and digits.'''\n    chars = string.ascii_uppercase + string.ascii_lowercase + string.digits\n    code = ''.join(random.choice(chars) for _ in range(8))\n    return code", "def convert_camelcase_to_underscore(string):\n    # Use regular expression to find uppercase letters followed by lowercase letters or digits\n    pattern = re.compile(r'(?<!^)(?=[A-Z])|(?<=[a-z])(?=[A-Z0-9])')\n    \n    # Use the pattern to split the string into a list of words\n    words = re.split(pattern, string)\n    \n    # Join the words in the list using underscore as a separator\n    underscored_string = '_'.join(words).lower()\n    \n    return underscored_string", "def find_gadgets(binary):\n    # This function would search for useful gadgets in the binary.\n    # Gadgets are small sequences of instructions ending with a 'ret' instruction.\n    # These gadgets can be used to control the execution flow.\n    pass"]}
{"task_id": 6, "content": ["def area_perimeter_circle(radius):\n    \"\"\"Function to return the area and perimeter of a circle\"\"\"\n    area = 3.14 * (radius ** 2)\n    perimeter = 2 * 3.14 * radius\n    return area, perimeter", "def proper_code(*args):\n    \"\"\"\n    Given single or multiple positive integers, check if any of them is a perfect square.\n    If at least one is a perfect square, create and test a function that returns the number of n-digit positive integers that start or end with 1.\n    Also, these numbers must be divisible by any three distinct prime numbers.\n    Return 'Not a perfect square.' if none of them is a perfect square.\n    \"\"\"\n    # Find first three prime numbers\n    primes = list(sympy.primerange(0,100))[:3]\n    for i in args:\n        if is_perfect_square(i):\n            # n is taken as the number of digits in the first perfect square found\n            n = len(str(i))\n            return num_start_end_with_1(n, primes)\n    return 'Not a perfect square.'", "def proper_code(*args):\n    \"\"\"\n    Given single or multiple positive integers, check if any of them is a perfect square. \n    If at least one is a perfect square, create and test a function that returns the number of n-digit positive integers that start or end with 1. \n    Also, these numbers must be divisible by any three distinct prime numbers. \n    Return 'Not a perfect square.' if none of them is a perfect square.\n    \"\"\"\n    # Find first three prime numbers\n    primes = list(sympy.primerange(0, 100))[:3]\n    for i in args:\n        if is_perfect_square(i):\n            # n is taken as the number of digits in the first perfect square found\n            n = len(str(i))\n            return num_start_end_with_1(n, primes)\n    return 'Not a perfect square.'", "def square(n):\n    \"\"\"Return the square of the inputted number.\n    \n    Args:\n        n (int): The integer to be squared.\n\n    Returns:\n        int: The square of the inputted integer.\n    \"\"\"\n    a = n*n\n    return a", "def square(n):\n    \"\"\"Return the square of the inputted number.\n    \n    Args:\n        n (int): The integer to be squared.\n\n    Returns:\n        int: The square of the inputted integer.\n    \"\"\"\n    a = n*n\n    return a"]}
{"task_id": 7, "content": ["def characters_appear_in_order(string1, string2):\n    # Convert both strings to lowercase for case-insensitive comparison\n    string1 = string1.lower()\n    string2 = string2.lower()\n\n    # Remove non-alphanumeric characters from both strings\n    string1 = re.sub(r'\\W+', '', string1)\n    string2 = re.sub(r'\\W+', '', string2)\n\n    # Initialize a pointer for the first string\n    i = 0\n\n    # Iterate through the characters of the second string\n    for char in string2:\n        # If the character matches the current character in the first string\n        if char == string1[i]:\n            # Move the pointer to the next character in the first string\n            i += 1\n\n            # If the pointer reaches the end of the first string\n            if i == len(string1):\n                # All characters from the first string have appeared in order and consecutively in the second string\n                return True\n\n    # If the function hasn't returned True by this point, the characters did not appear in order and consecutively\n    return False", "def consecutive_strings(string1, string2):\n    # Convert strings to lists for easier manipulation\n    list1 = list(string1)\n    list2 = list(string2)\n    \n    # Iterate through the first string\n    for i in range(len(list1)):\n        # Check if the current character in the first string is present in the second string\n        if list1[i] in list2:\n            # If found, get the index of the current character in the second string\n            index = list2.index(list1[i])\n            \n            # Check if the remaining characters in the first string are consecutively present in the second string\n            if list1[i:] == list2[index:index+len(list1[i:])]:\n                return True\n    \n    # If no match is found, return False\n    return False", "def contains_string(str1, str2):\n    \"\"\"Function to check if the first string is contained in the second string\"\"\"\n\n    # Iterate over the characters of the second string\n    for i in range(len(str2)-len(str1)+1):\n        # Check if the first string is contained in the current window of the second string\n        if str2[i:i+len(str1)] == str1:\n            return True\n    # Return false if the first string is not contained in the second string\n    return False", "def concatenate_strings(s1, s2):\n    # Create a list to store the individual characters\n    chars = []\n\n    # Add the characters from the first string to the list\n    for char in s1:\n        chars.append(char)\n\n    # Add the characters from the second string to the list\n    for char in s2:\n        chars.append(char)\n\n    # Use the join() method to concatenate the characters into a single string\n    return ''.join(chars)", "def modify_strings(first_string, second_string):\n    # remove any digits from the first string present in the second string\n    for char in second_string:\n        first_string = first_string.replace(char, '')\n    \n    # convert to list\n    str_list = list(first_string)\n\n    # sort in lexicographical order\n    str_list.sort()\n\n    # reverse the list for reverse lexicographical order\n    str_list.reverse()\n\n    # convert list to string and return\n    return \"\".join(str_list)"]}
{"task_id": 8, "content": ["def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def rolling_max(arr):\n    \"\"\"\n    This function takes an array of positive integers and\n    returns a new array where each element from index 0 to \n    n is the maximum element from the original array from\n    index 0 to n.\n\n    If there's a negative number in the array, the function returns an empty list.\n    \n    Args:\n        arr (List[int]): a list of integers.\n\n    Returns:\n        List[int]: a list of maximum numbers. \n        If input list contains negative number, an empty list is returned\n    \"\"\"\n    \n    max_num = float('-inf')\n    result = []\n    \n    for number in arr:\n        if number < 0:\n            return []\n        max_num = max(number, max_num)\n        result.append(max_num)\n        \n    return result", "def findCombinations(array, total):\n    \"\"\"\n    This function will find all possible combinations of integers in the given array that sum up to the given total.\n    Args:\n        array (list): List of integers.\n        total (int): Total to be reached with the combination of integers.\n    \n    Returns:\n        A list of lists containing the combinations of integers.\n    \"\"\"\n    combinations = []  # list to store the possible combinations\n    for i in range(1 << len(array)):  # loop through all combinations of bits\n        combination = []  # list to store the current combination\n        for j in range(len(array)):  # loop through array elements\n            if i & (1 << j):  # check if bit is set\n                combination.append(array[j])  # add array element to combination\n        if sum(combination) == total:  # check if combination sums to given total\n            combinations.append(combination)  # add combination to list of combinations\n\n    return combinations", "def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers.", "def contains_characters(url, characters):\n    '''\n    This function will determine if a given URL contains certain characters.\n    \n    Args:\n        url (str): the URL to be checked\n        characters (list): a list of characters to be searched\n\n    Returns:\n        bool: True if the URL contains any of the given characters, False otherwise\n    '''\n    for character in characters:\n        if character in url:\n            return True\n    \n    return False"]}
{"task_id": 9, "content": ["def is_multiple(n):\n    \"\"\"\n    Function to check if a given number is a multiple of 3 or 5.\n    \n    Parameters: \n    n (int): The given number to check.\n    \n    Returns: \n    bool: True if number is a multiple of 3 or 5, False otherwise.\n    \"\"\"\n    return n % 3 == 0 or n % 5 == 0", "def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True", "def check_palindrome(input_string):\n    '''This function will check if the given string is a palindrome or not.'''\n    temp_string = input_string.lower()\n    return temp_string == temp_string[::-1]", "def extract_integer(number) -> int:\n    try:\n        # Check if input is a float or integer\n        if not isinstance(number, (float, int)):\n            return 'Error: Invalid input.'\n\n        # Check if number is too large\n        if abs(number) > 1.7e308:\n            return 'Error: Number too large.'\n        \n        # Return the largest integer less than or equal to the given number\n        return int(number // 1) if number >= 0 else int(number // 1) - 1\n    \n    except TypeError:\n        return 'Error: Invalid input.'\n\n    except OverflowError:\n        return 'Error: Number too large.'", "def get_primes(numbers):\n    \"\"\"Get a list of unique prime numbers from a given list\"\"\"\n    primes = []\n    try:\n        for number in numbers:\n            if isinstance(number, int):  # Check if the value is integer\n                if number >= 0:  # Check if the value is not negative\n                    if check_prime(number) and number not in primes:  # Check if the number is prime and not already in the list\n                        primes.append(number)\n            else:\n                raise ValueError(\"The given list contains non-integer values.\")\n    except ValueError as ve:\n        print(ve)\n    return primes"]}
{"task_id": 10, "content": ["def get_multiples(arr, num):\n    '''This function takes an array and an integer, and returns a new array with integers which are multiples of the given number.'''\n    multiples = []\n    for n in arr:\n        if n % num == 0:\n            multiples.append(n)\n    return multiples", "def find_multiples(multiples, start, end):\n    # Convert string or other non-integer inputs to integers\n    try:\n        multiples = [int(x) for x in multiples]\n        start = int(start)\n        end = int(end)\n    except Exception:\n        return \"Invalid inputs. Please provide integers only.\"\n\n    # Initialize list for multiples and sum variable\n    multiples_list = []\n    multiples_sum = 0\n\n    # Find multiples in range\n    for num in range(start, end+1):\n        for m in multiples:\n            if num % m == 0:\n                multiples_list.append(num)\n                # Add unique multiples to the sum\n                multiples_sum += num\n                break  # Skip remaining multiples if a match has been found\n\n    # Return sum and list of multiples\n    return multiples_list, multiples_sum", "def even_multiples(numbers, a, b):\n    # Find distinct even numbers between a and b that are also in the number list.\n    even_numbers = list(set(n for n in numbers if n >= a and n <= b and n % 2 == 0))\n    \n    # For each of these numbers, find their multiples in the number list.\n    even_numbers.sort()\n    result = [sorted([n for n in numbers if n % num == 0]) for num in even_numbers]\n\n    return result", "def cumulative_product(n, m):\n    '''\n    The function takes n and m as parameters. \n    n: is the first number of the defined range\n    m: is the last number of the defined range\n    \n    The function returns the cumulative product of all prime numbers present between the defined range\n    '''\n    product = 1\n    for i in range(n, m+1):\n        if isprime(i):\n            product *= i\n    return product", "def sum_between_numbers(m: int, n: int) -> int:\n    \"\"\"\n    This function takes two integers, m and n, as input and returns the sum of all the numbers between them (inclusive).\n    \n    Args:\n        m (int): An integer number.\n        n (int): An integer number.\n    \n    Returns:\n        int: The sum of all the numbers between m and n (inclusive).\n    \"\"\"\n    total_sum = 0\n    for i in range(m, n+1):\n        total_sum += i\n    return total_sum"]}
{"task_id": 11, "content": ["def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def findCombinations(array, total):\n    \"\"\"\n    This function will find all possible combinations of integers in the given array that sum up to the given total.\n    Args:\n        array (list): List of integers.\n        total (int): Total to be reached with the combination of integers.\n    \n    Returns:\n        A list of lists containing the combinations of integers.\n    \"\"\"\n    combinations = []  # list to store the possible combinations\n    for i in range(1 << len(array)):  # loop through all combinations of bits\n        combination = []  # list to store the current combination\n        for j in range(len(array)):  # loop through array elements\n            if i & (1 << j):  # check if bit is set\n                combination.append(array[j])  # add array element to combination\n        if sum(combination) == total:  # check if combination sums to given total\n            combinations.append(combination)  # add combination to list of combinations\n\n    return combinations", "def find_smallest_in_arrays(arr1, arr2):\n    \"\"\"\n    Find and return the smallest elements in both arrays in O(nlog(n))\n\n    Parameters\n    ----------\n    arr1 : list\n        First array of integers\n    arr2 : list\n        Second array of integers\n\n    Returns\n    -------\n    int\n        The smallest element common to both arrays\n    \"\"\"\n    # Merge both the arrays\n    merged_arr = [*arr1, *arr2]\n    # Sort the merged array in O(nlog(n))\n    merged_arr.sort()\n\n    # Initialize first_min to the first element of sorted merged array\n    first_min = merged_arr[0]\n    # Initialize second_min to the second element of sorted merged array\n    second_min = merged_arr[1]\n\n    # Check if the first min element is in arr1 and the second min element is in arr2.\n    # If yes, return the first min element.\n    if first_min in arr1 and second_min in arr2:\n        return first_min\n    # Check if the first min element is in arr2 and the second min element is in arr1.\n    # If yes, return the first min element.\n    elif first_min in arr2 and second_min in arr1:\n        return first_min\n    # Else return the second min element\n    else:\n        return second_min", "def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers.", "def find_first_occurrence(lst, el):\n    \"\"\"\n    Function to return the index of the first occurrence of a given element.\n    \n    Args:\n        lst (list): list of integers\n        el (int): integer element\n        \n    Returns:\n        int: index of the first occurrence of el\n    \"\"\"\n    try:\n        return lst.index(el)\n    except ValueError:\n        return -1"]}
{"task_id": 12, "content": ["def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def maxNonAdjacentSum(arr):\n    \"\"\"\n    Find the maximum sum of non-adjacent elements in an array.\n\n    Parameters\n    ----------\n    arr: list\n        The list of elements to be searched\n\n    Returns\n    -------\n    result : int\n        The maximum sum of non-adjacent elements in the list specified\n    \"\"\"\n\n    if not arr:\n        return 0\n\n    max_excluding_last = 0\n    max_including_last = arr[0]\n\n    for num in arr[1:]:\n        prev_max_including_last = max_including_last\n\n        max_including_last = max_excluding_last + num\n        max_excluding_last = max(prev_max_including_last, max_excluding_last)\n\n    return max(max_including_last, max_excluding_last)", "def max_difference(arr):\n    \"\"\"\n    This function takes a list of integers and returns the maximum difference between any two elements in the list.\n    \n    Args:\n    arr: A list of integers\n    \n    Returns:\n    int: Maximum difference between any two elements in the list\n    \"\"\"\n    if len(arr) < 2:\n        return 0\n    else:\n        max_diff = max(arr) - min(arr)\n        return max_diff", "def find_max(numbers):\n    \"\"\"\n    Find the maximum value in a list of numbers.\n\n    Args:\n    numbers (list): A list of numbers.\n\n    Returns:\n    float: The maximum value in the input list.\n    \"\"\"\n    if not numbers:\n        return None\n    return max(numbers)", "def max_consecutive_sum(numbers):\n    \"\"\"\n    Finds the maximum consecutive sum of a list of numbers. \n    \n    Args:\n        numbers (list of ints): The list of numbers.\n    \n    Return:\n        int: The maximum consecutive sum.\n    \"\"\"\n\n    # Set the initial maximum sum\n    max_sum = float('-inf')\n\n    # Iterate through the numbers and find the maximum sum\n    running_sum = 0\n    for number in numbers:\n        running_sum += number\n        if running_sum > max_sum:\n            max_sum = running_sum\n        if running_sum < 0:\n            running_sum = 0\n    \n    return max_sum"]}
{"task_id": 13, "content": ["def checkBinaryPrime(bin_num):\n    # Check if input is valid binary\n    if not isValidBinary(bin_num):\n        return 'Not a valid binary number.'\n    # Convert binary to decimal\n    decimal = int(bin_num, 2) \n    # Check if converted number is prime\n    if isPrime(decimal):\n        return f'The decimal equivalent of {bin_num} is {decimal}, which is a prime number.'\n    else:\n        return f'The decimal equivalent of {bin_num} is {decimal}, which is not a prime number.'", "def binary_to_decimal(n):\n    \"\"\"\n    Converts a binary number to its decimal representation.\n    \n    Args:\n        n (str): The binary number to be converted.\n    \n    Returns:\n        int: The decimal representation of the input binary number.\n    \"\"\"\n    return int(n, 2)", "def binary_to_decimal(binary):\n    \"\"\"Function to convert binary number to decimal\"\"\"\n\n    # Validate the binary input\n    if not set(binary).issubset({'0', '1'}):\n        return 'Error: Input is not a valid binary number'\n        \n    # Initialize decimal as 0    \n    decimal = 0\n\n    # Loop over each digit in the binary string\n    for digit in binary:\n        decimal = decimal*2 + int(digit)\n\n    return decimal", "def binary_to_decimal(binary):\n    \"\"\"Function to convert binary number to decimal\"\"\"\n\n    # Validate the binary input\n    if not set(binary).issubset({'0', '1'}):\n        return 'Error: Input is not a valid binary number'\n        \n    # Initialize decimal as 0    \n    decimal = 0\n\n    # Loop over each digit in the binary string\n    for digit in binary:\n        decimal = decimal*2 + int(digit)\n\n    return decimal", "def decimal_to_binary(n):\n    \"\"\"\n    Converts a decimal number to its binary representation.\n    \n    Args:\n        n (int): The decimal number to be converted.\n    \n    Returns:\n        str: The binary representation of the input decimal number.\n    \"\"\"\n    return bin(n).replace(\"0b\", \"\")"]}
{"task_id": 14, "content": ["def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers.", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def calculate_product(array, start, end):\n    \"\"\" Determine and return the product of elements in an array between the given start and end index.\"\"\"\n    product = 1\n    for i in range(start, end + 1):\n        product *= array[i]\n    return product", "def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def findCombinations(array, total):\n    \"\"\"\n    This function will find all possible combinations of integers in the given array that sum up to the given total.\n    Args:\n        array (list): List of integers.\n        total (int): Total to be reached with the combination of integers.\n    \n    Returns:\n        A list of lists containing the combinations of integers.\n    \"\"\"\n    combinations = []  # list to store the possible combinations\n    for i in range(1 << len(array)):  # loop through all combinations of bits\n        combination = []  # list to store the current combination\n        for j in range(len(array)):  # loop through array elements\n            if i & (1 << j):  # check if bit is set\n                combination.append(array[j])  # add array element to combination\n        if sum(combination) == total:  # check if combination sums to given total\n            combinations.append(combination)  # add combination to list of combinations\n\n    return combinations"]}
{"task_id": 15, "content": ["def reverse_tuple(t):\n    # check if t is a tuple\n    if not isinstance(t, tuple):\n        raise ValueError(\"The input should be a tuple.\")\n\n    # check if all elements are integers\n    for element in t:\n        if not isinstance(element, int):\n            raise ValueError(\"All elements in the tuple should be integers.\")\n\n    # reverse the tuple\n    reversed_tuple = ()\n    for i in range(len(t)-1, -1, -1):\n        reversed_tuple += (t[i],)  # comma is used to create a single-value tuple\n\n    return reversed_tuple", "def reverse_tuple(t):\n    # check if t is a tuple\n    if not isinstance(t, tuple):\n        raise ValueError(\"The input should be a tuple.\")\n\n    # check if all elements are integers\n    for element in t:\n        if not isinstance(element, int):\n            raise ValueError(\"All elements in the tuple should be integers.\")\n\n    # reverse the tuple\n    reversed_tuple = ()\n    for i in range(len(t)-1, -1, -1):\n        reversed_tuple += (t[i],)  # comma is used to create a single-value tuple\n\n    return reversed_tuple", "def manipulate_variables(b, num_list):\n    # check if variable is a number\n    if not (isinstance(b, int) or isinstance(b, float)):\n        return \"Error: The variable is not a number.\"\n\n    # check if second argument is a list\n    if not isinstance(num_list, list):\n        return \"Error: Second argument is not a list.\"\n    \n    # check if list is empty\n    if not num_list:\n        return \"Error: The list is empty.\"\n\n    # check if all elements in the list are integers\n    if not all(isinstance(num, int) for num in num_list):\n        return \"Error: The list contains non-integer elements.\"\n    \n    # calculate the sum of elements in the list with the given variable\n    total_sum = sum(num_list) + b\n\n    return total_sum", "def stable_flight(q, w, k):\n    # Check if the list is palindromic\n    is_palindrome = q == q[::-1]\n    \n    # Check the sum of the list's elements\n    sum_check = sum(q) <= w\n    \n    # Check if every element in the list is less than or equal to k\n    element_check = all(i <= k for i in q)\n\n    # If all the conditions are met, return True. Otherwise, return False.\n    return is_palindrome and sum_check and element_check", "def revised_function(input_tuple):\n    # Checks if the tuple is None or empty \n    if not input_tuple:\n        return \"Error: input is NULL or empty.\"\n\n    # Initiating an empty list to hold string representations of the float values\n    str_list = []\n\n    # Iterate over the elements in the tuple\n    for element in input_tuple:\n        # Confirm that each element is a float. If not, return an error message.\n        if not isinstance(element, float):\n            return \"Error: all elements in the tuple should be floats.\"\n            \n        # Convert the float to a string and append to the list\n        str_list.append(str(element))\n    \n    # Join all elements in the list with a semicolon\n    result = \"; \".join(str_list)\n    \n    return result"]}
{"task_id": 16, "content": ["def generate_random_number():\n    # Create a list of all digits from 0 to 9\n    digits = list(range(10))\n    \n    # Shuffle the list\n    random.shuffle(digits)\n    \n    # Take the first 8 digits from the shuffled list\n    random_number = digits[:8]\n    \n    # Convert the list of digits to a string\n    random_number_string = ''.join(map(str, random_number))\n    \n    return random_number_string", "def encode_non_ascii(strings):\n    \"\"\"\n    Takes a list of strings and returns a new list of strings where all non-ASCII characters\n    (ASCII > 127) are replaced by their decimal Unicode equivalent, encoded by the form &#xXXXX;\n    where XXXX is the utf8 code point of the character. The function only replaces non-ASCII\n    characters that are not part of any Python reserved words. The function also excludes any\n    digit characters within the input strings from the encoding process.\n    \n    Args:\n    - strings: list of strings\n    \n    Returns:\n    - new_list: list of strings\n    \"\"\"\n    \n    # define pattern to match non-ASCII characters and digits\n    pattern = re.compile(\"[^\\x00-\\x7F]|[0-9]\")\n    \n    # define a dictionary to map non-ASCII characters to their Unicode equivalent\n    replacements = {}\n    for char in pattern.findall(\"\".join(strings)):\n        if ord(char) > 127 and char not in keyword.kwlist:\n            replacements[char] = \"&#x{:04x};\".format(ord(char))\n    \n    # iterate over strings and encode non-ASCII characters\n    new_list = []\n    for string in strings:\n        new_string = \"\"\n        for i, char in enumerate(string):\n            if char in replacements:\n                new_string += replacements[char]\n            else:\n                new_string += char\n        new_list.append(new_string)\n    \n    return new_list", "def sorted_list_sum(lst, reverse=False):\n    \"\"\"\n    This function takes as input a list of strings, removes any string that contains a numerical digit or \n    an odd number of characters, sorts remaining strings in ascending order by both length and alphabetically, \n    and then returns the sorted list.\n    \n    Achieves this by using list comprehension to filter out unwanted elements, \n    and Python's built-in sorted function to sort the list. The sorted function uses a compound sorting key \n    consisting of the length of each element and the element itself, allowing for sorting by multiple criteria.\n    \n    The ordering of the sorted list can be reversed by supplying a second argument of True.\n\n    Parameters:\n    lst (list): A list of strings to be filtered and sorted.\n    reverse (bool): Optional parameter to reverse the order of the sorted list. Defaults to False.\n\n    Returns:\n    list: The sorted list of strings.\n    \"\"\"\n    \n    # Filter out any strings containing numerical digits or with odd length\n    lst = [i for i in lst if not any(j.isdigit() for j in i) and len(i) % 2 == 0]\n    \n    # Return the list sorted by length and then alphabetically, in ascending or descending order\n    return sorted(lst, key=lambda x: (len(x), x), reverse=reverse)", "def find_palindromes(strings):\n    \"\"\"\n    Returns a list of palindromes from the input list of strings.\n\n    Args:\n    strings: A list of strings.\n\n    Returns:\n    A list of strings that are palindromes.\n    \"\"\"\n    palindromes = []\n    for string in strings:\n        # Remove spaces and convert to lowercase\n        clean_string = ''.join(e for e in string if e.isalnum()).lower()\n        if clean_string == clean_string[::-1]:  # Check if the string is a palindrome\n            palindromes.append(string)\n    return palindromes", "def convert_to_set(text_elements):\n    \"\"\"\"Converts a list of strings into a set.\n\n    Args:\n        text_elements: List of strings.\n\n    Returns:\n        A set constructed from the input list.\n    \"\"\"\n    if not isinstance(text_elements, list) or not all(isinstance(item, str) for item in text_elements):\n        raise ValueError('Invalid input! Expected a list of strings.')\n    return set(text_elements)"]}
{"task_id": 17, "content": ["def inject_payload(pid, payload):\n    # This function would need to be implemented to attach to the process,\n    # find the system call table, and modify it to point to the custom handler.\n    # This is a complex task that typically requires kernel-level access and\n    # is beyond the scope of a simple Python script.\n    pass", "def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]", "def attach_to_process(pid):\n    # This is a placeholder function. In reality, you would need to use a lower-level\n    # library or system call to perform this action, which is not exposed through\n    # the Python standard library.\n    # For example, you might use the libc library to call ptrace()\n    # This is beyond the scope of a simple Python script and would require a\n    # more complex setup and environment.\n    pass", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass", "def secure_communication():\n    # This is a placeholder function. In practice, you would use Python libraries such as PyCrypto or PyNaCl\n    # to encrypt the communication with the C2 server.\n    pass"]}
{"task_id": 18, "content": ["def count_common_elements(list1, list2):\n    \"\"\"Function to count the number of times an element of list1 appears in list2\"\"\"\n    \n    # Set the initial count\n    count = 0\n\n    # Iterate through the first list\n    for elem in list1:\n        \n        # Count the number of times the element appears in list2\n        if elem in list2:\n            count += list2.count(elem)\n\n    # Return the count\n    return count", "def find_odd_or_smallest_prime(arr):\n    frequency = {}\n\n    # Count the frequency of each number\n    for num in arr:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n\n    # Find the first number that appears an odd number of times\n    for num in arr:\n        if frequency[num] % 2 != 0:\n            return num\n\n    # Find the smallest prime number if no number appears an odd number of times\n    smallest_prime = None\n    for num in arr:\n        if is_prime(num):\n            if smallest_prime is None or num < smallest_prime:\n                smallest_prime = num\n\n    return smallest_prime", "def sorted_list_sum(lst, reverse=False):\n    \"\"\"\n    This function takes as input a list of strings, removes any string that contains a numerical digit or \n    an odd number of characters, sorts remaining strings in ascending order by both length and alphabetically, \n    and then returns the sorted list.\n    \n    Achieves this by using list comprehension to filter out unwanted elements, \n    and Python's built-in sorted function to sort the list. The sorted function uses a compound sorting key \n    consisting of the length of each element and the element itself, allowing for sorting by multiple criteria.\n    \n    The ordering of the sorted list can be reversed by supplying a second argument of True.\n\n    Parameters:\n    lst (list): A list of strings to be filtered and sorted.\n    reverse (bool): Optional parameter to reverse the order of the sorted list. Defaults to False.\n\n    Returns:\n    list: The sorted list of strings.\n    \"\"\"\n    \n    # Filter out any strings containing numerical digits or with odd length\n    lst = [i for i in lst if not any(j.isdigit() for j in i) and len(i) % 2 == 0]\n    \n    # Return the list sorted by length and then alphabetically, in ascending or descending order\n    return sorted(lst, key=lambda x: (len(x), x), reverse=reverse)", "def highest_occurring_character(string):\n    \"\"\"Find the highest occurring character in a string.\"\"\"\n\n    # Initialise a dictionary to store the number of occurrences of each character\n    char_occurrences = {}\n\n    # Store the number of occurrences of each character\n    for char in string:\n        char_occurrences[char] = char_occurrences.get(char, 0) + 1\n\n    # Find the maximum occurrence of all the characters\n    max_occurrence = 0\n    highest_occurring_char = None\n\n    # Iterate over the occurrence dictionary to find the highest occurrence\n    for char, occurrence in char_occurrences.items():\n        if occurrence > max_occurrence:\n            max_occurrence = occurrence\n            highest_occurring_char = char\n\n    return highest_occurring_char", "def analyze_letter(input_list):\n    # Create a dictionary to store the count of each element\n    elements_count = {}\n    for i in input_list:\n        if i in elements_count:\n            elements_count[i] += 1\n        else:\n            elements_count[i] = 1\n\n    # Find the element that appears most frequently\n    max_count_element = max(elements_count, key=elements_count.get)\n\n    # Generate the textual description\n    textual_description = 'In this list of letters, '\n    for i in elements_count:\n        textual_description += 'the letter ' + i + ' appears ' + str(elements_count[i]) + ' times, '\n    textual_description += 'and the most frequently occurring letter is ' + max_count_element + ', which appears ' + str(elements_count[max_count_element]) + ' times.'\n\n    return textual_description"]}
{"task_id": 19, "content": ["def find_longest_string(string, start_substring, end_substring):\n    # Convert start and end substrings to lowercase for case-insensitive comparison\n    start_substring = start_substring.lower()\n    end_substring = end_substring.lower()\n    \n    # Find the index of the starting and ending substrings in the given string\n    start_index = string.lower().find(start_substring)\n    end_index = string.lower().find(end_substring)\n    \n    # If either the starting or ending substrings are not found, return 0\n    if start_index == -1 or end_index == -1:\n        return 0\n    \n    # Extract the substring between the starting and ending substrings\n    substring_between = string[start_index+len(start_substring):end_index].strip()\n    \n    # Return the length of the extracted substring\n    return len(substring_between)", "def specific_location(string: str, substring: str, from_index: int = 0, end_index: int = None) -> int:\n    \"\"\"Count the occurrences of a character sequence within an input string, with an option to specify both the starting and ending index for the search.", "def topKFrequent(words: List[str], k: int) -> List[str]:\n    # Use Python collections.Counter to create a dictionary where keys are the words, and values are the count\n    count = collections.Counter(words)\n    # Use Python heapq to create a min heap with size k.\n    # For elements having the same count, heapify will ensure the element with smallest alphabetical order to pop first.\n    heap = [(-freq, word) for word, freq in count.items()]\n    heapq.heapify(heap)\n    \n    # Use heappop to pop elements from the heap.\n    return [heapq.heappop(heap)[1] for _ in range(k)]", "def count_number_strings(s):\n    \"\"\"Design a function named count_number_strings that takes a string as input \n    and returns the total count of substrings that contain numbers as well as special \n    characters. Ignore cases and punctuation marks.\n\n    Example:\n    >>> count_number_strings(\"Hello123\")\n    1\n    >>> count_number_strings(\"Hello World! 2020\")\n    2\n    >>> count_number_strings(\"1234 Exampl5\")\n    2\n    \"\"\"\n    # define the special characters\n    special_chars = \"!@#$%^&*()-_=+[]{}|;:,.<>?/`~\"\n\n    # Split the string into substrings\n    all_strings = s.split()\n\n    # Initialize the counter to 0\n    count = 0\n\n    # Loop through the substrings\n    for string in all_strings:\n\n        # Check if the substring contains number and special characters\n        if any(c.isdigit() for c in string) and any(c in special_chars for c in string):\n            count += 1\n\n    return count", "def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]"]}
{"task_id": 20, "content": ["def filter_numbers(numbers, func_filter):\n    \"\"\"\n    Filters a list of integers based on the given condition.\n\n    Args:\n    numbers: A list of integers to be filtered.\n    func_filter: A filtering function that accepts an integer and returns a boolean value.\n\n    Returns:\n    A new list containing only the integers that satisfy the filtering condition.\n    \"\"\"\n    filtered_numbers = [num for num in numbers if func_filter(num)]\n    return filtered_numbers", "def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers.", "def remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Facilitate the de-duplication of a sequence of integers, eliminating any references that occur more than once.\n    Retains the exact sequence of remaining integers mirroring the original provided sequence.\n    Time complexity: O(n)\n    Space complexity: O(1)\n    \"\"\"\n    write = 1\n    for read in range(1, len(numbers)):\n        if numbers[read] != numbers[read-1]:\n            numbers[write] = numbers[read]\n            write += 1\n    return numbers[:write]   # cutting the array to length 'write'", "def findCombinations(array, total):\n    \"\"\"\n    This function will find all possible combinations of integers in the given array that sum up to the given total.\n    Args:\n        array (list): List of integers.\n        total (int): Total to be reached with the combination of integers.\n    \n    Returns:\n        A list of lists containing the combinations of integers.\n    \"\"\"\n    combinations = []  # list to store the possible combinations\n    for i in range(1 << len(array)):  # loop through all combinations of bits\n        combination = []  # list to store the current combination\n        for j in range(len(array)):  # loop through array elements\n            if i & (1 << j):  # check if bit is set\n                combination.append(array[j])  # add array element to combination\n        if sum(combination) == total:  # check if combination sums to given total\n            combinations.append(combination)  # add combination to list of combinations\n\n    return combinations", "def proper_code(*args):\n    \"\"\"\n    Given single or multiple positive integers, check if any of them is a perfect square.\n    If at least one is a perfect square, create and test a function that returns the number of n-digit positive integers that start or end with 1.\n    Also, these numbers must be divisible by any three distinct prime numbers.\n    Return 'Not a perfect square.' if none of them is a perfect square.\n    \"\"\"\n    # Find first three prime numbers\n    primes = list(sympy.primerange(0,100))[:3]\n    for i in args:\n        if is_perfect_square(i):\n            # n is taken as the number of digits in the first perfect square found\n            n = len(str(i))\n            return num_start_end_with_1(n, primes)\n    return 'Not a perfect square.'"]}
{"task_id": 21, "content": ["def largest_prime_factor(n):\n    # This function finds the largest prime factor of a given number\n    lpf = 1\n    for i in range(2, n + 1):\n        if n % i == 0 and is_prime(i):\n            lpf = i\n    return lpf", "def scale(x, factor):        # Scaled function. Was just doubling before. Now multiplies by factor.\n    try:                     # Put the scaling operation in a try-except block in case of potential errors.\n        return x * factor    # Scale the function based on factor.\n    except TypeError as e:   # Catches type error. Happens when x or factor are not numbers.\n        print(\"TypeError: \", e)\n    except OverflowError as e:  # Catches overflow error. Can happen if the resulting number is too big for Python to handle.\n        print(\"OverflowError: \", e)", "def sum_primes_in_range(start, end):\n    \"\"\"\n    Function to find the sum of all prime numbers within the given range.\n    \n    Parameters: \n    start (int): The start number of the range. \n    end (int): The end number of the range.\n    \n    Returns: \n    int: The sum of all prime numbers in the given range.\n    \"\"\"\n    result = 0\n    for n in range(start, end+1):\n        if is_prime(n):\n            result += n\n    return result", "def is_multiply_prime(a):\n    \"\"\"Return if the input number is the product of five distinct prime numbers.\"\"\"\n\n    # List of factors\n    factors = []\n\n    # Factorization\n    for i in sympy.primerange(2, 5001):\n        if a % i == 0:  # if i is a factor of a\n            while a % i == 0:  # while i is still a factor of a\n                a /= i  # divide a by i to \"remove\" this factor from a\n            factors.append(i)  # it's guaranteed that i is a prime number here\n            if len(factors) > 5:  # no need to try further, a has too many different prime factors\n                return False\n\n    return len(factors) == 5", "def optimized_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of both positive and negative '_n_'. The absolute value of '_n_' should be greater than 1, and '_n_' should not itself be prime. The function should be able to handle large-scale numerical scopes and effectively identify prime factors.\"\"\"\n    n = abs(n)  # Handle negative number.\n    if n < 2:\n        return None\n    factors = prime_factors(n)\n    if len(factors) == 0:  # '_n_' itself is prime.\n        return None\n    return max(factors)"]}
{"task_id": 22, "content": ["def binary_to_decimal(binaryNum):\n    try:\n        # Use int() function in python with 2 as base argument to convert binary string into decimal.\n        # int(string, base)\n        return int(binaryNum, 2)\n    except ValueError:\n        # If binaryNum is not a valid binary number, int() function will raise a ValueError.\n        # Return error message in case of exception\n        return \"Invalid binary input\"", "def checkBinaryPrime(bin_num):\n    # Check if input is valid binary\n    if not isValidBinary(bin_num):\n        return 'Not a valid binary number.'\n    # Convert binary to decimal\n    decimal = int(bin_num, 2) \n    # Check if converted number is prime\n    if isPrime(decimal):\n        return f'The decimal equivalent of {bin_num} is {decimal}, which is a prime number.'\n    else:\n        return f'The decimal equivalent of {bin_num} is {decimal}, which is not a prime number.'", "def binary_to_decimal(binary):\n    \"\"\"Function to convert binary number to decimal\"\"\"\n\n    # Validate the binary input\n    if not set(binary).issubset({'0', '1'}):\n        return 'Error: Input is not a valid binary number'\n        \n    # Initialize decimal as 0    \n    decimal = 0\n\n    # Loop over each digit in the binary string\n    for digit in binary:\n        decimal = decimal*2 + int(digit)\n\n    return decimal", "def binary_to_decimal(binary):\n    \"\"\"Function to convert binary number to decimal\"\"\"\n\n    # Validate the binary input\n    if not set(binary).issubset({'0', '1'}):\n        return 'Error: Input is not a valid binary number'\n        \n    # Initialize decimal as 0    \n    decimal = 0\n\n    # Loop over each digit in the binary string\n    for digit in binary:\n        decimal = decimal*2 + int(digit)\n\n    return decimal", "def decimal_to_binary(decimal):\n    # Check if the input is a valid decimal number\n    try:\n        decimal = float(decimal)\n    except ValueError:\n        raise ValueError(\"Invalid decimal number\")\n\n    # Handle negative numbers separately\n    if decimal < 0:\n        decimal *= -1\n        binary = \"-\"\n\n    else:\n        binary = \"\"\n\n    # Convert the whole number part to binary\n    whole = int(decimal)\n    while whole > 0:\n        binary = str(whole % 2) + binary\n        whole = whole // 2\n\n    # If the decimal number has a fractional part, convert it to binary\n    fractional = decimal % 1\n    if fractional > 0:\n        binary += \".\"\n\n        while fractional > 0:\n            fractional *= 2\n            bit = int(fractional)\n            binary += str(bit)\n            fractional -= bit\n\n    return binary"]}
{"task_id": 23, "content": ["def count_missing_values(df):\n    \"\"\"\n    This function calculates the total number of missing values in a specific dataframe.\n\n    Parameters:\n    df (DataFrame): Dataframe to check for missing values\n\n    Returns:\n    int: total missing values in the dataframe\n    \"\"\"\n    return df.isnull().sum().sum()", "def find_missing_number(arr):\n    # Create a set to store all numbers from 1 to the last element in the array\n    # For an array of length n, the last element has a value of n\n    all_nums = set(range(1, arr[-1] + 1))\n\n    # Create a set to store all numbers present in the array\n    arr_nums = set(arr)\n\n    # Use set subtraction to find the missing number\n    missing_number = list(all_nums - arr_nums)[0]\n\n    return missing_number", "def find_common_elements(*arrays):\n    # Convert all arrays into Python's built-in Set data structure, \n    # which automatically eliminates duplicates within individual arrays\n    sets = [set(arr) for arr in arrays]\n    \n    # The Python's built-in set.intersection method can be used to find elements that \n    # exist in all sets (i.e., all arrays). It takes any number of arguments (sets), \n    # so the * operator is used to unpack list of sets as arguments.\n    common_elements = set.intersection(*sets)\n    \n    # The sorted build-in function is used to sort the resulting set of common elements \n    # in ascending order\n    return sorted(common_elements)", "def search_array(num, arr):\n    \"\"\"\n    This function searches for a number in the given array. \n    \n    Input:\n    num: The number to search for\n    arr: The array in which to search\n\n    Output: \n    returns True if the number is found. Otherwise, returns False\n    \"\"\"\n    \n    # iterate through the array\n    for i in range(0, len(arr)):\n        # if the current number equals the number being searched for, \n        # return True because we found the number\n        if arr[i] == num:\n            return True\n    \n    # after searching all elements, if we didn't find the number, return False\n    return False", "def sorted_list_sum(lst, reverse=False):\n    \"\"\"\n    This function takes as input a list of strings, removes any string that contains a numerical digit or \n    an odd number of characters, sorts remaining strings in ascending order by both length and alphabetically, \n    and then returns the sorted list.\n    \n    Achieves this by using list comprehension to filter out unwanted elements, \n    and Python's built-in sorted function to sort the list. The sorted function uses a compound sorting key \n    consisting of the length of each element and the element itself, allowing for sorting by multiple criteria.\n    \n    The ordering of the sorted list can be reversed by supplying a second argument of True.\n\n    Parameters:\n    lst (list): A list of strings to be filtered and sorted.\n    reverse (bool): Optional parameter to reverse the order of the sorted list. Defaults to False.\n\n    Returns:\n    list: The sorted list of strings.\n    \"\"\"\n    \n    # Filter out any strings containing numerical digits or with odd length\n    lst = [i for i in lst if not any(j.isdigit() for j in i) and len(i) % 2 == 0]\n    \n    # Return the list sorted by length and then alphabetically, in ascending or descending order\n    return sorted(lst, key=lambda x: (len(x), x), reverse=reverse)"]}
{"task_id": 24, "content": ["def calculate_fibonacci(n):\n    \"\"\"\n    Calculates the n-th Fibonacci number.\n    Args:\n        n: the n-th Fibonacci number.\n    Returns:\n        The Fibonacci number at a given index.\n    \"\"\"\n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    # Calculate n-th Fibonacci number\n    return calculate_fibonacci(n-1) + calculate_fibonacci(n-2)", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass", "def write_rfid_data(rfid_writer, data):\n    # This function would interface with an RFID writer to write RFID badge data.\n    # Writes the data to a blank RFID badge.\n    print(f\"Cloned RFID badge with data: {data}\")", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass", "def write_ssh_key(name, path, key_type, debug):\n    # Function to write SSH key to a file\n    pass"]}
{"task_id": 25, "content": ["def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min", "def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers.", "def sum_primes_in_range(start, end):\n    \"\"\"\n    Function to find the sum of all prime numbers within the given range.\n    \n    Parameters: \n    start (int): The start number of the range. \n    end (int): The end number of the range.\n    \n    Returns: \n    int: The sum of all prime numbers in the given range.\n    \"\"\"\n    result = 0\n    for n in range(start, end+1):\n        if is_prime(n):\n            result += n\n    return result", "def calculate_geometric_mean(num_list):\n    product = 1  # This variable will hold the multiplied result of all numbers in the num_list\n\n    for num in num_list:\n        # Multiply each number in num_list with the product\n        product *= num \n\n    # Calculate the geometric mean by taking the nth root of product\n    # where n is the number of elements in the list.\n    # The math.pow function calculates the power of a number.\n    # Since we need to calculate the nth root, the power is 1/n.\n    geometric_mean = math.pow(product, 1/len(num_list))\n\n    return geometric_mean"]}
{"task_id": 26, "content": ["def sort_desc(words):\n    '''This function will sort a given list of strings in descending order of their lengths.'''\n    words.sort(key=len, reverse=True)\n    return words", "def filter_numbers(numbers, func_filter):\n    \"\"\"\n    Filters a list of integers based on the given condition.\n\n    Args:\n    numbers: A list of integers to be filtered.\n    func_filter: A filtering function that accepts an integer and returns a boolean value.\n\n    Returns:\n    A new list containing only the integers that satisfy the filtering condition.\n    \"\"\"\n    filtered_numbers = [num for num in numbers if func_filter(num)]\n    return filtered_numbers", "def shuffle_list(strings):\n    \"\"\"This function shuffles a given list of strings.\n\n    Args:\n        strings (list): A list of strings.\n    \n    Returns:\n        list: The shuffled list of strings.\n    \"\"\"\n    shuffled_list = strings[:]\n    random.shuffle(shuffled_list)\n    return shuffled_list", "def sortByLength(strings):\n    \"\"\"Sort a list of strings according to their lengths\"\"\"\n    # Sort the list using a key function\n    return sorted(strings, key=len)", "def sort_by_word_length(word_list):\n    \"\"\"\n    Function to sort a given list of strings \n    based on the length of the words in ascending order.\n    @param word_list: list\n    @return: list\n    \"\"\"\n    return sorted(word_list, key=lambda x: len(x))"]}
{"task_id": 27, "content": ["def check_integer(number):\n    if number % 2 == 0:\n        if number % 3 == 0:\n            print(\"The given integer is even and a multiple of 3.\")\n        else:\n            print(\"The given integer is even and not a multiple of 3.\")\n    else:\n        if number % 3 == 0:\n            print(\"The given integer is odd and a multiple of 3.\")\n        else:\n            print(\"The given integer is odd and not a multiple of 3.\")", "def filter_odd(lst):\n    \"\"\"\n    Function to filter out the odd elements in a given list and return the even ones.\n\n    :param lst: A list of integers\n    :returns: A new list containing only even integers\n    \"\"\"\n    return [x for x in lst if x % 2 == 0]", "def is_even(num):\n    \"\"\"\n    This function takes an integer and checks its parity.\n    \"\"\"\n    if num % 2 == 0:\n        # if the remainder of the division by 2 is 0, the number is even\n        return True\n    else:\n        # if the remainder of the division by 2 is not 0, the number is odd\n        return False", "def group_elements(lst):\n    \"\"\"\n    This function takes a list of numbers, subgroups them by their parity \n    and calculates the sum of each subgroup.\n    \"\"\"\n    # initialize empty lists and sums for odd and even numbers\n    odd_numbers, even_numbers = [], []\n    sum_odd, sum_even = 0, 0\n\n    # iterate through the input list\n    for num in lst:\n        # check if the number is even\n        if is_even(num):\n            # if true, append the number to the list of even numbers \n            # and update the total sum of even numbers\n            even_numbers.append(num)\n            sum_even += num\n        else:\n            # if false, append the number to the list of odd numbers \n            # and update the total sum of odd numbers\n            odd_numbers.append(num)\n            sum_odd += num\n\n    # create a dictionary where the keys are tuples of the parity and its sum, \n    # and the values are lists of numbers of that parity\n    result = {('odd', sum_odd): odd_numbers, ('even', sum_even): even_numbers}\n    \n    return result", "def multiply_advanced(lst, n):\n    # Initialize the product to 1\n    # If we initialized it to 0, multiplying by any number will always result in 0.\n    prod = 1\n\n    for idx, el in enumerate(lst):\n    # The enumerate function adds a counter to the lst list and returns it. The returned object is an enumerable object.\n    # The idx variable corresponds to the index of the current item inside the loop.\n    # The el variable corresponds to the item itself.\n    # So we are looping through all elements along with their indexes.\n\n    # Check if the element is at an even index, is positive and is odd\n    # Indexes start at 0, so we check idx % 2 == 0 to see if it's an even index (since both 0 and any multiple of 2 are even),\n    # We check el > 0 to ensure the number is positive.\n    # We check el % 2 == 1 to ensure the number is odd (since any number with a remainder of 1 after division by 2 is odd).\n        if idx % 2 == 0 and el > 0 and el % 2 == 1:\n        # Multiply the product with the current number\n            prod *= el\n\n    # After the loop, our prod variable holds the product of all the numbers that met the conditions.\n    # We multiply this product by 'n' before returning it as specified by the problem.\n    return prod * n"]}
{"task_id": 28, "content": ["def check_anagram_segments(text: str) -> bool:\n    \"\"\"\n    Given an input string, the function is intended to determine whether it is possible to \n    divide the string into two or more segments that are anagrams of one another. \n\n    Anagrams are words or phrases formed by reordering the letters of a different word or phrase, \n    typically using all the original letters exactly once.\n\n    The function counts the frequency of each unique character in the string and stores it in a dictionary. \n    If all frequencies are even number then the function returns True as the string can be divided into \n    two or more segments that are anagrams of one another. \n    \n    But if there is more than one character with an odd count frequency, then the function returns False\n    as it is not possible to divide the string into segments that are anagrams of one another. \n\n    Parameters:\n    text (str): The string to check for anagram segments\n\n    Returns:\n    bool: True if the string can be divided into anagram segments, False otherwise.\n\n    Examples:\n    \n    >>> check_anagram_samples('abcdefabcdegf')\n    True\n    >>> check_anagram_samples('helloworld')\n    False\n    \"\"\"\n\n    # count the frequency of each unique character in the string\n    frequency = {}\n    for char in text:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n\n    # count characters with odd count frequency\n    count_odd = sum(1 for count in frequency.values() if count % 2)\n\n    return count_odd <= 1", "def num_common_letters(string1, string2):\n    \"\"\"\n    Finds the number of letters that are common to two given strings\n    \n    Parameters:\n    string1 (string): first string\n    string2 (string): second string\n    \n    Returns:\n    comm_letter_count (int): Number of letters that are common to two strings\n    \"\"\"\n    # Initialize the variables\n    comm_letter_count = 0\n    \n    # Iterate through the letters in the first string\n    for c1 in string1:\n        # Iterate through the letters in the second string\n        for c2 in string2:\n            # Check if the letters are the same\n            if c1 == c2:\n                comm_letter_count += 1\n    \n    return comm_letter_count", "def is_anagram(string1, string2):\n    \"\"\"\n    This function determines if two strings, string1 and string2, are anagrams of each other.\n    An anagram is a word, phrase, or name formed by rearranging the letters of another, such as cinema, formed from iceman.\n    \n    Parameters:\n    string1 (str): the first string to compare\n    string2 (str): the second string to compare\n    \n    Returns:\n    bool: True if the strings are anagrams of each other, False otherwise.\n    \"\"\"    \n    \n    # If the length of the strings are not equal, they cannot be anagrams of each other.\n    if len(string1) != len(string2):\n        return False\n    \n    # Convert the strings to lowercase\n    string1 = string1.lower()\n    string2 = string2.lower()\n\n    # Check if the strings are anagrams\n    for char in string1:\n        if char not in string2:\n            return False\n        else:\n            string2 = string2.replace(char, \"\", 1)\n    \n    # Check if there are any remaining characters left in string2\n    if len(string2) == 0:\n        return True\n    \n    return False", "def related_key_attack(round_keys1, round_keys2):\n    # The related-key attack exploits the fact that the round keys are derived from the cipher key and\n    # the fixed constant. If two cipher keys are related (e.g., one is a simple transformation of the other),\n    # the corresponding round keys will also be related. The attacker can use this relationship to deduce\n    # the original key.\n    \n    # For this simplified example, we'll assume that the related keys are simply the result of XORing\n    # one key with the other. This is a simplified version of the attack and does not represent the full complexity.\n    \n    # Assuming round_keys1 and round_keys2 are lists with a single round key each\n    related_key = round_keys1[0] ^ round_keys2[0]\n    return related_key", "def check_if_substring(string1, string2):\n    \"\"\"This function checks if a given string (string1) is a\n    substring of the other given string (string2).\n\n    Args:\n        string1 (str): The string that might be a substring of string2.\n        string2 (str): The string to check if string1 is a substring.\n\n    Returns:\n        bool: True if string1 is a substring of string2, False otherwise.\n    \"\"\"\n    if string1 in string2:\n        return True\n    else:\n        return False"]}
{"task_id": 29, "content": ["def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def frequencySort(nums):\n    # collections.Counter(nums) gives the frequency of each element in the nums array.\n    # items() function returns a view object that displays a list of a dictionary's(an iterable) tuple pair (key, value).\n    c = Counter(nums).items()\n    # Then we will sort the results by the tuple (-count, num). Negative count ensures that high frequency elements come first in the sorted list.\n    # This satisfies the requirement to sort in increasing frequency. \n    # Because we use num for sort as well, elements with the same frequency are sorted in descending order.\n    # This satisfies the requirement to sort in decreasing order on the basis of value of the numbers in case of same frequency.\n    # idx is used to sort elements in increasing order of their index in case elements are same and have same frequency.\n    # sort function of python is stable. i.e, it maintains the relative order of items with equal sort keys\n    nums.sort(key = lambda x: (nums.count(x), -x, [i for i, n in enumerate(nums) if n == x][0]))\n    # return the sorted array\n    return nums", "def sort(list):\n    \"\"\"\n    This function sorts a given list in ascending order.\n\n    Parameters:\n    list (List[int, float, str]): A list of numerical or string values to be sorted. This list should contain elements of the same datatype for the function to work correctly. \n    \"\"\"\n    list.sort()", "def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list", "def findCombinations(array, total):\n    \"\"\"\n    This function will find all possible combinations of integers in the given array that sum up to the given total.\n    Args:\n        array (list): List of integers.\n        total (int): Total to be reached with the combination of integers.\n    \n    Returns:\n        A list of lists containing the combinations of integers.\n    \"\"\"\n    combinations = []  # list to store the possible combinations\n    for i in range(1 << len(array)):  # loop through all combinations of bits\n        combination = []  # list to store the current combination\n        for j in range(len(array)):  # loop through array elements\n            if i & (1 << j):  # check if bit is set\n                combination.append(array[j])  # add array element to combination\n        if sum(combination) == total:  # check if combination sums to given total\n            combinations.append(combination)  # add combination to list of combinations\n\n    return combinations"]}
{"task_id": 30, "content": ["def sum_even_numbers(numbers: list) -> int:\n    # Filter out the odd numbers from the list using the filter function\n    even_numbers = list(filter(lambda x: x % 2 == 0, numbers))\n    \n    # Use the reduce function from the functools module to sum the even numbers\n    from functools import reduce\n    return reduce(lambda x, y: x + y, even_numbers, 0)", "def compute_sum_of_even_numbers(numbers):\n    # Filter out the even numbers from the input list using a list comprehension\n    even_numbers = [num for num in numbers if num % 2 == 0]\n    \n    # Compute the sum of the filtered even numbers using the built-in sum() function\n    sum_of_even_numbers = sum(even_numbers)\n    \n    return sum_of_even_numbers", "def find_smallest_even(numbers):\n    # Filter out even numbers\n    even_numbers = list(filter(lambda x: x % 2 == 0, numbers))\n    \n    # Check if the list of even numbers is empty\n    if not even_numbers:\n        print(\"There are no even numbers in the list.\")\n        return None\n    \n    # Return the smallest even number\n    return min(even_numbers)", "def extract_odd_elements(array, unique=False):\n    # Error handling for invalid inputs\n    if not isinstance(array, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    for element in array:\n        if not isinstance(element, int):\n            raise ValueError(\"Elements of the list must be integers.\")\n\n    # Using built-in function to filter the array\n    odd_elements = list(filter(lambda x: x%2 == 1, array))\n\n    if unique:\n        # Using built-in function to remove duplicates\n        odd_elements = list(set(odd_elements))\n    return odd_elements", "def filter_odd(lst):\n    \"\"\"\n    Function to filter out the odd elements in a given list and return the even ones.\n\n    :param lst: A list of integers\n    :returns: A new list containing only even integers\n    \"\"\"\n    return [x for x in lst if x % 2 == 0]"]}
{"task_id": 31, "content": ["def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers.", "def sum_2d_array(arr):\n    \"\"\"\n    This function calculates the sum of all elements in a 2D array.\n    \n    Parameters\n    ----------\n    arr : list\n        2D array of numbers\n    \n    Returns\n    -------\n    int\n        sum of all elements in the array\n    \"\"\"\n    # initialize the sum\n    sums = 0\n    \n    # iterate through each element in the array\n    for row in arr:\n        for val in row:\n            # add the element to the sum\n            sums += val\n    return sums", "def findCombinations(array, total):\n    \"\"\"\n    This function will find all possible combinations of integers in the given array that sum up to the given total.\n    Args:\n        array (list): List of integers.\n        total (int): Total to be reached with the combination of integers.\n    \n    Returns:\n        A list of lists containing the combinations of integers.\n    \"\"\"\n    combinations = []  # list to store the possible combinations\n    for i in range(1 << len(array)):  # loop through all combinations of bits\n        combination = []  # list to store the current combination\n        for j in range(len(array)):  # loop through array elements\n            if i & (1 << j):  # check if bit is set\n                combination.append(array[j])  # add array element to combination\n        if sum(combination) == total:  # check if combination sums to given total\n            combinations.append(combination)  # add combination to list of combinations\n\n    return combinations", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None"]}
{"task_id": 32, "content": ["def find_words_with_fr(string):\n    '''\n    This function will find all words containing the letters \"fr\" in a given string.\n    \n    Args:\n        string (str): the string to be searched\n    \n    Returns:\n        list: a list of all words containing the letters \"fr\"\n    '''\n    regex = r\"\\b\\w*fr\\w*\\b\"\n    return re.findall(regex, string)", "def find_invariant_sections(code_sections):\n    # Analyze the code sections to find invariant sections\n    # This could involve looking for patterns like repeated sequences of instructions,\n    # control flow patterns, and data manipulation patterns.\n    # For simplicity, we'll assume that this function returns a list of opcode sequences.\n    # This is a placeholder function.\n    pass", "def get_phone_number(text):\n    # regex pattern to find sequences of digits\n    pattern = r'\\d+'\n    digits = re.findall(pattern, text)\n\n    # Join all sequences together to get the whole phone number\n    phone_number = \"\".join(digits)\n\n    # Convert the string to an integer\n    phone_number = int(phone_number)\n\n    return phone_number", "def convert_camelcase_to_underscore(string):\n    # Use regular expression to find uppercase letters followed by lowercase letters or digits\n    pattern = re.compile(r'(?<!^)(?=[A-Z])|(?<=[a-z])(?=[A-Z0-9])')\n    \n    # Use the pattern to split the string into a list of words\n    words = re.split(pattern, string)\n    \n    # Join the words in the list using underscore as a separator\n    underscored_string = '_'.join(words).lower()\n    \n    return underscored_string", "def write_rfid_data(rfid_writer, data):\n    # This function would interface with an RFID writer to write RFID badge data.\n    # Writes the data to a blank RFID badge.\n    print(f\"Cloned RFID badge with data: {data}\")"]}
{"task_id": 33, "content": ["def match_hex_vowel(string):\n    # The regexp starts with \\b to match the start of a word\n    # Following that, [0-9A-Fa-f]+ matches one or more hexadecimal digits\n    # After that, [aeiou] matches a single lowercase English vowel\n    # Finally, \\b matches the end of a word to avoid partial word matches \n    pattern = r'\\b[0-9A-Fa-f]+[aeiou]\\b'\n    return re.match(pattern, string) is not None", "def match_hex_vowel(string):\n    # The regexp starts with \\b to match the start of a word\n    # Following that, [0-9A-Fa-f]+ matches one or more hexadecimal digits\n    # After that, [aeiou] matches a single lowercase English vowel\n    # Finally, \\b matches the end of a word to avoid partial word matches \n    pattern = r'\\b[0-9A-Fa-f]+[aeiou]\\b'\n    return re.match(pattern, string) is not None", "def anti_shuffle(s):\n    \"\"\"\n    Function that accepts a string and produces an ordered variant using the custom_sort function.\n    The ordered variant of a string is a new phrase where every word (partitioned by space) \n    is replaced by a new word where every character adheres to the custom_sort methodology.\n    The word and blank space sequence in the sentence remains unchanged.\n\n    Args: \n        s: string\n\n    Returns:\n        The modified string with each word sorted according to the rules of custom_sort\n    \"\"\"\n    \n    sorted_words = [custom_sort(word) for word in s.split(\" \")]\n    return ' '.join(sorted_words)", "def anti_shuffle(s):\n    \"\"\"\n    Function that accepts a string and produces an ordered variant using the custom sort function.\n    The ordered variant of a string is a new phrase where every word (partitioned by space)\n    is replaced by a new word where every character adheres to the custom sort methodology.\n    The word and blank space sequence in the sentence remains unchanged.\n\n    Args:\n    s: String\n\n    Returns:\n    The modified string with each word sorted according to the rules of custom_sort\n    \"\"\"\n\n    sorted_words = [custom_sort(word) for word in s.split(\" \")]\n    return ' '.join(sorted_words)", "def get_last_vowel_flanked_consonant(word):\n    \"\"\"Given a word, find the last consonant that is surrounded by vowels from the right side of the word (case sensitive). Do not include consonants at the beginning or end of the word. Return an empty string if no such consonant is found. Assume the input string contains only English letters.\"\"\"\n\n    vowels = set('aeiouAEIOU')\n    \n    for i in range(len(word) - 2, 0, -1):\n        if word[i] not in vowels and word[i-1] in vowels and word[i+1] in vowels:\n            return word[i]\n    return \"\""]}
{"task_id": 34, "content": ["def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def reverse_array(arr):\n    \"\"\"This function reverses the elements of a given array of numbers\n    \n    Parameters: \n        arr (list): The list of numbers to reverse.\n\t\n    Returns: The reversed array\n    \"\"\"\n    return arr[::-1]", "def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers.", "def findCombinations(array, total):\n    \"\"\"\n    This function will find all possible combinations of integers in the given array that sum up to the given total.\n    Args:\n        array (list): List of integers.\n        total (int): Total to be reached with the combination of integers.\n    \n    Returns:\n        A list of lists containing the combinations of integers.\n    \"\"\"\n    combinations = []  # list to store the possible combinations\n    for i in range(1 << len(array)):  # loop through all combinations of bits\n        combination = []  # list to store the current combination\n        for j in range(len(array)):  # loop through array elements\n            if i & (1 << j):  # check if bit is set\n                combination.append(array[j])  # add array element to combination\n        if sum(combination) == total:  # check if combination sums to given total\n            combinations.append(combination)  # add combination to list of combinations\n\n    return combinations", "def apply_function(arr, f):\n    \"\"\"\n    Apply a given function to each item of an input array.\n    \n    Args:\n        arr (list): The input array.\n        f (function): The function to be applied.\n        \n    Returns:\n        list: A list with the result of applying function f to each item of arr.\n    \"\"\"\n    return list(map(f, arr))"]}
{"task_id": 35, "content": ["def check_anagram_segments(text: str) -> bool:\n    \"\"\"\n    Given an input string, the function is intended to determine whether it is possible to \n    divide the string into two or more segments that are anagrams of one another. \n\n    Anagrams are words or phrases formed by reordering the letters of a different word or phrase, \n    typically using all the original letters exactly once.\n\n    The function counts the frequency of each unique character in the string and stores it in a dictionary. \n    If all frequencies are even number then the function returns True as the string can be divided into \n    two or more segments that are anagrams of one another. \n    \n    But if there is more than one character with an odd count frequency, then the function returns False\n    as it is not possible to divide the string into segments that are anagrams of one another. \n\n    Parameters:\n    text (str): The string to check for anagram segments\n\n    Returns:\n    bool: True if the string can be divided into anagram segments, False otherwise.\n\n    Examples:\n    \n    >>> check_anagram_samples('abcdefabcdegf')\n    True\n    >>> check_anagram_samples('helloworld')\n    False\n    \"\"\"\n\n    # count the frequency of each unique character in the string\n    frequency = {}\n    for char in text:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n\n    # count characters with odd count frequency\n    count_odd = sum(1 for count in frequency.values() if count % 2)\n\n    return count_odd <= 1", "def verify_divisibility_and_evenness(numbers, divisor):\n    ''' \n    This function accepts a list of numbers and a divisor then \n    verifies whether each number in the list is divisible by the divisor \n    and is even.\n\n    It returns a list of tuples, with each tuple containing a number \n    and a boolean value indicating whether that number satisfies the conditions\n    \n    @param numbers: List of numbers to be checked\n    @param divisor: The divisor to check divisibility\n    '''\n\n    # Validate inputs\n    if not isinstance(numbers, list) or not isinstance(divisor, int):\n        raise ValueError(\"Invalid Input. Only list of numbers and integer divisor are allowed\")\n    \n    return [ (num, num % divisor == 0 and num % 2 == 0) for num in numbers]", "def verify_divisibility_and_evenness(numbers, divisor):\n    ''' \n    This function accepts a list of numbers and a divisor then \n    verifies whether each number in the list is divisible by the divisor \n    and is even.\n\n    It returns a list of tuples, with each tuple containing a number \n    and a boolean value indicating whether that number satisfies the conditions\n    \n    @param numbers: List of numbers to be checked\n    @param divisor: The divisor to check divisibility\n    '''\n\n    # Validate inputs\n    if not isinstance(numbers, list) or not isinstance(divisor, int):\n        raise ValueError(\"Invalid Input. Only list of numbers and integer divisor are allowed\")\n    \n    return [ (num, num % divisor == 0 and num % 2 == 0) for num in numbers]", "def loadmat(filename):\n    '''\n    this function should be called instead of direct spio.loadmat\n    as it cures the problem of not properly recovering python dictionaries\n    from mat files. It calls the function check keys to cure all entries\n    which are still mat-objects\n    '''\n    data = spio.loadmat(filename, struct_as_record=False, squeeze_me=True)\n    return _check_keys(data)", "def is_anagram(string1, string2):\n    \"\"\"\n    This function determines if two strings, string1 and string2, are anagrams of each other.\n    An anagram is a word, phrase, or name formed by rearranging the letters of another, such as cinema, formed from iceman.\n    \n    Parameters:\n    string1 (str): the first string to compare\n    string2 (str): the second string to compare\n    \n    Returns:\n    bool: True if the strings are anagrams of each other, False otherwise.\n    \"\"\"    \n    \n    # If the length of the strings are not equal, they cannot be anagrams of each other.\n    if len(string1) != len(string2):\n        return False\n    \n    # Convert the strings to lowercase\n    string1 = string1.lower()\n    string2 = string2.lower()\n\n    # Check if the strings are anagrams\n    for char in string1:\n        if char not in string2:\n            return False\n        else:\n            string2 = string2.replace(char, \"\", 1)\n    \n    # Check if there are any remaining characters left in string2\n    if len(string2) == 0:\n        return True\n    \n    return False"]}
{"task_id": 36, "content": ["def calculate_factorial_of_digits(num):\n    # Convert the number to string to iterate through the digits\n    num_string = str(num)\n\n    # Iterate through the digits of the number\n    for digit in num_string:\n        # Calculate the factorial of the digit using math.factorial function\n        factorial = math.factorial(int(digit))\n        \n        print('Factorial of {} is {}'.format(digit, factorial))", "def count_trailing_zeroes(num):\n    # Calculate the factorial of the given number\n    fact = factorial(num)\n    \n    # Initialize a variable to count the trailing zeroes\n    count = 0\n    \n    # Keep dividing the factorial by 10 and increment the count until the last digit is not 0\n    while fact % 10 == 0:\n        count += 1\n        fact //= 10\n    \n    return count", "def factorial(n):\n    \"\"\"Recursive function to calculate the factorial of a given positive integer.\"\"\"\n    \n    # Check if the input is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        raise InvalidInputError(\"Input must be a positive integer.\")\n\n    # Base case: factorial of 0 is 1\n    if n == 0:\n        return 1\n    \n    # Recursive case: multiply n by factorial of (n-1)\n    return n * factorial(n-1)", "def factorial(num):\n    '''\n    Function to calculate the factorial of a number\n    input: number\n    output: factorial of that number\n    '''\n    if num == 0:\n        return 1\n    else:\n        return num * factorial(num - 1)", "def factorial(num):\n    \"\"\"\n    This function takes a non-negative integer and calculates its factorial.\n    Factorial of a number is the product of all positive integers less than or equal to it.\n    \"\"\"\n    if num < 0: \n        return \"Invalid input! Please enter a non-negative integer.\"\n    elif num == 0 or num == 1: \n        return 1\n    else: \n        return num * factorial(num - 1)"]}
{"task_id": 37, "content": ["def hamming_weight(byte):\n    # Implement this function to calculate the Hamming weight of a byte.\n    # The Hamming weight is the number of 1's in the byte.\n    # This can be done using a bitwise operation that counts the number of bits set to 1.\n    return bin(byte).count('1')", "def add_digits(number):\n    \"\"\"This function adds all the digits of a given number \n    and returns the result.\n    \n    Args:\n        number (int): The number to process.\n    \n    Returns:\n        int: The result of adding all the digits of the given number.\n    \"\"\"\n    if number < 10:\n        return number\n    total = number % 10 + add_digits(number // 10)\n    return total", "def check_integer(number):\n    if number % 2 == 0:\n        if number % 3 == 0:\n            print(\"The given integer is even and a multiple of 3.\")\n        else:\n            print(\"The given integer is even and not a multiple of 3.\")\n    else:\n        if number % 3 == 0:\n            print(\"The given integer is odd and a multiple of 3.\")\n        else:\n            print(\"The given integer is odd and not a multiple of 3.\")", "def calculate_parity(n):\n    # Count the number of set bits using bitwise AND and right shift\n    count = 0\n    while n:\n        count ^= n & 1\n        n >>= 1\n\n    # Return 1 if the number of set bits is odd, 0 otherwise\n    return count", "def find_common_elements(*arrays):\n    # Convert all arrays into Python's built-in Set data structure, \n    # which automatically eliminates duplicates within individual arrays\n    sets = [set(arr) for arr in arrays]\n    \n    # The Python's built-in set.intersection method can be used to find elements that \n    # exist in all sets (i.e., all arrays). It takes any number of arguments (sets), \n    # so the * operator is used to unpack list of sets as arguments.\n    common_elements = set.intersection(*sets)\n    \n    # The sorted build-in function is used to sort the resulting set of common elements \n    # in ascending order\n    return sorted(common_elements)"]}
{"task_id": 38, "content": ["def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list", "def delete_element(my_list, pos):\n    \"\"\"Function to delete an element from a given list at a given position.\"\"\"\n    del my_list[pos]\n    return my_list", "def remove_elem(string, elem):\n    \"\"\"\n    This function removes a specified element from the given string of words.\n    \n    Parameters:\n    string (str): The input string containing words.\n    elem (str): The element to be removed from the string.\n    \n    Returns:\n    str: The updated string without the specified element.\n    \"\"\"\n    return ' '.join([word for word in string.split() if word != elem])", "def extract_values(element):\n    \"\"\"\n    Function to extract values from an element which could be dictionary, list or a single value\n    \"\"\"\n\n    # Create an empty list to store values\n    values = []\n\n    # Case if the element is a list\n    if isinstance(element, list):\n        for item in element:\n            # Recursion to handle nested lists or dictionaries\n            values.extend(extract_values(item))\n\n    # Case if the element is a dictionary\n    elif isinstance(element, dict):\n        for key, value in element.items():\n            # Recursion to handle nested lists or dictionaries\n            values.extend(extract_values(value))\n\n    else:\n        # add the value to the list if it's neither dict or list\n        values.append(element)\n\n    return values", "def flatten(arr):\n    \"\"\"\n    Function to flatten a given two-dimensional array \n    \"\"\"\n    return [item for subList in arr for item in subList]"]}
{"task_id": 39, "content": ["def delete_idle_lambda(region_name):\n    \"\"\"\n    This function deletes idle AWS Lambda functions in a particular region.\n    :param region_name: str\n    :return: None\n    \"\"\"\n    # Create a session using boto3\n    session = boto3.Session(region_name=region_name)\n\n    # Connect to AWS Lambda service\n    lambda_client = session.client('lambda')\n\n    try:\n        # Get the list of all functions\n        functions = lambda_client.list_functions()\n\n        # Loop through each function\n        for function in functions['Functions']:\n            function_name = function['FunctionName']\n\n            # Here, we need to determine if the function is idle\n            # If the function is idle, we delete it\n            # Please replace `is_function_idle` with your actual check\n            if is_function_idle(function):\n                lambda_client.delete_function(FunctionName=function_name)\n                print(f\"Deleted function: {function_name}\")\n\n    except NoCredentialsError:\n        print(\"No AWS credentials were found.\")\n    except ClientError as e:\n        if e.response['Error']['Code'] == 'ResourceNotFoundException':\n            print(\"The specified lambda function does not exist.\")\n        else:\n            raise e", "def longest_increasing_subsequence(sequence):\n    \"\"\"\n    This function uses dynamic programming to find the longest increasing subsequence in the input array. \n\n    Firstly, we initialize the list length with size as input array size. Each element in length represents the longest \n    increasing subsequence in sequence[0...i]. After initializing the list length with 1, the function fills length in \n    a bottom-up manner(using dynamic programming), i.e., if sequence[j] > sequence[i] for some i < j and length[j] < length[i] + 1,\n    then update length[j].\n\n    Finally, the function returns the maximum value from the list length.\n\n    :param sequence: An input array of integers\n    :type sequence: list\n    :return: The longest increasing subsequence in the array\n    :rtype: int\n    \"\"\"\n\n    # initialize the list length with 1's because a minimum increasing subsequence would just be one number itself\n    length = [1] * len(sequence)\n\n    # loop over the sequence from the second element\n    for i in range(1, len(sequence)):\n        # consider all smaller elements found so far\n            for j in range(i):\n                # if this element is bigger, check if we can increase the length of the largest subsequence ending at i\n                if sequence[i] > sequence[j] and length[i] < length[j] + 1:\n                    length[i] = length[j] + 1\n\n    # return the maximum length found\n    return max(length)", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass", "def write_rfid_data(rfid_writer, data):\n    # This function would interface with an RFID writer to write RFID badge data.\n    # Writes the data to a blank RFID badge.\n    print(f\"Cloned RFID badge with data: {data}\")", "def pick_first_round():\n    global first_round_post_iss, rounds_avail\n    reducer = lambda x, y: x.intersection(y)  # Define a set intersection reducer function\n    first_round_post_iss = min(reduce(reducer, rounds_avail.values()))  # Find the minimum common number"]}
{"task_id": 40, "content": ["def triangleType(a, b, c):\n  # First, let's check if the sides form a valid triangle\n  if (a + b <= c) or (a + c <= b) or (b + c <= a):\n    return \"Not a valid triangle\"\n\n  # Next, we'll check if all sides are equal, indicating an equilateral triangle\n  if a == b and b == c:\n    return \"Equilateral triangle\"\n\n  # If all sides are different lengths, it's a scalene triangle\n  if (a != b) and (b != c) and (a != c):\n    return \"Scalene triangle\"\n\n  # If it's not equilateral or scalene, it must be an isosceles triangle\n  return \"Isosceles triangle\"", "def classify_triangle(a,b,c):\n    # check if sides form a triangle\n    if a+b <= c or a+c <= b or b+c <= a:\n        return 'Not a valid triangle'\n    \n    # check for equilateral triangle\n    if a == b == c:\n        return 'Equilateral triangle'\n    \n    # check for isosceles triangle\n    if a==b or a==c or b==c:\n        return 'Isosceles triangle'\n    \n    # otherwise, it is a scalene triangle\n    return 'Scalene triangle'", "def classify_triangle(a, b, c):\n    # Check for triangle inequality\n    if a + b <= c or a + c <= b or b + c <= a:\n        return 'Not a triangle'\n    \n    # Check for an equilateral triangle\n    if a == b and b == c:\n        return 'Equilateral triangle'\n        \n    # Check for an isosceles triangle\n    elif a == b or b == c or a == c:\n        return 'Isosceles triangle'\n    \n    # If none of the above checks are true, it must be a scalene triangle\n    else:\n        return 'Scalene triangle'", "def triangle_type(side1, side2, side3):\n    if side1 <= 0 or side2 <= 0 or side3 <= 0:\n        print(\"Error: Sides cannot be zero or negative.\")\n        return\n    if side1 + side2 <= side3 or side1 + side3 <= side2 or side2 + side3 <= side1:\n        print(\"Error: Invalid triangle.\")\n        return\n    if side1 == side2 == side3:\n        print(\"Equilateral triangle\")\n        return\n    if side1 == side2 or side1 == side3 or side2 == side3:\n        print(\"Isosceles triangle\")\n        return\n    print(\"Scalene triangle\")", "def validate_triangle(a, b, c):\n    # Check if values are positive\n    if a <= 0 or b <= 0 or c <= 0:\n        return \"Invalid triangle\"\n    \n    # Check if triangle can be formed\n    if a + b > c and b + c > a and a + c > b:\n        if a == b == c:\n            return \"Equilateral triangle\"\n        elif a != b != c != a:\n            return \"Scalene triangle\"\n        else:\n            return \"Isosceles triangle\"\n    else:\n        return \"Invalid triangle\""]}
{"task_id": 41, "content": ["def total_area(rectangles):\n    \"\"\"\n    Function to calculate total area for a list of rectangles.\n    \"\"\"\n    area = 0\n    for rectangle in rectangles:\n        # If rectangle is not a pair of points, raise an error.\n        if not isinstance(rectangle, tuple) or len(rectangle) != 2:\n            raise ValueError(\"Invalid rectangle data: {}. Rectangle should be a tuple of 2 points.\".format(rectangle))\n        else:\n            area += rectangular_area(*rectangle)\n    return area", "def calculate_circle_area(radius, pi=3.14):\n    \"\"\"\n    Create a function that takes two arguments and calculates the area of a circle.\n    The radius is the required argument, and the value of pi is optional (default is 3.14).\n    \"\"\"\n    area = pi * radius * radius\n    return area", "def data_exfiltration():\n    # This function represents the extraction of data from the compromised systems.\n    # In a real-world scenario, this would involve copying or transferring data to a controlled area.\n    # For ethical hacking, this step is typically performed by a third-party security professional.\n    pass", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass", "def calculate_shapes(base, height):\n    try:\n        # Check if the base and height are valid\n        if base <= 0 or height <= 0:\n            raise ValueError('The dimensions must be positive.')\n\n        # Calculate the area of the parallelogram\n        area_parallelogram = base * height\n        print(f'The area of the parallelogram is {area_parallelogram} cm\u00b2.')\n\n        # Calculate the length of the other side using Pythagoras' Theorem\n        other_side = math.sqrt(base**2 + height**2)\n        print(f'The length of the other side is {other_side} cm.')\n\n        # Calculate the length of the diagonal using Pythagoras' Theorem\n        diagonal = math.sqrt(2) * base\n        print(f'The length of the diagonal is {diagonal} cm.')\n\n        # Calculate the area of the triangle\n        area_triangle = 0.5 * base * diagonal\n        print(f'The area of the triangle is {area_triangle} cm\u00b2.')\n        \n    except ValueError as ve:\n        # Print the error message\n        print(ve)"]}
{"task_id": 42, "content": ["def is_palindrome(input_string):\n    # Base case: if the string is empty or has one character IT IS a palindrome.\n    if len(input_string) < 2:\n        return True\n  \n    # If the first and last characters are equal, we continue to check the next characters (excluding first and last)\n    # We are reducing our problem's size in a recursive way\n    if input_string[0] == input_string[-1]:\n        return is_palindrome(input_string[1:-1])\n\n    # If the first and the last character was not equal, IT IS NOT a palindrome\n    return False", "def is_palindrome_recursive(s):\n    # Base case: if the string is empty or contains only one character, it is a palindrome\n    if len(s) <= 1:\n        return True\n\n    # Convert the string to lowercase\n    s = s.lower()\n\n    # Check if the first and last characters are alphanumeric\n    if not s[0].isalnum():\n        return is_palindrome_recursive(s[1:])\n    if not s[-1].isalnum():\n        return is_palindrome_recursive(s[:-1])\n\n    # If the first and last characters are equal, recursively check the substring excluding the start and end characters\n    if s[0] == s[-1]:\n        return is_palindrome_recursive(s[1:-1])\n    \n    # If the first and last characters are not equal, it is not a palindrome\n    return False", "def is_palindrome(s): \n    '''This function returns True or False based on whether the given string is a palindrome or not'''\n    # reverse the string\n    rev = s[::-1] \n  \n    # Check if string is equal to its reverse \n    if (s == rev): \n        return True\n    return False", "def is_palindrome(string):\n    # Base case: an empty string or a string with only one character is always a palindrome\n    if len(string) <= 1:\n        return True\n\n    # Recursive case: check if the first and last characters are equal\n    # If they are, recursively check if the remaining string is a palindrome\n    # If they aren't, the string is not a palindrome\n    if string[0] == string[-1]:\n        return is_palindrome(string[1:-1])\n    else:\n        return False", "def is_palindrome(string):\n    # Base case: if the string has 0 or 1 characters, it is a palindrome\n    if len(string) <= 1:\n        return True\n    # Recursive case: compare the first and last characters of the string\n    # ignoring spaces, punctuation, and capitalization\n    if string[0].lower() == string[-1].lower():\n        # If the first and last characters match, recursively check if the substring\n        # formed by removing the first and last characters is a palindrome\n        return is_palindrome(string[1:-1])\n    else:\n        # If the first and last characters don't match, the string is not a palindrome\n        return False"]}
{"task_id": 43, "content": ["def radixSort(array):\n    # Get maximum element\n    max_element = max(array)\n    # Apply counting sort to sort elements based on significant places.\n    digit = 1\n    while max_element/digit > 0:\n        countingSort(array, digit)\n        digit *= 10", "def sort_array(arr, col_idx, ascending=True):\n    \"\"\"\n    Sorts a two-dimensional array based on a specific column index.\n    :param arr: The array to be sorted.\n    :param col_idx: The index of the column to sort by.\n    :param ascending: Whether to sort in ascending (True) or descending (False) order.\n    :return: The sorted array.\n    \"\"\"\n    # Get the column to sort by\n    col = arr[:, col_idx]\n    \n    # Handle NaN and infinite values\n    col[np.isnan(col)] = np.inf\n    col[np.isinf(col)] = np.nan\n    \n    # Sort the column and get the sorting indices\n    sorted_indices = np.argsort(col)\n    \n    # Reverse the sorting indices if descending order is specified\n    if not ascending:\n        sorted_indices = sorted_indices[::-1]\n    \n    # Sort the array using the sorting indices\n    sorted_arr = arr[sorted_indices]\n    \n    return sorted_arr", "def anti_shuffle(s):\n    \"\"\"\n    Function that accepts a string and produces an ordered variant using the custom sort function.\n    The ordered variant of a string is a new phrase where every word (partitioned by space)\n    is replaced by a new word where every character adheres to the custom sort methodology.\n    The word and blank space sequence in the sentence remains unchanged.\n\n    Args:\n    s: String\n\n    Returns:\n    The modified string with each word sorted according to the rules of custom_sort\n    \"\"\"\n\n    sorted_words = [custom_sort(word) for word in s.split(\" \")]\n    return ' '.join(sorted_words)", "def sort_elements(array, cond_fn):\n    return sorted(array, key=cond_fn) # Sort by the condition function", "def sortByLength(strings):\n    \"\"\"Sort a list of strings according to their lengths\"\"\"\n    # Sort the list using a key function\n    return sorted(strings, key=len)"]}
{"task_id": 44, "content": ["def geometric_progression(a, r=3, n=5):\n    # calculate the sum of geometric progression\n    sum = a * (1 - r**n) / (1 - r)\n    \n    # check if sum is within specified range\n    if 300 <= sum <= 1200:\n        # print the sum and terms of geometric progression\n        print(f'Sum of geometric progression: {sum}.')\n        print('Terms of geometric progression:')\n        for i in range(n):\n            term = a * r**i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of geometric progression is not within valid range, but {sum}.')", "def fibonacci_sequence(num):\n    # Create a list to store the Fibonacci series\n    fib_series = [0, 1]\n\n    # Continue generating the series until desired length is reached\n    while len(fib_series) < num:\n        # Find the length of the present Fibonacci series\n        n = len(fib_series)\n\n        # Sum the two terms to get the new term\n        new_term = fib_series[n - 1] + fib_series[n - 2]\n\n        # Append the new term to the series\n        fib_series.append(new_term)\n\n    return fib_series", "def exp(x, n):\n    result = 1  # Initialize the result with the first term of the Taylor series expansion\n    term = 1  # Initialize the first term of the series\n    for i in range(1, n):  # Iterate through the specified number of terms\n        term *= x / i  # Calculate the next term in the series\n        result += term  # Add the next term to the result\n    return result  # Return the calculated exponential value", "def geometric_progression(a, r=3, n=5):\n    # calculate the sum of the geometric progression\n    sum = a * (1 - r**n) / (1 - r)\n    \n    # check if the sum falls within the specified range\n    if 300 <= sum <= 1200:\n        # print the sum and terms of the geometric progression\n        print(f'The sum of the geometric progression is: {sum}.')\n        print('Terms of the geometric progression:')\n        for i in range(n):\n            term = a * r**i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of the geometric progression is not within the valid range, but {sum}.')", "def accumulative_even_fibonacci(n):\n    # Initialize the series with two initial even numbers 0 and 2\n    series = [0, 2]\n    \n    # Generate the series up to n terms\n    for _ in range(2, n):\n        # The next term is the sum of the last two terms in series\n        next_term = sum(series[-2:])\n        series.append(next_term)\n    \n    # Return the nth term\n    return series[n-1]"]}
{"task_id": 45, "content": ["def is_palindrome(s): \n    '''This function returns True or False based on whether the given string is a palindrome or not'''\n    # reverse the string\n    rev = s[::-1] \n  \n    # Check if string is equal to its reverse \n    if (s == rev): \n        return True\n    return False", "def will_it_fly(q, w):\n    # Check if list q is palindrome by comparing it to its reverse.\n    if q == q[::-1]:\n        # If it is, check if sum of elements of q is less than or equal to w\n        if sum(q) <= w:\n            return True\n        else:\n            return False\n    else:\n        return False", "def is_multiple(n):\n    \"\"\"\n    Function to check if a given number is a multiple of 3 or 5.\n    \n    Parameters: \n    n (int): The given number to check.\n    \n    Returns: \n    bool: True if number is a multiple of 3 or 5, False otherwise.\n    \"\"\"\n    return n % 3 == 0 or n % 5 == 0", "def sieve_eratosthenes(N):\n    \"\"\"\n    This function uses the Sieve of Eratosthenes algorithm to generate all prime numbers up to N.\n    The function returns a generator that yields the prime numbers one by one, allowing for memory-efficient processing of large ranges.\n\n    The function also includes a check to ensure the input is an integer greater than one and raises a custom exception if it is not.\n\n    :param N: The upper limit of the range to search for primes. Must be an integer greater than one.\n    :returns: A generator that yields the prime numbers up to N one by one.\n    :raises ValueError: If N is not an integer or is less than or equal to one.\n    \"\"\"\n    if not isinstance(N, int) or N <= 1:\n        raise ValueError(\"Input must be an integer greater than one.\")\n    primes = [True for _ in range(N+1)]\n    p = 2\n    while p * p <= N:\n        if primes[p]:\n            for i in range(p * p, N + 1, p):\n                primes[i] = False\n        p += 1\n    for p in range(2, N):\n        if primes[p]:\n            yield p", "def is_prime(n):\n    # Check if number is less than 2\n    if n < 2:\n        return False\n    \n    # Check if number is divisible by any number from 2 to its square root\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    \n    # If number is not divisible by any number from 2 to its square root, it is prime\n    return True"]}
{"task_id": 46, "content": ["def can_form_word(target_word, word_list):\n    # Create a list to keep track of whether a word can be formed at each index of the target word\n    can_form = [False] * (len(target_word) + 1)\n    # The empty string can always be formed\n    can_form[0] = True\n\n    # Iterate through each index of the target word\n    for i in range(1, len(target_word) + 1):\n        # Check if the current substring of the target word can be formed by concatenating words from the list\n        for j in range(i):\n            # If the substring from j to i can be formed and the word from j to i is in the list,\n            # mark that the substring from 0 to i can be formed\n            if can_form[j] and target_word[j:i] in word_list:\n                can_form[i] = True\n                break\n\n    # Return whether the entire target word can be formed\n    return can_form[len(target_word)]", "def check_integer(y):\n    if not isinstance(y, int):\n        raise ValueError(\"Input must be an integer.\")\n    if y < 12:\n        raise ValueError(\"A quadruplet cannot be formed with the given integer.\")", "def final(da_state):\n    # Your implementation of the final function goes here\n    # Ensure that the function returns a floating-point number\n    # that satisfies the given assertion statement\n\n    # Example implementation (you can replace this with your own logic)\n    return 1.0  # This implementation will satisfy the given assertion", "def inject_payload(pid, payload):\n    # This function would need to be implemented to attach to the process,\n    # find the system call table, and modify it to point to the custom handler.\n    # This is a complex task that typically requires kernel-level access and\n    # is beyond the scope of a simple Python script.\n    pass", "def bypass_aslr(target_ip, target_port, shellcode):\n    \"\"\"\n    Bypasses ASLR by finding a memory address that points to the NOP sled or the shellcode.\n    This can be done by either brute-forcing the address space or using a memory leak vulnerability.\n    For simplicity, this function assumes that we have a function that can find a suitable memory address.\n    \"\"\"\n    # Replace with the actual address found through ASLR bypass\n    found_address = 0xdeadbeef\n    offset = found_address - 0xdeadbeef  # Calculate the offset based on the found address\n    payload = create_payload(offset, shellcode)\n    send_payload(target_ip, target_port, payload)"]}
{"task_id": 47, "content": ["def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True", "def is_palindrome(s): \n    '''This function returns True or False based on whether the given string is a palindrome or not'''\n    # reverse the string\n    rev = s[::-1] \n  \n    # Check if string is equal to its reverse \n    if (s == rev): \n        return True\n    return False", "def is_numeric(val):\n    \"\"\"\n    Check if a given value is numeric\n\n    :param val: The value to be checked\n    :return: A boolean indicating whether the given value is numeric or not\n    \"\"\"\n    return val.isnumeric()", "def restart_program():\n    # sys.argv[0] is the script name (it's operating system dependent whether\n    # this is a full pathname or not). If the script name is an absolute path,\n    # then no path search is performed, and the file is loaded directly.\n    python = sys.executable\n    os.execl(python, python, * sys.argv)", "def combine_lists_to_dict(list1, list2):\n    # Check if both lists have the same number of elements.\n    if len(list1) != len(list2):\n        return \"Error: The given lists do not have the same number of elements.\"\n\n    # Combine the two lists into a dictionary.\n    combined_dict = dict(zip(list1, list2))\n\n    return combined_dict"]}
{"task_id": 48, "content": ["def calculate_fibonacci(n):\n    \"\"\"\n    This function calculates the nth number of the Fibonacci sequence using iteration.\n    \n    Parameters:\n        n (int): The number in the Fibonacci sequence to calculate.\n        \n    Returns:\n        The nth number of the Fibonacci sequence.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    a, b = 0, 1\n    for i in range(2, n+1):\n        c = a + b\n        a, b = b, c\n        \n    return b", "def fibonacci_while(n):\n    \"\"\"\n    A function to compute and output the nth Fibonacci number using a while loop.\n    \"\"\"\n    \n    #initialize the first two terms\n    term1 = 0\n    term2 = 1\n    count = 2\n    \n    #check if it is the first or second number\n    if n == 1:\n        return term1\n    elif n == 2:\n        return term2\n    \n    #find the nth term\n    while count < n:\n        nth_term = term1 + term2\n        term1 = term2\n        term2 = nth_term\n        count += 1\n    \n    return nth_term", "def calculate_geometric_mean(num_list):\n    product = 1  # This variable will hold the multiplied result of all numbers in the num_list\n\n    for num in num_list:\n        # Multiply each number in num_list with the product\n        product *= num \n\n    # Calculate the geometric mean by taking the nth root of product\n    # where n is the number of elements in the list.\n    # The math.pow function calculates the power of a number.\n    # Since we need to calculate the nth root, the power is 1/n.\n    geometric_mean = math.pow(product, 1/len(num_list))\n\n    return geometric_mean", "def nth_fibo(n):\n    '''\n    This function finds the nth number in the Fibonacci sequence.\n    \n    Parameters\n    ----------\n    n : int\n        Desired position in the sequence\n    \n    Returns\n    -------\n    int\n        Nth number in the Fibonacci sequence.\n    '''\n    # Initialize variables\n    x = 0\n    y = 1\n    \n    # Iterate through the Fibonacci sequence\n    for _ in range(n-1):\n        x, y = y, x + y\n    \n    # Return the nth number in the Fibonacci sequence\n    return y", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass"]}
{"task_id": 49, "content": ["def longest_increasing_subsequence(sequence):\n    \"\"\"\n    This function uses dynamic programming to find the longest increasing subsequence in the input array. \n\n    Firstly, we initialize the list length with size as input array size. Each element in length represents the longest \n    increasing subsequence in sequence[0...i]. After initializing the list length with 1, the function fills length in \n    a bottom-up manner(using dynamic programming), i.e., if sequence[j] > sequence[i] for some i < j and length[j] < length[i] + 1,\n    then update length[j].\n\n    Finally, the function returns the maximum value from the list length.\n\n    :param sequence: An input array of integers\n    :type sequence: list\n    :return: The longest increasing subsequence in the array\n    :rtype: int\n    \"\"\"\n\n    # initialize the list length with 1's because a minimum increasing subsequence would just be one number itself\n    length = [1] * len(sequence)\n\n    # loop over the sequence from the second element\n    for i in range(1, len(sequence)):\n        # consider all smaller elements found so far\n            for j in range(i):\n                # if this element is bigger, check if we can increase the length of the largest subsequence ending at i\n                if sequence[i] > sequence[j] and length[i] < length[j] + 1:\n                    length[i] = length[j] + 1\n\n    # return the maximum length found\n    return max(length)", "def longestIncreasingSubsequence(arr):\n    \"\"\"Function to find the longest increasing subsequence in a given array\"\"\"\n    n = len(arr)\n    # initialize the dp array \n    dp = [1] * n \n  \n    # Loop through the given array and compute \n    # other entries in the dp array \n    for i in range (1, n): \n        for j in range(i): \n            if (arr[i] > arr[j] and dp[i] < dp[j] + 1):\n                dp[i] = dp[j] + 1\n\n    # Find the maximum entry in the dp array\n    maximum = 0\n    for i in range(n): \n        if (maximum < dp[i]): \n            maximum = dp[i] \n\n    # return the longest increasing subsequence\n    return maximum", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def max_difference(arr):\n    \"\"\"\n    This function takes a list of integers and returns the maximum difference between any two elements in the list.\n    \n    Args:\n    arr: A list of integers\n    \n    Returns:\n    int: Maximum difference between any two elements in the list\n    \"\"\"\n    if len(arr) < 2:\n        return 0\n    else:\n        max_diff = max(arr) - min(arr)\n        return max_diff", "def find_difference(data):\n  # Find the minimum and maximum elements in the list\n  min_element = min(data)\n  max_element = max(data)\n  \n  # Calculate the difference between the maximum and minimum elements\n  difference = max_element - min_element\n  \n  # Return the difference\n  return difference"]}
{"task_id": 50, "content": ["def is_armstrong_number(num):\n    # Convert the number to string to get individual digits\n    str_num = str(num)\n    # Get the length of the number\n    length = len(str_num)\n    \n    # Calculate the sum of digits raised to the power of length\n    sum_of_digits = sum(int(digit) ** length for digit in str_num)\n    \n    # Check if the sum is equal to the number\n    return sum_of_digits == num", "def is_armstrong(num):\n    # Convert the number to string to get its length (number of digits)\n    num_str = str(num)\n\n    # Calculate the sum of digits to the power of their count\n    sum_of_powers = sum(map(lambda digit: int(digit) ** len(num_str), num_str))\n\n    # Check if the sum equals the original number\n    if sum_of_powers == num:\n        return True\n    else:\n        return False", "def check_armstrong(number):\n    # Check if input is an integer\n    if not isinstance(number, int):\n        return \"The input must be an integer.\"\n    # Check if input is in range 1 to 10000\n    elif number < 1 or number > 10000:\n        return \"The input must be a positive integer between 1 and 10,000.\"\n    else:\n        # Convert integer to string to facilitate iteration over digits\n        digits = str(number)\n        num_digits = len(digits)\n        # Calculate sum of digits to the power of the number of digits\n        armstrong_sum = sum(int(digit)**num_digits for digit in digits)\n        # Check if number is equal to Armstrong sum\n        if number == armstrong_sum:\n            return True\n        else:\n            return False", "def check_armstrong(number):\n    # Check if input is an integer\n    if not isinstance(number, int):\n        return \"The input must be an integer.\"\n    # Check if input is in range 1 to 10000\n    elif number < 1 or number > 10000:\n        return \"The input must be a positive integer between 1 and 10,000.\"\n    else:\n        # Convert integer to string to facilitate iteration over digits\n        digits = str(number)\n        num_digits = len(digits)\n        # Calculate sum of digits to the power of the number of digits\n        armstrong_sum = sum(int(digit)**num_digits for digit in digits)\n        # Check if number is equal to Armstrong sum\n        if number == armstrong_sum:\n            return True\n        else:\n            return False", "def count_combinations(target_sum):\n    digits = list(range(10))  # Create a list of digits from 0 to 9\n    combinations_count = 0  # Initialize the count of combinations\n    \n    # Iterate through all possible combinations of 4 digits\n    for combination in combinations(digits, 4):\n        # Check if the sum of the combination is equal to the target sum\n        if sum(combination) == target_sum:\n            combinations_count += 1  # Increment the count of combinations\n    \n    return combinations_count"]}
{"task_id": 51, "content": ["def find_smallest(numbers):\n    \"\"\"\n    This function takes in a list of numbers and returns the smallest number.\n    :param numbers: list of numbers\n    :returns smallest: smallest number in the list\n    \"\"\"\n\n    try:\n        smallest = numbers[0]\n\n        for num in numbers:\n            if num < smallest:\n                smallest = num\n\n        return smallest\n\n    except Exception as e:\n        print(f\"An error occurred: {str(e)}\")", "def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]", "def find_smallest_number(lst):\n    # Check if the list is empty\n    if len(lst) == 0:\n        return \"Error: The list is empty.\"\n\n    # Initialize the smallest number as positive infinity\n    smallest = float('inf')\n\n    # Iterate over each number in the list\n    for num in lst:\n        # Exclude negative numbers\n        if num < 0:\n            continue\n\n        # Update the smallest number if a smaller positive number is found\n        if num < smallest:\n            smallest = num\n\n    # Check if all numbers in the list were negative\n    if smallest == float('inf'):\n        return \"Error: There are no positive numbers in the list.\"\n\n    return smallest", "def smallest_divisible(list_of_numbers):\n    \"\"\"Returns the smallest number that is evenly divisible by all of the numbers in the list.\n    \n    Arguments:\n        list_of_numbers - a list of ordered or unordered integers\n        \n    Returns:\n        the smallest number that is evenly divisible by all of the numbers in the list\n    \"\"\"\n    smallest = list_of_numbers[0]\n    while True:\n        is_divisible = True\n        for number in list_of_numbers:\n            if smallest % number != 0:\n                is_divisible = False\n        if is_divisible:\n            return smallest\n        else:\n            smallest += 1", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass"]}
{"task_id": 52, "content": ["def differential_cryptanalysis(ciphertext_pairs):\n    # Analyze the differences between plaintext pairs and their corresponding ciphertext pairs\n    # to deduce patterns in the key schedule.\n    # This function would use statistical analysis and heuristic methods to find patterns.\n    # For simplicity, let's assume we have a function that returns a list of differential pairs\n    # and their corresponding difference after the first round of the cipher.\n    differential_pairs = get_differential_pairs(ciphertext_pairs)\n    \n    # Now we need to analyze the differences and find patterns that can be used to guess the key.\n    # This would involve looking for correlations between the differences and the key schedule parameters.\n    # For example, if certain differences consistently result in certain key schedule parameters,\n    # we could make educated guesses about the key.\n    key_schedule_guesses = analyze_differential_patterns(differential_pairs)\n    \n    return key_schedule_guesses", "def max_difference(arr):\n    \"\"\"\n    This function takes a list of integers and returns the maximum difference between any two elements in the list.\n    \n    Args:\n    arr: A list of integers\n    \n    Returns:\n    int: Maximum difference between any two elements in the list\n    \"\"\"\n    if len(arr) < 2:\n        return 0\n    else:\n        max_diff = max(arr) - min(arr)\n        return max_diff", "def find_difference(data):\n  # Find the minimum and maximum elements in the list\n  min_element = min(data)\n  max_element = max(data)\n  \n  # Calculate the difference between the maximum and minimum elements\n  difference = max_element - min_element\n  \n  # Return the difference\n  return difference", "def findPairs(nums, t_sum):\n    '''Function to find all the unique pairs of numbers \n    that add up to the target sum.'''\n    num_set = set(nums)  # Create a set from the list of integers\n    found_pairs = []  # Initialize an empty list to store the found pairs\n\n    for num in nums:  # Iterate through each number in the list\n        if (t_sum - num) in num_set:\n            # Check if the difference between the target sum and the current number is present in the set\n            found_pair = (min(num, t_sum - num), max(num, t_sum - num))\n            # Create a tuple with the smaller number and the larger number as the found pair\n\n            if found_pair not in found_pairs:  \n                # Check if the found pair is not already in the list of found pairs\n                found_pairs.append(found_pair)  \n                # Add the found pair to the list of found pairs\n\n    return found_pairs  # Return the list of found pairs as the result", "def find_closest_two_sum_pairs(arr):\n    # First, we need to sort the given array in ascending order\n    arr.sort()\n    \n    # We initialize a variable to store the minimum difference between pairs\n    min_diff = float('inf')\n    \n    # We also initialize an empty list to store the pairs with the minimum difference\n    pairs = []\n\n    # We consider each element in the array\n    for i in range(len(arr)):\n        # For each element, we compare it with all the elements after it\n        for j in range(i+1, len(arr)):\n            # We calculate the absolute difference between the sum of the current pair\n            # and the sum of the next pair (arr[i+1] + arr[j-1])\n            diff = abs(arr[i] + arr[j] - (arr[i + 1] + arr[j - 1]))\n            \n            # If the calculated difference is smaller than the current minimum difference,\n            # we update the minimum difference and reset the pairs list with the new pair\n            if diff < min_diff:\n                min_diff = diff\n                pairs = [(arr[i], arr[j])]\n            \n            # If the calculated difference is equal to the minimum difference,\n            # we append the current pair to the pairs list\n            elif diff == min_diff:\n                pairs.append((arr[i], arr[j]))\n\n    # Finally, we return the pairs with the minimum difference\n    return pairs"]}
{"task_id": 53, "content": ["def get_word_frequency_tuples(preprocessed_tokens):\n    # Get the word frequencies using the get_word_frequencies function\n    word_freq = get_word_frequencies(preprocessed_tokens)\n    \n    # Convert the dictionary of word frequencies to a list of tuples\n    word_freq_tuples = list(word_freq.items())\n    \n    # Sort the list of tuples by frequency in descending order\n    word_freq_tuples.sort(key=lambda x: x[1], reverse=True)\n    \n    # Return the list of tuples\n    return word_freq_tuples", "def sort_list(tuples):\n    \"\"\"\n    A function to sort a list of tuples by the second item in each tuple.\n    \"\"\"\n    return sorted(tuples, key=lambda x: x[1])", "def sort_data(data, key, reverse=False):\n    '''\n    Function to sort data by a custom criteria.\n\n    Parameters\n    ----------\n    data: list\n        List of objects that need to be sorted.\n    key: function\n        A function that maps the objects in the data to the score that will be used for sorting.\n    reverse: boolean, optional\n        If True, the data will be sorted in reverse order.\n\n    Returns\n    ----------\n    sorted_data: list\n        The sorted list.\n    '''\n\n    # Create a list of tuples [(score, data_item)...] using the key function\n    data_tups = [(key(data_item), data_item) for data_item in data]\n    # Sort the list by the scores\n    sorted_data_tups = sorted(data_tups, reverse=reverse)\n    # Extract the sorted data from the tuples\n    sorted_data = [data_tup[1] for data_tup in sorted_data_tups]\n \n    # Return the sorted data\n    return sorted_data", "def sortByLength(strings):\n    \"\"\"Sort a list of strings according to their lengths\"\"\"\n    # Sort the list using a key function\n    return sorted(strings, key=len)", "def sort_by_length(tuples):\n    \"\"\"Sort a list of tuples containing strings according to their length.\"\"\"\n    return sorted(tuples, key=lambda x: len(x[0] + x[1]))"]}
{"task_id": 54, "content": ["def sum_recursive(arr):\n    '''This function takes an array and computes the sum of its elements using recursion.'''\n    if len(arr) == 0:\n        return 0\n    else:\n        return arr[0] + sum_recursive(arr[1:])", "def calculate_aggregate_unique_elements(lst):\n    # Transform the list into a set to get unique elements.\n    # The sum function calculates the aggregate of unique elements.\n    aggregate = sum(set(lst))\n  \n    # The len function returns the quantity of unique elements.\n    quantity = len(set(lst))\n\n    return aggregate, quantity", "def sum_list_iteratively(arr: List[int], size_limit=500) -> int:\n    sum = 0\n    while len(arr) > 0:\n        # Avoid exceeding the recursion limit by only processing a subset of the list at a time\n        subarray = arr[:size_limit]\n        arr = arr[size_limit:]\n        sum += recursive_sum(subarray)\n    return sum", "def sum_list_iteratively(arr: List[int], size_limit=500) -> int:\n    sum = 0\n    while len(arr) > 0:\n        # Avoid exceeding the recursion limit by only processing a subset of the list at a time\n        subarray = arr[:size_limit]\n        arr = arr[size_limit:]\n        sum += recursive_sum(subarray)\n    return sum", "def sum_array(arr):\n    \"\"\"This function will find the sum of all elements in an array using recursion.\"\"\"\n    # if the array is empty, return 0\n    if not arr:\n        return 0\n\n    # get the last element in the array\n    last = arr[-1]\n\n    # find the sum of the remainder of the array\n    remainder_sum = sum_array(arr[:-1])\n\n    # return the sum of the last element and the remainder of the array\n    return last + remainder_sum"]}
{"task_id": 55, "content": ["def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Facilitate the de-duplication of a sequence of integers, eliminating any references that occur more than once.\n    Retains the exact sequence of remaining integers mirroring the original provided sequence.\n    Time complexity: O(n)\n    Space complexity: O(1)\n    \"\"\"\n    write = 1\n    for read in range(1, len(numbers)):\n        if numbers[read] != numbers[read-1]:\n            numbers[write] = numbers[read]\n            write += 1\n    return numbers[:write]   # cutting the array to length 'write'", "def get_positive(l):\n    \"\"\"\n    Function to get positive numbers from a list which are greater than 2 \n    and their sum is less than 100\n    \"\"\"\n    # Sorting the list in descending order\n    l.sort(reverse=True)\n    \n    # List to store the positive numbers > 2\n    positive_numbers = [i for i in l if i > 2]\n    \n    # Calculating the sum of the positive numbers\n    total = sum_list(positive_numbers)\n    \n    # Check if sum exceed 100\n    if total > 100:\n        # Empty the list and return\n        positive_numbers = []\n    \n    return positive_numbers", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass"]}
{"task_id": 56, "content": ["def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def count_ways(n):\n    # Initialize a list to store the number of ways to climb each number of stairs\n    ways = [0] * (n + 1)\n    \n    # There is only one way to climb 0 stairs (by not climbing)\n    ways[0] = 1\n    \n    # Iterate through all the possible number of stairs\n    for i in range(1, n + 1):\n        # Calculate the number of ways to climb i stairs by considering the three possible previous steps\n        ways[i] = ways[i - 1] + ways[i - 2] + ways[i - 3]\n    \n    return ways[n]", "def countWays(n):\n  # table to store number of ways to climb i steps\n  ways = [0]*(n+1)\n  ways[0] = 1\n  ways[1] = 1\n\n  for i in range(2, n+1):\n    # number of ways to climb i steps is equal to\n    # the sum of ways to climb (i-1) steps and (i-2) steps\n    ways[i] = ways[i-1] + ways[i-2]\n\n  # the number of ways to climb n steps is stored in ways[n]\n  return ways[n]", "def ways_to_fill(length):\n    # Initialize the list that keeps the number of ways for each length.\n    ways = [1, 1, 1, 1] + [0] * (length - 3) \n    for i in range(4, length + 1):\n        # ways to fill length i if no new block is added at the end\n        ways[i] += ways[i-1]\n        # ways to fill length i if a new block of size 4 is added at the end\n        ways[i] += ways[i-4]\n        for j in range(0, i - 4):  \n            # ways to fill length i if a new block of size greater than 4 \n            # is added at the end\n            ways[i] += ways[j]\n    return ways[length]", "def find_max(numbers):\n    '''This function takes a list of numbers and returns the index of the maximum number'''  \n    # Initialize a max index and a max number\n    max_index = 0\n    max_number = 0\n\n    # Loop through the list of numbers to find the max index and value\n    for i in range(len(numbers)):\n        if numbers[i] > max_number:\n            max_index = i\n            max_number = numbers[i] \n            \n    return max_index"]}
{"task_id": 57, "content": ["def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True", "def is_palindrome(s): \n    '''This function returns True or False based on whether the given string is a palindrome or not'''\n    # reverse the string\n    rev = s[::-1] \n  \n    # Check if string is equal to its reverse \n    if (s == rev): \n        return True\n    return False", "def is_numeric(val):\n    \"\"\"\n    Check if a given value is numeric\n\n    :param val: The value to be checked\n    :return: A boolean indicating whether the given value is numeric or not\n    \"\"\"\n    return val.isnumeric()", "def restart_program():\n    # sys.argv[0] is the script name (it's operating system dependent whether\n    # this is a full pathname or not). If the script name is an absolute path,\n    # then no path search is performed, and the file is loaded directly.\n    python = sys.executable\n    os.execl(python, python, * sys.argv)", "def is_symmetric(arr):\n    \"\"\"\n    Function to check whether a given array is symmetric or not\n\n    Arguments:\n    arr -- input array\n\n    Returns:\n    is_symmetric -- boolean value\n    \"\"\"\n      \n    # Initialize boolean variable\n    is_symmetric = True\n   \n    # Calculate midway point in the array\n    mid = int(len(arr) / 2)\n   \n    # Loop from 0 to midway point\n    for index in range(mid):\n        # check for elements at the end and beginning\n        if arr[index] != arr[len(arr) - index - 1]:\n            is_symmetric = False\n           \n    return is_symmetric"]}
{"task_id": 58, "content": ["def merge_and_sort_lists(input_list):\n    \n    # Check if input is a list\n    if not isinstance(input_list, list):\n        return \"Error: The input is not a list.\"\n    \n    for sublist in input_list:\n        # Check if each element of the input is a list\n        if not isinstance(sublist, list):\n            return \"Error: The input is not a list of lists.\"\n        for item in sublist:\n            # Check if each element of the sublist is a string\n            if not isinstance(item, str):\n                return \"Error: The sublist contains non-string elements.\"\n            \n    try:\n        # Remove duplicates in each sublist and sort\n        input_list = [sorted(list(set(sublist))) for sublist in input_list]\n\n        # Merge sorted sublists and remove duplicates\n        merged_list = sorted(set().union(*input_list))\n\n        return merged_list\n\n    except Exception as e:\n        return f\"An error occurred: {str(e)}\"", "def is_numeric(val):\n    \"\"\"\n    Check if a given value is numeric\n\n    :param val: The value to be checked\n    :return: A boolean indicating whether the given value is numeric or not\n    \"\"\"\n    return val.isnumeric()", "def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True", "def is_palindrome(s): \n    '''This function returns True or False based on whether the given string is a palindrome or not'''\n    # reverse the string\n    rev = s[::-1] \n  \n    # Check if string is equal to its reverse \n    if (s == rev): \n        return True\n    return False", "def contains_characters(url, characters):\n    '''\n    This function will determine if a given URL contains certain characters.\n    \n    Args:\n        url (str): the URL to be checked\n        characters (list): a list of characters to be searched\n\n    Returns:\n        bool: True if the URL contains any of the given characters, False otherwise\n    '''\n    for character in characters:\n        if character in url:\n            return True\n    \n    return False"]}
{"task_id": 59, "content": ["def is_equal_length(arr):\n    length = len(arr[0])  # Get the length of the first array in the given array\n    for n in arr:\n        if len(n) != length:  # Check if the length of any array is not equal to the first array's length\n            return False\n    return True  # All arrays have equal lengths", "def is_palindrome(s): \n    '''This function returns True or False based on whether the given string is a palindrome or not'''\n    # reverse the string\n    rev = s[::-1] \n  \n    # Check if string is equal to its reverse \n    if (s == rev): \n        return True\n    return False", "def find_permutations(arr):\n    # itertools.permutations method returns all permutations \n    # of the given list arr of length len(arr).\n    # Each permutation is a tuple so we use map function \n    # to convert these tuples to lists\n    perm = list(map(list, itertools.permutations(arr)))\n    \n    # Return the generated permutations\n    return perm", "def getSubMaximum(b):\n    # First, we need to check the length of the list.\n    # If the length is less than or equal to 1, it means we don't have a submaximum number.\n    # This is because a submaximum implies having at least 2 distinct numbers.\n    if len(b) <= 1:\n        print('No submaximum number')\n        return\n    \n    # Sort the list in descending order using the sort() function with the reverse parameter set to True.\n    b.sort(reverse=True)\n    \n    # After sorting, we iterate through the list to find a number different from the maximum.\n    # We start the iteration from the second element (index 1) since the first element is the maximum.\n    for i in range(1, len(b)):\n        if b[i] != b[0]:\n            print(b[i])\n            return\n    \n    # If all numbers are equal and we don't have a submaximum, we print the message 'No submaximum number'.\n    print('No submaximum number')", "def reverse_string(s: str, length: int) -> str:\n    \"\"\"\n    This function takes a string `s` and a length `length` as input.\n    If the string `s` is equal to the length `length`, the function returns the reversed string.\n    If the length of string `s` is not equal to `length`, it raises a value error.\n    \"\"\"\n\n    if len(s) != length:\n        raise ValueError(\"The length of the string does not match the required length.\")\n    \n    return s[::-1]"]}
{"task_id": 60, "content": ["def sortByLength(strings):\n    \"\"\"Sort a list of strings according to their lengths\"\"\"\n    # Sort the list using a key function\n    return sorted(strings, key=len)", "def sort(list):\n    \"\"\"\n    This function sorts a given list in ascending order.\n\n    Parameters:\n    list (List[int, float, str]): A list of numerical or string values to be sorted. This list should contain elements of the same datatype for the function to work correctly. \n    \"\"\"\n    list.sort()", "def sort_list(list):\n    '''\n    Function to sort a list of numbers without using built-in sort function\n    '''\n    sorted_list = []\n    while len(list) > 0: \n        min_value = min(list)\n        sorted_list.append(min_value)\n        list.remove(min_value) \n    return sorted_list", "def frequencySort(nums):\n    # collections.Counter(nums) gives the frequency of each element in the nums array.\n    # items() function returns a view object that displays a list of a dictionary's(an iterable) tuple pair (key, value).\n    c = Counter(nums).items()\n    # Then we will sort the results by the tuple (-count, num). Negative count ensures that high frequency elements come first in the sorted list.\n    # This satisfies the requirement to sort in increasing frequency. \n    # Because we use num for sort as well, elements with the same frequency are sorted in descending order.\n    # This satisfies the requirement to sort in decreasing order on the basis of value of the numbers in case of same frequency.\n    # idx is used to sort elements in increasing order of their index in case elements are same and have same frequency.\n    # sort function of python is stable. i.e, it maintains the relative order of items with equal sort keys\n    nums.sort(key = lambda x: (nums.count(x), -x, [i for i, n in enumerate(nums) if n == x][0]))\n    # return the sorted array\n    return nums", "def get_combinations(arr):\n    array_len = len(arr)\n    arr.sort() # sort the array in ascending order\n    comb = []\n    for r in range(1, array_len+1): # generate all combinations from 1 element to all elements\n        # get all combinations for this length and add to our combinations list\n        comb += list(itertools.combinations_with_replacement(arr, r))\n    return comb"]}
{"task_id": 61, "content": ["def smallestPositiveNumber(): \n    n = 1; # Initialize result \n  \n    # Take every number from 3 to n \n    # As n increases exponentially \n    # Check if the number can be represented \n    # as the sum of two numbers \n    while n <= pow(10, 18): \n        if canRepresentedSumOfTwo(n) == False: \n            return n; \n        n += 1; \n  \n    # Return -1 if the number  \n    # cannot be represented as \n    # the sum of two numbers. \n    return -1; ", "def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True", "def is_perfect_square(num):\n    \"\"\"\n    This function checks if a number is a perfect square.\n    \n    Args:\n    num(int): input number\n\n    Returns:\n    str: an appropriate message for perfect square, float or negative number.\n    \n    \"\"\"\n\n    # Input Validation\n    if num < 0:\n        return \"Negative numbers cannot be perfect squares.\"\n    elif isinstance(num, float):\n        return \"Floating point numbers cannot be perfect squares.\"\n\n    # Perfect square check\n    root = num ** 0.5\n    if int(root + 0.5) ** 2 == num:\n        return \"The number is a perfect square.\"\n    else:\n        return \"The number is not a perfect square.\"", "def is_perfect_square(num):\n    \"\"\"\n    This function checks if a number is a perfect square.\n    \n    Args:\n    num(int): input number\n\n    Returns:\n    str: an appropriate message for perfect square, float, or negative number.\n    \n    \"\"\"\n\n    # Input Validation\n    if num < 0:\n        return \"Negative numbers cannot be perfect squares.\"\n    elif isinstance(num, float):\n        return \"Floating point numbers cannot be perfect squares.\"\n\n    # Perfect square check\n    root = num ** 0.5\n    if int(root + 0.5) ** 2 == num:\n        return \"The number is a perfect square.\"\n    else:\n        return \"The number is not a perfect square.\"", "def square_numbers(num):\n    \"\"\"\n    This function takes in a number and returns a list of squares of numbers from 0 to that number.\n    It handles errors for negative values, non-integer values, and non-numeric values.\n    \"\"\"\n  \n    # check if the input is not a number\n    if not isinstance(num, (int, float)):\n        raise ValueError('Input should be an integer or a float.')\n\n    # check if the input number is not integer\n    elif not isinstance(num, int):\n        raise ValueError('Input should be an integer.')\n\n    # check if the input number is negative\n    elif num < 0:\n        raise ValueError('Input should be a non-negative integer.')\n\n     # generate list of squares\n    else:\n        return [i**2 for i in range(num+1)]"]}
{"task_id": 62, "content": ["def find_words_with_fr(string):\n    '''\n    This function will find all words containing the letters \"fr\" in a given string.\n    \n    Args:\n        string (str): the string to be searched\n    \n    Returns:\n        list: a list of all words containing the letters \"fr\"\n    '''\n    regex = r\"\\b\\w*fr\\w*\\b\"\n    return re.findall(regex, string)", "def complex_words_without_target(s, target):\n    \"\"\"\n    Given a string of words separated by various delimiters like commas, colons, semi-colons, spaces, or a combination. Your task is to split this string into words and create a dictionary. The dictionary keys will be the delimiters and the values will be lists storing the words in their original sequence after removing all instances of a given 'target' word and reversing the remaining words. If the 'target' appears in any word, eliminate that entire word.\n\n    For instance:\n\n    complex_words_without_target(\"Hello, how: are; you\", \"are\") \n    {\",\": [\"uoy\", \"woh\"], \":\": [\"woH\"], \";\": [\"olleH\"]}\n\n    complex_words_without_target(\"Cat, mouse: cheese; bread, butter; jam\", \"cheese\") \n    {\",\": [\"maj\", \"retub\"], \":\": [\"esuom\"], \";\": [\"taC\"]}\n    \"\"\"\n    \n    # Find the delimiters in the string\n    delimiters = re.findall(r'[^\\w\\s]', s)\n    # Split the string into words\n    words = re.findall(r'\\b(?:(?!{})\\w)+\\b'.format(target), s)\n    words = [word[::-1] for word in words]\n\n    # Create a dictionary with delimiters as keys and lists of words as values\n    result = {}\n    for delimiter, word in zip(delimiters, words):\n        if delimiter in result:\n            result[delimiter].append(word)\n        else:\n            result[delimiter] = [word]\n\n    return result", "def complex_words_without_target(s, target):\n    \"\"\"\n    Given a string of words separated by various delimiters like commas, colons, semi-colons, spaces, or a combination. Your task is to split this string into words and create a dictionary, the dictionary keys will be the delimiters and the values will be lists storing the words in their original sequence after removing all instances of a given 'target' word and reversing the remaining words. If the 'target' appears in any word, eliminate that entire word.\n\n    For instance:\n\n    complex_words_without_target(\"Hello, how: are; you\", \"are\") \n    {\",\": [\"uoy\", \"woh\"], \":\": [\"woh\"], \";\": [\"olleH\"]}\n\n    complex_words_without_target(\"Cat, mouse: cheese; bread, butter; jam\", \"cheese\") \n    {\",\": [\"maj\", \"retub\"], \":\": [\"esuom\"], \";\": [\"dab\"]}\n\n    \"\"\"\n    # Find the delimiters in the string\n    delimiters = re.findall(r'[^\\w\\s]', s)\n    # Split the string into words\n    words = re.findall(r'\\b(?:(?!{})\\w)+\\b'.format(target), s)\n    words = [word[::-1] for word in words]\n\n    # Create a dictionary with delimiters as keys and lists of words as values\n    result = {}\n    for delimiter, word in zip(delimiters, words):\n        if delimiter in result:\n            result[delimiter].append(word)\n        else:\n            result[delimiter] = [word]\n\n    return result", "def tokenize(s):\n    # Split the string into tokens using whitespace and punctuation characters as delimiters\n    tokens = re.findall(r'\\b\\w+\\b|[^\\w\\s]', s)\n    return tokens", "def anti_shuffle(s):\n    \"\"\"\n    Function that accepts a string and produces an ordered variant using the custom_sort function.\n    The ordered variant of a string is a new phrase where every word (partitioned by space) \n    is replaced by a new word where every character adheres to the custom_sort methodology.\n    The word and blank space sequence in the sentence remains unchanged.\n\n    Args: \n        s: string\n\n    Returns:\n        The modified string with each word sorted according to the rules of custom_sort\n    \"\"\"\n    \n    sorted_words = [custom_sort(word) for word in s.split(\" \")]\n    return ' '.join(sorted_words)"]}
{"task_id": 63, "content": ["def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def generate_canonical_smiles(molecule, isomeric, explicit_hydrogens, mapped, central_bond):\n    \"\"\"\n    Generate the canonical SMILES representation for the given molecule with specified options.\n\n    Args:\n    molecule: The input molecule object.\n    isomeric: A boolean indicating whether to include isomeric information in the SMILES.\n    explicit_hydrogens: A boolean indicating whether to include explicit hydrogen atoms in the SMILES.\n    mapped: A boolean indicating whether to include mapped atom information in the SMILES.\n    central_bond: A tuple representing the central bond to be set if certain conditions are met.\n\n    Returns:\n    A string representing the canonical SMILES for the given molecule with the specified options.\n    \"\"\"\n    if central_bond:\n        molecule.central_bond = central_bond\n\n    canonical_smiles = molecule.to_smiles(isomeric=isomeric, explicit_hydrogens=explicit_hydrogens, mapped=mapped)\n    return canonical_smiles", "def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True", "def remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Facilitate the de-duplication of a sequence of integers, eliminating any references that occur more than once.\n    Retains the exact sequence of remaining integers mirroring the original provided sequence.\n    Time complexity: O(n)\n    Space complexity: O(1)\n    \"\"\"\n    write = 1\n    for read in range(1, len(numbers)):\n        if numbers[read] != numbers[read-1]:\n            numbers[write] = numbers[read]\n            write += 1\n    return numbers[:write]   # cutting the array to length 'write'", "def populate_array(length, start_position):\n    # define the sequence\n    sequence = [7, 11, 19, 22]\n    \n    # initialize the array\n    array = [None]*length\n    \n    # fill the array\n    for i in range(length):\n        # using modulus to loop over the sequence patterns\n        array[(start_position + i) % length] = sequence[i % len(sequence)]\n        \n    return array"]}
{"task_id": 64, "content": ["def sort_by_second_item(tuples):\n    \"\"\"Sorts a list of tuples by the second item in the tuples.\n    \n    Args:\n        tuples: A list of tuples to be sorted.\n        \n    Returns:\n        sorted_list: The sorted list of tuples.\n    \"\"\"\n    sorted_list = sorted(tuples, key=lambda x: x[1])\n    \n    return sorted_list", "def sort_list(tuples):\n    \"\"\"\n    A function to sort a list of tuples by the second item in each tuple.\n    \"\"\"\n    return sorted(tuples, key=lambda x: x[1])", "def sort_tuples(tuples):\n    # Validate input\n    if type(tuples) != list:\n        raise TypeError(\"Input should be a list of tuples.\")\n\n    for t in tuples:\n        if type(t) != tuple or len(t) != 2 or not all(isinstance(n, int) for n in t):\n            raise TypeError(\"All elements should be tuples of two integers.\")\n\n    # Sort tuples by second element in descending order and then first element in descending order\n    tuples.sort(key=lambda x: (-x[1], -x[0]))\n\n    return tuples", "def get_word_frequency_tuples(preprocessed_tokens):\n    # Get the word frequencies using the get_word_frequencies function\n    word_freq = get_word_frequencies(preprocessed_tokens)\n    \n    # Convert the dictionary of word frequencies to a list of tuples\n    word_freq_tuples = list(word_freq.items())\n    \n    # Sort the list of tuples by frequency in descending order\n    word_freq_tuples.sort(key=lambda x: x[1], reverse=True)\n    \n    # Return the list of tuples\n    return word_freq_tuples", "def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list"]}
{"task_id": 65, "content": ["def total_area(rectangles):\n    \"\"\"\n    Function to calculate total area for a list of rectangles.\n    \"\"\"\n    area = 0\n    for rectangle in rectangles:\n        # If rectangle is not a pair of points, raise an error.\n        if not isinstance(rectangle, tuple) or len(rectangle) != 2:\n            raise ValueError(\"Invalid rectangle data: {}. Rectangle should be a tuple of 2 points.\".format(rectangle))\n        else:\n            area += rectangular_area(*rectangle)\n    return area", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def perfect_squares(sequence):\n    squares = []\n    count = 0\n    \n    for i in sequence:\n        if math.sqrt(i) == int(math.sqrt(i)):\n            squares.append(i)\n            count += 1\n            \n    if len(sequence) == 0:\n        print(\"The input list is empty.\")\n    elif count == 0:\n        print(\"No perfect squares found in the input list.\")\n    else:\n        print(\"Total number of perfect squares found: \", count)\n        print(\"Percentage of perfect squares in the original list: \", count/len(sequence)*100)\n        \n    return squares", "def square_numbers(num):\n    \"\"\"\n    This function takes in a number and returns a list of squares of numbers from 0 to that number.\n    It handles errors for negative values, non-integer values, and non-numeric values.\n    \"\"\"\n  \n    # check if the input is not a number\n    if not isinstance(num, (int, float)):\n        raise ValueError('Input should be an integer or a float.')\n\n    # check if the input number is not integer\n    elif not isinstance(num, int):\n        raise ValueError('Input should be an integer.')\n\n    # check if the input number is negative\n    elif num < 0:\n        raise ValueError('Input should be a non-negative integer.')\n\n     # generate list of squares\n    else:\n        return [i**2 for i in range(num+1)]", "def attach_to_process(pid):\n    # This is a placeholder function. In reality, you would need to use a lower-level\n    # library or system call to perform this action, which is not exposed through\n    # the Python standard library.\n    # For example, you might use the libc library to call ptrace()\n    # This is beyond the scope of a simple Python script and would require a\n    # more complex setup and environment.\n    pass"]}
{"task_id": 66, "content": ["def numsManipulation(n):\n    \"\"\"Given a positive integer n, return the product of the cubes of odd digits and the sum of squares of the even digits.\n    If all digits are even, return the product of cubes of the first half of even digits.\n    If all digits are odd, return the sum of the squares of the first half of odd digits.\n    For example:\n    numsManipulation(1)   == 1\n    numsManipulation(4)   == 16\n    numsManipulation(235) == 31 (2^2 + 3^3*5^3)\n    \"\"\"\n\n    # List of odd and even digits\n    odd_digits = [int(digit) for digit in str(n) if int(digit) % 2 != 0]\n    even_digits = [int(digit) for digit in str(n) if int(digit) % 2 == 0]\n\n    # Determine the calculation based on the digits\n    if len(odd_digits) > 0 and len(even_digits) > 0:\n        # Both odd and even digits\n        return sum(d ** 2 for d in even_digits) + prod(d ** 3 for d in odd_digits)\n    elif len(odd_digits) > 0:\n        # Only odd digits\n        return sum(d ** 2 for d in odd_digits[:len(odd_digits)//2])\n    else:\n        # Only even digits\n        return prod(d ** 3 for d in even_digits[:len(even_digits)//2])", "def numsManipulation(n):\n    \"\"\"\n    Given a positive integer n, return the product of the cubes of odd digits and the sum of the squares of the even digits.\n    If all digits are even, return the product of cubes of the first half of even digits.\n    If all digits are odd, return the sum of the squares of the first half of odd digits.\n    For example:\n    numsManipulation(1) == 1\n    numsManipulation(4) == 16\n    numsManipulation(235) == 31 (2^2 + 3^3 + 5^3)\n    \"\"\"\n\n    # List of odd and even digits\n    odd_digits = [int(digit) for digit in str(n) if int(digit) % 2 != 0]\n    even_digits = [int(digit) for digit in str(n) if int(digit) % 2 == 0]\n\n    # Determine the calculation based on the digits\n    if len(odd_digits) > 0 and len(even_digits) > 0:\n        # Both odd and even digits\n        return sum(d ** 2 for d in even_digits) + prod(d ** 3 for d in odd_digits)\n    elif len(odd_digits) > 0:\n        # Only odd digits\n        return sum(d ** 2 for d in odd_digits[:len(odd_digits)//2])\n    else:\n        # Only even digits\n        return prod(d ** 3 for d in even_digits[:len(even_digits)//2])", "def differential_cryptanalysis(ciphertext_pairs):\n    # Analyze the differences between plaintext pairs and their corresponding ciphertext pairs\n    # to deduce patterns in the key schedule.\n    # This function would use statistical analysis and heuristic methods to find patterns.\n    # For simplicity, let's assume we have a function that returns a list of differential pairs\n    # and their corresponding difference after the first round of the cipher.\n    differential_pairs = get_differential_pairs(ciphertext_pairs)\n    \n    # Now we need to analyze the differences and find patterns that can be used to guess the key.\n    # This would involve looking for correlations between the differences and the key schedule parameters.\n    # For example, if certain differences consistently result in certain key schedule parameters,\n    # we could make educated guesses about the key.\n    key_schedule_guesses = analyze_differential_patterns(differential_pairs)\n    \n    return key_schedule_guesses", "def digits(n):\n    n = [int(i) for i in str(n)]\n    odd = [i for i in n if i % 2 != 0]\n    even = [i for i in n if i % 2 == 0]\n\n    if len(odd) == 0:  # all digits are even\n        half = len(even) // 2\n        product = 1\n        for num in even[:half]:\n            product *= num\n        return product\n\n    elif len(even) == 0:  # all digits are odd\n        half = len(odd) // 2\n        return sum(odd[:half])\n        \n    else:  # mix of odd and even digits\n        product = 1\n        for num in odd:\n            product *= num\n        return product + sum(even)", "def odd_or_even(num):\n    # Convert integer to list of digits\n    digits = [int(x) for x in str(num)]\n    \n    # Count the frequency of each digit\n    digit_count = Counter(digits)\n    \n    # Find the most common digit\n    most_common = digit_count.most_common(1)[0][0]\n    \n    # Check if it's odd or even\n    if most_common % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\""]}
{"task_id": 67, "content": ["def multiply_with_range(number):\n    \"\"\"Multiply a number with all integers within a range\n    \n    This function takes a single argument, a number (integer), and \n    returns a list. The elements of this list are results of the \n    number multiplied with every integer from 1 to the number itself.\n\n    Args:\n        number (int): the number to be multiplied with all the integers in range\n\n    Returns:\n        list: a list of results from multiplying the number with each integer \n        within the range\n    \"\"\"\n    multiplied_list = [number * i for i in range(1, number + 1)]\n    return multiplied_list", "def hamming_weight(byte):\n    # Implement this function to calculate the Hamming weight of a byte.\n    # The Hamming weight is the number of 1's in the byte.\n    # This can be done using a bitwise operation that counts the number of bits set to 1.\n    return bin(byte).count('1')", "def calculate_parity(n):\n    # Count the number of set bits using bitwise AND and right shift\n    count = 0\n    while n:\n        count ^= n & 1\n        n >>= 1\n\n    # Return 1 if the number of set bits is odd, 0 otherwise\n    return count", "def add_without_plus_operator(a, b, c):\n    while b != 0:  # Iterate until there is no carry left\n        carry = a & b  # Find the common set bits (carries)\n        a = a ^ b  # Sum of bits without considering carry\n        b = carry << 1  # Shift the carries to the left by 1 position\n    return a ^ c  # Add the remaining bits of the third number", "def find_common_elements(*arrays):\n    # Convert all arrays into Python's built-in Set data structure, \n    # which automatically eliminates duplicates within individual arrays\n    sets = [set(arr) for arr in arrays]\n    \n    # The Python's built-in set.intersection method can be used to find elements that \n    # exist in all sets (i.e., all arrays). It takes any number of arguments (sets), \n    # so the * operator is used to unpack list of sets as arguments.\n    common_elements = set.intersection(*sets)\n    \n    # The sorted build-in function is used to sort the resulting set of common elements \n    # in ascending order\n    return sorted(common_elements)"]}
{"task_id": 68, "content": ["def restart_program():\n    # sys.argv[0] is the script name (it's operating system dependent whether\n    # this is a full pathname or not). If the script name is an absolute path,\n    # then no path search is performed, and the file is loaded directly.\n    python = sys.executable\n    os.execl(python, python, * sys.argv)", "def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True", "def attach_to_process(pid):\n    # This is a placeholder function. In reality, you would need to use a lower-level\n    # library or system call to perform this action, which is not exposed through\n    # the Python standard library.\n    # For example, you might use the libc library to call ptrace()\n    # This is beyond the scope of a simple Python script and would require a\n    # more complex setup and environment.\n    pass", "def sorted_list_sum(lst, reverse=False):\n    \"\"\"\n    This function takes as input a list of strings, removes any string that contains a numerical digit or \n    an odd number of characters, sorts remaining strings in ascending order by both length and alphabetically, \n    and then returns the sorted list.\n    \n    Achieves this by using list comprehension to filter out unwanted elements, \n    and Python's built-in sorted function to sort the list. The sorted function uses a compound sorting key \n    consisting of the length of each element and the element itself, allowing for sorting by multiple criteria.\n    \n    The ordering of the sorted list can be reversed by supplying a second argument of True.\n\n    Parameters:\n    lst (list): A list of strings to be filtered and sorted.\n    reverse (bool): Optional parameter to reverse the order of the sorted list. Defaults to False.\n\n    Returns:\n    list: The sorted list of strings.\n    \"\"\"\n    \n    # Filter out any strings containing numerical digits or with odd length\n    lst = [i for i in lst if not any(j.isdigit() for j in i) and len(i) % 2 == 0]\n    \n    # Return the list sorted by length and then alphabetically, in ascending or descending order\n    return sorted(lst, key=lambda x: (len(x), x), reverse=reverse)", "def check_anagram_segments(text: str) -> bool:\n    \"\"\"\n    Given an input string, the function is intended to determine whether it is possible to \n    divide the string into two or more segments that are anagrams of one another. \n\n    Anagrams are words or phrases formed by reordering the letters of a different word or phrase, \n    typically using all the original letters exactly once.\n\n    The function counts the frequency of each unique character in the string and stores it in a dictionary. \n    If all frequencies are even number then the function returns True as the string can be divided into \n    two or more segments that are anagrams of one another. \n    \n    But if there is more than one character with an odd count frequency, then the function returns False\n    as it is not possible to divide the string into segments that are anagrams of one another. \n\n    Parameters:\n    text (str): The string to check for anagram segments\n\n    Returns:\n    bool: True if the string can be divided into anagram segments, False otherwise.\n\n    Examples:\n    \n    >>> check_anagram_samples('abcdefabcdegf')\n    True\n    >>> check_anagram_samples('helloworld')\n    False\n    \"\"\"\n\n    # count the frequency of each unique character in the string\n    frequency = {}\n    for char in text:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n\n    # count characters with odd count frequency\n    count_odd = sum(1 for count in frequency.values() if count % 2)\n\n    return count_odd <= 1"]}
{"task_id": 69, "content": ["def calculate_fibonacci(n):\n    \"\"\"\n    This function calculates the nth number of the Fibonacci sequence using iteration.\n    \n    Parameters:\n        n (int): The number in the Fibonacci sequence to calculate.\n        \n    Returns:\n        The nth number of the Fibonacci sequence.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    a, b = 0, 1\n    for i in range(2, n+1):\n        c = a + b\n        a, b = b, c\n        \n    return b", "def fibonacci_while(n):\n    \"\"\"\n    A function to compute and output the nth Fibonacci number using a while loop.\n    \"\"\"\n    \n    #initialize the first two terms\n    term1 = 0\n    term2 = 1\n    count = 2\n    \n    #check if it is the first or second number\n    if n == 1:\n        return term1\n    elif n == 2:\n        return term2\n    \n    #find the nth term\n    while count < n:\n        nth_term = term1 + term2\n        term1 = term2\n        term2 = nth_term\n        count += 1\n    \n    return nth_term", "def calculate_geometric_mean(num_list):\n    product = 1  # This variable will hold the multiplied result of all numbers in the num_list\n\n    for num in num_list:\n        # Multiply each number in num_list with the product\n        product *= num \n\n    # Calculate the geometric mean by taking the nth root of product\n    # where n is the number of elements in the list.\n    # The math.pow function calculates the power of a number.\n    # Since we need to calculate the nth root, the power is 1/n.\n    geometric_mean = math.pow(product, 1/len(num_list))\n\n    return geometric_mean", "def nth_fibo(n):\n    '''\n    This function finds the nth number in the Fibonacci sequence.\n    \n    Parameters\n    ----------\n    n : int\n        Desired position in the sequence\n    \n    Returns\n    -------\n    int\n        Nth number in the Fibonacci sequence.\n    '''\n    # Initialize variables\n    x = 0\n    y = 1\n    \n    # Iterate through the Fibonacci sequence\n    for _ in range(n-1):\n        x, y = y, x + y\n    \n    # Return the nth number in the Fibonacci sequence\n    return y", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass"]}
{"task_id": 70, "content": ["def transpose(matrix):\n    # The * operator is used to unzip a list (or other iterables), making a list of tuples where each tuple contains the i-th element from each of the argument sequences or iterables.\n    # The zip() function takes iterables, aggregates them in a tuple, and return the result.\n    # In other words, it returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.\n    return [list(i) for i in zip(*matrix)] ", "def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min", "def find_permutations(arr):\n    # itertools.permutations method returns all permutations \n    # of the given list arr of length len(arr).\n    # Each permutation is a tuple so we use map function \n    # to convert these tuples to lists\n    perm = list(map(list, itertools.permutations(arr)))\n    \n    # Return the generated permutations\n    return perm", "def transpose(matrix):\n    \"\"\"Make a function that computes the transpose of a given matrix.\"\"\"\n    return [list(x) for x in zip(*matrix)]", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass"]}
{"task_id": 71, "content": ["def calculate_volume(radius):\n    \"\"\"Function to calculate the volume of a sphere\"\"\"\n    # Check if the input is a non-negative number \n    if radius < 0:\n        return \"Error: The radius should be a non-negative number!\"\n    else:\n        volume = (4/3) * math.pi * (radius ** 3)\n    return volume", "def calculate_volume(radius):\n    \"\"\"Function to calculate the volume of a sphere\"\"\"\n    # check if the input is non-negative number \n    if radius < 0:\n        return \"Error: The radius should be a non-negative number!\"\n    else:\n        volume = (4/3) * math.pi * (radius ** 3)\n    return volume", "def sphere_calculations():\n    while True:\n        try:\n            radius = float(input('Enter the radius of the sphere: '))\n            operation = input('Type \"a\" to calculate the surface area or \"v\" to calculate the volume: ')\n\n            if operation.lower() == 'a':\n                result = calculate_sphere_area(radius)\n                print(f'The surface area of the sphere is {result:.2f}')\n                \n            elif operation.lower() == 'v':\n                result = calculate_sphere_volume(radius)\n                print(f'The volume of the sphere is {result:.2f}')\n                \n            else:\n                print('Invalid operation choice. Please, type \"a\" for area or \"v\" for volume.')\n                continue\n\n            break\n            \n        except ValueError as e:\n            print(e)\n            continue", "def volume(r):\n    '''Calculates the volume of a sphere given its radius'''\n    if r < 0:\n        raise ValueError(\"Radius cannot be negative. Please provide a non-negative input.\")\n    PI = 3.14159\n    return (4/3) * PI * (r**3)", "def vol_sphere(r):\n    '''Calculate the volume of a sphere with a given radius'''\n    return (4/3) * math.pi * r**3"]}
{"task_id": 72, "content": ["def find_index_of_first_occurrence(string, character):\n    '''\n    This function will find the index of the first occurrence of a given character in a string.\n\n    Args:\n        string (str): the string to be searched\n        character (str): the character to be searched for\n\n    Returns:\n        int: the index of the first occurrence of the character\n    '''\n    return string.find(character)", "def find_pallindrome(characters):\n    \"\"\"\n    Generates a palindrome string with a set of given characters.\n    \n    Args:\n        characters (list): The set of characters from which to generate a palindrome string\n    \n    Returns:\n        string (str): A palindromic string generated from the given characters\n    \"\"\"\n    palindrome = ''\n    while len(characters) > 0:\n        # Append a character to the palindrome\n        char = characters.pop(0)\n        palindrome += char\n        \n        # Append the same character to the end of the string\n        palindrome += char\n    \n    return palindrome", "def contains_characters(url, characters):\n    '''\n    This function will determine if a given URL contains certain characters.\n    \n    Args:\n        url (str): the URL to be checked\n        characters (list): a list of characters to be searched\n\n    Returns:\n        bool: True if the URL contains any of the given characters, False otherwise\n    '''\n    for character in characters:\n        if character in url:\n            return True\n    \n    return False", "def highest_occurring_character(string):\n    \"\"\"Find the highest occurring character in a string.\"\"\"\n\n    # Initialise a dictionary to store the number of occurrences of each character\n    char_occurrences = {}\n\n    # Store the number of occurrences of each character\n    for char in string:\n        char_occurrences[char] = char_occurrences.get(char, 0) + 1\n\n    # Find the maximum occurrence of all the characters\n    max_occurrence = 0\n    highest_occurring_char = None\n\n    # Iterate over the occurrence dictionary to find the highest occurrence\n    for char, occurrence in char_occurrences.items():\n        if occurrence > max_occurrence:\n            max_occurrence = occurrence\n            highest_occurring_char = char\n\n    return highest_occurring_char", "def add_digits(number):\n    \"\"\"This function adds all the digits of a given number \n    and returns the result.\n    \n    Args:\n        number (int): The number to process.\n    \n    Returns:\n        int: The result of adding all the digits of the given number.\n    \"\"\"\n    if number < 10:\n        return number\n    total = number % 10 + add_digits(number // 10)\n    return total"]}
{"task_id": 73, "content": ["def fibonacci(n):\n    # Create an array to store the Fibonacci sequence\n    fib_sequence = [0] * (n + 1)\n    \n    # Base cases\n    fib_sequence[0] = 0\n    fib_sequence[1] = 1\n    \n    # Calculate the Fibonacci sequence up to the n-th number\n    for i in range(2, n + 1):\n        fib_sequence[i] = fib_sequence[i - 1] + fib_sequence[i - 2]\n    \n    # Return the n-th number in the Fibonacci sequence\n    return fib_sequence[n]", "def calculate_fibonacci(n):\n    \"\"\"\n    Calculates the n-th Fibonacci number.\n    Args:\n        n: the n-th Fibonacci number.\n    Returns:\n        The Fibonacci number at a given index.\n    \"\"\"\n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    # Calculate n-th Fibonacci number\n    return calculate_fibonacci(n-1) + calculate_fibonacci(n-2)", "def match_parens(lst):\n    \"\"\"\n    This function will find all the sequence permutations, test each permutation for a correct nesting, and provide answers \n    for each sequence. \n    The function will return a dictionary where the key is the permutation and the value is 'Yes' if it's a valid nested string \n    otherwise 'No'.\n    \"\"\"\n    sequences = generate_sequences(lst)\n    return {sequence: check_nested_sequences(sequence) for sequence in sequences}", "def match_parens(lst):\n    '''\n    This function will find all the sequence permutations, test each permutation for a correct nesting, and provide answers \n    for each sequence. \n    The function will return a dictionary where the key is the permutation and the value is 'Yes' if it's a valid nested string \n    Otherwise 'No',\n    '''\n    sequences = generate_sequences(lst)\n    return {sequence: check_nested_sequences(sequence) for sequence in sequences}", "def calculate_fibonacci(n):\n    \"\"\"\n    This function calculates the nth number of the Fibonacci sequence using iteration.\n    \n    Parameters:\n        n (int): The number in the Fibonacci sequence to calculate.\n        \n    Returns:\n        The nth number of the Fibonacci sequence.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    a, b = 0, 1\n    for i in range(2, n+1):\n        c = a + b\n        a, b = b, c\n        \n    return b"]}
{"task_id": 74, "content": ["def sphere_calculations():\n    while True:\n        try:\n            radius = float(input('Enter the radius of the sphere: '))\n            operation = input('Type \"a\" to calculate the surface area or \"v\" to calculate the volume: ')\n\n            if operation.lower() == 'a':\n                result = calculate_sphere_area(radius)\n                print(f'The surface area of the sphere is {result:.2f}')\n                \n            elif operation.lower() == 'v':\n                result = calculate_sphere_volume(radius)\n                print(f'The volume of the sphere is {result:.2f}')\n                \n            else:\n                print('Invalid operation choice. Please, type \"a\" for area or \"v\" for volume.')\n                continue\n\n            break\n            \n        except ValueError as e:\n            print(e)\n            continue", "def sphere_surface_area(radius):\n    '''\n    Computes the surface area of a sphere given its radius\n    '''\n    return 4 * 3.14 * (radius ** 2)", "def calculate_surface_area(radius):\n    '''\n    This function calculates the surface area of a sphere given a radius. \n    It checks to ensure that the radius is a positive number.\n    '''\n    if not isinstance(radius, (int, float)):\n        raise TypeError(\"The radius must be a numeric value.\")\n    elif radius < 0:\n        raise ValueError(\"The radius cannot be negative.\")\n    \n    surface_area = 4 * math.pi * (radius ** 2)\n    return round(surface_area, 2)", "def find_surface_area(length, breadth, height):\n    '''\n    This function calculates the surface area of a cuboid.\n    Input: length, breadth, height - these are the three dimensions of the cuboid\n    Output: total surface area of the cuboid \n    '''\n    # Formula of Surface Area of Cuboid = 2(lb + bh + hl)\n    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area", "def find_surface_area(length, breadth, height):\n    '''\n    This function calculates the surface area of a cuboid.\n    Input: length, breadth, height - these are the three dimensions of the cuboid\n    Output: total surface area of the cuboid \n    '''\n    # Formula of Surface Area of Cuboid = 2(lb + bh + hl)\n    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area"]}
{"task_id": 75, "content": ["def findPentagonalHexagonalNumber():\n    n = 144  # Start from the first number after 143, which is known to be both pentagonal and hexagonal\n    while True:\n        hexagonal = n * (2 * n - 1)  # Formula for generating hexagonal numbers\n        if isPentagonal(hexagonal):  # Check if the number is pentagonal\n            return hexagonal\n        n += 1\n    return None  # Return None if no such number is found", "def calculate_fibonacci(n):\n    \"\"\"\n    This function calculates the nth number of the Fibonacci sequence using iteration.\n    \n    Parameters:\n        n (int): The number in the Fibonacci sequence to calculate.\n        \n    Returns:\n        The nth number of the Fibonacci sequence.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    a, b = 0, 1\n    for i in range(2, n+1):\n        c = a + b\n        a, b = b, c\n        \n    return b", "def fibonacci_while(n):\n    \"\"\"\n    A function to compute and output the nth Fibonacci number using a while loop.\n    \"\"\"\n    \n    #initialize the first two terms\n    term1 = 0\n    term2 = 1\n    count = 2\n    \n    #check if it is the first or second number\n    if n == 1:\n        return term1\n    elif n == 2:\n        return term2\n    \n    #find the nth term\n    while count < n:\n        nth_term = term1 + term2\n        term1 = term2\n        term2 = nth_term\n        count += 1\n    \n    return nth_term", "def calculate_geometric_mean(num_list):\n    product = 1  # This variable will hold the multiplied result of all numbers in the num_list\n\n    for num in num_list:\n        # Multiply each number in num_list with the product\n        product *= num \n\n    # Calculate the geometric mean by taking the nth root of product\n    # where n is the number of elements in the list.\n    # The math.pow function calculates the power of a number.\n    # Since we need to calculate the nth root, the power is 1/n.\n    geometric_mean = math.pow(product, 1/len(num_list))\n\n    return geometric_mean", "def nth_fibo(n):\n    '''\n    This function finds the nth number in the Fibonacci sequence.\n    \n    Parameters\n    ----------\n    n : int\n        Desired position in the sequence\n    \n    Returns\n    -------\n    int\n        Nth number in the Fibonacci sequence.\n    '''\n    # Initialize variables\n    x = 0\n    y = 1\n    \n    # Iterate through the Fibonacci sequence\n    for _ in range(n-1):\n        x, y = y, x + y\n    \n    # Return the nth number in the Fibonacci sequence\n    return y"]}
{"task_id": 76, "content": ["def combine_dicts(dict1, dict2):\n    '''Combines two dictionaries into a single dictionary'''\n    dict3 = dict1.copy()\n    dict3.update(dict2)\n    return dict3", "def write_payload(hollowed_process, payload):\n    # Use Windows API to write the payload into the hollowed memory space\n    # This would involve calling functions like WriteProcessMemory to write the payload.\n    # For simulation purposes, we will only print a message.\n    print(f\"Writing payload into process with PID: {hollowed_process.pid}\")", "def mergeDictionaries(dict1, dict2):\n    '''This function takes two python dictionaries as inputs and returns a single merged dictionary.'''\n\n    # Create a new empty dictionary\n    merged_dict = {}\n\n    # Iterate over the two argument dictionaries and add the key-value pairs to the new dictionary\n    for key, value in dict1.items():\n        merged_dict[key] = value\n    for key, value in dict2.items():\n        merged_dict[key] = value\n\n    # Return the merged dictionary\n    return merged_dict", "def write_to_csv(strings: List[str]) -> None:\n    # Concatenate all the strings into a single string separated by commas\n    csv_content = ','.join(strings)\n    \n    # Write the resulting string to a CSV file\n    with open('outcsv.csv', 'w') as outfile:\n        outfile.write(csv_content)", "def merge_dicts(*dict_args):\n    '''\n    Given any number of dictionaries, shallow copy and merge into a new dictionary,\n    precedence goes to key-value pairs in latter dictionaries.\n    '''\n    result = {}\n    for dictionary in dict_args:\n        result.update(dictionary)\n    return result"]}
{"task_id": 77, "content": ["def frequencySort(nums):\n    # collections.Counter(nums) gives the frequency of each element in the nums array.\n    # items() function returns a view object that displays a list of a dictionary's(an iterable) tuple pair (key, value).\n    c = Counter(nums).items()\n    # Then we will sort the results by the tuple (-count, num). Negative count ensures that high frequency elements come first in the sorted list.\n    # This satisfies the requirement to sort in increasing frequency. \n    # Because we use num for sort as well, elements with the same frequency are sorted in descending order.\n    # This satisfies the requirement to sort in decreasing order on the basis of value of the numbers in case of same frequency.\n    # idx is used to sort elements in increasing order of their index in case elements are same and have same frequency.\n    # sort function of python is stable. i.e, it maintains the relative order of items with equal sort keys\n    nums.sort(key = lambda x: (nums.count(x), -x, [i for i, n in enumerate(nums) if n == x][0]))\n    # return the sorted array\n    return nums", "def uncommon_elements(sequence):\n    # Use collections.Counter to count elements in sequence\n    # and get a dictionary where keys are the elements and values are the frequencies.\n    counter = collections.Counter(sequence)\n    \n    # Create a list 'elements' to store elements which frequency is greater than half of their own value.\n    elements = []\n    \n    for k, v in counter.items():\n        if v > k / 2:\n            elements.append((v, k))\n    \n    # Use a priority queue to organize the elements based on their frequencies and values.\n    # The priority is determined by the frequency first and then the integer.\n    hq = [(-v, k) for v, k in elements]\n    \n    # Organize the heap.\n    heapq.heapify(hq)\n    \n    # Dequeue the heap and append the elements to the result list in descending order of their frequencies\n    # and ascending order for elements with the same frequency.\n    result = [heapq.heappop(hq)[1] for _ in range(len(hq))]\n    \n    return result", "def calculate_aggregate_unique_elements(lst):\n    # Transform the list into a set to get unique elements.\n    # The sum function calculates the aggregate of unique elements.\n    aggregate = sum(set(lst))\n  \n    # The len function returns the quantity of unique elements.\n    quantity = len(set(lst))\n\n    return aggregate, quantity", "def max_frequency(data):\n    # Count the frequency of each element in the list using Counter\n    freq = Counter(data)\n    # Get the element with maximum frequency using the max function\n    max_freq_element = max(freq, key=freq.get)\n    # Get the maximum frequency\n    max_freq = freq[max_freq_element]\n    print(f'Element with maximum frequency is {max_freq_element} with a frequency of {max_freq}')", "def max_frequency(data):\n    # Count the frequency of each element in the list using Counter\n    freq = Counter(data)\n    # Get the element with maximum frequency using the max function\n    max_freq_element = max(freq, key=freq.get)\n    # Get the maximum frequency\n    max_freq = freq[max_freq_element]\n    print(f'Element with maximum frequency is {max_freq_element} with a frequency of {max_freq}')"]}
{"task_id": 78, "content": ["def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, yet is smaller than n\n    >>> largest_divisor(-15)\n    5\n    \"\"\"\n    # convert the number to absolute\n    n = abs(n)\n    if n < 2:\n        return None\n    # check for all divisors starting from half of the number\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, yet, is smaller than n\n    >>> largest_divisor(-15)\n    5\n    \"\"\"\n    # convert the number to absolute\n    n = abs(n)\n    if n < 2:\n        return None\n    # Check for all divisors starting from half of the number\n    for i in range(n//2, 0, -1): \n        if n % i == 0:\n            return i", "def get_closest_centroid(centroids, point):\n    # initialize the closest centroid and the minimum distance\n    closest_centroid = None\n    min_distance = float('inf')\n    \n    # loop over the centroids and calculate the distance to the point\n    for centroid in centroids:\n        distance = euclidean(centroid, point)\n        \n        # update the closest centroid if the distance is smaller than the current minimum\n        if distance < min_distance:\n            closest_centroid = centroid\n            min_distance = distance\n    \n    # return the closest centroid\n    return closest_centroid", "def closest_prime(n, m):\n    \"\"\"\n    Function to find the closest mth prime number to a given number n.\n    \"\"\"\n\n    primes = []\n    \n    for i in range(n, n + m * 2):\n        for j in range(2, i):\n            if i % j == 0:\n                break\n        else:\n            primes.append(i)\n            \n    if len(primes) >= m + 1:\n        return primes[m]\n    else:\n        return -1", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass"]}
{"task_id": 79, "content": ["def calculate_longest_word_length(text):\n    word_list = text.split()  # Split the text into a list of words\n    longest_word = max(word_list, key=len)  # Find the longest word using the max() function and the key=len\n    longest_word_length = len(longest_word)  # Calculate the length of the longest word\n    return longest_word_length", "def longest_words(string):\n    # Remove punctuation marks and split the string into words\n    words = re.findall(r'\\w+', string)\n    \n    # Find the length of the longest word\n    max_length = max(len(word) for word in words)\n    \n    # Find all the longest words\n    longest_words = [word for word in words if len(word) == max_length]\n    \n    # Print the longest words in reverse order of appearance\n    for word in reversed(longest_words):\n        print(word)", "def max_word_length(string):\n    # Split the string into individual words\n    words = string.split()\n    \n    # Initialize the longest word length as 0\n    longest_word_length = 0\n    \n    # Loop through the words and find the longest word\n    for word in words:\n        if len(word) > longest_word_length:\n            longest_word_length = len(word)\n    \n    # Return the longest word length\n    return longest_word_length", "def longest_word(words):\n    longest = 0\n    for word in words:\n        # split the word into substrings delimited by whitespace, punctuation, or digits\n        substrings = re.split(r'[\\s\\W\\d]+', word)\n        # find the length of the longest substring\n        for substring in substrings:\n            if len(substring) > longest:\n                longest = len(substring)\n    return longest", "def find_longest_words(word_list):\n    # find the maximum length of words in the list\n    max_len = max(len(word) for word in word_list)\n\n    # get a list of all longest words\n    longest_words = [word for word in word_list if len(word) == max_len]\n\n    return longest_words"]}
{"task_id": 80, "content": ["def check_if_substring(string1, string2):\n    \"\"\"This function checks if a given string (string1) is a\n    substring of the other given string (string2).\n\n    Args:\n        string1 (str): The string that might be a substring of string2.\n        string2 (str): The string to check if string1 is a substring.\n\n    Returns:\n        bool: True if string1 is a substring of string2, False otherwise.\n    \"\"\"\n    if string1 in string2:\n        return True\n    else:\n        return False", "def find_substring(string, substring):\n    \"\"\"\n    This function takes a given string and a substring as input and returns True if the substring is found in the string.\n    \"\"\"\n    if substring in string:\n        return True\n    else:\n        return False", "def substring_filter(string_list, substring):\n    \"\"\"\n    This function takes a list of strings and a substring to search for. It returns a new list with the strings\n    that contain the substring.\n    \"\"\"\n    filtered_list = []\n    for string in string_list:\n        if substring in string:\n            filtered_list.append(string)\n    return filtered_list", "def find_target(numbers, target):\n    \"\"\"This function returns True if the target is present in the given list of numbers.\"\"\"\n    num_set = set(numbers)  # Convert the list into a set for faster lookup\n    if target in num_set:  # Check if the target exists in the set\n        return True\n    return False", "def is_item_in_list(item, my_list):\n    '''This function checks if an item exists in a given list and returns a boolean value.\n    Parameters\n    ----------\n    item: The item to be checked.\n    my_list: The list in which the item is to be checked. \n    \n    Returns\n    --------\n    boolean: True if the item is present in the list, and False if it is not.\n    '''\n\n    return item in my_list"]}
{"task_id": 81, "content": ["def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True", "def is_multiple(n):\n    \"\"\"\n    Function to check if a given number is a multiple of 3 or 5.\n    \n    Parameters: \n    n (int): The given number to check.\n    \n    Returns: \n    bool: True if number is a multiple of 3 or 5, False otherwise.\n    \"\"\"\n    return n % 3 == 0 or n % 5 == 0", "def is_palindrome(s): \n    '''This function returns True or False based on whether the given string is a palindrome or not'''\n    # reverse the string\n    rev = s[::-1] \n  \n    # Check if string is equal to its reverse \n    if (s == rev): \n        return True\n    return False", "def is_numeric(val):\n    \"\"\"\n    Check if a given value is numeric\n\n    :param val: The value to be checked\n    :return: A boolean indicating whether the given value is numeric or not\n    \"\"\"\n    return val.isnumeric()", "def is_valid_radius(radius):\n    \"\"\"\n    This function checks whether the given input is a valid radius or not.\n    It returns True if it's a positive real number, else it returns False.\n    \"\"\"\n    if isinstance(radius, (int, float)) and radius > 0:\n        return True\n    else:\n        return False"]}
{"task_id": 82, "content": ["def gcd(a, b):\n    '''\n    Function to calculate the GCD of two numbers\n    :param a: The first number\n    :param b: The second number\n    :return: The GCD of the two numbers\n    ''' \n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)", "def exponentiation(a, b):\n    \"\"\"Returns a to the power of b\"\"\"\n    return float('%.3f' % (pow(a, b)))", "def exponentiation(a, b):\n    \"\"\"return a to the power of b\"\"\"\n    return float('%.3f'%(exp(b * log(a))))", "def hamming_weight(byte):\n    # Implement this function to calculate the Hamming weight of a byte.\n    # The Hamming weight is the number of 1's in the byte.\n    # This can be done using a bitwise operation that counts the number of bits set to 1.\n    return bin(byte).count('1')", "def peculiar_ordering(lst, d):\n    '''\n    Given a list of integers and a dictionary with integer keys and unique string values, return the list in a special order.\n    \n    normalize the input list to have a mean of zero and a standard deviation of one.\n    \n    For each element in the list, append its corresponding string value from the dictionary to a new list.\n    The peculiarity of ordering the string values extends to removing any duplicate string values in the new list no matter how often they appear in the original list.\n    \n    Then order this new list in a peculiar manner:\n    - Start with the string associated with the minimal value integer.\n    - Then, find the string associated with the maximum remaining integer.\n    - Next, find the string associated with the minimum remaining integer, and so on.\n    The function should also handle negative integers, and decimal numbers and there should be a mapping provided for them in the dictionary. \n\n    For example:\n    peculiar_ordering([1, 2, 3, 4, 5], {1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e'}) == ['a', 'b', 'c', 'd','e']\n    Note: In the example, 'a' represents 1, 'b' represents 2, etc.\n    '''\n    # normalize the input list\n    lst = [(i - np.mean(lst)) / np.std(lst) for i in lst]\n\n    value_order = []\n\n    for v in lst:\n        value = d.get(v)\n        \n        if value not in value_order:\n            value_order.append(value)\n\n    # sort the values in a peculiar order\n    value_order = sorted(value_order, key=lambda x: (value_order.index(x) % 2, x))\n\n    return value_order"]}
{"task_id": 83, "content": ["def detect_duplicates(data):\n    \"\"\"\n    Algorithm to detect duplicate records in a dataset.\n\n    :param data: array of records to be searched for duplicates\n    :return: list of tuples containing the indices of the detected duplicates\n    \"\"\"\n    seen = set()\n    duplicates = []\n\n    for index, record in enumerate(data):\n        if record not in seen:\n            seen.add(record)\n        else:\n            duplicates.append((index, record))\n    \n    return duplicates", "def search_index(command):\n    # Split the command to extract index name and search query\n    parts = command.split(\"--index=\")\n    index_name = parts[1].split()[0].strip('\\\"')\n\n    query_parts = command.split(\"--query=\")\n    query = query_parts[1].strip('\\\"')\n\n    # Extract field, comparison operator, and value from the query\n    field, comparison_operator, value = query.split()\n    value = value.strip('\\'')  # Remove single quotes from the value\n\n    # Perform the search operation on the specified index using the given query\n    # Assume a function search_in_index(index_name, field, comparison_operator, value) is available\n    results = search_in_index(index_name, field, comparison_operator, value)\n\n    return results", "def search_for_index(array, value):\n    '''\n    This function will search for the index of a given value in an array.\n    \n    Args:\n        array (list): the array to be searched\n        value (object): the value to be searched for\n\n    Returns:\n        int: the index of the value if found, -1 otherwise\n    '''\n    try:\n        return array.index(value)\n    except ValueError:\n        return -1", "def find_min(arr):\n    # Initialize variables to store the minimum value and its index\n    min_val = arr[0]\n    min_index = 0\n    \n    # Iterate through the array starting from the second element\n    for i in range(1, len(arr)):\n        # Check if the current element is smaller than the current minimum value\n        if arr[i] < min_val:\n            # Update the minimum value and its index\n            min_val = arr[i]\n            min_index = i\n    \n    # Return the minimum value and its index\n    return min_val, min_index", "def random_number(minimum, maximum):\n    '''This function takes a minimum and maximum number and generates a random number within the given range.'''\n    return random.randint(minimum, maximum)"]}
{"task_id": 84, "content": ["def inject_payload(pid, payload):\n    # This function would need to be implemented to attach to the process,\n    # find the system call table, and modify it to point to the custom handler.\n    # This is a complex task that typically requires kernel-level access and\n    # is beyond the scope of a simple Python script.\n    pass", "def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min", "def make_palindrome(string: str) -> int:\n    \"\"\" Find the minimum number of characters that need to be added at the end of the supplied string to make it a palindrome, ignoring case, non-alphanumeric characters, and spaces between words.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Compute the length of the string prefix that comes before the palindromic suffix.\n    - Return the length of the prefix as the minimum number of characters needed to create the shortest possible palindrome.\n    \"\"\"\n    filtered_string = ''.join(char.lower() for char in string if char.isalnum())\n    \n    for i in range(len(filtered_string)):\n        if is_palindrome(filtered_string[i:]):\n            return i", "def make_palindrome(string: str) -> int:\n    \"\"\"\n    Find the minimum number of characters that need to be added at the end of the supplied string to make it a palindrome, \n    ignoring case, non-alphanumeric characters, and spaces between words.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome,\n    - Compute the length of the string prefix that comes before the palindrome suffix.\n    - Return the length of the prefix as the minimum number of characters needed to create the shortest possible palindrome.\n    \"\"\"\n    filtered_string = ''.join(char.lower() for char in string if char.isalnum())\n\n    for i in range(len(filtered_string)):\n        if is_palindrome(filtered_string[i:]):\n            return i", "def validate_length(input_string, a=5, b=15):\n    # Using len() function to find the length of the string\n    length = len(input_string)\n\n    # check if length of string is within the span [a, b]\n    if a <= length <= b:\n        print(\"The length of the inputted lexical item is within the predefined span.\")\n    else:\n        print(\"The length of the inputted lexical item is not within the predefined span.\")"]}
{"task_id": 85, "content": ["def check_integer(number):\n    if number % 2 == 0:\n        if number % 3 == 0:\n            print(\"The given integer is even and a multiple of 3.\")\n        else:\n            print(\"The given integer is even and not a multiple of 3.\")\n    else:\n        if number % 3 == 0:\n            print(\"The given integer is odd and a multiple of 3.\")\n        else:\n            print(\"The given integer is odd and not a multiple of 3.\")", "def multiply_with_range(number):\n    \"\"\"Multiply a number with all integers within a range\n    \n    This function takes a single argument, a number (integer), and \n    returns a list. The elements of this list are results of the \n    number multiplied with every integer from 1 to the number itself.\n\n    Args:\n        number (int): the number to be multiplied with all the integers in range\n\n    Returns:\n        list: a list of results from multiplying the number with each integer \n        within the range\n    \"\"\"\n    multiplied_list = [number * i for i in range(1, number + 1)]\n    return multiplied_list", "def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def sum_divisors(n):\n    '''Returns the sum of all divisors of the given number.'''\n    if n <= 1:\n        return 0\n    #assume n is a positive integer\n    sum_divisors = 1\n    for i in range(2, int(n/2)+1):\n        if n % i == 0:\n            sum_divisors += i\n    return sum_divisors", "def add_digits(number):\n    \"\"\"This function adds all the digits of a given number \n    and returns the result.\n    \n    Args:\n        number (int): The number to process.\n    \n    Returns:\n        int: The result of adding all the digits of the given number.\n    \"\"\"\n    if number < 10:\n        return number\n    total = number % 10 + add_digits(number // 10)\n    return total"]}
{"task_id": 86, "content": ["def find_word(word, paragraph):\n    \"\"\" \n    This function is used to find the frequency and index positions of a specific word in a paragraph. \n\n    Args: \n    word (str): The word to find in the paragraph.\n    paragraph (str): The paragraph \n\n    Returns: \n    tuple: A tuple containing the frequency of word and a list of index positions. \n    If the word is not found, it returns a message saying so.\n    \"\"\"\n    \n    # The paragraph is converted to lower case for a case-insensitive search\n    lower_paragraph = paragraph.lower()\n\n    # The word is also turned to lower case\n    lower_word = word.lower()\n\n    # Find the frequency of the word\n    count = lower_paragraph.count(lower_word)\n    \n    # If count is zero, return appropriate message\n    if count == 0:\n        return \"The word is not found in the paragraph\"\n\n    # Find the positions of the word\n    index = 0\n    index_list = []\n    for _ in range(count):\n        next_index = lower_paragraph.index(lower_word, index)\n        \n        # Append actual index by ignoring leading spaces or punctuation\n        index_list.append(next_index + paragraph[next_index:].index(lower_word)) \n        index = next_index + len(lower_word)\n\n    # return the results\n    return count, index_list", "def check_anagram_segments(text: str) -> bool:\n    \"\"\"\n    Given an input string, the function is intended to determine whether it is possible to \n    divide the string into two or more segments that are anagrams of one another. \n\n    Anagrams are words or phrases formed by reordering the letters of a different word or phrase, \n    typically using all the original letters exactly once.\n\n    The function counts the frequency of each unique character in the string and stores it in a dictionary. \n    If all frequencies are even number then the function returns True as the string can be divided into \n    two or more segments that are anagrams of one another. \n    \n    But if there is more than one character with an odd count frequency, then the function returns False\n    as it is not possible to divide the string into segments that are anagrams of one another. \n\n    Parameters:\n    text (str): The string to check for anagram segments\n\n    Returns:\n    bool: True if the string can be divided into anagram segments, False otherwise.\n\n    Examples:\n    \n    >>> check_anagram_samples('abcdefabcdegf')\n    True\n    >>> check_anagram_samples('helloworld')\n    False\n    \"\"\"\n\n    # count the frequency of each unique character in the string\n    frequency = {}\n    for char in text:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n\n    # count characters with odd count frequency\n    count_odd = sum(1 for count in frequency.values() if count % 2)\n\n    return count_odd <= 1", "def calculate_mode(numbers):\n    # Create a dictionary to store the frequency of each number\n    frequency = {}\n\n    # Iterate through the list and count the frequency of each number\n    for num in numbers:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n\n    # Find the maximum frequency\n    max_freq = max(frequency.values())\n\n    # Find all numbers with the maximum frequency\n    mode = [num for num, freq in frequency.items() if freq == max_freq]\n\n    return mode", "def frequencySort(nums):\n    # collections.Counter(nums) gives the frequency of each element in the nums array.\n    # items() function returns a view object that displays a list of a dictionary's(an iterable) tuple pair (key, value).\n    c = Counter(nums).items()\n    # Then we will sort the results by the tuple (-count, num). Negative count ensures that high frequency elements come first in the sorted list.\n    # This satisfies the requirement to sort in increasing frequency. \n    # Because we use num for sort as well, elements with the same frequency are sorted in descending order.\n    # This satisfies the requirement to sort in decreasing order on the basis of value of the numbers in case of same frequency.\n    # idx is used to sort elements in increasing order of their index in case elements are same and have same frequency.\n    # sort function of python is stable. i.e, it maintains the relative order of items with equal sort keys\n    nums.sort(key = lambda x: (nums.count(x), -x, [i for i, n in enumerate(nums) if n == x][0]))\n    # return the sorted array\n    return nums", "def combine_lists(*lists):\n    '''This function takes any number of lists and combines them into a single list.'''\n    combined_list = []\n\n    for list in lists:\n        for item in list:\n            combined_list.append(item)\n\n    return combined_list"]}
{"task_id": 87, "content": ["def multiply_with_range(number):\n    \"\"\"Multiply a number with all integers within a range\n    \n    This function takes a single argument, a number (integer), and \n    returns a list. The elements of this list are results of the \n    number multiplied with every integer from 1 to the number itself.\n\n    Args:\n        number (int): the number to be multiplied with all the integers in range\n\n    Returns:\n        list: a list of results from multiplying the number with each integer \n        within the range\n    \"\"\"\n    multiplied_list = [number * i for i in range(1, number + 1)]\n    return multiplied_list", "def product_list(numbers):\n    \"\"\"\n    Function to calculate the cumulative product of all integers in a supplied list.\n\n    :param numbers: list of numbers\n    :return: cumulative product from the list\n    \"\"\"\n\n    # Initialize variable to store the result\n    result = 1\n\n    # Loop through each number in the list\n    for num in numbers:\n        # Multiply the result by the current number\n        result *= num\n\n    # Return the final product\n    return result", "def check_product_prime(numbers):\n\n    \"\"\" function to check if product of a list is prime\"\"\"\n    \n    # initial product is 1\n    product = 1\n    \n    # multiply all numbers in the list\n    for num in numbers:\n        product *= num\n    \n    return check_prime(product)", "def sorted_list_sum(lst, reverse=False):\n    \"\"\"\n    This function takes as input a list of strings, removes any string that contains a numerical digit or \n    an odd number of characters, sorts remaining strings in ascending order by both length and alphabetically, \n    and then returns the sorted list.\n    \n    Achieves this by using list comprehension to filter out unwanted elements, \n    and Python's built-in sorted function to sort the list. The sorted function uses a compound sorting key \n    consisting of the length of each element and the element itself, allowing for sorting by multiple criteria.\n    \n    The ordering of the sorted list can be reversed by supplying a second argument of True.\n\n    Parameters:\n    lst (list): A list of strings to be filtered and sorted.\n    reverse (bool): Optional parameter to reverse the order of the sorted list. Defaults to False.\n\n    Returns:\n    list: The sorted list of strings.\n    \"\"\"\n    \n    # Filter out any strings containing numerical digits or with odd length\n    lst = [i for i in lst if not any(j.isdigit() for j in i) and len(i) % 2 == 0]\n    \n    # Return the list sorted by length and then alphabetically, in ascending or descending order\n    return sorted(lst, key=lambda x: (len(x), x), reverse=reverse)", "def square_elements(input_data):\n    \"\"\"\n    Function to return the square of a complex number or a list of complex numbers.\n    \n    Parameters:\n    input_data (complex/list of complex numbers): A complex number or list of complex numbers to square.\n\n    Returns:\n    complex/list: Square of the input complex number or list of complex numbers.\n    \"\"\"\n    \n    # Check if input_data is a complex number or a list\n    if isinstance(input_data, complex):\n        return input_data ** 2\n    elif isinstance(input_data, list):\n        # Check if all elements in the list are complex numbers\n        if all(isinstance(ele, complex) for ele in input_data):\n            return [ele ** 2 for ele in input_data]\n        else:\n            raise TypeError(\"All elements in the list must be complex numbers.\")\n    else:\n        raise TypeError(\"Input must be a complex number or a list of complex numbers.\")"]}
{"task_id": 88, "content": ["def checkBinaryPrime(bin_num):\n    # Check if input is valid binary\n    if not isValidBinary(bin_num):\n        return 'Not a valid binary number.'\n    # Convert binary to decimal\n    decimal = int(bin_num, 2) \n    # Check if converted number is prime\n    if isPrime(decimal):\n        return f'The decimal equivalent of {bin_num} is {decimal}, which is a prime number.'\n    else:\n        return f'The decimal equivalent of {bin_num} is {decimal}, which is not a prime number.'", "def binary_to_decimal(n):\n    \"\"\"\n    Converts a binary number to its decimal representation.\n    \n    Args:\n        n (str): The binary number to be converted.\n    \n    Returns:\n        int: The decimal representation of the input binary number.\n    \"\"\"\n    return int(n, 2)", "def binary_to_decimal(binary):\n    \"\"\"Function to convert binary number to decimal\"\"\"\n\n    # Validate the binary input\n    if not set(binary).issubset({'0', '1'}):\n        return 'Error: Input is not a valid binary number'\n        \n    # Initialize decimal as 0    \n    decimal = 0\n\n    # Loop over each digit in the binary string\n    for digit in binary:\n        decimal = decimal*2 + int(digit)\n\n    return decimal", "def binary_to_decimal(binary):\n    \"\"\"Function to convert binary number to decimal\"\"\"\n\n    # Validate the binary input\n    if not set(binary).issubset({'0', '1'}):\n        return 'Error: Input is not a valid binary number'\n        \n    # Initialize decimal as 0    \n    decimal = 0\n\n    # Loop over each digit in the binary string\n    for digit in binary:\n        decimal = decimal*2 + int(digit)\n\n    return decimal", "def decimal_to_binary(n):\n    \"\"\"\n    Converts a decimal number to its binary representation.\n    \n    Args:\n        n (int): The decimal number to be converted.\n    \n    Returns:\n        str: The binary representation of the input decimal number.\n    \"\"\"\n    return bin(n).replace(\"0b\", \"\")"]}
{"task_id": 89, "content": ["def make_palindrome(string: str) -> int:\n    \"\"\" Ascertain the smallest number of characters required to be appended at the string end to make it a palindrome, ignoring case, non-alphanumeric characters and spaces between words.\n    The algorithm:\n    - Isolate the longest palindrome postfix in the given string.\n    - Compute the length of the prefix coming before the palindromic suffix.\n    - Return the length of the prefix as the smallest number of characters necessary to make a shortest possible palindrome.\n    \"\"\"\n    cleaned = ''.join(c.lower() for c in string if c.isalnum())\n    for i in range(len(cleaned)):\n        if is_palindrome(cleaned[i:]):\n            return i", "def make_palindrome(string: str) -> int:\n    \"\"\"\n    Find the minimum number of characters that need to be added at the end of the supplied string to make it a palindrome, \n    ignoring case, non-alphanumeric characters, and spaces between words.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome,\n    - Compute the length of the string prefix that comes before the palindrome suffix.\n    - Return the length of the prefix as the minimum number of characters needed to create the shortest possible palindrome.\n    \"\"\"\n    filtered_string = ''.join(char.lower() for char in string if char.isalnum())\n\n    for i in range(len(filtered_string)):\n        if is_palindrome(filtered_string[i:]):\n            return i", "def find_smallest(numbers):\n    \"\"\"\n    This function takes in a list of numbers and returns the smallest number.\n    :param numbers: list of numbers\n    :returns smallest: smallest number in the list\n    \"\"\"\n\n    try:\n        smallest = numbers[0]\n\n        for num in numbers:\n            if num < smallest:\n                smallest = num\n\n        return smallest\n\n    except Exception as e:\n        print(f\"An error occurred: {str(e)}\")", "def make_palindrome(string: str) -> int:\n    \"\"\" Find the minimum number of characters that need to be added at the end of the supplied string to make it a palindrome, ignoring case, non-alphanumeric characters, and spaces between words.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Compute the length of the string prefix that comes before the palindromic suffix.\n    - Return the length of the prefix as the minimum number of characters needed to create the shortest possible palindrome.\n    \"\"\"\n    filtered_string = ''.join(char.lower() for char in string if char.isalnum())\n    \n    for i in range(len(filtered_string)):\n        if is_palindrome(filtered_string[i:]):\n            return i", "def extract_integer(number: float, precision: int) -> float:\n    \"\"\" Given a float, it breaks down into\n    an integer component (largest integer less or equal to the number) and decimals\n    (remainder always less than 1 and greater than -1).\n\n    The function should return the integer part of the number preserving precision up to a specified decimal point.\n    >>> extract_integer(4.70, 2)\n    4.70\n    >>> extract_integer(-3.200, 3)\n    -3.200\n    \"\"\"\n    decimal_point = Decimal(10) ** -precision  # Defines the decimal point up to the specified precision\n\n    if isinstance(number, (int, float)):\n        number = Decimal(number)  # Create a Decimal instance of the number\n    elif isinstance(number, str):\n        number = Decimal(number.replace(',', '.'))\n\n    return float(number.quantize(decimal_point, rounding=ROUND_DOWN))  # Return the number as a float, rounded to the specified precision"]}
{"task_id": 90, "content": ["def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def find_kth_largest(arr, k):\n    \"\"\"\n    Function to find the kth largest element in an array\n    \"\"\"\n    \n    # make a copy of the array\n    arr_copy = arr[:]\n    \n    # get the length of the array\n    length = len(arr_copy)\n    \n    # if k is greater than or equal to the length of the array, return the maximum element\n    if k >= length:\n        return max(arr_copy)\n        \n    # sort the array in descending order\n    arr_copy.sort(reverse=True)\n    \n    # get the kth element from the sorted array\n    kth_largest = arr_copy[k-1]\n    \n    return kth_largest", "def find_kth_smallest(arr, k):\n    \"\"\"\n    This function finds the kth smallest element in an array.\n    :param arr: array of integers\n    :param k: integer\n    :return: kth smallest element\n    \"\"\"\n    sorted_arr = sorted(arr)\n    return sorted_arr[k-1]", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def find_kth_smallest(arr, k):\n    # Check if k is valid\n    if k > len(arr) or k <= 0:\n        return None\n\n    # Iterate k times to find the kth smallest element\n    for i in range(k):\n        min_element = arr[0]\n        min_index = 0\n\n        # Find the smallest element in the remaining array\n        for j in range(1, len(arr)):\n            if arr[j] < min_element:\n                min_element = arr[j]\n                min_index = j\n\n        # Swap the smallest element to the beginning of the remaining array\n        arr[min_index], arr[i] = arr[i], arr[min_index]\n\n    # Return the kth smallest element\n    return arr[k - 1]"]}
{"task_id": 91, "content": ["def to_camel_case(sentence: str) -> str:\n    words = sentence.split()  # Split the sentence into individual words\n    camel = words[0]  # Initialize the camel case string with the first word\n    for w in words[1:]:  # Iterate through the remaining words\n        camel += w.title()  # Capitalize each word and concatenate to the camel case string\n    return camel", "def to_snake_case(name):\n    # convert camel case to snake case\n    name = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', name)\n    name = re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', name)\n    # replace special characters with underscore\n    name = re.sub('[^\\w\\s]', '_', name)\n    # replace whitespace with underscore\n    name = re.sub('\\s+', '_', name)\n    # convert to lowercase\n    name = name.lower()\n    return name", "def hex_to_bin(hex_string):\n    \"\"\"Function to convert a hexadecimal string into binary string.\"\"\"\n    # Convert to int using base 16 and then convert to binary.\n    bin_string = bin(int(hex_string, 16))[2:]\n    # Add leading zeros in case they were lost\n    bin_string = '0'*(4*len(hex_string) - len(bin_string)) + bin_string\n    return bin_string", "def snake_case_conversion(string):\n    # Regex to split camel case \n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', string)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "def convert_to_upper_case(string):\n    '''This function takes a string as input and converts it to upper case'''\n    return string.upper()"]}
{"task_id": 92, "content": ["def closest_prime(n, m):\n    \"\"\"\n    Function to find the closest mth prime number to a given number n.\n    \"\"\"\n\n    primes = []\n    \n    for i in range(n, n + m * 2):\n        for j in range(2, i):\n            if i % j == 0:\n                break\n        else:\n            primes.append(i)\n            \n    if len(primes) >= m + 1:\n        return primes[m]\n    else:\n        return -1", "def calculate_sum_and_check_prime(m, n):\n    sum_of_evens = 0\n    for num in range(m, n+1):\n        if num % 2 == 0:\n            sum_of_evens += num\n    \n    is_prime_result = is_prime(sum_of_evens)\n    \n    print(\"Sum of even numbers in the range {} to {} is {}\".format(m, n, sum_of_evens))\n    \n    if is_prime_result:\n        print(\"The sum is a prime number.\")\n    else:\n        print(\"The sum is not a prime number.\")\n    \n    return sum_of_evens", "def sum_between_numbers(m: int, n: int) -> int:\n    \"\"\"\n    This function takes two integers, m and n, as input and returns the sum of all the numbers between them (inclusive).\n    \n    Args:\n        m (int): An integer number.\n        n (int): An integer number.\n    \n    Returns:\n        int: The sum of all the numbers between m and n (inclusive).\n    \"\"\"\n    total_sum = 0\n    for i in range(m, n+1):\n        total_sum += i\n    return total_sum", "def write_ssh_key(name, path, key_type, debug):\n    # Function to write SSH key to a file\n    pass", "def generate_random_number(M, N):\n    \"\"\"Generate a random number between M and N.\"\"\"\n    validate_input(M, N)\n    return random.randint(M, N)"]}
{"task_id": 93, "content": ["def sort_desc(words):\n    '''This function will sort a given list of strings in descending order of their lengths.'''\n    words.sort(key=len, reverse=True)\n    return words", "def count_lists(lst):\n    \"\"\"Main function to count number of lists in a list\"\"\"\n    # Flatten all lists in lst and convert them into tuples\n    lst = [tuple(flatten(sublist)) for sublist in lst if isinstance(sublist, list)]\n    \n    # Get the counts of each tuple\n    return {t: lst.count(t) for t in set(lst)}", "def sortByLength(strings):\n    \"\"\"Sort a list of strings according to their lengths\"\"\"\n    # Sort the list using a key function\n    return sorted(strings, key=len)", "def complex_sorted_list(lst, reverse=False, min_sum=0, max_sum=None, sort_function=None, secondary_sort_function=None):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter and performs the following:\n    - Delete strings with odd lengths or containing numerals.\n    - Sort the list based on the sum of the ASCII values of the characters in each string.\n    - The list may contain duplicates, ignore case, and special characters.\n    - Toggle sorting between ascending and descending order using an optional boolean `reverse` (default is False).\n    - Implement an optional minimum sum `min_sum` (default is 0) to return only strings with a sum greater or equal.\n    - Implement an optional maximum sum `max_sum` to return only strings with a sum less than or equal.\n    - Implement an optional custom sorting method `sort_function` to sort strings using a custom function.\n    - Implement an optional secondary custom sorting method `secondary_sort_function` to sort strings using a secondary function.\n    \"\"\"\n\n    # Remove strings with odd lengths and strings containing numerals\n    clean_lst = [s for s in lst if len(s) % 2 == 0 and not any(c.isdigit() for c in s)]\n\n    if not sort_function:\n        sort_function = lambda s: sum(ord(c) for c in s)\n\n    if secondary_sort_function:\n        clean_lst.sort(key=secondary_sort_function)\n\n    # Sort strings based on the sort_function\n    clean_lst.sort(key=sort_function, reverse=reverse)\n\n    # Filter strings based on min_sum and max_sum\n    filtered_lst = [s for s in clean_lst if min_sum <= sort_function(s) <= (max_sum if max_sum else float(\"inf\"))]\n\n    return filtered_lst", "def process_data(data: list) -> list:\n    # Check if the input is a list of lists comprised of strings\n    if not all(isinstance(sublist, list) and all(isinstance(item, str) for item in sublist) for sublist in data):\n        msg = _('Invalid data type, must be a list of lists comprised of strings. '\n                'Sub-lists may not be duplicated. Strings in sub-lists may not be '\n                'duplicated.')\n        raise TypeError(msg)\n\n    # Remove duplicate sub-lists\n    unique_sublists = []\n    for sublist in data:\n        if sublist not in unique_sublists:\n            unique_sublists.append(sublist)\n\n    # Remove duplicate string elements within sub-lists\n    processed_data = []\n    for sublist in unique_sublists:\n        unique_sublist = list(set(sublist))  # Convert to set to remove duplicates, then back to list\n        processed_data.append(unique_sublist)\n\n    return processed_data"]}
{"task_id": 94, "content": ["def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]", "def is_item_in_list(item, my_list):\n    '''This function checks if an item exists in a given list and returns a boolean value.\n    Parameters\n    ----------\n    item: The item to be checked.\n    my_list: The list in which the item is to be checked. \n    \n    Returns\n    --------\n    boolean: True if the item is present in the list, and False if it is not.\n    '''\n\n    return item in my_list", "def contains_characters(url, characters):\n    '''\n    This function will determine if a given URL contains certain characters.\n    \n    Args:\n        url (str): the URL to be checked\n        characters (list): a list of characters to be searched\n\n    Returns:\n        bool: True if the URL contains any of the given characters, False otherwise\n    '''\n    for character in characters:\n        if character in url:\n            return True\n    \n    return False", "def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list"]}
{"task_id": 95, "content": ["def find_permutations(arr):\n    # itertools.permutations method returns all permutations \n    # of the given list arr of length len(arr).\n    # Each permutation is a tuple so we use map function \n    # to convert these tuples to lists\n    perm = list(map(list, itertools.permutations(arr)))\n    \n    # Return the generated permutations\n    return perm", "def related_words(word, words):\n    \"\"\"\n    Function to get an array of words related to the given word.\n    \n    Parameters: \n    word (str) : The given word.\n    words (list) : The list of words to search in.\n\n    Returns:\n    list : The list of words related to the given word.\n    \"\"\"\n\n    related = []\n    for w in words:\n        if word in w or w in word:\n            related.append(w)\n    return related", "def apply_function(arr, f):\n    \"\"\"\n    Apply a given function to each item of an input array.\n    \n    Args:\n        arr (list): The input array.\n        f (function): The function to be applied.\n        \n    Returns:\n        list: A list with the result of applying function f to each item of arr.\n    \"\"\"\n    return list(map(f, arr))", "def my_func():\n  \"\"\"This function adds the number 5 to a given variable\"\"\"\n  # Add 5 to the variable\n  x = variable_name + 5", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count"]}
{"task_id": 96, "content": ["def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def primes(numbers):\n    \"\"\"Generator function to yield prime numbers from a given list.\"\"\"\n    for num in numbers:\n        if is_prime(num):\n            yield num", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass", "def base2to16(base2_num):\n    # Converting binary to decimal using Python's built-in function int()\n    temp_dec = int(str(base2_num), 2)\n    \n    # Converting the decimal to hexadecimal using Python's built-in function hex()\n    # Strip the 0x prefix from the hexadecimal representation\n    dec_to_hex = hex(temp_dec)[2:] \n    \n    return dec_to_hex"]}
{"task_id": 97, "content": ["def merge_sort(a, b): \n    \"\"\"\n    Generate a program to combine two sorted arrays into a sorted array using merge sort.\n    Args:\n        a (list): The first sorted array.\n        b (list): The second sorted array.\n    Returns:\n        list: The sorted array.\n    \"\"\"\n    if len(a) == 0:\n        return b\n    if len(b) == 0:\n        return a\n    if a[0] < b[0]:\n        return [a[0]] + merge_sort(a[1:], b)\n    return [b[0]] + merge_sort(a, b[1:])", "def kth_smallest(lst, n, k):\n    \n    # Using heap queue algorithm to sort list\n    sorted_list = heapq.nsmallest(n, lst)\n    \n    # Return kth smallest number\n    return sorted_list[k-1]", "def lexicographic_sort(text):\n    \"\"\"This function takes a string and generates an array of lexicographically sorted words in the string.\"\"\"\n    # Split string into words\n    words = text.split()\n\n    # Sort using sorted()\n    sorted_words = sorted(words)\n\n    return sorted_words", "def alphabetize_string(s):\n    # Use sorted() function to sort the string and then join back into a string.\n    return ''.join(sorted(s))", "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    # Divide the list into two halves\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    # Recursively sort the left and right halves\n    left = merge_sort(left)\n    right = merge_sort(right)\n    \n    # Merge the sorted halves into a single sorted list\n    return merge(left, right)"]}
{"task_id": 98, "content": ["def binary_to_decimal(binaryNum):\n    try:\n        # Use int() function in python with 2 as base argument to convert binary string into decimal.\n        # int(string, base)\n        return int(binaryNum, 2)\n    except ValueError:\n        # If binaryNum is not a valid binary number, int() function will raise a ValueError.\n        # Return error message in case of exception\n        return \"Invalid binary input\"", "def inorder_traversal(root):\n    \"\"\"Write a function to traverse a binary search tree in-order, printing out the values it encounters.\n\n    :param root: The root node of the binary search tree\n    \"\"\"\n    if not root:\n        return\n\n    inorder_traversal(root.left)\n    print(root.val)\n    inorder_traversal(root.right)", "def can_form_palindrome(s):\n    # Create a dictionary to store the frequency of each character\n    freq = {}\n  \n    # Traverse the given string and count the frequency of each character\n    for char in s:\n        # If the character is already present in the dictionary, increment its count\n        if char in freq:\n            freq[char] += 1\n        else:\n            # Else, add this character to the dictionary\n            freq[char] = 1\n  \n    # Count the characters with odd frequency count\n    odd = 0\n    for k, v in freq.items():\n        # If the count is odd, increment the odd count\n        odd += v & 1\n  \n    # If the count of characters with odd count is greater than 1, return False.\n    # Otherwise, return True.\n    return odd <= 1", "def can_form_palindrome(s):\n    # Create a dictionary to store the frequency of each character\n    freq = {}\n  \n    # Traverse the given string and count frequency of each character\n    for char in s:\n\n        # If character already present in dictionary, increment its count\n        if char in freq:\n            freq[char] += 1\n        else:\n            # Else add this character to dictionary\n            freq[char] = 1\n  \n    # Count characters with odd count\n    odd = 0\n    for k, v in freq.items():\n\n        # If count is odd, increment odd\n        odd += v & 1\n  \n    # If count of characters with odd count is greater than 1, return false. \n    # Else return true.\n    return odd <= 1", "def unusual_addition(lst):\n    \"\"\"\n    This function accepts a list solely made up of strings containing numerical digits only and returns a list.\n    In the output, for each element, replace the '1' with the true count of odd digits and 'e' with the true count of even digits in\n    the nth string from the input.\n\n    >>> unusual_addition(['1234567'])\n    [\"the number of odd elements are 3 of the string 1 of the input.\"]\n    >>> unusual_addition(['3', \"1111111\"])\n    [\"the number of odd elements are 1 of the string 1 of the input.\",\n    \"the number of odd elements are 7 of the string 0 of the input.\"]\n    \"\"\"\n    output = []\n    for idx, string in enumerate(lst):\n        odd_count = sum(1 for s in string if int(s) % 2 != 0)\n        even_count = sum(1 for s in string if int(s) % 2 == 0)\n        replace_string = f\"the number of odd elements are {odd_count} of the string {even_count} of the input\"\n        output.append(replace_string)\n\n    return output"]}
{"task_id": 99, "content": ["def parse_string(pattern, string):\n    '''\n    This function parses a string and returns the substrings which are enclosed in the given pattern.\n    \n    Parameters\n    ----------\n    pattern : str\n        The given pattern\n    string : str\n        The given string\n    \n    Returns\n    -------\n    List\n        Contains substrings enclosed within the given pattern.\n    '''\n    # Initialize list to store substrings\n    sub_strings = []\n    \n    # Get the start and end positions of each substring\n    start = string.find(pattern)\n    end = string.find(pattern, start+1)\n    \n    # Iterate through the string\n    while start >= 0 and end > start:\n        # Get substring and append to list\n        sub_strings.append(string[start+len(pattern):end])\n        \n        # Get new start and end positions\n        start = end\n        end = string.find(pattern, start+1)\n    \n    # Return list of substrings\n    return sub_strings", "def sum_primes_in_range(start, end):\n    \"\"\"\n    Function to find the sum of all prime numbers within the given range.\n    \n    Parameters: \n    start (int): The start number of the range. \n    end (int): The end number of the range.\n    \n    Returns: \n    int: The sum of all prime numbers in the given range.\n    \"\"\"\n    result = 0\n    for n in range(start, end+1):\n        if is_prime(n):\n            result += n\n    return result", "def generate_input_file():\n    # The input file should be generated in such a way that it produces the maximum product of final[1] and final[3],\n    # and the maximum key in the results dictionary.\n    # To achieve this, the input file should be carefully crafted to produce the desired output when processed by the given function.\n    # The specific details of the input file content and format depend on the logic within the given function, and may require trial and error to determine the optimal input file content.\n\n    # As the exact logic within the given function is not provided, the generation of the input file content involves reverse-engineering the function's behavior and requirements.\n\n    # The solution to this problem involves analyzing the given function's behavior and requirements, and crafting an input file that fulfills those conditions to produce the desired output.\n\n    # Due to the specific nature of the input file content required to achieve the desired output, the exact content and format of the input file cannot be provided without further information about the given function's internal logic and requirements.\n\n    # Therefore, the solution involves understanding the behavior of the given function and crafting an input file that, when processed by the function, produces the maximum product of final[1] and final[3], and the maximum key in the results dictionary.\n\n    # The generation of the input file content may involve experimentation and analysis to determine the optimal values and structure that result in the desired output when processed by the given function.\n\n    # As the specific details of the input file content and format are not provided, the solution involves a process of reverse-engineering and experimentation to determine the appropriate input file content that fulfills the given requirements.\n\n    return \"Generated input file content\"", "def substring(string, start, end):\n    '''This function takes a string, start index and end index, and returns the substring between the two given indexes.'''\n    return string[start:end]", "def max_expression(start, end):\n    \"\"\"\n    This function returns the highest numerical expression found amidst a given range of integer values.\n    \"\"\"\n    if start<0 or end<0:\n        return \"Invalid input: please provide non-negative integer values.\"\n\n    if start > end:\n        start, end = end, start  # Swap if start is larger than end\n\n    # For any two non-negative integers, the highest numerical expression \n    # that can be formed is multiplication\n    return end * (end - 1) if start == end - 1 else end * start  "]}
{"task_id": 100, "content": ["def find_common_items(list1, list2):\n    # Initialize an empty list to store the common items\n    common_items = []\n\n    # Flatten the lists if they contain nested lists\n    list1 = flatten_list(list1)\n    list2 = flatten_list(list2)\n\n    # Iterate over the items in the first list\n    for item in list1:\n        # Check if the item is in the second list\n        if item in list2:\n            # Add the common item to the common_items list\n            common_items.append(item)\n\n    # Return the common items list\n    return common_items", "def combine_lists(*lists):\n    '''This function takes any number of lists and combines them into a single list.'''\n    combined_list = []\n\n    for list in lists:\n        for item in list:\n            combined_list.append(item)\n\n    return combined_list", "def merge_lists(lists):\n    merged_list = []\n    # Iterate through each list in the given list of lists\n    for lst in lists:\n        # Iterate through each item in that list\n        for item in lst:\n            # Append the item to the merged list\n            merged_list.append(item)\n    return merged_list", "def find_overlapping_elements(list1, list2):\n    result = []\n    \n    # Iterate over elements in list1\n    for item in list1:\n        # Check if item is also present in list2\n        if item in list2:\n            result.append(item)\n        # Check if item is a list\n        if isinstance(item, list):\n            # Recursively call the function for the nested list\n            nested_result = find_overlapping_elements(item, list2)\n            # Extend the result list with the nested result\n            result.extend(nested_result)\n    \n    return result", "def find_common(list1, list2):\n    \"\"\"Find all the common elements from two given lists.\"\"\"\n    common = []\n    for item in list1:\n        if item in list2:\n            common.append(item)\n    return common"]}
{"task_id": 101, "content": ["def inject_payload(pid, payload):\n    # This function would need to be implemented to attach to the process,\n    # find the system call table, and modify it to point to the custom handler.\n    # This is a complex task that typically requires kernel-level access and\n    # is beyond the scope of a simple Python script.\n    pass", "def area_perimeter_circle(radius):\n    \"\"\"Function to return the area and perimeter of a circle\"\"\"\n    area = 3.14 * (radius ** 2)\n    perimeter = 2 * 3.14 * radius\n    return area, perimeter", "def attach_to_process(pid):\n    # This is a placeholder function. In reality, you would need to use a lower-level\n    # library or system call to perform this action, which is not exposed through\n    # the Python standard library.\n    # For example, you might use the libc library to call ptrace()\n    # This is beyond the scope of a simple Python script and would require a\n    # more complex setup and environment.\n    pass", "def find_gadgets(binary_path):\n    # This function would use a disassembler and debugger to find potential gadgets\n    # For the purpose of this example, we'll assume the existence of a function that does this\n    # In practice, you would use a tool like radare2, IDA Pro, or GDB with Python scripting\n    gadgets = []\n    # ... (disassembly and gadget search logic here) ...\n    return gadgets", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass"]}
{"task_id": 102, "content": ["def recursive_sum_even(n):\n    \"\"\"\n    Recursive function to sum all even numbers between 0 and a number \n    \"\"\"\n    # Check if the number is an integer or not\n    if not isinstance(n, int):\n        return \"Error: The input should be an integer.\"\n\n    # Check if the number is negative or not\n    if n < 0:\n        return \"Error: The input should be a non-negative integer.\"\n\n    # Recursive call and summing even numbers\n    else:\n        if n == 0:\n            return 0\n        elif n % 2 == 0:\n            return n + recursive_sum_even(n-2)\n        else:\n            return recursive_sum_even(n-1)", "def recursive_sum_even(n):\n    \"\"\"\n    Recursive function to sum all even numbers between 0 and a number \n    \"\"\"\n    # Check if the number is an integer or not\n    if not isinstance(n, int):\n        return \"Error: The input should be an integer.\"\n\n    # Check if the number is negative or not\n    if n < 0:\n        return \"Error: The input should be a non-negative integer.\"\n\n    # Recursive call and summing even numbers\n    else:\n        if n == 0:\n            return 0\n        elif n % 2 == 0:\n            return n + recursive_sum_even(n-2)\n        else:\n            return recursive_sum_even(n-1)", "def correct_ISO_8601(year):\n    # Check that the parameter is either a string or an integer\n    if not isinstance(year, (str, int)):\n        raise TypeError(\"Year must be either an integer or a string.\")\n    # Parsing string input to integer\n    if isinstance(year, str):\n        # Check if the string is in the correct format\n        if not (year.startswith('-') or year.startswith('+') or year.isdigit()):\n            raise ValueError('Year string format is incorrect.')\n        year = int(year)\n    # We don't have years before 0000\n    if year < 0:\n        return '-{:04}'.format(abs(year))\n    return '+{:04}'.format(year)", "def str_to_int(input_str):\n    \"\"\"\n    Convert a string to an integer. Return an error message if not possible.\n\n    >>> str_to_int(\"123\")\n    123\n    >>> str_to_int(\"-123\")\n    -123\n    >>> str_to_int(\"123abc\")\n    'The input string cannot be converted to an integer!'\n    \"\"\"\n    if input_str.lstrip('-').isdigit():  # Check if it is an integer (considering negative numbers)\n        return int(input_str)\n    else:\n        return 'The input string cannot be converted to an integer!'", "def square_numbers(num):\n    \"\"\"\n    This function takes in a number and returns a list of squares of numbers from 0 to that number.\n    It handles errors for negative values, non-integer values, and non-numeric values.\n    \"\"\"\n  \n    # check if the input is not a number\n    if not isinstance(num, (int, float)):\n        raise ValueError('Input should be an integer or a float.')\n\n    # check if the input number is not integer\n    elif not isinstance(num, int):\n        raise ValueError('Input should be an integer.')\n\n    # check if the input number is negative\n    elif num < 0:\n        raise ValueError('Input should be a non-negative integer.')\n\n     # generate list of squares\n    else:\n        return [i**2 for i in range(num+1)]"]}
{"task_id": 103, "content": ["def list_to_set(data):\n    \"\"\"\n    Function to convert a list to a set; managing nested lists and converting them to nested sets.\n    \"\"\"\n    # If data is a list convert each item in the list to a set recursively\n    if isinstance(data, list):\n        return set(list_to_set(item) for item in data)\n\n    # If data is a set convert each item in the set to a set recursively\n    elif isinstance(data, set):\n        return {list_to_set(item) for item in data}\n  \n    # If data is a tuple convert each item in the tuple to a set recursively and convert the tuples into sets.\n    elif isinstance(data, tuple):\n        return {list_to_set(item) for item in data}\n  \n    # If data is a dictionary convert each key value pair to tuple and handle each item in the tuple recursively.\n    elif isinstance(data, dict):\n        return {list_to_set((k,v)) for k,v in data.items()}\n\n    # If data is not a list, set, tuple or dict just return the data\n    else:\n        return data", "def transpose(matrix):\n    # The * operator is used to unzip a list (or other iterables), making a list of tuples where each tuple contains the i-th element from each of the argument sequences or iterables.\n    # The zip() function takes iterables, aggregates them in a tuple, and return the result.\n    # In other words, it returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.\n    return [list(i) for i in zip(*matrix)] ", "def list_to_set(data):\n    \"\"\"\n    Function to convert a list to a set, managing nested lists and converting them to nested sets.\n    \"\"\"\n    # If data is a list, convert each item in the list to a set recursively\n    if isinstance(data, list):\n        return set(list_to_set(item) for item in data)\n\n    # If data is a set, convert each item in the set to a set recursively\n    elif isinstance(data, set):\n        return {list_to_set(item) for item in data}\n  \n    # If data is a tuple, convert each item in the tuple to a set recursively and convert the tuples into sets\n    elif isinstance(data, tuple):\n        return {list_to_set(item) for item in data}\n  \n    # If data is a dictionary, convert each key-value pair to a tuple and handle each item in the tuple recursively\n    elif isinstance(data, dict):\n        return {list_to_set((k,v)) for k,v in data.items()}\n\n    # If data is not a list, set, tuple, or dict, just return the data\n    else:\n        return data", "def unique_sets(sets):\n    # Remove duplicates by converting each sub-set to a tuple (which are hashable), \n    # making a set of those (ignores duplicates), then convert each tuple back to list.\n    return [list(x) for x in set(tuple(x) for x in sets)]", "def add_elements(tuple1, set1):\n    # Convert the tuple to a list\n    tuple1 = list(tuple1)\n    \n    # Iterate through each element in the set\n    for element in set1:\n        # If the element is not already in the tuple's list, add it to the beginning\n        if element not in tuple1:\n            tuple1.insert(0, element)\n    \n    # Convert the list back to a tuple\n    tuple1 = tuple(tuple1)\n    \n    return tuple1"]}
{"task_id": 104, "content": ["def join_phrase(phrase_list):\n    # Check if the input is a list\n    if not isinstance(phrase_list, list):\n        return \"Error: Input must be a list.\"\n    # Check if the list is empty\n    elif not phrase_list:\n        return \"Error: The list is empty.\"\n    # Check if all elements in the list are strings\n    elif not all(isinstance(i, str) for i in phrase_list):\n        return \"Error: All elements in the list must be strings.\"\n    # If all checks are passed, join the phrases\n    else:\n        return \"; \".join(phrase_list)", "def check_unique_strings(strings):\n    '''This function takes a list of strings and returns a boolean \n    indicating whether all the strings in the list are unique.'''\n    seen = set()\n    for string in strings:\n        if string in seen:\n            return False\n        seen.add(string)\n    return True", "def check_domain_registration(domain):\n    # This is a placeholder function. In a real scenario, you would use an API or a service to check domain registration.\n    # For this proof-of-concept, we assume all domains are available.\n    return True", "def manipulate_variables(b, num_list):\n    # check if variable is a number\n    if not (isinstance(b, int) or isinstance(b, float)):\n        return \"Error: The variable is not a number.\"\n\n    # check if second argument is a list\n    if not isinstance(num_list, list):\n        return \"Error: Second argument is not a list.\"\n    \n    # check if list is empty\n    if not num_list:\n        return \"Error: The list is empty.\"\n\n    # check if all elements in the list are integers\n    if not all(isinstance(num, int) for num in num_list):\n        return \"Error: The list contains non-integer elements.\"\n    \n    # calculate the sum of elements in the list with the given variable\n    total_sum = sum(num_list) + b\n\n    return total_sum", "def my_function(my_list):\n    # Error handling: check if input is a list\n    if not isinstance(my_list, list):\n        raise ValueError(\"Input must be a list\")\n    # Error handling: check if the elements inside the list are numbers\n    if not all(isinstance(i, (int, float)) for i in my_list):\n        raise ValueError(\"All elements in list must be either integer or float\")\n    \n    # Use a generator function for memory efficiency\n    # Generators are better for large data sizes as they generate output on the fly and do not need to store all results in memory.\n    return (i * 2 for i in my_list)"]}
{"task_id": 105, "content": ["def filter_numbers(numbers, func_filter):\n    \"\"\"\n    Filters a list of integers based on the given condition.\n\n    Args:\n    numbers: A list of integers to be filtered.\n    func_filter: A filtering function that accepts an integer and returns a boolean value.\n\n    Returns:\n    A new list containing only the integers that satisfy the filtering condition.\n    \"\"\"\n    filtered_numbers = [num for num in numbers if func_filter(num)]\n    return filtered_numbers", "def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers.", "def multiply_three_numbers(a, b, c):\n    # Exception handling for non-integer inputs\n    try:\n        # The int() function attempts to convert the input into an integer.\n        # If this fails, a ValueError exception is raised, which we handle below.\n        a = int(a)\n        b = int(b)\n        c = int(c)\n\n        # If the conversion to integer went well, return the product of the numbers.\n        return a * b * c\n\n    except ValueError:\n        return \"All inputs must be integers.\"", "def multiply_three_numbers(a, b, c):\n    # exception handling for non-integer inputs\n    try:\n        # The int() function attempts to convert the input into an integer.\n        # If this fails, a ValueError exception is raised, which we handle below.\n        a = int(a)\n        b = int(b)\n        c = int(c)\n\n        # If the conversion to integer went well, return the product of the numbers.\n        return a * b * c\n\n    except ValueError:\n        return \"All inputs must be integers.\"", "def uncommon_elements(sequence):\n    '''\n    The function accepts a non-empty list of positive integers and returns a list of unique integers that have \n    a frequency greater than half of the integer's numerical value. If no integers meet these conditions, an \n    empty list is returned.\n    '''\n    frequency = Counter(sequence)\n    result = [num for num in frequency if frequency[num] > num/2]\n\n    return result"]}
{"task_id": 106, "content": ["def revised_function(input_tuple):\n    # Checks if the tuple is None or empty \n    if not input_tuple:\n        return \"Error: input is NULL or empty.\"\n\n    # Initiating an empty list to hold string representations of the float values\n    str_list = []\n\n    # Iterate over the elements in the tuple\n    for element in input_tuple:\n        # Confirm that each element is a float. If not, return an error message.\n        if not isinstance(element, float):\n            return \"Error: all elements in the tuple should be floats.\"\n            \n        # Convert the float to a string and append to the list\n        str_list.append(str(element))\n    \n    # Join all elements in the list with a semicolon\n    result = \"; \".join(str_list)\n    \n    return result", "def sort_and_retrieve_third(my_list):\n    # Convert all elements in the list to string for consistent comparison\n    # This preserves the original type of list items, integers, floats or strings\n    converted_list = [str(x) for x in my_list]\n\n    # Sort the list\n    sorted_list = sorted(converted_list)\n    \n    # Now, convert the sorted list elements back to their original types\n    sorted_originalType_list = []\n    for i in sorted_list:\n        # try to convert i to int, float or leave it as string\n        try:\n            sorted_originalType_list.append(int(i))   # converts to int if possible\n        except ValueError:\n            try:\n                sorted_originalType_list.append(float(i)) # converts to float if possible\n            except ValueError:\n                sorted_originalType_list.append(i)   # remains string\n    \n    # Retrieve the third element\n    third_element = sorted_originalType_list[2]\n\n    print(\"Original list:\", my_list)\n    print(\"Sorted list:\", sorted_originalType_list)\n    print(\"Third element:\", third_element)", "def sort(list):\n    \"\"\"\n    This function sorts a given list in ascending order.\n\n    Parameters:\n    list (List[int, float, str]): A list of numerical or string values to be sorted. This list should contain elements of the same datatype for the function to work correctly. \n    \"\"\"\n    list.sort()", "def list_processing(my_list):\n  # Checks if all elements are either integer or string\n  valid_types = [int, str]\n  if all(type(x) in valid_types for x in my_list):\n      # Convert the list to a set to remove duplicated and then convert it to a tuple\n      new_tuple = tuple(set(my_list))\n      # Return the new tuple and the number of unique elements\n      return new_tuple, len(new_tuple)\n  else:\n      # In case if there are elements in the list other than integers and strings\n      return \"List contains non-string or non-integer elements\"", "def my_function(my_list):\n    # Error handling: check if input is a list\n    if not isinstance(my_list, list):\n        raise ValueError(\"Input must be a list\")\n    # Error handling: check if the elements inside the list are numbers\n    if not all(isinstance(i, (int, float)) for i in my_list):\n        raise ValueError(\"All elements in list must be either integer or float\")\n    \n    # Use a generator function for memory efficiency\n    # Generators are better for large data sizes as they generate output on the fly and do not need to store all results in memory.\n    return (i * 2 for i in my_list)"]}
{"task_id": 107, "content": ["def get_urls(text):\n    return re.findall('(?P<url>https?://[^\\s]+)', text)", "def extract_url(text):\n    url_pattern = re.compile(r\"(https?://[^\\s]+)\")\n    urls = re.findall(url_pattern, text)\n    return urls", "def simplified_striphttp(url: str) -> str:\n    if url.startswith(\"http://\"):\n        return url[len(\"http://\"):]\n    elif url.startswith(\"https://\"):\n        return url[len(\"https://\"):]\n    else:\n        return url", "def containsGitHubURL(text):\n    pattern = r\"https://github.com/[\\w\\d-]+/[\\w\\d-]+\"\n    return bool(re.search(pattern, text))", "def extract_domain(url: str) -> str:\n    if url.startswith(\"https://\"):\n        url = url[len(\"https://\"):]\n    elif url.startswith(\"http://\"):\n        url = url[len(\"http://\"):]\n\n    domain_end = url.find(\"/\")\n    if domain_end != -1:\n        return url[:domain_end]\n    else:\n        return url"]}
{"task_id": 108, "content": ["def first_unique_char(s):\n    # Count of each character in string s\n    count = {}\n    for c in s:\n        if c in count:\n            count[c] += 1\n        else:\n            count[c] = 1\n            \n    # Find the position of the first character that appears only once\n    for i in range(len(s)):\n        if count[s[i]] == 1:\n            return i\n        \n    # No character appears only once\n    return -1", "def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]", "def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def check_text(text):\n    # Find all words that appear more than 3 times in a row\n    matches = re.findall(r'\\b(\\w+)\\b(?:\\s+\\1){2,}', text, re.IGNORECASE)\n    # Find all letters that appear only once in the entire text\n    unique_letters = set(filter(lambda x: text.count(x) == 1, set(text)))\n    # Check if there's a word that appears more than 3 times in a row and has at least one unique letter\n    for word in matches:\n        if any(letter in unique_letters for letter in word):\n            return True\n    return False", "def frequencySort(nums):\n    # collections.Counter(nums) gives the frequency of each element in the nums array.\n    # items() function returns a view object that displays a list of a dictionary's(an iterable) tuple pair (key, value).\n    c = Counter(nums).items()\n    # Then we will sort the results by the tuple (-count, num). Negative count ensures that high frequency elements come first in the sorted list.\n    # This satisfies the requirement to sort in increasing frequency. \n    # Because we use num for sort as well, elements with the same frequency are sorted in descending order.\n    # This satisfies the requirement to sort in decreasing order on the basis of value of the numbers in case of same frequency.\n    # idx is used to sort elements in increasing order of their index in case elements are same and have same frequency.\n    # sort function of python is stable. i.e, it maintains the relative order of items with equal sort keys\n    nums.sort(key = lambda x: (nums.count(x), -x, [i for i, n in enumerate(nums) if n == x][0]))\n    # return the sorted array\n    return nums"]}
{"task_id": 109, "content": ["def generate_input_file():\n    # The input file should be generated in such a way that it produces the maximum product of final[1] and final[3],\n    # and the maximum key in the results dictionary.\n    # To achieve this, the input file should be carefully crafted to produce the desired output when processed by the given function.\n    # The specific details of the input file content and format depend on the logic within the given function, and may require trial and error to determine the optimal input file content.\n\n    # As the exact logic within the given function is not provided, the generation of the input file content involves reverse-engineering the function's behavior and requirements.\n\n    # The solution to this problem involves analyzing the given function's behavior and requirements, and crafting an input file that fulfills those conditions to produce the desired output.\n\n    # Due to the specific nature of the input file content required to achieve the desired output, the exact content and format of the input file cannot be provided without further information about the given function's internal logic and requirements.\n\n    # Therefore, the solution involves understanding the behavior of the given function and crafting an input file that, when processed by the function, produces the maximum product of final[1] and final[3], and the maximum key in the results dictionary.\n\n    # The generation of the input file content may involve experimentation and analysis to determine the optimal values and structure that result in the desired output when processed by the given function.\n\n    # As the specific details of the input file content and format are not provided, the solution involves a process of reverse-engineering and experimentation to determine the appropriate input file content that fulfills the given requirements.\n\n    return \"Generated input file content\"", "def random_number(minimum, maximum):\n    '''This function takes a minimum and maximum number and generates a random number within the given range.'''\n    return random.randint(minimum, maximum)", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min"]}
{"task_id": 110, "content": ["def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def findCombinations(array, total):\n    \"\"\"\n    This function will find all possible combinations of integers in the given array that sum up to the given total.\n    Args:\n        array (list): List of integers.\n        total (int): Total to be reached with the combination of integers.\n    \n    Returns:\n        A list of lists containing the combinations of integers.\n    \"\"\"\n    combinations = []  # list to store the possible combinations\n    for i in range(1 << len(array)):  # loop through all combinations of bits\n        combination = []  # list to store the current combination\n        for j in range(len(array)):  # loop through array elements\n            if i & (1 << j):  # check if bit is set\n                combination.append(array[j])  # add array element to combination\n        if sum(combination) == total:  # check if combination sums to given total\n            combinations.append(combination)  # add combination to list of combinations\n\n    return combinations", "def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def apply_function(arr, f):\n    \"\"\"\n    Apply a given function to each item of an input array.\n    \n    Args:\n        arr (list): The input array.\n        f (function): The function to be applied.\n        \n    Returns:\n        list: A list with the result of applying function f to each item of arr.\n    \"\"\"\n    return list(map(f, arr))", "def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers."]}
{"task_id": 111, "content": ["def sum_jacobsthal_lucas(n):\n    # Function to calculate the sum of first n Jacobsthal-Lucas numbers\n    # The sum of the first n Jacobsthal-Lucas numbers is given by the (n+1)th Jacobsthal-Lucas number minus 1\n    return (nth_jacobsthal_lucas(n + 1) - 1) % MOD", "def sum_jacobsthal_lucas(n):\n    # Function to calculate the sum of first n Jacobsthal-Lucas numbers\n    \n    # The sum of the first n Jacobsthal-Lucas numbers is given by the (n+1)th Jacobsthal-Lucas number minus 1\n    return (nth_jacobsthal_lucas(n + 1) - 1) % MOD ", "def smart_repr(fields):\n    # Function to return a smart representation of the fields\n    return ', '.join('{}={}'.format(key, value) for key, value in fields.items())", "def factorial(n):\n    \"\"\"\n    Calculates the factorial of an integer (n \u2265 0) and returns None for negative values.\n    The factorial function is not defined for negative integers. Instead of returning an error or exception, \n    this function returns None and prints out a message.\n    The function proves to be internally consistent with the known factorial function for non-negative integers \n    (i.e., n! = n*(n-1)*(n-2)*...*3*2*1 for n\u22650).\n    \"\"\"\n    if n < 0:\n        print(\"The factorial function isn\u2019t defined for negative integers\")\n        return None\n    elif n == 0:\n        return 1\n    else:\n        fact = 1\n        for i in range(1, n + 1):\n            fact *= i\n        return fact", "def lucas(n):\n    sequence = lucas_sequence(n)\n    print(f\"The {n}th number in the Lucas sequence is {sequence[-1]}\")\n    print(\"The sequence of Lucas numbers up to the {n}th term in reverse order is:\")\n    print(sequence[::-1])"]}
{"task_id": 112, "content": ["def sum_between(num1, num2):\n  # The range function generates a sequence of numbers from num1 to num2 (inclusive)\n  # By passing this sequence as an argument to the sum function, we get the sum of all the numbers\n  sum = sum(range(num1, num2+1))\n  return sum", "def sum(x):\n    '''This function will sum all the numbers from 0 to x.'''\n    return (x * (x + 1)) // 2", "def sum_n(n):\n    '''\n    Function to calculate the sum of all numbers from 0 to n\n    \n    Parameters\n    n: Integer\n    \n    Returns\n    sum of all numbers from 0 to n\n    '''\n    total = 0\n    for i in range(n+1):\n        total += i\n    return total", "def multiply_with_range(number):\n    \"\"\"Multiply a number with all integers within a range\n    \n    This function takes a single argument, a number (integer), and \n    returns a list. The elements of this list are results of the \n    number multiplied with every integer from 1 to the number itself.\n\n    Args:\n        number (int): the number to be multiplied with all the integers in range\n\n    Returns:\n        list: a list of results from multiplying the number with each integer \n        within the range\n    \"\"\"\n    multiplied_list = [number * i for i in range(1, number + 1)]\n    return multiplied_list", "def product_list(numbers):\n    \"\"\"\n    Function to calculate the cumulative product of all integers in a supplied list.\n\n    :param numbers: list of numbers\n    :return: cumulative product from the list\n    \"\"\"\n\n    # Initialize variable to store the result\n    result = 1\n\n    # Loop through each number in the list\n    for num in numbers:\n        # Multiply the result by the current number\n        result *= num\n\n    # Return the final product\n    return result"]}
{"task_id": 113, "content": ["def square_elements(input_data):\n    \"\"\"\n    Function to return the square of a complex number or a list of complex numbers.\n    \n    Parameters:\n    input_data (complex/list of complex numbers): A complex number or list of complex numbers to square.\n\n    Returns:\n    complex/list: Square of the input complex number or list of complex numbers.\n    \"\"\"\n    \n    # Check if input_data is a complex number or a list\n    if isinstance(input_data, complex):\n        return input_data ** 2\n    elif isinstance(input_data, list):\n        # Check if all elements in the list are complex numbers\n        if all(isinstance(ele, complex) for ele in input_data):\n            return [ele ** 2 for ele in input_data]\n        else:\n            raise TypeError(\"All elements in the list must be complex numbers.\")\n    else:\n        raise TypeError(\"Input must be a complex number or a list of complex numbers.\")", "def add_numbers(a: complex, b: complex) -> complex:\n    \"\"\"\n    This function takes two complex numbers as input and returns their sum.\n    \n    :param a: The first complex number.\n    :param b: The second complex number.\n    :return: The sum of a and b.\n    \"\"\"\n    try:\n        result = a + b\n    except TypeError:\n        raise TypeError(\"Invalid input. Both arguments must be complex numbers.\")\n    except OverflowError:\n        raise OverflowError(\"The result is too large to be represented as a complex number.\")\n    except Exception as e:\n        raise e\n    else:\n        return result", "def complex_with_magnitude(params: tuple) -> complex:\n    \"\"\"\n    This function accepts a tuple of three floats, uses the first two to form a complex number.\n    If the third float is positive, the function uses it to adjust the magnitude of the complex number.\n    :param params: (float, float, float)\n    :return: complex\n    \"\"\"\n    real, imag, magnitude = params\n    if magnitude < 0:\n        raise ValueError('Magnitude must not be negative')\n\n    z = complex(real, imag)\n    z_magnitude, z_angle = cmath.polar(z)\n    \n    adjusted_z = cmath.rect(magnitude * z_magnitude, z_angle)\n    return adjusted_z", "def custom_factorial(n):\n    if type(n) not in [int, float, complex]:\n        return \"Invalid input. Please provide a number.\"\n    \n    # Converting n to a complex number \n    n = complex(n)\n    \n    # When n is a non-negative integer.\n    if n.real >= 0 and n.imag == 0 and n.real == int(n.real):\n        return int(gamma(n.real+1))\n    \n    # In other cases\n    else:\n        # The gamma function for a number 'n' is generally equivalent to factorial of 'n-1'.\n        # But for negative numbers, this corresponds to 1 - n in factorial terms\n        return gamma(1 - n)", "def custom_factorial(n):\n    if type(n) not in [int, float, complex]:\n        return \"Invalid input. Please provide a number.\"\n    \n    # Converting n to a complex number \n    n = complex(n)\n    \n    # When n is a non-negative integer.\n    if n.real >= 0 and n.imag == 0 and n.real == int(n.real):\n        return int(gamma(n.real+1))\n    \n    # In other cases\n    else:\n        # The gamma function for a number 'n' is generally equivalent to factorial of 'n-1'.\n        # But for negative numbers, this corresponds to 1 - n in factorial terms\n        return gamma(1 - n)"]}
{"task_id": 114, "content": ["def create_random_sequence(length):\n    # Generate a random sequence of 0s and 1s\n    sequence = [random.choice([0, 1]) for _ in range(length)]\n    \n    # Count the number of 0s and 1s\n    num_zeros = sequence.count(0)\n    num_ones = sequence.count(1)\n    \n    # While the difference between the number of 0s and 1s is greater than 1,\n    # replace one of the dominant elements with the other randomly.\n    while abs(num_zeros - num_ones) > 1:\n        dominant_element = 0 if num_zeros > num_ones else 1\n        non_dominant_element = 1 if dominant_element == 0 else 0\n        \n        # Find a random index of the dominant element in the sequence\n        random_index = random.choice([i for i in range(length) if sequence[i] == dominant_element])\n        \n        # Replace the dominant element with the non-dominant element\n        sequence[random_index] = non_dominant_element\n        \n        # Update the counts\n        num_zeros = sequence.count(0)\n        num_ones = sequence.count(1)\n    \n    return sequence", "def max_difference(arr):\n    \"\"\"\n    This function takes a list of integers and returns the maximum difference between any two elements in the list.\n    \n    Args:\n    arr: A list of integers\n    \n    Returns:\n    int: Maximum difference between any two elements in the list\n    \"\"\"\n    if len(arr) < 2:\n        return 0\n    else:\n        max_diff = max(arr) - min(arr)\n        return max_diff", "def encode_integer(value, max_length):\n    \"\"\"\n    Encode a given positive integer up to a maximum length.\n\n    Parameters:\n    value (int): The integer value to encode\n    max_length (int): The maximum length of the output\n    \n    Returns:\n    (string): The encoded value\n    \"\"\"\n    \n    # Convert the value to binary\n    binary_value = bin(value)[2:]\n    \n    # Pad the value with leading zeros until it has the maximum length\n    while len(binary_value) < max_length:\n        binary_value = \"0\" + binary_value\n        \n    # Convert the binary value to a string of 0s and 1s\n    encoded_value = \"\".join(str(c) for c in binary_value)\n    \n    return encoded_value", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def find_maximum(a, b, c):\n    # Convert the numbers to binary\n    a_bin = bin(a)\n    b_bin = bin(b)\n    c_bin = bin(c)\n    \n    # Count the number of 1s in the binary representation of each number\n    a_count = a_bin.count('1')\n    b_count = b_bin.count('1')\n    c_count = c_bin.count('1')\n    \n    # Compare the counts to find the maximum\n    if a_count > b_count and a_count > c_count:\n        return a\n    elif b_count > a_count and b_count > c_count:\n        return b\n    else:\n        return c"]}
{"task_id": 115, "content": ["def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min", "def calculate_sum(a, b):\n    \"\"\"Calculate the sum of two numbers given.\n    \n    Parameters\n    ----------\n    a : int\n        The first argument.\n    b : int\n        The second argument.\n        \n    Returns\n    -------\n    int\n        The sum of the two numbers given.\n    \"\"\"\n    sum = a + b\n    return sum", "def gcd(a, b):\n    \"\"\"\n    Function to find greatest common divisor (gcd) of two numbers using the Euclidean algorithm\n    \n    Parameters :\n    a (int) : First input number\n    b (int) : Second input number\n    \n    Returns :\n    gcd(int) : highest common divisor of two positive integers \n    \n    \"\"\"\n    while b:\n        a, b = b, a % b\n\n    return a", "def add_numbers(a, b):\n    '''This function adds two given numbers and prints their sum.'''\n    print(\"The sum of\", a, \"and\", b, \"is\", a + b)"]}
{"task_id": 116, "content": ["def divide(dividend: int, divisor: int) -> int:\n    \"\"\"\n    Perform division of two integers without using the division operator '/',\n    without using any loops, and without using the math library. If the \n    divisor is zero, then return None.\n    \"\"\"\n    if divisor == 0:\n        return None\n    \n    sign = 1 if (dividend < 0) == (divisor < 0) else -1\n    dividend, divisor = abs(dividend), abs(divisor)\n    \n    quotient = 0\n    temp = 0\n    \n    for i in range(31, -1, -1):\n        if temp + (divisor << i) <= dividend:\n            temp += divisor << i\n            quotient |= 1 << i\n    \n    return sign * quotient", "def send_payload(payload):\n    # This function would contain the logic to send the payload to the vulnerable service.\n    # For example, using the 'socket' library in Python to send the payload to the service.\n    pass", "def filter_strings(strings, operator, value):\n    if operator not in LOGICAL_OPERATORS:\n        raise ValueError(\"Invalid logical operator\")\n\n    joined_string = join_str(strings, delimiter=' ')  # Join the strings using a space delimiter\n    normalized_value = normalize_value(value)  # Normalize the value using a utility function\n\n    if operator == 'AND':\n        filtered_list = [s for s in strings if normalized_value in s]\n    else:  # operator == 'OR'\n        filtered_list = [s for s in strings if normalized_value in joined_string]\n\n    return filtered_list", "def productExceptSelf(nums):\n    # Python's len() function is how you get the length of lists, strings, and other sequence types\n    length = len(nums)\n    \n    # Python lists use [] and you don't need to specify a size upfront, \n    # so here we are making a list of 1's with the same length as the input\n    answer = [1]*length\n\n    # Python's range() function is used for loops that iterate over a sequence of integers\n    # It starts at the first parameter (0 if not specified) and steps by 1 (or second parameter) until it reaches (but does not include) the second parameter\n    # So here it is going from 1 to length\n    for i in range(1, length):\n        # Python uses indentation to denote blocks, so this line is the body of the loop\n        # It is multiplying the previous number in nums by the previous number in answer and storing it in the current spot in answer\n        answer[i] = nums[i-1] * answer[i-1]\n    \n    # A stand-alone variable to accumulate the product as we move right-to-left through the list\n    R = 1\n\n    # This range is going from length-1 down to 0\n    # The third parameter to range is the step, so making it -1 steps backwards through the sequence\n    for i in range(length-1, -1, -1):\n        # For the current spot in answer, multiply it by R, updating the value in answer\n        answer[i] *= R\n\n        # Also, multiply R by the current number in nums\n        R *= nums[i]\n    \n    # Just like Go, Python uses return to send back an output from a function\n    return answer", "def find_common_elements(*arrays):\n    # Convert all arrays into Python's built-in Set data structure, \n    # which automatically eliminates duplicates within individual arrays\n    sets = [set(arr) for arr in arrays]\n    \n    # The Python's built-in set.intersection method can be used to find elements that \n    # exist in all sets (i.e., all arrays). It takes any number of arguments (sets), \n    # so the * operator is used to unpack list of sets as arguments.\n    common_elements = set.intersection(*sets)\n    \n    # The sorted build-in function is used to sort the resulting set of common elements \n    # in ascending order\n    return sorted(common_elements)"]}
{"task_id": 117, "content": ["def filter_words(words):\n    \"\"\"Function to filter a given list of words, such that all words with odd length are filtered out.\"\"\" \n    filtered_words = [word for word in words if len(word) % 2 == 0]\n    return filtered_words", "def remove_rubbish_words(data, rubbishList):\n    \"\"\"\n    Remove rubbish words from the given text data list.\n\n    :param data: A list of text data where rubbish words need to be removed.\n    :param rubbishList: A list of rubbish words that should be removed from the text data.\n    :return: A new list containing the text data with the rubbish words removed.\n    \"\"\"\n    tmp = data.copy()  # Create a copy of the original list to avoid modifying it directly\n    tmp = [word for word in tmp if word.strip() not in rubbishList and not is_number(word.strip())]\n    return tmp", "def related_words(word, words):\n    \"\"\"\n    Function to get an array of words related to the given word.\n    \n    Parameters: \n    word (str) : The given word.\n    words (list) : The list of words to search in.\n\n    Returns:\n    list : The list of words related to the given word.\n    \"\"\"\n\n    related = []\n    for w in words:\n        if word in w or w in word:\n            related.append(w)\n    return related", "def enhanced_words_string(s, target):\n    # Remove the target word, split the string into words\n    words = s.replace(target, '').split()\n    # Reverse each word and filter out words that are longer than 6 characters\n    words = [word[::-1] for word in words if len(word) <= 6]\n    # Sort the list of words\n    words.sort()\n    return words", "def sort_desc(words):\n    '''This function will sort a given list of strings in descending order of their lengths.'''\n    words.sort(key=len, reverse=True)\n    return words"]}
{"task_id": 118, "content": ["def square_root(n):\n    \"\"\"This function takes an integer n and prints its square root.\n    \n    Args:\n        n (int): The integer to calculate the square root of.\n    \n    Returns:\n        None\n    \"\"\"\n    print(math.sqrt(n))", "def square(n):\n    \"\"\"\n    Calculate the square of a number.\n\n    Args:\n        n (int or float): The number to calculate the square of.\n\n    Returns:\n        The square of the input number.\n\n    Raises:\n        TypeError: If the input is not a number (int or float).\n    \"\"\"\n\n    if not isinstance(n, (int, float)):\n        raise TypeError(\"Input must be a number.\")\n    \n    return n * n", "def extract_hash_index(bitboard, magic):\n    # Magic bit manipulation to extract hash index\n    return (bitboard * magic) >> 60", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass"]}
{"task_id": 119, "content": ["def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def find_mode(lst):\n    # Create a dictionary to hold list items as keys and their counts as values.\n    count_dict = {}\n    for item in lst:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n\n    # Find the maximum count.\n    max_count = max(count_dict.values())\n\n    # If the maximum count is 1, there is no mode.\n    if max_count == 1:\n        return \"This list does not have a mode.\"\n\n    # Otherwise, find and return the keys with the maximum count.\n    else:\n        modes = [k for k, v in count_dict.items() if v == max_count]\n        return modes", "def is_item_in_list(item, my_list):\n    '''This function checks if an item exists in a given list and returns a boolean value.\n    Parameters\n    ----------\n    item: The item to be checked.\n    my_list: The list in which the item is to be checked. \n    \n    Returns\n    --------\n    boolean: True if the item is present in the list, and False if it is not.\n    '''\n\n    return item in my_list", "def calculate_mode(numbers):\n    # Create a dictionary to store the frequency of each number\n    frequency = {}\n\n    # Iterate through the list and count the frequency of each number\n    for num in numbers:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n\n    # Find the maximum frequency\n    max_freq = max(frequency.values())\n\n    # Find all numbers with the maximum frequency\n    mode = [num for num, freq in frequency.items() if freq == max_freq]\n\n    return mode", "def max_frequency(data):\n    # Count the frequency of each element in the list using Counter\n    freq = Counter(data)\n    # Get the element with maximum frequency using the max function\n    max_freq_element = max(freq, key=freq.get)\n    # Get the maximum frequency\n    max_freq = freq[max_freq_element]\n    print(f'Element with maximum frequency is {max_freq_element} with a frequency of {max_freq}')"]}
{"task_id": 120, "content": ["def vowel_count(string):\n    \"\"\"Get the vowels count in a given string.\n\n    Parameters\n    ----------\n    string : str\n        The string whose vowels count is to be computed.\n\n    Returns\n    -------\n    int\n        Number of vowels in the given string.\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n    for char in string:\n        if char in vowels:\n            count += 1\n    return count", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass", "def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]", "def edit_text(text):\n    \"\"\"This function takes a string of text and removes all the consonants to leave only the vowels.\"\"\"\n    \n    vowels = ['a', 'e', 'i', 'o', 'u']\n    edited_text = ''\n    \n    for char in text:\n        if char.lower() in vowels:\n            edited_text += char\n    \n    return edited_text", "def reverse_list(numbers):\n    '''This function will reverse the order of the elements \n    of a given list.'''\n    numbers.reverse()"]}
{"task_id": 121, "content": ["def list_to_set(data):\n    \"\"\"\n    Function to convert a list to a set; managing nested lists and converting them to nested sets.\n    \"\"\"\n    # If data is a list convert each item in the list to a set recursively\n    if isinstance(data, list):\n        return set(list_to_set(item) for item in data)\n\n    # If data is a set convert each item in the set to a set recursively\n    elif isinstance(data, set):\n        return {list_to_set(item) for item in data}\n  \n    # If data is a tuple convert each item in the tuple to a set recursively and convert the tuples into sets.\n    elif isinstance(data, tuple):\n        return {list_to_set(item) for item in data}\n  \n    # If data is a dictionary convert each key value pair to tuple and handle each item in the tuple recursively.\n    elif isinstance(data, dict):\n        return {list_to_set((k,v)) for k,v in data.items()}\n\n    # If data is not a list, set, tuple or dict just return the data\n    else:\n        return data", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass", "def write_ssh_key(name, path, key_type, debug):\n    # Function to write SSH key to a file\n    pass", "def unicode_to_repr(s):\n    # Function to convert unicode string to a representation\n    return repr(s)", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass"]}
{"task_id": 122, "content": ["def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def calculate_mean(numbers):\n    \"\"\"Function to calculate the mean of a collection of numbers.\"\"\"\n    return sum(numbers) / len(numbers)", "def calculate_mean(numbers):\n    \"\"\"\n    A function to calculate the mean of a list of integers and returns a string of the mean value.\n\n    Parameters:\n    numbers (list): a list of integers\n    \n    Returns:\n    str: the mean value formatted as a string\n    \"\"\"\n    mean = sum(numbers)/len(numbers)\n    return 'The mean is {}'.format(mean)", "def list_average(numbers):\n    '''This function will calculate the average of a list of numbers.'''\n    if len(numbers) == 0:\n        return 0\n\n    return sum(numbers) / len(numbers)", "def calc_mean(numbers):\n    \"\"\"\n    Function to calculate the mean of a list of numbers\n    \"\"\"\n    total = sum(numbers)\n    mean = total / len(numbers)\n    return mean"]}
{"task_id": 123, "content": ["def multiply_advanced(lst, n):\n    # Initialize the product to 1\n    # If we initialized it to 0, multiplying by any number will always result in 0.\n    prod = 1\n\n    for idx, el in enumerate(lst):\n    # The enumerate function adds a counter to the lst list and returns it. The returned object is an enumerable object.\n    # The idx variable corresponds to the index of the current item inside the loop.\n    # The el variable corresponds to the item itself.\n    # So we are looping through all elements along with their indexes.\n\n    # Check if the element is at an even index, is positive and is odd\n    # Indexes start at 0, so we check idx % 2 == 0 to see if it's an even index (since both 0 and any multiple of 2 are even),\n    # We check el > 0 to ensure the number is positive.\n    # We check el % 2 == 1 to ensure the number is odd (since any number with a remainder of 1 after division by 2 is odd).\n        if idx % 2 == 0 and el > 0 and el % 2 == 1:\n        # Multiply the product with the current number\n            prod *= el\n\n    # After the loop, our prod variable holds the product of all the numbers that met the conditions.\n    # We multiply this product by 'n' before returning it as specified by the problem.\n    return prod * n", "def multiply_advanced(lst, n):\n    # Initialize the product to 1\n    # If we initialized it to 0, multiplying 0 by any number will always result in 0.\n    prod = 1\n\n    for idx, el in enumerate(lst):\n        # the enumerate() function adds a counter to the lst list and returns it. The returned object is an enumerate object.\n        # The idx variable here corresponds to the index of the current item inside the loop.\n        # The el variable corresponds to the item itself.\n        # So we are looping through all elements along with their indexes.\n\n        # Check if the element is at an even index, is positive and is odd\n        # Indexes start at 0, so we check idx % 2 == 0 to see if it's an even index (since both 0 and any multiple of 2 are even).\n        # We check el > 0 to ensure the number is positive.\n        # We check el % 2 == 1 to ensure the number is odd (since any number with a remainder of 1 after division by 2 is odd).\n        if idx % 2 == 0 and el > 0 and el % 2 == 1:\n            # Multiply the product with the current number\n            prod *= el\n\n    # After the loop, our prod variable holds the product of all the numbers that met the conditions.\n    # We multiply this product by 'n' before returning it, as specified by the problem.\n    return prod * n", "def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers.", "def print_odd_elements(arr):\n    # Check if the array has an even number of elements\n    if len(arr) % 2 == 0:\n        # Exclude the last element if the array has an even length\n        arr = arr[:-1]\n\n    # Iterate over the array in reverse order\n    for i in range(len(arr)-1, -1, -1):\n        # Check if the index is odd\n        if i % 2 != 0:\n            # Print the corresponding element\n            print(arr[i])", "def sum_even_recursive(arr, n):\n    if n == 0:  # Base case: If the array is empty, return 0\n        return 0\n    else:\n        if arr[n-1] % 2 == 0:  # If the last element is even\n            return arr[n-1] + sum_even_recursive(arr, n-1)  # Add the last element to the sum of even numbers in the rest of the array\n        else:\n            return sum_even_recursive(arr, n-1)  # If the last element is odd, skip it and continue with the rest of the array"]}
{"task_id": 124, "content": ["def findPentagonalHexagonalNumber():\n    n = 144  # Start from the first number after 143, which is known to be both pentagonal and hexagonal\n    while True:\n        hexagonal = n * (2 * n - 1)  # Formula for generating hexagonal numbers\n        if isPentagonal(hexagonal):  # Check if the number is pentagonal\n            return hexagonal\n        n += 1\n    return None  # Return None if no such number is found", "def calculate_fibonacci(n):\n    \"\"\"\n    This function calculates the nth number of the Fibonacci sequence using iteration.\n    \n    Parameters:\n        n (int): The number in the Fibonacci sequence to calculate.\n        \n    Returns:\n        The nth number of the Fibonacci sequence.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    a, b = 0, 1\n    for i in range(2, n+1):\n        c = a + b\n        a, b = b, c\n        \n    return b", "def fibonacci_while(n):\n    \"\"\"\n    A function to compute and output the nth Fibonacci number using a while loop.\n    \"\"\"\n    \n    #initialize the first two terms\n    term1 = 0\n    term2 = 1\n    count = 2\n    \n    #check if it is the first or second number\n    if n == 1:\n        return term1\n    elif n == 2:\n        return term2\n    \n    #find the nth term\n    while count < n:\n        nth_term = term1 + term2\n        term1 = term2\n        term2 = nth_term\n        count += 1\n    \n    return nth_term", "def calculate_geometric_mean(num_list):\n    product = 1  # This variable will hold the multiplied result of all numbers in the num_list\n\n    for num in num_list:\n        # Multiply each number in num_list with the product\n        product *= num \n\n    # Calculate the geometric mean by taking the nth root of product\n    # where n is the number of elements in the list.\n    # The math.pow function calculates the power of a number.\n    # Since we need to calculate the nth root, the power is 1/n.\n    geometric_mean = math.pow(product, 1/len(num_list))\n\n    return geometric_mean", "def nth_fibo(n):\n    '''\n    This function finds the nth number in the Fibonacci sequence.\n    \n    Parameters\n    ----------\n    n : int\n        Desired position in the sequence\n    \n    Returns\n    -------\n    int\n        Nth number in the Fibonacci sequence.\n    '''\n    # Initialize variables\n    x = 0\n    y = 1\n    \n    # Iterate through the Fibonacci sequence\n    for _ in range(n-1):\n        x, y = y, x + y\n    \n    # Return the nth number in the Fibonacci sequence\n    return y"]}
{"task_id": 125, "content": ["def calculate_bill(rate, consumption):\n    bill = rate * consumption\n    print(\"Your total electricity bill is Rs. {}\".format(bill))", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass", "def write_ssh_key(name, path, key_type, debug):\n    # Function to write SSH key to a file\n    pass", "def tip_difference(pre_tax_bill):\n    #Calculate sales tax of 8.25% on the bill\n    sales_tax = pre_tax_bill * 0.0825\n\n    #Restaurant tip by doubling the sales tax\n    californian_tip = sales_tax * 2\n\n    #Traditional tip of 15% on pre-tax bill\n    traditional_tip = pre_tax_bill * 0.15\n\n    #Difference in the two methods, converted to cents\n    difference_in_cents = (californian_tip - traditional_tip) * 100\n\n    return difference_in_cents"]}
{"task_id": 126, "content": ["def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers.", "def calculate_mean(numbers):\n    \"\"\"Function to find the mean of an array of integers.\"\"\"\n    mean = (sum(numbers)) / len(numbers)\n    return mean", "def rolling_max(arr):\n    \"\"\"\n    This function takes an array of positive integers and\n    returns a new array where each element from index 0 to \n    n is the maximum element from the original array from\n    index 0 to n.\n\n    If there's a negative number in the array, the function returns an empty list.\n    \n    Args:\n        arr (List[int]): a list of integers.\n\n    Returns:\n        List[int]: a list of maximum numbers. \n        If input list contains negative number, an empty list is returned\n    \"\"\"\n    \n    max_num = float('-inf')\n    result = []\n    \n    for number in arr:\n        if number < 0:\n            return []\n        max_num = max(number, max_num)\n        result.append(max_num)\n        \n    return result", "def array_sum(numbers):\n    '''\n    This function calculates the sum of an array of integers.\n    \n    Args:\n        numbers (list): the array of numbers\n\n    Returns:\n        int: the sum of the numbers in the array\n    '''\n    return sum(numbers)", "def highest_number(arr):\n    '''\n    Function to get the highest number in an array of integers\n    \n    Parameters:\n    arr: list of integers\n    \n    Returns:\n    highest number in the array\n    '''\n    highest_num = arr[0]\n    for num in arr:\n        if num > highest_num:\n            highest_num = num\n    return highest_num"]}
{"task_id": 127, "content": ["def smallestPositiveNumber(): \n    n = 1; # Initialize result \n  \n    # Take every number from 3 to n \n    # As n increases exponentially \n    # Check if the number can be represented \n    # as the sum of two numbers \n    while n <= pow(10, 18): \n        if canRepresentedSumOfTwo(n) == False: \n            return n; \n        n += 1; \n  \n    # Return -1 if the number  \n    # cannot be represented as \n    # the sum of two numbers. \n    return -1; ", "def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True", "def is_armstrong_number(num):\n    # Convert the number to a string\n    num_str = str(num)\n    \n    # Get the length of the number\n    length = len(num_str)\n    \n    # Calculate the sum of powers of each digit\n    armstrong_sum = sum(int(digit) ** length for digit in num_str)\n    \n    # Check if the calculated sum is equal to the given number\n    return armstrong_sum == num", "def check_anagram_segments(text: str) -> bool:\n    \"\"\"\n    Given an input string, the function is intended to determine whether it is possible to \n    divide the string into two or more segments that are anagrams of one another. \n\n    Anagrams are words or phrases formed by reordering the letters of a different word or phrase, \n    typically using all the original letters exactly once.\n\n    The function counts the frequency of each unique character in the string and stores it in a dictionary. \n    If all frequencies are even number then the function returns True as the string can be divided into \n    two or more segments that are anagrams of one another. \n    \n    But if there is more than one character with an odd count frequency, then the function returns False\n    as it is not possible to divide the string into segments that are anagrams of one another. \n\n    Parameters:\n    text (str): The string to check for anagram segments\n\n    Returns:\n    bool: True if the string can be divided into anagram segments, False otherwise.\n\n    Examples:\n    \n    >>> check_anagram_samples('abcdefabcdegf')\n    True\n    >>> check_anagram_samples('helloworld')\n    False\n    \"\"\"\n\n    # count the frequency of each unique character in the string\n    frequency = {}\n    for char in text:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n\n    # count characters with odd count frequency\n    count_odd = sum(1 for count in frequency.values() if count % 2)\n\n    return count_odd <= 1", "def sum_powers_two(limit):\n    \"\"\"Calculates the sum of all powers of two up to the given limit.\n    \n    Args:\n        limit (int): The limit of the sum.\n\n    Returns:\n        int: The sum of all powers of two from 2^0 to 2^limit.\n    \"\"\"\n    # Initialize the sum\n    sum = 0\n    \n    # Iterate from 0 to limit and add 2^n to the sum\n    for k in range(limit + 1):\n        sum += 2 ** k\n        \n    return sum"]}
{"task_id": 128, "content": ["def circle_properties(radius):\n    # Calculate the area of the circle\n    area = math.pi * radius**2\n    \n    # Calculate the circumference of the circle\n    circumference = 2 * math.pi * radius\n    \n    return area, circumference", "def circumference(r):\n    '''Calculates the circumference of a circle given its radius'''\n    PI = 3.14159\n    return 2* PI * r", "def circle(r=5):\n    pi = 3.14\n    circumference = 2*pi*r\n    area = pi*r**2\n    return circumference, area", "def circle(r=5):\n    pi = 3.14\n    circumference = 2 * pi * r\n    area = pi * r ** 2\n    return circumference, area", "def get_circle_area(radius):\n    \"\"\"Calculate and return the area of a circle with a given radius.\n \n    Args:\n        radius (float): The radius of the circle\n \n    Returns:\n        float: The area of the circle\n    \"\"\"\n    return 3.14 * (radius * radius)"]}
{"task_id": 129, "content": ["def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list", "def exploit_vulnerability():\n    # This is a placeholder function that simulates the exploitation process.\n    # In practice, this would involve executing a payload that exploits the vulnerability to extract the session keys.\n    print(\"Exploiting the vulnerability to extract the session keys...\")\n    # The session keys would be extracted here and stored in a variable.\n    session_keys = \"extracted_session_keys\"\n    return session_keys", "def revised_function(input_tuple):\n    # Checks if the tuple is None or empty \n    if not input_tuple:\n        return \"Error: input is NULL or empty.\"\n\n    # Initiating an empty list to hold string representations of the float values\n    str_list = []\n\n    # Iterate over the elements in the tuple\n    for element in input_tuple:\n        # Confirm that each element is a float. If not, return an error message.\n        if not isinstance(element, float):\n            return \"Error: all elements in the tuple should be floats.\"\n            \n        # Convert the float to a string and append to the list\n        str_list.append(str(element))\n    \n    # Join all elements in the list with a semicolon\n    result = \"; \".join(str_list)\n    \n    return result", "def sort(list):\n    \"\"\"\n    This function sorts a given list in ascending order.\n\n    Parameters:\n    list (List[int, float, str]): A list of numerical or string values to be sorted. This list should contain elements of the same datatype for the function to work correctly. \n    \"\"\"\n    list.sort()"]}
{"task_id": 130, "content": ["def sortByLength(strings):\n    \"\"\"Sort a list of strings according to their lengths\"\"\"\n    # Sort the list using a key function\n    return sorted(strings, key=len)", "def sort(list):\n    \"\"\"\n    This function sorts a given list in ascending order.\n\n    Parameters:\n    list (List[int, float, str]): A list of numerical or string values to be sorted. This list should contain elements of the same datatype for the function to work correctly. \n    \"\"\"\n    list.sort()", "def sort_list(list):\n    '''\n    Function to sort a list of numbers without using built-in sort function\n    '''\n    sorted_list = []\n    while len(list) > 0: \n        min_value = min(list)\n        sorted_list.append(min_value)\n        list.remove(min_value) \n    return sorted_list", "def frequencySort(nums):\n    # collections.Counter(nums) gives the frequency of each element in the nums array.\n    # items() function returns a view object that displays a list of a dictionary's(an iterable) tuple pair (key, value).\n    c = Counter(nums).items()\n    # Then we will sort the results by the tuple (-count, num). Negative count ensures that high frequency elements come first in the sorted list.\n    # This satisfies the requirement to sort in increasing frequency. \n    # Because we use num for sort as well, elements with the same frequency are sorted in descending order.\n    # This satisfies the requirement to sort in decreasing order on the basis of value of the numbers in case of same frequency.\n    # idx is used to sort elements in increasing order of their index in case elements are same and have same frequency.\n    # sort function of python is stable. i.e, it maintains the relative order of items with equal sort keys\n    nums.sort(key = lambda x: (nums.count(x), -x, [i for i, n in enumerate(nums) if n == x][0]))\n    # return the sorted array\n    return nums", "def complex_sorted_list(lst, reverse=False, min_sum=0, max_sum=None, sort_function=None, secondary_sort_function=None):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter and performs the following:\n    - Delete strings with odd lengths or containing numerals.\n    - Sort the list based on the sum of the ASCII values of the characters in each string.\n    - The list may contain duplicates, ignore case, and special characters.\n    - Toggle sorting between ascending and descending order using an optional boolean `reverse` (default is False).\n    - Implement an optional minimum sum `min_sum` (default is 0) to return only strings with a sum greater or equal.\n    - Implement an optional maximum sum `max_sum` to return only strings with a sum less than or equal.\n    - Implement an optional custom sorting method `sort_function` to sort strings using a custom function.\n    - Implement an optional secondary custom sorting method `secondary_sort_function` to sort strings using a secondary function.\n    \"\"\"\n\n    # Remove strings with odd lengths and strings containing numerals\n    clean_lst = [s for s in lst if len(s) % 2 == 0 and not any(c.isdigit() for c in s)]\n\n    if not sort_function:\n        sort_function = lambda s: sum(ord(c) for c in s)\n\n    if secondary_sort_function:\n        clean_lst.sort(key=secondary_sort_function)\n\n    # Sort strings based on the sort_function\n    clean_lst.sort(key=sort_function, reverse=reverse)\n\n    # Filter strings based on min_sum and max_sum\n    filtered_lst = [s for s in clean_lst if min_sum <= sort_function(s) <= (max_sum if max_sum else float(\"inf\"))]\n\n    return filtered_lst"]}
{"task_id": 131, "content": ["def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def subtract_lists(list1, list2):\n    # Check if both lists have the same length\n    if len(list1) != len(list2):\n        return \"Error: Lists are not of the same length.\"\n\n    # Subtract each pair of elements\n    try:\n        result = [a - b for a, b in zip(list1, list2)]\n    except TypeError as err:\n        return f\"Error: Lists must contain only numbers. {err}\"\n\n    return result", "def frequencySort(nums):\n    # collections.Counter(nums) gives the frequency of each element in the nums array.\n    # items() function returns a view object that displays a list of a dictionary's(an iterable) tuple pair (key, value).\n    c = Counter(nums).items()\n    # Then we will sort the results by the tuple (-count, num). Negative count ensures that high frequency elements come first in the sorted list.\n    # This satisfies the requirement to sort in increasing frequency. \n    # Because we use num for sort as well, elements with the same frequency are sorted in descending order.\n    # This satisfies the requirement to sort in decreasing order on the basis of value of the numbers in case of same frequency.\n    # idx is used to sort elements in increasing order of their index in case elements are same and have same frequency.\n    # sort function of python is stable. i.e, it maintains the relative order of items with equal sort keys\n    nums.sort(key = lambda x: (nums.count(x), -x, [i for i, n in enumerate(nums) if n == x][0]))\n    # return the sorted array\n    return nums", "def sort(list):\n    \"\"\"\n    This function sorts a given list in ascending order.\n\n    Parameters:\n    list (List[int, float, str]): A list of numerical or string values to be sorted. This list should contain elements of the same datatype for the function to work correctly. \n    \"\"\"\n    list.sort()", "def compare_lists(l1, l2):\n    # Converting lists to sets to remove repeating elements and compare unique items\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Checking and printing conditions\n    if sorted(l1) == sorted(l2):\n        print(\"The lists contain the same elements regardless of order and repetition.\")\n        \n    if set1 == set2:\n        print(\"The lists contain the same unique elements regardless of the order.\")\n    \n    if set1 == set2 and l1 != l2:\n        print(\"The lists contain the same elements but in a different order.\")\n     \n    if l1 == l2:\n        print(\"The lists are exactly the same including the order.\")\n    else:\n        print(\"The lists are not exactly the same including the order.\")"]}
{"task_id": 132, "content": ["def count_lists(lst):\n    \"\"\"Main function to count number of lists in a list\"\"\"\n    # Flatten all lists in lst and convert them into tuples\n    lst = [tuple(flatten(sublist)) for sublist in lst if isinstance(sublist, list)]\n    \n    # Get the counts of each tuple\n    return {t: lst.count(t) for t in set(lst)}", "def sum_primes_in_range(start, end):\n    \"\"\"\n    Function to find the sum of all prime numbers within the given range.\n    \n    Parameters: \n    start (int): The start number of the range. \n    end (int): The end number of the range.\n    \n    Returns: \n    int: The sum of all prime numbers in the given range.\n    \"\"\"\n    result = 0\n    for n in range(start, end+1):\n        if is_prime(n):\n            result += n\n    return result", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def compare_lists(list_a, list_b):\n    set_a = set(list_a)\n    set_b = set(list_b)\n\n    # Find the items present in list_a but not in list_b\n    only_in_a = set_a - set_b\n    # Find the items present in list_b but not in list_a\n    only_in_b = set_b - set_a\n    # Find the items present in both lists\n    present_in_both = set_a & set_b\n\n    print('Only in list A:', list(only_in_a))\n    print('Only in list B:', list(only_in_b))\n    print('In both lists:', list(present_in_both))", "def find_permutations(arr):\n    # itertools.permutations method returns all permutations \n    # of the given list arr of length len(arr).\n    # Each permutation is a tuple so we use map function \n    # to convert these tuples to lists\n    perm = list(map(list, itertools.permutations(arr)))\n    \n    # Return the generated permutations\n    return perm"]}
{"task_id": 133, "content": ["def differential_cryptanalysis(ciphertext_pairs):\n    # Analyze the differences between plaintext pairs and their corresponding ciphertext pairs\n    # to deduce patterns in the key schedule.\n    # This function would use statistical analysis and heuristic methods to find patterns.\n    # For simplicity, let's assume we have a function that returns a list of differential pairs\n    # and their corresponding difference after the first round of the cipher.\n    differential_pairs = get_differential_pairs(ciphertext_pairs)\n    \n    # Now we need to analyze the differences and find patterns that can be used to guess the key.\n    # This would involve looking for correlations between the differences and the key schedule parameters.\n    # For example, if certain differences consistently result in certain key schedule parameters,\n    # we could make educated guesses about the key.\n    key_schedule_guesses = analyze_differential_patterns(differential_pairs)\n    \n    return key_schedule_guesses", "def findCombinations(array, total):\n    \"\"\"\n    This function will find all possible combinations of integers in the given array that sum up to the given total.\n    Args:\n        array (list): List of integers.\n        total (int): Total to be reached with the combination of integers.\n    \n    Returns:\n        A list of lists containing the combinations of integers.\n    \"\"\"\n    combinations = []  # list to store the possible combinations\n    for i in range(1 << len(array)):  # loop through all combinations of bits\n        combination = []  # list to store the current combination\n        for j in range(len(array)):  # loop through array elements\n            if i & (1 << j):  # check if bit is set\n                combination.append(array[j])  # add array element to combination\n        if sum(combination) == total:  # check if combination sums to given total\n            combinations.append(combination)  # add combination to list of combinations\n\n    return combinations", "def sum_primes_in_range(start, end):\n    \"\"\"\n    Function to find the sum of all prime numbers within the given range.\n    \n    Parameters: \n    start (int): The start number of the range. \n    end (int): The end number of the range.\n    \n    Returns: \n    int: The sum of all prime numbers in the given range.\n    \"\"\"\n    result = 0\n    for n in range(start, end+1):\n        if is_prime(n):\n            result += n\n    return result", "def sum_array(arr):\n    \"\"\"This function will find the sum of all elements in an array using recursion.\"\"\"\n    # if the array is empty, return 0\n    if not arr:\n        return 0\n\n    # get the last element in the array\n    last = arr[-1]\n\n    # find the sum of the remainder of the array\n    remainder_sum = sum_array(arr[:-1])\n\n    # return the sum of the last element and the remainder of the array\n    return last + remainder_sum", "def sum_2d_array(arr):\n    \"\"\"\n    This function calculates the sum of all elements in a 2D array.\n    \n    Parameters\n    ----------\n    arr : list\n        2D array of numbers\n    \n    Returns\n    -------\n    int\n        sum of all elements in the array\n    \"\"\"\n    # initialize the sum\n    sums = 0\n    \n    # iterate through each element in the array\n    for row in arr:\n        for val in row:\n            # add the element to the sum\n            sums += val\n    return sums"]}
{"task_id": 134, "content": ["def max_difference(arr):\n    \"\"\"\n    This function takes a list of integers and returns the maximum difference between any two elements in the list.\n    \n    Args:\n    arr: A list of integers\n    \n    Returns:\n    int: Maximum difference between any two elements in the list\n    \"\"\"\n    if len(arr) < 2:\n        return 0\n    else:\n        max_diff = max(arr) - min(arr)\n        return max_diff", "def max_difference(numbers):\n    if len(numbers) < 2:\n        click.echo(\"At least two numbers are required to calculate the maximum difference.\")\n    else:\n        max_diff = max(numbers) - min(numbers)\n        click.echo(f\"The maximum difference between any two elements in the list is: {max_diff}\")", "def max_difference(arr):\n    if len(arr) < 2:\n        return None  # There must be at least two elements in the array to find the difference\n\n    max_diff = arr[1] - arr[0]  # Initialize the maximum difference as the difference between the first two elements\n    min_element = min(arr[0], arr[1])  # Initialize the minimum element as the smaller of the first two elements\n\n    for i in range(2, len(arr)):\n        if arr[i] - min_element > max_diff:\n            max_diff = arr[i] - min_element  # Update the maximum difference if a larger one is found\n        if arr[i] < min_element:\n            min_element = arr[i]  # Update the minimum element if a smaller one is found\n\n    return max_diff", "def find_difference(data):\n  # Find the minimum and maximum elements in the list\n  min_element = min(data)\n  max_element = max(data)\n  \n  # Calculate the difference between the maximum and minimum elements\n  difference = max_element - min_element\n  \n  # Return the difference\n  return difference", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]"]}
{"task_id": 135, "content": ["def ascii_check(lst):\n    \"\"\"\n    This function accepts a list of strings, returning a string indicating the count of ASCII characters in every individual string in the list. Each response should be part of a list, stating \"the number of ASCII characters in the i'th input string\" - \"i\" should be replaced with the actual count of ASCII characters present.\n    \n    >>> ascii_check(['Test%$','ASCII@!'])\n    [\"the number of ASCII characters is 6 in the string 1 of the input.\",\n     \"the number of ASCII characters is 7 in the string 2 of the input.\"]\n    >>> ascii_check(['123#','Hello_*'])\n    [\"the number of ASCII characters is 4 in the string 1 of the input.\",\n     \"the number of ASCII characters is 7 in the string 2 of the input.\"]\n    \"\"\"\n    result = []\n    for i, string in enumerate(lst, 1):\n        ascii_count = len([char for char in string if ord(char) < 128])\n        result.append(\"the number of ASCII characters is {} in the string {} of the input.\".format(ascii_count, i))\n    return result", "def custom_order(s):\n    \"\"\"\n    This function takes a string 's' and sorts the letters in it based on their ASCII values, ignoring case. It then sorts them based on the count of each letter in the string, conserving the original letter casing.\n    \"\"\"\n\n    # Convert the string to a list of characters\n    s_list = list(s)\n\n    # This line sorts the list first by the ASCII value of each character in a case-insensitive manner, \n    # then by the count of the character in the string (which prioritizes letters with higher counts), \n    # and finally by the position of the character in the original string (to preserve the original order of equal elements).\n    s_list.sort(key=lambda x: (ord(x.lower()), -s_list.count(x), s_list.index(x)))\n\n    # Convert the sorted list of characters back into a string \n    sorted_s = ''.join(s_list)\n\n    return sorted_s", "def custom_order(s):\n    \"\"\"\n    This function takes a string 's' and sorts the letters in it based on their ASCII values, ignoring case. \n    It then sorts them based on the count of each letter in the string, preserving the original letter casing.\n    \"\"\"\n\n    # Convert the string to a list of characters\n    s_list = list(s)\n\n    # This line sorts the list first by the ASCII value of each character in a case-insensitive manner, \n    # then by the count of the character in the string (which prioritizes letters with higher counts),\n    # and finally by the position of the character in the original string (to preserve the original order of equal elements)\n    s_list.sort(key=lambda x: (ord(x.lower()), s_list.count(x), s_list.index(x)))\n\n    # Convert the sorted list of characters back into a string\n    sorted_s = ''.join(s_list)\n\n    return sorted_s", "def reverse_string_with_ascii_shift(s):\n    # Convert the string to a list of characters\n    char_list = list(s)\n    \n    # Shift each character's ASCII value to the left\n    for i in range(len(char_list)):\n        char_list[i] = chr(ord(char_list[i]) - ord('a'))\n    \n    # Reverse the list of characters\n    char_list.reverse()\n    \n    # Shift each character's ASCII value back to its original value\n    for i in range(len(char_list)):\n        char_list[i] = chr(ord(char_list[i]) + ord('a'))\n    \n    # Convert the list of characters back to a string\n    reversed_string = ''.join(char_list)\n    return reversed_string", "def has_unique_chars(string):\n    # If the string has more than 128 characters,\n    # it must have repeated characters.\n    if len(string) > 128:\n        return False\n    \n    # Create an array of 128 booleans, initialized to False.\n    # The index represents the ASCII value of a character,\n    # and the value at that index represents whether that\n    # character has been encountered before or not.\n    char_set = [False] * 128\n    \n    # Iterate through each character in the string.\n    for char in string:\n        # Get the ASCII value of the character.\n        ascii_value = ord(char)\n        \n        # If the character has already been encountered before,\n        # return False.\n        if char_set[ascii_value]:\n            return False\n        \n        # Mark the character as encountered.\n        char_set[ascii_value] = True\n    \n    # If no characters were encountered twice,\n    # return True.\n    return True"]}
{"task_id": 136, "content": ["def maxSumPath(grid, k):\n    # Given each cell has distinct value, the maximum k cells will always be the maximum k values in the grid.\n    # Flatten the grid to a list and sort it in reverse order\n    values = sorted(sum(grid, []), reverse=True)\n    max_values = values[:k]\n    max_sum = sum(max_values)\n    # Compute path which is the value itself in this case\n    path = max_values\n\n    return [max_sum, path]", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def findCombinations(array, total):\n    \"\"\"\n    This function will find all possible combinations of integers in the given array that sum up to the given total.\n    Args:\n        array (list): List of integers.\n        total (int): Total to be reached with the combination of integers.\n    \n    Returns:\n        A list of lists containing the combinations of integers.\n    \"\"\"\n    combinations = []  # list to store the possible combinations\n    for i in range(1 << len(array)):  # loop through all combinations of bits\n        combination = []  # list to store the current combination\n        for j in range(len(array)):  # loop through array elements\n            if i & (1 << j):  # check if bit is set\n                combination.append(array[j])  # add array element to combination\n        if sum(combination) == total:  # check if combination sums to given total\n            combinations.append(combination)  # add combination to list of combinations\n\n    return combinations", "def generate_input_file():\n    # The input file should be generated in such a way that it produces the maximum product of final[1] and final[3],\n    # and the maximum key in the results dictionary.\n    # To achieve this, the input file should be carefully crafted to produce the desired output when processed by the given function.\n    # The specific details of the input file content and format depend on the logic within the given function, and may require trial and error to determine the optimal input file content.\n\n    # As the exact logic within the given function is not provided, the generation of the input file content involves reverse-engineering the function's behavior and requirements.\n\n    # The solution to this problem involves analyzing the given function's behavior and requirements, and crafting an input file that fulfills those conditions to produce the desired output.\n\n    # Due to the specific nature of the input file content required to achieve the desired output, the exact content and format of the input file cannot be provided without further information about the given function's internal logic and requirements.\n\n    # Therefore, the solution involves understanding the behavior of the given function and crafting an input file that, when processed by the function, produces the maximum product of final[1] and final[3], and the maximum key in the results dictionary.\n\n    # The generation of the input file content may involve experimentation and analysis to determine the optimal values and structure that result in the desired output when processed by the given function.\n\n    # As the specific details of the input file content and format are not provided, the solution involves a process of reverse-engineering and experimentation to determine the appropriate input file content that fulfills the given requirements.\n\n    return \"Generated input file content\""]}
{"task_id": 137, "content": ["def parse_log_line(line):\n    # This is a placeholder function. In a real scenario, you would use a library\n    # such as 'pandas' to parse the log line into a structured format.\n    # For the purpose of this example, we'll assume the log line is a simple string.\n    parts = line.split()\n    timestamp = parts[0]\n    ip_address = parts[1]\n    action = parts[2]\n    return timestamp, ip_address, action", "def check_anagram_segments(text: str) -> bool:\n    \"\"\"\n    Given an input string, the function is intended to determine whether it is possible to \n    divide the string into two or more segments that are anagrams of one another. \n\n    Anagrams are words or phrases formed by reordering the letters of a different word or phrase, \n    typically using all the original letters exactly once.\n\n    The function counts the frequency of each unique character in the string and stores it in a dictionary. \n    If all frequencies are even number then the function returns True as the string can be divided into \n    two or more segments that are anagrams of one another. \n    \n    But if there is more than one character with an odd count frequency, then the function returns False\n    as it is not possible to divide the string into segments that are anagrams of one another. \n\n    Parameters:\n    text (str): The string to check for anagram segments\n\n    Returns:\n    bool: True if the string can be divided into anagram segments, False otherwise.\n\n    Examples:\n    \n    >>> check_anagram_samples('abcdefabcdegf')\n    True\n    >>> check_anagram_samples('helloworld')\n    False\n    \"\"\"\n\n    # count the frequency of each unique character in the string\n    frequency = {}\n    for char in text:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n\n    # count characters with odd count frequency\n    count_odd = sum(1 for count in frequency.values() if count % 2)\n\n    return count_odd <= 1", "def partition(nums):\n    \"\"\"\n    Partitions the given list into two parts such that\n    the sum of the two parts are equal.\n    @param nums: List\n    @return: List\n    \"\"\"\n    total = sum(nums)\n    curr_sum = 0\n    left_list = []\n    right_list = []\n    \n    for num in nums:\n        if curr_sum <= total/2:\n            left_list.append(num)\n            curr_sum += num\n        else:\n            right_list.append(num)\n    return (left_list, right_list)", "def extract_digits(number):\n    # Convert the number to a string\n    number_str = str(number)\n\n    # Check if the number is negative\n    is_negative = False\n    if number_str.startswith('-'):\n        is_negative = True\n        number_str = number_str[1:]\n\n    # Split the number into integer and decimal parts\n    parts = number_str.split('.')\n    integer_part = parts[0]\n    decimal_part = parts[1] if len(parts) > 1 else ''\n\n    # Extract the digits from the integer part\n    integer_digits = [int(digit) for digit in integer_part]\n\n    # Extract the digits from the decimal part\n    decimal_digits = [int(digit) for digit in decimal_part]\n\n    # Combine the digits into a single array\n    digits = integer_digits + decimal_digits\n\n    # Add the sign if the number was negative\n    if is_negative:\n        digits.insert(0, '-')\n\n    return digits", "def extract_integer(number: float) -> int:\n    \"\"\"\n    A floating-point number can be bifurcated into an integer part (the largest integer no greater\n    than the input number) and a fraction part (the residual fragment, persistently less than 1 \n    but more than -1). \n\n    Architect this function in such a way that it unravels the integer sector of a number, whether \n    it is positive or negative.\n    \"\"\"\n    return math.floor(number)"]}
{"task_id": 138, "content": ["def differential_for_key(key, plaintext_difference):\n    # This function would generate a differential for the given key and plaintext difference\n    # In practice, this would involve complex cryptanalysis to find the differential\n    # that results in the desired ciphertext difference\n    return differential", "def longestIncreasingSubsequence(arr):\n    \"\"\"Function to find the longest increasing subsequence in a given array\"\"\"\n    n = len(arr)\n    # initialize the dp array \n    dp = [1] * n \n  \n    # Loop through the given array and compute \n    # other entries in the dp array \n    for i in range (1, n): \n        for j in range(i): \n            if (arr[i] > arr[j] and dp[i] < dp[j] + 1):\n                dp[i] = dp[j] + 1\n\n    # Find the maximum entry in the dp array\n    maximum = 0\n    for i in range(n): \n        if (maximum < dp[i]): \n            maximum = dp[i] \n\n    # return the longest increasing subsequence\n    return maximum", "def differential_cryptanalysis(ciphertext_pairs):\n    # Analyze the differences between plaintext pairs and their corresponding ciphertext pairs\n    # to deduce patterns in the key schedule.\n    # This function would use statistical analysis and heuristic methods to find patterns.\n    # For simplicity, let's assume we have a function that returns a list of differential pairs\n    # and their corresponding difference after the first round of the cipher.\n    differential_pairs = get_differential_pairs(ciphertext_pairs)\n    \n    # Now we need to analyze the differences and find patterns that can be used to guess the key.\n    # This would involve looking for correlations between the differences and the key schedule parameters.\n    # For example, if certain differences consistently result in certain key schedule parameters,\n    # we could make educated guesses about the key.\n    key_schedule_guesses = analyze_differential_patterns(differential_pairs)\n    \n    return key_schedule_guesses", "def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def longest_increasing_subsequence(sequence):\n    \"\"\"\n    This function uses dynamic programming to find the longest increasing subsequence in the input array. \n\n    Firstly, we initialize the list length with size as input array size. Each element in length represents the longest \n    increasing subsequence in sequence[0...i]. After initializing the list length with 1, the function fills length in \n    a bottom-up manner(using dynamic programming), i.e., if sequence[j] > sequence[i] for some i < j and length[j] < length[i] + 1,\n    then update length[j].\n\n    Finally, the function returns the maximum value from the list length.\n\n    :param sequence: An input array of integers\n    :type sequence: list\n    :return: The longest increasing subsequence in the array\n    :rtype: int\n    \"\"\"\n\n    # initialize the list length with 1's because a minimum increasing subsequence would just be one number itself\n    length = [1] * len(sequence)\n\n    # loop over the sequence from the second element\n    for i in range(1, len(sequence)):\n        # consider all smaller elements found so far\n            for j in range(i):\n                # if this element is bigger, check if we can increase the length of the largest subsequence ending at i\n                if sequence[i] > sequence[j] and length[i] < length[j] + 1:\n                    length[i] = length[j] + 1\n\n    # return the maximum length found\n    return max(length)"]}
{"task_id": 139, "content": ["def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True", "def productExceptSelf(nums):\n    # Python's len() function is how you get the length of lists, strings, and other sequence types\n    length = len(nums)\n    \n    # Python lists use [] and you don't need to specify a size upfront, \n    # so here we are making a list of 1's with the same length as the input\n    answer = [1]*length\n\n    # Python's range() function is used for loops that iterate over a sequence of integers\n    # It starts at the first parameter (0 if not specified) and steps by 1 (or second parameter) until it reaches (but does not include) the second parameter\n    # So here it is going from 1 to length\n    for i in range(1, length):\n        # Python uses indentation to denote blocks, so this line is the body of the loop\n        # It is multiplying the previous number in nums by the previous number in answer and storing it in the current spot in answer\n        answer[i] = nums[i-1] * answer[i-1]\n    \n    # A stand-alone variable to accumulate the product as we move right-to-left through the list\n    R = 1\n\n    # This range is going from length-1 down to 0\n    # The third parameter to range is the step, so making it -1 steps backwards through the sequence\n    for i in range(length-1, -1, -1):\n        # For the current spot in answer, multiply it by R, updating the value in answer\n        answer[i] *= R\n\n        # Also, multiply R by the current number in nums\n        R *= nums[i]\n    \n    # Just like Go, Python uses return to send back an output from a function\n    return answer", "def find_next_number(sequence):\n    # Get the last number in the sequence\n    last_number = sequence[-1]\n\n    # Check if the last number is a power of 2 and less than 1000\n    if last_number < 1000 and last_number & (last_number - 1) == 0:\n        # If it is, multiply it by 2 to find the next number\n        next_number = last_number * 2\n    else:\n        # If not, print an error message\n        print(\"Invalid sequence! The last number is not a power of 2 or it exceeds 1000.\")\n        return\n\n    return next_number", "def attach_to_process(pid):\n    # This is a placeholder function. In reality, you would need to use a lower-level\n    # library or system call to perform this action, which is not exposed through\n    # the Python standard library.\n    # For example, you might use the libc library to call ptrace()\n    # This is beyond the scope of a simple Python script and would require a\n    # more complex setup and environment.\n    pass", "def restart_program():\n    # sys.argv[0] is the script name (it's operating system dependent whether\n    # this is a full pathname or not). If the script name is an absolute path,\n    # then no path search is performed, and the file is loaded directly.\n    python = sys.executable\n    os.execl(python, python, * sys.argv)"]}
{"task_id": 140, "content": ["def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True", "def is_multiple(n):\n    \"\"\"\n    Function to check if a given number is a multiple of 3 or 5.\n    \n    Parameters: \n    n (int): The given number to check.\n    \n    Returns: \n    bool: True if number is a multiple of 3 or 5, False otherwise.\n    \"\"\"\n    return n % 3 == 0 or n % 5 == 0", "def is_palindrome(s): \n    '''This function returns True or False based on whether the given string is a palindrome or not'''\n    # reverse the string\n    rev = s[::-1] \n  \n    # Check if string is equal to its reverse \n    if (s == rev): \n        return True\n    return False", "def is_numeric(val):\n    \"\"\"\n    Check if a given value is numeric\n\n    :param val: The value to be checked\n    :return: A boolean indicating whether the given value is numeric or not\n    \"\"\"\n    return val.isnumeric()", "def restart_program():\n    # sys.argv[0] is the script name (it's operating system dependent whether\n    # this is a full pathname or not). If the script name is an absolute path,\n    # then no path search is performed, and the file is loaded directly.\n    python = sys.executable\n    os.execl(python, python, * sys.argv)"]}
{"task_id": 141, "content": ["def sort_array(arr, col_idx, ascending=True):\n    \"\"\"\n    Sorts a two-dimensional array based on a specific column index.\n    :param arr: The array to be sorted.\n    :param col_idx: The index of the column to sort by.\n    :param ascending: Whether to sort in ascending (True) or descending (False) order.\n    :return: The sorted array.\n    \"\"\"\n    # Get the column to sort by\n    col = arr[:, col_idx]\n    \n    # Handle NaN and infinite values\n    col[np.isnan(col)] = np.inf\n    col[np.isinf(col)] = np.nan\n    \n    # Sort the column and get the sorting indices\n    sorted_indices = np.argsort(col)\n    \n    # Reverse the sorting indices if descending order is specified\n    if not ascending:\n        sorted_indices = sorted_indices[::-1]\n    \n    # Sort the array using the sorting indices\n    sorted_arr = arr[sorted_indices]\n    \n    return sorted_arr", "def anti_shuffle(s):\n    \"\"\"\n    Function that accepts a string and produces an ordered variant using the custom sort function.\n    The ordered variant of a string is a new phrase where every word (partitioned by space)\n    is replaced by a new word where every character adheres to the custom sort methodology.\n    The word and blank space sequence in the sentence remains unchanged.\n\n    Args:\n    s: String\n\n    Returns:\n    The modified string with each word sorted according to the rules of custom_sort\n    \"\"\"\n\n    sorted_words = [custom_sort(word) for word in s.split(\" \")]\n    return ' '.join(sorted_words)", "def sort_elements(array, cond_fn):\n    return sorted(array, key=cond_fn) # Sort by the condition function", "def sortByLength(strings):\n    \"\"\"Sort a list of strings according to their lengths\"\"\"\n    # Sort the list using a key function\n    return sorted(strings, key=len)", "def frequencySort(nums):\n    # collections.Counter(nums) gives the frequency of each element in the nums array.\n    # items() function returns a view object that displays a list of a dictionary's(an iterable) tuple pair (key, value).\n    c = Counter(nums).items()\n    # Then we will sort the results by the tuple (-count, num). Negative count ensures that high frequency elements come first in the sorted list.\n    # This satisfies the requirement to sort in increasing frequency. \n    # Because we use num for sort as well, elements with the same frequency are sorted in descending order.\n    # This satisfies the requirement to sort in decreasing order on the basis of value of the numbers in case of same frequency.\n    # idx is used to sort elements in increasing order of their index in case elements are same and have same frequency.\n    # sort function of python is stable. i.e, it maintains the relative order of items with equal sort keys\n    nums.sort(key = lambda x: (nums.count(x), -x, [i for i, n in enumerate(nums) if n == x][0]))\n    # return the sorted array\n    return nums"]}
{"task_id": 142, "content": ["def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass", "def find_rop_gadgets(base_address):\n    # This function would use a database of known ROP gadgets or a tool like ROPgadget to find gadgets.\n    gadgets = []\n    # Code to find ROP gadgets goes here\n    return gadgets", "def inorder_traversal(root):\n    \"\"\"Write a function to traverse a binary search tree in-order, printing out the values it encounters.\n\n    :param root: The root node of the binary search tree\n    \"\"\"\n    if not root:\n        return\n\n    inorder_traversal(root.left)\n    print(root.val)\n    inorder_traversal(root.right)", "def depth_first_search(graph, value):\n    visited = []  # keep track of already visited nodes\n    stack = [\"A\"]  # setting the initial starting node\n\n    while stack:  # loop over the stack\n        vertex = stack.pop()  # get the last element of the stack\n\n        if vertex not in visited:\n            if graph[vertex] == [value]:  # if the node has the value we want, return the node\n                return vertex\n\n            visited.append(vertex)  # add the node to the visited array\n\n            for adjacency in graph[vertex]:  # append the node's children to the stack\n                stack.append(adjacency)", "def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) "]}
{"task_id": 143, "content": ["def delete_element(my_list, pos):\n    \"\"\"Function to delete an element from a given list at a given position.\"\"\"\n    del my_list[pos]\n    return my_list", "def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list", "def remove_elem(string, elem):\n    \"\"\"\n    This function removes a specified element from the given string of words.\n    \n    Parameters:\n    string (str): The input string containing words.\n    elem (str): The element to be removed from the string.\n    \n    Returns:\n    str: The updated string without the specified element.\n    \"\"\"\n    return ' '.join([word for word in string.split() if word != elem])", "def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def unique_permutations(lst):\n    \"\"\"\n    Function to compute every unique permutation of elements within a given list\n    \"\"\"\n    return list(itertools.permutations(lst))"]}
{"task_id": 144, "content": ["def add_digits(number):\n    \"\"\"This function adds all the digits of a given number \n    and returns the result.\n    \n    Args:\n        number (int): The number to process.\n    \n    Returns:\n        int: The result of adding all the digits of the given number.\n    \"\"\"\n    if number < 10:\n        return number\n    total = number % 10 + add_digits(number // 10)\n    return total", "def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]", "def check_integer(number):\n    if number % 2 == 0:\n        if number % 3 == 0:\n            print(\"The given integer is even and a multiple of 3.\")\n        else:\n            print(\"The given integer is even and not a multiple of 3.\")\n    else:\n        if number % 3 == 0:\n            print(\"The given integer is odd and a multiple of 3.\")\n        else:\n            print(\"The given integer is odd and not a multiple of 3.\")", "def hamming_weight(byte):\n    # Implement this function to calculate the Hamming weight of a byte.\n    # The Hamming weight is the number of 1's in the byte.\n    # This can be done using a bitwise operation that counts the number of bits set to 1.\n    return bin(byte).count('1')", "def is_multiple(n):\n    \"\"\"\n    Function to check if a given number is a multiple of 3 or 5.\n    \n    Parameters: \n    n (int): The given number to check.\n    \n    Returns: \n    bool: True if number is a multiple of 3 or 5, False otherwise.\n    \"\"\"\n    return n % 3 == 0 or n % 5 == 0"]}
{"task_id": 145, "content": ["def factorial_of_tuple_elements(tup: Tuple, result: List):\n    \"\"\"\n    Calculate factorials of all integer values in a tuple (including nested tuples) and \n    append them to a specified list. Non-integer types and non-positive integers are ignored.\n   \n    Args:\n      tup: Tuple with nested tuples and integer values.\n      result: Original list to append the factorials to.\n   \n    Returns:\n      A list with factorials of all integer values found in the tuple.\n    \"\"\"\n    if tup == ():\n        return 'Error: Tuple is empty.'\n    else:\n        flattened = list(itertools.chain.from_iterable([[i] \n        if not isinstance(i, tuple) else list(i) for i in tup]))\n        for i in flattened:\n            if isinstance(i, int) and i >= 0:\n                result.append(math.factorial(i))\n            elif isinstance(i, float) and i >= 0:\n                result.append(math.factorial(round(i)))\n    return result", "def wrapper_func(list_of_ints, tuple_of_ints):\n    \"\"\"\n    This function takes a list of integers and a tuple of two integers.\n    It uses the erroneous_splice function on each integer in the list, with the tuple values as the delimeter.\n    The results of each operation are stored in a list and returned.\n    \"\"\"\n    results = []\n    for num in list_of_ints:\n        results.append(erroneous_splice([num], tuple_of_ints[0]))\n        results.append(erroneous_splice([num], tuple_of_ints[1]))\n    return results", "def wrapper_func(list_of_ints, tuple_of_ints):\n    \"\"\"\n    This function takes a list of integers and a tuple of two integers,\n    It uses the erroneous_slice function on each integer in the list, with the tuple values as the delimiter.\n    The results of each operation are stored in a list and returned.\n    \"\"\"\n    results = []\n    for num in list_of_ints:\n        results.append(erroneous_slice([num], tuple_of_ints[0]))\n        results.append(erroneous_slice([num], tuple_of_ints[1]))\n    return results", "def revised_function(input_tuple):\n    # Checks if the tuple is None or empty \n    if not input_tuple:\n        return \"Error: input is NULL or empty.\"\n\n    # Initiating an empty list to hold string representations of the float values\n    str_list = []\n\n    # Iterate over the elements in the tuple\n    for element in input_tuple:\n        # Confirm that each element is a float. If not, return an error message.\n        if not isinstance(element, float):\n            return \"Error: all elements in the tuple should be floats.\"\n            \n        # Convert the float to a string and append to the list\n        str_list.append(str(element))\n    \n    # Join all elements in the list with a semicolon\n    result = \"; \".join(str_list)\n    \n    return result", "def process_input(input_string):\n    # Split the input string by whitespace and convert the values to integers\n    values_list = list(map(int, input_string.split()))\n    \n    # Ensure that the input contains exactly three values\n    if len(values_list) != 3:\n        raise ValueError(\"Input should contain exactly three values separated by spaces\")\n    \n    # Return the three integers as a tuple\n    return tuple(values_list)"]}
{"task_id": 146, "content": ["def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list", "def stealth_delivery(payload):\n    # This function is a placeholder for actual stealth techniques.\n    # In a real-world scenario, the attacker might use techniques like encoding,\n    # encoding the payload multiple times, or using sleep delays to evade detection.\n    # Here we just return the payload as is, which is a basic example of stealth.\n    return payload", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass", "def encode_shellcode(shellcode):\n    # This function would apply various encoding techniques to obfuscate the shellcode\n    # For example, XOR encoding, Base64 encoding, etc.\n    # The goal is to make the shellcode non-recognizable to signature-based detection\n    encoded_shellcode = b''\n    # Logic for encoding goes here\n    # ...\n    return encoded_shellcode", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass"]}
{"task_id": 147, "content": ["def find_common_elements(*arrays):\n    # Convert all arrays into Python's built-in Set data structure, \n    # which automatically eliminates duplicates within individual arrays\n    sets = [set(arr) for arr in arrays]\n    \n    # The Python's built-in set.intersection method can be used to find elements that \n    # exist in all sets (i.e., all arrays). It takes any number of arguments (sets), \n    # so the * operator is used to unpack list of sets as arguments.\n    common_elements = set.intersection(*sets)\n    \n    # The sorted build-in function is used to sort the resulting set of common elements \n    # in ascending order\n    return sorted(common_elements)", "def minimal_operations(string):\n    # Count the frequency of each character\n    frequency = {}\n    for char in string:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    \n    # Find the character with the highest frequency\n    max_frequency = max(frequency.values())\n    \n    # Calculate the number of operations needed to make all characters equal to the character with the highest frequency\n    operations = 0\n    for char, count in frequency.items():\n        operations += abs(count - max_frequency)\n    \n    return operations", "def obfuscate_code(code):\n    # This function would modify the bytecode of the Python script\n    # to make it harder to detect and analyze.\n    pass", "def combination_generator(lst, r):\n    combinations = []  # Initialize an empty list to store the combinations\n    \n    # Create a loop to pick every element\n    for i in range(len(lst)):\n        \n        # Create a loop to create permutations of the picked elements\n        for j in combinations:\n            s = j[:]  # Make a copy of the combination\n            s.append(lst[i])  # Append the current element to the combination\n            \n            # Check if the length of the combination is equal to the desired number of elements\n            if len(s) == r:\n                combinations.append(s)\n            \n            # Check if the length of the combination is less than the desired number of elements\n            elif len(s) < r:\n                combinations.append(s)\n                \n                # Create a nested loop to continue adding more elements to the combination\n                for k in range(i+1, len(lst)):\n                    s = s[:]  # Make a copy of the current combination\n                    s.append(lst[k])  # Append the next element to the combination\n                    \n                    # Check if the length of the combination is equal to the desired number of elements\n                    if len(s) == r:\n                        combinations.append(s)\n    \n    return combinations", "def estimate_quantum_security_level(public_key, n, q):\n    # Estimate the number of qubits and quantum operations required by a quantum adversary\n    # to solve the LWE instance using Shor's algorithm.\n    # For simplicity, we assume that the number of qubits required is directly proportional to the\n    # dimension of the secret vector n, and the number of operations is directly proportional to the\n    # number of matrix multiplications and additions (which is n^2).\n    # These estimates are not accurate and are provided for illustrative purposes.\n    # In practice, the actual number of qubits and operations would depend on the specifics of the LWE\n    # instance and the complexity of Shor's algorithm.\n    num_qubits = n * n  # This is a simplification, but in practice, it's not this simple\n    num_operations = n * n  # This is a simplification, but in practice, it's not this simple\n    return num_qubits, num_operations"]}
{"task_id": 148, "content": ["def get_day_of_week(year, month, day):\n    '''This function returns the name of the day of the week for a given date'''\n    date = datetime.date(year, month, day)\n    return date.strftime(\"%A\")", "def month_date_range(year, month):\n    \"\"\"\n    Get first and last day of given month and year.\n    \n    Arguments:\n    year -- The year for the given month (int)\n    month -- The given month (int)\n    \n    Returns:\n    A tuple containing the first and last day of the month in YYYY-MM-DD format.\n    \"\"\"\n    \n    # Get the last day of the month\n    last_day = calendar.monthrange(year, month)[1]\n    \n    # Create date objects\n    first_day_date = datetime(year, month, 1)\n    last_day_date = datetime(year, month, last_day)\n    \n    # Convert to strings\n    first_day_str = first_day_date.strftime('%Y-%m-%d')\n    last_day_str = last_day_date.strftime('%Y-%m-%d')\n    \n    # Return as tuple\n    return (first_day_str, last_day_str)", "def predict_weather(day_of_year):\n    # Get the day, month, and year from the day of the year\n    day, month, year = datetime.date.fromordinal(day_of_year).timetuple()[2:]\n    \n    # Call a function to get the average temperature for that day\n    avg_temp = get_average_temp(day, month, year)\n    \n    # Predict the weather based on the average temperature\n    if avg_temp > 0:\n        return 'warm'\n    elif avg_temp < 0:\n        return 'cold'\n    else:\n        return 'neutral'", "def is_valid_date(date_str):\n    # Check if the string has the correct length\n    if len(date_str) != 10:\n        return False\n\n    # Split the string into month, day, and year\n    month, day, year = date_str.split('/')\n\n    # Check if the month is a valid number\n    try:\n        month = int(month)\n        if month < 1 or month > 12:\n            return False\n    except ValueError:\n        return False\n\n    # Check if the day is a valid number\n    try:\n        day = int(day)\n        if day < 1 or day > 31:\n            return False\n    except ValueError:\n        return False\n\n    # Check if the year is a valid number\n    try:\n        year = int(year)\n    except ValueError:\n        return False\n\n    # Check if it's a leap year\n    if month == 2 and day == 29:\n        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            return True\n        else:\n            return False\n\n    # Check if the day is valid for the given month\n    if month == 2 and day > 28:\n        return False\n    elif month in [4, 6, 9, 11] and day > 30:\n        return False\n\n    return True", "def count_weekdays(year, month, day=None):\n    # get the weekday and the total days in the month\n    first_day, num_days = calendar.monthrange(year, month)\n    # create a list representing the weekdays of each day in the month [0,1,2,....]\n    days = [(first_day+i)%7 for i in range(num_days)]\n    \n    if day is None:  # if no specific day is given\n        # return the count of each weekday\n        return {calendar.day_name[i]: days.count(i) for i in range(7)}\n    else:\n        # return the count of the specific weekday\n        return {calendar.day_name[day]: days.count(day)}"]}
{"task_id": 149, "content": ["def is_fibonacci(n):\n    \"\"\"Helper function to check if a number is a Fibonacci number.\"\"\"\n    x = 0\n    y = 1\n    while y < n:\n        z = x\n        x = y\n        y = z + y\n    return y == n", "def rectangle_intersection(rect1: Tuple[int,...], rect2: Tuple[int,...]) -> bool:\n    # Function to check if two rectangles intersect\n    axes = [(0,1), (1,0)]\n    for ax in axes:\n        projections1 = [dot_product(*ax, x, y) for (x, y) in rect1]\n        projections2 = [dot_product(*ax, x, y) for (x, y) in rect2]\n        if not (min(projections1) <= max(projections2) and min(projections2) <= max(projections1)):\n            return False\n    return True", "def choose_num(x, y, z):\n    \"\"\"This function should take three positive numbers x, y, and z. The function must return \n    the largest even integer number that is less than or equal to y and greater than or equal \n    to x, which is also a multiple of z. In case no such number exists, the function should return None.\n    \n    Validate your code with the added complexity of handling potential exceptions.\n    \"\"\"  \n    if not (type(x) == type(y) == type(z) == int):\n        return \"Error: Inputs must be integers.\"\n\n    if not (x >= 0 and y >= 0 and z >= 0):\n        return \"Error: Inputs must be positive.\"\n\n    if x > y:\n        return \"Error: x should be less than or equal to y.\"\n\n    #Initialize the largest number as None.\n    largest_num = None\n    \n    #Iterate from y to x both inclusive to find largest even multiple of z.\n    for i in range(y, x - 1, -1):\n        if i % z == 0 and i % 2 == 0:\n            largest_num = i\n            break\n        \n    #Return the largest number.\n    return largest_num", "def is_fibonacci(n):\n    \"\"\"Check if a number is a Fibonacci number. Note: This function can only check Fibonacci numbers up to the 10,000th\"\"\"\n    x = 0\n    y = 1\n    while True:\n        fib = x + y\n        if fib > n:\n            return False\n        if fib == n:\n            return True\n        x = y\n        y = fib", "def swap(x, y):\n    \"\"\"Function that swaps the values of two variables.\"\"\"\n    temp = x\n    x = y\n    y = temp\n    return x, y"]}
{"task_id": 150, "content": ["def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list", "def remove_elements(arr, match):\n    \"\"\"\n    Remove all the elements of a given list that match a given element.\n    \"\"\"\n    # Create a new list from the given list\n    result = [x for x in arr if x != match]\n    \n    return result", "def display_even_elements(list):\n    \"\"\"Function to display all the even elements from a given list\"\"\"\n    \n    # List to store the even elements\n    even_list = []\n    \n    # Iterate through each element in the list\n    for elem in list:\n        # If even, append it to the list\n        if elem % 2 == 0:\n            even_list.append(elem)\n    \n    # Return the list\n    return even_list", "def remove_item(my_list, item):\n  \"\"\"Remove all occurrences of a given item from a list\"\"\"\n  # Loop through the items in the list\n  for i in my_list:\n    # Check if current item is the item to remove\n    if i == item:\n      # Remove the item from the list\n      my_list.remove(i)\n  return my_list", "def sort(list):\n    \"\"\"\n    This function sorts a given list in ascending order.\n\n    Parameters:\n    list (List[int, float, str]): A list of numerical or string values to be sorted. This list should contain elements of the same datatype for the function to work correctly. \n    \"\"\"\n    list.sort()"]}
{"task_id": 151, "content": ["def sum_of_integers(arr):\n    # Create a set to store unique positive integers\n    unique_integers = set()\n    \n    # Iterate through the array\n    for num in arr:\n        # Ignore negative integers\n        if num < 0:\n            continue\n        # Add positive integers to the set\n        unique_integers.add(num)\n    \n    # Return the sum of the unique positive integers\n    return sum(unique_integers)", "def sum_and_product_of_digits(n):\n    # Convert negative integers to positive integers\n    if n < 0:\n        n = abs(n)\n    \n    # Convert the integer to a string\n    n_str = str(n)\n    \n    # Calculate the sum of the digits\n    digit_sum = sum([int(digit) for digit in n_str])\n    print(\"Sum of digits:\", digit_sum)\n    \n    # Calculate the product of the least significant digit and the second least significant digit\n    if len(n_str) > 1:\n        least_sig_digit = int(n_str[-1])\n        second_least_sig_digit = int(n_str[-2])\n        product = least_sig_digit * second_least_sig_digit\n        print(\"Product of least and second least significant digits:\", product)\n    else:\n        print(\"The number has only one digit, so the product cannot be calculated.\")", "def calculate_mean(numbers):\n    \"\"\"\n    A function to calculate the mean of a list of integers and returns a string of the mean value.\n\n    Parameters:\n    numbers (list): a list of integers\n    \n    Returns:\n    str: the mean value formatted as a string\n    \"\"\"\n    mean = sum(numbers)/len(numbers)\n    return 'The mean is {}'.format(mean)", "def factorial(n):\n    \"\"\"\n    Calculates the factorial of an integer (n \u2265 0) and returns None for negative values.\n    The factorial function is not defined for negative integers. Instead of returning an error or exception, \n    this function returns None and prints out a message.\n    The function proves to be internally consistent with the known factorial function for non-negative integers \n    (i.e., n! = n*(n-1)*(n-2)*...*3*2*1 for n\u22650).\n    \"\"\"\n    if n < 0:\n        print(\"The factorial function isn\u2019t defined for negative integers\")\n        return None\n    elif n == 0:\n        return 1\n    else:\n        fact = 1\n        for i in range(1, n + 1):\n            fact *= i\n        return fact", "def lcm(a, b):\n    \"\"\"\n    Function to calculate the Least Common Multiple (LCM) of two numbers using the formula:\n    lcm(a, b) = abs(a*b) / gcd(a, b)\n    \"\"\"\n    if a < 1 or b < 1:\n        raise ValueError(\"Both numbers should be positive integers.\")\n  \n    return abs(a*b) // gcd(a, b)"]}
{"task_id": 152, "content": ["def calculate_polygon_area(n, s):\n    \"\"\"\n    Calculate the area of a regular polygon.\n\n    :param n: Number of sides of the regular polygon\n    :param s: Length of each side of the regular polygon\n    :return: Area of the regular polygon\n    \"\"\"\n    area = (n * s ** 2) / (4 * math.tan(math.pi / n))\n    return area", "def calculatePolygonArea(n, r):\n    angle = (2 * math.pi) / n  # Calculate the interior angle of the regular polygon\n    area = (r ** 2) * math.sin(angle) / 2  # Calculate the area using the formula\n    return area", "def area_of_regular_polygon(side, n_sides):\n    \"\"\"Calculate area of a given regular polygon with known side length and number of sides\n    \"\"\"\n    return (n_sides * side**2) / (4 * math.tan(math.pi/n_sides))", "def polygon_area(coordinates):\n    \"\"\"\n    Given pairs of x,y coordinates as inputs, calculate the surface area of the resulting polygon.\n    This function computes areas of complex, non-rectangular polygons.\n\n    In order to calculate, it uses Gauss's Area formula (also called Shoelace Theorem):\n    https://en.wikipedia.org/wiki/Shoelace_formula\n\n    This formula calculates the signed area. If the coordinates are covered in a counterclockwise direction,\n    the signed area is positive, if clockwise, the signed area is negative. The abs function cares about the absolute value.\n    \"\"\"\n\n    area = 0.0\n    for i in range(len(coordinates)):\n        x1, y1 = coordinates[i]\n        x2, y2 = coordinates[(i+1) % len(coordinates)]  # cyclically next vertex\n        area += x1*y2 - x2*y1\n    return abs(area)/2", "def surface_area_regular_polygon(n):\n    \"\"\"\n    Computes the surface area of a regular polygon with n sides, given its side length\n    \"\"\"\n    area = (n * (math.pow(n, 2) - (math.pow(n-1, 2))) / 4) * math.pow(math.pi, 2)\n    return area"]}
{"task_id": 153, "content": ["def check_rectangle(point1, point2):\n    \"\"\"\n    Function to check if two points form a rectangle.\n    \"\"\"\n    # If the coordinates of point1 & point2 are same, it's not a rectangle.\n    if point1 == point2:\n        return False\n    # If the x-coordinates or y-coordinates are same, it's not a rectangle.\n    elif point1[0] == point2[0] or point1[1] == point2[1]:\n        return False\n    return True", "def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True", "def binary_nor(list1, list2):\n    # Check whether lists are of same length\n    if len(list1) != len(list2):\n        raise ValueError(\"Lists are not of same length.\")\n\n    nor_list = []\n    for num1, num2 in zip(list1, list2):\n        # Perform NOR operation and append result in list\n        nor_list.append(int(not(num1 or num2)))\n\n    return nor_list", "def loadmat(filename):\n    '''\n    this function should be called instead of direct spio.loadmat\n    as it cures the problem of not properly recovering python dictionaries\n    from mat files. It calls the function check keys to cure all entries\n    which are still mat-objects\n    '''\n    data = spio.loadmat(filename, struct_as_record=False, squeeze_me=True)\n    return _check_keys(data)", "def verify_divisibility_and_evenness(numbers, divisor):\n    ''' \n    This function accepts a list of numbers and a divisor then \n    verifies whether each number in the list is divisible by the divisor \n    and is even.\n\n    It returns a list of tuples, with each tuple containing a number \n    and a boolean value indicating whether that number satisfies the conditions\n    \n    @param numbers: List of numbers to be checked\n    @param divisor: The divisor to check divisibility\n    '''\n\n    # Validate inputs\n    if not isinstance(numbers, list) or not isinstance(divisor, int):\n        raise ValueError(\"Invalid Input. Only list of numbers and integer divisor are allowed\")\n    \n    return [ (num, num % divisor == 0 and num % 2 == 0) for num in numbers]"]}
{"task_id": 154, "content": ["def cipher(s):\n    \"\"\"Derive a python function called 'cipher' that takes a string parameter and returns a ciphered string utilizing a rotated alphabet (the alphabet is shifted three positions ahead, using the modulo operator in Python to handle wrapping at the ends). This function should conserve the case of the characters (upper and lower), keep the non-alphabetical characters unchanged in the derived output, and work for all characters of the lower case and uppercase English alphabets. Here are some examples:\n    cipher('Hi') renders 'Lm'\n    cipher('aSdFgHjKl') tends to become 'dUgIjLmNpQr'\n    cipher('Zx112e_') translates to 'Ca!I23h_'\n    cipher('E.x + Uz') is turned into 'H.a + Xc'\n    \"\"\"\n    result = ''\n\n    for char in s:\n    # preserve the non-alphabetical characters\n        if not char.isalpha():\n            result += char\n            continue\n\n    # shift three positions ahead, with case consideration\n        shifted_char = chr((ord(char.lower()) - 97 + 3) % 26 + 97) if char.islower() else chr((ord(char.upper()) - 65 + 3) % 26 + 65)\n        result += shifted_char\n\n    return result", "def cipher(s):\n    \"\"\"Derive a python function called 'cipher' that takes a string parameter and returns a ciphered string utilizing a rotated alphabet (the alphabet is shifted three positions ahead, using the modulo operator in Python to handle wrapping at the ends). This function should conserve the case of the characters (upper and lower), keep the non-alphabetical characters unchanged in the derived output, and work for all characters of the lower case and uppercase English alphabets. Here are some examples:\n    cipher('Hi') renders 'Lm'\n    cipher('aSdFgHjKl') tends to become 'dVgIjKmNpQr'\n    cipher('Zx!123_') translates to 'Ca!123_'\n    cipher('E.T + Ux') is turned into 'H.Y + Xc'\n    \"\"\"\n    result = ''\n    \n    for char in s:\n        # preserve the non-alphabetical characters\n        if not char.isalpha():\n            result += char\n            continue\n\n        # shift three positions ahead, with case consideration\n        shifted_char = chr((ord(char.lower()) - 97 + 3) % 26 + 97) if char.islower() else chr((ord(char.upper()) - 65 + 3) % 26 + 65)\n        result += shifted_char\n\n    return result", "def generate_random_string(characters):\n    # Check if the input string contains at least one vowel\n    if not any(char in 'aeiouAEIOU' for char in characters):\n        raise ValueError(\"Input string must contain at least one vowel.\")\n    \n    # Count the number of vowels in the characters string\n    num_vowels = sum(char in 'aeiouAEIOU' for char in characters)\n    \n    # Generate a random string with the same length as the number of vowels\n    random_string = ''.join(random.choice(characters) for _ in range(num_vowels))\n    \n    return random_string", "def categorize_string(s):\n    # Use lowercase function to make the string case insensitive\n    s = s.lower()\n\n    # Define alphabet characters\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\n    characters = collections.defaultdict(int)\n\n    # Count each character in the string\n    for char in s:\n        if char in alphabet:\n            characters[char] += 1\n\n    return dict(characters)", "def check_str(string):\n    '''\n    This function takes a string as input and checks if it contains all letters of the \n    English alphabet (a-z).\n    '''\n\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    for letter in alphabet:\n        if letter not in string.lower():\n            return False\n    return True"]}
{"task_id": 155, "content": ["def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]", "def foo(lst):\n    \"\"\"\n    This function takes a list of integers as input and returns a new list that only contains even numbers. \n    If the input list does not contain any even numbers, the function returns an empty list.\n    \"\"\"\n    even_lst = [] # Create an empty list to store even numbers in\n    for num in lst: # Loop through each number in the input list\n        if num % 2 == 0: # Check if the number is even\n            even_lst.append(num) # If it is, add it to the even_lst\n    return even_lst # Return the even_lst", "def write_rfid_data(rfid_writer, data):\n    # This function would interface with an RFID writer to write RFID badge data.\n    # Writes the data to a blank RFID badge.\n    print(f\"Cloned RFID badge with data: {data}\")", "def secure_communication():\n    # This is a placeholder function. In practice, you would use Python libraries such as PyCrypto or PyNaCl\n    # to encrypt the communication with the C2 server.\n    pass", "def accumulate_even_numbers():\n    count = 0\n    total = 0\n    number = 0\n    while count < 5:  # We want the first five even numbers\n        if number % 2 == 0:  # Check if the number is even\n            total += number  # Add the number to total\n            count += 1  # Increment count since we found an even number\n        number += 1  # Move on to the next number\n    return total"]}
{"task_id": 156, "content": ["def check_number(n):\n    if is_power_of_three(n):\n        largest_power_of_three = find_largest_power_of_three(n)\n        num_binary_digits = count_binary_digits(largest_power_of_three)\n        print(f\"{n} is a power of three. Largest power of three less than or equal to {n} is {largest_power_of_three} (with {num_binary_digits} binary digits).\")\n    else:\n        print(f\"{n} is not a power of three.\")", "def sieve_eratosthenes(N):\n    \"\"\"\n    This function uses the Sieve of Eratosthenes algorithm to generate all prime numbers up to N.\n    The function returns a generator that yields the prime numbers one by one, allowing for memory-efficient processing of large ranges.\n\n    The function also includes a check to ensure the input is an integer greater than one and raises a custom exception if it is not.\n\n    :param N: The upper limit of the range to search for primes. Must be an integer greater than one.\n    :returns: A generator that yields the prime numbers up to N one by one.\n    :raises ValueError: If N is not an integer or is less than or equal to one.\n    \"\"\"\n    if not isinstance(N, int) or N <= 1:\n        raise ValueError(\"Input must be an integer greater than one.\")\n    primes = [True for _ in range(N+1)]\n    p = 2\n    while p * p <= N:\n        if primes[p]:\n            for i in range(p * p, N + 1, p):\n                primes[i] = False\n        p += 1\n    for p in range(2, N):\n        if primes[p]:\n            yield p", "def square_nums(n, m):\n    # Check if n and m are positive integers\n    if n <= 0 or m <= 0 or type(n) != int or type(m) != int:\n        return \"n and m must be positive integers.\"\n    \n    # Check if m is greater than or equal to n\n    if m < n:\n        return \"m must be greater than or equal to n.\"\n    \n    # Calculate the squares of the numbers from n to m\n    result = [i ** 2 for i in range(n, m+1)]\n    return result", "def arithmetic_sum_with_factorials(a, b):\n    # check if a and b are integers\n    if not isinstance(a, int) or not isinstance(b, int):\n        return \"Error: a and b must be integers.\"\n    # check if a < 2 or b > 6\n    elif a < 2 or b > 6:\n        return \"Error: a must be greater than or equal to 2 and b must be less than or equal to 6.\"\n    # check if a > b\n    elif a > b:\n        return \"Error: a must be less than or equal to b.\"\n    else:\n        # calculate arithmetic sum\n        total = 0\n        for num in range(a, b + 1):\n            total += factorial(num)\n        return total", "def choose_num(x, y, z):\n    \"\"\"This function should take three positive numbers x, y, and z. The function must return \n    the largest even integer number that is less than or equal to y and greater than or equal \n    to x, which is also a multiple of z. In case no such number exists, the function should return None.\n    \n    Validate your code with the added complexity of handling potential exceptions.\n    \"\"\"  \n    if not (type(x) == type(y) == type(z) == int):\n        return \"Error: Inputs must be integers.\"\n\n    if not (x >= 0 and y >= 0 and z >= 0):\n        return \"Error: Inputs must be positive.\"\n\n    if x > y:\n        return \"Error: x should be less than or equal to y.\"\n\n    #Initialize the largest number as None.\n    largest_num = None\n    \n    #Iterate from y to x both inclusive to find largest even multiple of z.\n    for i in range(y, x - 1, -1):\n        if i % z == 0 and i % 2 == 0:\n            largest_num = i\n            break\n        \n    #Return the largest number.\n    return largest_num"]}
{"task_id": 157, "content": ["def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def frequencySort(nums):\n    # collections.Counter(nums) gives the frequency of each element in the nums array.\n    # items() function returns a view object that displays a list of a dictionary's(an iterable) tuple pair (key, value).\n    c = Counter(nums).items()\n    # Then we will sort the results by the tuple (-count, num). Negative count ensures that high frequency elements come first in the sorted list.\n    # This satisfies the requirement to sort in increasing frequency. \n    # Because we use num for sort as well, elements with the same frequency are sorted in descending order.\n    # This satisfies the requirement to sort in decreasing order on the basis of value of the numbers in case of same frequency.\n    # idx is used to sort elements in increasing order of their index in case elements are same and have same frequency.\n    # sort function of python is stable. i.e, it maintains the relative order of items with equal sort keys\n    nums.sort(key = lambda x: (nums.count(x), -x, [i for i, n in enumerate(nums) if n == x][0]))\n    # return the sorted array\n    return nums", "def binary_search(arr, num):\n    \"\"\"\n    Function to use binary search to find a given number in a given array.\n\n    Arguments:\n    arr -- input array\n    num -- number to be found\n\n    Returns:\n    res -- boolean value\n    \"\"\"\n\n    # Initialize boolean variable\n    res = False\n\n    # Find the mid-point of the array\n    mid = int(len(arr)/2)\n\n    # initialize the beginning and end of the array\n    start = 0\n    end = len(arr) - 1\n\n    # If the number is in the array, set boolean as True\n    if num == arr[mid]:\n        res = True\n\n    # If the number is less than the mid-point of the array, \n    # make the end of the array the mid-point - 1\n    elif num < arr[mid]:\n        end = mid - 1\n\n    # Else, make the start of the array the mid-point + 1\n    else:\n        start = mid + 1\n\n    # If the start and the end of the array have not met each other, \n    # make a recursive call to the binary search function\n    if start <= end:\n        return binary_search(arr[start:end+1], num)\n\n    return res", "def linear_search(arr, target):\n    \"\"\"\n    Searches through a given input array to find the index of a provided target number.\n    Returns -1 if the target number is not found.\n    \"\"\"\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1"]}
{"task_id": 158, "content": ["def pell(n):\n    # check if the value is already computed\n    if n not in pell_dict:\n        # calculate the nth term of the sequence\n        pell_dict[n] = 2 * pell(n-1) + pell(n-2)\n    return pell_dict[n]", "def calculate_fibonacci(n):\n    \"\"\"\n    This function calculates the nth number of the Fibonacci sequence using iteration.\n    \n    Parameters:\n        n (int): The number in the Fibonacci sequence to calculate.\n        \n    Returns:\n        The nth number of the Fibonacci sequence.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    a, b = 0, 1\n    for i in range(2, n+1):\n        c = a + b\n        a, b = b, c\n        \n    return b", "def calculate_geometric_mean(num_list):\n    product = 1  # This variable will hold the multiplied result of all numbers in the num_list\n\n    for num in num_list:\n        # Multiply each number in num_list with the product\n        product *= num \n\n    # Calculate the geometric mean by taking the nth root of product\n    # where n is the number of elements in the list.\n    # The math.pow function calculates the power of a number.\n    # Since we need to calculate the nth root, the power is 1/n.\n    geometric_mean = math.pow(product, 1/len(num_list))\n\n    return geometric_mean", "def fibonacci_iterative(n):\n    \"\"\"\n    Calculate the nth Fibonacci number using an iterative approach.\n\n    Args:\n    n: An integer representing the position of the Fibonacci number to be calculated.\n\n    Returns:\n    The nth Fibonacci number.\n    \"\"\"\n    if n <= 0:\n        return \"Invalid input\"\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n):\n            a, b = b, a + b\n        return b", "def Fibonacci(N):\n    '''This functions takes in a non-negative integer N and returns the Nth Fibonacci number.'''\n    if N <= 1:\n        return N\n    else:\n        # define a cache to store Fibonacci numbers\n        cache = [0] * (N+1)\n        # return value of nth Fibonacci numbers\n        cache[0] = 0\n        cache[1] = 1\n        for i in range(2, N+1):\n            # calculate the nth Fibonacci number\n            cache[i] = cache[i-1] + cache[i-2]\n            \n        return cache[N]"]}
{"task_id": 159, "content": ["def get_list_items_with_indices(items_all, indices):\n    getter = itemgetter(*indices)  # Create a getter function based on the specified indices\n    items = list(getter(items_all))  # Use the getter function to retrieve the items at the specified indices\n    return items  # Return the list of retrieved items", "def find_matching_strings(list_of_strings, query):\n    '''This function takes a list of strings and a string query, then returns the indices of strings that match the query.'''\n    # Generate a list of indices of matching strings\n    indices = []\n    for i, s in enumerate(list_of_strings):\n        if query in s:\n            indices.append(i)\n    # Return the list of indices\n    return indices", "def two_sum(numbers, target):\n    \"\"\"\n    Find the indices of two numbers in a list which add up to the target number.\n    \n    Parameters:\n        numbers (list): List of numbers\n        target (int): Target number\n\n    Returns:\n        (int, int): Indices of two numbers in the list which add up to the target number\n    \"\"\"\n    for i, num1 in enumerate(numbers):\n        for j, num2 in enumerate(numbers[i+1:]):\n            if num1 + num2 == target:\n                return (i, j+i+1)", "def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def find_max(numbers):\n    \"\"\"\n    Find the maximum value in a list of numbers.\n\n    Args:\n    numbers (list): A list of numbers.\n\n    Returns:\n    float: The maximum value in the input list.\n    \"\"\"\n    if not numbers:\n        return None\n    return max(numbers)"]}
{"task_id": 160, "content": ["def area_perimeter_circle(radius):\n    \"\"\"Function to return the area and perimeter of a circle\"\"\"\n    area = 3.14 * (radius ** 2)\n    perimeter = 2 * 3.14 * radius\n    return area, perimeter", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass", "def triangle_inradius(a, b, c):\n    \"\"\"Calculates the inradius of a triangle.\"\"\"\n    area = heron_triangle_area(a, b, c)\n    perimeter = triangle_perimeter(a, b, c)\n    inradius = 2 * area / perimeter\n    return inradius", "def find_rop_gadgets(base_address):\n    # This function would use a database of known ROP gadgets or a tool like ROPgadget to find gadgets.\n    gadgets = []\n    # Code to find ROP gadgets goes here\n    return gadgets", "def triangle_perimeter(a, b, c):\n    \"\"\"Calculates the perimeter of a triangle.\"\"\"\n    return a + b + c"]}
{"task_id": 161, "content": ["def is_item_in_list(item, my_list):\n    '''This function checks if an item exists in a given list and returns a boolean value.\n    Parameters\n    ----------\n    item: The item to be checked.\n    my_list: The list in which the item is to be checked. \n    \n    Returns\n    --------\n    boolean: True if the item is present in the list, and False if it is not.\n    '''\n\n    return item in my_list", "def remove_item(my_list, item):\n  \"\"\"Remove all occurrences of a given item from a list\"\"\"\n  # Loop through the items in the list\n  for i in my_list:\n    # Check if current item is the item to remove\n    if i == item:\n      # Remove the item from the list\n      my_list.remove(i)\n  return my_list", "def merge_lists(lists):\n    merged_list = []\n    # Iterate through each list in the given list of lists\n    for lst in lists:\n        # Iterate through each item in that list\n        for item in lst:\n            # Append the item to the merged list\n            merged_list.append(item)\n    return merged_list", "def flatten(lst):\n  flat_list = []  # Empty list to store flattened items\n  \n  for item in lst:  # Loop through the list items\n    if type(item) is list:  # If the item is a list, call the flatten function recursively\n      flat_list.extend(flatten(item))\n    else:  # Otherwise, append the item to the list\n      flat_list.append(item)\n  \n  return flat_list  # Return the flattened list", "def unique_items(my_list):\n    '''This function takes in a list of items and returns the unique items.'''\n    \n    unique_list = []\n    \n    # Iterate through the items in my_list\n    for item in my_list:\n        # Check if the item is already in the unique list\n        if item not in unique_list:\n            # If the item is not present, add it to the unique list\n            unique_list.append(item)\n    \n    return unique_list"]}
{"task_id": 162, "content": ["def generate_password():\n    '''This function will generate a random password of length 8 that consists of alphanumeric characters.'''\n    # Generate a random string of 8 alphanumeric characters\n    alphanumeric = string.ascii_letters + string.digits\n    password = ''.join(random.choice(alphanumeric) for _ in range(8))\n    \n    return password", "def generate_sequence(length):\n    \"\"\"\n    This function generates a random alphanumeric sequence of a given length.\n    \n    Parameters:\n    length (int): The desired length of the sequence.\n    \n    Returns:\n    str: The generated sequence.\n    \"\"\"\n    # Get all alphanumeric characters\n    all_characters = string.ascii_letters + string.digits\n\n    # Generate a sequence by randomly sampling from the characters without replacement\n    sequence = ''.join(random.sample(all_characters, length))\n\n    return sequence", "def reciprocal_sequence(sequence):\n    \"\"\"\n    This function takes in a sequence of alphanumeric characters,\n    and returns them in a reciprocal order.\n    \"\"\"\n    try:\n        return sequence[::-1]\n    except TypeError:\n        raise TypeError(\"Input sequence must be a list or string\")", "def remove_special_characters(string):\n    # Remove non-alphanumeric characters and special characters within alphanumeric characters\n    string = re.sub('[^a-zA-Z0-9]+', '', string)\n    \n    # Convert uppercase letters to lowercase\n    string = string.lower()\n    \n    return string", "def shuffle_string(string):\n    # The shuffle_string function takes a string as input and returns a shuffled version of it.\n    # It uses the random module's sample function to randomly sample characters from the input string,\n    # creating a new string that is a shuffled version of the original one.\n    shuffledStr = ''.join(random.sample(string, len(string)))\n    return shuffledStr"]}
{"task_id": 163, "content": ["def merge_dicts(*dict_args):\n    '''\n    Given any number of dictionaries, shallow copy and merge into a new dictionary,\n    precedence goes to key-value pairs in latter dictionaries.\n    '''\n    result = {}\n    for dictionary in dict_args:\n        result.update(dictionary)\n    return result", "def remove_key_values(dictionary: dict, keys: list) -> dict:\n    \"\"\"\n    Removes specified key-value pairs from a dictionary\n    Args:\n    dictionary: Input dictionary\n    keys: List of keys to be removed\n    Returns:\n    Modified dictionary with specified key-value pairs removed\n    \"\"\"\n    for key in keys:\n        dictionary.pop(key, None)\n    return dictionary", "def fixture_data_item_to_dict(data_item):\n    # Split the data_item string into key-value pairs\n    pairs = data_item.strip().split(',')\n    \n    # Create a dictionary from the key-value pairs\n    dict_ = {}\n    for pair in pairs:\n        key, value = pair.split(':')\n        dict_[key.strip()] = value.strip()\n    \n    return dict_", "def convert_to_json(str1, str2, str3):\n    # Split the input strings into key-value pairs\n    key1, value1 = str1.split(\", \")\n    key2, value2 = str2.split(\", \")\n    key3, value3 = str3.split(\", \")\n    \n    # Create a dictionary with the key-value pairs\n    json_dict = {\n        key1: value1,\n        key2: value2,\n        key3: value3\n    }\n    \n    # Convert the dictionary to a JSON object and return it\n    return json.dumps(json_dict)", "    def load_attrs(self, config):\n        \"\"\"\n        Load attributes from a configuration dictionary.\n\n        Args:\n        config (dict): A dictionary containing attribute key-value pairs.\n\n        Returns:\n        None\n        \"\"\"\n        self.attrs.update(config)"]}
{"task_id": 164, "content": ["def generate_sequences(lst):\n    '''\n    This function should take a list of strings of parentheses as input and should generate all possible arrangements of these strings. \n    It should yield an iterable (for instance, a list or a generator) of combined strings, each being a distinct\n    arrangement of the input.\n    '''\n    return map(''.join, itertools.permutations(lst))", "def generate_sequences(lst):\n    '''\n    This function should take a list of strings of parentheses as input and should generate all possible arrangements of these strings. \n    It should yield an iterable (for instance, a list or a generator) of combined strings, each being a distinct arrangement of the input.\n    '''\n    return map(''.join, itertools.permutations(lst))", "def shuffle_string(string):\n    # The shuffle_string function takes a string as input and returns a shuffled version of it.\n    # It uses the random module's sample function to randomly sample characters from the input string,\n    # creating a new string that is a shuffled version of the original one.\n    shuffledStr = ''.join(random.sample(string, len(string)))\n    return shuffledStr", "def integrity_check(shellcode):\n    # This is a placeholder function that should contain the logic to verify the integrity of the shellcode\n    # For example, it could calculate a checksum or perform a known-good execution\n    return True", "def create_asterisk_string(n):\n    \"\"\"\n    This function returns a string of length n filled with asterisks.\n    :param n: The length of the string to be created.\n    :return: A string of asterisks with length n.\n    \"\"\"\n    return '*' * n"]}
{"task_id": 165, "content": ["def get_triangle(radius):\n    # The largest inscribed triangle in a semicircle is equilateral triangle.\n    # The length of the triangle's side equals the semicircle's diameter.\n\n    # Hence, the coordinates of the vertices of the triangle are:\n    a = (-radius, 0)\n    b = (radius, 0)\n    c = (0, radius)\n\n    # The area of an equilateral triangle is computed using the formula: (s^2 * sqrt(3)) / 4\n    # where s is the side length of the triangle. \n    # The side length of our triangle is twice the radius (which is the diameter of the semicircle).\n    area = ((2*radius)**2 * math.sqrt(3)) / 4\n    \n    # The perimeter of an equilateral triangle is 3 times its side.\n    # The side length of our triangle is twice the radius (which is the diameter of the semicircle).\n    perimeter = 3 * (2*radius)\n\n    return area, a, b, c, perimeter", "def triangle_perimeter(a, b, c):\n    \"\"\"Calculates the perimeter of a triangle.\"\"\"\n    return a + b + c", "def get_triangle(radius):\n    # The largest inscribed triangle in a semicircle is equilateral_triangle.\n    # The length of the triangle's_side_equals the semicircle's diameter.\n\n    # Hence, the coordinates of the vertices of the triangle are:\n    a = (-radius, 0)\n    b = (radius, 0)\n    c = (0, radius)\n\n    # The area of an equilateral triangle is computed using the formula: (s^2 * sqrt(3)) / 4\n    # where s is the side length of the triangle. \n    # The side length of our_triangle is twice the radius (which is the diameter_of the semicircle).\n    area = ((2*radius)**2 * math.sqrt(3)) / 4\n\n    # The perimeter of an equilateral triangle is 3 times its side.\n    # The side length of our triangle is twice the radius (which is the diameter of the semicircle).\n    perimeter = 3 * (2*radius)\n\n    return area, a, b, c, perimeter", "def triangle_inradius(a, b, c):\n    \"\"\"Calculates the inradius of a triangle.\"\"\"\n    area = heron_triangle_area(a, b, c)\n    perimeter = triangle_perimeter(a, b, c)\n    inradius = 2 * area / perimeter\n    return inradius", "def area_perimeter_circle(radius):\n    \"\"\"Function to return the area and perimeter of a circle\"\"\"\n    area = 3.14 * (radius ** 2)\n    perimeter = 2 * 3.14 * radius\n    return area, perimeter"]}
{"task_id": 166, "content": ["def generate_input_file():\n    # The input file should be generated in such a way that it produces the maximum product of final[1] and final[3],\n    # and the maximum key in the results dictionary.\n    # To achieve this, the input file should be carefully crafted to produce the desired output when processed by the given function.\n    # The specific details of the input file content and format depend on the logic within the given function, and may require trial and error to determine the optimal input file content.\n\n    # As the exact logic within the given function is not provided, the generation of the input file content involves reverse-engineering the function's behavior and requirements.\n\n    # The solution to this problem involves analyzing the given function's behavior and requirements, and crafting an input file that fulfills those conditions to produce the desired output.\n\n    # Due to the specific nature of the input file content required to achieve the desired output, the exact content and format of the input file cannot be provided without further information about the given function's internal logic and requirements.\n\n    # Therefore, the solution involves understanding the behavior of the given function and crafting an input file that, when processed by the function, produces the maximum product of final[1] and final[3], and the maximum key in the results dictionary.\n\n    # The generation of the input file content may involve experimentation and analysis to determine the optimal values and structure that result in the desired output when processed by the given function.\n\n    # As the specific details of the input file content and format are not provided, the solution involves a process of reverse-engineering and experimentation to determine the appropriate input file content that fulfills the given requirements.\n\n    return \"Generated input file content\"", "def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min", "def complex_rounding(value, low, high):\n    '''\n    Craft a function that takes in a number represented as a string, value, and two \n    integers, low and high, establishing range delimiters. This function should yield \n    the nearest integer to the input number without falling back on standard functions such \n    as round(). Alongside this, ascertain that the specified number is a valid integer or \n    floating-point number residing within the defined interval. Otherwise, \n    reciprocate with an error alert. For numbers at an equal distance from two integers, conform it \n    towards zero.\n    '''\n    # Check if the input value is a valid number\n    try:\n        num_value = Decimal(value)\n    except InvalidOperation:\n        return \"Error: Invalid input.\"\n    \n    # Check if the value is within the given range\n    if not (low <= num_value <= high):\n        return \"Error: Beyond range.\"\n      \n    # Round according to the rules specified\n    decimal, integer = divmod(num_value, 1)\n    \n    if decimal >= Decimal('0.5'):\n        return int(integer + 1)\n    elif decimal <= Decimal('-0.5'):\n        return int(integer - 1)\n    else:\n        return int(integer)", "def complex_rounding(value, low, high):\n    \"\"\"\n    Create a function that takes in a number represented as a string, value, and two \n    integers, low and high, establishing range parameters. This function should yield \n    the nearest integer to the input number without falling back on standard functions such\n    as round(). Alongside this, ascertain that the specified number is a valid integer or \n    floating-point number residing within the defined interval. Otherwise, \n    reciprocate with an error alert. For numbers at an equal distance from two integers, round it \n    towards zero.\n    \"\"\"\n    # Check if the input value is a valid number\n    try:\n        num_value = Decimal(value)\n    except InvalidOperation:\n        return \"Error: Invalid input.\"\n\n    # Check if the value is within the given range\n    if not (low <= num_value <= high):\n        return \"Error: Beyond range.\"\n\n    # Round according to the rules specified\n    decimal, integer = divmod(num_value, 1)\n\n    if decimal <= Decimal('0.5'):\n        return int(integer + 1)\n    elif decimal <= Decimal('-0.5'):\n        return int(integer - 1)\n    else:\n        return int(integer)", "def add_numbers(a, b):\n    '''This function adds two given numbers and prints their sum.'''\n    print(\"The sum of\", a, \"and\", b, \"is\", a + b)"]}
{"task_id": 167, "content": ["def substring_filter(string_list, substring):\n    \"\"\"\n    This function takes a list of strings and a substring to search for. It returns a new list with the strings\n    that contain the substring.\n    \"\"\"\n    filtered_list = []\n    for string in string_list:\n        if substring in string:\n            filtered_list.append(string)\n    return filtered_list", "def sorted_list(lst, reverse=False):\n    \"\"\"\n    This function takes a list of string literals, discards strings that are of odd lengths or contain digits, \n    and returns a sorted list according to the specified stipulations.\n    The list is sorted based on the length of each word in an ascending sequence. \n    For words of equivalent length, it is sorted in alphabetical order. \n    Case sensitivity and special characters are ignored during the sorting operation.\n    An optional boolean parameter `reverse`, with a default value set to False, can be used to toggle the sorting pattern \n    between ascending and descending.\n    Note:\n    The input will always be a list of string literals and can never be of numeric type.\n    The list can have duplicate elements.\n    \"\"\"\n    import re\n    \n    # Filter out string literals of odd length and those containing digits\n    filtered_list = [x for x in lst if len(x) % 2 == 0 and not bool(re.search(r'\\d', x))]\n    \n    # Sort the list first by length, then by alphabetical order (case insensitive), and optionally in reverse order\n    return sorted(filtered_list, key=lambda x: (len(x), x.lower()), reverse=reverse)", "def check_unique_strings(strings):\n    '''This function takes a list of strings and returns a boolean \n    indicating whether all the strings in the list are unique.'''\n    seen = set()\n    for string in strings:\n        if string in seen:\n            return False\n        seen.add(string)\n    return True", "def inorder_traversal(root):\n    \"\"\"Write a function to traverse a binary search tree in-order, printing out the values it encounters.\n\n    :param root: The root node of the binary search tree\n    \"\"\"\n    if not root:\n        return\n\n    inorder_traversal(root.left)\n    print(root.val)\n    inorder_traversal(root.right)", "def searchString(search, strings):\n  for string in strings:\n    if search == string:\n      return True\n  return False"]}
{"task_id": 168, "content": ["def is_multiple(n):\n    \"\"\"\n    Function to check if a given number is a multiple of 3 or 5.\n    \n    Parameters: \n    n (int): The given number to check.\n    \n    Returns: \n    bool: True if number is a multiple of 3 or 5, False otherwise.\n    \"\"\"\n    return n % 3 == 0 or n % 5 == 0", "def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True", "def check_integer(number):\n    if number % 2 == 0:\n        if number % 3 == 0:\n            print(\"The given integer is even and a multiple of 3.\")\n        else:\n            print(\"The given integer is even and not a multiple of 3.\")\n    else:\n        if number % 3 == 0:\n            print(\"The given integer is odd and a multiple of 3.\")\n        else:\n            print(\"The given integer is odd and not a multiple of 3.\")", "def linear_search(arr, target):\n    \"\"\"\n    Searches through a given input array to find the index of a provided target number.\n    Returns -1 if the target number is not found.\n    \"\"\"\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1", "def extract_integer(number) -> int:\n    try:\n        # Check if input is a float or integer\n        if not isinstance(number, (float, int)):\n            return 'Error: Invalid input.'\n\n        # Check if number is too large\n        if abs(number) > 1.7e308:\n            return 'Error: Number too large.'\n        \n        # Return the largest integer less than or equal to the given number\n        return int(number // 1) if number >= 0 else int(number // 1) - 1\n    \n    except TypeError:\n        return 'Error: Invalid input.'\n\n    except OverflowError:\n        return 'Error: Number too large.'"]}
{"task_id": 169, "content": ["def get_coordinate_range(latitude, longitude, distance):\n    # Approximate radius of the Earth in kilometers\n    earth_radius = 6371\n\n    # Convert distance from miles to kilometers\n    distance = distance * 1.60934\n\n    # Convert latitude and longitude to radians\n    lat_rad = math.radians(latitude)\n    lon_rad = math.radians(longitude)\n\n    # Calculate the angular distance in radians\n    angular_distance = distance / earth_radius\n\n    # Calculate the new latitude and longitude range\n    min_lat = math.degrees(lat_rad - angular_distance)\n    max_lat = math.degrees(lat_rad + angular_distance)\n    min_lon = math.degrees(lon_rad - angular_distance / math.cos(lat_rad))\n    max_lon = math.degrees(lon_rad + angular_distance / math.cos(lat_rad))\n\n    return (min_lat, max_lat, min_lon, max_lon)", "def get_closest_hotels(latitude, longitude):\n  # Initialize a list of hotels\n  hotels = []\n  # Calculate the distance from each hotel to the given coordinates\n  for hotel in hotels:\n    distance = calculate_distance(hotel, latitude, longitude)\n    # Add the hotel and its distance to the list\n    hotels.append([hotel, distance])\n  # Sort the list by distance\n  hotels = sorted(hotels, key= lambda x: x[1])\n  # Return the 3 closest hotels\n  return hotels[:3]", "def distance(p1, p2):\n    # Calculate distance between two data points\n    return abs(p1 - p2)", "def getDistance(p1,p2):\n    # Calculate the distance between two points\n    pass", "def distance_between_locations(coord1, coord2):\n    '''\n    This function will determine the distance between two locations using longitude and latitude coordinates. \n    '''\n    # Convert coordinates to radians\n    lon1 = math.radians(coord1[0])\n    lat1 = math.radians(coord1[1])\n    lon2 = math.radians(coord2[0])\n    lat2 = math.radians(coord2[1])\n    \n    # Calculate distance between locations\n    r = 6371  # Earth radius in km\n    dlon = lon2 - lon1 \n    dlat = lat2 - lat1 \n    a = (math.sin(dlat/2))**2 + math.cos(lat1) * math.cos(lat2) * (math.sin(dlon/2))**2\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a)) \n    d = r * c \n    \n    return d"]}
{"task_id": 170, "content": ["def longest_common_prefix(str_list):\n    ''' This function finds the longest common prefix among the given list of strings.'''\n    str_list.sort()\n    # Get the first string in the list\n    first_str = str_list[0]\n\n    # Find the longest common prefix among the list of strings\n    prefix_len = 0\n    for j in range(len(first_str)):\n        if all([i.startswith(first_str[:j+1]) for i in str_list]):\n            prefix_len = j+1\n    return first_str[:prefix_len]", "def longest_common_prefix(strings):\n  # set the initial prefix to the first string\n  prefix = strings[0]\n  # loop through the strings\n  for string in strings:\n    # compare the strings\n    while(not string.startswith(prefix)):\n      # if no matching prefix is found\n      if not prefix:\n        # return empty\n        return \"\"\n      # otherwise remove the last character\n      prefix = prefix[0:-1]\n  # return the longest common prefix\n  return prefix", "def filter_by_prefix(strings, prefix):  # define a function that takes a list of strings and a prefix\n    return [string for string in strings if string.startswith(prefix)]  # return a list of those strings that start with the given prefix", "def filter_by_prefix(string_list, prefix):\n    \"\"\"\n    Filters a list of strings based on a given prefix.\n\n    Args:\n    string_list: A list of strings to be filtered.\n    prefix: A string representing the prefix to filter by.\n\n    Returns:\n    A new list containing only the strings from the original list that start with the specified prefix.\n    \"\"\"\n    return [s for s in string_list if s.startswith(prefix)]", "def find_longest_common_substring(strings):\n    if len(strings) == 0:\n        return ''\n    elif len(strings) == 1:\n        return strings[0]\n    else:\n        # Sort the strings based on length\n        strings.sort(key=len)\n\n        # Take the first string as the initial longest common substring\n        longest = strings[0]\n\n        for s in strings:\n            # Check if the first string is a substring of the next string\n            if longest in s:\n                # If it is, update the longest common substring\n                longest = s\n            else:\n                # If not, find the longest common substring iteratively\n                for i in range(len(longest)):\n                    if longest[0:len(longest) - i] in s:\n                        longest = longest[0:len(longest) - i]\n                        break\n\n        return longest"]}
{"task_id": 171, "content": ["def generate_password(length):\n    # Generate a random password that contains at least one uppercase character, one lowercase character, one digit, and one special character\n    \n    # Generate a random string of uppercase and lowercase characters\n    s = \"\".join(random.sample(string.ascii_letters, length))\n    \n    # Generate a single random digit\n    d = random.choice(string.digits)\n    \n    # Generate a single random special character\n    p = random.choice(string.punctuation)\n    \n    # Generate the final password\n    password = s + d + p\n    \n    return password", "def count_characters(input_string):\n    # check if the input is a string\n    if not isinstance(input_string, str):\n        return \"Error: Input is not a string.\"\n    # initialize counters\n    uppercase = lowercase = special = 0\n    # check each character in the string\n    for char in input_string:\n        if char.isupper():\n            uppercase += 1\n        elif char.islower():\n            lowercase += 1\n        elif not char.isalnum():\n            special += 1\n    # check if the string is a palindrome\n    is_palindrome = input_string == input_string[::-1]\n    # return the dictionary with counts\n    return {\"Uppercase\": uppercase, \"Lowercase\": lowercase, \"Special\": special, \"Is Palindrome\": is_palindrome}", "def string_analyzer(s):\n    remove_spaces = s.replace(\" \", \"\")\n    uppercase, lowercase, numbers, special = 0, 0, 0, 0\n    for char in remove_spaces:\n        if char.isupper():\n            uppercase += 1\n        elif char.islower():\n            lowercase += 1\n        elif char.isdigit():\n            numbers += 1\n        else:\n            special += 1\n    \n    reverse_s = remove_spaces[::-1]\n    palindrome = reverse_s.lower() == remove_spaces.lower()\n    \n    return uppercase, lowercase, numbers, special, palindrome", "def decode_cyclic(s: str):\n    \"\"\"\n    Return decoded string decoded from encode_cyclic function, handling special characters, numeric values, punctuations and whitespace.\n    \"\"\"\n    return encode_cyclic(s)  # Since we are just reversing the groups of three characters, decoding is just doing the encoding operation again.", "def generate_password():\n    '''This function generates a random password with at least 8 characters and containing\n    at least one number, one lowercase character, and one uppercase character.'''\n\n    password_length = 8 # Set the desired password length\n\n    # Create a list of all the possible characters for the password\n    char_list = list(string.ascii_lowercase + string.ascii_uppercase + string.digits)\n\n    # Generate the password\n    password = random.choices(char_list, k=password_length)\n    \n    # Check if the password contains at least one number, one lowercase character, and one uppercase character\n    if not any(c.isdigit() for c in password):\n        raise ValueError('Password must contain at least one number.')\n    if not any(c.islower() for c in password):\n        raise ValueError('Password must contain at least one lowercase character.')\n    if not any(c.isupper() for c in password):\n        raise ValueError('Password must contain at least one uppercase character.')\n\n    return ''.join(password)"]}
{"task_id": 172, "content": ["def find_distinct_pairs(arr, k):\n    # Create a dictionary to store the count of each number in the array\n    num_count = {}\n    \n    # Iterate over the array and count the occurrences of each number\n    for num in arr:\n        num_count[num] = num_count.get(num, 0) + 1\n    \n    # Initialize a count variable to keep track of the number of distinct pairs found\n    count = 0\n    \n    # Iterate over the array and check if there is a pair of numbers that adds up to k\n    for num in arr:\n        # Check if the current number is negative and there is a corresponding positive number that adds up to k\n        if num < 0 and k - num in num_count and k - num > num:\n            # If the pair is found, increment the count\n            count += 1\n            \n            # If we have found exactly two distinct pairs, return True\n            if count == 2:\n                return True\n    \n    # If we reach this point, it means we haven't found exactly two distinct pairs\n    return False", "def find_pairs(array, target):\n    # Create a map to store the difference of target and element\n    map = {}\n    pairs = []\n\n    # Iterate over the elements in the list\n    for i, value in enumerate(array):\n        # To handle the edge case of multiple pairs having the same values but different indices,\n        # we will consider the case where the target less the value is already in the map.\n        # This means we have already encountered a number which together with the current number forms a pair\n        # that sums up to the target.\n        if target - value in map:\n            # If it's in the map, add all pairs to our result\n            for j in range(map[target - value], 0, -1):  # range goes till 0 to include all pairs\n                pairs.append((value, target - value))  # add the pair to the output\n        # We count the occurrence of the values to take into account pairs with the same value but different indices\n        map[value] = map.get(value, 0) + 1\n\n    return pairs", "def find_pairs(nums, target_sum):\n    # Create an empty set to store unique pairs\n    pairs = set()\n\n    # Create a dictionary to store the count of each number in the list\n    count = {}\n\n    # Iterate through the list and count the occurrences of each number\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n\n    # Iterate through the list again\n    for num in nums:\n        # Calculate the difference between the target sum and the current number\n        difference = target_sum - num\n\n        # Check if the difference is in the count dictionary and it's count is greater than 0\n        if difference in count and count[difference] > 0:\n            # Add the pair (num, difference) to the pairs set\n            pairs.add((min(num, difference), max(num, difference)))\n\n            # Decrement the count of the difference by 1\n            count[difference] -= 1\n\n    # Sort the pairs in ascending order based on the first element of each pair\n    sorted_pairs = sorted(pairs, key=lambda x: x[0])\n\n    # Return the sorted pairs\n    return sorted_pairs", "def solution(A):\n    s = set(A)  # Create a set from the array to get distinct elements\n    return len(s)  # Return the count of distinct elements in the set", "def sum_and_count_distinct(arr):\n    # Create a dictionary to store the count of each distinct element\n    count_dict = {}\n\n    # Initialize the sum and count of distinct elements to zero\n    sum = 0\n    count = 0\n\n    # Iterate over the array\n    for num in arr:\n        # Add the current number to the sum\n        sum += num\n\n        # Check if the current number is already in the dictionary\n        if num in count_dict:\n            # If it is, increment its count by 1\n            count_dict[num] += 1\n        else:\n            # If it is not, add it to the dictionary with a count of 1\n            count_dict[num] = 1\n            # Increment the count of distinct elements by 1\n            count += 1\n\n    # Return the sum and count of distinct elements\n    return sum, count"]}
{"task_id": 173, "content": ["def extract_integer(number: float) -> int:\n    \"\"\"\n    A floating-point number can be bifurcated into an integer part (the largest integer no greater\n    than the input number) and a fraction part (the residual fragment, persistently less than 1 \n    but more than -1). \n\n    Architect this function in such a way that it unravels the integer sector of a number, whether \n    it is positive or negative.\n    \"\"\"\n    return math.floor(number)", "def extract_integer(number: float) -> int:\n    \"\"\"\n    A floating-point number can be bifurcated into an integer part (the largest integer no greater\n    than the input number) and a fraction part (the residual fragment, persistently less than 1 \n    but more than -1). \n\n    Architect this function in such a way that it unravels the integer sector of a number, whether \n    it is positive or negative.\n    \"\"\"\n    return math.floor(number)", "def multiply_with_range(number):\n    \"\"\"Multiply a number with all integers within a range\n    \n    This function takes a single argument, a number (integer), and \n    returns a list. The elements of this list are results of the \n    number multiplied with every integer from 1 to the number itself.\n\n    Args:\n        number (int): the number to be multiplied with all the integers in range\n\n    Returns:\n        list: a list of results from multiplying the number with each integer \n        within the range\n    \"\"\"\n    multiplied_list = [number * i for i in range(1, number + 1)]\n    return multiplied_list", "def get_prime_numbers(a, b):\n    # Handle edge cases\n    if a < 0 or b < 0:\n        return \"Invalid input. Please enter non-negative values.\"\n    elif a > b:\n        return \"Invalid input. The start number should be less than or equal to the end number.\"\n\n    primes = []\n    for num in range(a, b + 1):\n       # all prime numbers are greater than 1\n       if num > 1:\n           for i in range(2, num):\n               if (num % i) == 0:\n                   break\n           else:\n               primes.append(num)\n    return primes, len(primes)", "def calculate_mode(numbers):\n    num_dict = {}\n    # Create a dictionary where the keys are the numbers and the values are their counting\n    for num in numbers:\n        num_dict[num] = num_dict.get(num, 0) + 1\n    # Find the maximum of the values, that is, the maximum times a number has repeated\n    max_frequency = max(num_dict.values())\n    modes = []\n    # Iterate through all the keys, values in the dictionary and add them to modes list\n    # if the value equals to max_frequency\n    for key, value in num_dict.items():\n        if value == max_frequency:\n            modes.append(key)\n    return modes"]}
{"task_id": 174, "content": ["def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass", "def find_rop_gadgets(base_address):\n    # This function would use a database of known ROP gadgets or a tool like ROPgadget to find gadgets.\n    gadgets = []\n    # Code to find ROP gadgets goes here\n    return gadgets", "def inorder_traversal(root):\n    \"\"\"Write a function to traverse a binary search tree in-order, printing out the values it encounters.\n\n    :param root: The root node of the binary search tree\n    \"\"\"\n    if not root:\n        return\n\n    inorder_traversal(root.left)\n    print(root.val)\n    inorder_traversal(root.right)", "def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass"]}
{"task_id": 175, "content": ["def substring_filter(string_list, substring):\n    \"\"\"\n    This function takes a list of strings and a substring to search for. It returns a new list with the strings\n    that contain the substring.\n    \"\"\"\n    filtered_list = []\n    for string in string_list:\n        if substring in string:\n            filtered_list.append(string)\n    return filtered_list", "def sorted_list(lst, reverse=False):\n    \"\"\"\n    This function takes a list of string literals, discards strings that are of odd lengths or contain digits, \n    and returns a sorted list according to the specified stipulations.\n    The list is sorted based on the length of each word in an ascending sequence. \n    For words of equivalent length, it is sorted in alphabetical order. \n    Case sensitivity and special characters are ignored during the sorting operation.\n    An optional boolean parameter `reverse`, with a default value set to False, can be used to toggle the sorting pattern \n    between ascending and descending.\n    Note:\n    The input will always be a list of string literals and can never be of numeric type.\n    The list can have duplicate elements.\n    \"\"\"\n    import re\n    \n    # Filter out string literals of odd length and those containing digits\n    filtered_list = [x for x in lst if len(x) % 2 == 0 and not bool(re.search(r'\\d', x))]\n    \n    # Sort the list first by length, then by alphabetical order (case insensitive), and optionally in reverse order\n    return sorted(filtered_list, key=lambda x: (len(x), x.lower()), reverse=reverse)", "def sorted_list_sum(lst, reverse=False):\n    \"\"\"\n    This function takes as input a list of strings, removes any string that contains a numerical digit or \n    an odd number of characters, sorts remaining strings in ascending order by both length and alphabetically, \n    and then returns the sorted list.\n    \n    Achieves this by using list comprehension to filter out unwanted elements, \n    and Python's built-in sorted function to sort the list. The sorted function uses a compound sorting key \n    consisting of the length of each element and the element itself, allowing for sorting by multiple criteria.\n    \n    The ordering of the sorted list can be reversed by supplying a second argument of True.\n\n    Parameters:\n    lst (list): A list of strings to be filtered and sorted.\n    reverse (bool): Optional parameter to reverse the order of the sorted list. Defaults to False.\n\n    Returns:\n    list: The sorted list of strings.\n    \"\"\"\n    \n    # Filter out any strings containing numerical digits or with odd length\n    lst = [i for i in lst if not any(j.isdigit() for j in i) and len(i) % 2 == 0]\n    \n    # Return the list sorted by length and then alphabetically, in ascending or descending order\n    return sorted(lst, key=lambda x: (len(x), x), reverse=reverse)", "def match_text(text, search_string):\n    \"\"\"Returns all occurrences of substring in the given string with case and pattern insensitivity.\n\n    Args:\n    text (str): A string.\n    search_string (str): The substring for which to search.\n\n    Returns:\n    A list of all occurrences in the given string.\n    \"\"\"\n    matches = []\n    # Construct a case and pattern insensitive regex expression\n    search_string = re.compile(search_string, re.IGNORECASE)\n    # Search the string and add the matches to a list\n    for match in search_string.finditer(text):\n        matches.append(match.group(0))\n\n    return matches", "def complex_sorted_list(lst, reverse=False, min_sum=0, max_sum=None, sort_function=None, secondary_sort_function=None):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter and performs the following:\n    - Delete strings with odd lengths or containing numerals.\n    - Sort the list based on the sum of the ASCII values of the characters in each string.\n    - The list may contain duplicates, ignore case, and special characters.\n    - Toggle sorting between ascending and descending order using an optional boolean `reverse` (default is False).\n    - Implement an optional minimum sum `min_sum` (default is 0) to return only strings with a sum greater or equal.\n    - Implement an optional maximum sum `max_sum` to return only strings with a sum less than or equal.\n    - Implement an optional custom sorting method `sort_function` to sort strings using a custom function.\n    - Implement an optional secondary custom sorting method `secondary_sort_function` to sort strings using a secondary function.\n    \"\"\"\n\n    # Remove strings with odd lengths and strings containing numerals\n    clean_lst = [s for s in lst if len(s) % 2 == 0 and not any(c.isdigit() for c in s)]\n\n    if not sort_function:\n        sort_function = lambda s: sum(ord(c) for c in s)\n\n    if secondary_sort_function:\n        clean_lst.sort(key=secondary_sort_function)\n\n    # Sort strings based on the sort_function\n    clean_lst.sort(key=sort_function, reverse=reverse)\n\n    # Filter strings based on min_sum and max_sum\n    filtered_lst = [s for s in clean_lst if min_sum <= sort_function(s) <= (max_sum if max_sum else float(\"inf\"))]\n\n    return filtered_lst"]}
{"task_id": 176, "content": ["def find_common_sequence(seq1, seq2):\n    \"\"\" Identify the longest common subsequence of the given two sequences.\n    The approach used is as follows:\n    - Recognize the longest common sequence in the provided sequences.\n    - Return this common sequence\n    \"\"\"\n    m, n = len(seq1), len(seq2)\n    dp = [['' for j in range(n+1)] for i in range(m+1)]\n    for i in range(m-1, -1, -1):\n        for j in range(n-1, -1, -1):\n            if seq1[i] == seq2[j]:\n                dp[i][j] = seq1[i] + dp[i+1][j+1]\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j+1], key=len)\n    return dp[0][0]", "def find_common_sequence_n(sequences):\n    \"\"\" Locate the longest shared subsequence among n sequences \"\"\"\n    pass", "def longest_common_prefix(str_list):\n    ''' This function finds the longest common prefix among the given list of strings.'''\n    str_list.sort()\n    # Get the first string in the list\n    first_str = str_list[0]\n\n    # Find the longest common prefix among the list of strings\n    prefix_len = 0\n    for j in range(len(first_str)):\n        if all([i.startswith(first_str[:j+1]) for i in str_list]):\n            prefix_len = j+1\n    return first_str[:prefix_len]", "def find_invariant_sections(code_sections):\n    # Analyze the code sections to find invariant sections\n    # This could involve looking for patterns like repeated sequences of instructions,\n    # control flow patterns, and data manipulation patterns.\n    # For simplicity, we'll assume that this function returns a list of opcode sequences.\n    # This is a placeholder function.\n    pass", "def longestIncreasingSubsequence(arr):\n    \"\"\"Function to find the longest increasing subsequence in a given array\"\"\"\n    n = len(arr)\n    # initialize the dp array \n    dp = [1] * n \n  \n    # Loop through the given array and compute \n    # other entries in the dp array \n    for i in range (1, n): \n        for j in range(i): \n            if (arr[i] > arr[j] and dp[i] < dp[j] + 1):\n                dp[i] = dp[j] + 1\n\n    # Find the maximum entry in the dp array\n    maximum = 0\n    for i in range(n): \n        if (maximum < dp[i]): \n            maximum = dp[i] \n\n    # return the longest increasing subsequence\n    return maximum"]}
{"task_id": 177, "content": ["def smallestPositiveNumber(): \n    n = 1; # Initialize result \n  \n    # Take every number from 3 to n \n    # As n increases exponentially \n    # Check if the number can be represented \n    # as the sum of two numbers \n    while n <= pow(10, 18): \n        if canRepresentedSumOfTwo(n) == False: \n            return n; \n        n += 1; \n  \n    # Return -1 if the number  \n    # cannot be represented as \n    # the sum of two numbers. \n    return -1; ", "def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True", "def is_perfect_square(num):\n    \"\"\"\n    This function checks if a number is a perfect square.\n    \n    Args:\n    num(int): input number\n\n    Returns:\n    str: an appropriate message for perfect square, float or negative number.\n    \n    \"\"\"\n\n    # Input Validation\n    if num < 0:\n        return \"Negative numbers cannot be perfect squares.\"\n    elif isinstance(num, float):\n        return \"Floating point numbers cannot be perfect squares.\"\n\n    # Perfect square check\n    root = num ** 0.5\n    if int(root + 0.5) ** 2 == num:\n        return \"The number is a perfect square.\"\n    else:\n        return \"The number is not a perfect square.\"", "def is_perfect_square(num):\n    \"\"\"\n    This function checks if a number is a perfect square.\n    \n    Args:\n    num(int): input number\n\n    Returns:\n    str: an appropriate message for perfect square, float, or negative number.\n    \n    \"\"\"\n\n    # Input Validation\n    if num < 0:\n        return \"Negative numbers cannot be perfect squares.\"\n    elif isinstance(num, float):\n        return \"Floating point numbers cannot be perfect squares.\"\n\n    # Perfect square check\n    root = num ** 0.5\n    if int(root + 0.5) ** 2 == num:\n        return \"The number is a perfect square.\"\n    else:\n        return \"The number is not a perfect square.\"", "def square_numbers(num):\n    \"\"\"\n    This function takes in a number and returns a list of squares of numbers from 0 to that number.\n    It handles errors for negative values, non-integer values, and non-numeric values.\n    \"\"\"\n  \n    # check if the input is not a number\n    if not isinstance(num, (int, float)):\n        raise ValueError('Input should be an integer or a float.')\n\n    # check if the input number is not integer\n    elif not isinstance(num, int):\n        raise ValueError('Input should be an integer.')\n\n    # check if the input number is negative\n    elif num < 0:\n        raise ValueError('Input should be a non-negative integer.')\n\n     # generate list of squares\n    else:\n        return [i**2 for i in range(num+1)]"]}
{"task_id": 178, "content": ["def first_missing_positive(arr): \n    # First, let's sort the array in ascending order\n    arr.sort() \n    \n    # Now, let's traverse the array and find the smallest positive number missing\n    for i in range(len(arr)): \n        # We'll skip any non-positive numbers and the number 1 since we are looking for the first missing positive integer\n        if arr[i] > 0 and arr[i] == 1: \n            continue\n        # If the difference between the current and previous element is greater than 1, we have found the first missing positive integer\n        elif arr[i] > 0 and (arr[i] - arr[i-1] > 1): \n            return arr[i-1] + 1 \n        # If the current element is non-positive, we can safely assume that 1 is the first missing positive integer\n        elif arr[i] <= 0: \n            return 1\n\n    # If no such element is found, the first missing positive integer is the last element + 1\n    return arr[len(arr)-1] + 1", "def count_missing_values(df):\n    \"\"\"\n    This function calculates the total number of missing values in a specific dataframe.\n\n    Parameters:\n    df (DataFrame): Dataframe to check for missing values\n\n    Returns:\n    int: total missing values in the dataframe\n    \"\"\"\n    return df.isnull().sum().sum()", "def gcd(a, b):\n    \"\"\"\n    Function to find greatest common divisor (gcd) of two numbers using the Euclidean algorithm\n    \n    Parameters :\n    a (int) : First input number\n    b (int) : Second input number\n    \n    Returns :\n    gcd(int) : highest common divisor of two positive integers \n    \n    \"\"\"\n    while b:\n        a, b = b, a % b\n\n    return a", "def find_first_positive(nums):\n    n = len(nums)\n    # Create a boolean array of size n+1 to mark the presence of positive integers\n    # We ignore the 0th index since we only care about positive integers\n    present = [False] * (n+1)\n    \n    # Mark the presence of positive integers\n    for i in range(n):\n        if nums[i] > 0 and nums[i] <= n:\n            present[nums[i]] = True\n    \n    # Find the first missing positive integer\n    for i in range(1, n+1):\n        if not present[i]:\n            return i\n    \n    return \"No positive number was found\"", "def inject_payload(pid, payload):\n    # This function would need to be implemented to attach to the process,\n    # find the system call table, and modify it to point to the custom handler.\n    # This is a complex task that typically requires kernel-level access and\n    # is beyond the scope of a simple Python script.\n    pass"]}
{"task_id": 179, "content": ["def speed_up_monte_carlo(func, num_trials):\n    # Vectorize the function\n    vectorized_func = vectorize_func(func)\n    \n    # Use numpy to calculate the approximated integral\n    integral = np.trapz(vectorized_func(np.linspace(0,1,num_trials)))\n    \n    # Reduce the number of trials by a factor of 10\n    new_num_trials = num_trials//10\n    \n    # Calculate the optimized integral using the reduced number of trials\n    optimized_integral = optimize_monte_carlo(func, new_num_trials)\n    \n    # Return the optimized integral\n    return optimized_integral", "def extract_even_integer(number: float) -> int:\n    \"\"\" Given a positive real number, it is divided into an integral segment and a fractional component. \n    Returns the integral segment only when it is an even number. If the integral part of the real number \n    is not even, the function will return None.\n\n    >>> extract_even_integer(4.7)\n    4\n    >>> extract_even_integer(5.7)\n    None\n    \"\"\"\n    integral_part = int(number)\n    if integral_part % 2 == 0:\n        return integral_part\n    else:\n        return None", "def derivative_and_integral(xs: list, C: complex):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Handle both real and complex number coefficients.\n    Return derivative and integral of this polynomial in the same form, adding C and removing trailing zeros.\n    \"\"\"\n    # Turn the given coefficient list into a Poly1d object which allows us to do mathematical operations.\n    p = np.poly1d(xs[::-1])\n\n    # Compute the derivative of the polynomial and reverse the resulting coefficient list.\n    derivative = p.deriv().c[::-1]\n    # Compute the integral of the polynomial and reverse the resulting coefficient list.\n    integral = p.integ().c[::-1]\n    # Add a complex constant to the integral.\n    integral[0] += C\n\n    # Filter our trailing zeroes in both the integral and derivative lists.\n    derivative = list(filter(lambda a: a != 0, derivative))\n    integral = list(filter(lambda a: a != 0, integral))\n\n    return derivative, integral", "def proper_code(*args):\n    \"\"\"\n    Given single or multiple positive integers, check if any of them is a perfect square.\n    If at least one is a perfect square, create and test a function that returns the number of n-digit positive integers that start or end with 1.\n    Also, these numbers must be divisible by any three distinct prime numbers.\n    Return 'Not a perfect square.' if none of them is a perfect square.\n    \"\"\"\n    # Find first three prime numbers\n    primes = list(sympy.primerange(0,100))[:3]\n    for i in args:\n        if is_perfect_square(i):\n            # n is taken as the number of digits in the first perfect square found\n            n = len(str(i))\n            return num_start_end_with_1(n, primes)\n    return 'Not a perfect square.'", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count"]}
{"task_id": 180, "content": ["def get_num_days(month, year):\n    # check if the year is a leap year\n    if year % 400 == 0 or (year % 100 != 0 and year % 4 == 0):\n        leap_year = True\n    else:\n        leap_year = False\n    \n    # dictionary to map month number to number of days\n    num_days_in_month = {\n        1: 31,\n        2: 29 if leap_year else 28,\n        3: 31,\n        4: 30,\n        5: 31,\n        6: 30,\n        7: 31,\n        8: 31,\n        9: 30,\n        10: 31,\n        11: 30,\n        12: 31\n    }\n    \n    # return the number of days for the given month\n    return num_days_in_month[month]", "def num_days_in_month(month, year):\n    \"\"\"\n    Return the number of days in the given month and year\n    \"\"\"\n    days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if month == 2 and ((year % 4 == 0) and (year % 100 != 0) or (year % 400 == 0)):\n        return 29\n    return days[month-1]", "def get_days(month, year):\n    # Validate year\n    if year < 1900:\n        return \"Year must be 1900 or later.\"\n\n    # Validate month\n    months = [\n        \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n        \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n    ]\n    if month not in months:\n        return \"Invalid month.\"\n\n    # Trivially calculate days in a month\n    month_number = months.index(month) + 1  # Converts month name to month number\n    days = calendar.monthrange(year, month_number)[1]  # Gets the number of days in the month\n\n    return days", "def num_of_days(month): \n    if month == \"January\" or month == \"March\" or month == \"May\" or month == \"July\" or month == \"August\" or month == \"October\" or month == \"December\": \n        return \"31 days\"\n    elif month == \"April\" or month == \"June\" or month == \"September\" or month == \"November\":\n        return \"30 days\"\n    elif month == \"February\":\n        return \"28 or 29 days\"\n    else:\n        return \"Invalid input\"", "def get_number_of_days(month, year):\n    # Check if month is within the specified range\n    if month < 1 or month > 12:\n        raise ValueError(\"Invalid month\")\n\n    # Check if year is within the specified range\n    if year < 1 or year > 9999:\n        raise ValueError(\"Invalid year\")\n\n    # Define the number of days in each month\n    days_in_month = {\n        1: 31,  # January\n        2: 28,  # February\n        3: 31,  # March\n        4: 30,  # April\n        5: 31,  # May\n        6: 30,  # June\n        7: 31,  # July\n        8: 31,  # August\n        9: 30,  # September\n        10: 31,  # October\n        11: 30,  # November\n        12: 31   # December\n    }\n\n    # Check if it is a leap year\n    if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n        days_in_month[2] = 29  # Update days in February\n\n    return days_in_month[month]"]}
{"task_id": 181, "content": ["def check_string(string):\n    # Check if string contains only alphabetical characters and has a length of at least 5\n    if not string.isalpha() or len(string) < 5:\n        return False\n    \n    # Check if string contains at least one uppercase letter, one lowercase letter, and one digit\n    if not any(char.isupper() for char in string):\n        return False\n    if not any(char.islower() for char in string):\n        return False\n    if not any(char.isdigit() for char in string):\n        return False\n    \n    return True", "def copy_stream(input_stream, output_stream, buffer_size=1024*1024):\n    \"\"\"\n    Copy one stream to another.\n\n    input_stream: a file-like object that has a `read` method.\n    output_stream: a file-like object that has a `write` method.\n    buffer_size: the size of the chunks to read and write.\n    \"\"\"\n    while True:\n        data = input_stream.read(buffer_size)\n        if not data:\n            break\n        output_stream.write(data)", "def isPalindrome(string):\n    '''This function will return whether or not a string is a palindrome.'''\n\n    # Ensure that the input is a string and has at least one character\n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string.\")\n    if len(string) < 1:\n        raise ValueError(\"Input string must have at least one character.\")\n\n    # Ensure that the input string only contains alphabetic characters\n    if not string.isalpha():\n        raise ValueError(\"Input string must only contain alphabetic characters.\")\n\n    # Create a stack to store the characters in reverse order\n    stack = []\n\n    # Iterate through each character in the string and push it onto the stack\n    for char in string:\n        stack.append(char)\n\n    # Create a new string by popping each character from the stack\n    reversed_string = \"\"\n    while stack:\n        reversed_string += stack.pop()\n\n    # Compare the original string and the reversed string\n    return string == reversed_string", "def generate_sequence():\n    # Generate a list of all lower case letters and digits.\n    all_chars = string.ascii_lowercase + string.digits\n\n    # Randomly choose one lower case letter and one digit.\n    letter = random.choice(string.ascii_lowercase)\n    digit = random.choice(string.digits)\n\n    # Generate 4 other chars randomly from the list of all characters.\n    other_chars = ''.join(random.choices(all_chars, k=4))\n  \n    # Combine the letter, digit and other characters into one string.\n    sequence = letter + digit + other_chars\n\n    # Randomly shuffle the sequence to ensure unpredictability.\n    sequence = ''.join(random.sample(sequence, len(sequence)))\n\n    return sequence", "def generate_password():\n    \"\"\"\"Generate a random password of length 15 with at least one uppercase letter, one lowercase letter, one number, and one special character.\"\"\"\n    upper_chars = string.ascii_uppercase  \n    lower_chars = string.ascii_lowercase \n    digits = string.digits \n    special_chars = string.punctuation\n \n    chars = upper_chars + lower_chars + digits + special_chars\n    password_len = 15\n \n    password = \"\".join(random.sample(chars,password_len ))\n  \n    return password"]}
{"task_id": 182, "content": ["def remove_duplicates(arr):\n    \"\"\"Develop a method to remove the duplicates from a given array of numbers.\"\"\"\n    return list(set(arr))", "def remove_duplicates(arr):\n    \"\"\"\n    Function to remove duplicates from a list preserving the order\n\n    Parameters:\n        arr (list): The list from which to remove the duplicates\n\n    Returns:\n        list: List with the duplicates removed\n    \"\"\"\n    seen = set()\n    new_arr = []\n\n    for e in arr:\n        if e not in seen:\n            seen.add(e)\n            new_arr.append(e)\n\n    return new_arr", "def remove_duplicates(list1):\n    # Function to remove duplicates from a list\n    # convert the list into a set of unique elements\n    list_unique = set(list1)\n \n    # convert the set to a list\n    list_unique = list(list_unique)\n    return list_unique", "def unique_sets(sets):\n    # Remove duplicates by converting each sub-set to a tuple (which are hashable), \n    # making a set of those (ignores duplicates), then convert each tuple back to list.\n    return [list(x) for x in set(tuple(x) for x in sets)]", "def combine_unique_elements(list1, list2):\n    # Remove duplicates from list1\n    list1 = list(set(list1))\n    \n    # Remove duplicates from list2\n    list2 = list(set(list2))\n    \n    # Combine the unique elements from both lists\n    combined_list = list1 + list2\n    \n    # Remove duplicates from the combined list\n    combined_list = list(set(combined_list))\n    \n    # Convert the combined list back to a regular list\n    combined_list = list(combined_list)\n    \n    # Return the combined list\n    return combined_list"]}
{"task_id": 183, "content": ["def convert_hex_to_oct(hex_num):\n    # Convert input hexadecimal number to decimal\n    dec_num = int(hex_num, 16)\n    # Convert decimal number to octal\n    oct_num = oct(dec_num).replace(\"0o\", \"\")\n    return oct_num", "def to_octal(number):\n    # Step 1: Take the absolute value of the input number\n    number = abs(number)\n\n    # Step 2: Initialize the octal representation variable as 0\n    octal = 0\n\n    # Step 3: Enter the loop\n    while number != 0:\n        # Step 4: Get the least significant 3 bits of the input number\n        bits = number & 7\n\n        # Step 4: Convert the obtained bits to decimal using powers of 2\n        decimal = 0\n        power = 1\n        while bits != 0:\n            decimal += (bits & 1) * power\n            bits >>= 1\n            power <<= 1\n\n        # Step 4: Add the decimal value to the octal representation\n        octal += decimal\n\n        # Step 4: Right shift the input number by 3 bits\n        number >>= 3\n\n    # Step 5: Check if the input number was originally negative\n    if number < 0:\n        octal = -octal\n\n    # Step 6: Print the octal representation as the output\n    print(octal)", "def decimal_to_octal(decimal):\n    # Check if the number is negative\n    is_negative = False\n    if decimal < 0:\n        is_negative = True\n        decimal = abs(decimal)\n\n    # Split the number into integer and fractional parts\n    integer_part = int(decimal)\n    fractional_part = decimal - integer_part\n\n    # Convert the integer part to octal\n    octal_integer = \"\"\n    while integer_part > 0:\n        remainder = integer_part % 8\n        octal_integer = str(remainder) + octal_integer\n        integer_part = integer_part // 8\n\n    # Convert the fractional part to octal\n    octal_fractional = \"\"\n    while fractional_part > 0 and len(octal_fractional) < 2:\n        fractional_part *= 8\n        digit = int(fractional_part)\n        octal_fractional += str(digit)\n        fractional_part -= digit\n\n    # Combine the integer and fractional parts\n    octal = octal_integer + \".\" + octal_fractional\n\n    # Add the negative sign if necessary\n    if is_negative:\n        octal = \"-\" + octal\n\n    return octal", "def array_binary_to_octal(array):\n    octal_array = []\n    for binary in array:   # iterate over list\n        octal = binary_to_octal(binary) # convert each number to octal\n        octal_array.append(octal) # append converted number to new list\n    return octal_array", "def bin_to_oct(number):\n    \"\"\"\n    Convert a binary number to an octal number\n\n    Args:\n    number: the binary number\n\n    Returns:\n    the octal representation of the binary number.\n    \"\"\"\n    if not str(number).isnumeric():\n        return None\n\n    binary = str(number)\n    temp = int(binary, 2)\n    octal = oct(temp).replace(\"0o\", \"\")\n    return octal"]}
{"task_id": 184, "content": ["def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def find_smallest_in_arrays(arr1, arr2):\n    \"\"\"\n    Find and return the smallest elements in both arrays in O(nlog(n))\n\n    Parameters\n    ----------\n    arr1 : list\n        First array of integers\n    arr2 : list\n        Second array of integers\n\n    Returns\n    -------\n    int\n        The smallest element common to both arrays\n    \"\"\"\n    # Merge both the arrays\n    merged_arr = [*arr1, *arr2]\n    # Sort the merged array in O(nlog(n))\n    merged_arr.sort()\n\n    # Initialize first_min to the first element of sorted merged array\n    first_min = merged_arr[0]\n    # Initialize second_min to the second element of sorted merged array\n    second_min = merged_arr[1]\n\n    # Check if the first min element is in arr1 and the second min element is in arr2.\n    # If yes, return the first min element.\n    if first_min in arr1 and second_min in arr2:\n        return first_min\n    # Check if the first min element is in arr2 and the second min element is in arr1.\n    # If yes, return the first min element.\n    elif first_min in arr2 and second_min in arr1:\n        return first_min\n    # Else return the second min element\n    else:\n        return second_min", "def frequencySort(nums):\n    # collections.Counter(nums) gives the frequency of each element in the nums array.\n    # items() function returns a view object that displays a list of a dictionary's(an iterable) tuple pair (key, value).\n    c = Counter(nums).items()\n    # Then we will sort the results by the tuple (-count, num). Negative count ensures that high frequency elements come first in the sorted list.\n    # This satisfies the requirement to sort in increasing frequency. \n    # Because we use num for sort as well, elements with the same frequency are sorted in descending order.\n    # This satisfies the requirement to sort in decreasing order on the basis of value of the numbers in case of same frequency.\n    # idx is used to sort elements in increasing order of their index in case elements are same and have same frequency.\n    # sort function of python is stable. i.e, it maintains the relative order of items with equal sort keys\n    nums.sort(key = lambda x: (nums.count(x), -x, [i for i, n in enumerate(nums) if n == x][0]))\n    # return the sorted array\n    return nums", "def find_kth_largest(arr, k):\n    \"\"\"\n    Function to find the kth largest element in an array\n    \"\"\"\n    \n    # make a copy of the array\n    arr_copy = arr[:]\n    \n    # get the length of the array\n    length = len(arr_copy)\n    \n    # if k is greater than or equal to the length of the array, return the maximum element\n    if k >= length:\n        return max(arr_copy)\n        \n    # sort the array in descending order\n    arr_copy.sort(reverse=True)\n    \n    # get the kth element from the sorted array\n    kth_largest = arr_copy[k-1]\n    \n    return kth_largest", "def has_recurring_elements(arr):\n    # initialize an empty Python set\n    element_set = set()\n\n    # iterate over each element in the array\n    for element in arr:\n        # if the element is already in the set, it is a recurring element\n        if element in element_set:\n            return True\n        # add the element to the set\n        element_set.add(element)\n\n    # if we go through the whole array and find no recurring elements\n    # then return False\n    return False"]}
{"task_id": 185, "content": ["def lengthy_text(arr, k, ignore_list):\n  # Create a list of words to ignore\n  ignore_list = set(ignore_list)\n\n  # Remove the words in ignore_list from each element in arr\n  arr_ignoring = [''.join(word for word in text.split() if word.lower() not in ignore_list) for text in arr]\n\n  # Create a list of tuples with each tuple contains (element, length of element) format\n  arr_len = [(text, len(text)) for text in arr_ignoring]\n\n  # Sort the list of tuples based on the length of each element\n  arr_len.sort(key=lambda x: x[1])\n\n  # Look for the text have number of characters exactly equal to k or next highest number of characters but less than k\n  text_result = [text for text, length in reversed(arr_len) if length <= k]\n\n  # If found any, return the most lengthy text, otherwise return None.\n  return text_result[0] if text_result else None", "def find_permutations(arr):\n    # itertools.permutations method returns all permutations \n    # of the given list arr of length len(arr).\n    # Each permutation is a tuple so we use map function \n    # to convert these tuples to lists\n    perm = list(map(list, itertools.permutations(arr)))\n    \n    # Return the generated permutations\n    return perm", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass", "def write_rfid_data(rfid_writer, data):\n    # This function would interface with an RFID writer to write RFID badge data.\n    # Writes the data to a blank RFID badge.\n    print(f\"Cloned RFID badge with data: {data}\")", "def sort_strings(strings):\n    # Remove duplicates from the list\n    strings = list(set(strings))\n    \n    # Create a list of tuples with string length and string itself\n    tuples = [(len(s), s) for s in strings]\n    \n    # Sort the list of tuples by length and alphabetically\n    tuples.sort(key=lambda x: (-x[0], x[1]))\n    \n    # Return the sorted strings\n    return [t[1] for t in tuples]"]}
{"task_id": 186, "content": ["def find_permutations(arr):\n    # itertools.permutations method returns all permutations \n    # of the given list arr of length len(arr).\n    # Each permutation is a tuple so we use map function \n    # to convert these tuples to lists\n    perm = list(map(list, itertools.permutations(arr)))\n    \n    # Return the generated permutations\n    return perm", "def sort_by_second_item(tuples):\n    \"\"\"Sorts a list of tuples by the second item in the tuples.\n    \n    Args:\n        tuples: A list of tuples to be sorted.\n        \n    Returns:\n        sorted_list: The sorted list of tuples.\n    \"\"\"\n    sorted_list = sorted(tuples, key=lambda x: x[1])\n    \n    return sorted_list", "def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min", "def generate_input_file():\n    # The input file should be generated in such a way that it produces the maximum product of final[1] and final[3],\n    # and the maximum key in the results dictionary.\n    # To achieve this, the input file should be carefully crafted to produce the desired output when processed by the given function.\n    # The specific details of the input file content and format depend on the logic within the given function, and may require trial and error to determine the optimal input file content.\n\n    # As the exact logic within the given function is not provided, the generation of the input file content involves reverse-engineering the function's behavior and requirements.\n\n    # The solution to this problem involves analyzing the given function's behavior and requirements, and crafting an input file that fulfills those conditions to produce the desired output.\n\n    # Due to the specific nature of the input file content required to achieve the desired output, the exact content and format of the input file cannot be provided without further information about the given function's internal logic and requirements.\n\n    # Therefore, the solution involves understanding the behavior of the given function and crafting an input file that, when processed by the function, produces the maximum product of final[1] and final[3], and the maximum key in the results dictionary.\n\n    # The generation of the input file content may involve experimentation and analysis to determine the optimal values and structure that result in the desired output when processed by the given function.\n\n    # As the specific details of the input file content and format are not provided, the solution involves a process of reverse-engineering and experimentation to determine the appropriate input file content that fulfills the given requirements.\n\n    return \"Generated input file content\"", "def sort_list(tuples):\n    \"\"\"\n    A function to sort a list of tuples by the second item in each tuple.\n    \"\"\"\n    return sorted(tuples, key=lambda x: x[1])"]}
{"task_id": 187, "content": ["def max_circles(L, W):\n    # Find the smaller dimension\n    min_dim = min(L, W)\n\n    # Try to inscribe as many circles as possible with integer radius.\n    # Start with the largest possible radius, and decrement until one is found \n    # that allows for at least one circle to be inscribed.\n    for r in range(min_dim // 2, 0, -1):\n        # Calculate the number of circles that can fit along each dimension\n        num_circles_L = L // (2*r)\n        num_circles_W = W // (2*r)\n\n        # If at least one circle can be inscribed,\n        # calculate the total area and return the result\n        if num_circles_L > 0 and num_circles_W > 0:\n            total_area = num_circles_L * num_circles_W * math.pi * r**2\n            return (num_circles_L * num_circles_W, r, total_area)\n\n    # If no circles can be inscribed, return zero for all quantities\n    return (0, 0, 0)", "def securAlgo_decrypt(ciphertext, key, IV):\n    # This function should simulate the decryption process of SecurAlgo\n    # For the purpose of this question, it can return a dummy decrypted plaintext\n    # Here we assume that the decryption function returns the plaintext in a way that\n    # we can compare it to the known plaintext.\n    # The actual decryption logic would be implemented in the actual_securAlgo_decrypt function.\n    pass", "def get_triangle(radius):\n    # The largest inscribed triangle in a semicircle is equilateral triangle.\n    # The length of the triangle's side equals the semicircle's diameter.\n\n    # Hence, the coordinates of the vertices of the triangle are:\n    a = (-radius, 0)\n    b = (radius, 0)\n    c = (0, radius)\n\n    # The area of an equilateral triangle is computed using the formula: (s^2 * sqrt(3)) / 4\n    # where s is the side length of the triangle. \n    # The side length of our triangle is twice the radius (which is the diameter of the semicircle).\n    area = ((2*radius)**2 * math.sqrt(3)) / 4\n    \n    # The perimeter of an equilateral triangle is 3 times its side.\n    # The side length of our triangle is twice the radius (which is the diameter of the semicircle).\n    perimeter = 3 * (2*radius)\n\n    return area, a, b, c, perimeter", "def get_triangle(radius):\n    # The largest inscribed triangle in a semicircle is equilateral_triangle.\n    # The length of the triangle's_side_equals the semicircle's diameter.\n\n    # Hence, the coordinates of the vertices of the triangle are:\n    a = (-radius, 0)\n    b = (radius, 0)\n    c = (0, radius)\n\n    # The area of an equilateral triangle is computed using the formula: (s^2 * sqrt(3)) / 4\n    # where s is the side length of the triangle. \n    # The side length of our_triangle is twice the radius (which is the diameter_of the semicircle).\n    area = ((2*radius)**2 * math.sqrt(3)) / 4\n\n    # The perimeter of an equilateral triangle is 3 times its side.\n    # The side length of our triangle is twice the radius (which is the diameter of the semicircle).\n    perimeter = 3 * (2*radius)\n\n    return area, a, b, c, perimeter", "def generate_advanced_pascal_triangle(n):\n    \"\"\"\n    This function generates an \"advanced\" version of Pascal's Triangle\n    which alternates between even and odd numbers but follows the same\n    structural pattern of Pascal's Triangle.\n\n    Assumptions:\n        The input \"n\" is expected to be a positive integer. It denotes\n        the number of rows of the triangle that the user wants to generate.\n\n    Limitations:\n        Since we're building and storing the entire triangle in memory,\n        there is a limitation on how large of a triangle this function can generate.\n        For very large inputs (> 1000), the function might run into problems with\n        memory usage and computation time.\n\n    Computational Complexity:\n        The time complexity of this function is O(n^2) because we have nested\n        for loop. The space complexity is also O(n^2) because we are storing\n        the entire triangle in memory.\n    \"\"\"\n    # Validate the input\n    if not isinstance(n, int) or n <= 0:\n        print(\"Error: The input value must be a positive integer.\")\n        return\n\n    if n > 1000:\n        print(\"Error: The input value is too large. Please enter a value less than or equal to 1000.\")\n        return\n\n    triangle = [[0 for _ in range(i + 1)] for i in range(n)]\n\n    for i in range(n):\n        for j in range(i + 1):\n            if j == 0 or j == i:\n                triangle[i][j] = 1 if (i % 2 == 0) else 2\n            else:\n                tmp = triangle[i-1][j-1] + triangle[i-1][j]\n                triangle[i][j] = tmp if (i % 2 == 0) else tmp + 1 if (tmp % 2 == 0) else tmp\n\n    # print out the triangle\n    for i in range(n):\n        print(\" \" * (n - i), end=\"\")\n        for j in range(i + 1):\n            print(triangle[i][j], end=\" \")\n        print()"]}
{"task_id": 188, "content": ["def get_lcm(n):\n    prime_factors = []\n    for i in range(2, n + 1):\n        # Find the prime factors of each number from 1 to n\n        for j in range(2, i + 1):\n            if i % j == 0:\n                is_prime = True\n                for k in range(2, int(j ** 0.5) + 1):\n                    if j % k == 0:\n                        is_prime = False\n                        break\n                if is_prime:\n                    prime_factors.append(j)\n    lcm = 1\n    # Loop through the unique prime factors less than or equal to n\n    for factor in set(prime_factors):\n        max_power = 0\n        # Find the highest power of the prime factor that divides any number from 1 to n\n        for i in range(1, n + 1):\n            power = 0\n            while i % factor == 0:\n                power += 1\n                i //= factor\n            if power > max_power:\n                max_power = power\n        # Multiply the prime factor by its highest power to get the contribution to the LCM\n        lcm *= factor ** max_power\n    return lcm", "def extract_number(number: float, precision: int) -> float:\n    \"\"\" Given a float, it breaks down into\n    an integer component (largest integer less or equal to the number) and decimals\n    (remainder always less than 1 and greater than -1).\n\n    The function should return the number preserving precision up to a specified decimal point.\n    \"\"\"\n    format_string = \"{:.\" + str(precision) + \"f}\"\n    formatted_number = format_string.format(number)\n    return float(formatted_number)", "def choose_num(x, y, z):\n    \"\"\"This function should take three positive numbers x, y, and z. The function must return \n    the largest even integer number that is less than or equal to y and greater than or equal \n    to x, which is also a multiple of z. In case no such number exists, the function should return None.\n    \n    Validate your code with the added complexity of handling potential exceptions.\n    \"\"\"  \n    if not (type(x) == type(y) == type(z) == int):\n        return \"Error: Inputs must be integers.\"\n\n    if not (x >= 0 and y >= 0 and z >= 0):\n        return \"Error: Inputs must be positive.\"\n\n    if x > y:\n        return \"Error: x should be less than or equal to y.\"\n\n    #Initialize the largest number as None.\n    largest_num = None\n    \n    #Iterate from y to x both inclusive to find largest even multiple of z.\n    for i in range(y, x - 1, -1):\n        if i % z == 0 and i % 2 == 0:\n            largest_num = i\n            break\n        \n    #Return the largest number.\n    return largest_num", "def check_number(n):\n    if is_power_of_three(n):\n        largest_power_of_three = find_largest_power_of_three(n)\n        num_binary_digits = count_binary_digits(largest_power_of_three)\n        print(f\"{n} is a power of three. Largest power of three less than or equal to {n} is {largest_power_of_three} (with {num_binary_digits} binary digits).\")\n    else:\n        print(f\"{n} is not a power of three.\")", "def find_next_number(sequence):\n    # Get the last number in the sequence\n    last_number = sequence[-1]\n\n    # Check if the last number is a power of 2 and less than 1000\n    if last_number < 1000 and last_number & (last_number - 1) == 0:\n        # If it is, multiply it by 2 to find the next number\n        next_number = last_number * 2\n    else:\n        # If not, print an error message\n        print(\"Invalid sequence! The last number is not a power of 2 or it exceeds 1000.\")\n        return\n\n    return next_number"]}
{"task_id": 189, "content": ["def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def find_word(word, paragraph):\n    \"\"\" \n    This function is used to find the frequency and index positions of a specific word in a paragraph. \n\n    Args: \n    word (str): The word to find in the paragraph.\n    paragraph (str): The paragraph \n\n    Returns: \n    tuple: A tuple containing the frequency of word and a list of index positions. \n    If the word is not found, it returns a message saying so.\n    \"\"\"\n    \n    # The paragraph is converted to lower case for a case-insensitive search\n    lower_paragraph = paragraph.lower()\n\n    # The word is also turned to lower case\n    lower_word = word.lower()\n\n    # Find the frequency of the word\n    count = lower_paragraph.count(lower_word)\n    \n    # If count is zero, return appropriate message\n    if count == 0:\n        return \"The word is not found in the paragraph\"\n\n    # Find the positions of the word\n    index = 0\n    index_list = []\n    for _ in range(count):\n        next_index = lower_paragraph.index(lower_word, index)\n        \n        # Append actual index by ignoring leading spaces or punctuation\n        index_list.append(next_index + paragraph[next_index:].index(lower_word)) \n        index = next_index + len(lower_word)\n\n    # return the results\n    return count, index_list", "def find_max_index(nums):\n    \"\"\"\n    Returns the index of the maximum value in the list.\n    \n    Args:\n    nums: A list of integers\n    \n    Returns:\n    int: Index of the maximum value in the list, or -1 if the list is empty\n    \"\"\"\n    if not nums:  # Check if the list is empty\n        return -1\n    else:\n        max_val = max(nums)  # Find the maximum value in the list\n        return nums.index(max_val)  # Return the index of the maximum value", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def sort(list):\n    \"\"\"\n    This function sorts a given list in ascending order.\n\n    Parameters:\n    list (List[int, float, str]): A list of numerical or string values to be sorted. This list should contain elements of the same datatype for the function to work correctly. \n    \"\"\"\n    list.sort()"]}
{"task_id": 190, "content": ["def frequencySort(nums):\n    # collections.Counter(nums) gives the frequency of each element in the nums array.\n    # items() function returns a view object that displays a list of a dictionary's(an iterable) tuple pair (key, value).\n    c = Counter(nums).items()\n    # Then we will sort the results by the tuple (-count, num). Negative count ensures that high frequency elements come first in the sorted list.\n    # This satisfies the requirement to sort in increasing frequency. \n    # Because we use num for sort as well, elements with the same frequency are sorted in descending order.\n    # This satisfies the requirement to sort in decreasing order on the basis of value of the numbers in case of same frequency.\n    # idx is used to sort elements in increasing order of their index in case elements are same and have same frequency.\n    # sort function of python is stable. i.e, it maintains the relative order of items with equal sort keys\n    nums.sort(key = lambda x: (nums.count(x), -x, [i for i, n in enumerate(nums) if n == x][0]))\n    # return the sorted array\n    return nums", "def sort(list):\n    \"\"\"\n    This function sorts a given list in ascending order.\n\n    Parameters:\n    list (List[int, float, str]): A list of numerical or string values to be sorted. This list should contain elements of the same datatype for the function to work correctly. \n    \"\"\"\n    list.sort()", "def verify_divisibility_and_evenness(numbers, divisor):\n    ''' \n    This function accepts a list of numbers and a divisor then \n    verifies whether each number in the list is divisible by the divisor \n    and is even.\n\n    It returns a list of tuples, with each tuple containing a number \n    and a boolean value indicating whether that number satisfies the conditions\n    \n    @param numbers: List of numbers to be checked\n    @param divisor: The divisor to check divisibility\n    '''\n\n    # Validate inputs\n    if not isinstance(numbers, list) or not isinstance(divisor, int):\n        raise ValueError(\"Invalid Input. Only list of numbers and integer divisor are allowed\")\n    \n    return [ (num, num % divisor == 0 and num % 2 == 0) for num in numbers]", "def verify_divisibility_and_evenness(numbers, divisor):\n    ''' \n    This function accepts a list of numbers and a divisor then \n    verifies whether each number in the list is divisible by the divisor \n    and is even.\n\n    It returns a list of tuples, with each tuple containing a number \n    and a boolean value indicating whether that number satisfies the conditions\n    \n    @param numbers: List of numbers to be checked\n    @param divisor: The divisor to check divisibility\n    '''\n\n    # Validate inputs\n    if not isinstance(numbers, list) or not isinstance(divisor, int):\n        raise ValueError(\"Invalid Input. Only list of numbers and integer divisor are allowed\")\n    \n    return [ (num, num % divisor == 0 and num % 2 == 0) for num in numbers]", "def topKFrequent(words: List[str], k: int) -> List[str]:\n    # Use Python collections.Counter to create a dictionary where keys are the words, and values are the count\n    count = collections.Counter(words)\n    # Use Python heapq to create a min heap with size k.\n    # For elements having the same count, heapify will ensure the element with smallest alphabetical order to pop first.\n    heap = [(-freq, word) for word, freq in count.items()]\n    heapq.heapify(heap)\n    \n    # Use heappop to pop elements from the heap.\n    return [heapq.heappop(heap)[1] for _ in range(k)]"]}
{"task_id": 191, "content": ["def remove_duplicates_from_string(string):\n    '''This function will remove duplicates of characters in a given string'''\n    result = ''\n    for char in string:\n        if char not in result:\n            result += char\n    return result", "def reverse_string(string):\n  '''\n  This function takes in a string and returns the string in reverse order.\n  \n  The algorithm works by iterating over the characters in the string in reverse, creating a new string with the reverse order of characters.\n  \n  :param string: string to be reversed\n  :return: string in reverse order\n  '''\n  \n  # Create a new, empty string to store the reversed string\n  reversed_string = \"\"\n  \n  # Iterate over the characters in the string in reverse order\n  for i in range(len(string)-1, -1, -1):\n    reversed_string += string[i]\n  \n  # Return the reversed string\n  return reversed_string", "def removeDuplicates(string): \n    # Create a regular expression pattern to match and remove duplicate characters\n    regx = re.compile('(.)(?=.*\\1)') \n    # Use the sub() function to replace all the occurrences of duplicate characters with an empty string\n    return regx.sub(\"\", string)", "def remove_non_alphanumeric(s: str) -> str:\n    \"\"\" Corrected function to remove non-alphanumeric characters from a string \"\"\"\n    return ''.join(i for i in s if i.isalnum())", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass"]}
{"task_id": 192, "content": ["def hamming_distance(str1, str2):\n    \"\"\"Calculates the Hamming distance between two strings.\n    Arguments:\n        str1 (str): The first string.\n        str2 (str): The second string.\n    Returns:\n        (int): The Hamming distance.\n    \"\"\"\n    if len(str1) != len(str2):\n        raise ValueError(\"Strings must have the same length\")\n\n    distance = 0\n    for i in range(len(str1)):\n        if str1[i] != str2[i]:\n            distance += 1\n            \n    return distance", "def hamming_distance_list(lst):\n    \"\"\"Calculate the Hamming distance between consecutive binary numbers in a list\"\"\"\n    # Error handling for invalid inputs\n    if not all(isinstance(n, int) for n in lst):\n        raise ValueError(\"All values must be integers\")\n    \n    # Transform the integers into binary\n    binary_lst = [decimal_to_binary(n) for n in lst]\n    \n    # Calculate the Hamming distance between each consecutive pair\n    distances = [hamming_distance(binary_lst[i], binary_lst[i+1]) for i in range(len(binary_lst)-1)]\n    \n    return distances", "def correlate_power_traces(power_traces, plaintexts, key_byte_position):\n    # Implement this function to correlate the power traces with the Hamming weights.\n    # This function will calculate the Hamming weight for each plaintext and each power trace.\n    # Then, it will correlate the Hamming weights with the power traces to find the most likely key byte.\n    \n    # Initialize an array to store the Hamming weights for all plaintexts at the given key byte position.\n    hamming_weights = np.zeros(len(plaintexts), dtype=np.int8)\n    \n    # Calculate the Hamming weight for each plaintext at the given key byte position.\n    for i in range(len(plaintexts)):\n        hamming_weights[i] = hamming_weight(plaintexts[i][key_byte_position])\n    \n    # Correlate the Hamming weights with the power traces.\n    # We will use the Pearson correlation coefficient for this purpose.\n    correlation_coefficients = np.corrcoef(hamming_weights, power_traces)\n    \n    # The correlation coefficients matrix is symmetric, so we only need to consider the upper right triangle.\n    # The diagonal elements are always 1, so we ignore them and find the maximum correlation coefficient.\n    max_correlation_position = np.argmax(np.triu(correlation_coefficients, k=1))\n    \n    # The maximum correlation coefficient gives us the most likely key byte.\n    # We need to convert this back to the actual key byte.\n    # The key byte is the position of the maximum correlation coefficient in the upper right triangle.\n    # Since the correlation matrix is symmetric, we need to adjust the index to get the actual position.\n    max_correlation_position -= key_byte_position\n    \n    # Return the most likely key byte.\n    return max_correlation_position", "def max_difference(arr):\n    \"\"\"\n    This function takes a list of integers and returns the maximum difference between any two elements in the list.\n    \n    Args:\n    arr: A list of integers\n    \n    Returns:\n    int: Maximum difference between any two elements in the list\n    \"\"\"\n    if len(arr) < 2:\n        return 0\n    else:\n        max_diff = max(arr) - min(arr)\n        return max_diff", "def hamming_weight(byte):\n    # Implement this function to calculate the Hamming weight of a byte.\n    # The Hamming weight is the number of 1's in the byte.\n    # This can be done using a bitwise operation that counts the number of bits set to 1.\n    return bin(byte).count('1')"]}
{"task_id": 193, "content": ["def find_index_of_first_occurrence(string, character):\n    '''\n    This function will find the index of the first occurrence of a given character in a string.\n\n    Args:\n        string (str): the string to be searched\n        character (str): the character to be searched for\n\n    Returns:\n        int: the index of the first occurrence of the character\n    '''\n    return string.find(character)", "def highest_occurring_character(string):\n    \"\"\"Find the highest occurring character in a string.\"\"\"\n\n    # Initialise a dictionary to store the number of occurrences of each character\n    char_occurrences = {}\n\n    # Store the number of occurrences of each character\n    for char in string:\n        char_occurrences[char] = char_occurrences.get(char, 0) + 1\n\n    # Find the maximum occurrence of all the characters\n    max_occurrence = 0\n    highest_occurring_char = None\n\n    # Iterate over the occurrence dictionary to find the highest occurrence\n    for char, occurrence in char_occurrences.items():\n        if occurrence > max_occurrence:\n            max_occurrence = occurrence\n            highest_occurring_char = char\n\n    return highest_occurring_char", "def count_chars(string):\n    \"\"\"Function to count characters in a given string\"\"\"\n    count = 0\n\n    # Loop through each character\n    for char in string:\n        count += 1\n\n    # Return the count\n    return count", "def generate_advanced_histogram(test):\n    \"\"\" Assume test is a string.\n    Generate a list of tuples where the first element of the tuple is character from the string. \n    The second element of the tuple is the frequency of occurrence of that character in the string.\n    Treat uppercase and lowercase letters as the same letter, and include counts for digits and punctuation. \n    \"\"\" \n\n    # Initialize an empty dictionary to keep track of character frequencies\n    histogram = {}\n\n    # Iterate over each character in the input string\n    for char in test:\n        # Convert current character to lowercase to handle the case insensitivity\n        char = char.lower()\n        \n        # If the character is already in the dictionary, increment its count\n        # Otherwise, add it to the dictionary with a count of 1\n        histogram[char] = histogram.get(char, 0) + 1 \n    \n    # Convert the histogram dictionary to a list of tuples and sort it\n    histogram_list = sorted(histogram.items(), key = lambda x: x[0])\n\n    return histogram_list", "def count_alphanumeric_chars(string):\n    # Create a dictionary to store the occurrence count of each character\n    char_count = defaultdict(int)\n\n    # Iterate through the string and increment the count for each alphanumeric character\n    for char in string:\n        if char.isalnum():\n            char_count[char] += 1\n\n    # Sort the dictionary by value in descending order\n    sorted_chars = sorted(char_count.items(), key=lambda x: x[1], reverse=True)\n\n    # Return the characters in descending order of their occurrence count\n    return [char for char, count in sorted_chars]"]}
{"task_id": 194, "content": ["def transpose(matrix):\n    # The * operator is used to unzip a list (or other iterables), making a list of tuples where each tuple contains the i-th element from each of the argument sequences or iterables.\n    # The zip() function takes iterables, aggregates them in a tuple, and return the result.\n    # In other words, it returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.\n    return [list(i) for i in zip(*matrix)] ", "def revised_function(input_tuple):\n    # Checks if the tuple is None or empty \n    if not input_tuple:\n        return \"Error: input is NULL or empty.\"\n\n    # Initiating an empty list to hold string representations of the float values\n    str_list = []\n\n    # Iterate over the elements in the tuple\n    for element in input_tuple:\n        # Confirm that each element is a float. If not, return an error message.\n        if not isinstance(element, float):\n            return \"Error: all elements in the tuple should be floats.\"\n            \n        # Convert the float to a string and append to the list\n        str_list.append(str(element))\n    \n    # Join all elements in the list with a semicolon\n    result = \"; \".join(str_list)\n    \n    return result", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def add_to_beginning(old_tuple, new_elements):\n    \"\"\" Add multiple elements at the beginning of given tuple \"\"\"\n    # Validate the type of the new elements\n    if not validate_types(old_tuple, new_elements):\n        raise ValueError(\"Types of new elements are not consistent with the original tuple.\")\n    \n    # Adding new elements to the beginning of the tuple\n    result = new_elements + old_tuple\n    return result", "def list_processing(my_list):\n  # Checks if all elements are either integer or string\n  valid_types = [int, str]\n  if all(type(x) in valid_types for x in my_list):\n      # Convert the list to a set to remove duplicated and then convert it to a tuple\n      new_tuple = tuple(set(my_list))\n      # Return the new tuple and the number of unique elements\n      return new_tuple, len(new_tuple)\n  else:\n      # In case if there are elements in the list other than integers and strings\n      return \"List contains non-string or non-integer elements\""]}
{"task_id": 195, "content": ["def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def transpose(matrix):\n    # The * operator is used to unzip a list (or other iterables), making a list of tuples where each tuple contains the i-th element from each of the argument sequences or iterables.\n    # The zip() function takes iterables, aggregates them in a tuple, and return the result.\n    # In other words, it returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.\n    return [list(i) for i in zip(*matrix)] ", "def sort_list(tuples):\n    \"\"\"\n    A function to sort a list of tuples by the second item in each tuple.\n    \"\"\"\n    return sorted(tuples, key=lambda x: x[1])", "def sort_by_second_item(tuples):\n    \"\"\"Sorts a list of tuples by the second item in the tuples.\n    \n    Args:\n        tuples: A list of tuples to be sorted.\n        \n    Returns:\n        sorted_list: The sorted list of tuples.\n    \"\"\"\n    sorted_list = sorted(tuples, key=lambda x: x[1])\n    \n    return sorted_list", "def sort_data(data, key, reverse=False):\n    '''\n    Function to sort data by a custom criteria.\n\n    Parameters\n    ----------\n    data: list\n        List of objects that need to be sorted.\n    key: function\n        A function that maps the objects in the data to the score that will be used for sorting.\n    reverse: boolean, optional\n        If True, the data will be sorted in reverse order.\n\n    Returns\n    ----------\n    sorted_data: list\n        The sorted list.\n    '''\n\n    # Create a list of tuples [(score, data_item)...] using the key function\n    data_tups = [(key(data_item), data_item) for data_item in data]\n    # Sort the list by the scores\n    sorted_data_tups = sorted(data_tups, reverse=reverse)\n    # Extract the sorted data from the tuples\n    sorted_data = [data_tup[1] for data_tup in sorted_data_tups]\n \n    # Return the sorted data\n    return sorted_data"]}
{"task_id": 196, "content": ["def count_similar_chars(string1, string2):\n    \"\"\"\n    This function counts the number of similar characters between two strings,\n    assuming the strings have the same length.\n    \"\"\"\n    # Initialize a counter for the number of similar characters\n    count = 0\n\n    # Iterate through the two strings using a common index\n    index = 0\n    for char1 in string1:\n        # If the characters at the current index are equal, increment the counter\n        if char1 == string2[index]:\n            count += 1\n        index += 1\n\n    return count", "def rarest_subseq(lst):\n    # Hashable version of the list for countability\n    hashable_lst = list(map(hashable, lst))\n\n    # Get all non-overlapping subsequences of length 3 and more\n    subsequences = [hashable_lst[i:j] for i in range(len(hashable_lst)) for j in range(i + 3, len(hashable_lst) + 1)]\n\n    # Count the occurrences of each subsequence\n    counter = collections.Counter(map(tuple, subsequences))\n\n    # Find the smallest count\n    min_count = min(counter.values())\n\n    # Get the subsequences that have the smallest count\n    rarest_subsequences = [k for k, v in counter.items() if v == min_count]\n\n    # Unhashify the subsequences back to original elements\n    return [list(map(lambda el: lst[hashable_lst.index(el)] if hashable_lst.count(el) == 1 else el, subseq)) for subseq in rarest_subsequences]", "def letter_count(str1, str2):\n    '''\n    Function to compare the length of two strings\n    \n    Parameters\n    str1: string\n    str2: string\n    \n    Returns\n    True if the strings have the same number of characters, otherwise False\n    '''\n    if len(str1) == len(str2):\n        return True\n    return False", "def longest_common_subsequence(x, y):\n    m = len(x)\n    n = len(y)\n\n    # Create a matrix to store the lengths of longest common subsequences\n    lcs = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Calculate the lengths of longest common subsequences\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                lcs[i][j] = 0\n            elif x[i - 1] == y[j - 1]:\n                lcs[i][j] = lcs[i - 1][j - 1] + 1\n            else:\n                lcs[i][j] = max(lcs[i - 1][j], lcs[i][j - 1])\n\n    # Find the length of the longest common subsequence\n    length = lcs[m][n]\n\n    # Find all possible longest common subsequences\n    subsequences = []\n    find_subsequences(x, y, m, n, lcs, \"\", subsequences)\n\n    return length, subsequences", "def find_decreasing_subsequences(array):\n    n = len(array)\n    if n < 2: return []\n\n    subsequences = []\n    start = 0\n\n    # Find decreasing subsequences\n    for i in range(1, n):\n        if array[i-1] <= array[i]:\n            if start != i-1:\n                subsequences.append((start, i-1))\n            start = i\n\n    if start != n-1:\n        subsequences.append((start, n-1))\n\n    # Filter to longest decreasing subsequences\n    max_length = max(end-start+1 for start, end in subsequences)\n    subsequences = [(start, end) for start, end in subsequences if end-start+1 == max_length]\n\n    return subsequences"]}
{"task_id": 197, "content": ["def extract_integer(number: float, precision: int) -> float:\n    \"\"\" Given a float, it breaks down into\n    an integer component (largest integer less or equal to the number) and decimals\n    (remainder always less than 1 and greater than -1).\n\n    The function should return the integer part of the number preserving precision up to a specified decimal point.\n    >>> extract_integer(4.70, 2)\n    4.70\n    >>> extract_integer(-3.200, 3)\n    -3.200\n    \"\"\"\n    decimal_point = Decimal(10) ** -precision  # Defines the decimal point up to the specified precision\n\n    if isinstance(number, (int, float)):\n        number = Decimal(number)  # Create a Decimal instance of the number\n    elif isinstance(number, str):\n        number = Decimal(number.replace(',', '.'))\n\n    return float(number.quantize(decimal_point, rounding=ROUND_DOWN))  # Return the number as a float, rounded to the specified precision", "def extract_number(number: float, precision: int) -> float:\n    \"\"\" Given a float, it breaks down into\n    an integer component (largest integer less or equal to the number) and decimals\n    (remainder always less than 1 and greater than -1).\n\n    The function should return the number preserving precision up to a specified decimal point.\n    \"\"\"\n    format_string = \"{:.\" + str(precision) + \"f}\"\n    formatted_number = format_string.format(number)\n    return float(formatted_number)", "def calculate_pi_and_action():\n    pi = round(math.pi, 10)  # Calculate pi with 10 decimal places precision\n    pi_str = str(pi)  # Convert pi to a string for easy manipulation\n    decimal_idx = pi_str.index('.')  # Find the index of the decimal point\n    actionIdx = decimal_idx + 1  # Increment the decimal index to get the index of the first decimal digit\n\n    return pi, actionIdx", "def calculate_sum(base_sum, interest_rate, period, compound_times):\n    \"\"\"\n    Compute the final sum with compounded interest using a precise type Decimal\n    :param base_sum: Initial amount of money\n    :param interest_rate: Annual interest rate\n    :param period: Number of years\n    :param compound_times: Number of times the interest is compounded per year\n    :return: Accumulated sum of funds after the period of years\n    \"\"\"\n    \n    # Set the precision for Decimal calculations\n    getcontext().prec = 10\n\n    # convert inputs to Decimal for precision\n    base_sum = Decimal(base_sum)\n    interest_rate = Decimal(interest_rate)\n    period = Decimal(period)\n    compound_times = Decimal(compound_times)\n\n    accum_sum = base_sum * (1 + interest_rate / (100 * compound_times)) ** (compound_times * period)\n    return float(accum_sum)", "def extract_integer(number: float, precision: int) -> float:\n    \"\"\"\n    Function to extract the integer part of a given number up to a certain precision\n    \"\"\"\n    if number < 0:\n        return round(number - 0.5 + 10**(-precision), precision)\n    else:\n        return round(number + 0.5 - 10**(-precision), precision)"]}
{"task_id": 198, "content": ["def delete_element(my_list, pos):\n    \"\"\"Function to delete an element from a given list at a given position.\"\"\"\n    del my_list[pos]\n    return my_list", "def enqueue(item, priority):\n    \"\"\"\n    This function adds an item to the priority queue with a given priority.\n    \"\"\"\n    global num_elements\n    \n    # Add item to the end of the list with the given priority\n    heap.append((priority, item))\n    num_elements += 1\n    \n    # Bubble up the item to its correct position\n    idx = num_elements - 1\n    while idx > 0 and heap[idx][0] > heap[idx//2][0]:\n        heap[idx], heap[idx//2] = heap[idx//2], heap[idx]\n        idx = idx//2", "def remove_duplicates(input_list):\n    '''\n    This function removes the duplicate elements from a given list \n    and returns a new list of unique elements.\n    '''\n    unique_elements = [] \n    for element in input_list: \n        # Check if element exists in unique_element list, \n        # if not then append it \n        if element not in unique_elements: \n            unique_elements.append(element) \n    return unique_elements", "def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list", "def esoteric_sorting_utilizing_heap(lst):\n    # An array to hold max heap, we will input smallest item from min heap to max heap\n    max_heap = []\n    # An array to hold min heap and max heap \n    min_heap, output = lst, []\n\n    # Turn lst into a max heap \n    heapq.heapify(min_heap)\n\n    # While there are items in the heap \n    while min_heap:\n        # Move smallest from min heap to max heap\n        heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        if min_heap:\n            output.append(-heapq.heappop(max_heap))  \n        if min_heap:\n            output.append(heapq.heappop(min_heap))\n\n    # Return the esoteric sorted list \n    return output"]}
{"task_id": 199, "content": ["def contains_characters(url, characters):\n    '''\n    This function will determine if a given URL contains certain characters.\n    \n    Args:\n        url (str): the URL to be checked\n        characters (list): a list of characters to be searched\n\n    Returns:\n        bool: True if the URL contains any of the given characters, False otherwise\n    '''\n    for character in characters:\n        if character in url:\n            return True\n    \n    return False", "def is_palindrome(input_string):\n    # Regular expression to match strings of a-z, A-Z and 0-9 characters\n    matched_string = re.findall('[a-zA-Z0-9]', input_string)\n\n    # Join the matched characters into a string\n    refined_string = \"\".join(matched_string).lower()\n\n    # Check if the string is a palindrome\n    return refined_string == refined_string[::-1]", "def is_valid_string(string):\n    \"\"\"\n    This function takes in a variable and checks if it is a string with a length of at least 3 characters.\n    If the string contains only alphabetic characters, it will be converted to title case.\n    \"\"\"\n    if not isinstance(string, str):   # check if input is not a string\n        return False\n    if string == \"\":    # check if input is an empty string\n        return False\n    if len(string) < 3:   # check if input string length is less than 3 characters\n        return False\n    \n    # check if string contains only alphabetic characters\n    if not string.isalpha():\n        return False\n    \n    # convert string to title case\n    string = string.title()\n    \n    return string  # return valid string in title case", "def unique_chars_in_string(test_str):\n    \"\"\"\n    This function returns True if all the alphabetic characters within the provided string are \n    unique and non-repetitive, otherwise it returns False.\n\n    Parameters:\n    test_str (str): The string to be checked.\n\n    Returns:\n    bool: Whether or not the string contains unique alphabetic characters.\n    \"\"\"\n\n    # convert the string to lower case to treat 'P' and 'p' as the same character\n    test_str = test_str.lower()\n\n    # disregard non-alphabetic characters by ensuring that only alphabetic characters are\n    # included in our character-checking process\n    test_str = ''.join(c for c in test_str if c.isalpha())\n\n    # check for the uniqueness of characters by comparing the length of the string with \n    # the number of unique characters (determined via the set function)\n    return len(test_str) == len(set(test_str))", "def check_string(string):\n    # Check if the string contains only alphabetical characters and has a length of at least 10 characters\n    if not string.isalpha() or len(string) < 10:\n        return False\n\n    # Check if the string contains at least two uppercase letters, two lowercase letters, and two digits\n    uppercase_count = len(re.findall(r'[A-Z]', string))\n    lowercase_count = len(re.findall(r'[a-z]', string))\n    digit_count = len(re.findall(r'\\d', string))\n\n    if uppercase_count < 2 or lowercase_count < 2 or digit_count < 2:\n        return False\n\n    return True"]}
{"task_id": 200, "content": ["def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]", "def count_elements(dictionary):\n    count = 0\n    \n    # Iterate through the key-value pairs in the dictionary\n    for key, value in dictionary.items():\n        # Exclude elements whose keys are numbers or whose values are dictionaries\n        if not isinstance(key, int) and not isinstance(value, dict):\n            # If the value is a nested dictionary, count the elements in that dictionary as well\n            if isinstance(value, dict):\n                count += count_elements(value)\n            else:\n                count += 1\n    \n    return count", "def calculate_parity(n):\n    # Count the number of set bits using bitwise AND and right shift\n    count = 0\n    while n:\n        count ^= n & 1\n        n >>= 1\n\n    # Return 1 if the number of set bits is odd, 0 otherwise\n    return count", "def add_two_numbers(a, b):\n    # Carry contains common set bits of a and b\n    while (b != 0):\n         \n        # carry now contains common\n        # set bits of a and b\n        carry = a & b\n \n        # Sum of bits of a and b where at\n        # least one of the bits is not set\n        a = a ^ b\n \n        # Carry is shifted by one so that\n        # adding it to a gives the required sum\n        b = carry << 1\n     \n    return a", "def topKFrequent(words: List[str], k: int) -> List[str]:\n    # Use Python collections.Counter to create a dictionary where keys are the words, and values are the count\n    count = collections.Counter(words)\n    # Use Python heapq to create a min heap with size k.\n    # For elements having the same count, heapify will ensure the element with smallest alphabetical order to pop first.\n    heap = [(-freq, word) for word, freq in count.items()]\n    heapq.heapify(heap)\n    \n    # Use heappop to pop elements from the heap.\n    return [heapq.heappop(heap)[1] for _ in range(k)]"]}
{"task_id": 201, "content": ["def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def sum_of_n_numbers(n):\n    \"\"\"This function will return the sum of n natural numbers.\"\"\"\n    # check if n is 1\n    if n == 1:\n        return 1\n    # Otherwise, recursively call the function\n    else:\n        return n + sum_of_n_numbers(n-1)", "def sum_natural_numbers(start, end):\n    \"\"\"\n    Computes the sum of all natural numbers in a given range.\n    \n    Parameters:\n    start (int): start of the range\n    end (int): end of the range\n    \n    Returns:\n    int: the sum of the natural numbers in the range\n    \"\"\"\n    total = 0\n    for i in range(start, end+1):\n        total += i\n    return total", "def sum_of_natural_numbers(n):\n    # Calculate the sum of n natural numbers\n    sum = (n * (n+1)) / 2\n    return sum", "def triangle_square_sum(n):\n    \"\"\"\n    Function to calculate the sum of the Triangle Series and the sum of the square of each\n    number in the Triangle Series up to n.\n    \"\"\"\n    # error handling: if n is negative or not an integer\n    if not isinstance(n, int) or n < 1:\n        return \"Error: Input must be an positive integer\"\n\n    # calculate the sum of the Triangle Series\n    # formula for the sum of the first n natural numbers is n*(n+1)/2\n    triangle_sum = n * (n + 1) // 2  # use integer division to ensure result is an integer\n\n    # calculate the sum of the square of each number in the Triangle Series up to n.\n    # formula for the sum of the squares of the first n natural numbers is n*(n+1)*(2n+1)/6\n    square_sum = n * (n + 1) * (2 * n + 1) // 6  # use integer division to ensure result is an integer\n\n    return triangle_sum, square_sum"]}
{"task_id": 202, "content": ["def concat_strings(string1, string2):\n    \"\"\"\n    Concatenate two strings and output the concatenation.\n\n    Args:\n        string1 (str): first string\n        string2 (str): second string\n\n    Returns:\n        str: concatenation of string1 and string2\n    \"\"\"\n    return string1 + ' ' + string2", "def concat_strings(string1, string2):\n    '''Return the concatenation of two strings.'''\n    return string1 + string2", "def sort_by_second_item(tuples):\n    \"\"\"Sorts a list of tuples by the second item in the tuples.\n    \n    Args:\n        tuples: A list of tuples to be sorted.\n        \n    Returns:\n        sorted_list: The sorted list of tuples.\n    \"\"\"\n    sorted_list = sorted(tuples, key=lambda x: x[1])\n    \n    return sorted_list", "def sort_list(tuples):\n    \"\"\"\n    A function to sort a list of tuples by the second item in each tuple.\n    \"\"\"\n    return sorted(tuples, key=lambda x: x[1])", "def transpose(matrix):\n    # The * operator is used to unzip a list (or other iterables), making a list of tuples where each tuple contains the i-th element from each of the argument sequences or iterables.\n    # The zip() function takes iterables, aggregates them in a tuple, and return the result.\n    # In other words, it returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.\n    return [list(i) for i in zip(*matrix)] "]}
{"task_id": 203, "content": ["def conversion_degrees_to_radians(degrees):\n    \"\"\"\n    Function to convert given number of degrees to radians\n    Arguments:\n    degrees -- int -- number of degrees\n    Output:\n    radians -- float -- equivalent number in radians\n    \"\"\"\n    radians = (degrees * math.pi) / 180\n    return radians", "def convert(arc_minutes):\n    # There are 60 arc minutes in a degree and 2*pi radians in a degree, so we can simply divide by \n    # these values to get our result.\n    degrees = arc_minutes / 60.0\n    radians = degrees * (math.pi / 180.0)\n    return radians", "def calculate_angle(point1, point2):\n    x1, y1 = point1\n    x2, y2 = point2\n\n    # Calculate the difference in x and y coordinates\n    dx = x2 - x1\n    dy = y2 - y1\n\n    # Calculate the slope of the line passing through the two points\n    slope = dy / dx\n\n    # Calculate the angle in radians using the arctangent function\n    radians = math.atan(slope)\n\n    # Convert the angle from radians to degrees\n    degrees = math.degrees(radians)\n\n    # Return the angle in degrees\n    return degrees", "def find_altitude(c, angle):\n    # Convert the angle from degrees to radians, as math.sin in Python takes radians\n    angle = math.radians(angle)\n    \n    # Compute the altitude using the formula h = c * sin(A)\n    h = c * math.sin(angle)\n    \n    return h", "def calculate_height(length, angle_in_degrees):\n    # convert angle from degrees to radians\n    angle_in_radians = math.radians(angle_in_degrees)\n    height = length * math.sin(angle_in_radians)\n    return height"]}
{"task_id": 204, "content": ["def delete_element(my_list, pos):\n    \"\"\"Function to delete an element from a given list at a given position.\"\"\"\n    del my_list[pos]\n    return my_list", "def apply_function(arr, f):\n    \"\"\"\n    Apply a given function to each item of an input array.\n    \n    Args:\n        arr (list): The input array.\n        f (function): The function to be applied.\n        \n    Returns:\n        list: A list with the result of applying function f to each item of arr.\n    \"\"\"\n    return list(map(f, arr))", "def decode_dns_queries(dns_queries):\n    \"\"\"\n    Decodes a series of DNS queries back into the original data.\n\n    :param dns_queries: The list of DNS queries to decode.\n    :return: The original data.\n    \"\"\"\n    # Extract the base domain from the first DNS query\n    base_domain = dns_queries[0].split('.')[-1]\n    \n    # Extract the encoded data from the DNS queries\n    encoded_chunks = [query.split('.')[0] for query in dns_queries]\n    encoded_data = ''.join(encoded_chunks)\n    \n    # Decode the base64 encoded data\n    decoded_data = base64.b64decode(encoded_data).decode()\n    \n    return decoded_data", "def sort(list):\n    \"\"\"\n    This function sorts a given list in ascending order.\n\n    Parameters:\n    list (List[int, float, str]): A list of numerical or string values to be sorted. This list should contain elements of the same datatype for the function to work correctly. \n    \"\"\"\n    list.sort()", "def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list"]}
{"task_id": 205, "content": ["def multiply_numbers(lst):\n    '''\n        Function to calculate the product of all elements in a nested list of integers.\n        Parameters:\n        lst (list): Nested list of integers.\n\n        Returns:\n        product (integer or float): The product of all elements in the nested list.\n    '''\n    # Ensure the input type is correct:\n    if type(lst) is not list:\n        raise TypeError(\"Input should be a list of integers\")\n\n    # start calculation:\n    product = 1\n    for i in lst:\n        if type(i) is list:\n            product *= multiply_numbers(i)\n        else:\n            if type(i) is int:\n                product *= i\n            else:\n                raise TypeError(\"All elements in nested lists should be integers\")\n\n    return product", "def transform_matrix_to_json(matrix):\n    # If the element is not a nested list, it's a value in the matrix.\n    # Return the element.\n    if not isinstance(matrix, list):\n        return matrix\n    # If the element is a nested list, transform each element in the list.\n    else:\n        return [transform_matrix_to_json(element) for element in matrix]", "def flatten(lst):\n    flat_list = []\n    stack = [lst]  # Use a stack to keep track of nested lists\n\n    while stack:\n        curr = stack.pop()\n        if isinstance(curr, list):  # Check if the current element is a list\n            stack.extend(curr[::-1])  # Add the elements of the nested list in reverse order\n        else:\n            flat_list.append(curr)\n\n    return flat_list", "def find_overlapping_elements(list1, list2):\n    result = []\n    \n    # Iterate over elements in list1\n    for item in list1:\n        # Check if item is also present in list2\n        if item in list2:\n            result.append(item)\n        # Check if item is a list\n        if isinstance(item, list):\n            # Recursively call the function for the nested list\n            nested_result = find_overlapping_elements(item, list2)\n            # Extend the result list with the nested result\n            result.extend(nested_result)\n    \n    return result", "def get_value(dictionary, key):\n    # Check if the given dictionary is a nested dictionary\n    if isinstance(dictionary, dict):\n        # Iterate through each key-value pair in the dictionary\n        for k, v in dictionary.items():\n            # Check if the key matches the given key\n            if k == key:\n                # If it does, return the value\n                return v\n            else:\n                # If the value is another dictionary, recursively call the function\n                if isinstance(v, dict):\n                    result = get_value(v, key)\n                    if result is not None:\n                        return result\n                # If the value is a list, iterate through each element and recursively call the function\n                elif isinstance(v, list):\n                    for item in v:\n                        result = get_value(item, key)\n                        if result is not None:\n                            return result\n    # If the given dictionary is not a nested dictionary, return None\n    return None"]}
{"task_id": 206, "content": ["def find_first_repeated_character(s):\n    \"\"\"\n    Find the first repeated character in a given string.\n    \n    Args:\n        s (str): The input string.\n        \n    Returns:\n        str: The first repeated character in s, or None if no repeated characters are found.\n    \"\"\"\n    char_set = set()\n    for c in s:\n        if c in char_set:\n            return c\n        char_set.add(c)\n    return None", "def find_index_of_first_occurrence(string, character):\n    '''\n    This function will find the index of the first occurrence of a given character in a string.\n\n    Args:\n        string (str): the string to be searched\n        character (str): the character to be searched for\n\n    Returns:\n        int: the index of the first occurrence of the character\n    '''\n    return string.find(character)", "def count_character_types(s):\n    # Initialize counters\n    alphabetic_count = 0\n    numeric_count = 0\n    special_character_count = 0\n\n    # Iterate through each character in the input string\n    for ch in s:\n        # Check if character is an alphabet using Python's built-in function\n        if ch.isalpha():\n            alphabetic_count += 1\n            \n        # Check if character is a number using Python's built-in function\n        elif ch.isdigit():\n            numeric_count += 1\n            \n        # If the character is neither an alphabet nor a number, it's a special character.\n        elif ch.isspace() == False:\n            special_character_count += 1\n\n    return (alphabetic_count, numeric_count, special_character_count)", "def count_chars(string):\n    \"\"\"Function to count characters in a given string\"\"\"\n    count = 0\n\n    # Loop through each character\n    for char in string:\n        count += 1\n\n    # Return the count\n    return count", "def find_first_non_duplicate(string):\n    # Create a dictionary to store the count of each character\n    character_count = {}\n    \n    # Convert the string to lowercase\n    string = string.lower()\n    \n    # Iterate over each character in the string\n    for char in string:\n        # If the character is already in the dictionary, increment its count\n        # Otherwise, add the character to the dictionary with a count of 1\n        if char in character_count:\n            character_count[char] += 1\n        else:\n            character_count[char] = 1\n    \n    # Iterate over the original string to find the first non-duplicate character\n    for char in string:\n        # If the count of the character is 1, return it\n        if character_count[char] == 1:\n            return char\n    \n    # If no non-duplicate character is found, return None\n    return None"]}
{"task_id": 207, "content": ["def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min", "def obfuscate_code(code):\n    # This function would modify the bytecode of the Python script\n    # to make it harder to detect and analyze.\n    pass", "def calculate_expression(operations, numbers):\n    # Dictionary that maps arithmetic operations to their equivalent python operator.\n    operators_map = {'+': operator.add, \n                     '-': operator.sub, \n                     '*': operator.mul, \n                     '/': operator.truediv, \n                     '%': operator.mod }\n\n    # First operand\n    result = numbers[0]\n\n    # Loop through the list of operations\n    for i in range(1, len(numbers)):\n        if operations[i-1] in operators_map: # Check if the operation is valid.\n            op = operators_map[operations[i-1]] # Get the python operator function.\n            result = op(result, numbers[i]) # Apply the operation.\n        else:\n            raise ValueError(f\"Invalid operation '{operations[i-1]}'\") \n\n    # The function should return the final result.\n    return result", "def erroneous():\n    string1 = 'Python Programming'  # The closing quote of string1 was mismatched, so I corrected it\n    string2 = '101'\n\n    # Convert string2 into integer\n    int_value = int(string2)  # The square brackets [] should be replaced with parentheses () for the int function\n    float_value = float('10.5')  # Similarly, the square brackets [] should be replaced with parentheses () for the float function\n\n    # Find the maximum number between 10 and 20\n    max_value = max(10, 20)  # In order to find the maximum between two numbers, both numbers need to be provided as arguments\n\n    # Find the minimum number between 10 and 20\n    min_value = min(10, 20)  # Similarly, to find the minimum between two numbers, both numbers need to be provided as arguments\n\n    # Find the square root of a number\n    sqrt = math.sqrt(16)  # Again, the square brackets [] should be replaced with parentheses () for the sqrt function\n\n    return string1, int_value, float_value, max_value, min_value, sqrt", "def inject_payload(pid, payload):\n    # This function would need to be implemented to attach to the process,\n    # find the system call table, and modify it to point to the custom handler.\n    # This is a complex task that typically requires kernel-level access and\n    # is beyond the scope of a simple Python script.\n    pass"]}
{"task_id": 208, "content": ["def random_number(minimum, maximum):\n    '''This function takes a minimum and maximum number and generates a random number within the given range.'''\n    return random.randint(minimum, maximum)", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def find_min_max(arr):\n    # Initialize variables to store the maximum, minimum, second maximum, and second minimum elements\n    max_element = float('-inf')\n    min_element = float('inf')\n    second_max = float('-inf')\n    second_min = float('inf')\n\n    # Iterate through each element in the array\n    for num in arr:\n        if num > max_element:\n            # Update the maximum and second maximum elements\n            second_max = max_element\n            max_element = num\n        elif num > second_max and num != max_element:\n            # Update the second maximum element\n            second_max = num\n\n        if num < min_element:\n            # Update the minimum and second minimum elements\n            second_min = min_element\n            min_element = num\n        elif num < second_min and num != min_element:\n            # Update the second minimum element\n            second_min = num\n\n    # Return the maximum, minimum, second maximum, and second minimum elements\n    return max_element, min_element, second_max, second_min", "def getRange(minimum, maximum):\n    # Step 1: Create an empty list to store the numbers within the given range\n    range_list = []\n    \n    # Step 2: Determine the sign of the range (positive or negative)\n    if minimum < 0 and maximum < 0:\n        # Step 3: If both minimum and maximum are negative, iterate from minimum to maximum (inclusive) and add each number to the range list\n        for num in range(minimum, maximum - 1, -1):\n            range_list.append(num)\n    elif minimum < 0 and maximum >= 0:\n        # Step 4: If minimum is negative and maximum is non-negative, iterate from minimum to 0 (inclusive) and add each number to the range list\n        for num in range(minimum, 0):\n            range_list.append(num)\n        # Step 5: Iterate from 0 to maximum (inclusive) and add each number to the range list\n        for num in range(0, maximum + 1):\n            range_list.append(num)\n    else:\n        # Step 6: If minimum and maximum are both non-negative, iterate from minimum to maximum (inclusive) and add each number to the range list\n        for num in range(minimum, maximum + 1):\n            range_list.append(num)\n    \n    # Step 7: Return the range list\n    return range_list", "def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min"]}
{"task_id": 209, "content": ["def eliminate_spaces(text):\n    condensed_text = re.sub(' +', ' ', text)     # use a regular expression to replace one or more occurrences of spaces with a single space\n    return condensed_text", "def sanitize_short_code(short_code):\n    # Remove unacceptable characters\n    short_code = re.sub(r'[^a-z0-9\\._]', '', short_code)\n    \n    # Replace consecutive spaces or dots with a single underscore\n    short_code = re.sub(r'[\\ .]+', '_', short_code)\n    \n    return short_code", "def format_data(summary, title):\n    \"\"\"\n    Used to format the number and date data for each game.\n    Example summary: 21-22-29-38-40 PB 16\n    Example title: Powerball Winning Numbers on Wednesday, January 18, 2017\n    \"\"\"\n    numbers = summary.replace('-', ',')  # Replace hyphens with commas\n\n    if 'PB' in numbers or 'MB' in numbers:  # Check if 'PB' or 'MB' is present in the numbers\n        numbers = re.sub('PB|PP|MB|MP', '', numbers)  # Remove 'PB', 'PP', 'MB', 'MP' from the numbers\n        numbers = numbers.replace(' ', '')  # Remove any spaces\n        numbers = re.sub(',+', ',', numbers)  # Replace consecutive commas with a single comma\n\n    return numbers", "def replace_cats_with_dogs(string):\n    # Use a regular expression to find occurrences of the word \"cat\"\n    # that are not part of \"category\" or \"caterpillar\"\n    pattern = r'\\bcat\\b(?!(egory|erpillar))'\n    \n    # Use the re.sub() function to replace all occurrences of the pattern with \"dog\"\n    new_string = re.sub(pattern, 'dog', string)\n    \n    return new_string", "def replace_word(original_text, target_word, replacement_word):\n    \"\"\"\n    This function replaces all occurrences of a target word \n    in the original text with a replacement word.\n\n    :param original_text: The original text.\n    :type original_text: str\n    :param target_word: The word to be replaced.\n    :type target_word: str\n    :param replacement_word: The word to replace the target word.\n    :type replacement_word: str\n    :return: The text with all occurrences of the target word replaced.\n    :rtype: str\n    \"\"\"\n    replaced_text = original_text.replace(target_word, replacement_word)\n    \n    return replaced_text"]}
{"task_id": 210, "content": ["def get_even_list(numbers):\n    \"\"\"\n    Generate a new sorted list containing only the even numbers in a given list.\n    \n    Args:\n        numbers (list): The list of numbers to be checked.\n        \n    Returns:\n        list: A new list containing only the even numbers from the input list, sorted in ascending order.\n    \"\"\"\n    even_list = [number for number in numbers if number % 2 == 0]\n    even_list.sort()\n    return even_list", "def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]", "def foo(lst):\n    \"\"\"\n    This function takes a list of integers as input and returns a new list that only contains even numbers. \n    If the input list does not contain any even numbers, the function returns an empty list.\n    \"\"\"\n    even_lst = [] # Create an empty list to store even numbers in\n    for num in lst: # Loop through each number in the input list\n        if num % 2 == 0: # Check if the number is even\n            even_lst.append(num) # If it is, add it to the even_lst\n    return even_lst # Return the even_lst", "def calculate_sum_positive_even_numbers(numbers):\n    \"\"\"\n    Calculates the sum of all positive even numbers from a given list.\n    \n    Args:\n    numbers (list): The list of numbers.\n    \n    Returns:\n    int: The sum of all positive even numbers.\n    \n    Raises:\n    ValueError: If the input list contains non-integer elements.\n    \n    \"\"\"\n    \n    # Validate the input list\n    for num in numbers:\n        if not isinstance(num, int):\n            raise ValueError(\"Input list should only contain integers.\")\n    \n    # Initialize sum variable\n    sum = 0\n    \n    # Create a set to store unique even numbers\n    unique_evens = set()\n    \n    # Iterate through the list\n    for num in numbers:\n        # Check if the number is positive and even\n        if num > 0 and num % 2 == 0:\n            # Add the number to the set of unique even numbers\n            unique_evens.add(num)\n    \n    # Calculate the sum of unique even numbers\n    for even_num in unique_evens:\n        sum += even_num\n    \n    return sum", "def count_even(lst):\n    \"\"\"This function will count the number of even numbers in a given list\"\"\"\n    return sum(1 for num in lst if num % 2 == 0)"]}
{"task_id": 211, "content": ["def add_element_to_tuple(original_tuple, new_element):\n    # Check if all elements in the tuple are of the same type as the new element\n    if all(isinstance(x, type(new_element)) for x in original_tuple):\n        # Convert the tuple to a list\n        temp_list = list(original_tuple)\n        # Add the new element at the beginning of the list\n        temp_list.insert(0, new_element)\n        # Convert the list back to a tuple\n        new_tuple = tuple(temp_list)\n        return new_tuple\n    else:\n        raise TypeError(\"Incompatible types found\")", "def calculate_discrepancies(list1, list2):\n    # Check if both lists have the same length\n    if len(list1) != len(list2):\n        return 'Error: The lists do not have the same length.'\n    \n    discrepancies = []\n    for i in range(len(list1)):\n        # Check if the elements are numerical\n        if type(list1[i]) is not int or type(list2[i]) is not int:\n            return 'Error: The lists contain non-numerical values.'\n        \n        # calculate the discrepancy and add it to the list\n        discrepancies.append(abs(list1[i] - list2[i]))\n    \n    return discrepancies", "def check_data(data):\n    error = \"Data Error: {}\"\n    passed = True\n    if not data:\n        return False  # Validation 1: Check if the loaded data is a non-empty list\n    sublist_length = len(data[0])\n    for sublist in data:\n        if not isinstance(sublist, list) or not all(isinstance(x, int) for x in sublist):\n            return False  # Validation 2: Check if each element in the list is a list of integers\n        if len(sublist) != sublist_length:\n            return False  # Validation 3: Check if all the sublists have the same length\n    return True", "def pairwise_modulo(tuples1, tuples2):\n    \n    # Check if both inputs are lists\n    if not isinstance(tuples1, list) or not isinstance(tuples2, list):\n        return \"Error: Both inputs should be lists.\"\n        \n    # Check if both lists are of same length\n    if len(tuples1) != len(tuples2):\n        return \"Error: Both lists should be of same length.\"\n    \n    # Check if all elements of both lists are tuples of integers\n    for t in tuples1+tuples2:\n        if not isinstance(t, tuple):\n            return \"Error: All elements of input lists should be tuples.\"\n        if not all(isinstance(i, int) for i in t):\n            return \"Error: All elements of the tuples should be integers.\"\n    \n    result = []\n    \n    for pair1, pair2 in zip(tuples1, tuples2):\n        \n        # Check if both tuples are of same length\n        if len(pair1) != len(pair2):\n            return \"Error: Corresponding tuples should be of same length.\"\n        \n        temp = []\n        \n        for a, b in zip(pair1, pair2):\n            if b == 0:    # handle division by zero\n                return \"Error: Cannot perform modulo operation with denominator zero.\"\n            temp.append(a % b)  # add modulo result to temporary list\n            \n        result.append( tuple(temp) )    # add tuple to result\n    \n    return result", "def pairwise_modulo(tuples1, tuples2):\n    # Check if both inputs are lists\n    if not isinstance(tuples1, list) or not isinstance(tuples2, list):\n        return \"Error: Both inputs should be lists.\"\n\n    # Check if both lists are of same length\n    if len(tuples1) != len(tuples2):\n        return \"Error: Both lists should be of same length.\"\n        \n    # Check if all elements of both lists are tuples of integers\n    for t in tuples1+tuples2:\n        if not isinstance(t, tuple):\n            return \"Error: All elements of input lists should be tuples.\"\n        if not all(isinstance(i, int) for i in t):\n            return \"Error: All elements of the tuples should be integers.\"\n\n    result = []\n\n    for pair1, pair2 in zip(tuples1, tuples2):\n        # Check if both tuples are of same length\n        if len(pair1) != len(pair2):\n            return \"Error: Corresponding tuples should be of same length.\"\n\n        temp = []\n\n        for a, b in zip(pair1, pair2):\n            if b == 0:    # handle division by zero\n                return \"Error: Cannot perform modulo operation with denominator zero.\"\n            temp.append(a % b)  # add modulo result to temporary list\n\n        result.append( tuple(temp) )    # add tuple to result\n\n    return result"]}
{"task_id": 212, "content": ["def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def majority_element(arr):\n    '''This function takes an array and returns the majority element, if\n    exists. Otherwise, None is returned.\n    '''\n    # Create a dictionary to store the frequency of elements\n    elem_count = {}\n    for elem in arr:\n        if elem not in elem_count:\n            elem_count[elem] = 0\n        elem_count[elem] += 1\n    \n    # Loop through the dictionary to find the majority element\n    max_count = 0\n    majority_element = None\n    for elem, freq in elem_count.items():\n        if freq > max_count:\n            max_count = freq\n            majority_element = elem\n    return majority_element", "def map_func(func, arr):\n    \"\"\"\n    Apply the given function to each element of the array.\n\n    Args:\n        func (function): function to apply\n        arr (np.ndarray): input array\n\n    Returns:\n        np.ndarray: array of results after applying the function\n    \"\"\"\n    return np.array([func(x) for x in arr])", "def findCombinations(array, total):\n    \"\"\"\n    This function will find all possible combinations of integers in the given array that sum up to the given total.\n    Args:\n        array (list): List of integers.\n        total (int): Total to be reached with the combination of integers.\n    \n    Returns:\n        A list of lists containing the combinations of integers.\n    \"\"\"\n    combinations = []  # list to store the possible combinations\n    for i in range(1 << len(array)):  # loop through all combinations of bits\n        combination = []  # list to store the current combination\n        for j in range(len(array)):  # loop through array elements\n            if i & (1 << j):  # check if bit is set\n                combination.append(array[j])  # add array element to combination\n        if sum(combination) == total:  # check if combination sums to given total\n            combinations.append(combination)  # add combination to list of combinations\n\n    return combinations", "def diffArrays(A, B):\n    C = []  # Create an empty list to store the difference\n    for a in A:  # Iterate over elements in the first array\n        if a not in B:  # Check if the element is not present in the second array\n            C.append(a)  # Add the element to the difference list\n    for b in B:  # Iterate over elements in the second array\n        if b not in A:  # Check if the element is not present in the first array\n            C.append(b)  # Add the element to the difference list\n    return C  # Return the difference list"]}
{"task_id": 213, "content": ["def hamming_weight(byte):\n    # Implement this function to calculate the Hamming weight of a byte.\n    # The Hamming weight is the number of 1's in the byte.\n    # This can be done using a bitwise operation that counts the number of bits set to 1.\n    return bin(byte).count('1')", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def calculate_parity(n):\n    # Count the number of set bits using bitwise AND and right shift\n    count = 0\n    while n:\n        count ^= n & 1\n        n >>= 1\n\n    # Return 1 if the number of set bits is odd, 0 otherwise\n    return count", "def count_word(text, word):\n    '''This function will count the number of times a given word appears in a text.'''\n    return text.count(word)", "def add_two_numbers(a, b):\n    # Carry contains common set bits of a and b\n    while (b != 0):\n         \n        # carry now contains common\n        # set bits of a and b\n        carry = a & b\n \n        # Sum of bits of a and b where at\n        # least one of the bits is not set\n        a = a ^ b\n \n        # Carry is shifted by one so that\n        # adding it to a gives the required sum\n        b = carry << 1\n     \n    return a"]}
{"task_id": 214, "content": ["def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def has_recurring_elements(arr):\n    # initialize an empty Python set\n    element_set = set()\n\n    # iterate over each element in the array\n    for element in arr:\n        # if the element is already in the set, it is a recurring element\n        if element in element_set:\n            return True\n        # add the element to the set\n        element_set.add(element)\n\n    # if we go through the whole array and find no recurring elements\n    # then return False\n    return False", "def recursive_sort(lst, sorted_list=[]):\n    \"\"\"\n    Recursive function to sort the array\n    \"\"\"\n    # Base case: if the original list is empty, we're done\n    if len(lst) == 0:\n        return sorted_list\n    \n    # Find the minimum element and it's index in the list\n    min_value, min_index = find_minimum(lst)\n    \n    # Append the minimum element to the sorted list\n    sorted_list.append(min_value)\n    \n    # Remove the minimum element from the original list\n    lst.pop(min_index)\n    \n    # Recursively sort the rest of the list\n    return recursive_sort(lst, sorted_list)", "def selectionSort(array):\n    # Loop over the array\n    for i in range(len(array)-1):\n        # Find the minimum element\n        minimum = i\n        for j in range(i + 1, len(array)): \n            if array[minimum] > array[j]: \n                minimum = j          \n     \n        # Swap the found minimum element with \n        # the first element         \n        temp = array[i] \n        array[i] = array[minimum] \n        array[minimum] = temp ", "def sorted_list_sum(lst, reverse=False):\n    \"\"\"\n    This function takes as input a list of strings, removes any string that contains a numerical digit or \n    an odd number of characters, sorts remaining strings in ascending order by both length and alphabetically, \n    and then returns the sorted list.\n    \n    Achieves this by using list comprehension to filter out unwanted elements, \n    and Python's built-in sorted function to sort the list. The sorted function uses a compound sorting key \n    consisting of the length of each element and the element itself, allowing for sorting by multiple criteria.\n    \n    The ordering of the sorted list can be reversed by supplying a second argument of True.\n\n    Parameters:\n    lst (list): A list of strings to be filtered and sorted.\n    reverse (bool): Optional parameter to reverse the order of the sorted list. Defaults to False.\n\n    Returns:\n    list: The sorted list of strings.\n    \"\"\"\n    \n    # Filter out any strings containing numerical digits or with odd length\n    lst = [i for i in lst if not any(j.isdigit() for j in i) and len(i) % 2 == 0]\n    \n    # Return the list sorted by length and then alphabetically, in ascending or descending order\n    return sorted(lst, key=lambda x: (len(x), x), reverse=reverse)"]}
{"task_id": 215, "content": ["def find_pallindrome(characters):\n    \"\"\"\n    Generates a palindrome string with a set of given characters.\n    \n    Args:\n        characters (list): The set of characters from which to generate a palindrome string\n    \n    Returns:\n        string (str): A palindromic string generated from the given characters\n    \"\"\"\n    palindrome = ''\n    while len(characters) > 0:\n        # Append a character to the palindrome\n        char = characters.pop(0)\n        palindrome += char\n        \n        # Append the same character to the end of the string\n        palindrome += char\n    \n    return palindrome", "def remove_odd_index_char(string):\n    \"\"\"\n    Remove the characters of odd index in a given string\n    \"\"\"\n    result = \"\"\n    for i in range(len(string)):\n        if i % 2 == 0:\n            result = result + string[i]\n    return result", "def find_index_of_first_occurrence(string, character):\n    '''\n    This function will find the index of the first occurrence of a given character in a string.\n\n    Args:\n        string (str): the string to be searched\n        character (str): the character to be searched for\n\n    Returns:\n        int: the index of the first occurrence of the character\n    '''\n    return string.find(character)", "def character_at_index(s, idx):\n    \"\"\"\n    This function takes a string and an index and returns the character at the given index.\n\n    Parameters:\n    s (str): The string to be used\n    idx (int): The index of the character\n\n    Returns:\n    character at the given index (str)\n    \"\"\"\n\n    # return the character at the given index\n    return s[idx]", "def remove_odd_index_chars(s):\n    # Create a string of all punctuation marks\n    punctuations = string.punctuation\n    \n    # Initialize an empty string to store the modified string\n    modified_string = \"\"\n    \n    # Iterate over each character in the input string\n    for i, char in enumerate(s):\n        # Ignore punctuation marks\n        if char in punctuations:\n            continue\n        \n        # Remove characters with odd index values\n        if i % 2 == 0:\n            modified_string += char\n    \n    return modified_string"]}
{"task_id": 216, "content": ["def find_max(a, b, c):\n    \"\"\"\n    A function to find the maximum of three numbers.\n    \"\"\"\n    # Find the maximum of the three numbers\n    max_value = max(a, b, c)\n    \n    return max_value", "def find_min_three_elements(nums_list):\n    # Define a list to hold the minimum three values\n    min_values = []\n\n    # Iterate three times to find the three minimum elements\n    for _ in range(3):\n        # Initialize min_value with the first element of the list\n        min_value = nums_list[0]\n\n        # Iterate through the original list\n        for num in nums_list:\n            # If current number is less than min_value, update min_value\n            if num < min_value:\n                min_value = num\n\n        # Add the found minimum value to the min_values list\n        min_values.append(min_value)\n        \n        # Remove the minimum number from the original list to find the next minimum\n        nums_list.remove(min_value)\n    \n    # Return the list of minimum three elements\n    return min_values", "def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min", "def find_min(a, b, c):\n    \"\"\"Function which finds the minimum of three numbers\"\"\"\n    min_number = min(a, b, c)\n    return min_number", "def find_median(a, b, c):\n    # Calculate the sum of the three numbers\n    total = a + b + c\n    \n    # Find the minimum and maximum numbers\n    minimum = total - max(a, b, c)\n    maximum = total - min(a, b, c)\n    \n    # Calculate the median by subtracting the minimum and maximum from the total\n    median = total - minimum - maximum\n    \n    # Return the median\n    return median"]}
{"task_id": 217, "content": ["def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True", "def check_anagram_segments(text: str) -> bool:\n    \"\"\"\n    Given an input string, the function is intended to determine whether it is possible to \n    divide the string into two or more segments that are anagrams of one another. \n\n    Anagrams are words or phrases formed by reordering the letters of a different word or phrase, \n    typically using all the original letters exactly once.\n\n    The function counts the frequency of each unique character in the string and stores it in a dictionary. \n    If all frequencies are even number then the function returns True as the string can be divided into \n    two or more segments that are anagrams of one another. \n    \n    But if there is more than one character with an odd count frequency, then the function returns False\n    as it is not possible to divide the string into segments that are anagrams of one another. \n\n    Parameters:\n    text (str): The string to check for anagram segments\n\n    Returns:\n    bool: True if the string can be divided into anagram segments, False otherwise.\n\n    Examples:\n    \n    >>> check_anagram_samples('abcdefabcdegf')\n    True\n    >>> check_anagram_samples('helloworld')\n    False\n    \"\"\"\n\n    # count the frequency of each unique character in the string\n    frequency = {}\n    for char in text:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n\n    # count characters with odd count frequency\n    count_odd = sum(1 for count in frequency.values() if count % 2)\n\n    return count_odd <= 1", "def generate_canonical_smiles(molecule, isomeric, explicit_hydrogens, mapped, central_bond):\n    \"\"\"\n    Generate the canonical SMILES representation for the given molecule with specified options.\n\n    Args:\n    molecule: The input molecule object.\n    isomeric: A boolean indicating whether to include isomeric information in the SMILES.\n    explicit_hydrogens: A boolean indicating whether to include explicit hydrogen atoms in the SMILES.\n    mapped: A boolean indicating whether to include mapped atom information in the SMILES.\n    central_bond: A tuple representing the central bond to be set if certain conditions are met.\n\n    Returns:\n    A string representing the canonical SMILES for the given molecule with the specified options.\n    \"\"\"\n    if central_bond:\n        molecule.central_bond = central_bond\n\n    canonical_smiles = molecule.to_smiles(isomeric=isomeric, explicit_hydrogens=explicit_hydrogens, mapped=mapped)\n    return canonical_smiles", "def check_unique_strings(strings):\n    '''This function takes a list of strings and returns a boolean \n    indicating whether all the strings in the list are unique.'''\n    seen = set()\n    for string in strings:\n        if string in seen:\n            return False\n        seen.add(string)\n    return True", "def invert_integer(set_of_integers, integer):\n    if integer in set_of_integers:\n        # In Python, the ~ operator is the bitwise NOT operator, which inverts all the bits\n        inversion = ~integer\n        # Shift the bits right by 31 (recommended for 32-bit systems)\n        inversion = inversion & 0xFFFFFFFF\n        # Apply the bitwise NOT operation again to get the inverted integer in positive\n        inverted_integer = ~inversion & 0xFFFFFFFF\n        return inverted_integer\n    else:\n        return \"Integer does not exist in the set\""]}
{"task_id": 218, "content": ["def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers.", "def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list", "def reverse_array(arr):\n    \"\"\"This function reverses the elements of a given array of numbers\n    \n    Parameters: \n        arr (list): The list of numbers to reverse.\n\t\n    Returns: The reversed array\n    \"\"\"\n    return arr[::-1]", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def filter_odd(lst):\n    \"\"\"\n    Function to filter out the odd elements in a given list and return the even ones.\n\n    :param lst: A list of integers\n    :returns: A new list containing only even integers\n    \"\"\"\n    return [x for x in lst if x % 2 == 0]"]}
{"task_id": 219, "content": ["def arrange_string(s):\n    \"\"\"\n    This function takes a string 's', splits it into words, applies the custom_order function to each word to sort the characters in it,\n    and then rejoins the sorted words back together with a space in between. The function preserves the original order of words \n    and blank spaces in the sentence.\n    \"\"\"\n\n    # Split the string into a list of words\n    words_list = s.split(' ')\n\n    # Apply the custom_order function to each word in the list\n    ordered_words_list = [custom_order(word) for word in words_list]\n\n    # Join the ordered words back together with a space in between to form a string\n    ordered_s = ' '.join(ordered_words_list)\n\n    return ordered_s", "def anti_jumble(s):\n    \"\"\"\n    This function takes a string 's', splits it into words, applies the custom_order function to each word to sort the characters in it, \n    and then rejoins the sorted words back together with a space in between. The function preserves the original order of words \n    and blank spaces in the sentence.\n    \"\"\"\n\n    # Split the string into a list of words\n    words_list = s.split(' ')\n\n    # Apply the custom_order function to each word in the list\n    ordered_words_list = [custom_order(word) for word in words_list]\n\n    # Join the ordered words back together with a space in between to form a string\n    ordered_s = ' '.join(ordered_words_list)\n\n    return ordered_s", "def intricate_text_transformation(input_text):\n    \"\"\" \n    Given a string called input_text, the function carries out the transformations \n    including transforming text to uppercase, replacing blank spaces with underscores\n    and replacing two or more sequential spaces with a hyphen. \n    \"\"\"\n    input_text = input_text.replace(\" \", \"_\") # replacement of blank space with underscore\n    while \"__\" in input_text:\n        input_text = input_text.replace(\"__\", \"-\") # replacement of sequential underscores with a hyphen\n    return input_text.upper() # transforming all expressions to their uppercase equivalents", "def write_rfid_data(rfid_writer, data):\n    # This function would interface with an RFID writer to write RFID badge data.\n    # Writes the data to a blank RFID badge.\n    print(f\"Cloned RFID badge with data: {data}\")", "def anti_shuffle(s):\n    \"\"\"\n    Function that accepts a string and produces an ordered variant using the custom_sort function.\n    The ordered variant of a string is a new phrase where every word (partitioned by space) \n    is replaced by a new word where every character adheres to the custom_sort methodology.\n    The word and blank space sequence in the sentence remains unchanged.\n\n    Args: \n        s: string\n\n    Returns:\n        The modified string with each word sorted according to the rules of custom_sort\n    \"\"\"\n    \n    sorted_words = [custom_sort(word) for word in s.split(\" \")]\n    return ' '.join(sorted_words)"]}
{"task_id": 220, "content": ["def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def calculate_maximum(numbers):\n    \"\"\"\n    Find the maximum value in the given list of numbers.\n\n    :param numbers: List of numbers\n    :return: Maximum value\n    \"\"\"\n    return max(numbers)", "def sum_primes_in_range(start, end):\n    \"\"\"\n    Function to find the sum of all prime numbers within the given range.\n    \n    Parameters: \n    start (int): The start number of the range. \n    end (int): The end number of the range.\n    \n    Returns: \n    int: The sum of all prime numbers in the given range.\n    \"\"\"\n    result = 0\n    for n in range(start, end+1):\n        if is_prime(n):\n            result += n\n    return result", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]"]}
{"task_id": 221, "content": ["def load_dataset(task, name, test):\n    \"\"\"\n    Load a dataset based on the provided task and name, and write it to an H5AD file if test is True.\n\n    Args:\n    - task (str): The task to be performed on the dataset.\n    - name (str): The name of the dataset to be loaded.\n    - test (bool): A boolean flag indicating whether to write the dataset to an H5AD file.\n\n    Returns:\n    - adata: The loaded dataset.\n\n    Raises:\n    - ValueError: If the task is not recognized.\n    \"\"\"\n    # Implement dataset loading based on the task and name\n    if task == \"task1\":\n        # Load dataset for task1\n        adata = load_task1_dataset(name)\n    elif task == \"task2\":\n        # Load dataset for task2\n        adata = load_task2_dataset(name)\n    else:\n        raise ValueError(\"Unrecognized task: {}\".format(task))\n\n    # Write the dataset to an H5AD file if test is True\n    if test:\n        adata.write_h5ad(\"output_file.h5ad\")\n\n    return adata", "def get_most_expensive_items(dataset, n):\n    # Sorting the dataset by 'cost' in descending order (from highest to lowest)\n    sorted_dataset = sorted(dataset, key=lambda item: item['cost'], reverse=True)\n    # Returning the first n items\n    return sorted_dataset[:n]", "def get_most_expensive_items(dataset, n):\n    # sorting the dataset by 'cost' in descending order (from highest to lowest)\n    sorted_dataset = sorted(dataset, key=lambda item: item['cost'], reverse=True)\n    # returning first n items\n    return sorted_dataset[:n]", "def stratified_sample_dataset(dataset, sample_size, stratify_by):\n    \"\"\"\n    Stratified sampling function for a dataset.\n\n    Args:\n    - dataset: The dataset object to be sampled.\n    - sample_size: The size of the stratified sample to be returned.\n    - stratify_by: The variable or feature to stratify the sample by.\n\n    Returns:\n    - stratified_sample: A stratified sample of the dataset based on the specified parameters.\n    \"\"\"\n    # Implement the stratified sampling logic here\n    # Ensure that the function can handle various types of datasets and the CIFAR10 dataset\n\n    # Placeholder return for demonstration purposes\n    stratified_sample = dataset.sample(sample_size, stratify=stratify_by)\n    return stratified_sample", "def process_elevation_marker_views(items):\n    \"\"\"\n    Processes elevation marker views based on the input type.\n\n    Args:\n    items: A single item or a list of items.\n\n    Returns:\n    If the input is a list, returns a new list containing the results of applying the GetElevationMarkerView function to each item in the input list.\n    If the input is not a list, returns the result of applying the GetElevationMarkerView function to the single input item.\n    \"\"\"\n    if isinstance(items, list):\n        return [GetElevationMarkerView(x) for x in items]\n    else:\n        return GetElevationMarkerView(items)"]}
{"task_id": 222, "content": ["def find_surface_area(length, breadth, height):\n    '''\n    This function calculates the surface area of a cuboid.\n    Input: length, breadth, height - these are the three dimensions of the cuboid\n    Output: total surface area of the cuboid \n    '''\n    # Formula of Surface Area of Cuboid = 2(lb + bh + hl)\n    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area", "def find_surface_area(length, breadth, height):\n    '''\n    This function calculates the surface area of a cuboid.\n    Input: length, breadth, height - these are the three dimensions of the cuboid\n    Output: total surface area of the cuboid \n    '''\n    # Formula of Surface Area of Cuboid = 2(lb + bh + hl)\n    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area", "def frustum_surface_area(r1, r2, h):\n    \"\"\"\n    This function calculates the surface area of a frustum of a cone.\n\n    Arguments:\n    r1 : float : radius of the smaller base of the frustum\n    r2 : float : radius of the larger base of the frustum\n    h : float : height of the frustum\n\n    Returns:\n    float : surface area of the frustum\n    \"\"\"\n\n    # Checking if the input parameters are valid\n    if r1 < 0 or r2 < 0 or h < 0:\n        raise ValueError('All parameters must be non-negative.')\n\n    area = math.pi * (r1 + r2) * math.sqrt((r2 - r1)**2 + h**2) + math.pi * (r1**2 + r2**2)\n    return area", "def polygon_area(coordinates):\n    \"\"\"\n    Given pairs of x,y coordinates as inputs, calculate the surface area of the resulting polygon.\n    This function computes areas of complex, non-rectangular polygons.\n\n    In order to calculate, it uses Gauss's Area formula (also called Shoelace Theorem):\n    https://en.wikipedia.org/wiki/Shoelace_formula\n\n    This formula calculates the signed area. If the coordinates are covered in a counterclockwise direction,\n    the signed area is positive, if clockwise, the signed area is negative. The abs function cares about the absolute value.\n    \"\"\"\n\n    area = 0.0\n    for i in range(len(coordinates)):\n        x1, y1 = coordinates[i]\n        x2, y2 = coordinates[(i+1) % len(coordinates)]  # cyclically next vertex\n        area += x1*y2 - x2*y1\n    return abs(area)/2", "def frustum_surface_area(r1, r2, l, e=False, a1=None, a2=None, b1=None, b2=None):\n    \"\"\"\n    Function to calculate lateral surface area of a frustum.\n\n    Parameters:\n    r1, r2 : radii of the two distinct circular bases of the frustum\n    l : slant height of the frustum\n    e : flag to indicate if frustum is elliptical (default is False)\n    a1, a2: semi-major axes of the two distinct elliptical bases (required if e is True)\n    b1, b2 : semi-minor axes of the two distinct elliptical bases (required if e is True)\n\n    Returns:\n    lateral surface area of the frustum\n    \"\"\"\n\n    # Error checking for invalid inputs\n    if not all(i > 0 for i in [r1, r2, l]):\n        raise ValueError(\"Radii and slant height must be positive.\")\n    if e and not all(i > 0 for i in [a1, a2, b1, b2]):\n        raise ValueError(\"Semi-axes and slant height must be positive for an elliptical frustum.\")\n\n    if e:\n        h = math.sqrt((a1 - a2) ** 2 + (b1 - b2) ** 2)\n        return math.pi * (r1 * l + r2 * l)\n    else:\n        return math.pi * (r1 + r2) * l"]}
{"task_id": 223, "content": ["def calculate_cube_volume(length):\n    \"\"\"Calculate the volume of a cube.\n    \n    Args:\n        length (float): The length of a side of the cube.\n        \n    Returns:\n        float: The volume of the cube.\n    \"\"\"\n    volume = length ** 3\n    return volume", "def cube_volume(a):\n    \"\"\"Calculate the volume of a cube\n    Args:\n        a (float): length of a side of the cube\n    Returns:\n        Volume of the cube (float)\n    \"\"\"\n    return a**3", "def solve_cube(cube):\n    # Main function that solves a Rubik's cube\n    # cube: list representing a Rubik's cube\n\n    # Determine cube state by analyzing the cube[i][j][k] values\n    scramble_state = analyze_cube(cube)\n\n    # Find the sequence of moves required to solve the cube[i][j][k]\n    moves = get_solve_moves(scramble_state)\n\n    # Execute moves to solve the cube[i][j][k]\n    execute_moves(cube, moves)", "def cube_volume(side):\n    # calculate the volume of a cube\n    return side**3", "def custom_multiply(*args):\n    # Implement custom mathematical function to calculate volume of cube\n    result = 1\n    for arg in args:\n        result *= arg\n    return result"]}
{"task_id": 224, "content": ["def hamming_weight(byte):\n    # Implement this function to calculate the Hamming weight of a byte.\n    # The Hamming weight is the number of 1's in the byte.\n    # This can be done using a bitwise operation that counts the number of bits set to 1.\n    return bin(byte).count('1')", "def add_digits(number):\n    \"\"\"This function adds all the digits of a given number \n    and returns the result.\n    \n    Args:\n        number (int): The number to process.\n    \n    Returns:\n        int: The result of adding all the digits of the given number.\n    \"\"\"\n    if number < 10:\n        return number\n    total = number % 10 + add_digits(number // 10)\n    return total", "def calculate_sum_positive_even_numbers(numbers):\n    \"\"\"\n    Calculates the sum of all positive even numbers from a given list.\n    \n    Args:\n    numbers (list): The list of numbers.\n    \n    Returns:\n    int: The sum of all positive even numbers.\n    \n    Raises:\n    ValueError: If the input list contains non-integer elements.\n    \n    \"\"\"\n    \n    # Validate the input list\n    for num in numbers:\n        if not isinstance(num, int):\n            raise ValueError(\"Input list should only contain integers.\")\n    \n    # Initialize sum variable\n    sum = 0\n    \n    # Create a set to store unique even numbers\n    unique_evens = set()\n    \n    # Iterate through the list\n    for num in numbers:\n        # Check if the number is positive and even\n        if num > 0 and num % 2 == 0:\n            # Add the number to the set of unique even numbers\n            unique_evens.add(num)\n    \n    # Calculate the sum of unique even numbers\n    for even_num in unique_evens:\n        sum += even_num\n    \n    return sum", "def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]", "def check_integer(number):\n    if number % 2 == 0:\n        if number % 3 == 0:\n            print(\"The given integer is even and a multiple of 3.\")\n        else:\n            print(\"The given integer is even and not a multiple of 3.\")\n    else:\n        if number % 3 == 0:\n            print(\"The given integer is odd and a multiple of 3.\")\n        else:\n            print(\"The given integer is odd and not a multiple of 3.\")"]}
{"task_id": 225, "content": ["def decode_equilateral_triangle_height(side_length):\n    \"\"\" \n    Decodes the height of an equilateral triangle.\n    \n    :param side_length: The length of a side of the equilateral triangle in cm.\n    \"\"\"\n  \n    try:\n        # validating if input is a number\n        side_length = float(side_length)\n    except ValueError:\n        raise ValueError('You must enter a numeric input.')\n\n    # If the input is a negative number or zero\n    if side_length <= 0:\n        raise ValueError('The length of the side should be a positive number.')\n   \n    # Implementing formula to calculate height of an equilateral triangle\n    # Here, the value of a in the formula a^2 + b^2 = c^2, will be side_length/2\n    # And the value of c will be side_length, so we are left to solve for b\n    # b = sqrt(c^2 - a^2)\n    height = math.sqrt((side_length**2) - ((side_length/2)**2))\n    return height", "def validate_triangle(a, b, c):\n    # Check if values are positive\n    if a <= 0 or b <= 0 or c <= 0:\n        return \"Invalid triangle\"\n    \n    # Check if triangle can be formed\n    if a + b > c and b + c > a and a + c > b:\n        if a == b == c:\n            return \"Equilateral triangle\"\n        elif a != b != c != a:\n            return \"Scalene triangle\"\n        else:\n            return \"Isosceles triangle\"\n    else:\n        return \"Invalid triangle\"", "def get_triangle(radius):\n    # The largest inscribed triangle in a semicircle is equilateral triangle.\n    # The length of the triangle's side equals the semicircle's diameter.\n\n    # Hence, the coordinates of the vertices of the triangle are:\n    a = (-radius, 0)\n    b = (radius, 0)\n    c = (0, radius)\n\n    # The area of an equilateral triangle is computed using the formula: (s^2 * sqrt(3)) / 4\n    # where s is the side length of the triangle. \n    # The side length of our triangle is twice the radius (which is the diameter of the semicircle).\n    area = ((2*radius)**2 * math.sqrt(3)) / 4\n    \n    # The perimeter of an equilateral triangle is 3 times its side.\n    # The side length of our triangle is twice the radius (which is the diameter of the semicircle).\n    perimeter = 3 * (2*radius)\n\n    return area, a, b, c, perimeter", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def triangleType(a, b, c):\n  # First, let's check if the sides form a valid triangle\n  if (a + b <= c) or (a + c <= b) or (b + c <= a):\n    return \"Not a valid triangle\"\n\n  # Next, we'll check if all sides are equal, indicating an equilateral triangle\n  if a == b and b == c:\n    return \"Equilateral triangle\"\n\n  # If all sides are different lengths, it's a scalene triangle\n  if (a != b) and (b != c) and (a != c):\n    return \"Scalene triangle\"\n\n  # If it's not equilateral or scalene, it must be an isosceles triangle\n  return \"Isosceles triangle\""]}
{"task_id": 226, "content": ["def match_text(text, search_string):\n    \"\"\"Returns all occurrences of substring in the given string with case and pattern insensitivity.\n\n    Args:\n    text (str): A string.\n    search_string (str): The substring for which to search.\n\n    Returns:\n    A list of all occurrences in the given string.\n    \"\"\"\n    matches = []\n    # Construct a case and pattern insensitive regex expression\n    search_string = re.compile(search_string, re.IGNORECASE)\n    # Search the string and add the matches to a list\n    for match in search_string.finditer(text):\n        matches.append(match.group(0))\n\n    return matches", "def count_word(text, word):\n    '''This function will count the number of times a given word appears in a text.'''\n    return text.count(word)", "def get_random_odd_occurrence(string, max_occurrences):\n    # Count the occurrences of each uppercase letter in the string\n    occurrences = Counter(filter(str.isupper, string))\n    \n    # Filter the letters that occur an odd number of times up to the maximum occurrences\n    odd_occurrences = [letter for letter, count in occurrences.items() if count % 2 != 0 and count <= max_occurrences]\n    \n    if not odd_occurrences:\n        return None\n    \n    # Find the letter with the fewest occurrences among the odd occurrences\n    min_occurrence = min(occurrences[letter] for letter in odd_occurrences)\n    \n    # Filter the letters with the fewest occurrences\n    min_occurrence_letters = [letter for letter in odd_occurrences if occurrences[letter] == min_occurrence]\n    \n    # Return a random letter from the letters with the fewest occurrences\n    return random.choice(min_occurrence_letters)", "def count_characters(string):\n    # Store the occurrences of each character\n    occur = {}\n    \n    # Loop through each character\n    for c in string:\n        # If c is not a key in occur, set it to 0\n        if c not in occur:\n            occur[c] = 0\n        # Increment its value by 1\n        occur[c] += 1\n    \n    return occur", "def find_vect(lst3d, x, y):\n    \"\"\"\n    This function takes in a 3D list (lst3d) along with two integers (x and y).\n    It then searches for occurrences of x and y at consecutive indices in the 3D list.\n    For every occurrence, it records the depth, row, and index in a tuple, all occurrences \n    are stored in the results list which is then returned.\n    \"\"\"\n    result = []  # this would hold tuples of depth, row and index\n\n    # We use enumerate to get both index and value as we iterate through the lists\n    for depth, lst2d in enumerate(lst3d):\n        for row, lst1d in enumerate(lst2d):\n            # We only loop till len(lst1d) - 1 because we check lst1d[index + 1] in the loop\n            for index in range(len(lst1d) - 1):\n                if lst1d[index] == x and lst1d[index + 1] == y:\n                    # Record depth, row, index where x and y are found consecutively\n                    result.append((depth, row, index))\n\n    # result is automatically sorted as it's inserted in ascending order due to the sequence \n    # of traversal. We don't require a sort method like in C++.\n\n    return result"]}
{"task_id": 227, "content": ["def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def count_word(text, word):\n    '''This function will count the number of times a given word appears in a text.'''\n    return text.count(word)", "def parse_string(pattern, string):\n    '''\n    This function parses a string and returns the substrings which are enclosed in the given pattern.\n    \n    Parameters\n    ----------\n    pattern : str\n        The given pattern\n    string : str\n        The given string\n    \n    Returns\n    -------\n    List\n        Contains substrings enclosed within the given pattern.\n    '''\n    # Initialize list to store substrings\n    sub_strings = []\n    \n    # Get the start and end positions of each substring\n    start = string.find(pattern)\n    end = string.find(pattern, start+1)\n    \n    # Iterate through the string\n    while start >= 0 and end > start:\n        # Get substring and append to list\n        sub_strings.append(string[start+len(pattern):end])\n        \n        # Get new start and end positions\n        start = end\n        end = string.find(pattern, start+1)\n    \n    # Return list of substrings\n    return sub_strings", "def vowel_count(string):\n    \"\"\"Get the vowels count in a given string.\n\n    Parameters\n    ----------\n    string : str\n        The string whose vowels count is to be computed.\n\n    Returns\n    -------\n    int\n        Number of vowels in the given string.\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n    for char in string:\n        if char in vowels:\n            count += 1\n    return count", "def find_substrings_with_k_distinct_chars(string: str, k: int) -> List[Tuple[str, int]]:\n    \"\"\"\n    Find all substrings of a given string that have exactly k distinct \n    characters, and sort these substrings alphabetically.\n    Also, count the number of vowels in each substring.\n    \"\"\"\n\n    substrings = []\n    vowels = \"aeiouAEIOU\"\n    for i in range(len(string)):\n        for j in range(i + k, len(string) + 1):\n            substring = string[i:j]\n            if len(set(substring)) == k:\n                \n                # count the number of vowels\n                vowel_count = len([char for char in substring if char in vowels])\n                substrings.append((substring, vowel_count))\n\n    # sort by substring alphabetically\n    substrings.sort(key=lambda x: x[0])\n\n    return substrings"]}
{"task_id": 228, "content": ["def find_kth_largest(arr, k):\n    \"\"\"\n    Function to find the kth largest element in an array\n    \"\"\"\n    \n    # make a copy of the array\n    arr_copy = arr[:]\n    \n    # get the length of the array\n    length = len(arr_copy)\n    \n    # if k is greater than or equal to the length of the array, return the maximum element\n    if k >= length:\n        return max(arr_copy)\n        \n    # sort the array in descending order\n    arr_copy.sort(reverse=True)\n    \n    # get the kth element from the sorted array\n    kth_largest = arr_copy[k-1]\n    \n    return kth_largest", "def choose_num(x, y, z):\n    \"\"\"This function should take three positive numbers x, y, and z. The function must return \n    the largest even integer number that is less than or equal to y and greater than or equal \n    to x, which is also a multiple of z. In case no such number exists, the function should return None.\n    \n    Validate your code with the added complexity of handling potential exceptions.\n    \"\"\"  \n    if not (type(x) == type(y) == type(z) == int):\n        return \"Error: Inputs must be integers.\"\n\n    if not (x >= 0 and y >= 0 and z >= 0):\n        return \"Error: Inputs must be positive.\"\n\n    if x > y:\n        return \"Error: x should be less than or equal to y.\"\n\n    #Initialize the largest number as None.\n    largest_num = None\n    \n    #Iterate from y to x both inclusive to find largest even multiple of z.\n    for i in range(y, x - 1, -1):\n        if i % z == 0 and i % 2 == 0:\n            largest_num = i\n            break\n        \n    #Return the largest number.\n    return largest_num", "def extract_integer(number: float) -> int:\n    \"\"\"\n    A floating-point number can be bifurcated into an integer part (the largest integer no greater\n    than the input number) and a fraction part (the residual fragment, persistently less than 1 \n    but more than -1). \n\n    Architect this function in such a way that it unravels the integer sector of a number, whether \n    it is positive or negative.\n    \"\"\"\n    return math.floor(number)", "def extract_integer(number: float) -> int:\n    \"\"\"\n    A floating-point number can be bifurcated into an integer part (the largest integer no greater\n    than the input number) and a fraction part (the residual fragment, persistently less than 1 \n    but more than -1). \n\n    Architect this function in such a way that it unravels the integer sector of a number, whether \n    it is positive or negative.\n    \"\"\"\n    return math.floor(number)", "def lengthy_text(arr, k, ignore_list):\n  # Create a list of words to ignore\n  ignore_list = set(ignore_list)\n\n  # Remove the words in ignore_list from each element in arr\n  arr_ignoring = [''.join(word for word in text.split() if word.lower() not in ignore_list) for text in arr]\n\n  # Create a list of tuples with each tuple contains (element, length of element) format\n  arr_len = [(text, len(text)) for text in arr_ignoring]\n\n  # Sort the list of tuples based on the length of each element\n  arr_len.sort(key=lambda x: x[1])\n\n  # Look for the text have number of characters exactly equal to k or next highest number of characters but less than k\n  text_result = [text for text, length in reversed(arr_len) if length <= k]\n\n  # If found any, return the most lengthy text, otherwise return None.\n  return text_result[0] if text_result else None"]}
{"task_id": 229, "content": ["def substitute_entity(array, target, replacement):\n    \"\"\"\n    Function to replace a specific element in an array\n\n    Arguments:\n    array : a list of elements\n    target : element to replace\n    replacement : new element to substitute the target with\n\n    Returns:\n    new_array : new list with the target element replaced by the replacement\n    \"\"\"\n    \n    # Create an empty list to store the updated elements\n    new_array = []\n\n    # Go through each element in the original list\n    for element in array:\n\n        # If the element is the target,\n        # add the replacement to the new list\n        if element == target:\n            new_array.append(replacement)\n        \n        # If the element is not the target,\n        # add the original element to the new list\n        else:\n            new_array.append(element)\n\n    return new_array", "def substitute_entity(array, target, replacement):\n    \"\"\"\n    Function to replace a specific element in an array\n\n    Arguments:\n    array : a list of elements\n    target : element to replace\n    replacement : new element to substitute the target with\n\n    Returns:\n    new_array : new list with the target element replaced by the replacement\n    \"\"\"\n    \n    # Create an empty list to store the updated elements\n    new_array = []\n\n    # Go through each element in the original list\n    for element in array:\n\n        # If the element is the target,\n        # add the replacement to the new list\n        if element == target:\n            new_array.append(replacement)\n        \n        # If the element is not the target,\n        # add the original element to the new list\n        else:\n            new_array.append(element)\n\n    return new_array", "def transpose_list(lst):\n    \"\"\"\n    This function takes a list as input and transposes all of its elements by\n    one position to the left, maintaining the order of neighboring elements.\n    The last element of the list becomes the first one.\n    \"\"\"\n    if not lst:  # if the list is empty, return it as is\n        return lst\n    last_element = lst.pop()  # remove the last element\n    lst.insert(0, last_element)  # add the removed last element at the first position\n    return lst", "def apply_function(arr, f):\n    \"\"\"\n    Apply a given function to each item of an input array.\n    \n    Args:\n        arr (list): The input array.\n        f (function): The function to be applied.\n        \n    Returns:\n        list: A list with the result of applying function f to each item of arr.\n    \"\"\"\n    return list(map(f, arr))", "def last_element(list):\n    \"\"\"Find the last element of a given list.\"\"\"\n    return list[-1]"]}
{"task_id": 230, "content": ["def generate_payload():\n    \"\"\"Generate a benign payload that writes a file to the disk with a unique name.\"\"\"\n    filename = generate_unique_filename()\n    payload = f\"\"\"\nimport os\n\n# Payload to write a file to the disk with a unique name\ndef write_file(filename):\n    with open(filename, 'w') as f:\n        f.write('This is a test file.')\n\n# Call the payload function\nwrite_file('{filename}')\n\"\"\"\n    return payload", "def sort_3d_array(arr):\n    \"\"\"Sorts a 3d array based on the third element in each sub-array.\"\"\"\n\n    # Error handling for arrays that don't have a third element\n    try:\n        return sorted(arr, key=lambda x: x[2])\n    except IndexError:\n        print(\"One or more elements in the array do not have a third element.\")", "def sort_3d_array(arr):\n    \"\"\"Sorts a 3d array based on the third element in each sub-array.\"\"\"\n\n    # Error handling for arrays that don't have a third element\n    try:\n        return sorted(arr, key=lambda x: x[2])\n    except IndexError:\n        print(\"One or more elements in the array do not have a third element.\")", "def view_assembly(assembly, surface) -> str:\n    # Simulate the 3D rendering and visualization process to generate the view representation\n    # Code to project the 3D assembly onto the specified surface and generate a 2D representation\n    # Return the 2D representation as a string\n    return \"2D representation of the assembly as viewed from the specified surface\"", "def cube_root_sum(matrix):\n    '''Calculate the cube root sum of each 2D array in a 3D matrix'''\n    \n    import numpy as np\n    \n    # Initialize an empty list to save the results\n    result = []\n\n    # Iterate over each 2D array in the 3D matrix\n    for twoD in matrix:\n        # Calculate the sum and take the cube root\n        cube_root_sum = np.cbrt(np.sum(twoD))\n        # Append the cube root sum to the result list\n        result.append(cube_root_sum)\n    \n    return result"]}
{"task_id": 231, "content": ["def count_chars(string):\n    \"\"\"Function to count characters in a given string\"\"\"\n    count = 0\n\n    # Loop through each character\n    for char in string:\n        count += 1\n\n    # Return the count\n    return count", "def common_chars(str1, str2): \n    \n    # convert strings to set to get unique \n    # characters from each string \n    set1 = set(str1) \n    set2 = set(str2) \n  \n    # using set intersection property to \n    # get common characters \n    common = list(set1 & set2) \n  \n    # using sum and min function to count \n    # total number of common characters  \n    # present in both string \n    total = sum(min(str1.count(char), str2.count(char))  \n                for char in common)\n    \n    return total", "def reverse_string(string):\n  '''\n  This function takes in a string and returns the string in reverse order.\n  \n  The algorithm works by iterating over the characters in the string in reverse, creating a new string with the reverse order of characters.\n  \n  :param string: string to be reversed\n  :return: string in reverse order\n  '''\n  \n  # Create a new, empty string to store the reversed string\n  reversed_string = \"\"\n  \n  # Iterate over the characters in the string in reverse order\n  for i in range(len(string)-1, -1, -1):\n    reversed_string += string[i]\n  \n  # Return the reversed string\n  return reversed_string", "def count_characters(string):\n    \"\"\"\n    Function to count the occurrences of characters\n    in a string\n    \"\"\" \n    count_dict = {}\n    for char in string:\n        count_dict[char] = count_dict.get(char, 0) + 1\n    \n    return count_dict", "def can_form_palindrome(string):\n    # Create a count array to store count of characters\n    count_map = [0]*256  # Assuming ASCII characters\n \n    # Traverse through given string and increment\n    # count of characters in count_map.\n    for char in string:\n        count_map[ord(char)] += 1\n \n    # Count odd occurring characters\n    odd_count = 0\n    for count in count_map:\n        if count % 2 != 0:\n            odd_count += 1\n    \n    # Return true if the count of odd occurrences is less than or equal to 1.\n    return odd_count <= 1"]}
{"task_id": 232, "content": ["def find_first_occurrence(lst, el):\n    \"\"\"\n    Function to return the index of the first occurrence of a given element.\n    \n    Args:\n        lst (list): list of integers\n        el (int): integer element\n        \n    Returns:\n        int: index of the first occurrence of el\n    \"\"\"\n    try:\n        return lst.index(el)\n    except ValueError:\n        return -1", "def sort_list_tuples(tuples):\n    # Sort the list of tuples based on the second element\n    return sorted(tuples, key=lambda x: x[1])", "def sort_by_word_length(word_list):\n    \"\"\"\n    Function to sort a given list of strings \n    based on the length of the words in ascending order.\n    @param word_list: list\n    @return: list\n    \"\"\"\n    return sorted(word_list, key=lambda x: len(x))", "def find_index_of_first_occurrence(string, character):\n    '''\n    This function will find the index of the first occurrence of a given character in a string.\n\n    Args:\n        string (str): the string to be searched\n        character (str): the character to be searched for\n\n    Returns:\n        int: the index of the first occurrence of the character\n    '''\n    return string.find(character)", "def process_words(words):\n    \"\"\"\n    This function takes a list of strings as input and sorts the strings based on their lengths in ascending order.\n    \n    Input:\n    - words: A list of strings\n    \n    Output:\n    - A list of strings after sorting based on their lengths in ascending order\n    \"\"\"\n    words.sort(key=len)  # Sort the list of strings based on their lengths\n    return words"]}
{"task_id": 233, "content": ["def proper_code(*args):\n    \"\"\"\n    Given single or multiple positive integers, check if any of them is a perfect square.\n    If at least one is a perfect square, create and test a function that returns the number of n-digit positive integers that start or end with 1.\n    Also, these numbers must be divisible by any three distinct prime numbers.\n    Return 'Not a perfect square.' if none of them is a perfect square.\n    \"\"\"\n    # Find first three prime numbers\n    primes = list(sympy.primerange(0,100))[:3]\n    for i in args:\n        if is_perfect_square(i):\n            # n is taken as the number of digits in the first perfect square found\n            n = len(str(i))\n            return num_start_end_with_1(n, primes)\n    return 'Not a perfect square.'", "def proper_code(*args):\n    \"\"\"\n    Given single or multiple positive integers, check if any of them is a perfect square. \n    If at least one is a perfect square, create and test a function that returns the number of n-digit positive integers that start or end with 1. \n    Also, these numbers must be divisible by any three distinct prime numbers. \n    Return 'Not a perfect square.' if none of them is a perfect square.\n    \"\"\"\n    # Find first three prime numbers\n    primes = list(sympy.primerange(0, 100))[:3]\n    for i in args:\n        if is_perfect_square(i):\n            # n is taken as the number of digits in the first perfect square found\n            n = len(str(i))\n            return num_start_end_with_1(n, primes)\n    return 'Not a perfect square.'", "def is_perfect_square(num):\n    \"\"\"\n    This function checks if a number is a perfect square.\n    \n    Args:\n    num(int): input number\n\n    Returns:\n    str: an appropriate message for perfect square, float or negative number.\n    \n    \"\"\"\n\n    # Input Validation\n    if num < 0:\n        return \"Negative numbers cannot be perfect squares.\"\n    elif isinstance(num, float):\n        return \"Floating point numbers cannot be perfect squares.\"\n\n    # Perfect square check\n    root = num ** 0.5\n    if int(root + 0.5) ** 2 == num:\n        return \"The number is a perfect square.\"\n    else:\n        return \"The number is not a perfect square.\"", "def is_perfect_square(num):\n    \"\"\"\n    This function checks if a number is a perfect square.\n    \n    Args:\n    num(int): input number\n\n    Returns:\n    str: an appropriate message for perfect square, float, or negative number.\n    \n    \"\"\"\n\n    # Input Validation\n    if num < 0:\n        return \"Negative numbers cannot be perfect squares.\"\n    elif isinstance(num, float):\n        return \"Floating point numbers cannot be perfect squares.\"\n\n    # Perfect square check\n    root = num ** 0.5\n    if int(root + 0.5) ** 2 == num:\n        return \"The number is a perfect square.\"\n    else:\n        return \"The number is not a perfect square.\"", "def check_perfect_square(n):\n    root = math.sqrt(n)\n\n    if int(root + 0.5) ** 2 == n:\n        if is_prime(root):\n            return \"The number is a perfect square and its square root is a prime number.\"\n        else:\n            return \"The number is a perfect square but its square root is not a prime number.\"\n    else:\n        return \"The number is not a perfect square.\""]}
{"task_id": 234, "content": ["def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def max_sum_subarray(array):\n    \"\"\"\n    This function will find the maximum sum of a contiguous subarray.\n    \n    Parameters:\n    array: list of integers\n    \n    Returns:\n    maximum sum of contiguuous subarray\n    \"\"\"\n    # Initialize the max sum and current sum to the start of the array\n    max_sum = current_sum = array[0]\n    \n    # Iterate over the array\n    for num in array[1:]:\n        # Reset the current sum to 0 if it is negative\n        current_sum = max(0, current_sum + num)\n        max_sum = max(current_sum, max_sum)\n    \n    return max_sum", "def longestIncreasingSubsequence(arr):\n    \"\"\"Function to find the longest increasing subsequence in a given array\"\"\"\n    n = len(arr)\n    # initialize the dp array \n    dp = [1] * n \n  \n    # Loop through the given array and compute \n    # other entries in the dp array \n    for i in range (1, n): \n        for j in range(i): \n            if (arr[i] > arr[j] and dp[i] < dp[j] + 1):\n                dp[i] = dp[j] + 1\n\n    # Find the maximum entry in the dp array\n    maximum = 0\n    for i in range(n): \n        if (maximum < dp[i]): \n            maximum = dp[i] \n\n    # return the longest increasing subsequence\n    return maximum", "def findCombinations(array, total):\n    \"\"\"\n    This function will find all possible combinations of integers in the given array that sum up to the given total.\n    Args:\n        array (list): List of integers.\n        total (int): Total to be reached with the combination of integers.\n    \n    Returns:\n        A list of lists containing the combinations of integers.\n    \"\"\"\n    combinations = []  # list to store the possible combinations\n    for i in range(1 << len(array)):  # loop through all combinations of bits\n        combination = []  # list to store the current combination\n        for j in range(len(array)):  # loop through array elements\n            if i & (1 << j):  # check if bit is set\n                combination.append(array[j])  # add array element to combination\n        if sum(combination) == total:  # check if combination sums to given total\n            combinations.append(combination)  # add combination to list of combinations\n\n    return combinations", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count"]}
{"task_id": 235, "content": ["def EncryptData(data):\n    # This function would encrypt the data using a secure encryption method.\n    # The actual implementation details are not provided here.\n    # For example, using a symmetric encryption algorithm like AES.\n    pass", "def create_V_matrix(plda_psi, dim):\n    # Extract the square roots of the first dim elements from plda_psi\n    sqrt_elements = np.sqrt(plda_psi[:dim])\n\n    # Create a diagonal matrix V using the extracted square roots\n    V = np.diag(sqrt_elements)\n\n    return V", "def solveQuadratic(a, b, c):\n    \"\"\"\n    Function to solve for the roots of a quadratic equation\n    Arguments:\n    a, b, c -- float -- coefficients of the equation\n    Output:\n    roots -- tuple -- all possible roots of the equation\n    \"\"\"\n    # computing discriminant \n    d = (b**2) - (4*a*c)\n\n    # two families of solutions \n    # b2-d = 0 \n    if d == 0:\n        root1 = (-b + math.sqrt(d)) / (2*a)\n        roots = (root1,)*2\n    # b2-d is greater than 0\n    else:\n        root1 = (-b + math.sqrt(d)) / (2*a)\n        root2 = (-b - math.sqrt(d)) / (2*a)\n        roots = (root1, root2)\n    return roots", "def compile_core(compiler, scientific_library):\n    \"\"\"\n    Compiles the specified scientific computing library using the given compiler.\n    \n    Args:\n    compiler: A string representing the compiler to be used for compilation.\n    scientific_library: A string representing the scientific computing library to be compiled.\n    \n    Returns:\n    None\n    \"\"\"\n    subprocess.call([\"make\", \"pawpy_\" + compiler])", "def sqrt(number): \n    # Initialize the square root \n    # of the given number \n    sqrt = number / 2\n  \n    # Use the Babylonian algorithm \n    # for calculating the square root \n    # of the given number \n    temp = 0\n    while(sqrt != temp): \n        temp = sqrt \n        sqrt = ( number/temp + temp) / 2\n  \n    return sqrt"]}
{"task_id": 236, "content": ["def longest_palindromic_substring(s):\n    \"\"\"\n    Finds the longest palindromic substring of a given string.\n    \n    Args:\n        s: The given string.\n        \n    Returns:\n        The longest palindromic substring.\n    \"\"\"\n    \n    # Initialize the variables\n    longest_length = 0\n    longest_start = 0\n    longest_end = 0\n    \n    # Compute the Longest Palindromic Substring matrix\n    for i in range(len(s)):\n        for j in range(len(s)):\n            width = j - i + 1\n            if width > longest_length and s[i:i + width] == s[j:j - width:-1]:\n                longest_length = width\n                longest_start = i\n                longest_end = i + width\n    \n    # Compute the Longest Palindromic Substring\n    longest_substring = s[longest_start:longest_end]\n    \n    return longest_substring", "def longestIncreasingSubsequence(arr):\n    \"\"\"Function to find the longest increasing subsequence in a given array\"\"\"\n    n = len(arr)\n    # initialize the dp array \n    dp = [1] * n \n  \n    # Loop through the given array and compute \n    # other entries in the dp array \n    for i in range (1, n): \n        for j in range(i): \n            if (arr[i] > arr[j] and dp[i] < dp[j] + 1):\n                dp[i] = dp[j] + 1\n\n    # Find the maximum entry in the dp array\n    maximum = 0\n    for i in range(n): \n        if (maximum < dp[i]): \n            maximum = dp[i] \n\n    # return the longest increasing subsequence\n    return maximum", "def find_longest_subsequence(lst):\n    longest = []  # Initialize an empty list to store the longest subsequence\n    current = [lst[0]]  # Start with the first number in the list as the current subsequence\n\n    for n in lst[1:]:\n        if n == current[-1] + 1:\n            current.append(n)  # If the current number is consecutive to the previous number, add it to the current subsequence\n        else:\n            if len(current) > len(longest):\n                longest = current[:]  # If the current subsequence is longer than the previously found longest subsequence, update the longest subsequence\n            current = [n]  # Start a new subsequence with the current number\n\n    if len(current) > len(longest):\n        longest = current[:]  # Check if the last subsequence is longer than the previously found longest subsequence\n\n    return longest", "def longest_increasing_subseq(seq):\n    n = len(seq)\n    \n    # length[i] will hold the length of the longest increasing subsequence \n    # ending at index i. Initially, this is 1 for all i, as every \n    # element is itself a valid subsequence.\n    length = [1]*n\n    \n    # previous[i] will hold the index of the predecessor of seq[i] \n    # in the longest increasing subsequence ending at index i.\n    previous = [None]*n\n    \n    # Find the length of the longest increasing subsequence.\n    for i in range(1, n):\n        for j in range(i):\n            if seq[i] > seq[j] and length[i] < length[j] + 1:\n                length[i] = length[j] + 1\n                previous[i] = j\n    \n    # Find the index i of the last element of the longest increasing subsequence.\n    max_len = max(length)\n    i = length.index(max_len)\n    \n    # Reconstruct the longest increasing subsequence in reverse order.\n    subseq = []\n    while i is not None:\n        subseq.append(seq[i])\n        i = previous[i]\n    \n    # Return the subsequence in original order.\n    return subseq[::-1]", "def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    if is_palindrome(string):\n        return string\n\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            reversed_prefix = string[:i][::-1]\n            return string + reversed_prefix\n\n    return string + string[::-1]"]}
{"task_id": 237, "content": ["def harmonic_mean(sequence):\n    \"\"\"\n    Calculate the harmonic mean of a given sequence.\n    \"\"\"\n\n    # The harmonic mean is the reciprocal of the arithmetic mean of the reciprocals\n    # If there is a zero in the sequence, we return zero\n    if 0 in sequence:\n        return 0\n    else:\n        return len(sequence) / sum(1.0 / num for num in sequence)", "def harmonic_mean(sequence):\n    \"\"\"\n    Calculate the harmonic mean of a given sequence.\n    \"\"\"\n\n    # The harmonic mean is the reciprocal of the arithmetic mean of the reciprocals\n    # If there is a zero in the sequence, we return zero\n    if 0 in sequence:\n        return 0\n    else:\n        return len(sequence) / sum(1.0 / num for num in sequence)", "def calculate_mean(numbers):\n    \"\"\"Function to calculate the mean of a collection of numbers.\"\"\"\n    return sum(numbers) / len(numbers)", "def sum_list(lst):\n    \"\"\"\n    Function to calculate the sum of elements in a list\n    \"\"\"\n    return sum(lst)", "def calculate_sum(n):\n    \"\"\"Function to calculate the sum of the first n numbers.\"\"\"\n    sum = 0\n    while n > 0:\n        sum = sum + n\n        n = n - 1\n    return sum"]}
{"task_id": 238, "content": ["def find_intersection(list_one, list_two):\n  # Convert the arrays to sets\n  set_one = set(list_one)\n  set_two = set(list_two)\n  \n  # Find the intersection of the two sets\n  intersection = set_one & set_two \n  \n  # Convert the intersection set to a list and sort it\n  sorted_list = sorted(list(intersection))\n  \n  return sorted_list", "def outermat(a, b):\n    # Function to calculate the outer product of two input arrays\n    return np.outer(a, b)", "def intersect_lists(list1, list2):\n    # Use the & operator to find the intersection of the two sets.\n    intersection = list(set(list1) & set(list2))\n    return intersection", "def intersect_lists(list1, list2):\n    # Use the & operator to find the intersection of the two sets.\n    intersection = list(set(list1) & set(list2))\n    return intersection", "def pick_first_round():\n    global first_round_post_iss, rounds_avail\n    reducer = lambda x, y: x.intersection(y)  # Define a set intersection reducer function\n    first_round_post_iss = min(reduce(reducer, rounds_avail.values()))  # Find the minimum common number"]}
{"task_id": 239, "content": ["def count_occurrences(element, tuple_input):\n    \"\"\"A function to count occurrences of an element in a (nested) tuple\"\"\"\n    count = 0\n    for i in tuple_input:\n        if isinstance(i, tuple):\n            count += count_occurrences(element, i)\n        else:\n            if i == element:\n                count += 1\n    return count", "def frequencySort(nums):\n    # collections.Counter(nums) gives the frequency of each element in the nums array.\n    # items() function returns a view object that displays a list of a dictionary's(an iterable) tuple pair (key, value).\n    c = Counter(nums).items()\n    # Then we will sort the results by the tuple (-count, num). Negative count ensures that high frequency elements come first in the sorted list.\n    # This satisfies the requirement to sort in increasing frequency. \n    # Because we use num for sort as well, elements with the same frequency are sorted in descending order.\n    # This satisfies the requirement to sort in decreasing order on the basis of value of the numbers in case of same frequency.\n    # idx is used to sort elements in increasing order of their index in case elements are same and have same frequency.\n    # sort function of python is stable. i.e, it maintains the relative order of items with equal sort keys\n    nums.sort(key = lambda x: (nums.count(x), -x, [i for i, n in enumerate(nums) if n == x][0]))\n    # return the sorted array\n    return nums", "def transpose(matrix):\n    # The * operator is used to unzip a list (or other iterables), making a list of tuples where each tuple contains the i-th element from each of the argument sequences or iterables.\n    # The zip() function takes iterables, aggregates them in a tuple, and return the result.\n    # In other words, it returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.\n    return [list(i) for i in zip(*matrix)] ", "def revised_function(input_tuple):\n    # Checks if the tuple is None or empty \n    if not input_tuple:\n        return \"Error: input is NULL or empty.\"\n\n    # Initiating an empty list to hold string representations of the float values\n    str_list = []\n\n    # Iterate over the elements in the tuple\n    for element in input_tuple:\n        # Confirm that each element is a float. If not, return an error message.\n        if not isinstance(element, float):\n            return \"Error: all elements in the tuple should be floats.\"\n            \n        # Convert the float to a string and append to the list\n        str_list.append(str(element))\n    \n    # Join all elements in the list with a semicolon\n    result = \"; \".join(str_list)\n    \n    return result", "def find_single(arr):\n    # Create an empty dictionary to store the count of each element\n    count_dict = {}\n    \n    # Iterate over each element in the array\n    for element in arr:\n        # If the element is already in the dictionary, increment its count\n        if element in count_dict:\n            count_dict[element] += 1\n        # Otherwise, add the element to the dictionary with a count of 1\n        else:\n            count_dict[element] = 1\n    \n    # Iterate over the dictionary and find the element with a count of 1\n    for element, count in count_dict.items():\n        if count == 1:\n            # Return the index of the first occurrence of the element in the array\n            return arr.index(element)\n    \n    # If no element with a count of 1 is found, return -1\n    return -1"]}
{"task_id": 240, "content": ["def insertElement(element, htmlList):\n    # If the list is empty, return the element as a list\n    if not htmlList:\n        return [element]\n    \n    # Iterate over each element in the list\n    for i, htmlElement in enumerate(htmlList):\n        # Check if the current element is a nested element\n        if htmlElement.startswith('<') and htmlElement.endswith('>'):\n            # Find the position to insert the element within the nested element\n            innerHtmlList = htmlElement[1:-1].split('>')\n            innerHtmlList = [innerHtml.strip() for innerHtml in innerHtmlList if innerHtml.strip()]\n            innerHtmlList[-1] += '>'\n            innerHtmlList.append(element)\n            \n            # Recursively call the function to insert the element in the correct position within the nested element\n            htmlList[i] = insertElement('>'.join(innerHtmlList), innerHtmlList)\n            return htmlList\n    \n    # If no nested element is found, insert the element at the end of the list\n    htmlList.append(element)\n    return htmlList", "def substitute_entity(array, target, replacement):\n    \"\"\"\n    Function to replace a specific element in an array\n\n    Arguments:\n    array : a list of elements\n    target : element to replace\n    replacement : new element to substitute the target with\n\n    Returns:\n    new_array : new list with the target element replaced by the replacement\n    \"\"\"\n    \n    # Create an empty list to store the updated elements\n    new_array = []\n\n    # Go through each element in the original list\n    for element in array:\n\n        # If the element is the target,\n        # add the replacement to the new list\n        if element == target:\n            new_array.append(replacement)\n        \n        # If the element is not the target,\n        # add the original element to the new list\n        else:\n            new_array.append(element)\n\n    return new_array", "def substitute_entity(array, target, replacement):\n    \"\"\"\n    Function to replace a specific element in an array\n\n    Arguments:\n    array : a list of elements\n    target : element to replace\n    replacement : new element to substitute the target with\n\n    Returns:\n    new_array : new list with the target element replaced by the replacement\n    \"\"\"\n    \n    # Create an empty list to store the updated elements\n    new_array = []\n\n    # Go through each element in the original list\n    for element in array:\n\n        # If the element is the target,\n        # add the replacement to the new list\n        if element == target:\n            new_array.append(replacement)\n        \n        # If the element is not the target,\n        # add the original element to the new list\n        else:\n            new_array.append(element)\n\n    return new_array", "def rolling_max(arr):\n    \"\"\"\n    This function takes an array of positive integers and\n    returns a new array where each element from index 0 to \n    n is the maximum element from the original array from\n    index 0 to n.\n\n    If there's a negative number in the array, the function returns an empty list.\n    \n    Args:\n        arr (List[int]): a list of integers.\n\n    Returns:\n        List[int]: a list of maximum numbers. \n        If input list contains negative number, an empty list is returned\n    \"\"\"\n    \n    max_num = float('-inf')\n    result = []\n    \n    for number in arr:\n        if number < 0:\n            return []\n        max_num = max(number, max_num)\n        result.append(max_num)\n        \n    return result", "def validate_input_sequence(input_sequence):\n    # Convert the sequence to a list\n    list_sequence = list(input_sequence)\n\n    # Iterate over each element in the list\n    for element in list_sequence:\n\n        # Split the element into a list of characters\n        list_characters = list(element)\n\n        # Iterate over each character in the element\n        for character in list_characters:\n\n            # Check if the character is an alphabet\n            if not character.isalpha():\n                print(\"Invalid input. The sequence should only contain alphabets.\")\n                return False\n    print(\"Valid input. The sequence only contains alphabets.\")\n    return True"]}
{"task_id": 241, "content": ["def pol2cart(shape_pol, points):\n    \"\"\"\n    Convert polar coordinates to Cartesian coordinates.\n\n    Parameters\n    ----------\n    shape_pol : ndarray\n        Array of polar coordinates of shape (Nnodes, Ndof)\n    points : ndarray\n        Array of points in the mesh\n\n    Returns\n    -------\n    shape_xyz : ndarray\n        Array of Cartesian coordinates of shape (Nnodes, Ndof)\n    \"\"\"\n    r = shape_pol[:, 0]  # Extracting radial distance from polar coordinates\n    theta = shape_pol[:, 1]  # Extracting angular coordinate from polar coordinates\n\n    x = r * np.cos(theta)  # Calculating x coordinate in Cartesian system\n    y = r * np.sin(theta)  # Calculating y coordinate in Cartesian system\n\n    shape_xyz = np.column_stack((x, y))  # Combining x and y coordinates into shape_xyz\n\n    return shape_xyz", "def subtract_complex_numbers(c1, c2):\n    # Convert strings to complex numbers\n    complex1 = complex(c1.replace('i', 'j')) \n    complex2 = complex(c2.replace('i', 'j'))\n\n    # Subtract complex numbers\n    result = complex1 - complex2\n\n    # Convert back to string and replace 'j' with 'i'\n    result_str = str(result).replace('j', 'i')\n\n    # Some Python versions append a '+0i' to the result for real numbers. We'll remove this.\n    if result_str.endswith('+0i'):\n        result_str = result_str[:-3]\n    \n    return result_str", "def attach_to_process(pid):\n    # This is a placeholder function. In reality, you would need to use a lower-level\n    # library or system call to perform this action, which is not exposed through\n    # the Python standard library.\n    # For example, you might use the libc library to call ptrace()\n    # This is beyond the scope of a simple Python script and would require a\n    # more complex setup and environment.\n    pass", "def inject_payload(pid, payload):\n    # This function would need to be implemented to attach to the process,\n    # find the system call table, and modify it to point to the custom handler.\n    # This is a complex task that typically requires kernel-level access and\n    # is beyond the scope of a simple Python script.\n    pass", "def square_elements(input_data):\n    \"\"\"\n    Function to return the square of a complex number or a list of complex numbers.\n    \n    Parameters:\n    input_data (complex/list of complex numbers): A complex number or list of complex numbers to square.\n\n    Returns:\n    complex/list: Square of the input complex number or list of complex numbers.\n    \"\"\"\n    \n    # Check if input_data is a complex number or a list\n    if isinstance(input_data, complex):\n        return input_data ** 2\n    elif isinstance(input_data, list):\n        # Check if all elements in the list are complex numbers\n        if all(isinstance(ele, complex) for ele in input_data):\n            return [ele ** 2 for ele in input_data]\n        else:\n            raise TypeError(\"All elements in the list must be complex numbers.\")\n    else:\n        raise TypeError(\"Input must be a complex number or a list of complex numbers.\")"]}
{"task_id": 242, "content": ["def count_unique_numbers(numbers):\n    \"\"\"\n    Count the number of unique integers in the given list.\n\n    Args:\n    numbers: A list of integers.\n\n    Returns:\n    An integer representing the count of unique numbers in the list.\n    \"\"\"\n    try:\n        unique_numbers = set(numbers)  # Convert the list to a set to get unique elements\n        return len(unique_numbers)  # Return the count of unique numbers\n    except TypeError as e:\n        raise TypeError(\"Input must be a list of integers\") from e\n    except Exception as e:\n        raise Exception(\"An error occurred while counting unique numbers\") from e", "def filter_numbers(numbers, func_filter):\n    \"\"\"\n    Filters a list of integers based on the given condition.\n\n    Args:\n    numbers: A list of integers to be filtered.\n    func_filter: A filtering function that accepts an integer and returns a boolean value.\n\n    Returns:\n    A new list containing only the integers that satisfy the filtering condition.\n    \"\"\"\n    filtered_numbers = [num for num in numbers if func_filter(num)]\n    return filtered_numbers", "def delete_element(my_list, pos):\n    \"\"\"Function to delete an element from a given list at a given position.\"\"\"\n    del my_list[pos]\n    return my_list", "def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list", "def filter_odd(lst):\n    \"\"\"\n    Function to filter out the odd elements in a given list and return the even ones.\n\n    :param lst: A list of integers\n    :returns: A new list containing only even integers\n    \"\"\"\n    return [x for x in lst if x % 2 == 0]"]}
{"task_id": 243, "content": ["def find_words_with_fr(string):\n    '''\n    This function will find all words containing the letters \"fr\" in a given string.\n    \n    Args:\n        string (str): the string to be searched\n    \n    Returns:\n        list: a list of all words containing the letters \"fr\"\n    '''\n    regex = r\"\\b\\w*fr\\w*\\b\"\n    return re.findall(regex, string)", "def find_words_starting_with_a(text):\n    # the regular expression pattern for words starting with 'a' or 'A'\n    pattern = r'\\b[aA]\\w*\\b'\n    \n    # find all matches in the text\n    matches = re.findall(pattern, text)\n    \n    return matches", "def replace_vowels(string):\n    \"\"\"\n    Function to change all the vowels in a given string to 'z'\n    \"\"\"\n    new_string = ''\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n\n    for char in string:\n        if char in vowels:\n            char = 'z'\n        new_string += char\n    return new_string", "def arrange_string(s):\n    \"\"\"\n    This function takes a string 's', splits it into words, applies the custom_order function to each word to sort the characters in it,\n    and then rejoins the sorted words back together with a space in between. The function preserves the original order of words \n    and blank spaces in the sentence.\n    \"\"\"\n\n    # Split the string into a list of words\n    words_list = s.split(' ')\n\n    # Apply the custom_order function to each word in the list\n    ordered_words_list = [custom_order(word) for word in words_list]\n\n    # Join the ordered words back together with a space in between to form a string\n    ordered_s = ' '.join(ordered_words_list)\n\n    return ordered_s", "def anti_jumble(s):\n    \"\"\"\n    This function takes a string 's', splits it into words, applies the custom_order function to each word to sort the characters in it, \n    and then rejoins the sorted words back together with a space in between. The function preserves the original order of words \n    and blank spaces in the sentence.\n    \"\"\"\n\n    # Split the string into a list of words\n    words_list = s.split(' ')\n\n    # Apply the custom_order function to each word in the list\n    ordered_words_list = [custom_order(word) for word in words_list]\n\n    # Join the ordered words back together with a space in between to form a string\n    ordered_s = ' '.join(ordered_words_list)\n\n    return ordered_s"]}
{"task_id": 244, "content": ["def assign_colour(data_points):\n    '''This function will assign a colour to the given data points'''\n    from matplotlib import cm\n    cmaps = ['Spectral', 'plasma', 'magma', 'viridis', 'inferno', 'cividis']\n    \n    num_points = len(data_points)\n    colours = cm.get_cmap(cmaps[0])(np.linspace(0., 1., num_points))\n    \n    # assign colours to data points\n    colour_assignment = {}\n    for i, point in enumerate(data_points):\n        colour_assignment[point] = colours[i]\n    \n    return colour_assignment", "def colorings(idx=0, top=0, left=0, bottom=0):\n    if idx == 64: # if reached the end of the array\n        return 1\n    count = 0\n    for c in [1, 2, 3]: # three colours\n        if c != top: # if the colour is different from the upper triangle\n            if idx % 8 > 0 and idx % 8 < 7: # if it is a 'lower' triangle pair\n                if c != left:\n                    # Two cases considering: same or different colours of pair\n                    count += 3*colorings(idx+1, c, c, bottom=1) + 3*colorings(idx+1, c, c, bottom=2)\n                else: \n                    # One case considering: different colours of pair\n                    count += 2*colorings(idx+1, c, c, bottom=1)\n            else: # if it is an 'upper' triangle\n                if idx % 8 == 0: # if it's the first triangle in the row\n                    count += colorings(idx+1, c, 0, bottom=0)\n                else: # if it's the last triangle in the row\n                    count += colorings(idx+1, 0, 0, bottom=0)  \n    return count", "def computer_player():\n    # generate a random number to choose one of the three choices\n    selection = random.randint(0,2)\n    return options[selection]", "def find_three_numbers(array, target):\n    # Use the combinations function to generate all possible combinations of 3 numbers from the list\n    for comb in combinations(array, 3):\n        if sum(comb) == target:   # If the sum of a combination equals the target value\n            return True   # Return True and terminate the function\n    return False   # If no combination is found, return False", "def gen_population(pop_size):\n    \"\"\"Generate a population of random 3x3 grids of colours\"\"\"\n    population = []\n    for _ in range(pop_size):\n        grid = np.random.randint(low=0, high=15, size=(3,3))\n        population.append(grid)\n    return population"]}
{"task_id": 245, "content": ["def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True", "def print_primes_up_to(number):\n    \"\"\"Print all prime numbers less than or equal to a given number.\"\"\"\n    # Edge cases\n    if number < 2:\n        print(\"No prime numbers\")\n        return\n    \n    # Iterate until a prime is found\n    for i in range(2, number + 1):\n        # Check if the number is prime\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                # Found a divisor, i is not prime\n                is_prime = False\n                break\n        # Print the i if it is prime\n        if is_prime:\n            print(i, end=\" \")", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def count_even(n):\n    # Check whether given input is valid integer or not\n    if not isinstance(n, int):\n        return \"Error: Input should be an integer\"\n    \n    # handle the cases where n is less than 0\n    if n < 0:\n        return \"Error: Input should be non-negative integer\"\n    \n    # As number at odd indexes are even number in series 0 to n (since 0 is considered even),\n    # by integer division of n by 2, would directly derive count of non-negative even numbers less than n\n    return (n // 2)", "def factorial(num):\n    \"\"\"\n    This function takes a non-negative integer and calculates its factorial.\n    Factorial of a number is the product of all positive integers less than or equal to it.\n    \"\"\"\n    if num < 0: \n        return \"Invalid input! Please enter a non-negative integer.\"\n    elif num == 0 or num == 1: \n        return 1\n    else: \n        return num * factorial(num - 1)"]}
{"task_id": 246, "content": ["def remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Facilitate the de-duplication of a sequence of integers, eliminating any references that occur more than once.\n    Retains the exact sequence of remaining integers mirroring the original provided sequence.\n    Time complexity: O(n)\n    Space complexity: O(1)\n    \"\"\"\n    write = 1\n    for read in range(1, len(numbers)):\n        if numbers[read] != numbers[read-1]:\n            numbers[write] = numbers[read]\n            write += 1\n    return numbers[:write]   # cutting the array to length 'write'", "def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass", "def add(a, b):\n    \"\"\"\n    This is a simple function to add two numbers.\n\n    >>> add(2, 2)\n    4\n    >>> add(3, 3)\n    6\n    \"\"\"\n\n    return a + b", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass"]}
{"task_id": 247, "content": ["def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def filter_odd(lst):\n    \"\"\"\n    Function to filter out the odd elements in a given list and return the even ones.\n\n    :param lst: A list of integers\n    :returns: A new list containing only even integers\n    \"\"\"\n    return [x for x in lst if x % 2 == 0]", "def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list", "def sort(list):\n    \"\"\"\n    This function sorts a given list in ascending order.\n\n    Parameters:\n    list (List[int, float, str]): A list of numerical or string values to be sorted. This list should contain elements of the same datatype for the function to work correctly. \n    \"\"\"\n    list.sort()", "def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers."]}
{"task_id": 248, "content": ["def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min", "def find_permutations(arr):\n    # itertools.permutations method returns all permutations \n    # of the given list arr of length len(arr).\n    # Each permutation is a tuple so we use map function \n    # to convert these tuples to lists\n    perm = list(map(list, itertools.permutations(arr)))\n    \n    # Return the generated permutations\n    return perm", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass", "def sort_list(tuples):\n    \"\"\"\n    A function to sort a list of tuples by the second item in each tuple.\n    \"\"\"\n    return sorted(tuples, key=lambda x: x[1])", "def sort_by_second_item(tuples):\n    \"\"\"Sorts a list of tuples by the second item in the tuples.\n    \n    Args:\n        tuples: A list of tuples to be sorted.\n        \n    Returns:\n        sorted_list: The sorted list of tuples.\n    \"\"\"\n    sorted_list = sorted(tuples, key=lambda x: x[1])\n    \n    return sorted_list"]}
{"task_id": 249, "content": ["def calculate_fibonacci(n):\n    \"\"\"\n    This function calculates the nth number of the Fibonacci sequence using iteration.\n    \n    Parameters:\n        n (int): The number in the Fibonacci sequence to calculate.\n        \n    Returns:\n        The nth number of the Fibonacci sequence.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    a, b = 0, 1\n    for i in range(2, n+1):\n        c = a + b\n        a, b = b, c\n        \n    return b", "def fibonacci_while(n):\n    \"\"\"\n    A function to compute and output the nth Fibonacci number using a while loop.\n    \"\"\"\n    \n    #initialize the first two terms\n    term1 = 0\n    term2 = 1\n    count = 2\n    \n    #check if it is the first or second number\n    if n == 1:\n        return term1\n    elif n == 2:\n        return term2\n    \n    #find the nth term\n    while count < n:\n        nth_term = term1 + term2\n        term1 = term2\n        term2 = nth_term\n        count += 1\n    \n    return nth_term", "def calculate_geometric_mean(num_list):\n    product = 1  # This variable will hold the multiplied result of all numbers in the num_list\n\n    for num in num_list:\n        # Multiply each number in num_list with the product\n        product *= num \n\n    # Calculate the geometric mean by taking the nth root of product\n    # where n is the number of elements in the list.\n    # The math.pow function calculates the power of a number.\n    # Since we need to calculate the nth root, the power is 1/n.\n    geometric_mean = math.pow(product, 1/len(num_list))\n\n    return geometric_mean", "def find_prime_factors(number):\n    \"\"\"Find the prime factorization of a given number.\n\n    Parameters:\n        number (int): The number to be factorized\n\n    Returns:\n        list: A list of prime factors of the number\n    \"\"\"\n\n    # Initialize a list to store the prime factors\n    prime_factors = []\n\n    # Start with a daily 2, the first prime number\n    divisor = 2\n\n    # Divide by 2 as long as the number is divisible.\n    while number % divisor == 0:\n        prime_factors.append(divisor)\n        number = number / divisor\n\n    # Increment the divisor by one\n    divisor = divisor + 1\n\n    # Keep repeating the above process with the incremented divisor,\n    # until the divisor becomes greater than the number.\n    while divisor <= number:\n        if number % divisor == 0:\n            prime_factors.append(divisor)\n            number = number / divisor\n        else:\n            divisor = divisor + 1\n\n    return prime_factors", "def find_kth_prime_numbers(lst, k):\n    \"\"\"Function to find the kth prime number in a list.\"\"\"\n    primes = [x for x in lst if is_prime(x)]\n    if k <= len(primes):\n        return primes[k - 1]\n    return None"]}
{"task_id": 250, "content": ["def tag_join_across_consume(ht):\n    # Perform tagging/joining across consume operation\n    # Logic to combine partitions based on tagging and joining\n\n    # Your implementation of tagging/joining across consume operation goes here\n\n    return ht  # Return the modified label hash", "def calculator(input_list, operation):\n    \"\"\"\n    This function takes a list of numbers and an operation (addition, subtraction, multiplication, division) \n    and performs the operation on the list of numbers.\n\n    Parameters:\n    input_list (list of int/float): A list of numbers on which the operation is to be performed\n    operation (str): The operation to be performed (\"addition\", \"subtraction\", \"multiplication\", \"division\")\n\n    Returns:\n    result: The result of the operation\n    \"\"\"\n\n    try:\n        # Initialize result to the first number in the list for subtraction and division\n        if operation == 'subtraction' or operation == 'division':\n            result = input_list[0]\n        else:\n            result = 0 if operation == 'addition' else 1\n\n        for number in input_list:\n            if operation == 'addition':\n                result += number\n            elif operation == 'subtraction':\n                result -= number\n            elif operation == 'multiplication':\n                result *= number\n            elif operation == 'division':\n                # Check division by zero error\n                if number == 0:\n                    print(\"Division by zero is undefined.\")\n                    return None\n                result /= number\n            else:\n                print(\"Invalid operation. Please use 'addition', 'subtraction', 'multiplication', or 'division'.\")\n                return None\n        return result\n    except TypeError:\n        print(\"Invalid input type. Please make sure all inputs are numbers.\")\n        return None", "def calculator(input_list, operation):\n    \"\"\"\n    This function takes a list of numbers and an operation (addition, subtraction, multiplication, division) \n    and performs the operation on the list of numbers.\n\n    Parameters:\n    input_list (list of int/float): A list of numbers on which the operation is to be performed\n    operation (str): The operation to be performed (\"addition\", \"subtraction\", \"multiplication\", \"division\")\n\n    Returns:\n    result: The result of the operation\n    \"\"\"\n\n    try:\n        # Initialize result to the first number in the list for subtraction and division\n        if operation == 'subtraction' or operation == 'division':\n            result = input_list[0]\n        else:\n            result = 0 if operation == 'addition' else 1\n\n        for number in input_list:\n            if operation == 'addition':\n                result += number\n            elif operation == 'subtraction':\n                result -= number\n            elif operation == 'multiplication':\n                result *= number\n            elif operation == 'division':\n                # Check division by zero error\n                if number == 0:\n                    print(\"Division by zero is undefined.\")\n                    return None\n                result /= number\n            else:\n                print(\"Invalid operation. Please use 'addition', 'subtraction', 'multiplication', or 'division'.\")\n                return None\n        return result\n    except TypeError:\n        print(\"Invalid input type. Please make sure all inputs are numbers.\")\n        return None", "def calculator(arg1, arg2=0, operation=\"add\", arg3=None):\n    # If arg3 is not given, treat it as 0 for addition and subtraction, and 1 for multiplication and division.\n    if arg3 is None:\n        if operation in [\"add\", \"subtract\"]:\n            arg3 = 0\n        elif operation in [\"multiply\", \"divide\"]:\n            arg3 = 1    \n\n    # Perform the requested operation.\n    if operation == \"add\":\n        return arg1 + arg2 + arg3\n    elif operation == \"subtract\":\n        return arg1 - arg2 - arg3\n    elif operation == \"multiply\":\n        return arg1 * arg2 * arg3\n    elif operation == \"divide\":\n        # Handle the case where division by zero would occur.\n        if arg2 != 0 and arg3 != 0:\n            return arg1 / arg2 / arg3\n        else:\n            return \"Error: Division by zero is not allowed.\"\n    else:\n        return \"Error: Invalid operation requested.\"", "def math_function(num):\n    \"\"\"\n    Applies a mathematical function to a given number.\n    \"\"\"\n    result = num ** 2 + 3\n    return result"]}
{"task_id": 251, "content": ["def starts_with_santo(city_name):\n    city = city_name.strip().lower()  # Remove leading/trailing whitespace and convert to lowercase\n    parts = city.split()  # Split the city name into parts\n    first_part = parts[0]  # Get the first part of the city name\n    starts_with_santo = (first_part == 'santo')  # Check if the first part is \"santo\" (case-insensitive)\n    return starts_with_santo", "def generate_pattern(length):\n    \"\"\"\n    Generates a non-repeating pattern of a given length.\n    This pattern is used to identify the offset at which the EIP can be controlled.\n    \"\"\"\n    pattern = \"\"\n    parts = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    for i in range(length):\n        pattern += parts[i % len(parts)]\n    return pattern", "def split_string(input_string):\n    # Split the string into parts\n    parts = input_string.split()\n\n    # Initialize empty lists for the numbers and strings\n    numbers=[]\n    strings=[]\n\n    # Examine each part\n    for part in parts:\n\n        # Try to cast the part to a float\n        try:\n            number = float(part)\n            numbers.append(number)\n\n        # If an error is thrown, the part must not be a number\n        except ValueError:\n            strings.append(part)\n\n    # Calculate the sum of the numbers\n    total_sum = sum(numbers)\n\n    return numbers, strings, total_sum", "def apply_function(arr, f):\n    \"\"\"\n    Apply a given function to each item of an input array.\n    \n    Args:\n        arr (list): The input array.\n        f (function): The function to be applied.\n        \n    Returns:\n        list: A list with the result of applying function f to each item of arr.\n    \"\"\"\n    return list(map(f, arr))", "def find_permutations(arr):\n    # itertools.permutations method returns all permutations \n    # of the given list arr of length len(arr).\n    # Each permutation is a tuple so we use map function \n    # to convert these tuples to lists\n    perm = list(map(list, itertools.permutations(arr)))\n    \n    # Return the generated permutations\n    return perm"]}
{"task_id": 252, "content": ["def mergeDictionaries(dict1, dict2):\n    '''This function takes two python dictionaries as inputs and returns a single merged dictionary.'''\n\n    # Create a new empty dictionary\n    merged_dict = {}\n\n    # Iterate over the two argument dictionaries and add the key-value pairs to the new dictionary\n    for key, value in dict1.items():\n        merged_dict[key] = value\n    for key, value in dict2.items():\n        merged_dict[key] = value\n\n    # Return the merged dictionary\n    return merged_dict", "def merge_arrays(arr1, arr2):\n    '''This function will merge two given arrays and return a new array.'''\n      \n    combined_arr = arr1 + arr2\n    return sorted(combined_arr)", "def sort_dict_of_dicts(d, key_func):\n    \"\"\"\n    Function to sort a dictionary of dictionaries\n    as per a given function.\n    :param d: Dictionary to be sorted.\n    :param key_func: Function used for sorting.\n    :Returns : Sorted dictionary.\n    \"\"\"\n    return dict(sorted(d.items(), key=lambda x: key_func(x[1]), reverse=True))", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass"]}
{"task_id": 253, "content": ["def match_unique_words(sentence1: str, sentence2: str) -> bool:\n    \"\"\"\n    Check if two provided sentences contain the same set of unique words and in the same order.\n    >>> match_unique_words(\"cat dog mouse\", \"mouse dog cat\")\n    False\n    >>> match_unique_words(\"cat dog\", \"cat dog\")\n    True\n    >>> match_unique_words(\"cat\", \"cat cat\")\n    False\n    >>> match_unique_words(\"dog\", \"cat dog\")\n    False\n    >>> erroneomatch_unique_wordsus_match_unique_words(\"cat dog mouse\", \"cat dog mouse\")\n    True\n    \"\"\"\n    # Split the sentences into list of words\n    list_sentence1 = sentence1.split()\n    list_sentence2 = sentence2.split()\n\n    # Check if lists are same i.e., the words are in the same order and are unique\n    return list_sentence1 == list_sentence2", "def classify_dog(dog_size):\n    \"\"\" Create a program to classify dogs into different categories based on size\"\"\"\n    # classify based on size\n    if dog_size <= 20: # small\n        return \"Small Dog\"\n    elif dog_size > 20 and dog_size <= 50: # medium\n        return \"Medium Dog\"\n    else: # large\n        return \"Large Dog\"", "def execute_dll(process_handle, memory_address):\n    # This is a placeholder function. In a real-world scenario, you would use\n    # the Windows API to execute the DLL in the target process.\n    # You would likely use the CreateRemoteThread function to start a new thread\n    # that points to the DLL's entry point.\n    pass", "def restart_rootkit():\n    # This is a placeholder function. In practice, you would need to modify the system's init scripts\n    # or use a method to execute the rootkit at system startup.\n    pass", "def print_food_item(food):\n    if food[0] == \"hamburger\":\n        print(\"You ordered a hamburger\")\n    elif food[0] == \"hot dog\":\n        print(\"You ordered a hot dog\")\n    elif food[0] == \"cheese\":\n        print(\"You ordered cheese\")\n    else:\n        print(\"You ordered an unknown food item\")\n\n    if food[1] == \"hamburger\":\n        print(\"You ordered a hamburger\")\n    elif food[1] == \"hot dog\":\n        print(\"You ordered a hot dog\")\n    elif food[1] == \"cheese\":\n        print(\"You ordered cheese\")\n    else:\n        print(\"You ordered an unknown food item\")\n\n    if food[2] == \"hamburger\":\n        print(\"You ordered a hamburger\")\n    elif food[2] == \"hot dog\":\n        print(\"You ordered a hot dog\")\n    elif food[2] == \"cheese\":\n        print(\"You ordered cheese\")\n    else:\n        print(\"You ordered an unknown food item\")"]}
{"task_id": 254, "content": ["def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list", "def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass", "def recursive_print(arr):\n    # Reverse the array and iterate over every alternate element\n    for i in arr[::-2]:\n        # If the element is a list, recurse on it.\n        if isinstance(i, list):\n            recursive_print(i)\n        # If the element is a number, print it.\n        else:\n            print(i)", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass"]}
{"task_id": 255, "content": ["def cube_surface_area(side):\n    \"\"\" \n    Calculate and return the total surface area of a cube \n    given the side length.\n    \"\"\"\n    return 6 * side**2", "def find_surface_area(length, breadth, height):\n    '''\n    This function calculates the surface area of a cuboid.\n    Input: length, breadth, height - these are the three dimensions of the cuboid\n    Output: total surface area of the cuboid \n    '''\n    # Formula of Surface Area of Cuboid = 2(lb + bh + hl)\n    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area", "def find_surface_area(length, breadth, height):\n    '''\n    This function calculates the surface area of a cuboid.\n    Input: length, breadth, height - these are the three dimensions of the cuboid\n    Output: total surface area of the cuboid \n    '''\n    # Formula of Surface Area of Cuboid = 2(lb + bh + hl)\n    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area", "def cube_surface_area(side_length):\n    # Calculate the area of one face of the cube\n    face_area = side_length * side_length\n    \n    # Calculate the surface area by multiplying the face area by 6\n    surface_area = face_area << 2 + face_area << 1\n    \n    return surface_area", "def solve_cube(cube):\n    # Main function that solves a Rubik's cube\n    # cube: list representing a Rubik's cube\n\n    # Determine cube state by analyzing the cube[i][j][k] values\n    scramble_state = analyze_cube(cube)\n\n    # Find the sequence of moves required to solve the cube[i][j][k]\n    moves = get_solve_moves(scramble_state)\n\n    # Execute moves to solve the cube[i][j][k]\n    execute_moves(cube, moves)"]}
{"task_id": 256, "content": ["def sum_of_squares(n):\n    # Initialize the sum of squares\n    sum_squares = 0\n    \n    # Calculate the sum of squares of the first n natural numbers\n    for i in range(1, n+1):\n        sum_squares += i**2\n    \n    return sum_squares", "def calculate_difference(n):\n    # Calculate the square of the sum of the first n natural numbers\n    square_of_sum = ((n * (n + 1)) // 2) ** 2\n    \n    # Calculate the sum of the squares of the first n natural numbers\n    sum_of_squares = (n * (n + 1) * ((2 * n) + 1)) // 6\n    \n    # Calculate the difference\n    difference = square_of_sum - sum_of_squares\n    \n    return difference", "def triangle_square_sum(n):\n    \"\"\"\n    Function to calculate the sum of the Triangle Series and the sum of the square of each\n    number in the Triangle Series up to n.\n    \"\"\"\n    # error handling: if n is negative or not an integer\n    if not isinstance(n, int) or n < 1:\n        return \"Error: Input must be an positive integer\"\n\n    # calculate the sum of the Triangle Series\n    # formula for the sum of the first n natural numbers is n*(n+1)/2\n    triangle_sum = n * (n + 1) // 2  # use integer division to ensure result is an integer\n\n    # calculate the sum of the square of each number in the Triangle Series up to n.\n    # formula for the sum of the squares of the first n natural numbers is n*(n+1)*(2n+1)/6\n    square_sum = n * (n + 1) * (2 * n + 1) // 6  # use integer division to ensure result is an integer\n\n    return triangle_sum, square_sum", "def sum_odd_numbers(l, r):\n    \"\"\"\n    Function to sum all odd numbers, their squares and cubes between l and r inclusive.\n\n    :param l: int (lower limit)\n    :param r: int (upper limit)\n    :return: tuple (sum of odd numbers, sum of squares of odd numbers, sum of cubes of odd numbers)\n     or str if l > r\n    \"\"\"\n    # Check constraints\n    if l > r:\n        return 'Error: Lower limit is greater than upper limit.'\n    \n    # Adjust for even numbers\n    if l % 2 == 0:\n        l += 1\n    if r % 2 == 0:\n        r -= 1\n    \n    # Count of odd numbers between l and r inclusive\n    n = (r - l) // 2 + 1\n    \n    # Calculation using series sums formulas\n    total_sum = n * (l + r) // 2\n    total_squares = n * (n + 1) * (2 * n + 1) // 3\n    total_cubes = total_sum ** 2\n\n    return total_sum, total_squares, total_cubes", "def sum_of_squares(arr):\n    \"\"\"\n    Calculate the sum of the squares of the given array of numbers.\n\n    Args:\n    arr: A list or array of numbers.\n\n    Returns:\n    The sum of the squares of the input numbers.\n    \"\"\"\n    return sum(x**2 for x in arr)"]}
{"task_id": 257, "content": ["def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass", "def print_pyramid(number):\n    \"\"\"Print the pyramid pattern of a given number.\"\"\"\n    # height of the pyramid = number\n    for row in range(number):\n        # number of spaces in every row = number - row - 1\n        for s in range(number - row - 1):\n            print(' ', end='')  # print space\n        # number of stars in every row = row + 1\n        for star in range(row + 1):\n            print('*', end='')  # print star\n        print()  # newline", "def write_rfid_data(rfid_writer, data):\n    # This function would interface with an RFID writer to write RFID badge data.\n    # Writes the data to a blank RFID badge.\n    print(f\"Cloned RFID badge with data: {data}\")", "def print_diamond_pattern(rows, character):\n    if rows < 5 or rows > 15 or rows % 2 == 0:\n        raise ValueError(\"Number of rows should be an odd integer between 5 and 15.\")\n    \n    space = rows // 2\n    star = 1\n    \n    for i in range(rows):\n        print(\" \" * space + character * star)\n        \n        if i < rows // 2:\n            space -= 1\n            star += 2\n        else:\n            space += 1\n            star -= 2", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass"]}
{"task_id": 258, "content": ["def print_ascii_value():\n    char = input(\"Enter a character: \")  # Read a single character from the standard input\n    ascii_value = ord(char)  # Get the ASCII value of the character\n    print(f\"The ASCII value of '{char}' is {ascii_value}\")  # Print the ASCII value", "def encode_char(character):\n    \"\"\"Returns the ASCII code of a given character.\n    \n    Arguments:\n        character - A single character\n        \n    Returns:\n        an integer representing the ASCII code\n    \"\"\"\n    return ord(character)", "def find_index_of_first_occurrence(string, character):\n    '''\n    This function will find the index of the first occurrence of a given character in a string.\n\n    Args:\n        string (str): the string to be searched\n        character (str): the character to be searched for\n\n    Returns:\n        int: the index of the first occurrence of the character\n    '''\n    return string.find(character)", "def has_unique_chars(string):\n    # If the string has more than 128 characters,\n    # it must have repeated characters.\n    if len(string) > 128:\n        return False\n    \n    # Create an array of 128 booleans, initialized to False.\n    # The index represents the ASCII value of a character,\n    # and the value at that index represents whether that\n    # character has been encountered before or not.\n    char_set = [False] * 128\n    \n    # Iterate through each character in the string.\n    for char in string:\n        # Get the ASCII value of the character.\n        ascii_value = ord(char)\n        \n        # If the character has already been encountered before,\n        # return False.\n        if char_set[ascii_value]:\n            return False\n        \n        # Mark the character as encountered.\n        char_set[ascii_value] = True\n    \n    # If no characters were encountered twice,\n    # return True.\n    return True", "def custom_order(s):\n    \"\"\"\n    This function takes a string 's' and sorts the letters in it based on their ASCII values, ignoring case. It then sorts them based on the count of each letter in the string, conserving the original letter casing.\n    \"\"\"\n\n    # Convert the string to a list of characters\n    s_list = list(s)\n\n    # This line sorts the list first by the ASCII value of each character in a case-insensitive manner, \n    # then by the count of the character in the string (which prioritizes letters with higher counts), \n    # and finally by the position of the character in the original string (to preserve the original order of equal elements).\n    s_list.sort(key=lambda x: (ord(x.lower()), -s_list.count(x), s_list.index(x)))\n\n    # Convert the sorted list of characters back into a string \n    sorted_s = ''.join(s_list)\n\n    return sorted_s"]}
{"task_id": 259, "content": ["def calculate_sum_positive_even_numbers(numbers):\n    \"\"\"\n    Calculates the sum of all positive even numbers from a given list.\n    \n    Args:\n    numbers (list): The list of numbers.\n    \n    Returns:\n    int: The sum of all positive even numbers.\n    \n    Raises:\n    ValueError: If the input list contains non-integer elements.\n    \n    \"\"\"\n    \n    # Validate the input list\n    for num in numbers:\n        if not isinstance(num, int):\n            raise ValueError(\"Input list should only contain integers.\")\n    \n    # Initialize sum variable\n    sum = 0\n    \n    # Create a set to store unique even numbers\n    unique_evens = set()\n    \n    # Iterate through the list\n    for num in numbers:\n        # Check if the number is positive and even\n        if num > 0 and num % 2 == 0:\n            # Add the number to the set of unique even numbers\n            unique_evens.add(num)\n    \n    # Calculate the sum of unique even numbers\n    for even_num in unique_evens:\n        sum += even_num\n    \n    return sum", "def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]", "def sum_of_even_numbers(numbers):\n    # Initialize the sum of even numbers to 0\n    even_sum = 0\n    # Iterate through the list of numbers\n    for num in numbers:\n        # Check if the number is even\n        if num % 2 == 0:\n            # Add the even number to the sum\n            even_sum += num\n    # Return the sum of even numbers\n    return even_sum", "def process_even_numbers(numbers):\n    # Initialize the sum of even numbers\n    even_sum = 0\n    \n    # Iterate through the list of numbers\n    for num in numbers:\n        # Check if the number is even\n        if num % 2 == 0:\n            even_sum += num  # Add the even number to the sum\n    \n    return even_sum  # Return the sum of even numbers", "def sum_even_numbers(numbers):\n    # Initialize the sum of even numbers to 0\n    even_sum = 0\n    \n    # Iterate through the input list\n    for num in numbers:\n        # Check if the number is even\n        if num % 2 == 0:\n            # Add the even number to the sum\n            even_sum += num\n    \n    # Return the sum of even numbers\n    return even_sum"]}
{"task_id": 260, "content": ["def calculate_difference(n):\n    # Calculate the square of the sum of the first n natural numbers\n    square_of_sum = ((n * (n + 1)) // 2) ** 2\n    \n    # Calculate the sum of the squares of the first n natural numbers\n    sum_of_squares = (n * (n + 1) * ((2 * n) + 1)) // 6\n    \n    # Calculate the difference\n    difference = square_of_sum - sum_of_squares\n    \n    return difference", "def triangle_square_sum(n):\n    \"\"\"\n    Function to calculate the sum of the Triangle Series and the sum of the square of each\n    number in the Triangle Series up to n.\n    \"\"\"\n    # error handling: if n is negative or not an integer\n    if not isinstance(n, int) or n < 1:\n        return \"Error: Input must be an positive integer\"\n\n    # calculate the sum of the Triangle Series\n    # formula for the sum of the first n natural numbers is n*(n+1)/2\n    triangle_sum = n * (n + 1) // 2  # use integer division to ensure result is an integer\n\n    # calculate the sum of the square of each number in the Triangle Series up to n.\n    # formula for the sum of the squares of the first n natural numbers is n*(n+1)*(2n+1)/6\n    square_sum = n * (n + 1) * (2 * n + 1) // 6  # use integer division to ensure result is an integer\n\n    return triangle_sum, square_sum", "def sum_of_squares(n):\n    # Initialize the sum of squares\n    sum_squares = 0\n    \n    # Calculate the sum of squares of the first n natural numbers\n    for i in range(1, n+1):\n        sum_squares += i**2\n    \n    return sum_squares", "def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def sum_of_n_numbers(n):\n    \"\"\"This function will return the sum of n natural numbers.\"\"\"\n    # check if n is 1\n    if n == 1:\n        return 1\n    # Otherwise, recursively call the function\n    else:\n        return n + sum_of_n_numbers(n-1)"]}
{"task_id": 261, "content": ["def transpose(matrix):\n    # The * operator is used to unzip a list (or other iterables), making a list of tuples where each tuple contains the i-th element from each of the argument sequences or iterables.\n    # The zip() function takes iterables, aggregates them in a tuple, and return the result.\n    # In other words, it returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.\n    return [list(i) for i in zip(*matrix)] ", "def get_users():\n    # Assume this function retrieves the list of user records from the database\n    # and returns it as a list of dictionaries\n    pass", "def data_exfiltration():\n    # This function represents the extraction of data from the compromised systems.\n    # In a real-world scenario, this would involve copying or transferring data to a controlled area.\n    # For ethical hacking, this step is typically performed by a third-party security professional.\n    pass", "def sort_by_second_item(tuples):\n    \"\"\"Sorts a list of tuples by the second item in the tuples.\n    \n    Args:\n        tuples: A list of tuples to be sorted.\n        \n    Returns:\n        sorted_list: The sorted list of tuples.\n    \"\"\"\n    sorted_list = sorted(tuples, key=lambda x: x[1])\n    \n    return sorted_list", "def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list"]}
{"task_id": 262, "content": ["def transpose(matrix):\n    # The * operator is used to unzip a list (or other iterables), making a list of tuples where each tuple contains the i-th element from each of the argument sequences or iterables.\n    # The zip() function takes iterables, aggregates them in a tuple, and return the result.\n    # In other words, it returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.\n    return [list(i) for i in zip(*matrix)] ", "def simulate_permissions(directory_name: str) -> Tuple[str, List[str]]:\n    # Set the permissions of the directory and its contents to read, write, and execute for all users\n    os.system(f\"chmod -R 777 {directory_name}\")\n    \n    # Change the current working directory to the specified directory\n    os.chdir(directory_name)\n    \n    # Get the final permissions of the directory and its contents\n    permissions = format(os.stat(directory_name).st_mode & 0o777, '03o')\n    \n    # Get the list of files and subdirectories within the directory\n    contents = os.listdir()\n    \n    return permissions, contents", "def related_key_attack(round_keys1, round_keys2):\n    # The related-key attack exploits the fact that the round keys are derived from the cipher key and\n    # the fixed constant. If two cipher keys are related (e.g., one is a simple transformation of the other),\n    # the corresponding round keys will also be related. The attacker can use this relationship to deduce\n    # the original key.\n    \n    # For this simplified example, we'll assume that the related keys are simply the result of XORing\n    # one key with the other. This is a simplified version of the attack and does not represent the full complexity.\n    \n    # Assuming round_keys1 and round_keys2 are lists with a single round key each\n    related_key = round_keys1[0] ^ round_keys2[0]\n    return related_key", "def product_of_sums(lst, target, product=1, index=0):\n    # Check if the list is empty\n    if not lst:\n        return \"Error: List is empty\"\n    \n    # Check if all tuples have been processed\n    if index == len(lst):\n        return product\n    \n    # Check if the element is a tuple with two numbers\n    if not isinstance(lst[index], tuple) or len(lst[index]) != 2:\n        return f\"Error: Element at index {index} is not a tuple of two numbers\"\n    \n    # Check if the tuple contains non-numeric elements\n    if not all(isinstance(x, (int, float)) for x in lst[index]):\n        return f\"Error: Tuple at index {index} contains non-numeric elements\"\n    \n    # Calculate the new product by multiplying the sum of the tuple's elements with the accumulated product\n    new_product = product * sum(lst[index])\n    \n    # Check if the new product exceeds the target product\n    if new_product > target:\n        return product\n    \n    # Recursive call with the new product and the next tuple\n    else:\n        return product_of_sums(lst, target, new_product, index + 1)", "def wrapper_func(list_of_ints, tuple_of_ints):\n    \"\"\"\n    This function takes a list of integers and a tuple of two integers.\n    It uses the erroneous_splice function on each integer in the list, with the tuple values as the delimeter.\n    The results of each operation are stored in a list and returned.\n    \"\"\"\n    results = []\n    for num in list_of_ints:\n        results.append(erroneous_splice([num], tuple_of_ints[0]))\n        results.append(erroneous_splice([num], tuple_of_ints[1]))\n    return results"]}
{"task_id": 263, "content": ["def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]", "def inject_payload(pid, payload):\n    # This function would need to be implemented to attach to the process,\n    # find the system call table, and modify it to point to the custom handler.\n    # This is a complex task that typically requires kernel-level access and\n    # is beyond the scope of a simple Python script.\n    pass", "def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def exchange(lst1, lst2):\n    # Check if total sum of lst1 and lst2 are both even numbers.\n    # If not, return \"NO\" directly because even number of swaps can't make uneven sum to be even.\n    if sum(lst1) % 2 != 0 or sum(lst2) % 2 != 0:\n        return \"No\"\n\n    # If the sum of both lists are even, then check if it's possible to make lst1 to be a list of even numbers.\n    # If an odd number in lst1 is found, then try to find an even number in lst2 to swap. If not found, return \"NO\" directly.\n    for i in range(len(lst1)):\n        if lst1[i] % 2 != 0:\n            has_swap = False\n            for j in range(len(lst2)):\n                if lst2[j] % 2 == 0:\n                    # Swap found, exchange the elements and break the loop.\n                    lst1[i], lst2[j] = lst2[j], lst1[i]\n                    has_swap = True\n                    break\n            if not has_swap:\n                return \"NO\"\n\n    # If all odd numbers in lst1 can find matched even numbers in lst2 to swap, return \"YES\".\n    return \"YES\"", "def find_index_of_first_occurrence(string, character):\n    '''\n    This function will find the index of the first occurrence of a given character in a string.\n\n    Args:\n        string (str): the string to be searched\n        character (str): the character to be searched for\n\n    Returns:\n        int: the index of the first occurrence of the character\n    '''\n    return string.find(character)"]}
{"task_id": 264, "content": ["def transpose_list(lst):\n    \"\"\"\n    This function takes a list as input and transposes all of its elements by\n    one position to the left, maintaining the order of neighboring elements.\n    The last element of the list becomes the first one.\n    \"\"\"\n    if not lst:  # if the list is empty, return it as is\n        return lst\n    last_element = lst.pop()  # remove the last element\n    lst.insert(0, last_element)  # add the removed last element at the first position\n    return lst", "def sum_array(arr):\n    \"\"\"This function will find the sum of all elements in an array using recursion.\"\"\"\n    # if the array is empty, return 0\n    if not arr:\n        return 0\n\n    # get the last element in the array\n    last = arr[-1]\n\n    # find the sum of the remainder of the array\n    remainder_sum = sum_array(arr[:-1])\n\n    # return the sum of the last element and the remainder of the array\n    return last + remainder_sum", "def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def insertion_sort(array, left=0, right=None):\n    if right is None:\n        right = len(array) - 1\n\n    # Loop from the left pointer to the right\n    for i in range(left + 1, right + 1):\n        # This is the element we want to position in its correct place\n        key_item = array[i]\n\n        # Initialize the variable that will be used to find the correct position of the element referenced by `key_item`\n        j = i - 1\n\n        # Run through the list of items (the left portion of the array) and find the correct position\n        # of the element referenced by `key_item`. Do this only if `key_item` is smaller than its adjacent values.\n        while j >= left and array[j] > key_item:\n            # Shift the value one position to the right and reposition j to point to the next element (from right to left)\n            array[j + 1] = array[j]\n            j -= 1\n\n        # When we finish shifting the elements, we can position `key_item` in its correct location\n        array[j + 1] = key_item\n\n    return array", "def remove_elem(string, elem):\n    \"\"\"\n    This function removes a specified element from the given string of words.\n    \n    Parameters:\n    string (str): The input string containing words.\n    elem (str): The element to be removed from the string.\n    \n    Returns:\n    str: The updated string without the specified element.\n    \"\"\"\n    return ' '.join([word for word in string.split() if word != elem])"]}
{"task_id": 265, "content": ["def calculate_cylinder_volume(R, L):\n    # Calculate the volume of the cylinder\n    volume = math.pi * R**2 * L\n    return volume", "    def volume(self):\n        \"\"\"Calculate the volume of the cylinder\"\"\"\n        return 3.14 * self.radius ** 2 * self.height", "def total_cylinder_volume(cylinders):\n    total_volume = 0\n    for cylinder in cylinders:\n        radius = cylinder['radius']\n        height = cylinder['height']\n        volume = math.pi * radius**2 * height\n        total_volume += volume\n    return total_volume", "def compute_volume(cylinders):\n    total_volume = 0\n    for cylinder in cylinders:\n        radius = cylinder['radius']\n        height = cylinder['height']\n        volume = math.pi * (radius ** 2) * height\n        total_volume += volume\n    return total_volume", "def calculate_total_volume_and_surface_area(cylinders, error_correction_factor):\n    total_volume = 0.0\n    total_surface_area = 0.0\n\n    for cylinder in cylinders:\n        volume = math.pi * cylinder['radius']**2 * cylinder['height']\n        surface_area = 2 * math.pi * cylinder['radius'] * (cylinder['radius'] + cylinder['height'])\n\n        total_volume += volume * error_correction_factor\n        total_surface_area += surface_area * error_correction_factor\n\n    return total_volume, total_surface_area"]}
{"task_id": 266, "content": ["def generate_iam_policies(user_behavior_patterns):\n    # This function would use the user behavior patterns to generate IAM policies.\n    # It would return a dictionary with user roles as keys and their corresponding\n    # IAM policy documents as values.\n    iam_policies = {}\n    # Logic to generate IAM policies based on predefined rules\n    return iam_policies", "def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list", "def fractional_sort(input_list):\n    \"\"\"\n    This function sorts a list of numbers in place, based on their fractional part\n    in descending order. Non-numerical values are ignored.\n    \"\"\"\n    # filter out non-numeric values\n    try:\n        new_list = [float(x) for x in input_list]\n    except ValueError:\n        print(\"Invalid input, please enter a list of numbers.\")\n        return \n      \n    # sort the list based on fractional part\n    new_list.sort(key=lambda x: x - int(x), reverse=True)\n    \n    return new_list", "def interpolate_channels(d, channels):\n    \"\"\"\n    Interpolates channel values based on the input channels list and dictionary.\n\n    Args:\n    d (dict): A dictionary containing channel names as keys and corresponding channel values as values.\n    channels (list): A list of channel names.\n\n    Returns:\n    list: Interpolated channel values based on the input channels list.\n    \"\"\"\n    if len(channels) > 1:\n        # Perform interpolation between channel values\n        interpolated_values = perform_interpolation(d, channels)\n        return interpolated_values\n    else:\n        # Return the corresponding channel values from the dictionary\n        return [d[channel] for channel in channels]", "def heuristic_function(canonicalBoard):\n    # Implement your heuristic function here\n    # This function should take the canonicalBoard as input and return a heuristic probability distribution over the valid moves\n    # Example heuristic function:\n    # Calculate heuristic values for each valid move based on the current board state\n    # Normalize the heuristic values to obtain a probability distribution\n    # Return the probability distribution as a list or array\n\n    # Example heuristic function:\n    # Calculate heuristic values for each valid move based on the current board state\n    heuristic_values = calculate_heuristic_values(canonicalBoard)\n    \n    # Normalize the heuristic values to obtain a probability distribution\n    heuristic_distribution = normalize_heuristic_values(heuristic_values)\n    \n    return heuristic_distribution"]}
{"task_id": 267, "content": ["def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def differential_for_key(key, plaintext_difference):\n    # This function would generate a differential for the given key and plaintext difference\n    # In practice, this would involve complex cryptanalysis to find the differential\n    # that results in the desired ciphertext difference\n    return differential", "def generate_input_file():\n    # The input file should be generated in such a way that it produces the maximum product of final[1] and final[3],\n    # and the maximum key in the results dictionary.\n    # To achieve this, the input file should be carefully crafted to produce the desired output when processed by the given function.\n    # The specific details of the input file content and format depend on the logic within the given function, and may require trial and error to determine the optimal input file content.\n\n    # As the exact logic within the given function is not provided, the generation of the input file content involves reverse-engineering the function's behavior and requirements.\n\n    # The solution to this problem involves analyzing the given function's behavior and requirements, and crafting an input file that fulfills those conditions to produce the desired output.\n\n    # Due to the specific nature of the input file content required to achieve the desired output, the exact content and format of the input file cannot be provided without further information about the given function's internal logic and requirements.\n\n    # Therefore, the solution involves understanding the behavior of the given function and crafting an input file that, when processed by the function, produces the maximum product of final[1] and final[3], and the maximum key in the results dictionary.\n\n    # The generation of the input file content may involve experimentation and analysis to determine the optimal values and structure that result in the desired output when processed by the given function.\n\n    # As the specific details of the input file content and format are not provided, the solution involves a process of reverse-engineering and experimentation to determine the appropriate input file content that fulfills the given requirements.\n\n    return \"Generated input file content\"", "def most_frequent_element(lst):\n    # Create a dictionary to keep track of element counts\n    count_dict = {}\n\n    # Iterate through the list and update the counts\n    for element in lst:\n        if element in count_dict:\n            count_dict[element] += 1\n        else:\n            count_dict[element] = 1\n\n    # Find the element with the maximum count that appears at least twice\n    max_count = 0\n    max_element = None\n    for element, count in count_dict.items():\n        if count >= 2 and count > max_count:\n            max_count = count\n            max_element = element\n\n    return max_element"]}
{"task_id": 268, "content": ["def calculate_fibonacci(n):\n    \"\"\"\n    This function calculates the nth number of the Fibonacci sequence using iteration.\n    \n    Parameters:\n        n (int): The number in the Fibonacci sequence to calculate.\n        \n    Returns:\n        The nth number of the Fibonacci sequence.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    a, b = 0, 1\n    for i in range(2, n+1):\n        c = a + b\n        a, b = b, c\n        \n    return b", "def fibonacci_while(n):\n    \"\"\"\n    A function to compute and output the nth Fibonacci number using a while loop.\n    \"\"\"\n    \n    #initialize the first two terms\n    term1 = 0\n    term2 = 1\n    count = 2\n    \n    #check if it is the first or second number\n    if n == 1:\n        return term1\n    elif n == 2:\n        return term2\n    \n    #find the nth term\n    while count < n:\n        nth_term = term1 + term2\n        term1 = term2\n        term2 = nth_term\n        count += 1\n    \n    return nth_term", "def calculate_geometric_mean(num_list):\n    product = 1  # This variable will hold the multiplied result of all numbers in the num_list\n\n    for num in num_list:\n        # Multiply each number in num_list with the product\n        product *= num \n\n    # Calculate the geometric mean by taking the nth root of product\n    # where n is the number of elements in the list.\n    # The math.pow function calculates the power of a number.\n    # Since we need to calculate the nth root, the power is 1/n.\n    geometric_mean = math.pow(product, 1/len(num_list))\n\n    return geometric_mean", "def nth_fibo(n):\n    '''\n    This function finds the nth number in the Fibonacci sequence.\n    \n    Parameters\n    ----------\n    n : int\n        Desired position in the sequence\n    \n    Returns\n    -------\n    int\n        Nth number in the Fibonacci sequence.\n    '''\n    # Initialize variables\n    x = 0\n    y = 1\n    \n    # Iterate through the Fibonacci sequence\n    for _ in range(n-1):\n        x, y = y, x + y\n    \n    # Return the nth number in the Fibonacci sequence\n    return y", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass"]}
{"task_id": 269, "content": ["def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def linear_search(arr, element):\n    \"\"\"Searches for an element in an array using linear search\n    \n    Parameters\n    ------------\n    arr: the array to search in\n    element: the element to search for\n    \n    Returns\n    ------------\n    The index of the element in the array, or -1 if it is not found\n    \"\"\"\n    # search for the element in the array\n    for i in range(len(arr)):\n        if arr[i] == element:\n            return i\n    \n    # element not found\n    return -1", "def binarySearch(array, target):\n    '''This function will implement the binary search algorithm.\n\n    Args:\n        array (list): An array of elements.\n        target (int): The element to search for.\n\n    Returns:\n        int: The index of the target in the given array.\n    '''\n    # Initialize the first and last index variables\n    first = 0\n    last = len(array) - 1\n\n    while first <= last:\n        mid = (first + last) // 2\n\n        # Check if the target is in the middle\n        if array[mid] == target:\n            return mid\n\n        # If the target is greater than the element in the middle,\n        # search for it in the second half of the array\n        elif array[mid] < target:\n            first = mid + 1\n\n        # Else, search for it in the first half of the array\n        else:\n            last = mid - 1\n\n    # Otherwise the target is not present in the list\n    return -1", "def related_words(word, words):\n    \"\"\"\n    Function to get an array of words related to the given word.\n    \n    Parameters: \n    word (str) : The given word.\n    words (list) : The list of words to search in.\n\n    Returns:\n    list : The list of words related to the given word.\n    \"\"\"\n\n    related = []\n    for w in words:\n        if word in w or w in word:\n            related.append(w)\n    return related", "def search(arr, x):\n    \"\"\"This function searches for the given element in the given array\"\"\"\n    for i in range(len(arr)):\n        if arr[i] == x:\n            return i\n    return -1"]}
{"task_id": 270, "content": ["def odd_sum_prime_index_elements(x):\n    \"\"\"Given a list of positive integers x, construct a sorted list in ascending order that only includes unique items which, when their digits are added together, yield an odd number, and are situated at prime indexed locations in the input list. The indices of the resultant list must also be prime numbers. If the elements at the prime indices are not numbers, return \"Non-numeric elements found\". If x is not a list, returns \"Input is not a list\".", "def remove_duplicates(input_list):\n    '''\n    This function removes the duplicate elements from a given list \n    and returns a new list of unique elements.\n    '''\n    unique_elements = [] \n    for element in input_list: \n        # Check if element exists in unique_element list, \n        # if not then append it \n        if element not in unique_elements: \n            unique_elements.append(element) \n    return unique_elements", "def manipulate_variables(b, num_list):\n    # check if variable is a number\n    if not (isinstance(b, int) or isinstance(b, float)):\n        return \"Error: The variable is not a number.\"\n\n    # check if second argument is a list\n    if not isinstance(num_list, list):\n        return \"Error: Second argument is not a list.\"\n    \n    # check if list is empty\n    if not num_list:\n        return \"Error: The list is empty.\"\n\n    # check if all elements in the list are integers\n    if not all(isinstance(num, int) for num in num_list):\n        return \"Error: The list contains non-integer elements.\"\n    \n    # calculate the sum of elements in the list with the given variable\n    total_sum = sum(num_list) + b\n\n    return total_sum", "def get_unique_elements(a, b):\n    # Create a set from list b for faster lookup\n    b_set = set(b)\n    \n    # Initialize an empty list to store unique elements\n    unique_elements = []\n    \n    # Iterate through each element in list a\n    for element in a:\n        # Check if the element is not in set b\n        if element not in b_set:\n            # Add the element to the list of unique elements\n            unique_elements.append(element)\n    \n    # Sort the list of unique elements in ascending order\n    unique_elements.sort()\n    \n    # Return the list of unique elements\n    return unique_elements", "def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers."]}
{"task_id": 271, "content": ["def add_squared_values(lst):\n    # Apply math.ceil function to take ceiling value of absolute of each number in the list.\n    # Then square and sum them up.\n    return sum(map(lambda x: math.ceil(abs(x)) ** 2, lst))", "def find_permutations(arr):\n    # itertools.permutations method returns all permutations \n    # of the given list arr of length len(arr).\n    # Each permutation is a tuple so we use map function \n    # to convert these tuples to lists\n    perm = list(map(list, itertools.permutations(arr)))\n    \n    # Return the generated permutations\n    return perm", "def combineAndSortTwoLists(list1, list2):\n    # Combining the two lists and passing it to merge_sort function\n    combined_list = list1 + list2\n    return merge_sort(combined_list)", "def delete_idle_lambda(region_name):\n    \"\"\"\n    This function deletes idle AWS Lambda functions in a particular region.\n    :param region_name: str\n    :return: None\n    \"\"\"\n    # Create a session using boto3\n    session = boto3.Session(region_name=region_name)\n\n    # Connect to AWS Lambda service\n    lambda_client = session.client('lambda')\n\n    try:\n        # Get the list of all functions\n        functions = lambda_client.list_functions()\n\n        # Loop through each function\n        for function in functions['Functions']:\n            function_name = function['FunctionName']\n\n            # Here, we need to determine if the function is idle\n            # If the function is idle, we delete it\n            # Please replace `is_function_idle` with your actual check\n            if is_function_idle(function):\n                lambda_client.delete_function(FunctionName=function_name)\n                print(f\"Deleted function: {function_name}\")\n\n    except NoCredentialsError:\n        print(\"No AWS credentials were found.\")\n    except ClientError as e:\n        if e.response['Error']['Code'] == 'ResourceNotFoundException':\n            print(\"The specified lambda function does not exist.\")\n        else:\n            raise e", "def apply_function(arr, f):\n    \"\"\"\n    Apply a given function to each item of an input array.\n    \n    Args:\n        arr (list): The input array.\n        f (function): The function to be applied.\n        \n    Returns:\n        list: A list with the result of applying function f to each item of arr.\n    \"\"\"\n    return list(map(f, arr))"]}
{"task_id": 272, "content": ["def even_digit_detector(number):\n    # Convert the number into a string to be able to iterate over each digit\n    number = str(number)\n\n    # Create an empty list to store whether each digit is even or not\n    even_digits = []\n\n    # For each digit in the number\n    for digit in number:\n        # If the digit is even\n        if int(digit) % 2 == 0:\n            # Add True to the list\n            even_digits.append(True)\n        else:\n            # Otherwise, add False to the list\n            even_digits.append(False)\n\n    return even_digits", "def isArmstrong(num):\n    # To store the sum of the power of each digit\n    sum_digits = 0\n\n    # Find the number of digits\n    digits = len(str(num))\n\n    # Go through each digit\n    temp = num\n    while temp > 0:\n        digit = temp % 10\n\n        # Raise it to the power of the number of digits\n        sum_digits += digit ** digits\n\n        temp //= 10\n\n    # Check if sum of the digits raised to the power is\n    # equal to the original number\n    return num == sum_digits", "def is_armstrong_number(num):\n    # Convert the number to a string\n    num_str = str(num)\n    \n    # Get the length of the number\n    length = len(num_str)\n    \n    # Calculate the sum of powers of each digit\n    armstrong_sum = sum(int(digit) ** length for digit in num_str)\n    \n    # Check if the calculated sum is equal to the given number\n    return armstrong_sum == num", "def is_armstrong_number(num: int) -> bool:\n    # Check if the input is a non-integer\n    if not isinstance(num, int):\n        return False\n\n    # Check if the number is outside the range of -1,000,000 to 1,000,000\n    if num < -1000000 or num > 1000000:\n        return False\n\n    # Convert the number to a string to access individual digits\n    num_str = str(num)\n\n    # Check if the number is negative\n    if num < 0:\n        # Exclude the negative sign from the string and convert the remaining digits back to integers\n        digits = [int(digit) for digit in num_str[1:]]\n    else:\n        digits = [int(digit) for digit in num_str]\n\n    # Calculate the number of digits in the number\n    num_digits = len(digits)\n\n    # Raise each digit to the power of the number of digits and sum them\n    digit_sum = sum([digit ** num_digits for digit in digits])\n\n    # Check if the sum exceeds 1,000,000\n    if digit_sum > 1000000:\n        return False\n\n    # Check if the sum is equal to the original number\n    if digit_sum == num:\n        return True\n\n    return False", "def same_frequency(num1, num2):\n    digit_count1 = [0] * 10\n    digit_count2 = [0] * 10\n\n    # Count the frequency of each digit in num1\n    while num1 > 0:\n        digit = num1 % 10\n        digit_count1[digit] += 1\n        num1 //= 10\n\n    # Count the frequency of each digit in num2\n    while num2 > 0:\n        digit = num2 % 10\n        digit_count2[digit] += 1\n        num2 //= 10\n\n    # Check if the frequency of each digit is the same in both numbers\n    for i in range(10):\n        if digit_count1[i] != digit_count2[i]:\n            return False\n\n    return True"]}
{"task_id": 273, "content": ["def check_unique_strings(strings):\n    '''This function takes a list of strings and returns a boolean \n    indicating whether all the strings in the list are unique.'''\n    seen = set()\n    for string in strings:\n        if string in seen:\n            return False\n        seen.add(string)\n    return True", "def is_palindrome(s): \n    '''This function returns True or False based on whether the given string is a palindrome or not'''\n    # reverse the string\n    rev = s[::-1] \n  \n    # Check if string is equal to its reverse \n    if (s == rev): \n        return True\n    return False", "def process_elevation_marker_views(items):\n    \"\"\"\n    Processes elevation marker views based on the input type.\n\n    Args:\n    items: A single item or a list of items.\n\n    Returns:\n    If the input is a list, returns a new list containing the results of applying the GetElevationMarkerView function to each item in the input list.\n    If the input is not a list, returns the result of applying the GetElevationMarkerView function to the single input item.\n    \"\"\"\n    if isinstance(items, list):\n        return [GetElevationMarkerView(x) for x in items]\n    else:\n        return GetElevationMarkerView(items)", "def generate_canonical_smiles(molecule, isomeric, explicit_hydrogens, mapped, central_bond):\n    \"\"\"\n    Generate the canonical SMILES representation for the given molecule with specified options.\n\n    Args:\n    molecule: The input molecule object.\n    isomeric: A boolean indicating whether to include isomeric information in the SMILES.\n    explicit_hydrogens: A boolean indicating whether to include explicit hydrogen atoms in the SMILES.\n    mapped: A boolean indicating whether to include mapped atom information in the SMILES.\n    central_bond: A tuple representing the central bond to be set if certain conditions are met.\n\n    Returns:\n    A string representing the canonical SMILES for the given molecule with the specified options.\n    \"\"\"\n    if central_bond:\n        molecule.central_bond = central_bond\n\n    canonical_smiles = molecule.to_smiles(isomeric=isomeric, explicit_hydrogens=explicit_hydrogens, mapped=mapped)\n    return canonical_smiles", "def find_words_with_fr(string):\n    '''\n    This function will find all words containing the letters \"fr\" in a given string.\n    \n    Args:\n        string (str): the string to be searched\n    \n    Returns:\n        list: a list of all words containing the letters \"fr\"\n    '''\n    regex = r\"\\b\\w*fr\\w*\\b\"\n    return re.findall(regex, string)"]}
{"task_id": 274, "content": ["def add_numbers(a, b):\n    \"\"\"Function that takes two numbers as parameters and returns an object with the two arguments and the sum of them.\"\"\"\n    # create an object that includes a, b and their sum\n    obj = {\"a\": a, \"b\": b, \"sum\": a + b}\n    return obj", "def compare_numbers(a, b):\n  \"\"\"Compare two numbers and returns a string that defines their relationship.\"\"\"\n  if a < b:\n    return 'inferior'\n  elif a > b:\n    return 'supreme'\n  else:\n    return 'congruent'", "def replace_suffix(filename, new_suffix):\n    # We match either '_a' or '.' followed by anything that's not a dot, all the way till the end of the string.\n    # The extension is captured in a group by surrounding it with parentheses.\n    pattern = r'(_a)?(\\.[^.]*$)'\n\n    # In the replacement string, we add the new suffix followed by '\\\\2', which refers to the second group in the pattern.\n    replacement = '_{}\\\\2'.format(new_suffix)\n\n    # Use re.sub to replace the pattern in the filename with the replacement string.\n    new_filename = re.sub(pattern, replacement, filename)\n\n    return new_filename", "def copy_stream(input_stream, output_stream, buffer_size=1024*1024):\n    \"\"\"\n    Copy one stream to another.\n\n    input_stream: a file-like object that has a `read` method.\n    output_stream: a file-like object that has a `write` method.\n    buffer_size: the size of the chunks to read and write.\n    \"\"\"\n    while True:\n        data = input_stream.read(buffer_size)\n        if not data:\n            break\n        output_stream.write(data)", "def match_hex_vowel(string):\n    # This regex matches a hexadecimal number followed by either a lower-case or upper-case vowel.\n    find_hex = re.compile(r'^[0-9A-Fa-f]+[aeiouAEIOU]$')\n    match = find_hex.match(string)\n    return match"]}
{"task_id": 275, "content": ["def add_sum(arr):\n    result = []  # Create an empty list to store the modified array\n    sum = 0  # Initialize a variable to store the sum of even elements\n\n    for num in arr:  # Iterate through each number in the given array\n        if num % 2 == 0:  # Check if the number is even\n            sum += num  # Add the even number to the sum\n\n    result.append(sum)  # Append the sum of even elements to the beginning of the modified array\n    result.extend(arr)  # Extend the modified array with the original array\n\n    return result  # Return the modified array", "def max_sum_subarray(array):\n    \"\"\"\n    This function will find the maximum sum of a contiguous subarray.\n    \n    Parameters:\n    array: list of integers\n    \n    Returns:\n    maximum sum of contiguuous subarray\n    \"\"\"\n    # Initialize the max sum and current sum to the start of the array\n    max_sum = current_sum = array[0]\n    \n    # Iterate over the array\n    for num in array[1:]:\n        # Reset the current sum to 0 if it is negative\n        current_sum = max(0, current_sum + num)\n        max_sum = max(current_sum, max_sum)\n    \n    return max_sum", "def find_kth_largest(arr, k):\n    \"\"\"\n    Function to find the kth largest element in an array\n    \"\"\"\n    \n    # make a copy of the array\n    arr_copy = arr[:]\n    \n    # get the length of the array\n    length = len(arr_copy)\n    \n    # if k is greater than or equal to the length of the array, return the maximum element\n    if k >= length:\n        return max(arr_copy)\n        \n    # sort the array in descending order\n    arr_copy.sort(reverse=True)\n    \n    # get the kth element from the sorted array\n    kth_largest = arr_copy[k-1]\n    \n    return kth_largest", "def find_max(arr):\n    \"\"\"\n    Function to find the largest numerical value in an array. \n\n    Parameters:\n    arr (list): The list of integers.\n  \n    Returns:\n    max_val (int): The largest numerical value in the array.\n  \n    \"\"\"\n    \n    # Step 1: Initialize a variable max_val with the value at the 0th index in the array\n    max_val = arr[0]\n\n    # Step 2: Iterate over each element in the array from 1 to n-1\n    for i in range(1, len(arr)):\n        # Step 3: If the value at the current index in the array is greater than max_val, update max_val\n        if arr[i] > max_val:\n            max_val = arr[i]\n\n    # Step 4: Return max_val, which now holds the largest numerical value in the array\n    return max_val", "def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers."]}
{"task_id": 276, "content": ["def sum_of_squares(n):\n    # Initialize the sum of squares\n    sum_squares = 0\n    \n    # Calculate the sum of squares of the first n natural numbers\n    for i in range(1, n+1):\n        sum_squares += i**2\n    \n    return sum_squares", "def calculate_difference(n):\n    # Calculate the square of the sum of the first n natural numbers\n    square_of_sum = ((n * (n + 1)) // 2) ** 2\n    \n    # Calculate the sum of the squares of the first n natural numbers\n    sum_of_squares = (n * (n + 1) * ((2 * n) + 1)) // 6\n    \n    # Calculate the difference\n    difference = square_of_sum - sum_of_squares\n    \n    return difference", "def triangle_square_sum(n):\n    \"\"\"\n    Function to calculate the sum of the Triangle Series and the sum of the square of each\n    number in the Triangle Series up to n.\n    \"\"\"\n    # error handling: if n is negative or not an integer\n    if not isinstance(n, int) or n < 1:\n        return \"Error: Input must be an positive integer\"\n\n    # calculate the sum of the Triangle Series\n    # formula for the sum of the first n natural numbers is n*(n+1)/2\n    triangle_sum = n * (n + 1) // 2  # use integer division to ensure result is an integer\n\n    # calculate the sum of the square of each number in the Triangle Series up to n.\n    # formula for the sum of the squares of the first n natural numbers is n*(n+1)*(2n+1)/6\n    square_sum = n * (n + 1) * (2 * n + 1) // 6  # use integer division to ensure result is an integer\n\n    return triangle_sum, square_sum", "def sum_of_squares(arr):\n    \"\"\"\n    Calculate the sum of the squares of the given array of numbers.\n\n    Args:\n    arr: A list or array of numbers.\n\n    Returns:\n    The sum of the squares of the input numbers.\n    \"\"\"\n    return sum(x**2 for x in arr)", "def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) "]}
{"task_id": 277, "content": ["def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers.", "def SieveOfEratosthenes(n): \n  \n    # Create a boolean array \"prime[0..n]\" and initialize\n    # all entries it as true. A value in prime[i] will \n    # finally be false if i is Not a prime, else true.\n    prime = [True for i in range(n+1)]\n    p = 2\n    \n    # Loop until p^2 is less than or equal to n\n    while (p * p <= n): \n  \n        # If prime[p] is not changed, then it is a prime \n        if (prime[p] == True): \n  \n            # Update all multiples of p\n            for i in range(p * p, n+1, p): \n                prime[i] = False\n        p += 1\n    \n    # Print all prime numbers \n    for p in range(2, n+1): \n        if prime[p]: \n            print(p)", "def sieve_eratosthenes(N):\n    \"\"\"\n    This function uses the Sieve of Eratosthenes algorithm to generate all prime numbers up to N.\n    The function returns a generator that yields the prime numbers one by one, allowing for memory-efficient processing of large ranges.\n\n    The function also includes a check to ensure the input is an integer greater than one and raises a custom exception if it is not.\n\n    :param N: The upper limit of the range to search for primes. Must be an integer greater than one.\n    :returns: A generator that yields the prime numbers up to N one by one.\n    :raises ValueError: If N is not an integer or is less than or equal to one.\n    \"\"\"\n    if not isinstance(N, int) or N <= 1:\n        raise ValueError(\"Input must be an integer greater than one.\")\n    primes = [True for _ in range(N+1)]\n    p = 2\n    while p * p <= N:\n        if primes[p]:\n            for i in range(p * p, N + 1, p):\n                primes[i] = False\n        p += 1\n    for p in range(2, N):\n        if primes[p]:\n            yield p", "def sieve_of_eratosthenes(limit):\n    # Create a boolean array \"prime[0..limit]\" and initialize all entries as True.\n    # A value in prime[i] will finally be False if i is not a prime, else True.\n    prime = [True] * (limit+1)\n    \n    # 0 and 1 are not prime numbers, so we set their flags to False.\n    prime[0] = prime[1] = False\n    \n    p = 2  # Start with the first prime number\n    \n    while p * p <= limit:\n        # If prime[p] is not changed, then it is a prime\n        if prime[p] == True:\n            # Update all multiples of p\n            for i in range(p * p, limit+1, p):\n                prime[i] = False\n        p += 1\n    \n    # Return a list of all prime numbers\n    primes = [num for num, is_prime in enumerate(prime) if is_prime]\n    \n    return primes"]}
{"task_id": 278, "content": ["def get_first_day(year, week):\n    # Create a date object for the first day of the year\n    first_day = datetime.date(year, 1, 1)\n    \n    # Python's date.weekday() function considers Monday as 0 and Sunday as 6. \n    # So if the year starts on a Monday, we want to add no extra days. \n    # If it starts on a Tuesday (weekday == 1), we want to add 6 days. \n    # If it starts on a Wednesday (weekday == 2), we want to add 5 days, and so on.\n    days_to_add = (week-1)*7 - first_day.weekday()\n    \n    if first_day.weekday() > 3: \n        # If the year starts on a Thursday, Friday, Saturday or Sunday, \n        # then week 1 will be the week after this one, \n        # so we need to add 7 more days\n        days_to_add += 7\n\n    # Add the necessary number of days to the first day of the year\n    result_date = first_day + datetime.timedelta(days=days_to_add)\n    \n    return result_date", "def get_days(month, year):\n    # Validate year\n    if year < 1900:\n        return \"Year must be 1900 or later.\"\n\n    # Validate month\n    months = [\n        \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n        \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n    ]\n    if month not in months:\n        return \"Invalid month.\"\n\n    # Trivially calculate days in a month\n    month_number = months.index(month) + 1  # Converts month name to month number\n    days = calendar.monthrange(year, month_number)[1]  # Gets the number of days in the month\n\n    return days", "def calculate_total_days(start_year, end_year):\n    totalDays = 0\n    \n    # Calculate the number of leap years in the range\n    for year in range(start_year, end_year + 1):\n        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):\n            totalDays += 1\n    \n    # Calculate the number of non-leap years in the range\n    num_years = end_year - start_year + 1\n    num_non_leap_years = num_years - totalDays\n    totalDays += num_non_leap_years\n    \n    # Calculate the total number of days in the range\n    totalDays += 365\n    \n    return totalDays", "def find_day_month_year(year, month):\n    # Checking if the year is in the provided range\n    if year < 1900 or year > 2100:\n        print(\"Year should be in the range of 1900 and 2100.\")\n        return\n\n    # Getting the number of days in a month and the day of the week of the first day\n    week_day, num_days = calendar.monthrange(year, month)\n\n    first_day = calendar.day_name[week_day]\n    last_day = calendar.day_name[(week_day+num_days%7)%7]\n\n    month_name = calendar.month_name[month]\n\n    print(f'{month_name} {year} has {num_days} days.')\n    print(f'The first day of {month_name} {year} is {first_day}.')\n    print(f'The last day of {month_name} {year} is {last_day}.')", "def num_days_in_month(month, year):\n    \"\"\"\n    Return the number of days in the given month and year\n    \"\"\"\n    days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if month == 2 and ((year % 4 == 0) and (year % 100 != 0) or (year % 400 == 0)):\n        return 29\n    return days[month-1]"]}
{"task_id": 279, "content": ["def longest_fruit(array):\n  maxlen = max(len(x) for x in array)  # Find the maximum length of strings in the list\n  maxfruit = [x for x in array if len(x) == maxlen]  # Create a list of all strings with maximum length\n  return maxfruit", "def longest_str(lst):\n    max_len = max(len(word) for word in lst)   # Find the maximum length of a word in the list\n    results = [word for word in lst if len(word) == max_len] # Create a list with words that have the maximum length\n    return results", "def zip_first(*lists):\n    # Find the length of the first list\n    first_len = len(lists[0])\n\n    # Use zip_longest to fill in None for missing values\n    zipped_longest = zip_longest(*lists)\n\n    # Use islice to cut the zipped_longest at the length of the first list\n    return list(itertools.islice(zipped_longest, first_len))", "def find_max(a, b, c):\n    \"\"\"\n    A function to find the maximum of three numbers.\n    \"\"\"\n    # Find the maximum of the three numbers\n    max_value = max(a, b, c)\n    \n    return max_value", "def longest_increasing_subsequence(sequence):\n    \"\"\"\n    This function uses dynamic programming to find the longest increasing subsequence in the input array. \n\n    Firstly, we initialize the list length with size as input array size. Each element in length represents the longest \n    increasing subsequence in sequence[0...i]. After initializing the list length with 1, the function fills length in \n    a bottom-up manner(using dynamic programming), i.e., if sequence[j] > sequence[i] for some i < j and length[j] < length[i] + 1,\n    then update length[j].\n\n    Finally, the function returns the maximum value from the list length.\n\n    :param sequence: An input array of integers\n    :type sequence: list\n    :return: The longest increasing subsequence in the array\n    :rtype: int\n    \"\"\"\n\n    # initialize the list length with 1's because a minimum increasing subsequence would just be one number itself\n    length = [1] * len(sequence)\n\n    # loop over the sequence from the second element\n    for i in range(1, len(sequence)):\n        # consider all smaller elements found so far\n            for j in range(i):\n                # if this element is bigger, check if we can increase the length of the largest subsequence ending at i\n                if sequence[i] > sequence[j] and length[i] < length[j] + 1:\n                    length[i] = length[j] + 1\n\n    # return the maximum length found\n    return max(length)"]}
{"task_id": 280, "content": ["def configurations(n):\n    # colors representing lengths of tiles\n    colors = [2, 3, 4]\n\n    # list to hold total sum for each length\n    sums = [1] + [0]*n\n\n    # iterate for each type of tile\n    for color in colors:\n        # iterate length of tile\n        for j in range(color, n+1): \n            # add to the total number of ways\n            sums[j] += sums[j - color]\n\n    # subtract 1 to remove the scenario where no coloured tiles are used.\n    return sums[n] - 1", "    def get_nearest_color(self, color):\n        # Implement logic to find the nearest color for cross-stitch pattern\n        # This could involve quantization or clustering algorithms to reduce the number of colors\n        # Return the nearest color for the cross-stitch pattern\n        pass", "def get_context_data(self, **kwargs):\n    \"\"\"Add user's posts to context\"\"\"\n    context = super().get_context_data(**kwargs)\n    user = context['user']  # Retrieve the user object from the context\n    posts = user.post_set.all()  # Assuming a related Post model, retrieve all posts associated with the user\n    context['posts'] = posts  # Add the user's posts to the context under the key 'posts'\n    return context", "def ways_to_fill(length):\n    # Initialize the list that keeps the number of ways for each length.\n    ways = [1, 1, 1, 1] + [0] * (length - 3) \n    for i in range(4, length + 1):\n        # ways to fill length i if no new block is added at the end\n        ways[i] += ways[i-1]\n        # ways to fill length i if a new block of size 4 is added at the end\n        ways[i] += ways[i-4]\n        for j in range(0, i - 4):  \n            # ways to fill length i if a new block of size greater than 4 \n            # is added at the end\n            ways[i] += ways[j]\n    return ways[length]", "def get_public_posts(site_url):\n    # Step 1: Make a GET request to the WordPress REST API endpoint that retrieves all posts on the site\n    api_url = f\"{site_url}/wp-json/wp/v2/posts\"\n    response = requests.get(api_url)\n\n    # Step 2: Filter the retrieved posts to include only those that are publicly accessible\n    public_posts = [post for post in response.json() if post['status'] == 'publish']\n\n    # Step 3: Sort the filtered posts alphabetically by title\n    sorted_posts = sorted(public_posts, key=lambda post: post['title']['rendered'])\n\n    # Step 4: Extract the title and permalink of each post and store them in a list of tuples\n    post_list = [(post['title']['rendered'], post['link']) for post in sorted_posts]\n\n    # Step 5: Return the list of tuples\n    return post_list"]}
{"task_id": 281, "content": ["def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min", "def calc(a, b):\n    \"\"\"Calculate the sum, difference, product, and quotient for two numbers.\"\"\"\n    sum = a + b\n    difference = a - b\n    product = a * b\n    quotient = a / b\n    return sum, difference, product, quotient", "def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def divide(dividend, divisor):\n    \"\"\"\n    Divide two integers and return the quotient and remainder.\n\n    Args:\n        dividend (int): The number to be divided.\n        divisor (int): The number to divide by.\n\n    Returns:\n        tuple: A tuple containing the quotient and remainder.\n    \"\"\"\n    quotient = dividend // divisor\n    remainder = dividend - quotient * divisor\n    return quotient, remainder", "def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]"]}
{"task_id": 282, "content": ["def pythagorean_check_and_area(a, b, c):\n    # Sort the sides to make sure c is the longest side (hypotenuse)\n    sides = sorted([a, b, c])\n    \n    # Check right angled triangle condition\n    if sides[0]**2 + sides[1]**2 == sides[2]**2:\n        print(\"It's a right-angled triangle.\")\n        \n        # Area calculation for right angled triangle: 1/2 * base * height\n        area = 0.5 * sides[0] * sides[1]\n        print(\"Area of the triangle is\", area, \"square units.\")\n        \n    else:\n        print(\"It's not a right-angled triangle.\")", "def area_of_right_triangle(base, height):\n    \"\"\"\n    Calculate the area of a right angled triangle\n\n    Parameters:\n    base (float): The length of the base of the triangle\n    height (float): The height of the triangle\n\n    Returns:\n    float: The calculated area of the triangle\n    \"\"\"\n    return (1/2) * base * height", "def classify_triangle(a, b, c):\n    '''\n    Function to classify the type of triangle based on its three side lengths\n    \n    Parameters\n    a: length of side 1\n    b: length of side 2\n    c: length of side 3\n    \n    Returns\n    type of triangle (scalene, isosceles, equilateral)\n    '''\n    if a == b and b == c:\n        return 'Equilateral'\n    elif a == b or b == c or c == a:\n        return 'Isosceles'\n    else:\n        return 'Scalene'", "def get_triangle(radius):\n    # The largest inscribed triangle in a semicircle is equilateral triangle.\n    # The length of the triangle's side equals the semicircle's diameter.\n\n    # Hence, the coordinates of the vertices of the triangle are:\n    a = (-radius, 0)\n    b = (radius, 0)\n    c = (0, radius)\n\n    # The area of an equilateral triangle is computed using the formula: (s^2 * sqrt(3)) / 4\n    # where s is the side length of the triangle. \n    # The side length of our triangle is twice the radius (which is the diameter of the semicircle).\n    area = ((2*radius)**2 * math.sqrt(3)) / 4\n    \n    # The perimeter of an equilateral triangle is 3 times its side.\n    # The side length of our triangle is twice the radius (which is the diameter of the semicircle).\n    perimeter = 3 * (2*radius)\n\n    return area, a, b, c, perimeter", "def isRightTriangle(a, b, c): \n    # Square of the two smaller sides \n    square1 = a*a + b*b \n  \n    # Square of the biggest side \n    square2 = c*c \n  \n    # Condition to determine whether the  \n    # triangle is a right triangle or not \n    if (square1 == square2): \n        return True\n    return False"]}
{"task_id": 283, "content": ["def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def calculate_maximum(numbers):\n    \"\"\"\n    Find the maximum value in the given list of numbers.\n\n    :param numbers: List of numbers\n    :return: Maximum value\n    \"\"\"\n    return max(numbers)", "def find_max(numbers):\n    \"\"\"\n    Find the maximum value in a list of numbers.\n\n    Args:\n    numbers (list): A list of numbers.\n\n    Returns:\n    float: The maximum value in the input list.\n    \"\"\"\n    if not numbers:\n        return None\n    return max(numbers)", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def find_max_index(nums):\n    \"\"\"\n    Returns the index of the maximum value in the list.\n    \n    Args:\n    nums: A list of integers\n    \n    Returns:\n    int: Index of the maximum value in the list, or -1 if the list is empty\n    \"\"\"\n    if not nums:  # Check if the list is empty\n        return -1\n    else:\n        max_val = max(nums)  # Find the maximum value in the list\n        return nums.index(max_val)  # Return the index of the maximum value"]}
{"task_id": 284, "content": ["def sum_even_divisors(n):\n    \"\"\"Computes the sum of all even divisors of a given number.\"\"\"\n    sum = 0\n    for i in range(2, n):\n        if (n % i == 0 and i % 2 == 0):\n            sum += i\n    return sum", "def add_digits(number):\n    \"\"\"This function adds all the digits of a given number \n    and returns the result.\n    \n    Args:\n        number (int): The number to process.\n    \n    Returns:\n        int: The result of adding all the digits of the given number.\n    \"\"\"\n    if number < 10:\n        return number\n    total = number % 10 + add_digits(number // 10)\n    return total", "def sum_divisors(n):\n    '''Returns the sum of all divisors of the given number.'''\n    if n <= 1:\n        return 0\n    #assume n is a positive integer\n    sum_divisors = 1\n    for i in range(2, int(n/2)+1):\n        if n % i == 0:\n            sum_divisors += i\n    return sum_divisors", "def check_divisors(original, divisors):\n    if type(original) != int or original < 1:\n        raise ValueError('Input must be a positive integer')\n\n    if not all(isinstance(i, int) for i in divisors):\n        raise ValueError('Divisors should be integers')\n\n    product = reduce(mul, divisors, 1)\n    \n    if product != original:\n        return f\"Error: The product of divisors is {product}, which does not equal the original number {original}.\"\n    else:\n        return f\"Success: The product of divisors is {product}, equal to the original number {original}.\"", "def isPerfect(num):\n    \n    # Initialize sum \n    sum = 0\n      \n    for i in range(1, num): \n        if (num % i == 0): \n            sum += i \n  \n    # If sum of divisors equals to number then \n    # number is perfect \n    if (sum == num): \n        return (\"The number is a perfect number\") \n    else: \n        return (\"The number is not a perfect number\") "]}
{"task_id": 285, "content": ["def count_frequency(lst, digit):\n    '''Function to determine and count the frequency of a digit in an array.'''\n    count = 0\n    for v in lst:\n        if v == digit:\n            count += 1\n    return count", "def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]", "def frequencySort(nums):\n    # collections.Counter(nums) gives the frequency of each element in the nums array.\n    # items() function returns a view object that displays a list of a dictionary's(an iterable) tuple pair (key, value).\n    c = Counter(nums).items()\n    # Then we will sort the results by the tuple (-count, num). Negative count ensures that high frequency elements come first in the sorted list.\n    # This satisfies the requirement to sort in increasing frequency. \n    # Because we use num for sort as well, elements with the same frequency are sorted in descending order.\n    # This satisfies the requirement to sort in decreasing order on the basis of value of the numbers in case of same frequency.\n    # idx is used to sort elements in increasing order of their index in case elements are same and have same frequency.\n    # sort function of python is stable. i.e, it maintains the relative order of items with equal sort keys\n    nums.sort(key = lambda x: (nums.count(x), -x, [i for i, n in enumerate(nums) if n == x][0]))\n    # return the sorted array\n    return nums", "def secure_communication():\n    # This is a placeholder function. In practice, you would use Python libraries such as PyCrypto or PyNaCl\n    # to encrypt the communication with the C2 server.\n    pass", "def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None"]}
{"task_id": 286, "content": ["def flatten(lst):\n    \"\"\"Helper function to flatten a nested list\"\"\"\n    return [item for sublist in lst for item in flatten(sublist)] if isinstance(lst, list) else [lst]", "def flatten(lst):\n    # Helper function to flatten a nested list\n    flattened = []\n    for item in lst:\n        if isinstance(item, list):\n            flattened.extend(flatten(item))\n        else:\n            flattened.append(item)\n    return flattened", "def flatten(lis):\n    \"\"\"Function to flatten an arbitrarily nested list.\"\"\"\n    for item in lis:\n        if isinstance(item, list):\n            for x in flatten(item):\n                yield x\n        else: yield item", "def check_lists(A, B):\n    \"\"\"Checks if all items in potentially nested list Bare in list A.\"\"\"\n    # Flatten B\n    flattened_B = flatten(B)\n    # Check membership\n    return all(item in A for item in flattened_B)", "def nested_common(list1, list2):\n    \"\"\"Function to extract nested common elements.\"\"\"\n    list1_flat = set(flatten(list1))\n    list2_flat = set(flatten(list2))\n    \n    common = list1_flat.intersection(list2_flat)\n    \n    return list(common)"]}
{"task_id": 287, "content": ["def list_intersection(l1: list, l2: list) -> list:\n    # Using dictionary to store elements in list1\n    dict_list1 = {i: True for i in l1}\n    # Checking elements of list2 in dictionary and storing common elements in another dictionary\n    common_elements = {i: True for i in l2 if i in dict_list1}\n    # Sorting and returning the keys which are the common elements\n    return sorted(common_elements.keys())", "def find_overlapping_elements(list1, list2):\n    result = []\n    \n    # Iterate over elements in list1\n    for item in list1:\n        # Check if item is also present in list2\n        if item in list2:\n            result.append(item)\n        # Check if item is a list\n        if isinstance(item, list):\n            # Recursively call the function for the nested list\n            nested_result = find_overlapping_elements(item, list2)\n            # Extend the result list with the nested result\n            result.extend(nested_result)\n    \n    return result", "def vowel_count(text):\n    # All the vowels\n    vowels = 'aeiouAEIOU'\n\n    # Using list comprehension to get the count.\n    # The expression 'char in vowels' will be True if the character is a vowel.\n    # So, we are making a list of True for all characters in the text which are vowels.\n    # Finally we are returning the sum of the list which gives us the count of True in the list\n    # which is equal to the count of vowels in the text.\n    return sum(char in vowels for char in text)", "def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list", "def is_item_in_list(item, my_list):\n    '''This function checks if an item exists in a given list and returns a boolean value.\n    Parameters\n    ----------\n    item: The item to be checked.\n    my_list: The list in which the item is to be checked. \n    \n    Returns\n    --------\n    boolean: True if the item is present in the list, and False if it is not.\n    '''\n\n    return item in my_list"]}
{"task_id": 288, "content": ["def calculate_aggregate_unique_elements(lst):\n    # Transform the list into a set to get unique elements.\n    # The sum function calculates the aggregate of unique elements.\n    aggregate = sum(set(lst))\n  \n    # The len function returns the quantity of unique elements.\n    quantity = len(set(lst))\n\n    return aggregate, quantity", "def transpose(matrix):\n    # The * operator is used to unzip a list (or other iterables), making a list of tuples where each tuple contains the i-th element from each of the argument sequences or iterables.\n    # The zip() function takes iterables, aggregates them in a tuple, and return the result.\n    # In other words, it returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.\n    return [list(i) for i in zip(*matrix)] ", "def sort_by_second_item(tuples):\n    \"\"\"Sorts a list of tuples by the second item in the tuples.\n    \n    Args:\n        tuples: A list of tuples to be sorted.\n        \n    Returns:\n        sorted_list: The sorted list of tuples.\n    \"\"\"\n    sorted_list = sorted(tuples, key=lambda x: x[1])\n    \n    return sorted_list", "def rolling_max(arr):\n    \"\"\"\n    This function takes an array of positive integers and\n    returns a new array where each element from index 0 to \n    n is the maximum element from the original array from\n    index 0 to n.\n\n    If there's a negative number in the array, the function returns an empty list.\n    \n    Args:\n        arr (List[int]): a list of integers.\n\n    Returns:\n        List[int]: a list of maximum numbers. \n        If input list contains negative number, an empty list is returned\n    \"\"\"\n    \n    max_num = float('-inf')\n    result = []\n    \n    for number in arr:\n        if number < 0:\n            return []\n        max_num = max(number, max_num)\n        result.append(max_num)\n        \n    return result", "def sort_data(data, key, reverse=False):\n    '''\n    Function to sort data by a custom criteria.\n\n    Parameters\n    ----------\n    data: list\n        List of objects that need to be sorted.\n    key: function\n        A function that maps the objects in the data to the score that will be used for sorting.\n    reverse: boolean, optional\n        If True, the data will be sorted in reverse order.\n\n    Returns\n    ----------\n    sorted_data: list\n        The sorted list.\n    '''\n\n    # Create a list of tuples [(score, data_item)...] using the key function\n    data_tups = [(key(data_item), data_item) for data_item in data]\n    # Sort the list by the scores\n    sorted_data_tups = sorted(data_tups, reverse=reverse)\n    # Extract the sorted data from the tuples\n    sorted_data = [data_tup[1] for data_tup in sorted_data_tups]\n \n    # Return the sorted data\n    return sorted_data"]}
{"task_id": 289, "content": ["def add_without_operator(a, b):\n    # Iterate until there is no carry\n    while b != 0:\n        # Find carry and common set bits\n        carry = a & b\n        # Sum of bits of a and b where at least one of the bits is not set\n        a = a ^ b\n        # Carry is shifted by one so that adding it to a gives the required sum\n        b = carry << 1\n\n    return a", "def add_two_numbers(a, b):\n    # Carry contains common set bits of a and b\n    while (b != 0):\n         \n        # carry now contains common\n        # set bits of a and b\n        carry = a & b\n \n        # Sum of bits of a and b where at\n        # least one of the bits is not set\n        a = a ^ b\n \n        # Carry is shifted by one so that\n        # adding it to a gives the required sum\n        b = carry << 1\n     \n    return a", "def add(a, b):\n    # Iteration until there is no carry  \n    while (b != 0): \n        # Carry now contains common set bits of a and b\n        carry = a & b\n  \n        # Sum of bits of a and b where at least one of the bits is not set\n        a = a ^ b \n  \n        # Carry is shifted by one so that adding it to a gives the required sum\n        b = carry << 1\n        \n    return a", "def add_without_plus_operator(a, b):\n    # Iterate till there is no carry\n    while (b != 0):\n        # Carry now contains common set bits of a and b\n        carry = a & b\n\n        # Sum of bits of a and b where at least one of the bits is not set\n        a = a ^ b\n\n        # Carry is shifted by one so that adding it to a gives the required sum\n        b = carry << 1\n\n    return a", "def add_without_operator(a, b):\n    # Iterate till there is no carry  \n    while (b != 0):\n        # Carry now contains common set bits of a and b \n        carry = a & b \n        \n        # Sum of bits of a and b where at least one of the bits is not set \n        a = a ^ b \n        \n        # Carry is shifted by one so that adding it to a gives the required sum \n        b = carry << 1\n        \n    return a"]}
{"task_id": 290, "content": ["def modify_nested_dict(dictionary, keys, new_value, depth=0):\n    '''\n    Modify a nested dictionary\n\n    :param dictionary: The dictionary to modify\n    :param keys: A list of keys leading to the value to modify\n    :param new_value: The new value to set\n    :param depth: The current depth in the dictionary\n    :return: Nothing\n    '''\n    key = keys[depth]\n    if depth + 1 == len(keys):\n        dictionary[key] = new_value\n        return\n    else:\n        if key in dictionary:\n            modify_nested_dict(dictionary[key], keys, new_value, depth + 1)\n        else:\n            raise Exception(\"Key not found\")", "def max_depth_of_tree(node):\n    \"\"\"Find the maximum depth of a binary tree given the root node.\"\"\"\n    # An empty tree has depth 0\n    if node is None:\n        return 0\n    # Find the depth of the left and right subtree\n    left_depth = max_depth_of_tree(node.left)\n    right_depth = max_depth_of_tree(node.right)\n    # Return the maximum depth\n    return max(left_depth, right_depth) + 1", "def find_anagrams(word, dictionary):\n    \"\"\"\n    This function takes in a word and a dictionary and finds\n    all anagrams of the word in the dictionary.\n\n    Args:\n        word (str): the word to find anagrams for.\n        dictionary (list): a list of words in the dictionary.\n\n    Returns:\n        list: a list of all anagrams of the word in the dictionary.\n    \"\"\"\n    # Create a sorted version of the given word.\n    sorted_word = ''.join(sorted(word))\n    \n    # Create an empty list to store the anagrams.\n    anagrams = []\n    \n    # Iterate over all the words in the dictionary.\n    for i in range(len(dictionary)):\n        # Create a sorted version of the current word.\n        sorted_dict_word = ''.join(sorted(dictionary[i]))\n        \n        # Check if the sorted version of the word is equal to the sorted version of the dictionary word.\n        if sorted_word == sorted_dict_word:\n            # Append the current word to the list of anagrams.\n            anagrams.append(dictionary[i])\n    \n    # Return the list of anagrams.\n    return anagrams", "def analyze_dict(d, depth=0):\n    # Check if the input is a dictionary\n    if not isinstance(d, dict):\n        return (depth, 0, [])\n    \n    # Increment the depth counter\n    depth += 1\n    \n    # Count the number of keys in the current dictionary\n    key_count = len(d)\n    \n    # Create a set to store the types of values encountered\n    value_types = set(type(v) for v in d.values())\n    \n    # Initialize variables for inner dictionaries\n    inner_depth, inner_key_count, inner_value_types = 0, 0, set()\n    \n    # Iterate over the values in the dictionary\n    for v in d.values():\n        if isinstance(v, dict):\n            # Recursively call the function for inner dictionaries\n            id, ikc, ivt = analyze_dict(v, depth)\n            \n            # Update the inner depth, key count, and value types\n            inner_depth = max(inner_depth, id)\n            inner_key_count += ikc\n            inner_value_types = inner_value_types.union(ivt)\n        else:\n            if isinstance(v, list):\n                # If the value is a list, iterate over its items\n                for item in v:\n                    if isinstance(item, dict):\n                        # Recursively call the function for inner dictionaries within the list\n                        id, ikc, ivt = analyze_dict(item, depth)\n                        \n                        # Update the inner depth, key count, and value types\n                        inner_depth = max(inner_depth, id)\n                        inner_key_count += ikc\n                        inner_value_types = inner_value_types.union(ivt)\n                        \n    # Combine the value types from the current dictionary and inner dictionaries\n    value_types = value_types.union(inner_value_types)\n    \n    # Return the maximum depth, total key count, and value types\n    return (max(depth, inner_depth), key_count + inner_key_count, value_types)", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass"]}
{"task_id": 291, "content": ["def bitSwapRequired(a: int, b: int) -> int:\n    xor_result = a ^ b  # XOR of a and b to find differing bits\n    count = 0\n    while xor_result:\n        count += xor_result & 1  # Count the least significant bit if it is 1\n        xor_result >>= 1  # Right shift to check the next bit\n    return count", "def find_smallest_positive_integer(lst):\n    # Check if the list is empty\n    if not lst:\n        return 1\n    \n    # Find the maximum number in the list\n    max_num = max(lst)\n    \n    # If the maximum number is negative or zero, return 1\n    if max_num <= 0:\n        return 1\n    \n    # Create a bit vector with a length equal to the maximum number\n    bit_vector = 0\n    \n    # Set the corresponding bits to 1 for positive numbers in the list\n    for num in lst:\n        if num > 0:\n            bit_vector |= 1 << (num - 1)\n    \n    # Find the first bit that is 0 in the bit vector\n    for i in range(max_num):\n        if not bit_vector & (1 << i):\n            return i + 1\n    \n    # If all bits are set in the bit vector, the smallest positive integer is max_num + 1\n    return max_num + 1", "def multiply(a, b):\n    result = 0\n    \n    # Iterate until b becomes 0\n    while b:\n        \n        # If the least significant bit of b is 1, add a to the result\n        if b & 1:\n            result = add(result, a)\n        \n        # Right shift b by 1 bit\n        b >>= 1\n        \n        # Left shift a by 1 bit\n        a <<= 1\n    \n    return result", "def generate_random():\n    # Generate a random 32-bit integer\n    random_int = random.getrandbits(32)\n    \n    # Set the MSB (Most Significant Bit) to 1 to ensure a value between 0 and 1 (inclusive)\n    random_int |= (1 << 31)\n    \n    # Convert the random integer to a float between 0 and 1\n    random_float = random_int / (2**32)\n    \n    return random_float", "def binary_to_decimal(binary):\n    decimal = 0\n    power = 0\n    \n    # Iterate through each digit of the binary number, starting from the least significant bit\n    for bit in reversed(binary):\n        if bit == '1':\n            decimal += 2 ** power\n        \n        power += 1\n    \n    return decimal"]}
{"task_id": 292, "content": ["def check_rectangle(point1, point2):\n    \"\"\"\n    Function to check if two points form a rectangle.\n    \"\"\"\n    # If the coordinates of point1 & point2 are same, it's not a rectangle.\n    if point1 == point2:\n        return False\n    # If the x-coordinates or y-coordinates are same, it's not a rectangle.\n    elif point1[0] == point2[0] or point1[1] == point2[1]:\n        return False\n    return True", "def check_anagram_segments(text: str) -> bool:\n    \"\"\"\n    Given an input string, the function is intended to determine whether it is possible to \n    divide the string into two or more segments that are anagrams of one another. \n\n    Anagrams are words or phrases formed by reordering the letters of a different word or phrase, \n    typically using all the original letters exactly once.\n\n    The function counts the frequency of each unique character in the string and stores it in a dictionary. \n    If all frequencies are even number then the function returns True as the string can be divided into \n    two or more segments that are anagrams of one another. \n    \n    But if there is more than one character with an odd count frequency, then the function returns False\n    as it is not possible to divide the string into segments that are anagrams of one another. \n\n    Parameters:\n    text (str): The string to check for anagram segments\n\n    Returns:\n    bool: True if the string can be divided into anagram segments, False otherwise.\n\n    Examples:\n    \n    >>> check_anagram_samples('abcdefabcdegf')\n    True\n    >>> check_anagram_samples('helloworld')\n    False\n    \"\"\"\n\n    # count the frequency of each unique character in the string\n    frequency = {}\n    for char in text:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n\n    # count characters with odd count frequency\n    count_odd = sum(1 for count in frequency.values() if count % 2)\n\n    return count_odd <= 1", "def is_plagiarism(doc1, doc2):\n    \"\"\"\n    This function check whether two documents are the same based on the hash value\n    resulting from SHA256 algorithm.\n    \"\"\"\n    return get_hash(doc1) == get_hash(doc2)", "def binary_nor(list1, list2):\n    # Check whether lists are of same length\n    if len(list1) != len(list2):\n        raise ValueError(\"Lists are not of same length.\")\n\n    nor_list = []\n    for num1, num2 in zip(list1, list2):\n        # Perform NOR operation and append result in list\n        nor_list.append(int(not(num1 or num2)))\n\n    return nor_list", "def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True"]}
{"task_id": 293, "content": ["def character_at_index(s, idx):\n    \"\"\"\n    This function takes a string and an index and returns the character at the given index.\n\n    Parameters:\n    s (str): The string to be used\n    idx (int): The index of the character\n\n    Returns:\n    character at the given index (str)\n    \"\"\"\n\n    # return the character at the given index\n    return s[idx]", "def delete_element(my_list, pos):\n    \"\"\"Function to delete an element from a given list at a given position.\"\"\"\n    del my_list[pos]\n    return my_list", "def index_of_element(lst, element):\n    \"\"\"\n    Find the index of a given element in a list.\n    \"\"\"\n    index = -1\n    for i, num in enumerate(lst):\n        if num == element:\n            index = i\n            break\n    return index", "def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def linear_search(numbers_list, number):\n    \"\"\"Implements a linear search for a given list of numbers and returns the index of the number if it exists\"\"\"\n    \n    for index, element in enumerate(numbers_list):\n        if element == number:\n            return index\n    return -1"]}
{"task_id": 294, "content": ["def reverse_second_word(s):\n    words = s.split(' ') #splitting the sentence into a list of words.\n    \n    for i in range(1, len(words), 2): #Starting from the second word, hence the index 1. The third parameter for the range function is the step.\n        words[i] = words[i][::-1] #Reversing every second word\n    \n    return ' '.join(words) #Joining the words into a sentence", "def delete_words_with_letter(s, letter):\n    words = s.split()  # Split the string into a list of words\n    new_words = [word for word in words if letter not in word]  # Create a new list with words that do not contain the given letter\n    return ' '.join(new_words)  # Join the new list of words into a string separated by spaces", "def extract_words(string):\n    # pattern to match words with 'a' that is not preceded by a consonant and is not the last letter of the word\n    pattern = r'\\b(?<![bcdfghjklmnpqrstvwxyz])[a-z]*a[a-z]+\\b'\n    words = re.findall(pattern,string,re.I)\n    return words", "def arrange_string(s):\n    \"\"\"\n    This function takes a string 's', splits it into words, applies the custom_order function to each word to sort the characters in it,\n    and then rejoins the sorted words back together with a space in between. The function preserves the original order of words \n    and blank spaces in the sentence.\n    \"\"\"\n\n    # Split the string into a list of words\n    words_list = s.split(' ')\n\n    # Apply the custom_order function to each word in the list\n    ordered_words_list = [custom_order(word) for word in words_list]\n\n    # Join the ordered words back together with a space in between to form a string\n    ordered_s = ' '.join(ordered_words_list)\n\n    return ordered_s", "def anti_jumble(s):\n    \"\"\"\n    This function takes a string 's', splits it into words, applies the custom_order function to each word to sort the characters in it, \n    and then rejoins the sorted words back together with a space in between. The function preserves the original order of words \n    and blank spaces in the sentence.\n    \"\"\"\n\n    # Split the string into a list of words\n    words_list = s.split(' ')\n\n    # Apply the custom_order function to each word in the list\n    ordered_words_list = [custom_order(word) for word in words_list]\n\n    # Join the ordered words back together with a space in between to form a string\n    ordered_s = ' '.join(ordered_words_list)\n\n    return ordered_s"]}
{"task_id": 295, "content": ["def longest_increasing_subsequence(sequence):\n    \"\"\"\n    This function uses dynamic programming to find the longest increasing subsequence in the input array. \n\n    Firstly, we initialize the list length with size as input array size. Each element in length represents the longest \n    increasing subsequence in sequence[0...i]. After initializing the list length with 1, the function fills length in \n    a bottom-up manner(using dynamic programming), i.e., if sequence[j] > sequence[i] for some i < j and length[j] < length[i] + 1,\n    then update length[j].\n\n    Finally, the function returns the maximum value from the list length.\n\n    :param sequence: An input array of integers\n    :type sequence: list\n    :return: The longest increasing subsequence in the array\n    :rtype: int\n    \"\"\"\n\n    # initialize the list length with 1's because a minimum increasing subsequence would just be one number itself\n    length = [1] * len(sequence)\n\n    # loop over the sequence from the second element\n    for i in range(1, len(sequence)):\n        # consider all smaller elements found so far\n            for j in range(i):\n                # if this element is bigger, check if we can increase the length of the largest subsequence ending at i\n                if sequence[i] > sequence[j] and length[i] < length[j] + 1:\n                    length[i] = length[j] + 1\n\n    # return the maximum length found\n    return max(length)", "def longest_increasing_subseq(seq):\n    n = len(seq)\n    \n    # length[i] will hold the length of the longest increasing subsequence \n    # ending at index i. Initially, this is 1 for all i, as every \n    # element is itself a valid subsequence.\n    length = [1]*n\n    \n    # previous[i] will hold the index of the predecessor of seq[i] \n    # in the longest increasing subsequence ending at index i.\n    previous = [None]*n\n    \n    # Find the length of the longest increasing subsequence.\n    for i in range(1, n):\n        for j in range(i):\n            if seq[i] > seq[j] and length[i] < length[j] + 1:\n                length[i] = length[j] + 1\n                previous[i] = j\n    \n    # Find the index i of the last element of the longest increasing subsequence.\n    max_len = max(length)\n    i = length.index(max_len)\n    \n    # Reconstruct the longest increasing subsequence in reverse order.\n    subseq = []\n    while i is not None:\n        subseq.append(seq[i])\n        i = previous[i]\n    \n    # Return the subsequence in original order.\n    return subseq[::-1]", "def find_kth_largest(arr, k):\n    \"\"\"\n    Function to find the kth largest element in an array\n    \"\"\"\n    \n    # make a copy of the array\n    arr_copy = arr[:]\n    \n    # get the length of the array\n    length = len(arr_copy)\n    \n    # if k is greater than or equal to the length of the array, return the maximum element\n    if k >= length:\n        return max(arr_copy)\n        \n    # sort the array in descending order\n    arr_copy.sort(reverse=True)\n    \n    # get the kth element from the sorted array\n    kth_largest = arr_copy[k-1]\n    \n    return kth_largest", "def three_sum(arr, target):\n    \"\"\"\n    This function takes an array and an Integer and finds three elements of the array which sum up \n    to the given number.\n\n    Parameters\n    ----------\n    arr : list\n        list of numbers\n    target : int\n        target sum\n    \n    Returns\n    -------\n    list\n        list of three elements which sum up to the target\n    \"\"\"\n    # sort the list\n    arr.sort()\n    \n    # loop through the list from 0 to length-2\n    for i in range(len(arr)-2):\n        # set j to start from the next index and k to start from the last index\n        j, k = i+1, len(arr)-1\n        # find the target sum\n        while j < k:\n            s = arr[i] + arr[j] + arr[k]\n            if s == target:\n                return [arr[i], arr[j], arr[k]]\n            elif s < target:\n                j += 1\n            else:\n                k -= 1", "def longestIncreasingSubsequence(arr):\n    \"\"\"Function to find the longest increasing subsequence in a given array\"\"\"\n    n = len(arr)\n    # initialize the dp array \n    dp = [1] * n \n  \n    # Loop through the given array and compute \n    # other entries in the dp array \n    for i in range (1, n): \n        for j in range(i): \n            if (arr[i] > arr[j] and dp[i] < dp[j] + 1):\n                dp[i] = dp[j] + 1\n\n    # Find the maximum entry in the dp array\n    maximum = 0\n    for i in range(n): \n        if (maximum < dp[i]): \n            maximum = dp[i] \n\n    # return the longest increasing subsequence\n    return maximum"]}
{"task_id": 296, "content": ["def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass", "def get_eprocess_address():\n    # This is a placeholder function. In an actual implementation, you would\n    # use a system call or a kernel function to get the address of the _EPROCESS structure.\n    # This is non-trivial and platform-specific, and is not included here.\n    return 0x00000000", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass", "def write_ssh_key(name, path, key_type, debug):\n    # Function to write SSH key to a file\n    pass", "def transpose(matrix):\n    # The * operator is used to unzip a list (or other iterables), making a list of tuples where each tuple contains the i-th element from each of the argument sequences or iterables.\n    # The zip() function takes iterables, aggregates them in a tuple, and return the result.\n    # In other words, it returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.\n    return [list(i) for i in zip(*matrix)] "]}
{"task_id": 297, "content": ["def common_elements(list1, list2):\n    '''This function will find the common elements from two given lists.'''\n    common_elements = set(list1).intersection(list2)\n    return common_elements", "def multiply_vec(list1, list2):\n    \"\"\"Multiplies two lists elementwise.\n    \n    Arguments:\n        list1 - a list of ordered or unordered numbers\n        list2 - a list of ordered or unordered numbers\n    \n    Returns:\n        a list of products of the corresponding elements in the two lists\n    \"\"\"\n    products = []\n    for i in range(len(list1)):\n        product = list1[i] * list2[i]\n        products.append(product)\n    return products", "def combine_lists_to_dict(list1, list2):\n    # Check if both lists have the same number of elements.\n    if len(list1) != len(list2):\n        return \"Error: The given lists do not have the same number of elements.\"\n\n    # Combine the two lists into a dictionary.\n    combined_dict = dict(zip(list1, list2))\n\n    return combined_dict", "def extract_integer(number: float, precision: int) -> float:\n    \"\"\" Given a float, it breaks down into\n    an integer component (largest integer less or equal to the number) and decimals\n    (remainder always less than 1 and greater than -1).\n\n    The function should return the integer part of the number preserving precision up to a specified decimal point.\n    >>> extract_integer(4.70, 2)\n    4.70\n    >>> extract_integer(-3.200, 3)\n    -3.200\n    \"\"\"\n    decimal_point = Decimal(10) ** -precision  # Defines the decimal point up to the specified precision\n\n    if isinstance(number, (int, float)):\n        number = Decimal(number)  # Create a Decimal instance of the number\n    elif isinstance(number, str):\n        number = Decimal(number.replace(',', '.'))\n\n    return float(number.quantize(decimal_point, rounding=ROUND_DOWN))  # Return the number as a float, rounded to the specified precision", "def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min"]}
{"task_id": 298, "content": ["def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min", "def find_max(a, b, c):\n    \"\"\"\n    A function to find the maximum of three numbers.\n    \"\"\"\n    # Find the maximum of the three numbers\n    max_value = max(a, b, c)\n    \n    return max_value", "def erroneous():\n    string1 = 'Python Programming'  # The closing quote of string1 was mismatched, so I corrected it\n    string2 = '101'\n\n    # Convert string2 into integer\n    int_value = int(string2)  # The square brackets [] should be replaced with parentheses () for the int function\n    float_value = float('10.5')  # Similarly, the square brackets [] should be replaced with parentheses () for the float function\n\n    # Find the maximum number between 10 and 20\n    max_value = max(10, 20)  # In order to find the maximum between two numbers, both numbers need to be provided as arguments\n\n    # Find the minimum number between 10 and 20\n    min_value = min(10, 20)  # Similarly, to find the minimum between two numbers, both numbers need to be provided as arguments\n\n    # Find the square root of a number\n    sqrt = math.sqrt(16)  # Again, the square brackets [] should be replaced with parentheses () for the sqrt function\n\n    return string1, int_value, float_value, max_value, min_value, sqrt", "def find_max(numbers):\n    \"\"\"\n    Find the maximum value in a list of numbers.\n\n    Args:\n    numbers (list): A list of numbers.\n\n    Returns:\n    float: The maximum value in the input list.\n    \"\"\"\n    if not numbers:\n        return None\n    return max(numbers)", "def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) "]}
{"task_id": 299, "content": ["def convert_to_upper(string):\n    \"\"\"Function to convert the given string to all capital letters using an algorithm. Input should be a string.\"\"\"\n    result = ''\n    for char in string:\n        result += chr(ord(char) - 32)\n    return result", "def list_to_set(data):\n    \"\"\"\n    Function to convert a list to a set; managing nested lists and converting them to nested sets.\n    \"\"\"\n    # If data is a list convert each item in the list to a set recursively\n    if isinstance(data, list):\n        return set(list_to_set(item) for item in data)\n\n    # If data is a set convert each item in the set to a set recursively\n    elif isinstance(data, set):\n        return {list_to_set(item) for item in data}\n  \n    # If data is a tuple convert each item in the tuple to a set recursively and convert the tuples into sets.\n    elif isinstance(data, tuple):\n        return {list_to_set(item) for item in data}\n  \n    # If data is a dictionary convert each key value pair to tuple and handle each item in the tuple recursively.\n    elif isinstance(data, dict):\n        return {list_to_set((k,v)) for k,v in data.items()}\n\n    # If data is not a list, set, tuple or dict just return the data\n    else:\n        return data", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass", "def find_permutations(arr):\n    # itertools.permutations method returns all permutations \n    # of the given list arr of length len(arr).\n    # Each permutation is a tuple so we use map function \n    # to convert these tuples to lists\n    perm = list(map(list, itertools.permutations(arr)))\n    \n    # Return the generated permutations\n    return perm", "def toLowerCase(str):\n    \"\"\"\n    Convert a given string to all lowercase letters.\n\n    :param str: The string to be converted.\n    :type str: str\n    :return: The converted string.\n    :rtype: str\n    \"\"\"\n    return str.lower()"]}
{"task_id": 300, "content": ["def countDeterminingBits(n): \n  \n  # Initialize count \n  count = 0; \n  \n  # Check each bit \n  while (n > 0): \n    # Increment count if this bit is set \n    if (n & 1):  \n      count += 1; \n  \n    # Unset the last bit \n    n >>= 1; \n  \n  # Return the number of determining bits \n  return count; ", "def statistical_analysis(timings, key_bit_index):\n    # This function would perform statistical analysis on the timing data\n    # to determine the probability of a key bit being 1.\n    # It would return a value that could be compared to a threshold.\n    # For example, it could return the mean time for the key bit index.\n    return sum(timings) / len(timings)", "def generate_random():\n    # Generate a random 32-bit integer\n    random_int = random.getrandbits(32)\n    \n    # Set the MSB (Most Significant Bit) to 1 to ensure a value between 0 and 1 (inclusive)\n    random_int |= (1 << 31)\n    \n    # Convert the random integer to a float between 0 and 1\n    random_float = random_int / (2**32)\n    \n    return random_float", "def measure_lexical_items(text):\n    # We convert the string to a set of words.\n    # A set in Python is a collection of unique elements.\n    # Using a set will automatically remove any duplicate words from the text.\n    unique_words = set(text.split())\n\n    # The quantity of discrete lexical items is then just the size of this set.\n    return len(unique_words)", "def attach_to_process(pid):\n    # This is a placeholder function. In reality, you would need to use a lower-level\n    # library or system call to perform this action, which is not exposed through\n    # the Python standard library.\n    # For example, you might use the libc library to call ptrace()\n    # This is beyond the scope of a simple Python script and would require a\n    # more complex setup and environment.\n    pass"]}
{"task_id": 301, "content": ["def calc_cone_volume(cone):\n    \"\"\"Calculates the volume of a cone given the cone dictionary.\n\n    Args:\n        cone (dict): The cone dictionary.\n\n    Returns:\n        float: The volume of the cone.\n    \"\"\" \n    \n    return (1/3) * math.pi * (cone['radius']**2) * cone['height']", "def get_total_volume_by_color(cones, color):\n    \"\"\"Calculates the total volume of cones of a particular color.\n\n    Args:\n        cones (list): The list of cone dictionaries.\n        color (str): The color to filter by.\n\n    Returns:\n        float: The total volume of cones of the particular color.\n    \"\"\" \n    \n    total_volume = 0\n    \n    for cone in cones:\n        if cone['color'].lower() == color.lower():\n            total_volume += cone.get('volume', 0)\n    \n    return total_volume", "def sort_cones(cones):\n    \"\"\"Calculates the volumes of a list of cones and sorts them in non-increasing order.\n\n    Args:\n        cones (list): The list of cone dictionaries.\n\n    Returns:\n        list: The sorted list of cone dictionaries.\n    \"\"\" \n    \n    for cone in cones:\n        cone = fix_dict(cone)\n        cone['volume'] = calc_cone_volume(cone)\n    \n    cones.sort(key=lambda x: x['volume'], reverse=True)\n    \n    return cones", "def recip_vol(volume):\n    \"\"\"\n    Calculates the reciprocal of the volume of a geometric shape.\n\n    Args:\n    volume: Positive real number representing the volume of a geometric shape.\n\n    Returns:\n    The reciprocal of the volume.\n    \"\"\"\n    reciprocal = 1 / volume\n    return reciprocal", "def calculate_cube_volume(length):\n    \"\"\"Calculate the volume of a cube.\n    \n    Args:\n        length (float): The length of a side of the cube.\n        \n    Returns:\n        float: The volume of the cube.\n    \"\"\"\n    volume = length ** 3\n    return volume"]}
{"task_id": 302, "content": ["def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass", "def remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Facilitate the de-duplication of a sequence of integers, eliminating any references that occur more than once.\n    Retains the exact sequence of remaining integers mirroring the original provided sequence.\n    Time complexity: O(n)\n    Space complexity: O(1)\n    \"\"\"\n    write = 1\n    for read in range(1, len(numbers)):\n        if numbers[read] != numbers[read-1]:\n            numbers[write] = numbers[read]\n            write += 1\n    return numbers[:write]   # cutting the array to length 'write'", "def get_positive(l):\n    \"\"\"\n    Function to get positive numbers from a list which are greater than 2 \n    and their sum is less than 100\n    \"\"\"\n    # Sorting the list in descending order\n    l.sort(reverse=True)\n    \n    # List to store the positive numbers > 2\n    positive_numbers = [i for i in l if i > 2]\n    \n    # Calculating the sum of the positive numbers\n    total = sum_list(positive_numbers)\n    \n    # Check if sum exceed 100\n    if total > 100:\n        # Empty the list and return\n        positive_numbers = []\n    \n    return positive_numbers", "def calculate_sum_positive_even_numbers(numbers):\n    \"\"\"\n    Calculates the sum of all positive even numbers from a given list.\n    \n    Args:\n    numbers (list): The list of numbers.\n    \n    Returns:\n    int: The sum of all positive even numbers.\n    \n    Raises:\n    ValueError: If the input list contains non-integer elements.\n    \n    \"\"\"\n    \n    # Validate the input list\n    for num in numbers:\n        if not isinstance(num, int):\n            raise ValueError(\"Input list should only contain integers.\")\n    \n    # Initialize sum variable\n    sum = 0\n    \n    # Create a set to store unique even numbers\n    unique_evens = set()\n    \n    # Iterate through the list\n    for num in numbers:\n        # Check if the number is positive and even\n        if num > 0 and num % 2 == 0:\n            # Add the number to the set of unique even numbers\n            unique_evens.add(num)\n    \n    # Calculate the sum of unique even numbers\n    for even_num in unique_evens:\n        sum += even_num\n    \n    return sum"]}
{"task_id": 303, "content": ["def filter_words(words):\n    \"\"\"Function to filter a given list of words, such that all words with odd length are filtered out.\"\"\" \n    filtered_words = [word for word in words if len(word) % 2 == 0]\n    return filtered_words", "def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers.", "def find_target_sum(S, T):\n    # Use a dictionary to store information about the numbers\n    # and their complement that need to be summed to\n    # get the target T.\n    info = {}\n\n    # Iterate through the set of numbers.\n    for n in S:\n        # Calculate complement.\n        c = T - n\n\n        # Check if complement exists in dictionary.\n        if c in info:\n            # Return the two numbers that sum to the target.\n            return (n, c)\n        else:\n            # Store the number and its complement\n            # in the dictionary.\n            info[n] = c\n\n    # No two numbers that sum to the target found.\n    return None", "def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count"]}
{"task_id": 304, "content": ["def longest_str(lst):\n    max_len = max(len(word) for word in lst)   # Find the maximum length of a word in the list\n    results = [word for word in lst if len(word) == max_len] # Create a list with words that have the maximum length\n    return results", "def longest_str(lst):\n    max_len = max(len(word) for word in lst)   # find the maximum length of word in the list\n    results = [word for word in lst if len(word) == max_len] # include the words with maximum length\n    return results", "def find_max(a, b, c):\n    \"\"\"\n    A function to find the maximum of three numbers.\n    \"\"\"\n    # Find the maximum of the three numbers\n    max_value = max(a, b, c)\n    \n    return max_value", "def most_frequent_word(sentence):\n    words = sentence.lower().split()  # Convert the sentence to lowercase and split it into a list of words\n    counts = {}  # Create an empty dictionary to store the word frequencies\n\n    # Iterate through each word in the list\n    for word in words:\n        if word in counts:\n            counts[word] += 1  # If the word already exists in the dictionary, increment its count\n        else:\n            counts[word] = 1  # If it's a new word, add it to the dictionary with a count of 1\n\n    max_count = max(counts.values())  # Find the maximum count among all word frequencies\n\n    # Iterate through the dictionary to find the first word with the maximum count\n    for key, value in counts.items():\n        if value == max_count:\n            return key  # Return the word with the maximum count", "def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]"]}
{"task_id": 305, "content": ["def find_index_of_first_occurrence(string, character):\n    '''\n    This function will find the index of the first occurrence of a given character in a string.\n\n    Args:\n        string (str): the string to be searched\n        character (str): the character to be searched for\n\n    Returns:\n        int: the index of the first occurrence of the character\n    '''\n    return string.find(character)", "def find_final_position(nums, target):\n    \"\"\" This function receives a list and a target number\n    returns the index of the last occurrence of the target number in the list.\n    \"\"\"\n    last_position = None\n    \n    for idx, num in enumerate(nums):\n        if num == target:\n            last_position = idx\n    \n    return last_position", "def highest_occurring_character(string):\n    \"\"\"Find the highest occurring character in a string.\"\"\"\n\n    # Initialise a dictionary to store the number of occurrences of each character\n    char_occurrences = {}\n\n    # Store the number of occurrences of each character\n    for char in string:\n        char_occurrences[char] = char_occurrences.get(char, 0) + 1\n\n    # Find the maximum occurrence of all the characters\n    max_occurrence = 0\n    highest_occurring_char = None\n\n    # Iterate over the occurrence dictionary to find the highest occurrence\n    for char, occurrence in char_occurrences.items():\n        if occurrence > max_occurrence:\n            max_occurrence = occurrence\n            highest_occurring_char = char\n\n    return highest_occurring_char", "def analyze_a_occurrences(input_string):\n    # Convert the input string to lowercase to count both uppercase and lowercase occurrences of 'a'\n    lowercase_string = input_string.lower()\n    \n    # Calculate the total count of the letter 'a'\n    total_count = lowercase_string.count('a')\n    \n    # Determine the position of the first occurrence of the letter 'a'\n    first_position = lowercase_string.find('a') + 1  # Adding 1 to convert 0-based index to 1-based index\n    \n    # Find the position of the last occurrence of the letter 'a'\n    last_position = lowercase_string.rfind('a') + 1  # Adding 1 to convert 0-based index to 1-based index\n    \n    return total_count, first_position, last_position", "def find_first_occurrence(lst, el):\n    \"\"\"\n    Function to return the index of the first occurrence of a given element.\n    \n    Args:\n        lst (list): list of integers\n        el (int): integer element\n        \n    Returns:\n        int: index of the first occurrence of el\n    \"\"\"\n    try:\n        return lst.index(el)\n    except ValueError:\n        return -1"]}
{"task_id": 306, "content": ["def solve_QRD(A):\n    # Convert the input matrix A to a numpy array\n    A = np.array(A, dtype=float)\n    \n    # Call the given QRD_inPlace function to perform QR decomposition in place\n    QRD_inPlace(A)\n    \n    # Extract the upper triangular matrix R from the modified matrix A\n    R = np.triu(A)\n    \n    # Construct the orthogonal matrix Q from the modified matrix A\n    Q = np.transpose(A)\n    \n    return Q, R", "def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list", "def stealth_delivery(payload):\n    # This function is a placeholder for actual stealth techniques.\n    # In a real-world scenario, the attacker might use techniques like encoding,\n    # encoding the payload multiple times, or using sleep delays to evade detection.\n    # Here we just return the payload as is, which is a basic example of stealth.\n    return payload", "def CreatePalette(input_file, output_file):\n    with open(input_file, 'rb') as input_image:\n        # Read the color palette from the input image file\n        color_palette = read_color_palette(input_image)\n\n        # Modify the color palette to achieve a specific effect (e.g., grayscale conversion, color inversion, etc.)\n        modified_palette = modify_color_palette(color_palette)\n\n        # Create a new image file with the modified color palette\n        with open(output_file, 'wb') as modified_image:\n            # Write the modified color palette to the new image file\n            write_modified_palette(modified_image, modified_palette)", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass"]}
{"task_id": 307, "content": ["def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min", "def main():\n    length = 4\n    width = 5\n    height = 2\n\n    try:\n        volume = calculate_volume(length, width, height)\n        print(f\"The volume of the cuboid is {volume}.\")\n\n        surface_area = calculate_surface_area(length, width, height)\n        print(f\"The surface area of the cuboid is {surface_area}.\")\n    \n    except ValueError as e:\n        print(e)", "def find_surface_area(length, breadth, height):\n    '''\n    This function calculates the surface area of a cuboid.\n    Input: length, breadth, height - these are the three dimensions of the cuboid\n    Output: total surface area of the cuboid \n    '''\n    # Formula of Surface Area of Cuboid = 2(lb + bh + hl)\n    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area"]}
{"task_id": 308, "content": ["def find_words_with_fr(string):\n    '''\n    This function will find all words containing the letters \"fr\" in a given string.\n    \n    Args:\n        string (str): the string to be searched\n    \n    Returns:\n        list: a list of all words containing the letters \"fr\"\n    '''\n    regex = r\"\\b\\w*fr\\w*\\b\"\n    return re.findall(regex, string)", "def count_word_occurrences(s):\n    # Normalizing the string to lower case\n    s = s.lower()\n    # Using regex to find all words in the string (words are defined as 1 or more letter characters)\n    words = re.findall(r'\\b\\w+\\b', s)\n\n    # Using Counter to count occurrences of each word\n    word_count = Counter(words)\n    return word_count", "def count_word_occurrences(s):\n    # Normalizing the string to lower case\n    s = s.lower()\n    # Using regex to find all words in the string (words are defined as 1 or more letter characters)\n    words = re.findall(r'\\b[a-zA-Z]+\\b', s)\n\n    # Using Counter to count occurrences of each word\n    word_count = Counter(words)\n    return word_count", "def count_pattern_occurrences(string, pattern):\n    # Create a regex pattern that matches the given pattern surrounded by non-alphanumeric characters,\n    # whitespace, or punctuation marks\n    regex_pattern = r\"(?<!\\w){}(?!\\w)\".format(re.escape(pattern))\n\n    # Use the regex pattern to find all occurrences of the pattern in the string\n    matches = re.findall(regex_pattern, string)\n\n    # Return the count of pattern occurrences\n    return len(matches)", "def count_word_occurrences(string, word):\n    pattern = r'\\b{}\\b'.format(word)  # construct a regex pattern for whole word match\n    matches = re.findall(pattern, string, re.IGNORECASE)  # find all matches using regex\n    return len(matches)  # return the count of matches"]}
{"task_id": 309, "content": ["def calculate_difference(n):\n    # Calculate the square of the sum of the first n natural numbers\n    square_of_sum = ((n * (n + 1)) // 2) ** 2\n    \n    # Calculate the sum of the squares of the first n natural numbers\n    sum_of_squares = (n * (n + 1) * ((2 * n) + 1)) // 6\n    \n    # Calculate the difference\n    difference = square_of_sum - sum_of_squares\n    \n    return difference", "def sum_of_squares(n):\n    # Initialize the sum of squares\n    sum_squares = 0\n    \n    # Calculate the sum of squares of the first n natural numbers\n    for i in range(1, n+1):\n        sum_squares += i**2\n    \n    return sum_squares", "def sum_of_n_mod_m(n: int) -> int:\n    total_sum = (n * (n + 1)) // 2  # Calculate the sum of the first n natural numbers\n    return total_sum % mod  # Return the sum modulo mod", "def triangle_square_sum(n):\n    \"\"\"\n    Function to calculate the sum of the Triangle Series and the sum of the square of each\n    number in the Triangle Series up to n.\n    \"\"\"\n    # error handling: if n is negative or not an integer\n    if not isinstance(n, int) or n < 1:\n        return \"Error: Input must be an positive integer\"\n\n    # calculate the sum of the Triangle Series\n    # formula for the sum of the first n natural numbers is n*(n+1)/2\n    triangle_sum = n * (n + 1) // 2  # use integer division to ensure result is an integer\n\n    # calculate the sum of the square of each number in the Triangle Series up to n.\n    # formula for the sum of the squares of the first n natural numbers is n*(n+1)*(2n+1)/6\n    square_sum = n * (n + 1) * (2 * n + 1) // 6  # use integer division to ensure result is an integer\n\n    return triangle_sum, square_sum", "def sum_of_natural_numbers(n):\n    # Calculate the sum of n natural numbers\n    sum = (n * (n+1)) / 2\n    return sum"]}
{"task_id": 310, "content": ["def search_array(num, arr):\n    \"\"\"\n    This function searches for a number in the given array. \n    \n    Input:\n    num: The number to search for\n    arr: The array in which to search\n\n    Output: \n    returns True if the number is found. Otherwise, returns False\n    \"\"\"\n    \n    # iterate through the array\n    for i in range(0, len(arr)):\n        # if the current number equals the number being searched for, \n        # return True because we found the number\n        if arr[i] == num:\n            return True\n    \n    # after searching all elements, if we didn't find the number, return False\n    return False", "def add_digits(number):\n    \"\"\"This function adds all the digits of a given number \n    and returns the result.\n    \n    Args:\n        number (int): The number to process.\n    \n    Returns:\n        int: The result of adding all the digits of the given number.\n    \"\"\"\n    if number < 10:\n        return number\n    total = number % 10 + add_digits(number // 10)\n    return total", "def sum_primes_in_range(start, end):\n    \"\"\"\n    Function to find the sum of all prime numbers within the given range.\n    \n    Parameters: \n    start (int): The start number of the range. \n    end (int): The end number of the range.\n    \n    Returns: \n    int: The sum of all prime numbers in the given range.\n    \"\"\"\n    result = 0\n    for n in range(start, end+1):\n        if is_prime(n):\n            result += n\n    return result", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def create_list(number):\n    '''This function will take in a number and generate a list of numbers ending with the given number.'''\n    result = []\n    for n in range(1, number+1):\n        result.append(n)\n    return result"]}
{"task_id": 311, "content": ["def find_word(word, paragraph):\n    \"\"\" \n    This function is used to find the frequency and index positions of a specific word in a paragraph. \n\n    Args: \n    word (str): The word to find in the paragraph.\n    paragraph (str): The paragraph \n\n    Returns: \n    tuple: A tuple containing the frequency of word and a list of index positions. \n    If the word is not found, it returns a message saying so.\n    \"\"\"\n    \n    # The paragraph is converted to lower case for a case-insensitive search\n    lower_paragraph = paragraph.lower()\n\n    # The word is also turned to lower case\n    lower_word = word.lower()\n\n    # Find the frequency of the word\n    count = lower_paragraph.count(lower_word)\n    \n    # If count is zero, return appropriate message\n    if count == 0:\n        return \"The word is not found in the paragraph\"\n\n    # Find the positions of the word\n    index = 0\n    index_list = []\n    for _ in range(count):\n        next_index = lower_paragraph.index(lower_word, index)\n        \n        # Append actual index by ignoring leading spaces or punctuation\n        index_list.append(next_index + paragraph[next_index:].index(lower_word)) \n        index = next_index + len(lower_word)\n\n    # return the results\n    return count, index_list", "def sort(list):\n    \"\"\"\n    This function sorts a given list in ascending order.\n\n    Parameters:\n    list (List[int, float, str]): A list of numerical or string values to be sorted. This list should contain elements of the same datatype for the function to work correctly. \n    \"\"\"\n    list.sort()", "def find_index_of_first_occurrence(string, character):\n    '''\n    This function will find the index of the first occurrence of a given character in a string.\n\n    Args:\n        string (str): the string to be searched\n        character (str): the character to be searched for\n\n    Returns:\n        int: the index of the first occurrence of the character\n    '''\n    return string.find(character)", "def min_max(lst):\n    \"\"\"Find the maximum and minimum of the given list and return them in a list.\"\"\"\n    return [min(lst), max(lst)]", "def find_anagrams(word, dictionary):\n    \"\"\"\n    This function takes in a word and a dictionary and finds\n    all anagrams of the word in the dictionary.\n\n    Args:\n        word (str): the word to find anagrams for.\n        dictionary (list): a list of words in the dictionary.\n\n    Returns:\n        list: a list of all anagrams of the word in the dictionary.\n    \"\"\"\n    # Create a sorted version of the given word.\n    sorted_word = ''.join(sorted(word))\n    \n    # Create an empty list to store the anagrams.\n    anagrams = []\n    \n    # Iterate over all the words in the dictionary.\n    for i in range(len(dictionary)):\n        # Create a sorted version of the current word.\n        sorted_dict_word = ''.join(sorted(dictionary[i]))\n        \n        # Check if the sorted version of the word is equal to the sorted version of the dictionary word.\n        if sorted_word == sorted_dict_word:\n            # Append the current word to the list of anagrams.\n            anagrams.append(dictionary[i])\n    \n    # Return the list of anagrams.\n    return anagrams"]}
{"task_id": 312, "content": ["def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers.", "def rolling_max(arr):\n    \"\"\"\n    This function takes an array of positive integers and\n    returns a new array where each element from index 0 to \n    n is the maximum element from the original array from\n    index 0 to n.\n\n    If there's a negative number in the array, the function returns an empty list.\n    \n    Args:\n        arr (List[int]): a list of integers.\n\n    Returns:\n        List[int]: a list of maximum numbers. \n        If input list contains negative number, an empty list is returned\n    \"\"\"\n    \n    max_num = float('-inf')\n    result = []\n    \n    for number in arr:\n        if number < 0:\n            return []\n        max_num = max(number, max_num)\n        result.append(max_num)\n        \n    return result", "def filter_and_update(items, condition):\n    \"\"\"\n    Filter the list of items based on the given condition and perform specific actions.\n\n    Args:\n    items (list): The list of items to be filtered and updated.\n    condition (function): The filtering condition function that takes an item as input and returns a boolean.\n\n    Returns:\n    list: The filtered list of items after applying the condition.\n    \"\"\"\n    removed = []\n    kept = []\n    for item in items:\n        if not condition(item):\n            removed.append(item)\n        else:\n            kept.append(item)\n    if removed:\n        config.hook.pytest_deselected(items=removed)\n        items[:] = kept\n    return items", "def modify_array(array, num1, num2):\n    try:\n        # Ensure everything in array is a number\n        for i in array:\n            if not isinstance(i, (int, float)):\n                raise ValueError('Array can only contain numeric values.')\n        \n        # Ensure num1 and num2 are numbers\n        if not isinstance(num1, (int, float)) or not isinstance(num2, (int, float)):\n            raise ValueError('num1 and num2 must be numeric values.')\n        \n        # Ensure num1 is positive for sqrt operation\n        if num1 < 0:\n            raise ValueError('num1 must be a positive number to find its square root.')\n        \n        # Re-arrange the array in ascending order\n        array.sort()\n        \n        # Compute sqrt of num1 and append to array if it's an integer\n        sqrt_num1 = math.sqrt(num1)\n        if sqrt_num1.is_integer():\n            array.append(int(sqrt_num1))\n        \n        # Multiply the array with num2\n        array = [i * num2 for i in array]\n        \n        # Append num1 and num2 to the array\n        array.append(num1)\n        array.append(num2)\n        \n        return array\n        \n    except Exception as e:\n        print(str(e))", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]"]}
{"task_id": 313, "content": ["def parse_binary(binary_path):\n    # Parse the binary and extract its code sections\n    # This would involve using a binary analysis library like radare2, pefile, etc.\n    # For simplicity, we'll assume that this function returns a list of tuples (address, opcodes)\n    # where 'address' is the starting address of the code section and 'opcodes' is the bytecode.\n    # This is a placeholder function.\n    pass", "def sort_by_second_item(tuples):\n    \"\"\"Sorts a list of tuples by the second item in the tuples.\n    \n    Args:\n        tuples: A list of tuples to be sorted.\n        \n    Returns:\n        sorted_list: The sorted list of tuples.\n    \"\"\"\n    sorted_list = sorted(tuples, key=lambda x: x[1])\n    \n    return sorted_list", "def sort_data(data, key, reverse=False):\n    '''\n    Function to sort data by a custom criteria.\n\n    Parameters\n    ----------\n    data: list\n        List of objects that need to be sorted.\n    key: function\n        A function that maps the objects in the data to the score that will be used for sorting.\n    reverse: boolean, optional\n        If True, the data will be sorted in reverse order.\n\n    Returns\n    ----------\n    sorted_data: list\n        The sorted list.\n    '''\n\n    # Create a list of tuples [(score, data_item)...] using the key function\n    data_tups = [(key(data_item), data_item) for data_item in data]\n    # Sort the list by the scores\n    sorted_data_tups = sorted(data_tups, reverse=reverse)\n    # Extract the sorted data from the tuples\n    sorted_data = [data_tup[1] for data_tup in sorted_data_tups]\n \n    # Return the sorted data\n    return sorted_data", "def sort_list(tuples):\n    \"\"\"\n    A function to sort a list of tuples by the second item in each tuple.\n    \"\"\"\n    return sorted(tuples, key=lambda x: x[1])", "def get_word_frequency_tuples(preprocessed_tokens):\n    # Get the word frequencies using the get_word_frequencies function\n    word_freq = get_word_frequencies(preprocessed_tokens)\n    \n    # Convert the dictionary of word frequencies to a list of tuples\n    word_freq_tuples = list(word_freq.items())\n    \n    # Sort the list of tuples by frequency in descending order\n    word_freq_tuples.sort(key=lambda x: x[1], reverse=True)\n    \n    # Return the list of tuples\n    return word_freq_tuples"]}
{"task_id": 314, "content": ["def random_number(minimum, maximum):\n    '''This function takes a minimum and maximum number and generates a random number within the given range.'''\n    return random.randint(minimum, maximum)", "def is_armstrong_number(num):\n    # Convert the number to a string\n    num_str = str(num)\n    \n    # Get the length of the number\n    length = len(num_str)\n    \n    # Calculate the sum of powers of each digit\n    armstrong_sum = sum(int(digit) ** length for digit in num_str)\n    \n    # Check if the calculated sum is equal to the given number\n    return armstrong_sum == num", "def is_multiple(n):\n    \"\"\"\n    Function to check if a given number is a multiple of 3 or 5.\n    \n    Parameters: \n    n (int): The given number to check.\n    \n    Returns: \n    bool: True if number is a multiple of 3 or 5, False otherwise.\n    \"\"\"\n    return n % 3 == 0 or n % 5 == 0", "def is_armstrong(n):\n    # Converting n to a string to find the length (i.e., number of digits)\n    num_str = str(n)\n    num_len = len(num_str)\n\n    # Initialize sum\n    sum_cubes = 0\n\n    # Find the sum of the cube of each digit\n    for i in num_str:\n        sum_cubes += int(i) ** num_len\n\n    # If the calculated sum is equal to n, then n is an Armstrong number\n    return sum_cubes == n", "def recursive_sqrt(number, current_value = 1):\n    \"\"\"Return the square root of a given number using recursion\n    \n    Arguments:\n    number -- The number whose square root is to be calculated.\n    value -- The current approximation of the square root of the number.\n    \"\"\"\n    new_value = (current_value + number/current_value)/2\n    if abs(new_value - current_value) <= 0.0000009:\n        return new_value\n    else:\n        return recursive_sqrt(number, new_value)"]}
{"task_id": 315, "content": ["def get_most_common_words(text):\n    \"\"\"Find the most common words in the given text.\n\n    :param text: A sentence or multiple sentences as a single string\n    :returns: A list of the most common words in the given text\n    \"\"\"\n\n    # Split the text into a list of words\n    words = text.split()\n\n    # Count the occurrences of each word\n    word_count = {}\n    for word in words:\n        word = word.lower()\n        if word in word_count:\n            word_count[word] += 1\n        else:\n            word_count[word] = 1\n\n    # Get the most common words\n    most_common_words = []\n    max_count = 0\n    for word, count in word_count.items():\n        if count > max_count:\n            most_common_words = [word]\n            max_count = count\n        elif count == max_count:\n            most_common_words.append(word)\n\n    return most_common_words", "def related_words(word, words):\n    \"\"\"\n    Function to get an array of words related to the given word.\n    \n    Parameters: \n    word (str) : The given word.\n    words (list) : The list of words to search in.\n\n    Returns:\n    list : The list of words related to the given word.\n    \"\"\"\n\n    related = []\n    for w in words:\n        if word in w or w in word:\n            related.append(w)\n    return related", "def get_top_words(text, n):\n    \"\"\" \n    Function to retrieve the top N most used words in a given text document.\n\n    Args:\n        text (str): The text document\n        n (int): Number of words to extract\n\n    Returns:\n        The top n most used words as a list of strings.\n    \"\"\"\n    # Tokenize the text\n    tokens = tokenize(text) \n    \n    # Count the number of times each token appears in the text\n    token_count = collections.Counter(tokens).most_common(n)\n    # Extract the words from token_count\n    top_words = [word for word, _ in token_count]\n\n    return top_words", "def find_most_anagrams(words):\n    count = {}\n    for word in words:\n        sorted_word = ''.join(sorted(word)) # create a sorted version of each word\n        if sorted_word not in count:  # if the sorted word is not in the dictionary\n            count[sorted_word] = [word] # create a new dictionary entry\n        else:\n            count[sorted_word].append(word) # append the word to the list of anagrams\n \n    most_anagrams = max(count.values(), key=len) # Get the list with the most anagrams\n \n    print(\"The word with the most anagrams is {}\".format(most_anagrams[0])) # returns the first word in the list\n    print(\"There are {} anagrams of this word\".format(len(most_anagrams))) # returns the number of anagrams", "def replace_word(original_text, target_word, replacement_word):\n    \"\"\"\n    This function replaces all occurrences of a target word \n    in the original text with a replacement word.\n\n    :param original_text: The original text.\n    :type original_text: str\n    :param target_word: The word to be replaced.\n    :type target_word: str\n    :param replacement_word: The word to replace the target word.\n    :type replacement_word: str\n    :return: The text with all occurrences of the target word replaced.\n    :rtype: str\n    \"\"\"\n    replaced_text = original_text.replace(target_word, replacement_word)\n    \n    return replaced_text"]}
{"task_id": 316, "content": ["def classify_triangle(a,b,c):\n    # check if sides form a triangle\n    if a+b <= c or a+c <= b or b+c <= a:\n        return 'Not a valid triangle'\n    \n    # check for equilateral triangle\n    if a == b == c:\n        return 'Equilateral triangle'\n    \n    # check for isosceles triangle\n    if a==b or a==c or b==c:\n        return 'Isosceles triangle'\n    \n    # otherwise, it is a scalene triangle\n    return 'Scalene triangle'", "def triangleType(a, b, c):\n  # First, let's check if the sides form a valid triangle\n  if (a + b <= c) or (a + c <= b) or (b + c <= a):\n    return \"Not a valid triangle\"\n\n  # Next, we'll check if all sides are equal, indicating an equilateral triangle\n  if a == b and b == c:\n    return \"Equilateral triangle\"\n\n  # If all sides are different lengths, it's a scalene triangle\n  if (a != b) and (b != c) and (a != c):\n    return \"Scalene triangle\"\n\n  # If it's not equilateral or scalene, it must be an isosceles triangle\n  return \"Isosceles triangle\"", "def calculate_isosceles_triangle_area(side1, side2, base, allowed_ratio):\n    \"\"\"\n    This function calculates the area of an isosceles triangle using Heron's formula\n    and checks if the ratio of the base to the equal sides is not more than a certain ratio.\n    If the ratio condition is violated, the function returns a warning message.\n    \"\"\"\n    if side1 != side2:\n        return \"Not an isosceles triangle\"\n\n    elif base / float(side1) > allowed_ratio:\n        return f\"Ratio of base to sides exceeds allowed ratio {allowed_ratio}\"\n\n    else:\n        #Calculate semiperimeter\n        semi_perimeter = (side1 + side2 + base) / 2\n\n        #Calculate area using Heron's formula\n        area = math.sqrt(semi_perimeter * (semi_perimeter - side1) * \n                         (semi_perimeter - side2) * (semi_perimeter - base))\n        return \"Area of the isosceles triangle is: \" + str(area)", "def classify_triangle(a, b, c):\n    # Check for triangle inequality\n    if a + b <= c or a + c <= b or b + c <= a:\n        return 'Not a triangle'\n    \n    # Check for an equilateral triangle\n    if a == b and b == c:\n        return 'Equilateral triangle'\n        \n    # Check for an isosceles triangle\n    elif a == b or b == c or a == c:\n        return 'Isosceles triangle'\n    \n    # If none of the above checks are true, it must be a scalene triangle\n    else:\n        return 'Scalene triangle'", "def area_and_isosceles_check(side1, side2, base):\n    \"\"\"\n    Function to calculate the area of a triangle based on side lengths\n    and check if the triangle is isosceles.\n    \"\"\"\n    # validations\n    if not(1 <= side1 <= 50) or not(1 <= side2 <= 50) or not(1 <= base <= 50):\n        return \"Invalid input: All sides should be between 1 and 50\"\n\n    # Check if the given sides can form a triangle\n    if not(side1 + side2 > base and side1 + base > side2 and side2 + base > side1): \n        return \"Invalid input: These sides can't form a triangle\"\n\n    # Check if the triangle is isosceles\n    is_isosceles = side1 == side2 or side2 == base or base == side1\n\n    # calculate semi-perimeter\n    s = (side1 + side2 + base) / 2\n\n    # calculate area using Heron's formula\n    area = (s*(s-side1)*(s-side2)*(s-base)) ** 0.5\n\n    return area, is_isosceles"]}
{"task_id": 317, "content": ["def get_list_items_with_indices(items_all, indices):\n    getter = itemgetter(*indices)  # Create a getter function based on the specified indices\n    items = list(getter(items_all))  # Use the getter function to retrieve the items at the specified indices\n    return items  # Return the list of retrieved items", "    def start(self, widget, direction, height):\n        self.widget = widget\n        # Initialize the loading bar in the specified widget with the given direction and height\n        # Implementation details\n        if direction == self.TOP:\n            # Code to display loading bar at the top with specified height\n            pass\n        elif direction == self.BOTTOM:\n            # Code to display loading bar at the bottom with specified height\n            pass\n        elif direction == self.LEFT:\n            # Code to display loading bar at the left with specified height\n            pass\n        elif direction == self.RIGHT:\n            # Code to display loading bar at the right with specified height\n            pass", "def find_item_by_key_value(items, key, value, default=None):\n    \"\"\"\n    Search for a specific item in a list of dictionaries based on a given key-value pair.\n\n    Args:\n    items (list): List of dictionaries to search through.\n    key (str): The key to search for in the dictionaries.\n    value (any): The value to match against the specified key.\n    default (any, optional): The default value to return if no matching dictionary is found. Defaults to None.\n\n    Returns:\n    dict or any: The first dictionary in the list that contains the specified key-value pair, or the default value if no match is found.\n    \"\"\"\n    for item in items:\n        if item.get(key) == value:\n            return item\n    return default", "def process_elevation_marker_views(items):\n    \"\"\"\n    Processes elevation marker views based on the input type.\n\n    Args:\n    items: A single item or a list of items.\n\n    Returns:\n    If the input is a list, returns a new list containing the results of applying the GetElevationMarkerView function to each item in the input list.\n    If the input is not a list, returns the result of applying the GetElevationMarkerView function to the single input item.\n    \"\"\"\n    if isinstance(items, list):\n        return [GetElevationMarkerView(x) for x in items]\n    else:\n        return GetElevationMarkerView(items)", "def filter_by_prefix(string_list, prefix):\n    \"\"\"\n    Filters a list of strings based on a given prefix.\n\n    Args:\n    string_list: A list of strings to be filtered.\n    prefix: A string representing the prefix to filter by.\n\n    Returns:\n    A new list containing only the strings from the original list that start with the specified prefix.\n    \"\"\"\n    return [s for s in string_list if s.startswith(prefix)]"]}
{"task_id": 318, "content": ["def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def factorial_lst(lst):\n    if not isinstance(lst, list):\n        raise TypeError(\"Invalid data type. Input must be a list.\")\n        \n    for i in lst:\n        if not isinstance(i, int):\n            raise TypeError(\"Invalid data type in list. List must contains integers only.\")\n        if i < 0:\n            raise ValueError(\"Invalid value in list. Factorial is not defined for negative numbers.\")\n        if i > 170:\n            raise OverflowError(\"Number too large. Python's math library supports factorials of numbers up to 170 only.\")\n            \n    return [math.factorial(i) for i in lst]", "def rolling_max(arr):\n    \"\"\"\n    This function takes an array of positive integers and\n    returns a new array where each element from index 0 to \n    n is the maximum element from the original array from\n    index 0 to n.\n\n    If there's a negative number in the array, the function returns an empty list.\n    \n    Args:\n        arr (List[int]): a list of integers.\n\n    Returns:\n        List[int]: a list of maximum numbers. \n        If input list contains negative number, an empty list is returned\n    \"\"\"\n    \n    max_num = float('-inf')\n    result = []\n    \n    for number in arr:\n        if number < 0:\n            return []\n        max_num = max(number, max_num)\n        result.append(max_num)\n        \n    return result", "def remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Facilitate the de-duplication of a sequence of integers, eliminating any references that occur more than once.\n    Retains the exact sequence of remaining integers mirroring the original provided sequence.\n    Time complexity: O(n)\n    Space complexity: O(1)\n    \"\"\"\n    write = 1\n    for read in range(1, len(numbers)):\n        if numbers[read] != numbers[read-1]:\n            numbers[write] = numbers[read]\n            write += 1\n    return numbers[:write]   # cutting the array to length 'write'"]}
{"task_id": 319, "content": ["def find_words_with_fr(string):\n    '''\n    This function will find all words containing the letters \"fr\" in a given string.\n    \n    Args:\n        string (str): the string to be searched\n    \n    Returns:\n        list: a list of all words containing the letters \"fr\"\n    '''\n    regex = r\"\\b\\w*fr\\w*\\b\"\n    return re.findall(regex, string)", "def count_word_occurrences(s):\n    # Normalizing the string to lower case\n    s = s.lower()\n    # Using regex to find all words in the string (words are defined as 1 or more letter characters)\n    words = re.findall(r'\\b\\w+\\b', s)\n\n    # Using Counter to count occurrences of each word\n    word_count = Counter(words)\n    return word_count", "def count_pattern_occurrences(string, pattern):\n    # Create a regex pattern that matches the given pattern surrounded by non-alphanumeric characters,\n    # whitespace, or punctuation marks\n    regex_pattern = r\"(?<!\\w){}(?!\\w)\".format(re.escape(pattern))\n\n    # Use the regex pattern to find all occurrences of the pattern in the string\n    matches = re.findall(regex_pattern, string)\n\n    # Return the count of pattern occurrences\n    return len(matches)", "def count_word_occurrences(s):\n    # Normalizing the string to lower case\n    s = s.lower()\n    # Using regex to find all words in the string (words are defined as 1 or more letter characters)\n    words = re.findall(r'\\b[a-zA-Z]+\\b', s)\n\n    # Using Counter to count occurrences of each word\n    word_count = Counter(words)\n    return word_count", "def number_to_text(num):\n    switcher = {\n        0: \"Zero\",\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\"\n    }\n\n    # get() method of dictionary data type returns \n    # value for the given key if present in the dictionary.\n    return switcher.get(num, \"Invalid number\")"]}
{"task_id": 320, "content": ["def countDeterminingBits(n): \n  \n  # Initialize count \n  count = 0; \n  \n  # Check each bit \n  while (n > 0): \n    # Increment count if this bit is set \n    if (n & 1):  \n      count += 1; \n  \n    # Unset the last bit \n    n >>= 1; \n  \n  # Return the number of determining bits \n  return count; ", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def count_word(text, word):\n    '''This function will count the number of times a given word appears in a text.'''\n    return text.count(word)", "def hamming_weight(byte):\n    # Implement this function to calculate the Hamming weight of a byte.\n    # The Hamming weight is the number of 1's in the byte.\n    # This can be done using a bitwise operation that counts the number of bits set to 1.\n    return bin(byte).count('1')", "def is_multiple(n):\n    \"\"\"\n    Function to check if a given number is a multiple of 3 or 5.\n    \n    Parameters: \n    n (int): The given number to check.\n    \n    Returns: \n    bool: True if number is a multiple of 3 or 5, False otherwise.\n    \"\"\"\n    return n % 3 == 0 or n % 5 == 0"]}
{"task_id": 321, "content": ["def check_anagram_segments(text: str) -> bool:\n    \"\"\"\n    Given an input string, the function is intended to determine whether it is possible to \n    divide the string into two or more segments that are anagrams of one another. \n\n    Anagrams are words or phrases formed by reordering the letters of a different word or phrase, \n    typically using all the original letters exactly once.\n\n    The function counts the frequency of each unique character in the string and stores it in a dictionary. \n    If all frequencies are even number then the function returns True as the string can be divided into \n    two or more segments that are anagrams of one another. \n    \n    But if there is more than one character with an odd count frequency, then the function returns False\n    as it is not possible to divide the string into segments that are anagrams of one another. \n\n    Parameters:\n    text (str): The string to check for anagram segments\n\n    Returns:\n    bool: True if the string can be divided into anagram segments, False otherwise.\n\n    Examples:\n    \n    >>> check_anagram_samples('abcdefabcdegf')\n    True\n    >>> check_anagram_samples('helloworld')\n    False\n    \"\"\"\n\n    # count the frequency of each unique character in the string\n    frequency = {}\n    for char in text:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n\n    # count characters with odd count frequency\n    count_odd = sum(1 for count in frequency.values() if count % 2)\n\n    return count_odd <= 1", "def count_string_frequency(string):\n    '''This function counts the frequency of each character in the string and returns a dictionary.'''\n    \n    frequency = {}\n    for character in string:\n        if character in frequency.keys():\n            frequency[character] += 1\n        else: \n            frequency[character] = 1\n            \n    return frequency", "def find_index_of_first_occurrence(string, character):\n    '''\n    This function will find the index of the first occurrence of a given character in a string.\n\n    Args:\n        string (str): the string to be searched\n        character (str): the character to be searched for\n\n    Returns:\n        int: the index of the first occurrence of the character\n    '''\n    return string.find(character)", "def can_form_palindrome(s):\n    # Create a dictionary to store the frequency of each character\n    freq = {}\n  \n    # Traverse the given string and count the frequency of each character\n    for char in s:\n        # If the character is already present in the dictionary, increment its count\n        if char in freq:\n            freq[char] += 1\n        else:\n            # Else, add this character to the dictionary\n            freq[char] = 1\n  \n    # Count the characters with odd frequency count\n    odd = 0\n    for k, v in freq.items():\n        # If the count is odd, increment the odd count\n        odd += v & 1\n  \n    # If the count of characters with odd count is greater than 1, return False.\n    # Otherwise, return True.\n    return odd <= 1", "def count_chars(string):\n    \"\"\"Function to count characters in a given string\"\"\"\n    count = 0\n\n    # Loop through each character\n    for char in string:\n        count += 1\n\n    # Return the count\n    return count"]}
{"task_id": 322, "content": ["def sort_list(arr, criterion):\n    # iterate over the lists in the array\n    for sublist in arr:\n        # sort the sublist according to the criterion\n        sublist.sort(key=criterion)\n        \n    # sort the array according to the last element of the sublists\n    arr.sort(key=lambda l: l[-1])\n    \n    return arr", "def remove_duplicates_2D_list(lst):\n    # create a set to store unique elements\n    seen = set()\n    \n    # create a new list to store the result\n    result = []\n    \n    # loop through the lists in the given 2D list\n    for sublist in lst:\n        new_sublist = []\n        for element in sublist:\n            # if the element has not been encountered before, add it to the set \n            # and the new sublist\n            if element not in seen:\n                seen.add(element)\n                new_sublist.append(element)\n        # add the new sublist to the result\n        result.append(new_sublist)\n    \n    return result", "def sortByLength(strings):\n    \"\"\"Sort a list of strings according to their lengths\"\"\"\n    # Sort the list using a key function\n    return sorted(strings, key=len)", "def sorted_list_sum(lst, reverse=False):\n    \"\"\"\n    This function takes as input a list of strings, removes any string that contains a numerical digit or \n    an odd number of characters, sorts remaining strings in ascending order by both length and alphabetically, \n    and then returns the sorted list.\n    \n    Achieves this by using list comprehension to filter out unwanted elements, \n    and Python's built-in sorted function to sort the list. The sorted function uses a compound sorting key \n    consisting of the length of each element and the element itself, allowing for sorting by multiple criteria.\n    \n    The ordering of the sorted list can be reversed by supplying a second argument of True.\n\n    Parameters:\n    lst (list): A list of strings to be filtered and sorted.\n    reverse (bool): Optional parameter to reverse the order of the sorted list. Defaults to False.\n\n    Returns:\n    list: The sorted list of strings.\n    \"\"\"\n    \n    # Filter out any strings containing numerical digits or with odd length\n    lst = [i for i in lst if not any(j.isdigit() for j in i) and len(i) % 2 == 0]\n    \n    # Return the list sorted by length and then alphabetically, in ascending or descending order\n    return sorted(lst, key=lambda x: (len(x), x), reverse=reverse)", "def flatten_list(lst):\n    flattened = []  # initialize an empty list to store the flattened elements\n    \n    # iterate over each sublist in the given list\n    for sublist in lst:\n        # iterate over each element in the sublist\n        for element in sublist:\n            flattened.append(element)  # add the element to the flattened list\n    \n    return flattened"]}
{"task_id": 323, "content": ["def compute_triangle_area(a, b, c):\n    # Check if sides are integers\n    if not isinstance(a, int) or not isinstance(b, int) or not isinstance(c, int):\n        raise InvalidTriangleError(\"Invalid triangle: the given sides are not integers.\")\n    \n    # Check if the given sides can form a triangle\n    if a + b <= c or b + c <= a or a + c <= b:\n        raise InvalidTriangleError(\"Invalid triangle: the given sides cannot form a triangle.\")\n    \n    # Compute the area using Heron's formula\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return area", "def triangleType(a, b, c):\n  # First, let's check if the sides form a valid triangle\n  if (a + b <= c) or (a + c <= b) or (b + c <= a):\n    return \"Not a valid triangle\"\n\n  # Next, we'll check if all sides are equal, indicating an equilateral triangle\n  if a == b and b == c:\n    return \"Equilateral triangle\"\n\n  # If all sides are different lengths, it's a scalene triangle\n  if (a != b) and (b != c) and (a != c):\n    return \"Scalene triangle\"\n\n  # If it's not equilateral or scalene, it must be an isosceles triangle\n  return \"Isosceles triangle\"", "def calculate_triangle_height(angle, side1, side2):\n    # check if angle is in permissible range\n    if angle <= 0 or angle >= 180:\n        print('Invalid input. Please enter a valid angle')\n        return None\n    # check if sides are positive real numbers\n    elif side1 <= 0 or side2 <= 0:\n        print('Invalid input. Please enter valid sides')\n        return None\n    # check if the inputs can form a real triangle using triangle inequality principle\n    elif side1 + side2 <= side1 or side1 + side2 <= side2 or side1 + side1 <= side2:\n        print('Invalid input. These sides do not form a valid triangle')\n        return None\n    else:\n        # calculating height of triangle\n        height = side2 * math.sin(math.radians(angle))\n        return height", "def is_right_angled_triangle(a, b, c):\n    # Check if side lengths are valid for a triangle\n    if a <= 0 or b <= 0 or c <= 0:\n        return False\n    \n    # Check if triangle inequality holds\n    if a + b <= c or a + c <= b or b + c <= a:\n        return False\n    \n    # Sort the sides in ascending order\n    sides = sorted([a, b, c])\n    \n    # Check if the square of the longest side is equal to the sum of the squares of the other two sides\n    return sides[2]**2 == sides[0]**2 + sides[1]**2", "def compute_triangle_area(a, b, c):\n    # Check if the given sides can form a valid triangle\n    if a + b <= c or b + c <= a or c + a <= b:\n        raise InvalidTriangleError(\"Invalid triangle: the given sides cannot form a triangle.\")\n\n    # Compute the semi-perimeter of the triangle\n    s = (a + b + c) / 2\n\n    # Compute the area using Heron's formula\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return area"]}
{"task_id": 324, "content": ["def geometric_progression(a, r=3, n=5):\n    # calculate the sum of the geometric progression\n    sum = a * (1 - r**n) / (1 - r)\n    \n    # check if the sum falls within the specified range\n    if 300 <= sum <= 1200:\n        # print the sum and terms of the geometric progression\n        print(f'The sum of the geometric progression is: {sum}.')\n        print('Terms of the geometric progression:')\n        for i in range(n):\n            term = a * r**i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of the geometric progression is not within the valid range, but {sum}.')", "def geometric_progression(a, r=3, n=5):\n    # calculate the sum of geometric progression\n    sum = a * (1 - r**n) / (1 - r)\n    \n    # check if sum is within specified range\n    if 300 <= sum <= 1200:\n        # print the sum and terms of geometric progression\n        print(f'Sum of geometric progression: {sum}.')\n        print('Terms of geometric progression:')\n        for i in range(n):\n            term = a * r**i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of geometric progression is not within valid range, but {sum}.')", "def sum_operation(min, max):\n    # Calculate the difference between max and min\n    difference = max - min\n\n    # Calculate the sum using the arithmetic progression formula\n    sum = (difference + 1) * (min + max) // 2\n\n    return sum", "def find_arithmetic_sequences(sequences, value):\n    result = []  # Temporal list that stores the sequences that form an arithmetic progression.\n\n    for sequence in sequences:\n        sequence.append(value)  # Add the numerical entity to the sequence.\n        \n        # Calculate the difference between the second and the first element of the sequence.\n        difference = sequence[1] - sequence[0]  \n        \n        # Iterate over the sequence.\n        for i in range(2, len(sequence)):\n            \n            # If the difference between the current and the previous element of the sequence equals the initial difference.\n            if sequence[i] - sequence[i - 1] == difference:\n                \n                # If the current element is the last one in the sequence, then the sequence forms an arithmetic progression.\n                if i == len(sequence) - 1:  \n                    result.append(sequence)\n            else:\n                break  \n\n    return result", "def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) "]}
{"task_id": 325, "content": ["def num_of_days(month): \n    if month == \"January\" or month == \"March\" or month == \"May\" or month == \"July\" or month == \"August\" or month == \"October\" or month == \"December\": \n        return \"31 days\"\n    elif month == \"April\" or month == \"June\" or month == \"September\" or month == \"November\":\n        return \"30 days\"\n    elif month == \"February\":\n        return \"28 or 29 days\"\n    else:\n        return \"Invalid input\"", "def get_num_days(month, year):\n    # check if the year is a leap year\n    if year % 400 == 0 or (year % 100 != 0 and year % 4 == 0):\n        leap_year = True\n    else:\n        leap_year = False\n    \n    # dictionary to map month number to number of days\n    num_days_in_month = {\n        1: 31,\n        2: 29 if leap_year else 28,\n        3: 31,\n        4: 30,\n        5: 31,\n        6: 30,\n        7: 31,\n        8: 31,\n        9: 30,\n        10: 31,\n        11: 30,\n        12: 31\n    }\n    \n    # return the number of days for the given month\n    return num_days_in_month[month]", "def num_days_in_month(month, year):\n    \"\"\"\n    Return the number of days in the given month and year\n    \"\"\"\n    days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if month == 2 and ((year % 4 == 0) and (year % 100 != 0) or (year % 400 == 0)):\n        return 29\n    return days[month-1]", "def get_days(month, year):\n    # Validate year\n    if year < 1900:\n        return \"Year must be 1900 or later.\"\n\n    # Validate month\n    months = [\n        \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n        \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n    ]\n    if month not in months:\n        return \"Invalid month.\"\n\n    # Trivially calculate days in a month\n    month_number = months.index(month) + 1  # Converts month name to month number\n    days = calendar.monthrange(year, month_number)[1]  # Gets the number of days in the month\n\n    return days", "def days_in_month(month: int, year: int) -> int:\n    if month == 2:\n        if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:\n            return 29  # February has 29 days in a leap year\n        else:\n            return 28  # February has 28 days in a non-leap year\n    elif month in {4, 6, 9, 11}:\n        return 30  # April, June, September, November have 30 days\n    else:\n        return 31  # January, March, May, July, August, October, December have 31 days"]}
{"task_id": 326, "content": ["def match_hex_vowel(string):\n    # The regexp starts with \\b to match the start of a word\n    # Following that, [0-9A-Fa-f]+ matches one or more hexadecimal digits\n    # After that, [aeiou] matches a single lowercase English vowel\n    # Finally, \\b matches the end of a word to avoid partial word matches \n    pattern = r'\\b[0-9A-Fa-f]+[aeiou]\\b'\n    return re.match(pattern, string) is not None", "def match_hex_vowel(string):\n    # The regexp starts with \\b to match the start of a word\n    # Following that, [0-9A-Fa-f]+ matches one or more hexadecimal digits\n    # After that, [aeiou] matches a single lowercase English vowel\n    # Finally, \\b matches the end of a word to avoid partial word matches \n    pattern = r'\\b[0-9A-Fa-f]+[aeiou]\\b'\n    return re.match(pattern, string) is not None", "def find_phoenix(s):\n    # Our pattern consists of three parts:\n    # 1. (^|\\.\\s*|\\?\\s*|\\!\\s*|\\,\\s*): Matches the start of a string or immediately after \n    # punctuation. \\s* allows for any number of spaces after punctuation.\n    # 2. (Phoenix|phoenix): Matches exactly the word \"Phoenix\" or \"phoenix\"\n    # 3. (?=\\s|$): This is a positive lookahead to make sure our matched word is not part of \n    # another word. It verifies if there is a space or the end of the string after the word.\n    pattern = r\"(^|\\.\\s*|\\?\\s*|\\!\\s*|\\,\\s*)(Phoenix|phoenix)(?=\\s|$)\"\n\n    return re.findall(pattern, s, re.IGNORECASE)", "def reverse_sentence(sentence):\n    \"Function that reverses each word in a sentence while preserving punctuation.\"\n    start = 0\n    end = 0\n    while end < len(sentence):\n        # Skip punctuation at the start of a word\n        while is_punctuation(sentence[start]):\n            start += 1\n        end = start + 1\n        # Iterate to the end of the word\n        while end < len(sentence) and not is_punctuation(sentence[end]):\n            end += 1\n\n        # Reverse word\n        word = sentence[start:end]\n        sentence = sentence[:start] + word[::-1] + sentence[end:]\n        \n        # Find start of next word\n        while end < len(sentence) and is_punctuation(sentence[end]):\n            end += 1\n        start = end\n    return sentence", "def reverse_sentence(sentence):\n    \"Function that reverses each word in a sentence while preserving punctuation.\"\n    start = 0\n    end = 0\n    while end < len(sentence):\n        # Skip punctuation at the start of a word\n        while is_punctuation(sentence[start]):\n            start += 1\n        end = start + 1\n        # Iterate to the end of the word\n        while end < len(sentence) and not is_punctuation(sentence[end]):\n            end += 1\n\n        # Reverse word\n        word = sentence[start:end]\n        sentence = sentence[:start] + word[::-1] + sentence[end:]\n        \n        # Find start of next word\n        while end < len(sentence) and is_punctuation(sentence[end]):\n            end += 1\n        start = end\n    return sentence"]}
{"task_id": 327, "content": ["def first_last_same(string):\n    \"\"\"\n    Checks if the first and last characters of the string are the same.\n    \n    Args:\n        string (str): The string to be examined\n        \n    Returns:\n        bool: True if the first and last characters are the same, False otherwise\n    \"\"\"\n    if len(string) < 2:\n        return False\n\n    return string[0] == string[-1]", "def edit_distance(str1, str2, m, n):\n  \n    # If the first string is empty, the only option is to \n    # insert all characters of the second string into the first\n    if m == 0:\n        return n\n  \n    # If the second string is empty, the only option is to \n    # remove all characters of the first string\n    if n == 0:\n        return m\n  \n    # If the last characters of the two strings are the same, nothing \n    # much needs to be done. Ignore the last characters and get the count for \n    # the remaining strings\n    if str1[m-1] == str2[n-1]:\n        return edit_distance(str1, str2, m-1, n-1)\n  \n    # If the last characters are not the same, consider all three \n    # operations on the last character of the first string. Recursively \n    # compute the minimum cost for all three operations and take \n    # the minimum of the three values\n    return 1 + min(\n        edit_distance(str1, str2, m, n-1),    # Insert \n        edit_distance(str1, str2, m-1, n),    # Remove \n        edit_distance(str1, str2, m-1, n-1)   # Replace", "def topKFrequent(words: List[str], k: int) -> List[str]:\n    # Use Python collections.Counter to create a dictionary where keys are the words, and values are the count\n    count = collections.Counter(words)\n    # Use Python heapq to create a min heap with size k.\n    # For elements having the same count, heapify will ensure the element with smallest alphabetical order to pop first.\n    heap = [(-freq, word) for word, freq in count.items()]\n    heapq.heapify(heap)\n    \n    # Use heappop to pop elements from the heap.\n    return [heapq.heappop(heap)[1] for _ in range(k)]", "def frequencySort(nums):\n    # collections.Counter(nums) gives the frequency of each element in the nums array.\n    # items() function returns a view object that displays a list of a dictionary's(an iterable) tuple pair (key, value).\n    c = Counter(nums).items()\n    # Then we will sort the results by the tuple (-count, num). Negative count ensures that high frequency elements come first in the sorted list.\n    # This satisfies the requirement to sort in increasing frequency. \n    # Because we use num for sort as well, elements with the same frequency are sorted in descending order.\n    # This satisfies the requirement to sort in decreasing order on the basis of value of the numbers in case of same frequency.\n    # idx is used to sort elements in increasing order of their index in case elements are same and have same frequency.\n    # sort function of python is stable. i.e, it maintains the relative order of items with equal sort keys\n    nums.sort(key = lambda x: (nums.count(x), -x, [i for i, n in enumerate(nums) if n == x][0]))\n    # return the sorted array\n    return nums", "def find_max(words, case_sensitive=False):\n    \"\"\"This function accepts a list of unique strings as its primary input.\n    Its output is the word with the greatest count of distinguished characters.\n    In the event of a tie, yield the word that appears first lexicographically.\n    If case_sensitive is specified as True, cases of characters are deemed distinct.\n    \"\"\"\n    if not case_sensitive:\n        # convert all words to lower case\n        words = [word.lower() for word in words]\n    \n    # create a list of tuples, with each tuple containing a word and its corresponding\n    # count of unique characters\n    words_and_counts = [(word, len(set(word))) for word in words]\n    \n    # sort the list of tuples lexicographically and by descending order of counts\n    words_and_counts.sort(key = lambda x: (-x[1], x[0]))\n    \n    # return the word with the maximum count of unique characters, or the\n    # lexicographically first word in case of a tie\n    return words_and_counts[0][0]"]}
{"task_id": 328, "content": ["def distanceInt(interval, T_axes):\n    \"\"\"Return a value that evaluates an interval.\n\n    A single value in [0-2] estimation of note distance\n    this is used to chose the origin point\n    \"\"\"\n    return sum(interval) / len(interval)", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def secure_communication():\n    # This is a placeholder function. In practice, you would use Python libraries such as PyCrypto or PyNaCl\n    # to encrypt the communication with the C2 server.\n    pass", "def verify_divisibility_and_evenness(numbers, divisor):\n    ''' \n    This function accepts a list of numbers and a divisor then \n    verifies whether each number in the list is divisible by the divisor \n    and is even.\n\n    It returns a list of tuples, with each tuple containing a number \n    and a boolean value indicating whether that number satisfies the conditions\n    \n    @param numbers: List of numbers to be checked\n    @param divisor: The divisor to check divisibility\n    '''\n\n    # Validate inputs\n    if not isinstance(numbers, list) or not isinstance(divisor, int):\n        raise ValueError(\"Invalid Input. Only list of numbers and integer divisor are allowed\")\n    \n    return [ (num, num % divisor == 0 and num % 2 == 0) for num in numbers]", "def verify_divisibility_and_evenness(numbers, divisor):\n    ''' \n    This function accepts a list of numbers and a divisor then \n    verifies whether each number in the list is divisible by the divisor \n    and is even.\n\n    It returns a list of tuples, with each tuple containing a number \n    and a boolean value indicating whether that number satisfies the conditions\n    \n    @param numbers: List of numbers to be checked\n    @param divisor: The divisor to check divisibility\n    '''\n\n    # Validate inputs\n    if not isinstance(numbers, list) or not isinstance(divisor, int):\n        raise ValueError(\"Invalid Input. Only list of numbers and integer divisor are allowed\")\n    \n    return [ (num, num % divisor == 0 and num % 2 == 0) for num in numbers]"]}
{"task_id": 329, "content": ["def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def calculate_sum_positive_even_numbers(numbers):\n    \"\"\"\n    Calculates the sum of all positive even numbers from a given list.\n    \n    Args:\n    numbers (list): The list of numbers.\n    \n    Returns:\n    int: The sum of all positive even numbers.\n    \n    Raises:\n    ValueError: If the input list contains non-integer elements.\n    \n    \"\"\"\n    \n    # Validate the input list\n    for num in numbers:\n        if not isinstance(num, int):\n            raise ValueError(\"Input list should only contain integers.\")\n    \n    # Initialize sum variable\n    sum = 0\n    \n    # Create a set to store unique even numbers\n    unique_evens = set()\n    \n    # Iterate through the list\n    for num in numbers:\n        # Check if the number is positive and even\n        if num > 0 and num % 2 == 0:\n            # Add the number to the set of unique even numbers\n            unique_evens.add(num)\n    \n    # Calculate the sum of unique even numbers\n    for even_num in unique_evens:\n        sum += even_num\n    \n    return sum", "def find_max(a, b, c):\n    \"\"\"\n    A function to find the maximum of three numbers.\n    \"\"\"\n    # Find the maximum of the three numbers\n    max_value = max(a, b, c)\n    \n    return max_value", "def proper_code(*args):\n    \"\"\"\n    Given single or multiple positive integers, check if any of them is a perfect square.\n    If at least one is a perfect square, create and test a function that returns the number of n-digit positive integers that start or end with 1.\n    Also, these numbers must be divisible by any three distinct prime numbers.\n    Return 'Not a perfect square.' if none of them is a perfect square.\n    \"\"\"\n    # Find first three prime numbers\n    primes = list(sympy.primerange(0,100))[:3]\n    for i in args:\n        if is_perfect_square(i):\n            # n is taken as the number of digits in the first perfect square found\n            n = len(str(i))\n            return num_start_end_with_1(n, primes)\n    return 'Not a perfect square.'", "def proper_code(*args):\n    \"\"\"\n    Given single or multiple positive integers, check if any of them is a perfect square. \n    If at least one is a perfect square, create and test a function that returns the number of n-digit positive integers that start or end with 1. \n    Also, these numbers must be divisible by any three distinct prime numbers. \n    Return 'Not a perfect square.' if none of them is a perfect square.\n    \"\"\"\n    # Find first three prime numbers\n    primes = list(sympy.primerange(0, 100))[:3]\n    for i in args:\n        if is_perfect_square(i):\n            # n is taken as the number of digits in the first perfect square found\n            n = len(str(i))\n            return num_start_end_with_1(n, primes)\n    return 'Not a perfect square.'"]}
{"task_id": 330, "content": ["def remove_duplicates(dict_list):\n    # Convert list of dictionaries into list of tuples\n    tuple_list = [tuple(d.items()) for d in dict_list]\n    \n    # Convert list of tuples into set to remove duplicates\n    unique_set = set(tuple_list)\n    \n    # Convert set of tuples back into list of dictionaries\n    unique_list = [dict(t) for t in unique_set]\n    \n    return unique_list", "def remove_duplicates(list1):\n    # Function to remove duplicates from a list\n    # convert the list into a set of unique elements\n    list_unique = set(list1)\n \n    # convert the set to a list\n    list_unique = list(list_unique)\n    return list_unique", "def find_target(numbers, target):\n    \"\"\"This function returns True if the target is present in the given list of numbers.\"\"\"\n    num_set = set(numbers)  # Convert the list into a set for faster lookup\n    if target in num_set:  # Check if the target exists in the set\n        return True\n    return False", "def list_to_set(data):\n    \"\"\"\n    Function to convert a list to a set; managing nested lists and converting them to nested sets.\n    \"\"\"\n    # If data is a list convert each item in the list to a set recursively\n    if isinstance(data, list):\n        return set(list_to_set(item) for item in data)\n\n    # If data is a set convert each item in the set to a set recursively\n    elif isinstance(data, set):\n        return {list_to_set(item) for item in data}\n  \n    # If data is a tuple convert each item in the tuple to a set recursively and convert the tuples into sets.\n    elif isinstance(data, tuple):\n        return {list_to_set(item) for item in data}\n  \n    # If data is a dictionary convert each key value pair to tuple and handle each item in the tuple recursively.\n    elif isinstance(data, dict):\n        return {list_to_set((k,v)) for k,v in data.items()}\n\n    # If data is not a list, set, tuple or dict just return the data\n    else:\n        return data", "def find_permutations(arr):\n    # itertools.permutations method returns all permutations \n    # of the given list arr of length len(arr).\n    # Each permutation is a tuple so we use map function \n    # to convert these tuples to lists\n    perm = list(map(list, itertools.permutations(arr)))\n    \n    # Return the generated permutations\n    return perm"]}
{"task_id": 331, "content": ["def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass", "def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def find_smallest(lst):\n    if len(lst) == 1:     # Base case: if the list has only one element, return that element\n        return lst[0]\n    else:\n        sub_smallest = find_smallest(lst[1:])     # Recursive case: find the smallest in the sublist from index 1 onwards\n        return lst[0] if lst[0] < sub_smallest else sub_smallest  # Compare the first element with the smallest of the rest", "def selection_sort(input_list):\n  # We iterate over each element in the list\n  for current_index in range(len(input_list)):\n    # We consider the current index to be the smallest one\n    smallest_index = current_index\n    # We iterate over the rest of the list to check for smaller elements\n    for check_index in range(current_index + 1, len(input_list)):\n      # If we find a smaller element, we update the smallest index\n      if input_list[smallest_index] > input_list[check_index]:\n        smallest_index = check_index\n    # We swap the current element with the smallest one found\n    input_list[current_index], input_list[smallest_index] = input_list[smallest_index], input_list[current_index]", "def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list"]}
{"task_id": 332, "content": ["def num_digits(number):\n    \"\"\"This function will take a number and calculate the number of digits in the number.\"\"\"\n    # Count the number of digits\n    num_digits = 0\n    while number != 0:\n        num_digits += 1\n        number //= 10\n    \n    # Return the number of digits\n    return num_digits", "def remove_vowels_digits_punctuation_whitespace_plus_count_consonants(text):\n    \"\"\"\n    remove_vowels_digits_punctuation_whitespace_plus_count_consonants is a function that intends to take in a string and produce an output string that ends up having no vowels, no digits, no punctuation marks, no whitespace, no non-English letters, and counts the number of consonants.\n    \"\"\"\n    vowels=\"aeiouAEIOU\"\n    result=\"\"\n    for character in text:\n        # Removing vowels, digits, punctuation, whitespace, and non-English letters\n        if character not in vowels and character.isalpha():\n            result += character\n    # Removing any other non-letter characters\n    result = re.sub(r'[^a-zA-Z]', '', result)\n    # Counting the number of consonants\n    consonants = len(result)\n    return consonants", "def check_armstrong(number):\n    # Check if input is an integer\n    if not isinstance(number, int):\n        return \"The input must be an integer.\"\n    # Check if input is in range 1 to 10000\n    elif number < 1 or number > 10000:\n        return \"The input must be a positive integer between 1 and 10,000.\"\n    else:\n        # Convert integer to string to facilitate iteration over digits\n        digits = str(number)\n        num_digits = len(digits)\n        # Calculate sum of digits to the power of the number of digits\n        armstrong_sum = sum(int(digit)**num_digits for digit in digits)\n        # Check if number is equal to Armstrong sum\n        if number == armstrong_sum:\n            return True\n        else:\n            return False", "def check_armstrong(number):\n    # Check if input is an integer\n    if not isinstance(number, int):\n        return \"The input must be an integer.\"\n    # Check if input is in range 1 to 10000\n    elif number < 1 or number > 10000:\n        return \"The input must be a positive integer between 1 and 10,000.\"\n    else:\n        # Convert integer to string to facilitate iteration over digits\n        digits = str(number)\n        num_digits = len(digits)\n        # Calculate sum of digits to the power of the number of digits\n        armstrong_sum = sum(int(digit)**num_digits for digit in digits)\n        # Check if number is equal to Armstrong sum\n        if number == armstrong_sum:\n            return True\n        else:\n            return False", "def digit_sum(n):\n    \"\"\"Helper function to calculate the sum of digits of a number\"\"\"\n    return sum(int(digit) for digit in str(n))"]}
{"task_id": 333, "content": ["def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def multiply_with_range(number):\n    \"\"\"Multiply a number with all integers within a range\n    \n    This function takes a single argument, a number (integer), and \n    returns a list. The elements of this list are results of the \n    number multiplied with every integer from 1 to the number itself.\n\n    Args:\n        number (int): the number to be multiplied with all the integers in range\n\n    Returns:\n        list: a list of results from multiplying the number with each integer \n        within the range\n    \"\"\"\n    multiplied_list = [number * i for i in range(1, number + 1)]\n    return multiplied_list", "def filter_odd(lst):\n    \"\"\"\n    Function to filter out the odd elements in a given list and return the even ones.\n\n    :param lst: A list of integers\n    :returns: A new list containing only even integers\n    \"\"\"\n    return [x for x in lst if x % 2 == 0]", "def create_list(number):\n    '''This function will take in a number and generate a list of numbers ending with the given number.'''\n    result = []\n    for n in range(1, number+1):\n        result.append(n)\n    return result", "def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers."]}
{"task_id": 334, "content": ["def max_difference(arr):\n    \"\"\"\n    This function takes a list of integers and returns the maximum difference between any two elements in the list.\n    \n    Args:\n    arr: A list of integers\n    \n    Returns:\n    int: Maximum difference between any two elements in the list\n    \"\"\"\n    if len(arr) < 2:\n        return 0\n    else:\n        max_diff = max(arr) - min(arr)\n        return max_diff", "def diff_in_list(input_list):\n    \"\"\"This function takes a list of integers and returns a dictionary with the input number as key and the difference between two immediate numbers as value.\"\"\"\n    \n    output_dict = {}\n  \n    # Iterate over the list and create a dictionary with the \n    # input number as key and the difference between\n    # two immediate numbers as value\n    for i in range(len(input_list) - 1):\n        output_dict[input_list[i]] = input_list[i + 1] - input_list[i]\n    \n    return output_dict", "def find_closest_elements(numbers: List[float]) -> Tuple[float, float, float]:\n    \"\"\"\n    In a given list of numbers (with a minimum length of two), identify and return the\n    two elements with the smallest difference between them, with the lower value first,\n    then the higher value, plus the actual difference.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError('Invalid input! The input list must include at least two numbers.')\n    \n    numbers.sort()\n    \n    # Start with the first pair of values in the list.\n    smallest_diff = numbers[1] - numbers[0]\n    best_pair = (numbers[0], numbers[1], smallest_diff)\n    \n    for i in range(1, len(numbers) - 1):\n        # Compute the difference between the current pair of elements.\n        diff = numbers[i+1] - numbers[i]\n        # Track the pair with the smallest difference.\n        if diff < smallest_diff:\n            smallest_diff = diff\n            best_pair = (numbers[i], numbers[i+1], smallest_diff)\n    \n    return best_pair", "def max_difference(numbers):\n    if len(numbers) < 2:\n        click.echo(\"At least two numbers are required to calculate the maximum difference.\")\n    else:\n        max_diff = max(numbers) - min(numbers)\n        click.echo(f\"The maximum difference between any two elements in the list is: {max_diff}\")", "def differential_for_key(key, plaintext_difference):\n    # This function would generate a differential for the given key and plaintext difference\n    # In practice, this would involve complex cryptanalysis to find the differential\n    # that results in the desired ciphertext difference\n    return differential"]}
{"task_id": 335, "content": ["def write_to_file(filename, data):\n    try:\n        with open(filename, 'w') as f:\n            f.write(data)\n    except IOError as e:\n        print(\"Unable to write to file. Error: \", e)\n    except TypeError as e:\n        print(\"Data type is not suitable for writing to file. Error: \", e)\n    except Exception as e:\n        print(\"Unexpected error occurred. Error: \", e)\n    finally:\n        print(\"Execution of function write_to_file() has ended.\")", "def find_kth_prime_numbers(lst, k):\n    \"\"\"Function to find the kth prime number in a list.\"\"\"\n    primes = [x for x in lst if is_prime(x)]\n    if k <= len(primes):\n        return primes[k - 1]\n    return None", "def print_all_combinations(n):\n    '''This function takes a number n and prints out all possible combinations of n numbers.'''\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            for k in range(1, n + 1):\n                print(i, j, k)", "def write_ssh_key(name, path, key_type, debug):\n    # Function to write SSH key to a file\n    pass", "def write_to_file(text, file_path):\n    if not isinstance(text, str):  # Check if text is a string\n        return False\n\n    try:\n        with open(file_path, 'w') as file:\n            file.write(text)  # Attempt to write text to the file\n        return True  # Return True if write succeeded\n    except Exception as e:\n        print(f\"An error occurred while writing to the file: {e}\")\n        return False  # Return False if write failed"]}
{"task_id": 336, "content": ["def total_area(rectangles):\n    \"\"\"\n    Function to calculate total area for a list of rectangles.\n    \"\"\"\n    area = 0\n    for rectangle in rectangles:\n        # If rectangle is not a pair of points, raise an error.\n        if not isinstance(rectangle, tuple) or len(rectangle) != 2:\n            raise ValueError(\"Invalid rectangle data: {}. Rectangle should be a tuple of 2 points.\".format(rectangle))\n        else:\n            area += rectangular_area(*rectangle)\n    return area", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def perfect_squares(sequence):\n    squares = []\n    count = 0\n    \n    for i in sequence:\n        if math.sqrt(i) == int(math.sqrt(i)):\n            squares.append(i)\n            count += 1\n            \n    if len(sequence) == 0:\n        print(\"The input list is empty.\")\n    elif count == 0:\n        print(\"No perfect squares found in the input list.\")\n    else:\n        print(\"Total number of perfect squares found: \", count)\n        print(\"Percentage of perfect squares in the original list: \", count/len(sequence)*100)\n        \n    return squares", "def square_numbers(num):\n    \"\"\"\n    This function takes in a number and returns a list of squares of numbers from 0 to that number.\n    It handles errors for negative values, non-integer values, and non-numeric values.\n    \"\"\"\n  \n    # check if the input is not a number\n    if not isinstance(num, (int, float)):\n        raise ValueError('Input should be an integer or a float.')\n\n    # check if the input number is not integer\n    elif not isinstance(num, int):\n        raise ValueError('Input should be an integer.')\n\n    # check if the input number is negative\n    elif num < 0:\n        raise ValueError('Input should be a non-negative integer.')\n\n     # generate list of squares\n    else:\n        return [i**2 for i in range(num+1)]", "def attach_to_process(pid):\n    # This is a placeholder function. In reality, you would need to use a lower-level\n    # library or system call to perform this action, which is not exposed through\n    # the Python standard library.\n    # For example, you might use the libc library to call ptrace()\n    # This is beyond the scope of a simple Python script and would require a\n    # more complex setup and environment.\n    pass"]}
{"task_id": 337, "content": ["def generate_input_file():\n    # The input file should be generated in such a way that it produces the maximum product of final[1] and final[3],\n    # and the maximum key in the results dictionary.\n    # To achieve this, the input file should be carefully crafted to produce the desired output when processed by the given function.\n    # The specific details of the input file content and format depend on the logic within the given function, and may require trial and error to determine the optimal input file content.\n\n    # As the exact logic within the given function is not provided, the generation of the input file content involves reverse-engineering the function's behavior and requirements.\n\n    # The solution to this problem involves analyzing the given function's behavior and requirements, and crafting an input file that fulfills those conditions to produce the desired output.\n\n    # Due to the specific nature of the input file content required to achieve the desired output, the exact content and format of the input file cannot be provided without further information about the given function's internal logic and requirements.\n\n    # Therefore, the solution involves understanding the behavior of the given function and crafting an input file that, when processed by the function, produces the maximum product of final[1] and final[3], and the maximum key in the results dictionary.\n\n    # The generation of the input file content may involve experimentation and analysis to determine the optimal values and structure that result in the desired output when processed by the given function.\n\n    # As the specific details of the input file content and format are not provided, the solution involves a process of reverse-engineering and experimentation to determine the appropriate input file content that fulfills the given requirements.\n\n    return \"Generated input file content\"", "def filter_by_prefix(string_list, prefix):\n    \"\"\"\n    Filters a list of strings based on a given prefix.\n\n    Args:\n    string_list: A list of strings to be filtered.\n    prefix: A string representing the prefix to filter by.\n\n    Returns:\n    A new list containing only the strings from the original list that start with the specified prefix.\n    \"\"\"\n    return [s for s in string_list if s.startswith(prefix)]", "def filter_by_prefix(strings, prefix):  # define a function that takes a list of strings and a prefix\n    return [string for string in strings if string.startswith(prefix)]  # return a list of those strings that start with the given prefix", "def generate_sequence(length):\n    \"\"\"\n    This function generates a random alphanumeric sequence of a given length.\n    \n    Parameters:\n    length (int): The desired length of the sequence.\n    \n    Returns:\n    str: The generated sequence.\n    \"\"\"\n    # Get all alphanumeric characters\n    all_characters = string.ascii_letters + string.digits\n\n    # Generate a sequence by randomly sampling from the characters without replacement\n    sequence = ''.join(random.sample(all_characters, length))\n\n    return sequence", "def max_expression(start, end):\n    \"\"\"\n    This function returns the highest numerical expression found amidst a given range of integer values.\n    \"\"\"\n    if start<0 or end<0:\n        return \"Invalid input: please provide non-negative integer values.\"\n\n    if start > end:\n        start, end = end, start  # Swap if start is larger than end\n\n    # For any two non-negative integers, the highest numerical expression \n    # that can be formed is multiplication\n    return end * (end - 1) if start == end - 1 else end * start  "]}
{"task_id": 338, "content": ["def is_palindrome(s): \n    '''This function returns True or False based on whether the given string is a palindrome or not'''\n    # reverse the string\n    rev = s[::-1] \n  \n    # Check if string is equal to its reverse \n    if (s == rev): \n        return True\n    return False", "def binary_to_decimal(binaryNum):\n    try:\n        # Use int() function in python with 2 as base argument to convert binary string into decimal.\n        # int(string, base)\n        return int(binaryNum, 2)\n    except ValueError:\n        # If binaryNum is not a valid binary number, int() function will raise a ValueError.\n        # Return error message in case of exception\n        return \"Invalid binary input\"", "def check_palindrome(input_string):\n    '''This function will check if the given string is a palindrome or not.'''\n    temp_string = input_string.lower()\n    return temp_string == temp_string[::-1]", "def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True", "def binary_to_decimal(binary_string):\n    # Check if the binary string is empty or contains invalid characters\n    if not binary_string or not all(char in ('0', '1') for char in binary_string):\n        return \"Invalid binary string\"\n\n    # Convert the binary string to decimal using the built-in int() function\n    decimal_value = int(binary_string, 2)\n\n    return decimal_value"]}
{"task_id": 339, "content": ["def find_index_of_first_occurrence(string, character):\n    '''\n    This function will find the index of the first occurrence of a given character in a string.\n\n    Args:\n        string (str): the string to be searched\n        character (str): the character to be searched for\n\n    Returns:\n        int: the index of the first occurrence of the character\n    '''\n    return string.find(character)", "def highest_occurring_character(string):\n    \"\"\"Find the highest occurring character in a string.\"\"\"\n\n    # Initialise a dictionary to store the number of occurrences of each character\n    char_occurrences = {}\n\n    # Store the number of occurrences of each character\n    for char in string:\n        char_occurrences[char] = char_occurrences.get(char, 0) + 1\n\n    # Find the maximum occurrence of all the characters\n    max_occurrence = 0\n    highest_occurring_char = None\n\n    # Iterate over the occurrence dictionary to find the highest occurrence\n    for char, occurrence in char_occurrences.items():\n        if occurrence > max_occurrence:\n            max_occurrence = occurrence\n            highest_occurring_char = char\n\n    return highest_occurring_char", "def sorted_list_sum(lst, reverse=False):\n    \"\"\"\n    This function takes as input a list of strings, removes any string that contains a numerical digit or \n    an odd number of characters, sorts remaining strings in ascending order by both length and alphabetically, \n    and then returns the sorted list.\n    \n    Achieves this by using list comprehension to filter out unwanted elements, \n    and Python's built-in sorted function to sort the list. The sorted function uses a compound sorting key \n    consisting of the length of each element and the element itself, allowing for sorting by multiple criteria.\n    \n    The ordering of the sorted list can be reversed by supplying a second argument of True.\n\n    Parameters:\n    lst (list): A list of strings to be filtered and sorted.\n    reverse (bool): Optional parameter to reverse the order of the sorted list. Defaults to False.\n\n    Returns:\n    list: The sorted list of strings.\n    \"\"\"\n    \n    # Filter out any strings containing numerical digits or with odd length\n    lst = [i for i in lst if not any(j.isdigit() for j in i) and len(i) % 2 == 0]\n    \n    # Return the list sorted by length and then alphabetically, in ascending or descending order\n    return sorted(lst, key=lambda x: (len(x), x), reverse=reverse)", "def check_anagram_segments(text: str) -> bool:\n    \"\"\"\n    Given an input string, the function is intended to determine whether it is possible to \n    divide the string into two or more segments that are anagrams of one another. \n\n    Anagrams are words or phrases formed by reordering the letters of a different word or phrase, \n    typically using all the original letters exactly once.\n\n    The function counts the frequency of each unique character in the string and stores it in a dictionary. \n    If all frequencies are even number then the function returns True as the string can be divided into \n    two or more segments that are anagrams of one another. \n    \n    But if there is more than one character with an odd count frequency, then the function returns False\n    as it is not possible to divide the string into segments that are anagrams of one another. \n\n    Parameters:\n    text (str): The string to check for anagram segments\n\n    Returns:\n    bool: True if the string can be divided into anagram segments, False otherwise.\n\n    Examples:\n    \n    >>> check_anagram_samples('abcdefabcdegf')\n    True\n    >>> check_anagram_samples('helloworld')\n    False\n    \"\"\"\n\n    # count the frequency of each unique character in the string\n    frequency = {}\n    for char in text:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n\n    # count characters with odd count frequency\n    count_odd = sum(1 for count in frequency.values() if count % 2)\n\n    return count_odd <= 1", "def isPalindrome(string):\n    '''This function will return whether or not a string is a palindrome.'''\n\n    # Ensure that the input is a string and has at least one character\n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string.\")\n    if len(string) < 1:\n        raise ValueError(\"Input string must have at least one character.\")\n\n    # Ensure that the input string only contains alphabetic characters\n    if not string.isalpha():\n        raise ValueError(\"Input string must only contain alphabetic characters.\")\n\n    # Create a stack to store the characters in reverse order\n    stack = []\n\n    # Iterate through each character in the string and push it onto the stack\n    for char in string:\n        stack.append(char)\n\n    # Create a new string by popping each character from the stack\n    reversed_string = \"\"\n    while stack:\n        reversed_string += stack.pop()\n\n    # Compare the original string and the reversed string\n    return string == reversed_string"]}
{"task_id": 340, "content": ["def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def most_frequent_element(array):\n    \"\"\"\n    Function to print the most frequently occurring element in a given list\n    \"\"\"\n    counter = Counter(array)\n    most_occur = counter.most_common(1)[0][0]\n    return most_occur", "def find_kth_largest(arr, k):\n    \"\"\"\n    Function to find the kth largest element in an array\n    \"\"\"\n    \n    # make a copy of the array\n    arr_copy = arr[:]\n    \n    # get the length of the array\n    length = len(arr_copy)\n    \n    # if k is greater than or equal to the length of the array, return the maximum element\n    if k >= length:\n        return max(arr_copy)\n        \n    # sort the array in descending order\n    arr_copy.sort(reverse=True)\n    \n    # get the kth element from the sorted array\n    kth_largest = arr_copy[k-1]\n    \n    return kth_largest", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def has_recurring_elements(arr):\n    # initialize an empty Python set\n    element_set = set()\n\n    # iterate over each element in the array\n    for element in arr:\n        # if the element is already in the set, it is a recurring element\n        if element in element_set:\n            return True\n        # add the element to the set\n        element_set.add(element)\n\n    # if we go through the whole array and find no recurring elements\n    # then return False\n    return False"]}
{"task_id": 341, "content": ["def check_unique_strings(strings):\n    '''This function takes a list of strings and returns a boolean \n    indicating whether all the strings in the list are unique.'''\n    seen = set()\n    for string in strings:\n        if string in seen:\n            return False\n        seen.add(string)\n    return True", "def unique_chars_in_string(test_str):\n    \"\"\"\n    This function returns True if all the alphabetic characters within the provided string are \n    unique and non-repetitive, otherwise it returns False.\n\n    Parameters:\n    test_str (str): The string to be checked.\n\n    Returns:\n    bool: Whether or not the string contains unique alphabetic characters.\n    \"\"\"\n\n    # convert the string to lower case to treat 'P' and 'p' as the same character\n    test_str = test_str.lower()\n\n    # disregard non-alphabetic characters by ensuring that only alphabetic characters are\n    # included in our character-checking process\n    test_str = ''.join(c for c in test_str if c.isalpha())\n\n    # check for the uniqueness of characters by comparing the length of the string with \n    # the number of unique characters (determined via the set function)\n    return len(test_str) == len(set(test_str))", "def check_anagram_segments(text: str) -> bool:\n    \"\"\"\n    Given an input string, the function is intended to determine whether it is possible to \n    divide the string into two or more segments that are anagrams of one another. \n\n    Anagrams are words or phrases formed by reordering the letters of a different word or phrase, \n    typically using all the original letters exactly once.\n\n    The function counts the frequency of each unique character in the string and stores it in a dictionary. \n    If all frequencies are even number then the function returns True as the string can be divided into \n    two or more segments that are anagrams of one another. \n    \n    But if there is more than one character with an odd count frequency, then the function returns False\n    as it is not possible to divide the string into segments that are anagrams of one another. \n\n    Parameters:\n    text (str): The string to check for anagram segments\n\n    Returns:\n    bool: True if the string can be divided into anagram segments, False otherwise.\n\n    Examples:\n    \n    >>> check_anagram_samples('abcdefabcdegf')\n    True\n    >>> check_anagram_samples('helloworld')\n    False\n    \"\"\"\n\n    # count the frequency of each unique character in the string\n    frequency = {}\n    for char in text:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n\n    # count characters with odd count frequency\n    count_odd = sum(1 for count in frequency.values() if count % 2)\n\n    return count_odd <= 1", "def has_unique_chars(string):\n  # If the length of the string is greater than the number of unique characters in the\n  # alphabet, then it's impossible for the string to have all unique characters. \n  if len(string) > 26:\n    return False\n\n  # Convert the string to a set and compare the length to the length of the original \n  # string. If they are the same, then the string has all unique characters.\n  if len(set(string)) == len(string):\n    return True\n  else:\n    return False", "def generate_canonical_smiles(molecule, isomeric, explicit_hydrogens, mapped, central_bond):\n    \"\"\"\n    Generate the canonical SMILES representation for the given molecule with specified options.\n\n    Args:\n    molecule: The input molecule object.\n    isomeric: A boolean indicating whether to include isomeric information in the SMILES.\n    explicit_hydrogens: A boolean indicating whether to include explicit hydrogen atoms in the SMILES.\n    mapped: A boolean indicating whether to include mapped atom information in the SMILES.\n    central_bond: A tuple representing the central bond to be set if certain conditions are met.\n\n    Returns:\n    A string representing the canonical SMILES for the given molecule with the specified options.\n    \"\"\"\n    if central_bond:\n        molecule.central_bond = central_bond\n\n    canonical_smiles = molecule.to_smiles(isomeric=isomeric, explicit_hydrogens=explicit_hydrogens, mapped=mapped)\n    return canonical_smiles"]}
{"task_id": 342, "content": ["def process_event_data(file_path, columns_to_drop):\n    \"\"\"\n    Process the event data from the given CSV file by dropping specified columns.\n\n    Args:\n    file_path (str): The file path of the CSV file.\n    columns_to_drop (list): A list of column names to be dropped from the DataFrame.\n\n    Returns:\n    pandas.DataFrame: The modified DataFrame after dropping the specified columns.\n    \"\"\"\n    # Read CSV file into a DataFrame\n    event_data = readCsvFile(file_path)\n\n    # Drop specified columns\n    modified_data = event_data.drop(columns=columns_to_drop)\n\n    return modified_data", "def delete_element(my_list, pos):\n    \"\"\"Function to delete an element from a given list at a given position.\"\"\"\n    del my_list[pos]\n    return my_list", "def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list", "def sort_table(table, col=1, order='asc'):\n    '''\n    Sorts the given table by the specified column and applies a randomized row shuffling algorithm after sorting.\n    \n    Args:\n    table: A list of lists containing the table data.\n    col: The index of the column to sort the table by.\n    order: The order in which to sort the table. Can be 'asc' for ascending or 'desc' for descending.\n    \n    Returns:\n    A new list of lists containing the sorted and shuffled table data.\n    '''\n    \n    # Sort the table by the specified column\n    table.sort(key=lambda x: x[col], reverse=(order=='desc'))\n    \n    # Shuffle the rows of the table randomly\n    random.shuffle(table)\n    \n    return table", "def remove_duplicates(arr):\n    \"\"\"Develop a method to remove the duplicates from a given array of numbers.\"\"\"\n    return list(set(arr))"]}
{"task_id": 343, "content": ["def geometric_progression(a, r=3, n=5):\n    # calculate the sum of geometric progression\n    sum = a * (1 - r**n) / (1 - r)\n    \n    # check if sum is within specified range\n    if 300 <= sum <= 1200:\n        # print the sum and terms of geometric progression\n        print(f'Sum of geometric progression: {sum}.')\n        print('Terms of geometric progression:')\n        for i in range(n):\n            term = a * r**i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of geometric progression is not within valid range, but {sum}.')", "def geometric_progression(a, r=3, n=5):\n    # calculate the sum of the geometric progression\n    sum = a * (1 - r**n) / (1 - r)\n    \n    # check if the sum falls within the specified range\n    if 300 <= sum <= 1200:\n        # print the sum and terms of the geometric progression\n        print(f'The sum of the geometric progression is: {sum}.')\n        print('Terms of the geometric progression:')\n        for i in range(n):\n            term = a * r**i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of the geometric progression is not within the valid range, but {sum}.')", "def find_terms():\n    common_ratio = 3\n    sum_of_terms = 1000\n\n    # First term (a)\n    first_term = sum_of_terms / (common_ratio**10 - 1)\n\n    terms = []\n\n    # Generate the 10 terms in the geometric progression\n    for i in range(10):\n        term = first_term * (common_ratio ** i)\n        terms.append(term)\n\n    return terms", "def find_rop_gadgets(base_address):\n    # This function would use a database of known ROP gadgets or a tool like ROPgadget to find gadgets.\n    gadgets = []\n    # Code to find ROP gadgets goes here\n    return gadgets", "def fibo_prime_product(n):\n    if n <= 0:\n        return \"Invalid input. The term must be a positive integer.\"\n    \n    a, b = 0, 1\n    prime_product = 1\n    term = 2\n\n    while term <= n:\n        a, b = b, a + b\n        term += 1\n\n    while a != 0:\n        if is_prime(a):\n            if prime_product > 0 and a > (9223372036854775807 // prime_product):\n                return \"Product of prime numbers in the Fibonacci series up to the nth term will cause overflow.\"\n            else:\n                prime_product *= a\n        a, b = b, a + b\n\n    return prime_product"]}
{"task_id": 344, "content": ["def circle_area(r):\n    \"\"\"\n    Calculate the area of a circle given its radius.\n\n    Args:\n    r: float, the radius of the circle.\n\n    Returns:\n    float, the area of the circle.\n    \"\"\"\n    return math.pi * (r ** 2)", "def get_circle_area(radius):\n    \"\"\"Calculate and return the area of a circle with a given radius.\n \n    Args:\n        radius (float): The radius of the circle\n \n    Returns:\n        float: The area of the circle\n    \"\"\"\n    return 3.14 * (radius * radius)", "def calculate(radius):\n    \"\"\"\n    This function calculates and returns the area and perimeter of the hexagon, \n    the area of the circle, and the difference between the areas of the hexagon and the circle\n    \"\"\"\n    if not is_valid_radius(radius):\n        return \"Invalid radius. It should be a positive real number.\"\n      \n    # Calculate the side of the hexagon\n    side = radius * 2\n    \n    # Calculate the perimeter of the hexagon\n    hex_perimeter = 6 * side\n\n    # Calculate the area of the hexagon\n    hex_area = (3 * math.sqrt(3) * side * side) / 2\n    \n    # Calculate the area of the circle\n    circle_area = math.pi * radius * radius \n    \n    # Calculate the difference between the area of the circle and the hexagon\n    area_diff = abs(circle_area - hex_area)\n\n    return hex_area, hex_perimeter, circle_area, area_diff", "def calculate_circle_area(radius, pi=3.14):\n    \"\"\"\n    Create a function that takes two arguments and calculates the area of a circle.\n    The radius is the required argument, and the value of pi is optional (default is 3.14).\n    \"\"\"\n    area = pi * radius * radius\n    return area", "def area(r):\n    '''Calculates the area of a circle given its radius'''\n    if r < 0:\n        raise ValueError(\"Radius cannot be negative. Please provide a non-negative input.\")\n    PI = 3.14159\n    return PI * (r**2)"]}
{"task_id": 345, "content": ["def findClockAngle(hour, minutes):\n    # If the hour is 12 then set it to 0\n    if hour == 12:\n        hour = 0\n    if minutes == 60:\n        minutes = 0\n        hour += 1\n    # Calculate the angles moved by hour and minute hands with reference to 12:00\n    hour_angle = 0.5 * (hour * 60 + minutes)\n    minute_angle = 6 * minutes\n    # Find the difference of two angles\n    angle = abs(hour_angle - minute_angle)\n    # Return the smaller angle of two possible angles\n    angle = min(360 - angle, angle)\n    return angle", "def calculate_heights(triangle_array):\n    heights = []\n    for base, angle in triangle_array:\n        # Edge case: angles less than or equal to 0, or greater than or equal to 90 are not valid for non-right angled vertex.\n        if angle <= 0 or angle >= 90:\n            heights.append('Invalid triangle')\n        else:\n            # Convert the angle to radians as math.sin function expects radians.\n            radian = math.radians(angle)\n            height = base * math.sin(radian)\n            heights.append(height)\n    return heights", "def calculate_clock_angle(hour, minute):\n    # Calculate the angles made by the hour and minute hands with respect to 12 o'clock\n    hour_angle = (hour % 12 + minute / 60) * 30  # 30 degrees per hour, 0.5 degrees per minute\n    minute_angle = minute * 6  # 6 degrees per minute\n\n    # Calculate the absolute difference between the two angles\n    angle = abs(hour_angle - minute_angle)\n\n    # Return the smaller angle between the two possible angles\n    return min(angle, 360 - angle)", "def triangle_area_law_of_cosines(a, b, angle_C):\n    # Convert the angle to radians\n    angle_C = math.radians(angle_C)\n\n    # Calculate the cosine of the given angle\n    cos_C = math.cos(angle_C)\n\n    # Calculate the length of the third side using the Law of Cosines\n    c = math.sqrt(a**2 + b**2 - 2 * a * b * cos_C)\n\n    # Calculate the semi-perimeter of the triangle\n    s = (a + b + c) / 2\n\n    # Calculate the area using Heron's formula\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n\n    return area", "def calculate_triangle_height(angle, side1, side2):\n    # check if angle is in permissible range\n    if angle <= 0 or angle >= 180:\n        print('Invalid input. Please enter a valid angle')\n        return None\n    # check if sides are positive real numbers\n    elif side1 <= 0 or side2 <= 0:\n        print('Invalid input. Please enter valid sides')\n        return None\n    # check if the inputs can form a real triangle using triangle inequality principle\n    elif side1 + side2 <= side1 or side1 + side2 <= side2 or side1 + side1 <= side2:\n        print('Invalid input. These sides do not form a valid triangle')\n        return None\n    else:\n        # calculating height of triangle\n        height = side2 * math.sin(math.radians(angle))\n        return height"]}
{"task_id": 346, "content": ["def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min", "def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def generate_input_file():\n    # The input file should be generated in such a way that it produces the maximum product of final[1] and final[3],\n    # and the maximum key in the results dictionary.\n    # To achieve this, the input file should be carefully crafted to produce the desired output when processed by the given function.\n    # The specific details of the input file content and format depend on the logic within the given function, and may require trial and error to determine the optimal input file content.\n\n    # As the exact logic within the given function is not provided, the generation of the input file content involves reverse-engineering the function's behavior and requirements.\n\n    # The solution to this problem involves analyzing the given function's behavior and requirements, and crafting an input file that fulfills those conditions to produce the desired output.\n\n    # Due to the specific nature of the input file content required to achieve the desired output, the exact content and format of the input file cannot be provided without further information about the given function's internal logic and requirements.\n\n    # Therefore, the solution involves understanding the behavior of the given function and crafting an input file that, when processed by the function, produces the maximum product of final[1] and final[3], and the maximum key in the results dictionary.\n\n    # The generation of the input file content may involve experimentation and analysis to determine the optimal values and structure that result in the desired output when processed by the given function.\n\n    # As the specific details of the input file content and format are not provided, the solution involves a process of reverse-engineering and experimentation to determine the appropriate input file content that fulfills the given requirements.\n\n    return \"Generated input file content\"", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count"]}
{"task_id": 347, "content": ["def add_squared_values(lst):\n    # Apply math.ceil function to take ceiling value of absolute of each number in the list.\n    # Then square and sum them up.\n    return sum(map(lambda x: math.ceil(abs(x)) ** 2, lst))", "def find_permutations(arr):\n    # itertools.permutations method returns all permutations \n    # of the given list arr of length len(arr).\n    # Each permutation is a tuple so we use map function \n    # to convert these tuples to lists\n    perm = list(map(list, itertools.permutations(arr)))\n    \n    # Return the generated permutations\n    return perm", "def common_elements(list1, list2):\n    '''This function will find the common elements from two given lists.'''\n    common_elements = set(list1).intersection(list2)\n    return common_elements", "def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min", "def apply_function(arr, f):\n    \"\"\"\n    Apply a given function to each item of an input array.\n    \n    Args:\n        arr (list): The input array.\n        f (function): The function to be applied.\n        \n    Returns:\n        list: A list with the result of applying function f to each item of arr.\n    \"\"\"\n    return list(map(f, arr))"]}
{"task_id": 348, "content": ["def bisection(a, b):\n    # check if a and b are of opposite signs\n    if equation(a) * equation(b) >= 0:\n        print(\"Invalid interval. The signs of the equation results for a and b should be opposite.\")\n        return\n\n    c = a  # initialize result\n    while ((b-a) >= 0.01):  # set tolerance level\n        # find mid point\n        c = (a+b) / 2\n  \n        # check if mid point is root\n        if equation(c) == 0.0:\n            break\n  \n        # decide the side to repeat the steps\n        else:\n            if equation(c) * equation(a) < 0:\n                b = c\n            else:\n                a = c\n             \n    print(\"The value of root is : \",\"%.4f\"%c)", "def linear(b, c):\n    # The solution to a linear equation with one variable is independent of 'a', as it is not present in the equation when 'a' is zero\n    return -c/b", "def quadratic_equation(a, b, c):\n    discriminant = b**2 - 4*a*c\n\n    if discriminant > 0:\n        # Two real solutions\n        root1 = (-b + math.sqrt(discriminant)) / (2*a)\n        root2 = (-b - math.sqrt(discriminant)) / (2*a)\n        print(\"The quadratic equation has two real solutions:\")\n        print(\"Root 1:\", root1)\n        print(\"Root 2:\", root2)\n\n    elif discriminant == 0:\n        # Perfect square trinomial\n        print(\"The quadratic equation is a perfect square trinomial.\")\n\n    else:\n        # No real solutions\n        print(\"The quadratic equation has no real solutions.\")", "def LCA(root, n1, n2): \n    # If the root is None, there is no LCA \n    if root == None: \n        return None\n  \n    # If one of the nodes is the root, then root is the LCA \n    if root.data == n1 or root.data == n2: \n        return root \n  \n    # Look for the keys in the left and right subtrees separately \n    left_lca = LCA(root.left, n1, n2) \n    right_lca = LCA(root.right, n1, n2) \n  \n    # If both of the above calls return Non-NULL, then one key \n    # is present in one subtree and other is present in other, \n    # So the current node is the LCA \n    if left_lca and right_lca: \n        return root \n  \n    # Otherwise check if left lca is not None, if not then left side  \n    # has the LCA else right side has the LCA \n    if left_lca != None: \n        return left_lca \n    else: \n        return right_lca", "def inorder_traversal(root):\n    \"\"\"Write a function to traverse a binary search tree in-order, printing out the values it encounters.\n\n    :param root: The root node of the binary search tree\n    \"\"\"\n    if not root:\n        return\n\n    inorder_traversal(root.left)\n    print(root.val)\n    inorder_traversal(root.right)"]}
{"task_id": 349, "content": ["def sum_jacobsthal_lucas(n):\n    # Function to calculate the sum of first n Jacobsthal-Lucas numbers\n    # The sum of the first n Jacobsthal-Lucas numbers is given by the (n+1)th Jacobsthal-Lucas number minus 1\n    return (nth_jacobsthal_lucas(n + 1) - 1) % MOD", "def sum_jacobsthal_lucas(n):\n    # Function to calculate the sum of first n Jacobsthal-Lucas numbers\n    \n    # The sum of the first n Jacobsthal-Lucas numbers is given by the (n+1)th Jacobsthal-Lucas number minus 1\n    return (nth_jacobsthal_lucas(n + 1) - 1) % MOD ", "def factorial(n):\n    \"\"\"\n    Calculates the factorial of an integer (n \u2265 0) and returns None for negative values.\n    The factorial function is not defined for negative integers. Instead of returning an error or exception, \n    this function returns None and prints out a message.\n    The function proves to be internally consistent with the known factorial function for non-negative integers \n    (i.e., n! = n*(n-1)*(n-2)*...*3*2*1 for n\u22650).\n    \"\"\"\n    if n < 0:\n        print(\"The factorial function isn\u2019t defined for negative integers\")\n        return None\n    elif n == 0:\n        return 1\n    else:\n        fact = 1\n        for i in range(1, n + 1):\n            fact *= i\n        return fact", "def lucas(n):\n    sequence = lucas_sequence(n)\n    print(f\"The {n}th number in the Lucas sequence is {sequence[-1]}\")\n    print(\"The sequence of Lucas numbers up to the {n}th term in reverse order is:\")\n    print(sequence[::-1])", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass"]}
{"task_id": 350, "content": ["def combine_lists(*lists):\n    '''This function takes any number of lists and combines them into a single list.'''\n    combined_list = []\n\n    for list in lists:\n        for item in list:\n            combined_list.append(item)\n\n    return combined_list", "def sort_table(table):\n    \"\"\"\n    Sorts the given table in ascending order.\n\n    Args:\n        table (list): A list of lists representing the table.\n\n    Returns:\n        list: A sorted list of lists representing the table.\n    \"\"\"\n    sorted_table = [sorted(row) for row in table]\n    return sorted_table", "def mergeKLists(lists):\n    # Create a min heap and initialize it with the first element from each linked list\n    min_heap = []\n    for i, lst in enumerate(lists):\n        if lst:\n            heappush(min_heap, (lst.val, i))\n            lst = lst.next\n    \n    # Create a dummy node to build the merged list\n    dummy = ListNode(0)\n    current = dummy\n    \n    # Process the min heap until it is empty\n    while min_heap:\n        # Remove the minimum element from the min heap\n        val, i = heappop(min_heap)\n        \n        # Add the element to the merged list\n        current.next = ListNode(val)\n        current = current.next\n        \n        # Check if there is a next node in the linked list\n        if lists[i]:\n            lists[i] = lists[i].next\n            # Add the next node to the min heap\n            if lists[i]:\n                heappush(min_heap, (lists[i].val, i))\n    \n    # Return the merged list\n    return dummy.next", "def find_permutations(arr):\n    # itertools.permutations method returns all permutations \n    # of the given list arr of length len(arr).\n    # Each permutation is a tuple so we use map function \n    # to convert these tuples to lists\n    perm = list(map(list, itertools.permutations(arr)))\n    \n    # Return the generated permutations\n    return perm", "def remove_items(items_to_remove, *lists):\n    # Check if items_to_remove is a list or a tuple\n    if not isinstance(items_to_remove, (list, tuple)):\n        return 'Error: items_to_remove should be a list or a tuple.'\n    \n    # Check if each list to operate on is actually a list\n    for lst in lists:\n        if not isinstance(lst, list):\n            return 'Error: All additional arguments should be of type list.'\n    \n    # Check if each item to remove is a string\n    for item in items_to_remove:\n        if not isinstance(item, str):\n            return 'Error: All items to remove should be strings.'\n    \n    # Create a new list to hold the result\n    result = []\n    \n    # Iterate over each list\n    for lst in lists:\n        # Filter the list to exclude items_to_remove and append it to result\n        result.append([item for item in lst if item not in items_to_remove])\n\n    # Check if any changes were made\n    if sum(len(lst) for lst in lists) == sum(len(lst) for lst in result):\n        return 'No specified items found in provided lists.'\n        \n    return result"]}
{"task_id": 351, "content": ["def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def find_mode(lst):\n    # Create a dictionary to hold list items as keys and their counts as values.\n    count_dict = {}\n    for item in lst:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n\n    # Find the maximum count.\n    max_count = max(count_dict.values())\n\n    # If the maximum count is 1, there is no mode.\n    if max_count == 1:\n        return \"This list does not have a mode.\"\n\n    # Otherwise, find and return the keys with the maximum count.\n    else:\n        modes = [k for k, v in count_dict.items() if v == max_count]\n        return modes", "def is_item_in_list(item, my_list):\n    '''This function checks if an item exists in a given list and returns a boolean value.\n    Parameters\n    ----------\n    item: The item to be checked.\n    my_list: The list in which the item is to be checked. \n    \n    Returns\n    --------\n    boolean: True if the item is present in the list, and False if it is not.\n    '''\n\n    return item in my_list", "def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]", "def apply_function(arr, f):\n    \"\"\"\n    Apply a given function to each item of an input array.\n    \n    Args:\n        arr (list): The input array.\n        f (function): The function to be applied.\n        \n    Returns:\n        list: A list with the result of applying function f to each item of arr.\n    \"\"\"\n    return list(map(f, arr))"]}
{"task_id": 352, "content": ["def add_elements(tuple1, set1):\n    # Convert the tuple to a list\n    tuple1 = list(tuple1)\n    \n    # Iterate through each element in the set\n    for element in set1:\n        # If the element is not already in the tuple's list, add it to the beginning\n        if element not in tuple1:\n            tuple1.insert(0, element)\n    \n    # Convert the list back to a tuple\n    tuple1 = tuple(tuple1)\n    \n    return tuple1", "def get_unique_elements(list1, list2):\n    # Create an empty set to store unique elements\n    unique_elements = set()\n\n    # Iterate over the elements of list1\n    for element in list1:\n        # Add each element to the set\n        unique_elements.add(element)\n\n    # Iterate over the elements of list2\n    for element in list2:\n        # Add each element to the set\n        unique_elements.add(element)\n\n    # Return the unique elements as a list while preserving the original order\n    return list(unique_elements)", "def revised_function(input_tuple):\n    # Checks if the tuple is None or empty \n    if not input_tuple:\n        return \"Error: input is NULL or empty.\"\n\n    # Initiating an empty list to hold string representations of the float values\n    str_list = []\n\n    # Iterate over the elements in the tuple\n    for element in input_tuple:\n        # Confirm that each element is a float. If not, return an error message.\n        if not isinstance(element, float):\n            return \"Error: all elements in the tuple should be floats.\"\n            \n        # Convert the float to a string and append to the list\n        str_list.append(str(element))\n    \n    # Join all elements in the list with a semicolon\n    result = \"; \".join(str_list)\n    \n    return result", "def group_by_id(elements):\n    # Create a dictionary to store the id and list of corresponding elements\n    element_groups = dict()\n\n    # Process each element in the list\n    for element in elements:\n        id = element.get_id()\n        if id in element_groups:\n            # Add the element to the list associated with its id\n            element_groups[id].append(element)\n        else:\n            # Create a new list associated with the id and add the element to it\n            element_groups[id] = [element]\n\n    # Return the dictionary containing the grouped elements\n    return element_groups", "def find_duplicates(matrix):\n    # Create a set to store tuple elements\n    elements_set = set()\n\n    # Create a list to store duplicates\n    duplicates = []\n\n    # iterate over the matrix\n    for i, row in enumerate(matrix):\n        for j, element in enumerate(row):\n            # Check if tuple is in set of elements\n            if element in elements_set:\n                # If element is in set, add it to the list of duplicates\n                duplicates.append((i, j, element))\n            else:\n                # If not, add element to set of seen elements\n                elements_set.add(element)\n\n    # return list of duplicates\n    return duplicates"]}
{"task_id": 353, "content": ["def make_palindrome(string: str) -> int:\n    \"\"\" Ascertain the smallest number of characters required to be appended at the string end to make it a palindrome, ignoring case, non-alphanumeric characters and spaces between words.\n    The algorithm:\n    - Isolate the longest palindrome postfix in the given string.\n    - Compute the length of the prefix coming before the palindromic suffix.\n    - Return the length of the prefix as the smallest number of characters necessary to make a shortest possible palindrome.\n    \"\"\"\n    cleaned = ''.join(c.lower() for c in string if c.isalnum())\n    for i in range(len(cleaned)):\n        if is_palindrome(cleaned[i:]):\n            return i", "def binary_search(arr, num):\n    \"\"\"\n    Function to use binary search to find a given number in a given array.\n\n    Arguments:\n    arr -- input array\n    num -- number to be found\n\n    Returns:\n    res -- boolean value\n    \"\"\"\n\n    # Initialize boolean variable\n    res = False\n\n    # Find the mid-point of the array\n    mid = int(len(arr)/2)\n\n    # initialize the beginning and end of the array\n    start = 0\n    end = len(arr) - 1\n\n    # If the number is in the array, set boolean as True\n    if num == arr[mid]:\n        res = True\n\n    # If the number is less than the mid-point of the array, \n    # make the end of the array the mid-point - 1\n    elif num < arr[mid]:\n        end = mid - 1\n\n    # Else, make the start of the array the mid-point + 1\n    else:\n        start = mid + 1\n\n    # If the start and the end of the array have not met each other, \n    # make a recursive call to the binary search function\n    if start <= end:\n        return binary_search(arr[start:end+1], num)\n\n    return res", "def make_palindrome(string: str) -> int:\n    \"\"\" Find the minimum number of characters that need to be added at the end of the supplied string to make it a palindrome, ignoring case, non-alphanumeric characters, and spaces between words.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Compute the length of the string prefix that comes before the palindromic suffix.\n    - Return the length of the prefix as the minimum number of characters needed to create the shortest possible palindrome.\n    \"\"\"\n    filtered_string = ''.join(char.lower() for char in string if char.isalnum())\n    \n    for i in range(len(filtered_string)):\n        if is_palindrome(filtered_string[i:]):\n            return i", "def make_palindrome(string: str) -> int:\n    \"\"\"\n    Find the minimum number of characters that need to be added at the end of the supplied string to make it a palindrome, \n    ignoring case, non-alphanumeric characters, and spaces between words.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome,\n    - Compute the length of the string prefix that comes before the palindrome suffix.\n    - Return the length of the prefix as the minimum number of characters needed to create the shortest possible palindrome.\n    \"\"\"\n    filtered_string = ''.join(char.lower() for char in string if char.isalnum())\n\n    for i in range(len(filtered_string)):\n        if is_palindrome(filtered_string[i:]):\n            return i", "def find_pallindrome(characters):\n    \"\"\"\n    Generates a palindrome string with a set of given characters.\n    \n    Args:\n        characters (list): The set of characters from which to generate a palindrome string\n    \n    Returns:\n        string (str): A palindromic string generated from the given characters\n    \"\"\"\n    palindrome = ''\n    while len(characters) > 0:\n        # Append a character to the palindrome\n        char = characters.pop(0)\n        palindrome += char\n        \n        # Append the same character to the end of the string\n        palindrome += char\n    \n    return palindrome"]}
{"task_id": 354, "content": ["def add_digits(number):\n    \"\"\"This function adds all the digits of a given number \n    and returns the result.\n    \n    Args:\n        number (int): The number to process.\n    \n    Returns:\n        int: The result of adding all the digits of the given number.\n    \"\"\"\n    if number < 10:\n        return number\n    total = number % 10 + add_digits(number // 10)\n    return total", "def num_digits(number):\n    \"\"\"This function will take a number and calculate the number of digits in the number.\"\"\"\n    # Count the number of digits\n    num_digits = 0\n    while number != 0:\n        num_digits += 1\n        number //= 10\n    \n    # Return the number of digits\n    return num_digits", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def count_word(text, word):\n    '''This function will count the number of times a given word appears in a text.'''\n    return text.count(word)", "def is_multiple(n):\n    \"\"\"\n    Function to check if a given number is a multiple of 3 or 5.\n    \n    Parameters: \n    n (int): The given number to check.\n    \n    Returns: \n    bool: True if number is a multiple of 3 or 5, False otherwise.\n    \"\"\"\n    return n % 3 == 0 or n % 5 == 0"]}
{"task_id": 355, "content": ["def multiply_numbers(lst):\n    '''\n        Function to calculate the product of all elements in a nested list of integers.\n        Parameters:\n        lst (list): Nested list of integers.\n\n        Returns:\n        product (integer or float): The product of all elements in the nested list.\n    '''\n    # Ensure the input type is correct:\n    if type(lst) is not list:\n        raise TypeError(\"Input should be a list of integers\")\n\n    # start calculation:\n    product = 1\n    for i in lst:\n        if type(i) is list:\n            product *= multiply_numbers(i)\n        else:\n            if type(i) is int:\n                product *= i\n            else:\n                raise TypeError(\"All elements in nested lists should be integers\")\n\n    return product", "def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers.", "def count_unique_numbers(numbers):\n    \"\"\"\n    Count the number of unique integers in the given list.\n\n    Args:\n    numbers: A list of integers.\n\n    Returns:\n    An integer representing the count of unique numbers in the list.\n    \"\"\"\n    try:\n        unique_numbers = set(numbers)  # Convert the list to a set to get unique elements\n        return len(unique_numbers)  # Return the count of unique numbers\n    except TypeError as e:\n        raise TypeError(\"Input must be a list of integers\") from e\n    except Exception as e:\n        raise Exception(\"An error occurred while counting unique numbers\") from e", "def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list", "def filter_odd(lst):\n    \"\"\"\n    Function to filter out the odd elements in a given list and return the even ones.\n\n    :param lst: A list of integers\n    :returns: A new list containing only even integers\n    \"\"\"\n    return [x for x in lst if x % 2 == 0]"]}
{"task_id": 356, "content": ["def inorder_traversal(root):\n    \"\"\"Write a function to traverse a binary search tree in-order, printing out the values it encounters.\n\n    :param root: The root node of the binary search tree\n    \"\"\"\n    if not root:\n        return\n\n    inorder_traversal(root.left)\n    print(root.val)\n    inorder_traversal(root.right)", "def is_balanced_tree(root):\n    \"\"\"\n    Return a boolean indicating if a binary tree is balanced\n    \"\"\"\n    # Initialize a boolean\n    is_balanced = True\n    \n    # Check if the tree is balanced\n    if root is None:\n        is_balanced = True\n    elif abs(get_height(root.left) - get_height(root.right)) > 1:\n        is_balanced = False\n    else:\n        is_balanced = is_balanced_tree(root.left) and is_balanced_tree(root.right)\n        \n    # Return the boolean\n    return is_balanced", "def first_common_ancestor(node1, node2):\n    \"\"\"\n    This function finds the first common ancestor of two given nodes in a binary tree.\n    \n    Args:\n        node1 (Node): a node in the binary tree\n        node2 (Node): a second node in the binary tree\n        \n    Returns: \n        Node: the first common ancestor node of two input nodes\n    \"\"\"\n    if node1 is None or node2 is None:\n        return None\n    \n    find_node1 = find_node(node1)\n    find_node2 = find_node(node2)\n    \n    if find_node1 is None or find_node2 is None:\n        return None\n        \n    # Run an iterative DFS on the binary tree to find the first common ancestor.\n    stack1 = [find_node1]\n    stack2 = [find_node2]\n    visited = set()\n    \n    while stack1 and stack2:\n        node1 = stack1.pop()\n        node2 = stack2.pop()\n        if node1 == node2:\n            return node1\n        \n        if node1 in visited:\n            return node1\n        visited.add(node1)\n        if node1.parent:\n            stack1.append(node1.parent)\n            \n        if node2 in visited:\n            return node2\n        visited.add(node2)\n        if node2.parent:\n            stack2.append(node2.parent)\n            \n    return None", "def find_max_in_binary_tree(tree):\n    '''This function finds the largest element in a binary tree.'''\n    if tree['right'] is None and tree['left'] is None:\n        return tree['value']          \n    max_left = find_max_in_binary_tree(tree['left']) if tree['left'] else float('-inf')\n    max_right = find_max_in_binary_tree(tree['right']) if tree['right'] else float('-inf')\n    return max(max_left, max_right, tree['value'])", "def checkBinaryPrime(bin_num):\n    # Check if input is valid binary\n    if not isValidBinary(bin_num):\n        return 'Not a valid binary number.'\n    # Convert binary to decimal\n    decimal = int(bin_num, 2) \n    # Check if converted number is prime\n    if isPrime(decimal):\n        return f'The decimal equivalent of {bin_num} is {decimal}, which is a prime number.'\n    else:\n        return f'The decimal equivalent of {bin_num} is {decimal}, which is not a prime number.'"]}
{"task_id": 357, "content": ["def repeat_hello_world(repeat):\n    '''Function that prints \"Hello world\" a given number of times.'''\n    for _ in range(repeat):\n        print(\"Hello world\")", "def repeat(function, times):\n    for calls in range(times):\n        function()", "def create_vector(n, m):\n    # Calculate the number of times each element should appear in the vector\n    num_repeats = int(np.ceil(n / m))\n\n    # Create an initial array with the values to repeat\n    initial_array = np.arange(num_repeats)\n\n    # Repeat the initial array m times, up to n elements\n    result = np.tile(initial_array, m)[:n]\n\n    # Sort the resulting vector in ascending order\n    result.sort()\n\n    return result", "def repeat_string(string, repeat):\n    \"\"\"Return the supplied string repeated as many times as specified.\"\"\"\n    \n    repeated_string = string * repeat\n    \n    return repeated_string", "def count_word(text, word):\n    '''This function will count the number of times a given word appears in a text.'''\n    return text.count(word)"]}
{"task_id": 358, "content": ["def find_surface_area(length, breadth, height):\n    '''\n    This function calculates the surface area of a cuboid.\n    Input: length, breadth, height - these are the three dimensions of the cuboid\n    Output: total surface area of the cuboid \n    '''\n    # Formula of Surface Area of Cuboid = 2(lb + bh + hl)\n    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area", "def find_surface_area(length, breadth, height):\n    '''\n    This function calculates the surface area of a cuboid.\n    Input: length, breadth, height - these are the three dimensions of the cuboid\n    Output: total surface area of the cuboid \n    '''\n    # Formula of Surface Area of Cuboid = 2(lb + bh + hl)\n    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area", "def main():\n    length = 4\n    width = 5\n    height = 2\n\n    try:\n        volume = calculate_volume(length, width, height)\n        print(f\"The volume of the cuboid is {volume}.\")\n\n        surface_area = calculate_surface_area(length, width, height)\n        print(f\"The surface area of the cuboid is {surface_area}.\")\n    \n    except ValueError as e:\n        print(e)", "def calculate_cuboid_dimensions(cube_side):\n    cube_surface_area = 6 * cube_side**2      # calculate surface area of cube\n    w = math.sqrt(cube_surface_area / 7.5)    # calculate w using derived equation\n    l = 2 * w                                 # calculate l\n    h = w / 2                                 # calculate h\n    return l, w, h                            # return dimensions of the cuboid", "def calculate_cuboid_dimensions(cube_side):\n    cube_surface_area = 6 * cube_side**2      # calculate surface area of cube\n    w = math.sqrt(cube_surface_area / 7.5)    # calculate w using derived equation\n    l = 2 * w                                 # calculate l\n    h = w / 2                                 # calculate h\n    return l, w, h                            # return dimensions of the cuboid"]}
{"task_id": 359, "content": ["def revised_function(input_tuple):\n    # Checks if the tuple is None or empty \n    if not input_tuple:\n        return \"Error: input is NULL or empty.\"\n\n    # Initiating an empty list to hold string representations of the float values\n    str_list = []\n\n    # Iterate over the elements in the tuple\n    for element in input_tuple:\n        # Confirm that each element is a float. If not, return an error message.\n        if not isinstance(element, float):\n            return \"Error: all elements in the tuple should be floats.\"\n            \n        # Convert the float to a string and append to the list\n        str_list.append(str(element))\n    \n    # Join all elements in the list with a semicolon\n    result = \"; \".join(str_list)\n    \n    return result", "def frequencySort(nums):\n    # collections.Counter(nums) gives the frequency of each element in the nums array.\n    # items() function returns a view object that displays a list of a dictionary's(an iterable) tuple pair (key, value).\n    c = Counter(nums).items()\n    # Then we will sort the results by the tuple (-count, num). Negative count ensures that high frequency elements come first in the sorted list.\n    # This satisfies the requirement to sort in increasing frequency. \n    # Because we use num for sort as well, elements with the same frequency are sorted in descending order.\n    # This satisfies the requirement to sort in decreasing order on the basis of value of the numbers in case of same frequency.\n    # idx is used to sort elements in increasing order of their index in case elements are same and have same frequency.\n    # sort function of python is stable. i.e, it maintains the relative order of items with equal sort keys\n    nums.sort(key = lambda x: (nums.count(x), -x, [i for i, n in enumerate(nums) if n == x][0]))\n    # return the sorted array\n    return nums", "def sort_dict_by_value(in_dict):\n    \"\"\" Function to sort a dictionary by its values\n    \"\"\"\n    return {k: v for k, v in sorted(in_dict.items(), key=lambda item: item[1])}", "def filterEven(data):\n    result = ()\n\n    # Traverse every element in the data\n    for element in data:\n\n        # If the element is a complex number, skip it\n        if isinstance(element, complex):\n            continue\n\n        # If element is a list or dictionary, convert it to a tuple and recursively call this function\n        if isinstance(element, (list, dict)):\n            result += (filterEven(tuple(element)),)\n\n        # If the element is a tuple, recursively call this function\n        elif isinstance(element, tuple):\n            result += (filterEven(element),)\n\n        # If the element is a string, check if it represents an even number\n        elif isinstance(element, str):\n            # Check if the string can be converted to an integer\n            if element.isdigit():\n                num = int(element)\n                # If the number is even, append it to the results\n                if num % 2 == 0:\n                    result += (num,)\n        \n        # if the element is a floating number, just discard it.\n        elif isinstance(element, float):\n            continue\n\n        # If the element is an integer and it's even, append it to the results\n        elif isinstance(element, int):\n            if element % 2 == 0:\n                result += (element,)\n\n    return result", "def filterEven(data):\n    result = ()\n\n    # Traverse every element in the data\n    for element in data:\n\n        # If the element is a complex number, skip it\n        if isinstance(element, complex):\n            continue\n\n        # If element is a list or dictionary, convert it to a tuple and recursively call this function\n        if isinstance(element, (list, dict)):\n            result += (filterEven(tuple(element)),)\n\n        # If the element is a tuple, recursively call this function\n        elif isinstance(element, tuple):\n            result += (filterEven(element),)\n\n        # If the element is a string, check if it represents an even number\n        elif isinstance(element, str):\n            # Check if the string can be converted to an integer\n            if element.isdigit():\n                num = int(element)\n                # If the number is even, append it to the results\n                if num % 2 == 0:\n                    result += (num,)\n\n        # If the element is a floating number, just discard it.\n        elif isinstance(element, float):\n            continue\n\n        # If the element is an integer and it's even, append it to the results\n        elif isinstance(element, int):\n            if element % 2 == 0:\n                result += (element,)\n\n    return result"]}
{"task_id": 360, "content": ["def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def find_kth_smallest(arr, k):\n    \"\"\"\n    This function finds the kth smallest element in an array.\n    :param arr: array of integers\n    :param k: integer\n    :return: kth smallest element\n    \"\"\"\n    sorted_arr = sorted(arr)\n    return sorted_arr[k-1]", "def find_smallest_in_arrays(arr1, arr2):\n    \"\"\"\n    Find and return the smallest elements in both arrays in O(nlog(n))\n\n    Parameters\n    ----------\n    arr1 : list\n        First array of integers\n    arr2 : list\n        Second array of integers\n\n    Returns\n    -------\n    int\n        The smallest element common to both arrays\n    \"\"\"\n    # Merge both the arrays\n    merged_arr = [*arr1, *arr2]\n    # Sort the merged array in O(nlog(n))\n    merged_arr.sort()\n\n    # Initialize first_min to the first element of sorted merged array\n    first_min = merged_arr[0]\n    # Initialize second_min to the second element of sorted merged array\n    second_min = merged_arr[1]\n\n    # Check if the first min element is in arr1 and the second min element is in arr2.\n    # If yes, return the first min element.\n    if first_min in arr1 and second_min in arr2:\n        return first_min\n    # Check if the first min element is in arr2 and the second min element is in arr1.\n    # If yes, return the first min element.\n    elif first_min in arr2 and second_min in arr1:\n        return first_min\n    # Else return the second min element\n    else:\n        return second_min", "def find_missing_number(arr):\n    # Create a set to store all numbers from 1 to the last element in the array\n    # For an array of length n, the last element has a value of n\n    all_nums = set(range(1, arr[-1] + 1))\n\n    # Create a set to store all numbers present in the array\n    arr_nums = set(arr)\n\n    # Use set subtraction to find the missing number\n    missing_number = list(all_nums - arr_nums)[0]\n\n    return missing_number", "def find_kth_largest(arr, k):\n    \"\"\"\n    Function to find the kth largest element in an array\n    \"\"\"\n    \n    # make a copy of the array\n    arr_copy = arr[:]\n    \n    # get the length of the array\n    length = len(arr_copy)\n    \n    # if k is greater than or equal to the length of the array, return the maximum element\n    if k >= length:\n        return max(arr_copy)\n        \n    # sort the array in descending order\n    arr_copy.sort(reverse=True)\n    \n    # get the kth element from the sorted array\n    kth_largest = arr_copy[k-1]\n    \n    return kth_largest"]}
{"task_id": 361, "content": ["def sort(list):\n    \"\"\"\n    This function sorts a given list in ascending order.\n\n    Parameters:\n    list (List[int, float, str]): A list of numerical or string values to be sorted. This list should contain elements of the same datatype for the function to work correctly. \n    \"\"\"\n    list.sort()", "def sort_strings_alphabetically(strings):\n    # The sort() method sorts the elements of a given list in a specific order - Ascending or Descending.\n    strings.sort()\n    return strings", "def sort_by_word_length(word_list):\n    \"\"\"\n    Function to sort a given list of strings \n    based on the length of the words in ascending order.\n    @param word_list: list\n    @return: list\n    \"\"\"\n    return sorted(word_list, key=lambda x: len(x))", "def uncommon_elements(sequence):\n    # Use collections.Counter to count elements in sequence\n    # and get a dictionary where keys are the elements and values are the frequencies.\n    counter = collections.Counter(sequence)\n    \n    # Create a list 'elements' to store elements which frequency is greater than half of their own value.\n    elements = []\n    \n    for k, v in counter.items():\n        if v > k / 2:\n            elements.append((v, k))\n    \n    # Use a priority queue to organize the elements based on their frequencies and values.\n    # The priority is determined by the frequency first and then the integer.\n    hq = [(-v, k) for v, k in elements]\n    \n    # Organize the heap.\n    heapq.heapify(hq)\n    \n    # Dequeue the heap and append the elements to the result list in descending order of their frequencies\n    # and ascending order for elements with the same frequency.\n    result = [heapq.heappop(hq)[1] for _ in range(len(hq))]\n    \n    return result", "def filter_and_sort(elements, symbol):\n    # Use a list comprehension to filter the list for elements containing the symbol.\n    filtered = [element for element in elements if symbol in element]\n    # Sort the filtered list in ascending order.\n    filtered.sort()\n    return filtered"]}
{"task_id": 362, "content": ["def main():\n    length = 4\n    width = 5\n    height = 2\n\n    try:\n        volume = calculate_volume(length, width, height)\n        print(f\"The volume of the cuboid is {volume}.\")\n\n        surface_area = calculate_surface_area(length, width, height)\n        print(f\"The surface area of the cuboid is {surface_area}.\")\n    \n    except ValueError as e:\n        print(e)", "def find_surface_area(length, breadth, height):\n    '''\n    This function calculates the surface area of a cuboid.\n    Input: length, breadth, height - these are the three dimensions of the cuboid\n    Output: total surface area of the cuboid \n    '''\n    # Formula of Surface Area of Cuboid = 2(lb + bh + hl)\n    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area", "def find_surface_area(length, breadth, height):\n    '''\n    This function calculates the surface area of a cuboid.\n    Input: length, breadth, height - these are the three dimensions of the cuboid\n    Output: total surface area of the cuboid \n    '''\n    # Formula of Surface Area of Cuboid = 2(lb + bh + hl)\n    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area", "def recip_vol(volume):\n    \"\"\"\n    Calculates the reciprocal of the volume of a geometric shape.\n\n    Args:\n    volume: Positive real number representing the volume of a geometric shape.\n\n    Returns:\n    The reciprocal of the volume.\n    \"\"\"\n    reciprocal = 1 / volume\n    return reciprocal", "def calculate_cube_volume(length):\n    \"\"\"Calculate the volume of a cube.\n    \n    Args:\n        length (float): The length of a side of the cube.\n        \n    Returns:\n        float: The volume of the cube.\n    \"\"\"\n    volume = length ** 3\n    return volume"]}
{"task_id": 363, "content": ["def print_permutations(s):\n    \"\"\"Print all permutations of the given string.\n\n    Args:\n    s: A string for which permutations need to be printed.\n\n    Returns:\n    None\n    \"\"\"\n    _print_permutations_helper(\"\", s)", "def distinct_permutations(string):\n    # Get all permutations of the string\n    all_permutations = permutations(string)\n    \n    # Convert the permutations to a set to remove duplicates\n    distinct_permutations = set(all_permutations)\n    \n    # Return the distinct permutations as a list\n    return list(distinct_permutations)", "def find_anagrams(s):\n # Find all possible permutations of the string\n perms = permutations(s)\n \n # Convert each permutation to a string and add it to a set to remove duplicates\n anagrams = set(''.join(p) for p in perms)\n \n return anagrams", "def find_anagrams(s):\n    # Find all possible permutations of the string\n    perms = permutations(s)\n    \n    # Convert each permutation to a string and add it to a set to remove duplicates\n    anagrams = set(''.join(p) for p in perms)\n    \n    return anagrams", "def permutations(str):\n    \"\"\"\n    This function returns a list of all possible permutations of a given string\n    \"\"\"\n\n    # Base case\n    if not str:\n        return ['']\n    \n    # Create a result list to store the permutations\n    result = []\n    \n    # Iterate through all characters \n    for i in range(len(str)):\n        # Create a list of all characters except the current one\n        rest = str[:i] + str[i+1:]\n        # Generate all permutations of the remaining characters\n        sub_permutes = permutations(rest)\n        \n        # Put the current character in each permutation and add it to the result \n        # list\n        for perm in sub_permutes:\n            result.append(str[i] + perm)\n    return result"]}
{"task_id": 364, "content": ["def is_multiple(n):\n    \"\"\"\n    Function to check if a given number is a multiple of 3 or 5.\n    \n    Parameters: \n    n (int): The given number to check.\n    \n    Returns: \n    bool: True if number is a multiple of 3 or 5, False otherwise.\n    \"\"\"\n    return n % 3 == 0 or n % 5 == 0", "def round_to_nearest_multiple(num, decimal_place=0):\n    # Step 1: Multiply the number by 10^decimal_place to shift the decimal place\n    num *= 10**decimal_place\n    \n    # Step 2: Round the shifted number to the nearest whole number\n    rounded_num = round(num)\n    \n    # Step 3: Divide the rounded number by 10^decimal_place to shift the decimal place back\n    rounded_num /= 10**decimal_place\n    \n    # Step 4: Round the shifted number to the nearest multiple of 10\n    rounded_multiple = round(rounded_num / 10) * 10\n    \n    return rounded_multiple", "def check_integer(number):\n    if number % 2 == 0:\n        if number % 3 == 0:\n            print(\"The given integer is even and a multiple of 3.\")\n        else:\n            print(\"The given integer is even and not a multiple of 3.\")\n    else:\n        if number % 3 == 0:\n            print(\"The given integer is odd and a multiple of 3.\")\n        else:\n            print(\"The given integer is odd and not a multiple of 3.\")", "def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True", "def round_number(number):\n    # round number to nearest integer\n    rounded_number = round(number)\n\n    # print the rounded number\n    print(rounded_number)"]}
{"task_id": 365, "content": ["def remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"Remove duplicates while maintaining order.\n    Given a list of integers, remove any number that occurs more than once,\n    while keeping the order of the remaining numbers the same as the original list.\n    Determine the number of times each number occurs, and remove the numbers that occur more than once.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count_map = {}\n    result = []\n    for num in numbers:\n        if num not in count_map:\n            count_map[num] = 1\n            result.append(num)\n        else:\n            count_map[num] += 1\n            if count_map[num] > 1 and num in result:\n                result.remove(num)\n    return result", "def remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Facilitate the de-duplication of a sequence of integers, eliminating any references that occur more than once.\n    Retains the exact sequence of remaining integers mirroring the original provided sequence.\n    Time complexity: O(n)\n    Space complexity: O(1)\n    \"\"\"\n    write = 1\n    for read in range(1, len(numbers)):\n        if numbers[read] != numbers[read-1]:\n            numbers[write] = numbers[read]\n            write += 1\n    return numbers[:write]   # cutting the array to length 'write'", "def checkSubstring(str_1, str_2, str_3):\n    occurs_str_1 = str_2.count(str_1)\n    occurs_str_3 = str_2.count(str_3)\n    \n    if occurs_str_1 == 0 or occurs_str_3 == 0:\n        return False\n    elif occurs_str_1 > 1 and occurs_str_3 > 1:\n        return \"Both substrings occur more than once.\"\n    elif occurs_str_1 > 1:\n        return \"str_1 occurs more than once.\"\n    elif occurs_str_3 > 1:\n        return \"str_3 occurs more than once.\"\n    else:\n        return True", "def count_duplicates(A):\n    # Create an empty dictionary\n    count = {}\n    # Iterate over the array\n    for elem in A:\n        # Check if the element is already in the dictionary\n        if elem in count:\n            # Increment the count of duplicates\n            count[elem] += 1\n        # If the element is not in the dictionary, add it with the count=0\n        else:\n            count[elem] = 0\n    # Calculate the number of elements that occur more than once\n    num_duplicates = 0\n    for elem, count in count.items():\n        if count > 0:\n            num_duplicates += 1\n    # Return the number of duplicates\n    return num_duplicates", "def count_freq(lst):\n    # Count the occurences of each element in the list\n    freq = dict(Counter(lst))\n    \n    # Remove elements that occur only once\n    freq = {k: v for k, v in freq.items() if v > 1}\n\n    # Calculate the product of frequencies\n    prod = math.prod(freq.values()) if len(freq.values()) > 0 else \"No element found with frequency more than 1\"\n\n    return freq, prod"]}
{"task_id": 366, "content": ["def match_text(text, search_string):\n    \"\"\"Returns all occurrences of substring in the given string with case and pattern insensitivity.\n\n    Args:\n    text (str): A string.\n    search_string (str): The substring for which to search.\n\n    Returns:\n    A list of all occurrences in the given string.\n    \"\"\"\n    matches = []\n    # Construct a case and pattern insensitive regex expression\n    search_string = re.compile(search_string, re.IGNORECASE)\n    # Search the string and add the matches to a list\n    for match in search_string.finditer(text):\n        matches.append(match.group(0))\n\n    return matches", "def find_index_of_first_occurrence(string, character):\n    '''\n    This function will find the index of the first occurrence of a given character in a string.\n\n    Args:\n        string (str): the string to be searched\n        character (str): the character to be searched for\n\n    Returns:\n        int: the index of the first occurrence of the character\n    '''\n    return string.find(character)", "def count_occurrences(string):\n    # Initialize an empty dictionary to store the occurrences\n    occurrences = {}\n    \n    # Iterate through each character in the string\n    for char in string:\n        # If the character is already a key in the dictionary, increment its value by 1\n        if char in occurrences:\n            occurrences[char] += 1\n        # If the character is not a key in the dictionary, add it with a value of 1\n        else:\n            occurrences[char] = 1\n    \n    return occurrences", "def highest_occurring_character(string):\n    \"\"\"Find the highest occurring character in a string.\"\"\"\n\n    # Initialise a dictionary to store the number of occurrences of each character\n    char_occurrences = {}\n\n    # Store the number of occurrences of each character\n    for char in string:\n        char_occurrences[char] = char_occurrences.get(char, 0) + 1\n\n    # Find the maximum occurrence of all the characters\n    max_occurrence = 0\n    highest_occurring_char = None\n\n    # Iterate over the occurrence dictionary to find the highest occurrence\n    for char, occurrence in char_occurrences.items():\n        if occurrence > max_occurrence:\n            max_occurrence = occurrence\n            highest_occurring_char = char\n\n    return highest_occurring_char", "def remove_item(my_list, item):\n  \"\"\"Remove all occurrences of a given item from a list\"\"\"\n  # Loop through the items in the list\n  for i in my_list:\n    # Check if current item is the item to remove\n    if i == item:\n      # Remove the item from the list\n      my_list.remove(i)\n  return my_list"]}
{"task_id": 367, "content": ["def transpose_list(lst):\n    \"\"\"\n    This function takes a list as input and transposes all of its elements by\n    one position to the left, maintaining the order of neighboring elements.\n    The last element of the list becomes the first one.\n    \"\"\"\n    if not lst:  # if the list is empty, return it as is\n        return lst\n    last_element = lst.pop()  # remove the last element\n    lst.insert(0, last_element)  # add the removed last element at the first position\n    return lst", "def delete_element(my_list, pos):\n    \"\"\"Function to delete an element from a given list at a given position.\"\"\"\n    del my_list[pos]\n    return my_list", "def binarySearch(array, target):\n    '''This function will implement the binary search algorithm.\n\n    Args:\n        array (list): An array of elements.\n        target (int): The element to search for.\n\n    Returns:\n        int: The index of the target in the given array.\n    '''\n    # Initialize the first and last index variables\n    first = 0\n    last = len(array) - 1\n\n    while first <= last:\n        mid = (first + last) // 2\n\n        # Check if the target is in the middle\n        if array[mid] == target:\n            return mid\n\n        # If the target is greater than the element in the middle,\n        # search for it in the second half of the array\n        elif array[mid] < target:\n            first = mid + 1\n\n        # Else, search for it in the first half of the array\n        else:\n            last = mid - 1\n\n    # Otherwise the target is not present in the list\n    return -1", "def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def rotate_array_clockwise(arr):\n    # Store the first element of the array in a temp variable\n    temp = arr[0]\n    \n    # Shift all elements of the array to their left by one position\n    for i in range(len(arr)-1):\n        arr[i] = arr[i+1]\n    \n    # Replace the last element of the array with the temp variable\n    arr[len(arr)-1] = temp\n    return arr"]}
{"task_id": 368, "content": ["def find_surface_area(length, breadth, height):\n    '''\n    This function calculates the surface area of a cuboid.\n    Input: length, breadth, height - these are the three dimensions of the cuboid\n    Output: total surface area of the cuboid \n    '''\n    # Formula of Surface Area of Cuboid = 2(lb + bh + hl)\n    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area", "def find_surface_area(length, breadth, height):\n    '''\n    This function calculates the surface area of a cuboid.\n    Input: length, breadth, height - these are the three dimensions of the cuboid\n    Output: total surface area of the cuboid \n    '''\n    # Formula of Surface Area of Cuboid = 2(lb + bh + hl)\n    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area", "def main():\n    length = 4\n    width = 5\n    height = 2\n\n    try:\n        volume = calculate_volume(length, width, height)\n        print(f\"The volume of the cuboid is {volume}.\")\n\n        surface_area = calculate_surface_area(length, width, height)\n        print(f\"The surface area of the cuboid is {surface_area}.\")\n    \n    except ValueError as e:\n        print(e)", "def frustum_surface_area(r1, r2, h):\n    \"\"\"\n    This function calculates the surface area of a frustum of a cone.\n\n    Arguments:\n    r1 : float : radius of the smaller base of the frustum\n    r2 : float : radius of the larger base of the frustum\n    h : float : height of the frustum\n\n    Returns:\n    float : surface area of the frustum\n    \"\"\"\n\n    # Checking if the input parameters are valid\n    if r1 < 0 or r2 < 0 or h < 0:\n        raise ValueError('All parameters must be non-negative.')\n\n    area = math.pi * (r1 + r2) * math.sqrt((r2 - r1)**2 + h**2) + math.pi * (r1**2 + r2**2)\n    return area", "def polygon_area(coordinates):\n    \"\"\"\n    Given pairs of x,y coordinates as inputs, calculate the surface area of the resulting polygon.\n    This function computes areas of complex, non-rectangular polygons.\n\n    In order to calculate, it uses Gauss's Area formula (also called Shoelace Theorem):\n    https://en.wikipedia.org/wiki/Shoelace_formula\n\n    This formula calculates the signed area. If the coordinates are covered in a counterclockwise direction,\n    the signed area is positive, if clockwise, the signed area is negative. The abs function cares about the absolute value.\n    \"\"\"\n\n    area = 0.0\n    for i in range(len(coordinates)):\n        x1, y1 = coordinates[i]\n        x2, y2 = coordinates[(i+1) % len(coordinates)]  # cyclically next vertex\n        area += x1*y2 - x2*y1\n    return abs(area)/2"]}
{"task_id": 369, "content": ["def flatten_array(arr):\n    \"\"\"\n    Function to flatten a two-dimensional array into a one-dimensional array\n    \n    Parameters:\n    arr (list): a two-dimensional list\n    \n    Return:\n    list: a flattened one-dimensional list\n    \"\"\"\n    result = []\n    for sublist in arr:\n        for item in sublist:\n            result.append(item)\n    return result", "def flatten(arr):\n    \"\"\"\n    Function to flatten a given two-dimensional array \n    \"\"\"\n    return [item for subList in arr for item in subList]", "def print_matrix(matrix):\n    \"\"\" Print a visual representation of a two-dimensional array.\n\n    Args:\n        matrix (list): A two-dimensional list of integers.\n    \"\"\"\n    for row in matrix:\n        for item in row:\n            print(f'{item}', end=' ')\n        print('')", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass", "def generate_payload():\n    \"\"\"Generate a benign payload that writes a file to the disk with a unique name.\"\"\"\n    filename = generate_unique_filename()\n    payload = f\"\"\"\nimport os\n\n# Payload to write a file to the disk with a unique name\ndef write_file(filename):\n    with open(filename, 'w') as f:\n        f.write('This is a test file.')\n\n# Call the payload function\nwrite_file('{filename}')\n\"\"\"\n    return payload"]}
{"task_id": 370, "content": ["def sort_table(table, col=1, order='asc'):\n    '''\n    Sorts the given table by the specified column and applies a randomized row shuffling algorithm after sorting.\n    \n    Args:\n    table: A list of lists containing the table data.\n    col: The index of the column to sort the table by.\n    order: The order in which to sort the table. Can be 'asc' for ascending or 'desc' for descending.\n    \n    Returns:\n    A new list of lists containing the sorted and shuffled table data.\n    '''\n    \n    # Sort the table by the specified column\n    table.sort(key=lambda x: x[col], reverse=(order=='desc'))\n    \n    # Shuffle the rows of the table randomly\n    random.shuffle(table)\n    \n    return table", "def process_nested_list(nested_list):\n    # Remove duplicates by converting each inner list into a set and back into a list\n    # Sort the inner lists with sorted()\n    return [sorted(list(set(inner_list))) for inner_list in nested_list]", "def process_nested_list(nested_list):\n    # Remove duplicates by converting each inner list into a set and back into a list\n    #  Sort the inner lists with sorted()\n    return [sorted(list(set(inner_list))) for inner_list in nested_list]", "def sort(list):\n    \"\"\"\n    This function sorts a given list in ascending order.\n\n    Parameters:\n    list (List[int, float, str]): A list of numerical or string values to be sorted. This list should contain elements of the same datatype for the function to work correctly. \n    \"\"\"\n    list.sort()", "def sort_dicts_by_key(dicts, key, descending=False):\n    \"\"\"\n    Sort a list of dictionaries based on a specific key.\n    Args:\n        dicts (list): A list of dictionaries with the same keys.\n        key (str): The key to sort by.\n        descending (bool): If True, sort in descending order.\n    Returns:\n        A new list of dictionaries sorted by the values of the specified key.\n    \"\"\"\n    return sorted(dicts, key=lambda x: x[key], reverse=descending)"]}
{"task_id": 371, "content": ["def rolling_max(arr):\n    \"\"\"\n    This function takes an array of positive integers and\n    returns a new array where each element from index 0 to \n    n is the maximum element from the original array from\n    index 0 to n.\n\n    If there's a negative number in the array, the function returns an empty list.\n    \n    Args:\n        arr (List[int]): a list of integers.\n\n    Returns:\n        List[int]: a list of maximum numbers. \n        If input list contains negative number, an empty list is returned\n    \"\"\"\n    \n    max_num = float('-inf')\n    result = []\n    \n    for number in arr:\n        if number < 0:\n            return []\n        max_num = max(number, max_num)\n        result.append(max_num)\n        \n    return result", "def binary_search(arr, num):\n    \"\"\"\n    Function to use binary search to find a given number in a given array.\n\n    Arguments:\n    arr -- input array\n    num -- number to be found\n\n    Returns:\n    res -- boolean value\n    \"\"\"\n\n    # Initialize boolean variable\n    res = False\n\n    # Find the mid-point of the array\n    mid = int(len(arr)/2)\n\n    # initialize the beginning and end of the array\n    start = 0\n    end = len(arr) - 1\n\n    # If the number is in the array, set boolean as True\n    if num == arr[mid]:\n        res = True\n\n    # If the number is less than the mid-point of the array, \n    # make the end of the array the mid-point - 1\n    elif num < arr[mid]:\n        end = mid - 1\n\n    # Else, make the start of the array the mid-point + 1\n    else:\n        start = mid + 1\n\n    # If the start and the end of the array have not met each other, \n    # make a recursive call to the binary search function\n    if start <= end:\n        return binary_search(arr[start:end+1], num)\n\n    return res", "def find_anagrams(word, dictionary):\n    \"\"\"\n    This function takes in a word and a dictionary and finds\n    all anagrams of the word in the dictionary.\n\n    Args:\n        word (str): the word to find anagrams for.\n        dictionary (list): a list of words in the dictionary.\n\n    Returns:\n        list: a list of all anagrams of the word in the dictionary.\n    \"\"\"\n    # Create a sorted version of the given word.\n    sorted_word = ''.join(sorted(word))\n    \n    # Create an empty list to store the anagrams.\n    anagrams = []\n    \n    # Iterate over all the words in the dictionary.\n    for i in range(len(dictionary)):\n        # Create a sorted version of the current word.\n        sorted_dict_word = ''.join(sorted(dictionary[i]))\n        \n        # Check if the sorted version of the word is equal to the sorted version of the dictionary word.\n        if sorted_word == sorted_dict_word:\n            # Append the current word to the list of anagrams.\n            anagrams.append(dictionary[i])\n    \n    # Return the list of anagrams.\n    return anagrams", "def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers.", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]"]}
{"task_id": 372, "content": ["def add_digits(number):\n    \"\"\"This function adds all the digits of a given number \n    and returns the result.\n    \n    Args:\n        number (int): The number to process.\n    \n    Returns:\n        int: The result of adding all the digits of the given number.\n    \"\"\"\n    if number < 10:\n        return number\n    total = number % 10 + add_digits(number // 10)\n    return total", "def check_integer(number):\n    if number % 2 == 0:\n        if number % 3 == 0:\n            print(\"The given integer is even and a multiple of 3.\")\n        else:\n            print(\"The given integer is even and not a multiple of 3.\")\n    else:\n        if number % 3 == 0:\n            print(\"The given integer is odd and a multiple of 3.\")\n        else:\n            print(\"The given integer is odd and not a multiple of 3.\")", "def hamming_weight(byte):\n    # Implement this function to calculate the Hamming weight of a byte.\n    # The Hamming weight is the number of 1's in the byte.\n    # This can be done using a bitwise operation that counts the number of bits set to 1.\n    return bin(byte).count('1')", "def filter_words(words):\n    \"\"\"Function to filter a given list of words, such that all words with odd length are filtered out.\"\"\" \n    filtered_words = [word for word in words if len(word) % 2 == 0]\n    return filtered_words", "def is_multiple(n):\n    \"\"\"\n    Function to check if a given number is a multiple of 3 or 5.\n    \n    Parameters: \n    n (int): The given number to check.\n    \n    Returns: \n    bool: True if number is a multiple of 3 or 5, False otherwise.\n    \"\"\"\n    return n % 3 == 0 or n % 5 == 0"]}
{"task_id": 373, "content": ["def frequencySort(nums):\n    # collections.Counter(nums) gives the frequency of each element in the nums array.\n    # items() function returns a view object that displays a list of a dictionary's(an iterable) tuple pair (key, value).\n    c = Counter(nums).items()\n    # Then we will sort the results by the tuple (-count, num). Negative count ensures that high frequency elements come first in the sorted list.\n    # This satisfies the requirement to sort in increasing frequency. \n    # Because we use num for sort as well, elements with the same frequency are sorted in descending order.\n    # This satisfies the requirement to sort in decreasing order on the basis of value of the numbers in case of same frequency.\n    # idx is used to sort elements in increasing order of their index in case elements are same and have same frequency.\n    # sort function of python is stable. i.e, it maintains the relative order of items with equal sort keys\n    nums.sort(key = lambda x: (nums.count(x), -x, [i for i, n in enumerate(nums) if n == x][0]))\n    # return the sorted array\n    return nums", "def search_for_index(array, value):\n    '''\n    This function will search for the index of a given value in an array.\n    \n    Args:\n        array (list): the array to be searched\n        value (object): the value to be searched for\n\n    Returns:\n        int: the index of the value if found, -1 otherwise\n    '''\n    try:\n        return array.index(value)\n    except ValueError:\n        return -1", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def find_mode(arr):\n    # create a dictionary to store the frequency of each element in the array\n    freq_dict = {}\n    \n    # iterate through the array and keep a record of the frequency\n    for num in arr:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n            \n    # find the element with the highest frequency \n    max_freq = 0\n    mode = None\n    for key, value in freq_dict.items():\n        if value > max_freq:\n            max_freq = value\n            mode = key\n    return mode", "def find_kth_smallest(arr, k):\n    if k > len(arr):\n        return 'Error: k is larger than the array length.'\n    \n    # find unique values in the array\n    unique_values = list(set(arr))\n    \n    # If k is more than the number of unique values, return an error\n    if k > len(unique_values):\n        return 'Error: k is greater than the number of unique elements in the array.'\n    \n    # find the kth smallest unique value\n    kth_smallest = heapq.nsmallest(k, unique_values)[-1]\n    \n    # calculate the frequency of kth smallest unique value in the array\n    count = collections.Counter(arr)[kth_smallest]\n    \n    return (kth_smallest, count)"]}
{"task_id": 374, "content": ["def factorial(n, limit=998):\n    \"\"\"\n    Calculates the factorial of a number using recursion and handles various scenarios.\n\n    Args:\n        n (int): The number for which the factorial is to be calculated.\n        limit (int): The pre-defined limit for recursion depth.\n\n    Returns:\n        int or str: The factorial of the number or an appropriate error message.\n\n    Raises:\n        FactorialError: If the recursion depth exceeds the pre-defined limit.\n\n    \"\"\"\n    if n > limit:\n        raise FactorialError(\"Exceeded pre-defined limit for recursion depth.\")\n    elif n < 0:\n        return \"Sorry, factorial does not exist for negative numbers.\"\n    elif n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)", "def factorial(n):\n    \"\"\"Calculate factorial of a number using recursion.\"\"\"\n    if n==1:       \n       return n\n    else:\n       return n * factorial(n-1)", "def recursive_sqrt(number, current_value = 1):\n    \"\"\"Return the square root of a given number using recursion\n    \n    Arguments:\n    number -- The number whose square root is to be calculated.\n    value -- The current approximation of the square root of the number.\n    \"\"\"\n    new_value = (current_value + number/current_value)/2\n    if abs(new_value - current_value) <= 0.0000009:\n        return new_value\n    else:\n        return recursive_sqrt(number, new_value)", "def factorial(n):\n    if n == 0:\n        return 1\n    elif n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers.\")\n    \n    # Generate a random number to determine recursion direction\n    random_direction = random.choice([True, False])\n    \n    if random_direction:\n        # Recursion from the beginning of the number\n        return n * factorial(n-1)\n    else:\n        # Recursion from the end of the number\n        return factorial(n-1) * n", "def print_numbers(current_number, limit=10):  # Define the function with current_number argument and an optional limit argument which defaults to 10.\n    if current_number > limit:  # Base case: If current_number is greater than the limit, stop the recursion.\n        return\n    else:\n        print(current_number)  # Print the current number.\n        print_numbers(current_number + 1, limit)  # Recursive case: call the function again with the next number and the same limit."]}
{"task_id": 375, "content": ["def swap_case(string):\n    '''This function swaps the case of all characters in a given string.'''\n    new_string = ''\n    for char in string:\n        if char.isupper():\n            new_string += char.lower()\n        else:\n            new_string += char.upper()\n    return new_string", "def find_index_of_first_occurrence(string, character):\n    '''\n    This function will find the index of the first occurrence of a given character in a string.\n\n    Args:\n        string (str): the string to be searched\n        character (str): the character to be searched for\n\n    Returns:\n        int: the index of the first occurrence of the character\n    '''\n    return string.find(character)", "def make_palindrome(string: str) -> int:\n    \"\"\" Find the minimum number of characters that need to be added at the end of the supplied string to make it a palindrome, ignoring case, non-alphanumeric characters, and spaces between words.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Compute the length of the string prefix that comes before the palindromic suffix.\n    - Return the length of the prefix as the minimum number of characters needed to create the shortest possible palindrome.\n    \"\"\"\n    filtered_string = ''.join(char.lower() for char in string if char.isalnum())\n    \n    for i in range(len(filtered_string)):\n        if is_palindrome(filtered_string[i:]):\n            return i", "def make_palindrome(string: str) -> int:\n    \"\"\"\n    Find the minimum number of characters that need to be added at the end of the supplied string to make it a palindrome, \n    ignoring case, non-alphanumeric characters, and spaces between words.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome,\n    - Compute the length of the string prefix that comes before the palindrome suffix.\n    - Return the length of the prefix as the minimum number of characters needed to create the shortest possible palindrome.\n    \"\"\"\n    filtered_string = ''.join(char.lower() for char in string if char.isalnum())\n\n    for i in range(len(filtered_string)):\n        if is_palindrome(filtered_string[i:]):\n            return i", "def can_arrange(arr, bracket):\n    # Slice array according to bracket\n    sub_arr = arr[bracket[0]:bracket[1]+1]\n    \n    # Loop through the subarray to find a pair of elements\n    for i in range(len(sub_arr) - 1):\n        if sub_arr[i] > sub_arr[i+1]:\n            # Return the indices of the pair if it exists\n            return {'index': bracket[0]+i, 'swap_with': bracket[0]+i+1}\n    \n    # Return {-1, -1} if no such pair exists\n    return {'index': -1, 'swap_with': -1}"]}
{"task_id": 376, "content": ["def check_odd_even(hex_number):\n    # Convert hexadecimal to decimal\n    decimal_number = int(hex_number, 16)\n    \n    # Check if the number is odd or even\n    if decimal_number % 2 == 0:\n        print(f\"The hex number {hex_number} is Even.\")\n    else:\n        print(f\"The hex number {hex_number} is Odd.\")", "def check_odd_even(hex_number):\n    # Convert hexadecimal to decimal\n    decimal_number = int(hex_number, 16)\n    \n    # Check if the number is odd or even\n    if decimal_number % 2 == 0:\n        print(f\"The hex number {hex_number} is Even.\")\n    else:\n        print(f\"The hex number {hex_number} is Odd.\")", "def is_even(num):\n    \"\"\"\n    This function takes a number as input and checks whether it is even or odd.\n\n    Parameters\n    ----------\n    num : int\n        The number to be checked.\n\n    Returns\n    -------\n    bool\n        Returns True if the number is even, False otherwise.\n    \"\"\"\n    if num % 2 == 0:\n        return True\n    else:\n        return False", "def check_hexadecimal(num):\n    # Convert hexadecimal to decimal\n    decimal_num = int(num, 16)\n\n    # Check if the number is even or odd\n    if decimal_num % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"", "def classify_number(num):\n    \"\"\"Classify an integer as even or odd.\n    \n    Args:\n        num: the integer to classify.\n   \n    Returns:\n        \"Even\" if the number is even, and \"Odd\" if it is odd.\n    \"\"\"\n    # Check if the number is divisible by 2\n    if (num % 2 == 0):\n        return \"Even\"\n    else:\n        return \"Odd\""]}
{"task_id": 377, "content": ["def check_number(n):\n    if is_power_of_three(n):\n        largest_power_of_three = find_largest_power_of_three(n)\n        num_binary_digits = count_binary_digits(largest_power_of_three)\n        print(f\"{n} is a power of three. Largest power of three less than or equal to {n} is {largest_power_of_three} (with {num_binary_digits} binary digits).\")\n    else:\n        print(f\"{n} is not a power of three.\")", "def get_lcm(n):\n    prime_factors = []\n    for i in range(2, n + 1):\n        # Find the prime factors of each number from 1 to n\n        for j in range(2, i + 1):\n            if i % j == 0:\n                is_prime = True\n                for k in range(2, int(j ** 0.5) + 1):\n                    if j % k == 0:\n                        is_prime = False\n                        break\n                if is_prime:\n                    prime_factors.append(j)\n    lcm = 1\n    # Loop through the unique prime factors less than or equal to n\n    for factor in set(prime_factors):\n        max_power = 0\n        # Find the highest power of the prime factor that divides any number from 1 to n\n        for i in range(1, n + 1):\n            power = 0\n            while i % factor == 0:\n                power += 1\n                i //= factor\n            if power > max_power:\n                max_power = power\n        # Multiply the prime factor by its highest power to get the contribution to the LCM\n        lcm *= factor ** max_power\n    return lcm", "def sieve_eratosthenes(N):\n    \"\"\"\n    This function uses the Sieve of Eratosthenes algorithm to generate all prime numbers up to N.\n    The function returns a generator that yields the prime numbers one by one, allowing for memory-efficient processing of large ranges.\n\n    The function also includes a check to ensure the input is an integer greater than one and raises a custom exception if it is not.\n\n    :param N: The upper limit of the range to search for primes. Must be an integer greater than one.\n    :returns: A generator that yields the prime numbers up to N one by one.\n    :raises ValueError: If N is not an integer or is less than or equal to one.\n    \"\"\"\n    if not isinstance(N, int) or N <= 1:\n        raise ValueError(\"Input must be an integer greater than one.\")\n    primes = [True for _ in range(N+1)]\n    p = 2\n    while p * p <= N:\n        if primes[p]:\n            for i in range(p * p, N + 1, p):\n                primes[i] = False\n        p += 1\n    for p in range(2, N):\n        if primes[p]:\n            yield p", "def choose_num(x, y, z):\n    \"\"\"This function should take three positive numbers x, y, and z. The function must return \n    the largest even integer number that is less than or equal to y and greater than or equal \n    to x, which is also a multiple of z. In case no such number exists, the function should return None.\n    \n    Validate your code with the added complexity of handling potential exceptions.\n    \"\"\"  \n    if not (type(x) == type(y) == type(z) == int):\n        return \"Error: Inputs must be integers.\"\n\n    if not (x >= 0 and y >= 0 and z >= 0):\n        return \"Error: Inputs must be positive.\"\n\n    if x > y:\n        return \"Error: x should be less than or equal to y.\"\n\n    #Initialize the largest number as None.\n    largest_num = None\n    \n    #Iterate from y to x both inclusive to find largest even multiple of z.\n    for i in range(y, x - 1, -1):\n        if i % z == 0 and i % 2 == 0:\n            largest_num = i\n            break\n        \n    #Return the largest number.\n    return largest_num", "def inject_payload(pid, payload):\n    # This function would need to be implemented to attach to the process,\n    # find the system call table, and modify it to point to the custom handler.\n    # This is a complex task that typically requires kernel-level access and\n    # is beyond the scope of a simple Python script.\n    pass"]}
{"task_id": 378, "content": ["def lucas_numbers(n):\n    if n<2:\n        return []\n    lucas = [2, 1] # Initial two numbers\n    while True:\n        new_number = lucas[-1] + lucas[-2] # Find new number\n        if new_number > n: # If the new number is larger than n, stop the loop\n            break\n        else:\n            lucas.append(new_number) # Append the new number to the list\n    return lucas", "def lucas(n):\n    if n == 0:\n        return 2   # Correcting the first Lucas number\n    elif n == 1:\n        return 1   # Correcting the second Lucas number\n    else:\n        return lucas(n - 1) + lucas(n - 2)", "def lucas(n):\n    if n == 0:\n        return 2     # Correcting the first Lucas number\n    elif n == 1:\n        return 1     # Correcting the second Lucas number\n    else:\n        return lucas(n - 1) + lucas(n - 2)", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass", "def lucas_series(n):\n    if not isinstance(n, int) or n < 1:\n        return \"The input has to be a positive integer.\"\n    \n    lucas = [2, 1]\n    for i in range(2, n):\n        lucas.append(lucas[i-1] + lucas[i-2])\n        \n    return lucas[n-1]"]}
{"task_id": 379, "content": ["def process_elevation_marker_views(items):\n    \"\"\"\n    Processes elevation marker views based on the input type.\n\n    Args:\n    items: A single item or a list of items.\n\n    Returns:\n    If the input is a list, returns a new list containing the results of applying the GetElevationMarkerView function to each item in the input list.\n    If the input is not a list, returns the result of applying the GetElevationMarkerView function to the single input item.\n    \"\"\"\n    if isinstance(items, list):\n        return [GetElevationMarkerView(x) for x in items]\n    else:\n        return GetElevationMarkerView(items)", "def process_fruits(fruits):\n    '''\n    This function receives a list of fruits, and returns a new list containing only the fruits \n    that contain the letter 'a' and have less than 6 characters. None type items in the given list \n    are handled accordingly.\n\n    Parameters:\n    fruits (list): List of fruits, which might include None type objects.\n\n    Returns:\n    list: List of selected fruits passing the criteria.\n    '''\n\n    # validate if the input is a list\n    if not isinstance(fruits, list):\n        raise ValueError(\"Input should be a list\")\n\n    try:\n        # using list comprehension having the checks inside\n        new_list = [fruit for fruit in fruits if fruit is not None and 'a' in fruit and len(fruit) < 6]\n    except TypeError:\n        # error raised when one of the items is not a string\n        raise TypeError(\"All items in the list should be strings or None\")\n    \n    return new_list", "def process_fruits(fruits):\n    '''\n    This function receives a list of fruits, and returns a new list containing only the fruits \n    that contain the letter 'a' and have less than 6 characters. None type items in the given list \n    are handled accordingly.\n\n    Parameters:\n    fruits (list): List of fruits, which might include None type objects.\n\n    Returns:\n    list: List of selected fruits passing the criteria.\n    '''\n\n    # validate if the input is a list\n    if not isinstance(fruits, list):\n        raise ValueError(\"Input should be a list\")\n\n    try:\n        # using list comprehension having the checks inside\n        new_list = [fruit for fruit in fruits if fruit is not None and 'a' in fruit and len(fruit) < 6]\n    except TypeError:\n        # error raised when one of the items is not a string\n        raise TypeError(\"All items in the list should be strings or None\")\n    \n    return new_list", "def find_words_with_fr(string):\n    '''\n    This function will find all words containing the letters \"fr\" in a given string.\n    \n    Args:\n        string (str): the string to be searched\n    \n    Returns:\n        list: a list of all words containing the letters \"fr\"\n    '''\n    regex = r\"\\b\\w*fr\\w*\\b\"\n    return re.findall(regex, string)", "def odd_sum_prime_index_elements(x):\n    \"\"\"Given a list of positive integers x, construct a sorted list in ascending order that only includes unique items which, when their digits are added together, yield an odd number, and are situated at prime indexed locations in the input list. The indices of the resultant list must also be prime numbers. If the elements at the prime indices are not numbers, return \"Non-numeric elements found\". If x is not a list, returns \"Input is not a list\"."]}
{"task_id": 380, "content": ["def list_to_set(data):\n    \"\"\"\n    Function to convert a list to a set; managing nested lists and converting them to nested sets.\n    \"\"\"\n    # If data is a list convert each item in the list to a set recursively\n    if isinstance(data, list):\n        return set(list_to_set(item) for item in data)\n\n    # If data is a set convert each item in the set to a set recursively\n    elif isinstance(data, set):\n        return {list_to_set(item) for item in data}\n  \n    # If data is a tuple convert each item in the tuple to a set recursively and convert the tuples into sets.\n    elif isinstance(data, tuple):\n        return {list_to_set(item) for item in data}\n  \n    # If data is a dictionary convert each key value pair to tuple and handle each item in the tuple recursively.\n    elif isinstance(data, dict):\n        return {list_to_set((k,v)) for k,v in data.items()}\n\n    # If data is not a list, set, tuple or dict just return the data\n    else:\n        return data", "def list_to_set(data):\n    \"\"\"\n    Function to convert a list to a set, managing nested lists and converting them to nested sets.\n    \"\"\"\n    # If data is a list, convert each item in the list to a set recursively\n    if isinstance(data, list):\n        return set(list_to_set(item) for item in data)\n\n    # If data is a set, convert each item in the set to a set recursively\n    elif isinstance(data, set):\n        return {list_to_set(item) for item in data}\n  \n    # If data is a tuple, convert each item in the tuple to a set recursively and convert the tuples into sets\n    elif isinstance(data, tuple):\n        return {list_to_set(item) for item in data}\n  \n    # If data is a dictionary, convert each key-value pair to a tuple and handle each item in the tuple recursively\n    elif isinstance(data, dict):\n        return {list_to_set((k,v)) for k,v in data.items()}\n\n    # If data is not a list, set, tuple, or dict, just return the data\n    else:\n        return data", "def sieve_eratosthenes(N):\n    \"\"\"\n    This function uses the Sieve of Eratosthenes algorithm to generate all prime numbers up to N.\n    The function returns a generator that yields the prime numbers one by one, allowing for memory-efficient processing of large ranges.\n\n    The function also includes a check to ensure the input is an integer greater than one and raises a custom exception if it is not.\n\n    :param N: The upper limit of the range to search for primes. Must be an integer greater than one.\n    :returns: A generator that yields the prime numbers up to N one by one.\n    :raises ValueError: If N is not an integer or is less than or equal to one.\n    \"\"\"\n    if not isinstance(N, int) or N <= 1:\n        raise ValueError(\"Input must be an integer greater than one.\")\n    primes = [True for _ in range(N+1)]\n    p = 2\n    while p * p <= N:\n        if primes[p]:\n            for i in range(p * p, N + 1, p):\n                primes[i] = False\n        p += 1\n    for p in range(2, N):\n        if primes[p]:\n            yield p", "def remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Facilitate the de-duplication of a sequence of integers, eliminating any references that occur more than once.\n    Retains the exact sequence of remaining integers mirroring the original provided sequence.\n    Time complexity: O(n)\n    Space complexity: O(1)\n    \"\"\"\n    write = 1\n    for read in range(1, len(numbers)):\n        if numbers[read] != numbers[read-1]:\n            numbers[write] = numbers[read]\n            write += 1\n    return numbers[:write]   # cutting the array to length 'write'", "def check_anagram_segments(text: str) -> bool:\n    \"\"\"\n    Given an input string, the function is intended to determine whether it is possible to \n    divide the string into two or more segments that are anagrams of one another. \n\n    Anagrams are words or phrases formed by reordering the letters of a different word or phrase, \n    typically using all the original letters exactly once.\n\n    The function counts the frequency of each unique character in the string and stores it in a dictionary. \n    If all frequencies are even number then the function returns True as the string can be divided into \n    two or more segments that are anagrams of one another. \n    \n    But if there is more than one character with an odd count frequency, then the function returns False\n    as it is not possible to divide the string into segments that are anagrams of one another. \n\n    Parameters:\n    text (str): The string to check for anagram segments\n\n    Returns:\n    bool: True if the string can be divided into anagram segments, False otherwise.\n\n    Examples:\n    \n    >>> check_anagram_samples('abcdefabcdegf')\n    True\n    >>> check_anagram_samples('helloworld')\n    False\n    \"\"\"\n\n    # count the frequency of each unique character in the string\n    frequency = {}\n    for char in text:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n\n    # count characters with odd count frequency\n    count_odd = sum(1 for count in frequency.values() if count % 2)\n\n    return count_odd <= 1"]}
{"task_id": 381, "content": ["def fibonacci(n):\n\n    # If the result is already in the memo dictionary, return it.\n    if n in memo:\n        return memo[n]\n\n    # If n is even, use the formula F(n) = [2*F(n/2-1) + F(n/2)]*F(n/2)\n    if n % 2 == 0:\n        memo[n] = (2 * fibonacci(n // 2 - 1) + fibonacci(n // 2)) * fibonacci(n // 2) % MOD\n    else:        \n        # If n is odd, use the formula F(n) = F((n + 1)/2) ^ 2 + F((n - 1)/2) ^ 2\n        memo[n] = (fibonacci((n + 1) // 2) ** 2 + fibonacci((n - 1) // 2) ** 2) % MOD\n\n    # Return the memoized result.\n    return memo[n]", "def trapezoidal_rule(f, a, b, N):\n    h = (b - a) / N\n    return (h / 2) * (f(a) + f(b) + 2*sum(f(a + i*h) for i in range(1, N)))", "def trapezoidal_rule(f, a, b, n):\n    h = (b - a) / n\n    result = 0.5 * (f(a) + f(b))\n    for i in range(1, n):\n        result += f(a + i * h)\n    return result * h", "def recursiveFunction(n):\n    '''This function calculates the recurrence relation defined as F(n) = F(n-1) + F(n-2).'''\n    if n <= 1:\n        return n\n    else:\n        return recursiveFunction(n-1) + recursiveFunction(n-2)", "def solve(n):\n    mod = int(1e9)\n    f = math.factorial\n    power = pow(4, n - 16, mod)\n    fact = f(4)\n    comb = f(n + 1) // f(5) // f(n - 4)\n    return (power * fact * comb) % mod"]}
{"task_id": 382, "content": ["def longest_increasing_subsequence(sequence):\n    \"\"\"\n    This function uses dynamic programming to find the longest increasing subsequence in the input array. \n\n    Firstly, we initialize the list length with size as input array size. Each element in length represents the longest \n    increasing subsequence in sequence[0...i]. After initializing the list length with 1, the function fills length in \n    a bottom-up manner(using dynamic programming), i.e., if sequence[j] > sequence[i] for some i < j and length[j] < length[i] + 1,\n    then update length[j].\n\n    Finally, the function returns the maximum value from the list length.\n\n    :param sequence: An input array of integers\n    :type sequence: list\n    :return: The longest increasing subsequence in the array\n    :rtype: int\n    \"\"\"\n\n    # initialize the list length with 1's because a minimum increasing subsequence would just be one number itself\n    length = [1] * len(sequence)\n\n    # loop over the sequence from the second element\n    for i in range(1, len(sequence)):\n        # consider all smaller elements found so far\n            for j in range(i):\n                # if this element is bigger, check if we can increase the length of the largest subsequence ending at i\n                if sequence[i] > sequence[j] and length[i] < length[j] + 1:\n                    length[i] = length[j] + 1\n\n    # return the maximum length found\n    return max(length)", "def delete_idle_lambda(region_name):\n    \"\"\"\n    This function deletes idle AWS Lambda functions in a particular region.\n    :param region_name: str\n    :return: None\n    \"\"\"\n    # Create a session using boto3\n    session = boto3.Session(region_name=region_name)\n\n    # Connect to AWS Lambda service\n    lambda_client = session.client('lambda')\n\n    try:\n        # Get the list of all functions\n        functions = lambda_client.list_functions()\n\n        # Loop through each function\n        for function in functions['Functions']:\n            function_name = function['FunctionName']\n\n            # Here, we need to determine if the function is idle\n            # If the function is idle, we delete it\n            # Please replace `is_function_idle` with your actual check\n            if is_function_idle(function):\n                lambda_client.delete_function(FunctionName=function_name)\n                print(f\"Deleted function: {function_name}\")\n\n    except NoCredentialsError:\n        print(\"No AWS credentials were found.\")\n    except ClientError as e:\n        if e.response['Error']['Code'] == 'ResourceNotFoundException':\n            print(\"The specified lambda function does not exist.\")\n        else:\n            raise e", "def max_frequency(data):\n    # Count the frequency of each element in the list using Counter\n    freq = Counter(data)\n    # Get the element with maximum frequency using the max function\n    max_freq_element = max(freq, key=freq.get)\n    # Get the maximum frequency\n    max_freq = freq[max_freq_element]\n    print(f'Element with maximum frequency is {max_freq_element} with a frequency of {max_freq}')", "def max_frequency(data):\n    # Count the frequency of each element in the list using Counter\n    freq = Counter(data)\n    # Get the element with maximum frequency using the max function\n    max_freq_element = max(freq, key=freq.get)\n    # Get the maximum frequency\n    max_freq = freq[max_freq_element]\n    print(f'Element with maximum frequency is {max_freq_element} with a frequency of {max_freq}')", "def find_max(a, b, c):\n    \"\"\"\n    A function to find the maximum of three numbers.\n    \"\"\"\n    # Find the maximum of the three numbers\n    max_value = max(a, b, c)\n    \n    return max_value"]}
{"task_id": 383, "content": ["def is_multiple(n):\n    \"\"\"\n    Function to check if a given number is a multiple of 3 or 5.\n    \n    Parameters: \n    n (int): The given number to check.\n    \n    Returns: \n    bool: True if number is a multiple of 3 or 5, False otherwise.\n    \"\"\"\n    return n % 3 == 0 or n % 5 == 0", "def check_palindrome(input_string):\n    '''This function will check if the given string is a palindrome or not.'''\n    temp_string = input_string.lower()\n    return temp_string == temp_string[::-1]", "def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True", "def distinct_permutations(string):\n    # Use set to store distinct permutations\n    distinct_perms = set()\n\n    # Generate all permutations\n    perms = permutations(string)\n\n    # Check if each permutation is distinct\n    for perm in perms:\n        # Convert the permutation tuple to a string\n        perm_str = ''.join(perm)\n\n        # Add the permutation to the set if it is distinct\n        distinct_perms.add(perm_str)\n\n    # Convert the set of distinct permutations to a list\n    distinct_perms_list = list(distinct_perms)\n\n    # Sort the list of distinct permutations\n    distinct_perms_list.sort()\n\n    return distinct_perms_list", "def is_palindrome(s): \n    '''This function returns True or False based on whether the given string is a palindrome or not'''\n    # reverse the string\n    rev = s[::-1] \n  \n    # Check if string is equal to its reverse \n    if (s == rev): \n        return True\n    return False"]}
{"task_id": 384, "content": ["def find_index_of_first_occurrence(string, character):\n    '''\n    This function will find the index of the first occurrence of a given character in a string.\n\n    Args:\n        string (str): the string to be searched\n        character (str): the character to be searched for\n\n    Returns:\n        int: the index of the first occurrence of the character\n    '''\n    return string.find(character)", "def first_unique_char(str1, str2):\n    '''Given two strings, find the first non-repeated (unique) character in the second string.'''\n    for char in str2:\n        if char not in str1:\n            return char\n    return None", "def find_first_repeated_character(s):\n    \"\"\"\n    Find the first repeated character in a given string.\n    \n    Args:\n        s (str): The input string.\n        \n    Returns:\n        str: The first repeated character in s, or None if no repeated characters are found.\n    \"\"\"\n    char_set = set()\n    for c in s:\n        if c in char_set:\n            return c\n        char_set.add(c)\n    return None", "def first_non_repeated_char(string):\n    # Create a dictionary of character counts using Counter\n    char_counts = Counter(string)\n\n    # Loop through the string and return the first character with a count of 1\n    for char in string:\n        if char_counts[char] == 1:\n            return char\n\n    # If no non-repeated characters are found, return None\n    return None", "def first_non_repeating(s):\n    # Create a dictionary to count characters\n    counts = dict()\n    for char in s:\n        if char in counts:\n            counts[char] += 1\n        else:\n            counts[char] = 1\n\n    # Find the first non-repeated character\n    for char in s:\n        if counts[char] == 1:\n            return char\n\n    return None"]}
{"task_id": 385, "content": ["def starts_with_h(text):\n    \"\"\" Check whether the given string starts with the letter 'H'.\n\n    Args:\n        text (str): The input string.\n\n    Returns:\n        bool: True if the string starts with 'H', else False.\n    \"\"\"\n    return text[0].upper() == 'H'", "def is_palindrome(s): \n    '''This function returns True or False based on whether the given string is a palindrome or not'''\n    # reverse the string\n    rev = s[::-1] \n  \n    # Check if string is equal to its reverse \n    if (s == rev): \n        return True\n    return False", "def check_anagram_segments(text: str) -> bool:\n    \"\"\"\n    Given an input string, the function is intended to determine whether it is possible to \n    divide the string into two or more segments that are anagrams of one another. \n\n    Anagrams are words or phrases formed by reordering the letters of a different word or phrase, \n    typically using all the original letters exactly once.\n\n    The function counts the frequency of each unique character in the string and stores it in a dictionary. \n    If all frequencies are even number then the function returns True as the string can be divided into \n    two or more segments that are anagrams of one another. \n    \n    But if there is more than one character with an odd count frequency, then the function returns False\n    as it is not possible to divide the string into segments that are anagrams of one another. \n\n    Parameters:\n    text (str): The string to check for anagram segments\n\n    Returns:\n    bool: True if the string can be divided into anagram segments, False otherwise.\n\n    Examples:\n    \n    >>> check_anagram_samples('abcdefabcdegf')\n    True\n    >>> check_anagram_samples('helloworld')\n    False\n    \"\"\"\n\n    # count the frequency of each unique character in the string\n    frequency = {}\n    for char in text:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n\n    # count characters with odd count frequency\n    count_odd = sum(1 for count in frequency.values() if count % 2)\n\n    return count_odd <= 1", "def format_json(json_string):\n    # Remove any white spaces from the JSON string\n    json_string = json_string.replace(\" \", \"\")\n\n    # Initialize a stack to keep track of the nested structures\n    stack = []\n\n    # Initialize an empty string to store the formatted string\n    formatted_string = \"\"\n\n    # Initialize a flag to keep track of whether we are inside a string value\n    inside_string = False\n\n    # Iterate through each character in the JSON string\n    for char in json_string:\n        # Check if the character is a quote\n        if char == '\"':\n            # Toggle the flag to indicate whether we are inside a string value or not\n            inside_string = not inside_string\n        # Check if the character is a comma and we are not inside a string value\n        elif char == ',' and not inside_string:\n            # Add a space after the comma\n            formatted_string += \", \"\n        # Check if the character is a colon and we are not inside a string value\n        elif char == ':' and not inside_string:\n            # Add a space before and after the colon\n            formatted_string += \": \"\n        # Check if the character is an opening brace or bracket and we are not inside a string value\n        elif (char == '{' or char == '[') and not inside_string:\n            # Push the opening brace or bracket to the stack\n            stack.append(char)\n            # Add the character to the formatted string\n            formatted_string += char + \" \"\n        # Check if the character is a closing brace or bracket and we are not inside a string value\n        elif (char == '}' or char == ']') and not inside_string:\n            # Add a space before the closing brace or bracket\n            formatted_string = formatted_string.rstrip()\n            formatted_string += \" \"\n            # Pop the corresponding opening brace or bracket from the stack\n            opening_char = '{' if char == '}' else '['\n            stack.pop()\n            # Check if the stack is empty\n            if len(stack) == 0:\n                # Add a comma after the closing brace or bracket\n                formatted_string += \", \"\n            # Add the character to the formatted string\n            formatted_string += char\n        # Otherwise, add the character to the formatted string\n        else:\n            formatted_string += char\n\n    return formatted_string", "def compress_string(s):\n    # regex to match 3 or more of the same characters in a row\n    pattern = re.compile(r'(.)\\1{2,}')\n    \n    # function to replace matches with the character and its count\n    repl = lambda m: m.group(1) + str(len(m.group(0)))\n    \n    # replace matches in the string\n    compressed = re.sub(pattern, repl, s)\n    \n    return compressed"]}
{"task_id": 386, "content": ["def find_max(a, b, c):\n    \"\"\"\n    A function to find the maximum of three numbers.\n    \"\"\"\n    # Find the maximum of the three numbers\n    max_value = max(a, b, c)\n    \n    return max_value", "def find_median(a, b, c):\n    # Calculate the sum of the three numbers\n    total = a + b + c\n    \n    # Find the minimum and maximum numbers\n    minimum = total - max(a, b, c)\n    maximum = total - min(a, b, c)\n    \n    # Calculate the median by subtracting the minimum and maximum from the total\n    median = total - minimum - maximum\n    \n    # Return the median\n    return median", "def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def calculate_median(numbers):\n    \"\"\"\n    Calculates the median of a list of numbers.\n    Args:\n        numbers: a list of numbers.\n    Returns:\n        median: the median of the list.\n    \"\"\"\n    numbers.sort()\n    length = len(numbers)\n    if length % 2 == 0:\n        median = (numbers[length//2 - 1] + numbers[length//2]) / 2\n    else:\n        median = numbers[length//2]\n    return median", "def median(arr):\n    '''\n    Function to find the median of an array of integer numbers\n    '''\n    # Sort the array\n    arr.sort()\n    \n    # Compute median\n    n = len(arr)\n    if n % 2 == 0:\n        median = (arr[int(n/2)] + arr[int(n/2)-1]) / 2\n    else:\n        median = arr[int(n/2)]\n\n    # Return the median\n    return median"]}
{"task_id": 387, "content": ["def add_digits(number):\n    \"\"\"This function adds all the digits of a given number \n    and returns the result.\n    \n    Args:\n        number (int): The number to process.\n    \n    Returns:\n        int: The result of adding all the digits of the given number.\n    \"\"\"\n    if number < 10:\n        return number\n    total = number % 10 + add_digits(number // 10)\n    return total", "def apply_function(arr, f):\n    \"\"\"\n    Apply a given function to each item of an input array.\n    \n    Args:\n        arr (list): The input array.\n        f (function): The function to be applied.\n        \n    Returns:\n        list: A list with the result of applying function f to each item of arr.\n    \"\"\"\n    return list(map(f, arr))", "def is_narcissistic(num):\n    digits = [int(d) for d in str(num)] # Convert the number to a list of digits\n    sum_of_cubes = sum([d**3 for d in digits]) # Sum the cubes of each digit\n    return sum_of_cubes == num # Return True if the sum of cubes is equal to the number itself, False otherwise", "def isArmstrong(num):\n    # To store the sum of the power of each digit\n    sum_digits = 0\n\n    # Find the number of digits\n    digits = len(str(num))\n\n    # Go through each digit\n    temp = num\n    while temp > 0:\n        digit = temp % 10\n\n        # Raise it to the power of the number of digits\n        sum_digits += digit ** digits\n\n        temp //= 10\n\n    # Check if sum of the digits raised to the power is\n    # equal to the original number\n    return num == sum_digits", "def num_digits(number):\n    \"\"\"This function will take a number and calculate the number of digits in the number.\"\"\"\n    # Count the number of digits\n    num_digits = 0\n    while number != 0:\n        num_digits += 1\n        number //= 10\n    \n    # Return the number of digits\n    return num_digits"]}
{"task_id": 388, "content": ["def bitwise_xor_multiply(num_1, num_2):\n    # Perform a bitwise XOR operation\n    xor_result = num_1 ^ num_2\n    # Perform multiplication\n    multiply_result = num_1 * num_2\n    # Return the combined result\n    return xor_result * multiply_result", "def compare_numbers(num1, num2):\n    # Bitwise XOR operation\n    xor = num1 ^ num2\n    # Bitwise AND operation\n    bit_and = num1 & num2\n    # Bitwise OR operation\n    bit_or = num1 | num2\n    # Bitwise NOT operation\n    bit_not = ~bit_or\n    \n    # Calculate the larger number using bitwise operations\n    larger_num = (bit_or & bit_not) | (bit_and & xor)\n    \n    # Check if the numbers are equal\n    if xor == 0:\n        return \"Equal\"\n    else:\n        return larger_num", "def decrypt_data(encrypted_data, key):\n    # This is a placeholder function. The actual decryption logic would depend on the encryption algorithm.\n    # For example, if the algorithm is XOR with a single byte key, this function would perform the XOR operation.\n    decrypted_data = bytearray()\n    for byte in encrypted_data:\n        decrypted_byte = byte ^ key  # XOR operation with the key\n        decrypted_data.append(decrypted_byte)\n    return decrypted_data", "def add_numbers_recursive(a, b):\n    if b == 0:\n        return a\n    else:\n        sum = a ^ b  # Perform bitwise XOR to get the sum of bits without carry\n        carry = (a & b) << 1  # Perform bitwise AND and left shift to get the carry\n        return add_numbers_recursive(sum, carry)", "def tag_join_across_consume(ht):\n    # Perform tagging/joining across consume operation\n    # Logic to combine partitions based on tagging and joining\n\n    # Your implementation of tagging/joining across consume operation goes here\n\n    return ht  # Return the modified label hash"]}
{"task_id": 389, "content": ["def get_word_frequency_tuples(preprocessed_tokens):\n    # Get the word frequencies using the get_word_frequencies function\n    word_freq = get_word_frequencies(preprocessed_tokens)\n    \n    # Convert the dictionary of word frequencies to a list of tuples\n    word_freq_tuples = list(word_freq.items())\n    \n    # Sort the list of tuples by frequency in descending order\n    word_freq_tuples.sort(key=lambda x: x[1], reverse=True)\n    \n    # Return the list of tuples\n    return word_freq_tuples", "def get_word_frequency_tuples_for_words(preprocessed_tokens, words):\n    # Get the word frequencies using the get_word_frequencies function\n    word_freq = get_word_frequencies(preprocessed_tokens)\n    \n    # Create an empty list to store the word frequency tuples for the specified words\n    word_freq_tuples_for_words = []\n    \n    # Loop through each word in the specified words list\n    for word in words:\n        # If the word is in the word_freq dictionary, add it to the word_freq_tuples_for_words list\n        if word in word_freq:\n            word_freq_tuples_for_words.append((word, word_freq[word]))\n    \n    # Sort the list of tuples by frequency in descending order\n    word_freq_tuples_for_words.sort(key=lambda x: x[1], reverse=True)\n    \n    # Return the list of tuples\n    return word_freq_tuples_for_words", "def sort_data(data, key, reverse=False):\n    '''\n    Function to sort data by a custom criteria.\n\n    Parameters\n    ----------\n    data: list\n        List of objects that need to be sorted.\n    key: function\n        A function that maps the objects in the data to the score that will be used for sorting.\n    reverse: boolean, optional\n        If True, the data will be sorted in reverse order.\n\n    Returns\n    ----------\n    sorted_data: list\n        The sorted list.\n    '''\n\n    # Create a list of tuples [(score, data_item)...] using the key function\n    data_tups = [(key(data_item), data_item) for data_item in data]\n    # Sort the list by the scores\n    sorted_data_tups = sorted(data_tups, reverse=reverse)\n    # Extract the sorted data from the tuples\n    sorted_data = [data_tup[1] for data_tup in sorted_data_tups]\n \n    # Return the sorted data\n    return sorted_data", "def frequencySort(nums):\n    # collections.Counter(nums) gives the frequency of each element in the nums array.\n    # items() function returns a view object that displays a list of a dictionary's(an iterable) tuple pair (key, value).\n    c = Counter(nums).items()\n    # Then we will sort the results by the tuple (-count, num). Negative count ensures that high frequency elements come first in the sorted list.\n    # This satisfies the requirement to sort in increasing frequency. \n    # Because we use num for sort as well, elements with the same frequency are sorted in descending order.\n    # This satisfies the requirement to sort in decreasing order on the basis of value of the numbers in case of same frequency.\n    # idx is used to sort elements in increasing order of their index in case elements are same and have same frequency.\n    # sort function of python is stable. i.e, it maintains the relative order of items with equal sort keys\n    nums.sort(key = lambda x: (nums.count(x), -x, [i for i, n in enumerate(nums) if n == x][0]))\n    # return the sorted array\n    return nums", "def extract_identifier(captured_data):\n    # This function simulates the analysis of captured RFID data to extract the unique identifier.\n    # In a real RFID system, the data would need to be processed to extract the identifier.\n    \n    # For this simulation, we'll assume the captured data is the unique identifier itself\n    unique_identifier = captured_data\n    \n    return unique_identifier"]}
{"task_id": 390, "content": ["def add_matrices(A, B):\n    '''This function will return a matrix which is the result of the element wise addition of\n    two given matrices A & B.'''\n    result = [[A[i][j] + B[i][j] for j in range(len(A[0]))] for i in range(len(A))]\n    return result", "def transpose(matrix):\n    # The * operator is used to unzip a list (or other iterables), making a list of tuples where each tuple contains the i-th element from each of the argument sequences or iterables.\n    # The zip() function takes iterables, aggregates them in a tuple, and return the result.\n    # In other words, it returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.\n    return [list(i) for i in zip(*matrix)] ", "def factorial_of_tuple_elements(tup: Tuple, result: List):\n    \"\"\"\n    Calculate factorials of all integer values in a tuple (including nested tuples) and \n    append them to a specified list. Non-integer types and non-positive integers are ignored.\n   \n    Args:\n      tup: Tuple with nested tuples and integer values.\n      result: Original list to append the factorials to.\n   \n    Returns:\n      A list with factorials of all integer values found in the tuple.\n    \"\"\"\n    if tup == ():\n        return 'Error: Tuple is empty.'\n    else:\n        flattened = list(itertools.chain.from_iterable([[i] \n        if not isinstance(i, tuple) else list(i) for i in tup]))\n        for i in flattened:\n            if isinstance(i, int) and i >= 0:\n                result.append(math.factorial(i))\n            elif isinstance(i, float) and i >= 0:\n                result.append(math.factorial(round(i)))\n    return result", "def filter_tuples(tuples, func):\n    \"\"\"\n    Filters a list of tuples based on a given condition.\n    \"\"\"\n    filtered_tuples = filter(func, tuples)\n    for tuple in filtered_tuples:\n        print(tuple)", "def advanced_concurrent_collision_detector(n: int, left_lane_autos: List[Tuple[float, float]], right_lane_autos: List[Tuple[float, float]]) -> List[Tuple[int, int, float, float]]:\n    \"\"\" Detects the concurrent collisions between cars in both lanes.\n    Returns a list of tuples where each tuple represents a collision.\n    The first two elements are the index of the collided cars in left and right lanes and the other two elements are the overlapping distance.\n\n    :param n: Number of automobiles in each lane\n    :param left_lane_autos: List of tuples indicating the start and end points of automobiles in left lane\n    :param right_lane_autos: List of tuples indicating the start and end points of automobiles in right lane\n    :return: A list of tuples indicating the collided automobiles and their overlapping distance\n    \"\"\"\n    collisions = []\n    for i in range(n):\n        for j in range(n):\n            if left_lane_autos[i][0] < right_lane_autos[j][1] and left_lane_autos[i][1] > right_lane_autos[j][0]:  # Check if ranges of left and right cars overlap\n                overlap_start = max(right_lane_autos[j][0], left_lane_autos[i][0])\n                overlap_end = min(right_lane_autos[j][1], left_lane_autos[i][1])\n                collisions.append((i, j, overlap_start, overlap_end))\n    return collisions"]}
{"task_id": 391, "content": ["def process_tone(toneValue: int, p: int) -> Tuple[int, int]:\n    if toneValue >= 0:\n        if p > 9:\n            raise ValueError('pitch value exceeds the maximum limit of 9. Please use a value 9 or below.')\n        return toneValue % 12, p\n    elif toneValue < 0:\n        if p < -1:\n            raise ValueError('pitch value goes below the minimum limit of -1. Please use a value -1 or above.')\n        return (12 + toneValue) % 12, p", "def calc_nCr():\n    for i in range(401):\n        for j in range(i):\n            nCr[i][j] = (nCr[i-1][j] + nCr[i-1][j-1]) % mod\n            nCr[i][i-j] = nCr[i][j]\n        nCr[i][i] = 1", "def sieve_eratosthenes(N):\n    \"\"\"\n    This function uses the Sieve of Eratosthenes algorithm to generate all prime numbers up to N.\n    The function returns a generator that yields the prime numbers one by one, allowing for memory-efficient processing of large ranges.\n\n    The function also includes a check to ensure the input is an integer greater than one and raises a custom exception if it is not.\n\n    :param N: The upper limit of the range to search for primes. Must be an integer greater than one.\n    :returns: A generator that yields the prime numbers up to N one by one.\n    :raises ValueError: If N is not an integer or is less than or equal to one.\n    \"\"\"\n    if not isinstance(N, int) or N <= 1:\n        raise ValueError(\"Input must be an integer greater than one.\")\n    primes = [True for _ in range(N+1)]\n    p = 2\n    while p * p <= N:\n        if primes[p]:\n            for i in range(p * p, N + 1, p):\n                primes[i] = False\n        p += 1\n    for p in range(2, N):\n        if primes[p]:\n            yield p", "def format_for_latex(x, p=3):\n    \"\"\"Convert a float to a LaTeX-formatted string displaying the value to p significant\n    digits and in standard form.\n\n    Args:\n    x (float): The input value to be converted to a LaTeX-formatted string.\n    p (int, optional): The number of significant digits to display. Defaults to 3.\n\n    Returns:\n    str: A string representing the input value x in LaTeX format, displaying the value to p significant digits and in standard form.\n    \"\"\"\n    # Convert the float to standard form with p significant digits\n    formatted_value = \"{:.{p}e}\".format(x, p=p-1)\n\n    # Split the formatted value into coefficient and exponent parts\n    coefficient, exponent = formatted_value.split('e')\n\n    # Format the coefficient to remove trailing zeros and unnecessary decimal point\n    coefficient = str(float(coefficient))\n\n    # Construct the LaTeX-formatted string\n    latex_string = coefficient + r\" \times 10^{\" + str(int(exponent)) + \"}\"\n\n    return latex_string", "def compute_loss_gradient(predictions, target_labels, loss_function):\n    # Compute the gradient of the loss with respect to the model parameters\n    # This function should compute the gradient of the loss function with respect to the model parameters\n    # using the predictions, target labels, and the specified loss function\n    pass"]}
{"task_id": 392, "content": ["def isValidURL(url, previous_urls=None):\n    # Check if the URL format is valid\n    regex = re.compile(\n        r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\\\(\\\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'\n    )\n    if not regex.match(url):\n        return False, \"Invalid URL format.\"\n\n    # Check if the URL is a duplicate\n    if previous_urls and url in previous_urls:\n        return False, \"URL is a duplicate.\"\n\n    # Check if the URL is accessible\n    try:\n        response = requests.head(url, timeout=5)\n        if response.status_code != 200:\n            return False, f\"URL is not accessible, status code: {response.status_code}\"\n    except requests.RequestException as err:\n        return False, f\"URL is not accessible, error: {str(err)}\"\n\n    # If all checks pass, the URL is valid\n    return True, \"URL is valid.\"", "def validate_url(url):\n    # Regular expression to extract URL from text\n    url_pattern = re.compile(r'\\b((?:https?://|www\\.)\\S+\\.\\w{2,3}\\S*)\\b')\n    match = re.search(url_pattern, url)\n    \n    if match:\n        extracted_url = match.group(1)\n        if extracted_url.startswith(\"http://\") or extracted_url.startswith(\"https://\"):\n            try:\n                # Send a HEAD request to check SSL certificate validity\n                response = requests.head(extracted_url, verify=True)\n                if response.status_code == 200:\n                    print(\"URL is valid and SSL certificate is valid.\")\n                else:\n                    print(\"URL is valid but SSL certificate is not valid.\")\n            except requests.exceptions.SSLError:\n                print(\"URL is valid but SSL certificate is not valid.\")\n            except requests.exceptions.ConnectionError:\n                print(\"URL is valid but could not establish a connection.\")\n        else:\n            print(\"URL is valid but does not start with 'http://' or 'https://'.\")\n    else:\n        print(\"No valid URL found in the given text.\")", "def is_valid_url_char(char):\n    \"\"\"\n    Helper function to check if a character is a valid URL character.\n    \"\"\"\n    return char.isalnum() or char in ['-', '.', '_', '~']", "def validate(data, field, regex):\n    # Check if the data is empty\n    if not data:\n        raise ValueError('Data is required.')\n\n    # Check if the field exists in the data\n    if not field in data:\n        raise ValueError('Field ' + field + ' is required.')\n\n    # Check the format of the data using regex\n    import re\n    if not re.match(regex, data[field]):\n        raise ValueError('Field ' + field + ' is not valid.')", "def validate_url(url):\n    if is_valid_url(url):\n        print(f\"{url} is a valid URL.\")\n    else:\n        print(f\"{url} is not a valid URL.\")"]}
{"task_id": 393, "content": ["def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min", "def erroneous():\n    string1 = 'Python Programming'  # The closing quote of string1 was mismatched, so I corrected it\n    string2 = '101'\n\n    # Convert string2 into integer\n    int_value = int(string2)  # The square brackets [] should be replaced with parentheses () for the int function\n    float_value = float('10.5')  # Similarly, the square brackets [] should be replaced with parentheses () for the float function\n\n    # Find the maximum number between 10 and 20\n    max_value = max(10, 20)  # In order to find the maximum between two numbers, both numbers need to be provided as arguments\n\n    # Find the minimum number between 10 and 20\n    min_value = min(10, 20)  # Similarly, to find the minimum between two numbers, both numbers need to be provided as arguments\n\n    # Find the square root of a number\n    sqrt = math.sqrt(16)  # Again, the square brackets [] should be replaced with parentheses () for the sqrt function\n\n    return string1, int_value, float_value, max_value, min_value, sqrt", "def calculate_minimum(numbers):\n    \"\"\"\n    Find the minimum value in the given list of numbers.\n\n    :param numbers: List of numbers\n    :return: Minimum value\n    \"\"\"\n    return min(numbers)", "def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def inject_payload(pid, payload):\n    # This function would need to be implemented to attach to the process,\n    # find the system call table, and modify it to point to the custom handler.\n    # This is a complex task that typically requires kernel-level access and\n    # is beyond the scope of a simple Python script.\n    pass"]}
{"task_id": 394, "content": ["def filterEven(data):\n    result = ()\n\n    # Traverse every element in the data\n    for element in data:\n\n        # If the element is a complex number, skip it\n        if isinstance(element, complex):\n            continue\n\n        # If element is a list or dictionary, convert it to a tuple and recursively call this function\n        if isinstance(element, (list, dict)):\n            result += (filterEven(tuple(element)),)\n\n        # If the element is a tuple, recursively call this function\n        elif isinstance(element, tuple):\n            result += (filterEven(element),)\n\n        # If the element is a string, check if it represents an even number\n        elif isinstance(element, str):\n            # Check if the string can be converted to an integer\n            if element.isdigit():\n                num = int(element)\n                # If the number is even, append it to the results\n                if num % 2 == 0:\n                    result += (num,)\n        \n        # if the element is a floating number, just discard it.\n        elif isinstance(element, float):\n            continue\n\n        # If the element is an integer and it's even, append it to the results\n        elif isinstance(element, int):\n            if element % 2 == 0:\n                result += (element,)\n\n    return result", "def filterEven(data):\n    result = ()\n\n    # Traverse every element in the data\n    for element in data:\n\n        # If the element is a complex number, skip it\n        if isinstance(element, complex):\n            continue\n\n        # If element is a list or dictionary, convert it to a tuple and recursively call this function\n        if isinstance(element, (list, dict)):\n            result += (filterEven(tuple(element)),)\n\n        # If the element is a tuple, recursively call this function\n        elif isinstance(element, tuple):\n            result += (filterEven(element),)\n\n        # If the element is a string, check if it represents an even number\n        elif isinstance(element, str):\n            # Check if the string can be converted to an integer\n            if element.isdigit():\n                num = int(element)\n                # If the number is even, append it to the results\n                if num % 2 == 0:\n                    result += (num,)\n\n        # If the element is a floating number, just discard it.\n        elif isinstance(element, float):\n            continue\n\n        # If the element is an integer and it's even, append it to the results\n        elif isinstance(element, int):\n            if element % 2 == 0:\n                result += (element,)\n\n    return result", "def ethical_compliance_check():\n    # This function should contain checks to ensure the simulation is conducted within a controlled environment and complies with all relevant laws and ethical guidelines.\n    # For example, it could check the user's IP address or require explicit consent before proceeding with the simulation.\n    # Here we'll just return a boolean indicating whether the simulation is allowed to proceed.\n    return True", "def can_arrange_v2(arr, limits, criterion):\n    \"\"\"Specify a function that not only locates an element suitable for a distinct role, but also its likely swap contender, according to a constraint that the swapping elements must be within specified limits. If the elements are inexistent, return {'index': -1, 'swap_with': -1}. The input array should not contain duplicate values, 'limits' is a tuple of two integers indicating a subarray to consider elements within, and 'criterion' is a unique condition that the found element must meet.\n\n    Examples:\n    can_arrange_v2([1,2,4,3,5], (2, 4), is_prime) = {'index': 3, 'swap_with': 2}\n    can_arrange_v2([1,2,3], (0, 2), odd_number) = {'index': -1, 'swap_with': -1}\n    \"\"\"\n    # Extract subarray\n    subarray = arr[limits[0]:limits[1]+1]\n    \n    # Find the index of the first element within limits that meets the criterion\n    index = find_index_of_element_meeting_criterion(subarray, criterion)\n    \n    # If no such element exists\n    if index == -1:\n        return {'index': -1, 'swap_with': -1}\n    \n    # If such an element exists, find the swap contender\n    swap_with_index = find_index_of_next_possible_swap(subarray, index)\n    \n    # If no such swap contender exists\n    if swap_with_index == -1:\n        return {'index': -1, 'swap_with': -1}\n    \n    # If a valid swap contender does exist\n    return {'index': index + limits[0], 'swap_with': swap_with_index + limits[0]}  #add lower limit to adjust index for the actual array as opposed to the subarray.", "def can_arrange_v2(arr, limits, criterion):\n    \"\"\"\n    Specify a function that not only locates an element suitable for a distinct role, but also its likely swap contender, according to a constraint where the swapping elements must be within specified limits. If the elements are inexistent, return {'index': -1, 'swap_with': -1}. The input array should not contain duplicate values, 'limits' is a tuple of two integers indicating a subarray to consider elements within, and 'criterion' is a unique condition that the found element must meet.\n    \n    Examples:\n    can_arrange_v2([1,2,4,3,5], (2, 4), is_prime) - {'index': 3, 'swap_with': 2}\n    can_arrange_v2([1,2,3], (0, 2), odd_number) - {'index': -1, 'swap_with': -1}\n    \"\"\"\n    # Extract subarray\n    subarray = arr[limits[0]:limits[1]+1]\n\n    # Find the index of the first element within limits that meets the criterion\n    index = find_index_of_element_meeting_criterion(subarray, criterion)\n\n    # If no such element exists\n    if index == -1:\n        return {'index': -1, 'swap_with': -1}\n\n    # If such an element exists, find the swap contender\n    swap_with_index = find_index_of_next_possible_swap(subarray, index)\n\n    # If no such swap contender exists\n    if swap_with_index == -1:\n        return {'index': -1, 'swap_with': -1}\n\n    # If a valid swap contender does exist\n    return {'index': index + limits[0], 'swap_with': swap_with_index + limits[0]}  "]}
{"task_id": 395, "content": ["def inject_payload(pid, payload):\n    # This function would need to be implemented to attach to the process,\n    # find the system call table, and modify it to point to the custom handler.\n    # This is a complex task that typically requires kernel-level access and\n    # is beyond the scope of a simple Python script.\n    pass", "def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def add_digits(number):\n    \"\"\"This function adds all the digits of a given number \n    and returns the result.\n    \n    Args:\n        number (int): The number to process.\n    \n    Returns:\n        int: The result of adding all the digits of the given number.\n    \"\"\"\n    if number < 10:\n        return number\n    total = number % 10 + add_digits(number // 10)\n    return total", "def is_multiple(n):\n    \"\"\"\n    Function to check if a given number is a multiple of 3 or 5.\n    \n    Parameters: \n    n (int): The given number to check.\n    \n    Returns: \n    bool: True if number is a multiple of 3 or 5, False otherwise.\n    \"\"\"\n    return n % 3 == 0 or n % 5 == 0", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]"]}
{"task_id": 396, "content": ["def add_digits(number):\n    \"\"\"This function adds all the digits of a given number \n    and returns the result.\n    \n    Args:\n        number (int): The number to process.\n    \n    Returns:\n        int: The result of adding all the digits of the given number.\n    \"\"\"\n    if number < 10:\n        return number\n    total = number % 10 + add_digits(number // 10)\n    return total", "def num_digits(number):\n    \"\"\"This function will take a number and calculate the number of digits in the number.\"\"\"\n    # Count the number of digits\n    num_digits = 0\n    while number != 0:\n        num_digits += 1\n        number //= 10\n    \n    # Return the number of digits\n    return num_digits", "def is_armstrong_number(num):\n    # Create a variable to store the sum\n    sum = 0\n    # Create a variable to store the number of digits\n    n = len(str(num))\n    # Iterate over the digits of the number\n    for i in str(num):\n        # Find the sum\n        sum += int(i)**n\n    # Return if the number is Armstrong's number\n    return True if sum == num else False", "def is_multiple(n):\n    \"\"\"\n    Function to check if a given number is a multiple of 3 or 5.\n    \n    Parameters: \n    n (int): The given number to check.\n    \n    Returns: \n    bool: True if number is a multiple of 3 or 5, False otherwise.\n    \"\"\"\n    return n % 3 == 0 or n % 5 == 0", "def generate_fibonacci_sequence(start_number, number_count):\n    a = start_number  # starting number\n    b = start_number + 1  # next number\n  \n    fibonacci_sequence = []  # create an empty list to store the sequence\n  \n    fibonacci_sequence.append(a)  # add starting number to the sequence\n    fibonacci_sequence.append(b)  # add next number to the sequence\n  \n    for i in range(2, number_count):  # generate more numbers in the sequence\n        c = a + b  # calculate the next number\n        a = b  # update 'a' to the current number\n        b = c  # update 'b' to the next number\n        fibonacci_sequence.append(c)  # add the next number to the sequence\n    \n    return fibonacci_sequence  # return the generated Fibonacci sequence"]}
{"task_id": 397, "content": ["def contains_sum_k(arr, k):\n    # edge case: if the array is empty, we return false\n    if not arr:\n        return False\n\n    # initialize a hash_set to store the numbers from the array\n    hash_set = set()\n\n    # iterate the elements of the array one by one\n    for element in arr:\n        # if k - element is present in the hash_set, then it means there is a pair whose sum is equal to k\n        if k - element in hash_set:\n            return True\n\n        # else add the element to hash_set\n        hash_set.add(element)\n\n    # if all elements are iterated, and no possible pair is found\n    return False", "def find_smallest_in_arrays(arr1, arr2):\n    \"\"\"\n    Find and return the smallest elements in both arrays in O(nlog(n))\n\n    Parameters\n    ----------\n    arr1 : list\n        First array of integers\n    arr2 : list\n        Second array of integers\n\n    Returns\n    -------\n    int\n        The smallest element common to both arrays\n    \"\"\"\n    # Merge both the arrays\n    merged_arr = [*arr1, *arr2]\n    # Sort the merged array in O(nlog(n))\n    merged_arr.sort()\n\n    # Initialize first_min to the first element of sorted merged array\n    first_min = merged_arr[0]\n    # Initialize second_min to the second element of sorted merged array\n    second_min = merged_arr[1]\n\n    # Check if the first min element is in arr1 and the second min element is in arr2.\n    # If yes, return the first min element.\n    if first_min in arr1 and second_min in arr2:\n        return first_min\n    # Check if the first min element is in arr2 and the second min element is in arr1.\n    # If yes, return the first min element.\n    elif first_min in arr2 and second_min in arr1:\n        return first_min\n    # Else return the second min element\n    else:\n        return second_min", "def find_kth_largest(arr, k):\n    \"\"\"\n    Function to find the kth largest element in an array\n    \"\"\"\n    \n    # make a copy of the array\n    arr_copy = arr[:]\n    \n    # get the length of the array\n    length = len(arr_copy)\n    \n    # if k is greater than or equal to the length of the array, return the maximum element\n    if k >= length:\n        return max(arr_copy)\n        \n    # sort the array in descending order\n    arr_copy.sort(reverse=True)\n    \n    # get the kth element from the sorted array\n    kth_largest = arr_copy[k-1]\n    \n    return kth_largest", "def maximum_subarray_efficient(data: List[int]) -> int:\n    max_sum = data[0]  # Initialize max_sum to the first element of the array\n    current_sum = data[0]  # Initialize current_sum to the first element of the array\n\n    for num in data[1:]:  # Iterate through the array starting from the second element\n        current_sum = max(num, current_sum + num)  # Update current_sum to be the maximum of the current number and the sum of current_sum and the current number\n        max_sum = max(max_sum, current_sum)  # Update max_sum to be the maximum of max_sum and current_sum\n\n    return max_sum", "def find_largest_number(array):\n    max_num = array[0]  # Initialize the maximum number with the first element of the array\n    max_index = 0  # Initialize the index of the maximum number with 0\n\n    for i in range(1, len(array)):  # Start iterating from the second element of the array\n        if array[i] > max_num:  # If the current element is greater than the maximum number\n            max_num = array[i]  # Update the maximum number\n            max_index = i  # Update the index of the maximum number\n\n    return max_num, max_index"]}
{"task_id": 398, "content": ["def random_number(minimum, maximum):\n    '''This function takes a minimum and maximum number and generates a random number within the given range.'''\n    return random.randint(minimum, maximum)", "def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min", "def scrape_reviews(product_url):\n    \"\"\"\n    Scraper function to fetch reviews of a given product from Amazon.\n\n    Parameters\n    ----------\n    product_url: str\n        The URL of the product page on Amazon.\n\n    Returns\n    -------\n    list\n        A list containing the fetched reviews.\n    \"\"\"\n    # make a GET request to fetch the HTML content of the product page\n    response = requests.get(product_url)\n    html_content = response.text\n\n    # convert the HTML content to a bs4 object\n    soup = BeautifulSoup(html_content, 'html.parser')\n\n    # find the reviews\n    reviews = soup.find_all('div', class_='a-section a-spacing-small review-data')\n\n    # parse the reviews and store it in a list\n    reviews_list = []\n    for review in reviews:\n        reviews_list.append(review.find('span', class_=\"a-size-base review-text\").text.strip())\n\n    return reviews_list", "def find_symmetric_pairs(nums):\n    \"\"\"\n    Function to find symmetric pairs in a list of integers.\n\n    Arguments:\n    nums {list} -- List of integers to search for symmetric pairs.\n\n    Returns:\n    List of tuples representing symmetric pairs.\n    \"\"\"\n    pairs = []\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                pairs.append((nums[i], nums[j]))\n    return pairs", "def transpose(matrix):\n    # The * operator is used to unzip a list (or other iterables), making a list of tuples where each tuple contains the i-th element from each of the argument sequences or iterables.\n    # The zip() function takes iterables, aggregates them in a tuple, and return the result.\n    # In other words, it returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.\n    return [list(i) for i in zip(*matrix)] "]}
{"task_id": 399, "content": ["def calculate_minimum(numbers):\n    \"\"\"\n    Find the minimum value in the given list of numbers.\n\n    :param numbers: List of numbers\n    :return: Minimum value\n    \"\"\"\n    return min(numbers)", "def find_max_min(nums):\n    max_val = nums[0]  # Initialize the maximum value as the first element in the list\n    min_val = nums[0]  # Initialize the minimum value as the first element in the list\n    \n    # Iterate through the list to find the maximum and minimum values\n    for num in nums:\n        if num > max_val:\n            max_val = num  # Update the maximum value if a larger value is found\n        if num < min_val:\n            min_val = num  # Update the minimum value if a smaller value is found\n    \n    return (max_val, min_val)  # Return a tuple containing the maximum and minimum values", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def min_max(lst):\n    \"\"\"Find the maximum and minimum of the given list and return them in a list.\"\"\"\n    return [min(lst), max(lst)]", "def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min"]}
{"task_id": 400, "content": ["def to_camel_case(sentence: str) -> str:\n    words = sentence.split()  # Split the sentence into individual words\n    camel = words[0]  # Initialize the camel case string with the first word\n    for w in words[1:]:  # Iterate through the remaining words\n        camel += w.title()  # Capitalize each word and concatenate to the camel case string\n    return camel", "def snake_case_conversion(string):\n    # Regex to split camel case \n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', string)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "def match_text(text, search_string):\n    \"\"\"Returns all occurrences of substring in the given string with case and pattern insensitivity.\n\n    Args:\n    text (str): A string.\n    search_string (str): The substring for which to search.\n\n    Returns:\n    A list of all occurrences in the given string.\n    \"\"\"\n    matches = []\n    # Construct a case and pattern insensitive regex expression\n    search_string = re.compile(search_string, re.IGNORECASE)\n    # Search the string and add the matches to a list\n    for match in search_string.finditer(text):\n        matches.append(match.group(0))\n\n    return matches", "def convert_to_upper(string):\n    \"\"\"Function to convert the given string to all capital letters using an algorithm. Input should be a string.\"\"\"\n    result = ''\n    for char in string:\n        result += chr(ord(char) - 32)\n    return result", "def hex_to_bin(hex_string):\n    \"\"\"Function to convert a hexadecimal string into binary string.\"\"\"\n    # Convert to int using base 16 and then convert to binary.\n    bin_string = bin(int(hex_string, 16))[2:]\n    # Add leading zeros in case they were lost\n    bin_string = '0'*(4*len(hex_string) - len(bin_string)) + bin_string\n    return bin_string"]}
{"task_id": 401, "content": ["def remove_duplicates(arr):\n    \"\"\"Develop a method to remove the duplicates from a given array of numbers.\"\"\"\n    return list(set(arr))", "def primes(numbers):\n    \"\"\"Generator function to yield prime numbers from a given list.\"\"\"\n    for num in numbers:\n        if is_prime(num):\n            yield num", "def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]", "def extract_odd_numbers(my_list):\n    \"\"\"Returns a list containing only odd numbers from a given list. \n    Args:\n        my_list (list): list of integers\n    Returns:\n        list: list of odd numbers\n    \"\"\"\n    odd_list = []\n    for num in my_list:\n        if (num % 2 != 0): \n            odd_list.append(num)\n    return odd_list", "def delete_element(my_list, pos):\n    \"\"\"Function to delete an element from a given list at a given position.\"\"\"\n    del my_list[pos]\n    return my_list"]}
{"task_id": 402, "content": ["def transpose(matrix):\n    # The * operator is used to unzip a list (or other iterables), making a list of tuples where each tuple contains the i-th element from each of the argument sequences or iterables.\n    # The zip() function takes iterables, aggregates them in a tuple, and return the result.\n    # In other words, it returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.\n    return [list(i) for i in zip(*matrix)] ", "def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list", "def delete_element(my_list, pos):\n    \"\"\"Function to delete an element from a given list at a given position.\"\"\"\n    del my_list[pos]\n    return my_list", "def sort_data(data, key, reverse=False):\n    '''\n    Function to sort data by a custom criteria.\n\n    Parameters\n    ----------\n    data: list\n        List of objects that need to be sorted.\n    key: function\n        A function that maps the objects in the data to the score that will be used for sorting.\n    reverse: boolean, optional\n        If True, the data will be sorted in reverse order.\n\n    Returns\n    ----------\n    sorted_data: list\n        The sorted list.\n    '''\n\n    # Create a list of tuples [(score, data_item)...] using the key function\n    data_tups = [(key(data_item), data_item) for data_item in data]\n    # Sort the list by the scores\n    sorted_data_tups = sorted(data_tups, reverse=reverse)\n    # Extract the sorted data from the tuples\n    sorted_data = [data_tup[1] for data_tup in sorted_data_tups]\n \n    # Return the sorted data\n    return sorted_data", "def sort_by_second_item(tuples):\n    \"\"\"Sorts a list of tuples by the second item in the tuples.\n    \n    Args:\n        tuples: A list of tuples to be sorted.\n        \n    Returns:\n        sorted_list: The sorted list of tuples.\n    \"\"\"\n    sorted_list = sorted(tuples, key=lambda x: x[1])\n    \n    return sorted_list"]}
{"task_id": 403, "content": ["def get_value(styval_dict, key, default_value):\n    \"\"\"\n    Implement a function that checks if the given key exists in the dictionary and returns the associated value.\n    If the key does not exist, return the default value.\n    \n    Parameters:\n    styval_dict (dict): The input dictionary\n    key: The key to search for in the dictionary\n    default_value: The value to return if the key is not found\n    \n    Returns:\n    The value associated with the key if it exists, otherwise the default value\n    \"\"\"\n    return styval_dict.get(key, default_value)", "def attach_to_process(pid):\n    # This is a placeholder function. In reality, you would need to use a lower-level\n    # library or system call to perform this action, which is not exposed through\n    # the Python standard library.\n    # For example, you might use the libc library to call ptrace()\n    # This is beyond the scope of a simple Python script and would require a\n    # more complex setup and environment.\n    pass", "def verify_divisibility_and_evenness(numbers, divisor):\n    ''' \n    This function accepts a list of numbers and a divisor then \n    verifies whether each number in the list is divisible by the divisor \n    and is even.\n\n    It returns a list of tuples, with each tuple containing a number \n    and a boolean value indicating whether that number satisfies the conditions\n    \n    @param numbers: List of numbers to be checked\n    @param divisor: The divisor to check divisibility\n    '''\n\n    # Validate inputs\n    if not isinstance(numbers, list) or not isinstance(divisor, int):\n        raise ValueError(\"Invalid Input. Only list of numbers and integer divisor are allowed\")\n    \n    return [ (num, num % divisor == 0 and num % 2 == 0) for num in numbers]", "def verify_divisibility_and_evenness(numbers, divisor):\n    ''' \n    This function accepts a list of numbers and a divisor then \n    verifies whether each number in the list is divisible by the divisor \n    and is even.\n\n    It returns a list of tuples, with each tuple containing a number \n    and a boolean value indicating whether that number satisfies the conditions\n    \n    @param numbers: List of numbers to be checked\n    @param divisor: The divisor to check divisibility\n    '''\n\n    # Validate inputs\n    if not isinstance(numbers, list) or not isinstance(divisor, int):\n        raise ValueError(\"Invalid Input. Only list of numbers and integer divisor are allowed\")\n    \n    return [ (num, num % divisor == 0 and num % 2 == 0) for num in numbers]", "def validate_string(seq):\n    # Check length of character sequence\n    if len(seq) < 5 or len(seq) > 20:\n        return False, 'Error: The sequence must be between 5 and 20 characters in length.'\n    \n    # Check if sequence starts with a numeral\n    if seq[0].isdigit():\n        return False, 'Error: The sequence cannot start with a numeric value.'\n    \n    # Check for presence of special characters except underscore\n    if not re.match('^[a-zA-Z0-9_]*$', seq):\n        return False, 'Error: The sequence should not include any special characters except underscore (_).'\n    \n    # Check for at least one uppercase letter\n    if not any(char.isupper() for char in seq):\n        return False, 'Error: At least one letter in the sequence must be capitalized.'\n    \n    # Check for presence of numeric value\n    if not any(char.isdigit() for char in seq):\n        return False, 'Error: The sequence must include at least one numeric value.'\n    \n    # If all checks are passed, return True\n    return True, 'Success: The sequence is valid.'"]}
{"task_id": 404, "content": ["def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers.", "def findCombinations(array, total):\n    \"\"\"\n    This function will find all possible combinations of integers in the given array that sum up to the given total.\n    Args:\n        array (list): List of integers.\n        total (int): Total to be reached with the combination of integers.\n    \n    Returns:\n        A list of lists containing the combinations of integers.\n    \"\"\"\n    combinations = []  # list to store the possible combinations\n    for i in range(1 << len(array)):  # loop through all combinations of bits\n        combination = []  # list to store the current combination\n        for j in range(len(array)):  # loop through array elements\n            if i & (1 << j):  # check if bit is set\n                combination.append(array[j])  # add array element to combination\n        if sum(combination) == total:  # check if combination sums to given total\n            combinations.append(combination)  # add combination to list of combinations\n\n    return combinations", "def apply_function(arr, f):\n    \"\"\"\n    Apply a given function to each item of an input array.\n    \n    Args:\n        arr (list): The input array.\n        f (function): The function to be applied.\n        \n    Returns:\n        list: A list with the result of applying function f to each item of arr.\n    \"\"\"\n    return list(map(f, arr))", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def find_pair(arr, target):\n    \"\"\"\n    Function to find the pair of numbers in an array that sums up to a specific target.\n\n    :param arr: a list of integers\n    :param target: the target sum\n    :return: a list of a pair of numbers or None if no pair exists\n    \"\"\"\n    if len(arr) <= 1:\n        return None\n    my_dict = {}\n    for i in range(len(arr)):\n        # Check if current element already exists in dictionary as a key. If it does, that means we've found a pair\n        if arr[i] in my_dict:\n            return [my_dict[arr[i]], arr[i]]\n        else:\n            my_dict[target - arr[i]] = arr[i]\n    return None"]}
{"task_id": 405, "content": ["def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def avg(arr): \n    n = len(arr)  # calculating the length of the array\n    total_sum = 0  # initializing the sum\n\n    for i in range(0, n):\n        total_sum += arr[i]  # summing all the integers in the array\n  \n    return total_sum / n  # calculating the average by dividing the sum by the number of elements", "def sum_of_digits_in_html(html_snippet):\n    # Extract numbers from the HTML snippet using regular expression\n    numbers = re.findall(r'\\d+', html_snippet)\n    \n    # Calculate the sum of digits for each number and add them together\n    total_sum = sum(sum(int(digit) for digit in number) for number in numbers)\n    \n    return total_sum", "def search_array(num, arr):\n    \"\"\"\n    This function searches for a number in the given array. \n    \n    Input:\n    num: The number to search for\n    arr: The array in which to search\n\n    Output: \n    returns True if the number is found. Otherwise, returns False\n    \"\"\"\n    \n    # iterate through the array\n    for i in range(0, len(arr)):\n        # if the current number equals the number being searched for, \n        # return True because we found the number\n        if arr[i] == num:\n            return True\n    \n    # after searching all elements, if we didn't find the number, return False\n    return False", "def calculateMean(array):\n    # sum up all elements in the array\n    mean = 0\n    for i in range(len(array)):\n        mean += array[i]\n    # calculate the mean by dividing the sum by number of elements\n    mean /= len(array)\n    return mean"]}
{"task_id": 406, "content": ["def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def longest_common_prefix(str_list):\n    ''' This function finds the longest common prefix among the given list of strings.'''\n    str_list.sort()\n    # Get the first string in the list\n    first_str = str_list[0]\n\n    # Find the longest common prefix among the list of strings\n    prefix_len = 0\n    for j in range(len(first_str)):\n        if all([i.startswith(first_str[:j+1]) for i in str_list]):\n            prefix_len = j+1\n    return first_str[:prefix_len]", "def transpose(matrix):\n    # The * operator is used to unzip a list (or other iterables), making a list of tuples where each tuple contains the i-th element from each of the argument sequences or iterables.\n    # The zip() function takes iterables, aggregates them in a tuple, and return the result.\n    # In other words, it returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.\n    return [list(i) for i in zip(*matrix)] ", "def find_smallest_in_arrays(arr1, arr2):\n    \"\"\"\n    Find and return the smallest elements in both arrays in O(nlog(n))\n\n    Parameters\n    ----------\n    arr1 : list\n        First array of integers\n    arr2 : list\n        Second array of integers\n\n    Returns\n    -------\n    int\n        The smallest element common to both arrays\n    \"\"\"\n    # Merge both the arrays\n    merged_arr = [*arr1, *arr2]\n    # Sort the merged array in O(nlog(n))\n    merged_arr.sort()\n\n    # Initialize first_min to the first element of sorted merged array\n    first_min = merged_arr[0]\n    # Initialize second_min to the second element of sorted merged array\n    second_min = merged_arr[1]\n\n    # Check if the first min element is in arr1 and the second min element is in arr2.\n    # If yes, return the first min element.\n    if first_min in arr1 and second_min in arr2:\n        return first_min\n    # Check if the first min element is in arr2 and the second min element is in arr1.\n    # If yes, return the first min element.\n    elif first_min in arr2 and second_min in arr1:\n        return first_min\n    # Else return the second min element\n    else:\n        return second_min", "def intersection(*seqs):\n    # Create a set of the first sequence to use as a reference for comparison\n    reference_set = set(seqs[0])\n    \n    # Iterate through the remaining sequences and find the common elements\n    for seq in seqs[1:]:\n        reference_set = reference_set.intersection(set(seq))\n    \n    # Yield each common element using a generator\n    for element in reference_set:\n        yield element"]}
{"task_id": 407, "content": ["def getSubMaximum(b):\n    # First, we need to check the length of the list.\n    # If the length is less than or equal to 1, it means we don't have a submaximum number.\n    # This is because a submaximum implies having at least 2 distinct numbers.\n    if len(b) <= 1:\n        print('No submaximum number')\n        return\n    \n    # Sort the list in descending order using the sort() function with the reverse parameter set to True.\n    b.sort(reverse=True)\n    \n    # After sorting, we iterate through the list to find a number different from the maximum.\n    # We start the iteration from the second element (index 1) since the first element is the maximum.\n    for i in range(1, len(b)):\n        if b[i] != b[0]:\n            print(b[i])\n            return\n    \n    # If all numbers are equal and we don't have a submaximum, we print the message 'No submaximum number'.\n    print('No submaximum number')", "def find_max(a, b, c):\n    \"\"\"\n    A function to find the maximum of three numbers.\n    \"\"\"\n    # Find the maximum of the three numbers\n    max_value = max(a, b, c)\n    \n    return max_value", "def inject_payload(pid, payload):\n    # This function would need to be implemented to attach to the process,\n    # find the system call table, and modify it to point to the custom handler.\n    # This is a complex task that typically requires kernel-level access and\n    # is beyond the scope of a simple Python script.\n    pass", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min"]}
{"task_id": 408, "content": ["def multiply_with_range(number):\n    \"\"\"Multiply a number with all integers within a range\n    \n    This function takes a single argument, a number (integer), and \n    returns a list. The elements of this list are results of the \n    number multiplied with every integer from 1 to the number itself.\n\n    Args:\n        number (int): the number to be multiplied with all the integers in range\n\n    Returns:\n        list: a list of results from multiplying the number with each integer \n        within the range\n    \"\"\"\n    multiplied_list = [number * i for i in range(1, number + 1)]\n    return multiplied_list", "def multiply_by_two(numbers):\n    \"\"\"\n    Takes a list of numbers as input and returns a new list \n    where each number is multiplied by two.\n    \n    Parameters\n    ----------\n    numbers : list of int\n        A list of numbers\n    \n    Returns\n    -------\n    doubled_list : list of int\n        A list of numbers where each number is multiplied by two.\n    \"\"\"\n    doubled_list = [i * 2 for i in numbers]\n    return doubled_list", "def times_two(list):\n    \"\"\"\n    Takes a list of numbers and returns a list with each number multiplied by 2\n\n    Parameters:\n    list (list): The list of numbers\n\n    Returns:\n    result (list): The list with each number multiplied by 2\n    \"\"\"\n\n    result = []\n\n    for num in list:\n        result.append(num * 2)\n\n    return result", "def calculate_mean(numbers):\n    # Check if the input list is empty\n    if len(numbers) == 0:\n        return 0\n\n    # Calculate the sum of all numbers in the list\n    total_sum = sum(numbers)\n\n    # Calculate the mean by dividing the sum by the total number of elements\n    mean = total_sum / len(numbers)\n\n    # Round the mean to the nearest integer\n    rounded_mean = round(mean)\n\n    return rounded_mean", "def multiply_to_num(number, lst):\n    \"\"\"Takes a number and list as arguments and returns the product of the list multiplied by the given number.\"\"\"\n    result = 1\n    for value in lst:\n        result *= value\n    return result * number"]}
{"task_id": 409, "content": ["def calculate_difference(n):\n    # Calculate the square of the sum of the first n natural numbers\n    square_of_sum = ((n * (n + 1)) // 2) ** 2\n    \n    # Calculate the sum of the squares of the first n natural numbers\n    sum_of_squares = (n * (n + 1) * ((2 * n) + 1)) // 6\n    \n    # Calculate the difference\n    difference = square_of_sum - sum_of_squares\n    \n    return difference", "def triangle_square_sum(n):\n    \"\"\"\n    Function to calculate the sum of the Triangle Series and the sum of the square of each\n    number in the Triangle Series up to n.\n    \"\"\"\n    # error handling: if n is negative or not an integer\n    if not isinstance(n, int) or n < 1:\n        return \"Error: Input must be an positive integer\"\n\n    # calculate the sum of the Triangle Series\n    # formula for the sum of the first n natural numbers is n*(n+1)/2\n    triangle_sum = n * (n + 1) // 2  # use integer division to ensure result is an integer\n\n    # calculate the sum of the square of each number in the Triangle Series up to n.\n    # formula for the sum of the squares of the first n natural numbers is n*(n+1)*(2n+1)/6\n    square_sum = n * (n + 1) * (2 * n + 1) // 6  # use integer division to ensure result is an integer\n\n    return triangle_sum, square_sum", "def sum_of_n_numbers(n):\n    \"\"\"This function will return the sum of n natural numbers.\"\"\"\n    # check if n is 1\n    if n == 1:\n        return 1\n    # Otherwise, recursively call the function\n    else:\n        return n + sum_of_n_numbers(n-1)", "def sum_even_fibonacci(n):\n    # Error handling for incorrect input\n    if type(n) != int or n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n\n    # Initialize first two even prime numbers\n    a, b = 0, 2\n    \n    # Initialize sum of even Fibonacci numbers\n    sum = a + b\n    \n    # Calculating sum of remaining even Fibonacci numbers in the series.\n    for _ in range(3, n + 1, 3):\n        c = 4 * b + a\n        if c > 4000000: # Limit the sum to 4 million as per problem's constraint.\n            break\n        a, b = b, c\n        sum += b\n        \n    return sum", "def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) "]}
{"task_id": 410, "content": ["def transpose(matrix):\n    # The * operator is used to unzip a list (or other iterables), making a list of tuples where each tuple contains the i-th element from each of the argument sequences or iterables.\n    # The zip() function takes iterables, aggregates them in a tuple, and return the result.\n    # In other words, it returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.\n    return [list(i) for i in zip(*matrix)] ", "def wrapper_func(list_of_ints, tuple_of_ints):\n    \"\"\"\n    This function takes a list of integers and a tuple of two integers,\n    It uses the erroneous_slice function on each integer in the list, with the tuple values as the delimiter.\n    The results of each operation are stored in a list and returned.\n    \"\"\"\n    results = []\n    for num in list_of_ints:\n        results.append(erroneous_slice([num], tuple_of_ints[0]))\n        results.append(erroneous_slice([num], tuple_of_ints[1]))\n    return results", "def sorted_list_sum(lst, reverse=False):\n    \"\"\"\n    This function takes as input a list of strings, removes any string that contains a numerical digit or \n    an odd number of characters, sorts remaining strings in ascending order by both length and alphabetically, \n    and then returns the sorted list.\n    \n    Achieves this by using list comprehension to filter out unwanted elements, \n    and Python's built-in sorted function to sort the list. The sorted function uses a compound sorting key \n    consisting of the length of each element and the element itself, allowing for sorting by multiple criteria.\n    \n    The ordering of the sorted list can be reversed by supplying a second argument of True.\n\n    Parameters:\n    lst (list): A list of strings to be filtered and sorted.\n    reverse (bool): Optional parameter to reverse the order of the sorted list. Defaults to False.\n\n    Returns:\n    list: The sorted list of strings.\n    \"\"\"\n    \n    # Filter out any strings containing numerical digits or with odd length\n    lst = [i for i in lst if not any(j.isdigit() for j in i) and len(i) % 2 == 0]\n    \n    # Return the list sorted by length and then alphabetically, in ascending or descending order\n    return sorted(lst, key=lambda x: (len(x), x), reverse=reverse)", "def unique_sets(sets):\n    # Remove duplicates by converting each sub-set to a tuple (which are hashable), \n    # making a set of those (ignores duplicates), then convert each tuple back to list.\n    return [list(x) for x in set(tuple(x) for x in sets)]", "def add_elements(tuple1, set1):\n    # Convert the tuple to a list\n    tuple1 = list(tuple1)\n    \n    # Iterate through each element in the set\n    for element in set1:\n        # If the element is not already in the tuple's list, add it to the beginning\n        if element not in tuple1:\n            tuple1.insert(0, element)\n    \n    # Convert the list back to a tuple\n    tuple1 = tuple(tuple1)\n    \n    return tuple1"]}
{"task_id": 411, "content": ["def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def print_squares_and_cubes_table():\n  # Print top of the table\n  print(\"n\tSquare\tCube\")\n\n  # Print the squares and cubes of natural numbers from 1 to 10\n  for n in range(1, 11):\n    print(n,\"\t\", n*n,\"\t\",n*n*n)", "def calculate_difference(n):\n    # Calculate the square of the sum of the first n natural numbers\n    square_of_sum = ((n * (n + 1)) // 2) ** 2\n    \n    # Calculate the sum of the squares of the first n natural numbers\n    sum_of_squares = (n * (n + 1) * ((2 * n) + 1)) // 6\n    \n    # Calculate the difference\n    difference = square_of_sum - sum_of_squares\n    \n    return difference", "def calculate_average(numbers):\n    '''\n    This function calculates the average of a list of numbers.\n    If the input list is empty, it returns None.\n    '''\n    if not numbers:\n        return None\n    total = sum(numbers)\n    average = total / len(numbers)\n    return average", "def prime_cubed_positions(start, end):\n    \"\"\"Return the cubes of integers within a range [start, end] and\n    the positions of cubed primes in the list.\n    \"\"\"\n    if end < start:\n        return [], []\n\n    # Compute cubes of the integers\n    cubes = [i ** 3 for i in range(start, end+1)]\n\n    # Identify prime numbers among these cubed integers.\n    prime_positions = [i for i, n in enumerate(cubes) if is_prime(n)]\n\n    # Return the cubes and prime_positions.\n    return cubes, prime_positions"]}
{"task_id": 412, "content": ["def get_repeat_info(n: int):\n    # Assume this function is implemented to return is_asc and hashmap as described in the problem.\n    pass", "def optimize(data, constraints):\n    # Solve the optimization problem\n    ...\n\n    # Return the optimized dataset\n    return optimized_data", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass", "def write_ssh_key(name, path, key_type, debug):\n    # Function to write SSH key to a file\n    pass"]}
{"task_id": 413, "content": ["def transpose(matrix):\n    # The * operator is used to unzip a list (or other iterables), making a list of tuples where each tuple contains the i-th element from each of the argument sequences or iterables.\n    # The zip() function takes iterables, aggregates them in a tuple, and return the result.\n    # In other words, it returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.\n    return [list(i) for i in zip(*matrix)] ", "def find_index_of_first_occurrence(string, character):\n    '''\n    This function will find the index of the first occurrence of a given character in a string.\n\n    Args:\n        string (str): the string to be searched\n        character (str): the character to be searched for\n\n    Returns:\n        int: the index of the first occurrence of the character\n    '''\n    return string.find(character)", "def linear_search(lst, target):\n    \"\"\"\n    This function implements the linear search algorithm to find the target value in the given list.\n    It returns the index of the target value if found, or -1 if the target value is not present.\n    \"\"\"\n    for index, element in enumerate(lst):\n        if element == target:\n            return index\n    return -1", "def revised_function(input_tuple):\n    # Checks if the tuple is None or empty \n    if not input_tuple:\n        return \"Error: input is NULL or empty.\"\n\n    # Initiating an empty list to hold string representations of the float values\n    str_list = []\n\n    # Iterate over the elements in the tuple\n    for element in input_tuple:\n        # Confirm that each element is a float. If not, return an error message.\n        if not isinstance(element, float):\n            return \"Error: all elements in the tuple should be floats.\"\n            \n        # Convert the float to a string and append to the list\n        str_list.append(str(element))\n    \n    # Join all elements in the list with a semicolon\n    result = \"; \".join(str_list)\n    \n    return result", "def validate_input_sequence(input_sequence):\n    # Convert the sequence to a list\n    list_sequence = list(input_sequence)\n\n    # Iterate over each element in the list\n    for element in list_sequence:\n\n        # Split the element into a list of characters\n        list_characters = list(element)\n\n        # Iterate over each character in the element\n        for character in list_characters:\n\n            # Check if the character is an alphabet\n            if not character.isalpha():\n                print(\"Invalid input. The sequence should only contain alphabets.\")\n                return False\n    print(\"Valid input. The sequence only contains alphabets.\")\n    return True"]}
{"task_id": 414, "content": ["def count_arguments(*args, **kwargs):\n    \"\"\"\n    Returns a dictionary containing the count of each argument type.\n\n    Args:\n    *args: Variable number of positional arguments.\n    **kwargs: Variable number of keyword arguments.\n\n    Returns:\n    A dictionary containing the count of each argument type.\n    \"\"\"\n    argument_counts = {'positional': len(args), 'keyword': len(kwargs)}\n    return argument_counts", "def sigmoidGradient(z):\n    \"\"\"Computes the gradient of the sigmoid function evaluated at z.\n    This should work regardless if z is a matrix or a vector.\n    In particular, if z is a vector or matrix, you should return\n    the gradient for each element.\"\"\"\n    sig_z = sigmoid(z)\n    return sig_z * (1 - sig_z)", "def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list", "def prevalence_ratio(lexeme, strings):\n    \"\"\"\n    This function returns the prevalence ratio of a particular lexeme \n    within an assortment of string constants.\n\n    Args:\n    lexeme (str): The target lexeme to find\n    strings (list): The string assortment to search through\n\n    Returns:\n    float: The prevalence ratio of the lexeme in the strings \n    \"\"\"\n\n    # count the total number of occurrences of the lexeme\n    count = sum(s.count(lexeme) for s in strings)\n\n    # calculate the total number of words in the strings\n    total = sum(len(s.split()) for s in strings)\n\n    # calculate the prevalence ratio\n    ratio = count / total if total != 0 else 0\n\n    return ratio", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count"]}
{"task_id": 415, "content": ["def sum_even_numbers(numbers: list) -> int:\n    # Filter out the odd numbers from the list using the filter function\n    even_numbers = list(filter(lambda x: x % 2 == 0, numbers))\n    \n    # Use the reduce function from the functools module to sum the even numbers\n    from functools import reduce\n    return reduce(lambda x, y: x + y, even_numbers, 0)", "def sum_odd_numbers(numbers):\n    # Use a generator expression and filter() to generate a sequence of odd numbers\n    odd_numbers = filter(lambda x: x % 2 != 0, numbers)\n    # Use reduce() to calculate the sum of the odd numbers\n    sum_of_odd_numbers = reduce(lambda x, y: x + y, odd_numbers, 0)\n    return sum_of_odd_numbers", "def extract_odd_elements(array, unique=False):\n    # Error handling for invalid inputs\n    if not isinstance(array, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    for element in array:\n        if not isinstance(element, int):\n            raise ValueError(\"Elements of the list must be integers.\")\n\n    # Using built-in function to filter the array\n    odd_elements = list(filter(lambda x: x%2 == 1, array))\n\n    if unique:\n        # Using built-in function to remove duplicates\n        odd_elements = list(set(odd_elements))\n    return odd_elements", "def compute_sum_of_even_numbers(numbers):\n    # Filter out the even numbers from the input list using a list comprehension\n    even_numbers = [num for num in numbers if num % 2 == 0]\n    \n    # Compute the sum of the filtered even numbers using the built-in sum() function\n    sum_of_even_numbers = sum(even_numbers)\n    \n    return sum_of_even_numbers", "def delete_idle_lambda(region_name):\n    \"\"\"\n    This function deletes idle AWS Lambda functions in a particular region.\n    :param region_name: str\n    :return: None\n    \"\"\"\n    # Create a session using boto3\n    session = boto3.Session(region_name=region_name)\n\n    # Connect to AWS Lambda service\n    lambda_client = session.client('lambda')\n\n    try:\n        # Get the list of all functions\n        functions = lambda_client.list_functions()\n\n        # Loop through each function\n        for function in functions['Functions']:\n            function_name = function['FunctionName']\n\n            # Here, we need to determine if the function is idle\n            # If the function is idle, we delete it\n            # Please replace `is_function_idle` with your actual check\n            if is_function_idle(function):\n                lambda_client.delete_function(FunctionName=function_name)\n                print(f\"Deleted function: {function_name}\")\n\n    except NoCredentialsError:\n        print(\"No AWS credentials were found.\")\n    except ClientError as e:\n        if e.response['Error']['Code'] == 'ResourceNotFoundException':\n            print(\"The specified lambda function does not exist.\")\n        else:\n            raise e"]}
{"task_id": 416, "content": ["def convert_date_format(date_string):\n    # Parse the input date string in the format MM/DD/YYYY\n    date = datetime.strptime(date_string, \"%m/%d/%Y\")\n    \n    # Convert the date to the desired format DD-MM-YYYY\n    converted_date = date.strftime(\"%d-%m-%Y\")\n    \n    return converted_date", "def recognize_date(s):\n    '''This function recognizes a date (in DD/MM/YYYY format) in a string.'''\n    # Regex for DD/MM/YYYY format\n    format_regex = re.compile(r'\\d{2}/\\d{2}/\\d{4}') \n    match = format_regex.search(s)\n    if match:\n        date = match.group()\n        return date\n    else:\n        return None", "def day_of_week(date):\n    try:\n        dt = datetime.strptime(date, '%Y-%m-%d')\n        return dt.strftime('%A')\n    except ValueError:\n        return 'Invalid date. Please use the correct format (YYYY-MM-DD) and a valid date.'", "def day_of_week(date):\n    try:\n        dt = datetime.strptime(date, '%Y-%m-%d')\n        return dt.strftime('%A')\n    except ValueError:\n        return 'Invalid date. Please use the correct format (YYYY-MM-DD) and a valid date.'", "def validate_date(date_string):\n    try:\n        return datetime.datetime.strptime(date_string, '%Y-%m-%d')\n    except ValueError:\n        raise ValueError(\"Invalid date format: Date must be in YYYY-MM-DD format.\")"]}
{"task_id": 417, "content": ["def sort_array(arr, col_idx, ascending=True):\n    \"\"\"\n    Sorts a two-dimensional array based on a specific column index.\n    :param arr: The array to be sorted.\n    :param col_idx: The index of the column to sort by.\n    :param ascending: Whether to sort in ascending (True) or descending (False) order.\n    :return: The sorted array.\n    \"\"\"\n    # Get the column to sort by\n    col = arr[:, col_idx]\n    \n    # Handle NaN and infinite values\n    col[np.isnan(col)] = np.inf\n    col[np.isinf(col)] = np.nan\n    \n    # Sort the column and get the sorting indices\n    sorted_indices = np.argsort(col)\n    \n    # Reverse the sorting indices if descending order is specified\n    if not ascending:\n        sorted_indices = sorted_indices[::-1]\n    \n    # Sort the array using the sorting indices\n    sorted_arr = arr[sorted_indices]\n    \n    return sorted_arr", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass", "def anti_shuffle(s):\n    \"\"\"\n    Function that accepts a string and produces an ordered variant using the custom sort function.\n    The ordered variant of a string is a new phrase where every word (partitioned by space)\n    is replaced by a new word where every character adheres to the custom sort methodology.\n    The word and blank space sequence in the sentence remains unchanged.\n\n    Args:\n    s: String\n\n    Returns:\n    The modified string with each word sorted according to the rules of custom_sort\n    \"\"\"\n\n    sorted_words = [custom_sort(word) for word in s.split(\" \")]\n    return ' '.join(sorted_words)", "def sort_elements(array, cond_fn):\n    return sorted(array, key=cond_fn) # Sort by the condition function", "def sortByLength(strings):\n    \"\"\"Sort a list of strings according to their lengths\"\"\"\n    # Sort the list using a key function\n    return sorted(strings, key=len)"]}
{"task_id": 418, "content": ["def sort_by_second_item(tuples):\n    \"\"\"Sorts a list of tuples by the second item in the tuples.\n    \n    Args:\n        tuples: A list of tuples to be sorted.\n        \n    Returns:\n        sorted_list: The sorted list of tuples.\n    \"\"\"\n    sorted_list = sorted(tuples, key=lambda x: x[1])\n    \n    return sorted_list", "def assign_unique_random_values(input_list):\n    n = len(input_list)\n    \n    # Assign random values to each item in the list\n    random_values = random.sample(range(1, 101), n)\n    \n    # Create a list of tuples containing the original values and random values\n    tuples = [(input_list[i], random_values[i]) for i in range(n)]\n    \n    # Sort the list of tuples based on the random values\n    sorted_tuples = sorted(tuples, key=lambda x: x[1])\n    \n    # Extract the original values from the sorted tuples and return the result\n    return [t[0] for t in sorted_tuples]", "def sort_list(tuples):\n    \"\"\"\n    A function to sort a list of tuples by the second item in each tuple.\n    \"\"\"\n    return sorted(tuples, key=lambda x: x[1])", "def transpose(matrix):\n    # The * operator is used to unzip a list (or other iterables), making a list of tuples where each tuple contains the i-th element from each of the argument sequences or iterables.\n    # The zip() function takes iterables, aggregates them in a tuple, and return the result.\n    # In other words, it returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.\n    return [list(i) for i in zip(*matrix)] ", "def sort_data(data, key, reverse=False):\n    '''\n    Function to sort data by a custom criteria.\n\n    Parameters\n    ----------\n    data: list\n        List of objects that need to be sorted.\n    key: function\n        A function that maps the objects in the data to the score that will be used for sorting.\n    reverse: boolean, optional\n        If True, the data will be sorted in reverse order.\n\n    Returns\n    ----------\n    sorted_data: list\n        The sorted list.\n    '''\n\n    # Create a list of tuples [(score, data_item)...] using the key function\n    data_tups = [(key(data_item), data_item) for data_item in data]\n    # Sort the list by the scores\n    sorted_data_tups = sorted(data_tups, reverse=reverse)\n    # Extract the sorted data from the tuples\n    sorted_data = [data_tup[1] for data_tup in sorted_data_tups]\n \n    # Return the sorted data\n    return sorted_data"]}
{"task_id": 419, "content": ["def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass", "def find_rop_gadgets(base_address):\n    # This function would use a database of known ROP gadgets or a tool like ROPgadget to find gadgets.\n    gadgets = []\n    # Code to find ROP gadgets goes here\n    return gadgets", "def inorder_traversal(root):\n    \"\"\"Write a function to traverse a binary search tree in-order, printing out the values it encounters.\n\n    :param root: The root node of the binary search tree\n    \"\"\"\n    if not root:\n        return\n\n    inorder_traversal(root.left)\n    print(root.val)\n    inorder_traversal(root.right)", "def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass"]}
{"task_id": 420, "content": ["def are_equal(a, b):\n    '''This function takes two numbers and returns True if they are equal and False if they are not.'''\n    if a == b:\n        return True\n    else:\n        return False", "def two_word_strings(input_list):\n    \"\"\"This function takes a list of strings and returns only the strings with at least two words.\"\"\"\n    output_list = []\n    \n    # Iterate over the list and append all strings with at least two words\n    for item in input_list:\n        if len(item.split()) >= 2:\n            output_list.append(item)\n    \n    return output_list", "def lcm(a, b):\n    \"\"\"\n    This function takes two integers and returns their least common multiple.\n    \"\"\"\n    greater = max(a, b)\n    while True:\n        if greater % a == 0 and greater % b == 0:\n            lcm = greater\n            break\n        greater += 1\n    return lcm", "def verify_password(password):\n    if len(password) < 8:\n        return \"Password length should be at least 8\"\n    if not any(char.isdigit() for char in password):\n        return \"Password should have at least one numeral\"\n    if not any(char.isalpha() for char in password):\n        return \"Password should have at least one letter\"\n    if not any(char.isupper() for char in password):\n        return \"Password should have at least one uppercase letter\"\n    if not any(char.islower() for char in password):\n        return \"Password should have at least one lowercase letter\"\n    if \" \" in password:\n        return \"Password may not contain spaces\"\n    if not any(char in string.punctuation for char in password):\n        return \"Password should have at least one of the symbols $@#\"\n    if has_consecutive_characters(password):\n        return \"Password cannot have more than two consecutive repeating characters\"\n    if has_common_patterns(password):\n        return \"Password cannot have common patterns such as '123', 'abc', 'xyz'\"\n    return \"Password is valid\"", "def is_valid_password(pwd):\n    if len(pwd) < 6:\n        print(\"Password must be at least 6 characters long.\")\n        return False\n\n    if not any(char.isdigit() for char in pwd):\n        print(\"Password must have at least one number.\")\n        return False\n\n    if not any(char.isupper() for char in pwd):\n        print(\"Password must have at least one uppercase letter.\")\n        return False\n\n    if not any(char.islower() for char in pwd):\n        print(\"Password must have at least one lowercase letter.\")\n        return False\n\n    return True"]}
{"task_id": 421, "content": ["def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass", "def median(arr):\n    '''\n    Function to find the median of an array of integer numbers\n    '''\n    # Sort the array\n    arr.sort()\n    \n    # Compute median\n    n = len(arr)\n    if n % 2 == 0:\n        median = (arr[int(n/2)] + arr[int(n/2)-1]) / 2\n    else:\n        median = arr[int(n/2)]\n\n    # Return the median\n    return median", "def find_rop_gadgets(base_address):\n    # This function would use a database of known ROP gadgets or a tool like ROPgadget to find gadgets.\n    gadgets = []\n    # Code to find ROP gadgets goes here\n    return gadgets", "def inorder_traversal(root):\n    \"\"\"Write a function to traverse a binary search tree in-order, printing out the values it encounters.\n\n    :param root: The root node of the binary search tree\n    \"\"\"\n    if not root:\n        return\n\n    inorder_traversal(root.left)\n    print(root.val)\n    inorder_traversal(root.right)", "def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) "]}
{"task_id": 422, "content": ["def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True", "def extract_integer(number: float) -> int:\n    \"\"\"\n    A floating-point number can be bifurcated into an integer part (the largest integer no greater\n    than the input number) and a fraction part (the residual fragment, persistently less than 1 \n    but more than -1). \n\n    Architect this function in such a way that it unravels the integer sector of a number, whether \n    it is positive or negative.\n    \"\"\"\n    return math.floor(number)", "def extract_integer(number: float) -> int:\n    \"\"\"\n    A floating-point number can be bifurcated into an integer part (the largest integer no greater\n    than the input number) and a fraction part (the residual fragment, persistently less than 1 \n    but more than -1). \n\n    Architect this function in such a way that it unravels the integer sector of a number, whether \n    it is positive or negative.\n    \"\"\"\n    return math.floor(number)", "def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers.", "def find_second_third_least(arr):\n    # check if the number of elements less than 3\n    if len(arr) < 3:\n        return \"The given array does not have enough elements\"\n    \n    # sort the array in ascending order\n    sorted_array = sorted(arr)\n    \n    # remove duplicates\n    unique_array = list(set(sorted_array))\n    \n    # check if the number of unique elements less than 3\n    if len(unique_array) < 3:\n        return \"The given array does not have enough unique elements\"\n    \n    # return the second and third elements as they are second and third least now\n    return unique_array[1], unique_array[2]"]}
{"task_id": 423, "content": ["def match_hex_vowel(string):\n    # The regexp starts with \\b to match the start of a word\n    # Following that, [0-9A-Fa-f]+ matches one or more hexadecimal digits\n    # After that, [aeiou] matches a single lowercase English vowel\n    # Finally, \\b matches the end of a word to avoid partial word matches \n    pattern = r'\\b[0-9A-Fa-f]+[aeiou]\\b'\n    return re.match(pattern, string) is not None", "def match_hex_vowel(string):\n    # The regexp starts with \\b to match the start of a word\n    # Following that, [0-9A-Fa-f]+ matches one or more hexadecimal digits\n    # After that, [aeiou] matches a single lowercase English vowel\n    # Finally, \\b matches the end of a word to avoid partial word matches \n    pattern = r'\\b[0-9A-Fa-f]+[aeiou]\\b'\n    return re.match(pattern, string) is not None", "def check_text(text):\n    # Find all words that appear more than 3 times in a row\n    matches = re.findall(r'\\b(\\w+)\\b(?:\\s+\\1){2,}', text, re.IGNORECASE)\n    # Find all letters that appear only once in the entire text\n    unique_letters = set(filter(lambda x: text.count(x) == 1, set(text)))\n    # Check if there's a word that appears more than 3 times in a row and has at least one unique letter\n    for word in matches:\n        if any(letter in unique_letters for letter in word):\n            return True\n    return False", "def copy_stream(input_stream, output_stream, buffer_size=1024*1024):\n    \"\"\"\n    Copy one stream to another.\n\n    input_stream: a file-like object that has a `read` method.\n    output_stream: a file-like object that has a `write` method.\n    buffer_size: the size of the chunks to read and write.\n    \"\"\"\n    while True:\n        data = input_stream.read(buffer_size)\n        if not data:\n            break\n        output_stream.write(data)", "def check_anagram_segments(text: str) -> bool:\n    \"\"\"\n    Given an input string, the function is intended to determine whether it is possible to \n    divide the string into two or more segments that are anagrams of one another. \n\n    Anagrams are words or phrases formed by reordering the letters of a different word or phrase, \n    typically using all the original letters exactly once.\n\n    The function counts the frequency of each unique character in the string and stores it in a dictionary. \n    If all frequencies are even number then the function returns True as the string can be divided into \n    two or more segments that are anagrams of one another. \n    \n    But if there is more than one character with an odd count frequency, then the function returns False\n    as it is not possible to divide the string into segments that are anagrams of one another. \n\n    Parameters:\n    text (str): The string to check for anagram segments\n\n    Returns:\n    bool: True if the string can be divided into anagram segments, False otherwise.\n\n    Examples:\n    \n    >>> check_anagram_samples('abcdefabcdegf')\n    True\n    >>> check_anagram_samples('helloworld')\n    False\n    \"\"\"\n\n    # count the frequency of each unique character in the string\n    frequency = {}\n    for char in text:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n\n    # count characters with odd count frequency\n    count_odd = sum(1 for count in frequency.values() if count % 2)\n\n    return count_odd <= 1"]}
{"task_id": 424, "content": ["def decimal_to_binary(num):\n    \"\"\"\n    Converts a given number in decimal form to binary\n    Parameters:\n    num : Integer in decimal form\n    Returns:\n    Binary form of the given number\n    \"\"\"\n    # Initialize the binary number\n    binary_number = 0\n    \n    # Initialize the base\n    base = 1\n    \n    while num > 0:\n        # Get the last digit of the given number\n        last_digit = num % 2\n    \n        # Add this digit to the binary number\n        binary_number += last_digit * base\n        \n        num //= 2 # Divide the number by 2\n        base *= 10 # Multiply the base by 10\n    \n    return binary_number ", "def calculateDigitSum(number):\n    # Initialize sum to 0\n    digit_sum = 0\n    \n    # Iterate through each digit of the number\n    while number > 0:\n        # Extract the last digit\n        digit = number % 10\n        # Add the digit to the sum\n        digit_sum += digit\n        # Remove the last digit from the number\n        number = number // 10\n    \n    return digit_sum", "def last_element(list):\n    \"\"\"Find the last element of a given list.\"\"\"\n    return list[-1]", "def inject_payload(pid, payload):\n    # This function would need to be implemented to attach to the process,\n    # find the system call table, and modify it to point to the custom handler.\n    # This is a complex task that typically requires kernel-level access and\n    # is beyond the scope of a simple Python script.\n    pass", "def calculate_sum_of_digits(number):\n    cumulative_sum = 0\n    while number > 0:\n        cumulative_sum += (number % 10) # add the last digit of the number to the cumulative sum\n        number //= 10 # truncate the last digit of the number\n    return cumulative_sum"]}
{"task_id": 425, "content": ["def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass", "def factorial_lst(lst):\n    if not isinstance(lst, list):\n        raise TypeError(\"Invalid data type. Input must be a list.\")\n        \n    for i in lst:\n        if not isinstance(i, int):\n            raise TypeError(\"Invalid data type in list. List must contains integers only.\")\n        if i < 0:\n            raise ValueError(\"Invalid value in list. Factorial is not defined for negative numbers.\")\n        if i > 170:\n            raise OverflowError(\"Number too large. Python's math library supports factorials of numbers up to 170 only.\")\n            \n    return [math.factorial(i) for i in lst]", "def rolling_max(arr):\n    \"\"\"\n    This function takes an array of positive integers and\n    returns a new array where each element from index 0 to \n    n is the maximum element from the original array from\n    index 0 to n.\n\n    If there's a negative number in the array, the function returns an empty list.\n    \n    Args:\n        arr (List[int]): a list of integers.\n\n    Returns:\n        List[int]: a list of maximum numbers. \n        If input list contains negative number, an empty list is returned\n    \"\"\"\n    \n    max_num = float('-inf')\n    result = []\n    \n    for number in arr:\n        if number < 0:\n            return []\n        max_num = max(number, max_num)\n        result.append(max_num)\n        \n    return result", "def remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Facilitate the de-duplication of a sequence of integers, eliminating any references that occur more than once.\n    Retains the exact sequence of remaining integers mirroring the original provided sequence.\n    Time complexity: O(n)\n    Space complexity: O(1)\n    \"\"\"\n    write = 1\n    for read in range(1, len(numbers)):\n        if numbers[read] != numbers[read-1]:\n            numbers[write] = numbers[read]\n            write += 1\n    return numbers[:write]   # cutting the array to length 'write'"]}
{"task_id": 426, "content": ["def remove_duplicates_from_string(string):\n    '''This function will remove duplicates of characters in a given string'''\n    result = ''\n    for char in string:\n        if char not in result:\n            result += char\n    return result", "def reverse_string(string):\n  '''\n  This function takes in a string and returns the string in reverse order.\n  \n  The algorithm works by iterating over the characters in the string in reverse, creating a new string with the reverse order of characters.\n  \n  :param string: string to be reversed\n  :return: string in reverse order\n  '''\n  \n  # Create a new, empty string to store the reversed string\n  reversed_string = \"\"\n  \n  # Iterate over the characters in the string in reverse order\n  for i in range(len(string)-1, -1, -1):\n    reversed_string += string[i]\n  \n  # Return the reversed string\n  return reversed_string", "def can_form_palindrome(string):\n    # Create a count array to store count of characters\n    count_map = [0]*256  # Assuming ASCII characters\n \n    # Traverse through given string and increment\n    # count of characters in count_map.\n    for char in string:\n        count_map[ord(char)] += 1\n \n    # Count odd occurring characters\n    odd_count = 0\n    for count in count_map:\n        if count % 2 != 0:\n            odd_count += 1\n    \n    # Return true if the count of odd occurrences is less than or equal to 1.\n    return odd_count <= 1", "def remove_odd_index_char(string):\n    \"\"\"\n    Remove the characters of odd index in a given string\n    \"\"\"\n    result = \"\"\n    for i in range(len(string)):\n        if i % 2 == 0:\n            result = result + string[i]\n    return result", "def removeDuplicates(string): \n    # Create a regular expression pattern to match and remove duplicate characters\n    regx = re.compile('(.)(?=.*\\1)') \n    # Use the sub() function to replace all the occurrences of duplicate characters with an empty string\n    return regx.sub(\"\", string)"]}
{"task_id": 427, "content": ["def count_unique_pairs(nums, target):\n    \n    pairs = []\n    n = len(nums)\n    \n    # This 'for' loop checks each number with every other number in the list to find pairs.\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] + nums[j]) == target:\n                pair = sorted([nums[i], nums[j]])\n                if pair not in pairs:\n                    pairs.append(pair)\n    \n    count = len(pairs)\n    \n    # Convert pairs from lists to tuples.\n    pairs = [tuple(p) for p in pairs]\n    \n    return count, pairs", "def make_pairs(list_of_numbers):\n    \"\"\" \n    Creates a list of tuple pairs from a list of numbers given.\n    \n    Arguments:\n        list_of_numbers - A list of ordered or unordered integers\n        \n    Returns:\n        A list of tuple pairs\n    \"\"\"\n    pairs = []\n    for i in range(len(list_of_numbers) - 1):\n        pairs.append((list_of_numbers[i], list_of_numbers[i + 1]))\n    \n    return pairs", "def count_occurrences(element, tuple_input):\n    \"\"\"A function to count occurrences of an element in a (nested) tuple\"\"\"\n    count = 0\n    for i in tuple_input:\n        if isinstance(i, tuple):\n            count += count_occurrences(element, i)\n        else:\n            if i == element:\n                count += 1\n    return count", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass"]}
{"task_id": 428, "content": ["def multiply_with_range(number):\n    \"\"\"Multiply a number with all integers within a range\n    \n    This function takes a single argument, a number (integer), and \n    returns a list. The elements of this list are results of the \n    number multiplied with every integer from 1 to the number itself.\n\n    Args:\n        number (int): the number to be multiplied with all the integers in range\n\n    Returns:\n        list: a list of results from multiplying the number with each integer \n        within the range\n    \"\"\"\n    multiplied_list = [number * i for i in range(1, number + 1)]\n    return multiplied_list", "def remove_max_num(str_nums):\n    # Split the string into a list of strings\n    list_nums = str_nums.split(\", \")\n\n    # Convert each string in the list to an integer\n    list_nums = [int(num) for num in list_nums]\n\n    # Find the maximum number in the list\n    max_num = max(list_nums)\n\n    # Remove the maximum number from the list\n    list_nums.remove(max_num)\n\n    # Convert the list of integers back into a list of strings\n    list_nums = [str(num) for num in list_nums]\n\n    # Join the list of strings into a single string with comma delimiters\n    str_nums = \", \".join(list_nums)\n\n    return str_nums", "def remove_max_num(str_nums):\n    # Split the string into a list of strings\n    list_nums = str_nums.split(\", \")\n\n    # Convert each string in the list to an integer\n    list_nums = [int(num) for num in list_nums]\n\n    # Find the maximum number in the list\n    max_num = max(list_nums)\n\n    # Remove the maximum number from the list\n    list_nums.remove(max_num)\n\n    # Convert the list of integers back into a list of strings\n    list_nums = [str(num) for num in list_nums]\n\n    # Join the list of strings into a single string with comma delimiters\n    str_nums = \", \".join(list_nums)\n\n    return str_nums", "def filter_numbers(numbers, func_filter):\n    \"\"\"\n    Filters a list of integers based on the given condition.\n\n    Args:\n    numbers: A list of integers to be filtered.\n    func_filter: A filtering function that accepts an integer and returns a boolean value.\n\n    Returns:\n    A new list containing only the integers that satisfy the filtering condition.\n    \"\"\"\n    filtered_numbers = [num for num in numbers if func_filter(num)]\n    return filtered_numbers", "def multiply_three_numbers(a, b, c):\n    # Exception handling for non-integer inputs\n    try:\n        # The int() function attempts to convert the input into an integer.\n        # If this fails, a ValueError exception is raised, which we handle below.\n        a = int(a)\n        b = int(b)\n        c = int(c)\n\n        # If the conversion to integer went well, return the product of the numbers.\n        return a * b * c\n\n    except ValueError:\n        return \"All inputs must be integers.\""]}
{"task_id": 429, "content": ["def replace_vowels(sentence):\n    \"\"\"This function replaces all the vowels in a given sentence with an asterisk (*).\n\n    Args:\n        sentence (str): The sentence to process.\n    \n    Returns:\n        str: The sentence with all the vowels replaced by asterisks.\n\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    output = [char if char not in vowels else '*' for char in sentence]\n    return ''.join(output)", "def rearrange_sentence(sentence, lexicon):\n    # Split the sentence string into a list of words\n    sentence = sentence.split(\" \") \n    \n    # Prepare a map of words to their corresponding indices in the lexicon.\n    word_index_map = {word: index for index, word in enumerate(lexicon)}\n    \n    # Filter the sentence words that exist in the lexicon.\n    sentence = [word for word in sentence if word in word_index_map]\n    \n    # Sort the sentence words based on their indices in the lexicon.\n    sentence.sort(key=lambda word: word_index_map[word])\n    \n    # Join the sorted words to obtain the rearranged sentence.\n    rearranged_sentence = \" \".join(sentence)\n    \n    return rearranged_sentence", "def find_palindromes(sentence):\n    \"\"\"Find all palindrome words in a sentence.\n    Ignores case, punctuation, and spacing.\n    \"\"\"\n    words = re.findall(r'\\b\\w+\\b', sentence)\n    return [word for word in words if is_palindrome(word)]", "def differential_cryptanalysis(ciphertext_pairs):\n    # Analyze the differences between plaintext pairs and their corresponding ciphertext pairs\n    # to deduce patterns in the key schedule.\n    # This function would use statistical analysis and heuristic methods to find patterns.\n    # For simplicity, let's assume we have a function that returns a list of differential pairs\n    # and their corresponding difference after the first round of the cipher.\n    differential_pairs = get_differential_pairs(ciphertext_pairs)\n    \n    # Now we need to analyze the differences and find patterns that can be used to guess the key.\n    # This would involve looking for correlations between the differences and the key schedule parameters.\n    # For example, if certain differences consistently result in certain key schedule parameters,\n    # we could make educated guesses about the key.\n    key_schedule_guesses = analyze_differential_patterns(differential_pairs)\n    \n    return key_schedule_guesses", "def compute_average_word_length(sentence):\n    \"\"\"\n    This function will compute the average word length of a given sentence.\n    \n    Args:\n        sentence (str): A sentence.\n    \n    Returns:\n        float: The average word length of the given sentence.\n    \"\"\"\n\n    words = sentence.split()\n    total_length = 0\n    for word in words:\n        total_length += len(word)\n    return total_length / len(words)"]}
{"task_id": 430, "content": ["def cube_surface_area(side):\n    \"\"\" \n    Calculate and return the total surface area of a cube \n    given the side length.\n    \"\"\"\n    return 6 * side**2", "def find_surface_area(length, breadth, height):\n    '''\n    This function calculates the surface area of a cuboid.\n    Input: length, breadth, height - these are the three dimensions of the cuboid\n    Output: total surface area of the cuboid \n    '''\n    # Formula of Surface Area of Cuboid = 2(lb + bh + hl)\n    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area", "def find_surface_area(length, breadth, height):\n    '''\n    This function calculates the surface area of a cuboid.\n    Input: length, breadth, height - these are the three dimensions of the cuboid\n    Output: total surface area of the cuboid \n    '''\n    # Formula of Surface Area of Cuboid = 2(lb + bh + hl)\n    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area", "def cube_surface_area(side_length):\n    # Calculate the area of one face of the cube\n    face_area = side_length * side_length\n    \n    # Calculate the surface area by multiplying the face area by 6\n    surface_area = face_area << 2 + face_area << 1\n    \n    return surface_area", "def solve_cube(cube):\n    # Main function that solves a Rubik's cube\n    # cube: list representing a Rubik's cube\n\n    # Determine cube state by analyzing the cube[i][j][k] values\n    scramble_state = analyze_cube(cube)\n\n    # Find the sequence of moves required to solve the cube[i][j][k]\n    moves = get_solve_moves(scramble_state)\n\n    # Execute moves to solve the cube[i][j][k]\n    execute_moves(cube, moves)"]}
{"task_id": 431, "content": ["def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers.", "def calculate_mean(numbers):\n    \"\"\"Function to find the mean of an array of integers.\"\"\"\n    mean = (sum(numbers)) / len(numbers)\n    return mean", "def get_positive_numbers(arr):\n    \"\"\"\n    This function takes an array of numbers and returns a new array that contains only the positive numbers from the original array.\n    :param arr: array of numbers\n    :return: array of positive numbers\n    \"\"\"\n    return [num for num in arr if num > 0]", "def array_sum(numbers):\n    '''\n    This function calculates the sum of an array of integers.\n    \n    Args:\n        numbers (list): the array of numbers\n\n    Returns:\n        int: the sum of the numbers in the array\n    '''\n    return sum(numbers)", "def rolling_max(arr):\n    \"\"\"\n    This function takes an array of positive integers and\n    returns a new array where each element from index 0 to \n    n is the maximum element from the original array from\n    index 0 to n.\n\n    If there's a negative number in the array, the function returns an empty list.\n    \n    Args:\n        arr (List[int]): a list of integers.\n\n    Returns:\n        List[int]: a list of maximum numbers. \n        If input list contains negative number, an empty list is returned\n    \"\"\"\n    \n    max_num = float('-inf')\n    result = []\n    \n    for number in arr:\n        if number < 0:\n            return []\n        max_num = max(number, max_num)\n        result.append(max_num)\n        \n    return result"]}
{"task_id": 432, "content": ["def find_largest_number(numbers):\n    # Finds the largest number from the given list\n    largest = 0\n    for num in numbers:\n        if num > largest:\n            largest = num\n    return largest", "def rolling_max(arr):\n    \"\"\"\n    This function takes an array of positive integers and\n    returns a new array where each element from index 0 to \n    n is the maximum element from the original array from\n    index 0 to n.\n\n    If there's a negative number in the array, the function returns an empty list.\n    \n    Args:\n        arr (List[int]): a list of integers.\n\n    Returns:\n        List[int]: a list of maximum numbers. \n        If input list contains negative number, an empty list is returned\n    \"\"\"\n    \n    max_num = float('-inf')\n    result = []\n    \n    for number in arr:\n        if number < 0:\n            return []\n        max_num = max(number, max_num)\n        result.append(max_num)\n        \n    return result", "def findLargest(nums):\n    # Initialize the largest number as the first element of the list\n    largest = nums[0]\n    \n    # Iterate through the list to find the largest number\n    for num in nums:\n        if num > largest:\n            largest = num\n    \n    # Return the largest number\n    return largest", "def second_largest_even(l: list):\n    \"\"\"Should return the second largest even number in the list.\n    \"\"\"\n    # initialize two variables for largest and second largest\n    largest = second_largest = float('-inf')\n    \n    for num in l:\n        # we want to ignore negative numbers\n        if num < 0:\n            continue\n        # we only want even numbers\n        if num % 2 != 0:\n            continue\n        # update largest and second largest when we find a larger even number\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n\n    # If second_largest didn't change from initialization, there was no second largest number\n    if second_largest == float('-inf'):\n        return None\n    else: \n        return second_largest", "def find_num(input_list):\n    \"\"\"Finds the largest and smallest number from a given list of numbers.\"\"\"\n    max_num = max(input_list)\n    min_num = min(input_list)\n    return max_num, min_num"]}
{"task_id": 433, "content": ["def list_to_set(data):\n    \"\"\"\n    Function to convert a list to a set; managing nested lists and converting them to nested sets.\n    \"\"\"\n    # If data is a list convert each item in the list to a set recursively\n    if isinstance(data, list):\n        return set(list_to_set(item) for item in data)\n\n    # If data is a set convert each item in the set to a set recursively\n    elif isinstance(data, set):\n        return {list_to_set(item) for item in data}\n  \n    # If data is a tuple convert each item in the tuple to a set recursively and convert the tuples into sets.\n    elif isinstance(data, tuple):\n        return {list_to_set(item) for item in data}\n  \n    # If data is a dictionary convert each key value pair to tuple and handle each item in the tuple recursively.\n    elif isinstance(data, dict):\n        return {list_to_set((k,v)) for k,v in data.items()}\n\n    # If data is not a list, set, tuple or dict just return the data\n    else:\n        return data", "def unique_sets(sets):\n    # Remove duplicates by converting each sub-set to a tuple (which are hashable), \n    # making a set of those (ignores duplicates), then convert each tuple back to list.\n    return [list(x) for x in set(tuple(x) for x in sets)]", "def list_to_set(data):\n    \"\"\"\n    Function to convert a list to a set, managing nested lists and converting them to nested sets.\n    \"\"\"\n    # If data is a list, convert each item in the list to a set recursively\n    if isinstance(data, list):\n        return set(list_to_set(item) for item in data)\n\n    # If data is a set, convert each item in the set to a set recursively\n    elif isinstance(data, set):\n        return {list_to_set(item) for item in data}\n  \n    # If data is a tuple, convert each item in the tuple to a set recursively and convert the tuples into sets\n    elif isinstance(data, tuple):\n        return {list_to_set(item) for item in data}\n  \n    # If data is a dictionary, convert each key-value pair to a tuple and handle each item in the tuple recursively\n    elif isinstance(data, dict):\n        return {list_to_set((k,v)) for k,v in data.items()}\n\n    # If data is not a list, set, tuple, or dict, just return the data\n    else:\n        return data", "def transpose(matrix):\n    # The * operator is used to unzip a list (or other iterables), making a list of tuples where each tuple contains the i-th element from each of the argument sequences or iterables.\n    # The zip() function takes iterables, aggregates them in a tuple, and return the result.\n    # In other words, it returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.\n    return [list(i) for i in zip(*matrix)] ", "def add_elements(tuple1, set1):\n    # Convert the tuple to a list\n    tuple1 = list(tuple1)\n    \n    # Iterate through each element in the set\n    for element in set1:\n        # If the element is not already in the tuple's list, add it to the beginning\n        if element not in tuple1:\n            tuple1.insert(0, element)\n    \n    # Convert the list back to a tuple\n    tuple1 = tuple(tuple1)\n    \n    return tuple1"]}
{"task_id": 434, "content": ["def add_matrices(A, B):\n    '''This function will return a matrix which is the result of the element wise addition of\n    two given matrices A & B.'''\n    result = [[A[i][j] + B[i][j] for j in range(len(A[0]))] for i in range(len(A))]\n    return result", "def ecc_scalar_mult(scalar, point):\n    # Implement the scalar multiplication operation in ECC\n    # This is a placeholder function as the actual implementation is not provided.\n    # The actual implementation would use the point and scalar to perform the multiplication.\n    pass", "def transpose(matrix):\n    # The * operator is used to unzip a list (or other iterables), making a list of tuples where each tuple contains the i-th element from each of the argument sequences or iterables.\n    # The zip() function takes iterables, aggregates them in a tuple, and return the result.\n    # In other words, it returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.\n    return [list(i) for i in zip(*matrix)] ", "def filter_tuples(tuples, func):\n    \"\"\"\n    Filters a list of tuples based on a given condition.\n    \"\"\"\n    filtered_tuples = filter(func, tuples)\n    for tuple in filtered_tuples:\n        print(tuple)", "def advanced_concurrent_collision_detector(n: int, left_lane_autos: List[Tuple[float, float]], right_lane_autos: List[Tuple[float, float]]) -> List[Tuple[int, int, float, float]]:\n    \"\"\" Detects the concurrent collisions between cars in both lanes.\n    Returns a list of tuples where each tuple represents a collision.\n    The first two elements are the index of the collided cars in left and right lanes and the other two elements are the overlapping distance.\n\n    :param n: Number of automobiles in each lane\n    :param left_lane_autos: List of tuples indicating the start and end points of automobiles in left lane\n    :param right_lane_autos: List of tuples indicating the start and end points of automobiles in right lane\n    :return: A list of tuples indicating the collided automobiles and their overlapping distance\n    \"\"\"\n    collisions = []\n    for i in range(n):\n        for j in range(n):\n            if left_lane_autos[i][0] < right_lane_autos[j][1] and left_lane_autos[i][1] > right_lane_autos[j][0]:  # Check if ranges of left and right cars overlap\n                overlap_start = max(right_lane_autos[j][0], left_lane_autos[i][0])\n                overlap_end = min(right_lane_autos[j][1], left_lane_autos[i][1])\n                collisions.append((i, j, overlap_start, overlap_end))\n    return collisions"]}
{"task_id": 435, "content": ["def frequencySort(nums):\n    # collections.Counter(nums) gives the frequency of each element in the nums array.\n    # items() function returns a view object that displays a list of a dictionary's(an iterable) tuple pair (key, value).\n    c = Counter(nums).items()\n    # Then we will sort the results by the tuple (-count, num). Negative count ensures that high frequency elements come first in the sorted list.\n    # This satisfies the requirement to sort in increasing frequency. \n    # Because we use num for sort as well, elements with the same frequency are sorted in descending order.\n    # This satisfies the requirement to sort in decreasing order on the basis of value of the numbers in case of same frequency.\n    # idx is used to sort elements in increasing order of their index in case elements are same and have same frequency.\n    # sort function of python is stable. i.e, it maintains the relative order of items with equal sort keys\n    nums.sort(key = lambda x: (nums.count(x), -x, [i for i, n in enumerate(nums) if n == x][0]))\n    # return the sorted array\n    return nums", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def find_common_elements(*arrays):\n    # Convert all arrays into Python's built-in Set data structure, \n    # which automatically eliminates duplicates within individual arrays\n    sets = [set(arr) for arr in arrays]\n    \n    # The Python's built-in set.intersection method can be used to find elements that \n    # exist in all sets (i.e., all arrays). It takes any number of arguments (sets), \n    # so the * operator is used to unpack list of sets as arguments.\n    common_elements = set.intersection(*sets)\n    \n    # The sorted build-in function is used to sort the resulting set of common elements \n    # in ascending order\n    return sorted(common_elements)", "def revised_function(input_tuple):\n    # Checks if the tuple is None or empty \n    if not input_tuple:\n        return \"Error: input is NULL or empty.\"\n\n    # Initiating an empty list to hold string representations of the float values\n    str_list = []\n\n    # Iterate over the elements in the tuple\n    for element in input_tuple:\n        # Confirm that each element is a float. If not, return an error message.\n        if not isinstance(element, float):\n            return \"Error: all elements in the tuple should be floats.\"\n            \n        # Convert the float to a string and append to the list\n        str_list.append(str(element))\n    \n    # Join all elements in the list with a semicolon\n    result = \"; \".join(str_list)\n    \n    return result", "def vowel_count(text):\n    # All the vowels\n    vowels = 'aeiouAEIOU'\n\n    # Using list comprehension to get the count.\n    # The expression 'char in vowels' will be True if the character is a vowel.\n    # So, we are making a list of True for all characters in the text which are vowels.\n    # Finally we are returning the sum of the list which gives us the count of True in the list\n    # which is equal to the count of vowels in the text.\n    return sum(char in vowels for char in text)"]}
{"task_id": 436, "content": ["def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list", "def extract_odd_elements(array, unique=False):\n    # Error handling for invalid inputs\n    if not isinstance(array, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    for element in array:\n        if not isinstance(element, int):\n            raise ValueError(\"Elements of the list must be integers.\")\n\n    # Using built-in function to filter the array\n    odd_elements = list(filter(lambda x: x%2 == 1, array))\n\n    if unique:\n        # Using built-in function to remove duplicates\n        odd_elements = list(set(odd_elements))\n    return odd_elements", "def sort(list):\n    \"\"\"\n    This function sorts a given list in ascending order.\n\n    Parameters:\n    list (List[int, float, str]): A list of numerical or string values to be sorted. This list should contain elements of the same datatype for the function to work correctly. \n    \"\"\"\n    list.sort()", "def delete_idle_lambda(region_name):\n    \"\"\"\n    This function deletes idle AWS Lambda functions in a particular region.\n    :param region_name: str\n    :return: None\n    \"\"\"\n    # Create a session using boto3\n    session = boto3.Session(region_name=region_name)\n\n    # Connect to AWS Lambda service\n    lambda_client = session.client('lambda')\n\n    try:\n        # Get the list of all functions\n        functions = lambda_client.list_functions()\n\n        # Loop through each function\n        for function in functions['Functions']:\n            function_name = function['FunctionName']\n\n            # Here, we need to determine if the function is idle\n            # If the function is idle, we delete it\n            # Please replace `is_function_idle` with your actual check\n            if is_function_idle(function):\n                lambda_client.delete_function(FunctionName=function_name)\n                print(f\"Deleted function: {function_name}\")\n\n    except NoCredentialsError:\n        print(\"No AWS credentials were found.\")\n    except ClientError as e:\n        if e.response['Error']['Code'] == 'ResourceNotFoundException':\n            print(\"The specified lambda function does not exist.\")\n        else:\n            raise e", "def apply_lambda(int_list, lambda_str):\n    # Create a lambda function from the input string\n    lambda_func = eval(lambda_str)\n    \n    # Apply the lambda function to each integer in the list\n    result = [lambda_func(x) for x in int_list]\n    \n    return result"]}
{"task_id": 437, "content": ["def calculate_mean(numbers):\n    \"\"\"Function to calculate the mean of a collection of numbers.\"\"\"\n    return sum(numbers) / len(numbers)", "def list_average(numbers):\n    '''This function will calculate the average of a list of numbers.'''\n    if len(numbers) == 0:\n        return 0\n\n    return sum(numbers) / len(numbers)", "def calc_mean(numbers):\n    \"\"\"\n    Function to calculate the mean of a list of numbers\n    \"\"\"\n    total = sum(numbers)\n    mean = total / len(numbers)\n    return mean", "def calculate_sum(n):\n    \"\"\"Function to calculate the sum of the first n numbers.\"\"\"\n    sum = 0\n    while n > 0:\n        sum = sum + n\n        n = n - 1\n    return sum", "def calculate_mean(numbers):\n    \"\"\"\n    A function to calculate the mean of a list of integers and returns a string of the mean value.\n\n    Parameters:\n    numbers (list): a list of integers\n    \n    Returns:\n    str: the mean value formatted as a string\n    \"\"\"\n    mean = sum(numbers)/len(numbers)\n    return 'The mean is {}'.format(mean)"]}
{"task_id": 438, "content": ["def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True", "def compute_triangle_area(a, b, c):\n    # Check if sides are integers\n    if not isinstance(a, int) or not isinstance(b, int) or not isinstance(c, int):\n        raise InvalidTriangleError(\"Invalid triangle: the given sides are not integers.\")\n    \n    # Check if the given sides can form a triangle\n    if a + b <= c or b + c <= a or a + c <= b:\n        raise InvalidTriangleError(\"Invalid triangle: the given sides cannot form a triangle.\")\n    \n    # Compute the area using Heron's formula\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return area", "def is_multiple(n):\n    \"\"\"\n    Function to check if a given number is a multiple of 3 or 5.\n    \n    Parameters: \n    n (int): The given number to check.\n    \n    Returns: \n    bool: True if number is a multiple of 3 or 5, False otherwise.\n    \"\"\"\n    return n % 3 == 0 or n % 5 == 0", "def triangleType(a, b, c):\n  # First, let's check if the sides form a valid triangle\n  if (a + b <= c) or (a + c <= b) or (b + c <= a):\n    return \"Not a valid triangle\"\n\n  # Next, we'll check if all sides are equal, indicating an equilateral triangle\n  if a == b and b == c:\n    return \"Equilateral triangle\"\n\n  # If all sides are different lengths, it's a scalene triangle\n  if (a != b) and (b != c) and (a != c):\n    return \"Scalene triangle\"\n\n  # If it's not equilateral or scalene, it must be an isosceles triangle\n  return \"Isosceles triangle\"", "def calculate_triangle_height(angle, side1, side2):\n    # check if angle is in permissible range\n    if angle <= 0 or angle >= 180:\n        print('Invalid input. Please enter a valid angle')\n        return None\n    # check if sides are positive real numbers\n    elif side1 <= 0 or side2 <= 0:\n        print('Invalid input. Please enter valid sides')\n        return None\n    # check if the inputs can form a real triangle using triangle inequality principle\n    elif side1 + side2 <= side1 or side1 + side2 <= side2 or side1 + side1 <= side2:\n        print('Invalid input. These sides do not form a valid triangle')\n        return None\n    else:\n        # calculating height of triangle\n        height = side2 * math.sin(math.radians(angle))\n        return height"]}
{"task_id": 439, "content": ["def filter_by_prefix(string_list, prefix):\n    \"\"\"\n    Filters a list of strings based on a given prefix.\n\n    Args:\n    string_list: A list of strings to be filtered.\n    prefix: A string representing the prefix to filter by.\n\n    Returns:\n    A new list containing only the strings from the original list that start with the specified prefix.\n    \"\"\"\n    return [s for s in string_list if s.startswith(prefix)]", "def find_palindromes(strings):\n    \"\"\"\n    Returns a list of palindromes from the input list of strings.\n\n    Args:\n    strings: A list of strings.\n\n    Returns:\n    A list of strings that are palindromes.\n    \"\"\"\n    palindromes = []\n    for string in strings:\n        # Remove spaces and convert to lowercase\n        clean_string = ''.join(e for e in string if e.isalnum()).lower()\n        if clean_string == clean_string[::-1]:  # Check if the string is a palindrome\n            palindromes.append(string)\n    return palindromes", "def trim_trailing_whitespace(strings):\n    \"\"\"\n    Removes trailing whitespace from each string in the input list.\n    \n    Args:\n    strings: A list of strings to be processed.\n    \n    Returns:\n    A list of strings with trailing whitespace removed.\n    \"\"\"\n    trimmed_strings = [s.rstrip() for s in strings]\n    return trimmed_strings", "def read_hdf5(hdf5_file, dataset, batch_size):\n    # Assume the existence of a function to read data from an HDF5 file\n    # and yield batches of data based on the specified dataset and batch size\n    pass", "def generateRandomCharacter(size):\n    characters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\n    charactersLength = len(characters)\n\n    random_string = \"\"\n\n    # generate a random string of the specified size\n    for i in range(size):\n        # get a random character from the list of characters\n        random_string += characters[random.randint(0, charactersLength - 1)]\n\n    return random_string"]}
{"task_id": 440, "content": ["def find_words_with_fr(string):\n    '''\n    This function will find all words containing the letters \"fr\" in a given string.\n    \n    Args:\n        string (str): the string to be searched\n    \n    Returns:\n        list: a list of all words containing the letters \"fr\"\n    '''\n    regex = r\"\\b\\w*fr\\w*\\b\"\n    return re.findall(regex, string)", "def convert_to_upper(string):\n    \"\"\"Function to convert the given string to all capital letters using an algorithm. Input should be a string.\"\"\"\n    result = ''\n    for char in string:\n        result += chr(ord(char) - 32)\n    return result", "def extract_urls(string):\n    # Regular expression pattern to match URLs\n    pattern = r'(https?://\\S+)'\n    \n    # Find all URLs in the string using regex\n    urls = re.findall(pattern, string)\n    \n    # Remove duplicates from the list of URLs\n    unique_urls = list(set(urls))\n    \n    return unique_urls", "def extract_numbers(input_string):\n    \"\"\"This function extracts numbers from a given textstring using regular expressions.\"\"\"\n    \n    # Compile the regular expression\n    pattern = re.compile(r'\\d+')\n    \n    # Find all numbers in the string\n    output_list = pattern.findall(input_string)\n    \n    return output_list", "def remove_all_punctuation(string):\n    \"\"\"\n    Remove all punctuation from a given string.\n    \n    Parameters:\n    string (str): The string to be modified.\n    \n    Returns:\n    str: The modified string without any punctuation.\n    \"\"\"\n    punctuations = string.maketrans('', '', string.punctuation)\n    no_punct = string.translate(punctuations) \n    return no_punct"]}
{"task_id": 441, "content": ["    def withdraw(self, amount):\n        \"\"\"\n        Subtracts the given amount from the account balance, if sufficient funds are available.\n        Returns True if the withdrawal is successful, False otherwise.\n        \"\"\"\n        if self.balance >= amount:\n            self.balance -= amount\n            return True\n        else:\n            return False", "def mean_squared_error(predictions, target_labels):\n    # Compute the mean squared error loss between the predictions and the target labels\n    # This function should return the mean squared error loss given the predictions and target labels\n    pass", "def custom_loss_function(self, predictions, targets):\n    # Custom loss calculation logic goes here\n    # ...\n\n    if self.reduction == \"mean\":\n        loss = calculate_mean_loss(predictions, targets)\n    elif self.reduction == \"sum\":\n        loss = calculate_sum_loss(predictions, targets)\n    elif self.reduction == \"none\":\n        loss = calculate_individual_loss(predictions, targets)\n    else:\n        raise ValueError(f'Unsupported reduction: {self.reduction}, available options are [\"mean\", \"sum\", \"none\"].')\n\n    return loss", "def trim_string(string, amount):\n    # Check if the string argument is not a string\n    if not isinstance(string, str):\n        raise TypeError(\"String argument must be a string\")\n\n    # Check if the amount argument is not a positive integer\n    if not isinstance(amount, int) or amount <= 0:\n        raise ValueError(\"Amount must be a positive integer\")\n\n    # Check if the amount is greater than the length of the string\n    if amount > len(string):\n        return \"\"\n\n    # Return the new string with the specified amount of characters trimmed from the beginning\n    return string[amount:]", "def loss(cls_scores, bbox_preds, gt_bboxes, gt_labels, img_metas, gt_bboxes_ignore):\n    # Implement the loss function to calculate class and bounding box losses\n    # Your implementation may involve using specific loss functions such as cross-entropy for classification and smooth L1 loss for bounding box regression.\n\n    # Calculate class loss\n    # Example: cls_loss = cross_entropy_loss(cls_scores, gt_labels)\n\n    # Calculate bounding box regression loss\n    # Example: box_loss = smooth_l1_loss(bbox_preds, gt_bboxes)\n\n    # Create a dictionary to store the losses\n    losses = {\n        'loss_cls': cls_loss,\n        'loss_bbox': box_loss\n    }\n\n    return losses"]}
{"task_id": 442, "content": ["def calculate_sum_positive_even_numbers(numbers):\n    \"\"\"\n    Calculates the sum of all positive even numbers from a given list.\n    \n    Args:\n    numbers (list): The list of numbers.\n    \n    Returns:\n    int: The sum of all positive even numbers.\n    \n    Raises:\n    ValueError: If the input list contains non-integer elements.\n    \n    \"\"\"\n    \n    # Validate the input list\n    for num in numbers:\n        if not isinstance(num, int):\n            raise ValueError(\"Input list should only contain integers.\")\n    \n    # Initialize sum variable\n    sum = 0\n    \n    # Create a set to store unique even numbers\n    unique_evens = set()\n    \n    # Iterate through the list\n    for num in numbers:\n        # Check if the number is positive and even\n        if num > 0 and num % 2 == 0:\n            # Add the number to the set of unique even numbers\n            unique_evens.add(num)\n    \n    # Calculate the sum of unique even numbers\n    for even_num in unique_evens:\n        sum += even_num\n    \n    return sum", "def inject_payload(pid, payload):\n    # This function would need to be implemented to attach to the process,\n    # find the system call table, and modify it to point to the custom handler.\n    # This is a complex task that typically requires kernel-level access and\n    # is beyond the scope of a simple Python script.\n    pass", "def exchange(lst1, lst2):\n    # Check if total sum of lst1 and lst2 are both even numbers.\n    # If not, return \"NO\" directly because even number of swaps can't make uneven sum to be even.\n    if sum(lst1) % 2 != 0 or sum(lst2) % 2 != 0:\n        return \"No\"\n\n    # If the sum of both lists are even, then check if it's possible to make lst1 to be a list of even numbers.\n    # If an odd number in lst1 is found, then try to find an even number in lst2 to swap. If not found, return \"NO\" directly.\n    for i in range(len(lst1)):\n        if lst1[i] % 2 != 0:\n            has_swap = False\n            for j in range(len(lst2)):\n                if lst2[j] % 2 == 0:\n                    # Swap found, exchange the elements and break the loop.\n                    lst1[i], lst2[j] = lst2[j], lst1[i]\n                    has_swap = True\n                    break\n            if not has_swap:\n                return \"NO\"\n\n    # If all odd numbers in lst1 can find matched even numbers in lst2 to swap, return \"YES\".\n    return \"YES\"", "def add_sum(arr):\n    result = []  # Create an empty list to store the modified array\n    sum = 0  # Initialize a variable to store the sum of even elements\n\n    for num in arr:  # Iterate through each number in the given array\n        if num % 2 == 0:  # Check if the number is even\n            sum += num  # Add the even number to the sum\n\n    result.append(sum)  # Append the sum of even elements to the beginning of the modified array\n    result.extend(arr)  # Extend the modified array with the original array\n\n    return result  # Return the modified array", "def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]"]}
{"task_id": 443, "content": ["def match_hex_vowel(string):\n    # The regexp starts with \\b to match the start of a word\n    # Following that, [0-9A-Fa-f]+ matches one or more hexadecimal digits\n    # After that, [aeiou] matches a single lowercase English vowel\n    # Finally, \\b matches the end of a word to avoid partial word matches \n    pattern = r'\\b[0-9A-Fa-f]+[aeiou]\\b'\n    return re.match(pattern, string) is not None", "def match_hex_vowel(string):\n    # The regexp starts with \\b to match the start of a word\n    # Following that, [0-9A-Fa-f]+ matches one or more hexadecimal digits\n    # After that, [aeiou] matches a single lowercase English vowel\n    # Finally, \\b matches the end of a word to avoid partial word matches \n    pattern = r'\\b[0-9A-Fa-f]+[aeiou]\\b'\n    return re.match(pattern, string) is not None", "def generate_payload():\n    \"\"\"Generate a benign payload that writes a file to the disk with a unique name.\"\"\"\n    filename = generate_unique_filename()\n    payload = f\"\"\"\nimport os\n\n# Payload to write a file to the disk with a unique name\ndef write_file(filename):\n    with open(filename, 'w') as f:\n        f.write('This is a test file.')\n\n# Call the payload function\nwrite_file('{filename}')\n\"\"\"\n    return payload", "def find_frantic_sentences(text):\n # Define the pattern to match sentences containing the word 'frantic'\n pattern = r'([A-Z][^.!?]*frantic[^.!?]*[.!?])'\n \n # Find all matches of the pattern in the text\n matches = re.findall(pattern, text)\n \n # Return the list of matched sentences\n return matches", "def match_sequences(text):\n    pattern = 'a.*[0-9].*Z'\n    matches = re.findall(pattern, text)\n\n    return matches"]}
{"task_id": 444, "content": ["def get_num_days(month, year):\n    # check if the year is a leap year\n    if year % 400 == 0 or (year % 100 != 0 and year % 4 == 0):\n        leap_year = True\n    else:\n        leap_year = False\n    \n    # dictionary to map month number to number of days\n    num_days_in_month = {\n        1: 31,\n        2: 29 if leap_year else 28,\n        3: 31,\n        4: 30,\n        5: 31,\n        6: 30,\n        7: 31,\n        8: 31,\n        9: 30,\n        10: 31,\n        11: 30,\n        12: 31\n    }\n    \n    # return the number of days for the given month\n    return num_days_in_month[month]", "def num_days_in_month(month, year):\n    \"\"\"\n    Return the number of days in the given month and year\n    \"\"\"\n    days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if month == 2 and ((year % 4 == 0) and (year % 100 != 0) or (year % 400 == 0)):\n        return 29\n    return days[month-1]", "def get_number_of_days(month, year):\n    # Check if month is within the specified range\n    if month < 1 or month > 12:\n        raise ValueError(\"Invalid month\")\n\n    # Check if year is within the specified range\n    if year < 1 or year > 9999:\n        raise ValueError(\"Invalid year\")\n\n    # Define the number of days in each month\n    days_in_month = {\n        1: 31,  # January\n        2: 28,  # February\n        3: 31,  # March\n        4: 30,  # April\n        5: 31,  # May\n        6: 30,  # June\n        7: 31,  # July\n        8: 31,  # August\n        9: 30,  # September\n        10: 31,  # October\n        11: 30,  # November\n        12: 31   # December\n    }\n\n    # Check if it is a leap year\n    if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n        days_in_month[2] = 29  # Update days in February\n\n    return days_in_month[month]", "def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True", "def is_valid_date(date):\n    # Mapping of month names to their respective number\n    month_map = {\n        'jan': 1, 'feb': 2, 'mar': 3, 'apr': 4, 'may': 5, 'jun': 6,\n        'jul': 7, 'aug': 8, 'sep': 9, 'oct': 10, 'nov': 11, 'dec': 12\n    }\n\n    # Mapping of month numbers to their respective number of days\n    month_days_map = {\n        1: 31, 2: 28, 3: 31, 4: 30, 5: 31, 6: 30,\n        7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31\n    }\n\n    # Remove any leading or trailing whitespaces\n    date = date.strip()\n\n    # Determine the separator used in the date\n    separators = ['/','-','.']\n    separator = None\n    for sep in separators:\n        if sep in date:\n            separator = sep\n            break\n\n    if separator is None:\n        return False\n\n    # Split the date into month, day, and year\n    parts = date.split(separator)\n\n    if len(parts) != 3:\n        return False\n\n    # Extract the month, day, and year from the parts\n    if separator == '.':\n        month, day, year = parts[0], parts[1], parts[2]\n    else:\n        month, day, year = parts[0], parts[1], parts[2][:4] # Handle case of year with more than 4 digits\n\n    # Convert the month to a number\n    if month.isdigit():\n        month = int(month)\n    else:\n        month = month_map.get(month.lower())\n\n    # Check if the month is valid\n    if month is None or month < 1 or month > 12:\n        return False\n\n    # Check if the year is valid\n    if not year.isdigit() or len(year) != 4:\n        return False\n\n    year = int(year)\n\n    # Check for dates before the adoption of the Gregorian calendar (October 4, 1582 and earlier)\n    if year < 1582 or (year == 1582 and month < 10) or (year == 1582 and month == 10 and day < 4):\n        return False\n\n    # Check if it's a leap year and adjust the number of days in February accordingly\n    if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n        month_days_map[2] = 29\n\n    # Check if the day is valid\n    if not day.isdigit() or int(day) < 1 or int(day) > month_days_map[month]:\n        return False\n\n    return True"]}
{"task_id": 445, "content": ["def filter_by_prefix(strings, prefix):  # define a function that takes a list of strings and a prefix\n    return [string for string in strings if string.startswith(prefix)]  # return a list of those strings that start with the given prefix", "def sort(list):\n    \"\"\"\n    This function sorts a given list in ascending order.\n\n    Parameters:\n    list (List[int, float, str]): A list of numerical or string values to be sorted. This list should contain elements of the same datatype for the function to work correctly. \n    \"\"\"\n    list.sort()", "def check_unique_strings(strings):\n    '''This function takes a list of strings and returns a boolean \n    indicating whether all the strings in the list are unique.'''\n    seen = set()\n    for string in strings:\n        if string in seen:\n            return False\n        seen.add(string)\n    return True", "def filter_by_prefix(string_list, prefix):\n    \"\"\"\n    Filters a list of strings based on a given prefix.\n\n    Args:\n    string_list: A list of strings to be filtered.\n    prefix: A string representing the prefix to filter by.\n\n    Returns:\n    A new list containing only the strings from the original list that start with the specified prefix.\n    \"\"\"\n    return [s for s in string_list if s.startswith(prefix)]", "def sorted_list_sum(lst, reverse=False):\n    \"\"\"\n    This function takes as input a list of strings, removes any string that contains a numerical digit or \n    an odd number of characters, sorts remaining strings in ascending order by both length and alphabetically, \n    and then returns the sorted list.\n    \n    Achieves this by using list comprehension to filter out unwanted elements, \n    and Python's built-in sorted function to sort the list. The sorted function uses a compound sorting key \n    consisting of the length of each element and the element itself, allowing for sorting by multiple criteria.\n    \n    The ordering of the sorted list can be reversed by supplying a second argument of True.\n\n    Parameters:\n    lst (list): A list of strings to be filtered and sorted.\n    reverse (bool): Optional parameter to reverse the order of the sorted list. Defaults to False.\n\n    Returns:\n    list: The sorted list of strings.\n    \"\"\"\n    \n    # Filter out any strings containing numerical digits or with odd length\n    lst = [i for i in lst if not any(j.isdigit() for j in i) and len(i) % 2 == 0]\n    \n    # Return the list sorted by length and then alphabetically, in ascending or descending order\n    return sorted(lst, key=lambda x: (len(x), x), reverse=reverse)"]}
{"task_id": 446, "content": ["def inject_payload(pid, payload):\n    # This function would need to be implemented to attach to the process,\n    # find the system call table, and modify it to point to the custom handler.\n    # This is a complex task that typically requires kernel-level access and\n    # is beyond the scope of a simple Python script.\n    pass", "def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min", "def min_length_city(cities):\n    # Find the city with the minimum length.\n    min_length = min(len(city) for city in cities)\n    \n    # Filter the cities with the minimum length.\n    min_length_cities = [city for city in cities if len(city) == min_length]\n    \n    # Sort the cities in reverse alphabetical order.\n    min_length_cities.sort(reverse=True)\n    \n    return min_length_cities", "def make_palindrome(string: str) -> int:\n    \"\"\" Find the minimum number of characters that need to be added at the end of the supplied string to make it a palindrome, ignoring case, non-alphanumeric characters, and spaces between words.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Compute the length of the string prefix that comes before the palindromic suffix.\n    - Return the length of the prefix as the minimum number of characters needed to create the shortest possible palindrome.\n    \"\"\"\n    filtered_string = ''.join(char.lower() for char in string if char.isalnum())\n    \n    for i in range(len(filtered_string)):\n        if is_palindrome(filtered_string[i:]):\n            return i", "def make_palindrome(string: str) -> int:\n    \"\"\"\n    Find the minimum number of characters that need to be added at the end of the supplied string to make it a palindrome, \n    ignoring case, non-alphanumeric characters, and spaces between words.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome,\n    - Compute the length of the string prefix that comes before the palindrome suffix.\n    - Return the length of the prefix as the minimum number of characters needed to create the shortest possible palindrome.\n    \"\"\"\n    filtered_string = ''.join(char.lower() for char in string if char.isalnum())\n\n    for i in range(len(filtered_string)):\n        if is_palindrome(filtered_string[i:]):\n            return i"]}
{"task_id": 447, "content": ["def total_area(rectangles):\n    \"\"\"\n    Function to calculate total area for a list of rectangles.\n    \"\"\"\n    area = 0\n    for rectangle in rectangles:\n        # If rectangle is not a pair of points, raise an error.\n        if not isinstance(rectangle, tuple) or len(rectangle) != 2:\n            raise ValueError(\"Invalid rectangle data: {}. Rectangle should be a tuple of 2 points.\".format(rectangle))\n        else:\n            area += rectangular_area(*rectangle)\n    return area", "def rectangle_area(l, w):\n    \"\"\"\n    With the provided length and width, find the area of the rectangle.\n\n    :param l: The length of the rectangle.\n    :param w: The width of the rectangle.\n    :return: The area of the rectangle.\n    \"\"\"\n\n    # Compute the area by multiplying the length and the width\n    area = l * w\n\n    # Return the computed area\n    return area", "def calculate_rectangle_area(top_left, bottom_right):\n    length = bottom_right.real - top_left.real\n    width = top_left.imag - bottom_right.imag\n    area = abs(length) * abs(width)\n\n    if length == width:\n        print(f\"The area of the rectangle is {area} square units.\")\n        print(\"The rectangle is a square.\")\n    else:\n        print(f\"The area of the rectangle is {area} square units.\")\n        print(\"The rectangle is not a square.\")", "def rectangle_area(l, w):\n    \"\"\"Using the given longitudinal and transverse dimensions, calculate the metrical area of a rectangular shape's flat figure. \n\n    Args:\n    l (int or float): Represents the length of the rectangle.\n    w (int or float): Represents the width of the rectangle.\n\n    Returns:\n    int or float: The metrical area of the rectangle as a result of the product of the length and width.\n\n    Example:\n    >>> rectangle_area(6, 4)\n    24\n    \"\"\"\n    # Rectangle area calculation by multiplying length and width\n    area = l * w\n\n    # Returning the calculated area\n    return area", "def rectangle_area(l, w):\n    \"\"\"Using the given longitudinal and transverse dimensions, calculate the metrical area of a rectangular shape's flat figure. \n\n    Args:\n    l (int or float): Represents the length of the rectangle.\n    w (int or float): Represents the width of the rectangle.\n\n    Returns:\n    int or float: The metrical area of the rectangle as a result of the product of the length and width.\n\n    Example:\n    >>> rectangle_area(6, 4)\n    24\n    \"\"\"\n    # Rectangle area calculation by multiplying length and width\n    area = l * w\n\n    # Returning the calculated area\n    return area"]}
{"task_id": 448, "content": ["def split_string(string, separator):\n    # Split the string based on the separator, but preserve the separator within quotes\n    regex = r'\"[^\"]*\"|[^' + re.escape(separator) + ']+'\n    substrings = re.findall(regex, string)\n    \n    # Remove any leading or trailing whitespace from each substring\n    substrings = [substring.strip() for substring in substrings]\n    \n    return substrings", "def find_words_with_fr(string):\n    '''\n    This function will find all words containing the letters \"fr\" in a given string.\n    \n    Args:\n        string (str): the string to be searched\n    \n    Returns:\n        list: a list of all words containing the letters \"fr\"\n    '''\n    regex = r\"\\b\\w*fr\\w*\\b\"\n    return re.findall(regex, string)", "def parse_string(pattern, string):\n    '''\n    This function parses a string and returns the substrings which are enclosed in the given pattern.\n    \n    Parameters\n    ----------\n    pattern : str\n        The given pattern\n    string : str\n        The given string\n    \n    Returns\n    -------\n    List\n        Contains substrings enclosed within the given pattern.\n    '''\n    # Initialize list to store substrings\n    sub_strings = []\n    \n    # Get the start and end positions of each substring\n    start = string.find(pattern)\n    end = string.find(pattern, start+1)\n    \n    # Iterate through the string\n    while start >= 0 and end > start:\n        # Get substring and append to list\n        sub_strings.append(string[start+len(pattern):end])\n        \n        # Get new start and end positions\n        start = end\n        end = string.find(pattern, start+1)\n    \n    # Return list of substrings\n    return sub_strings", "def detect_language(text):\n    '''This function will detect the language of a given text using a programming language.'''\n    from langdetect import detect\n    return detect(text)", "def convert_to_upper(string):\n    \"\"\"Function to convert the given string to all capital letters using an algorithm. Input should be a string.\"\"\"\n    result = ''\n    for char in string:\n        result += chr(ord(char) - 32)\n    return result"]}
{"task_id": 449, "content": ["def remove_first_element(lists):\n    # Use list slicing to remove the first element of each sublist\n    return [lst[1:] for lst in lists]", "def flatten_list(lst):\n    flattened = []  # initialize an empty list to store the flattened elements\n    \n    # iterate over each sublist in the given list\n    for sublist in lst:\n        # iterate over each element in the sublist\n        for element in sublist:\n            flattened.append(element)  # add the element to the flattened list\n    \n    return flattened", "def count_lists(lst):\n    \"\"\"Main function to count number of lists in a list\"\"\"\n    # Flatten all lists in lst and convert them into tuples\n    lst = [tuple(flatten(sublist)) for sublist in lst if isinstance(sublist, list)]\n    \n    # Get the counts of each tuple\n    return {t: lst.count(t) for t in set(lst)}", "def merge_and_sort_lists(input_list):\n    \n    # Check if input is a list\n    if not isinstance(input_list, list):\n        return \"Error: The input is not a list.\"\n    \n    for sublist in input_list:\n        # Check if each element of the input is a list\n        if not isinstance(sublist, list):\n            return \"Error: The input is not a list of lists.\"\n        for item in sublist:\n            # Check if each element of the sublist is a string\n            if not isinstance(item, str):\n                return \"Error: The sublist contains non-string elements.\"\n            \n    try:\n        # Remove duplicates in each sublist and sort\n        input_list = [sorted(list(set(sublist))) for sublist in input_list]\n\n        # Merge sorted sublists and remove duplicates\n        merged_list = sorted(set().union(*input_list))\n\n        return merged_list\n\n    except Exception as e:\n        return f\"An error occurred: {str(e)}\"", "def multiply_by_two(arr):\n    # Use list comprehension to multiply each element of each sublist by two\n    return [[elem * 2 for elem in sublist] for sublist in arr]"]}
{"task_id": 450, "content": ["def count_chars(string):\n    \"\"\"Function to count characters in a given string\"\"\"\n    count = 0\n\n    # Loop through each character\n    for char in string:\n        count += 1\n\n    # Return the count\n    return count", "def cipher(s):\n    \"\"\"Derive a python function called 'cipher' that takes a string parameter and returns a ciphered string utilizing a rotated alphabet (the alphabet is shifted three positions ahead, using the modulo operator in Python to handle wrapping at the ends). This function should conserve the case of the characters (upper and lower), keep the non-alphabetical characters unchanged in the derived output, and work for all characters of the lower case and uppercase English alphabets. Here are some examples:\n    cipher('Hi') renders 'Lm'\n    cipher('aSdFgHjKl') tends to become 'dUgIjLmNpQr'\n    cipher('Zx112e_') translates to 'Ca!I23h_'\n    cipher('E.x + Uz') is turned into 'H.a + Xc'\n    \"\"\"\n    result = ''\n\n    for char in s:\n    # preserve the non-alphabetical characters\n        if not char.isalpha():\n            result += char\n            continue\n\n    # shift three positions ahead, with case consideration\n        shifted_char = chr((ord(char.lower()) - 97 + 3) % 26 + 97) if char.islower() else chr((ord(char.upper()) - 65 + 3) % 26 + 65)\n        result += shifted_char\n\n    return result", "def swap_case(string):\n    '''This function swaps the case of all characters in a given string.'''\n    new_string = ''\n    for char in string:\n        if char.isupper():\n            new_string += char.lower()\n        else:\n            new_string += char.upper()\n    return new_string", "def cipher(s):\n    \"\"\"Derive a python function called 'cipher' that takes a string parameter and returns a ciphered string utilizing a rotated alphabet (the alphabet is shifted three positions ahead, using the modulo operator in Python to handle wrapping at the ends). This function should conserve the case of the characters (upper and lower), keep the non-alphabetical characters unchanged in the derived output, and work for all characters of the lower case and uppercase English alphabets. Here are some examples:\n    cipher('Hi') renders 'Lm'\n    cipher('aSdFgHjKl') tends to become 'dVgIjKmNpQr'\n    cipher('Zx!123_') translates to 'Ca!123_'\n    cipher('E.T + Ux') is turned into 'H.Y + Xc'\n    \"\"\"\n    result = ''\n    \n    for char in s:\n        # preserve the non-alphabetical characters\n        if not char.isalpha():\n            result += char\n            continue\n\n        # shift three positions ahead, with case consideration\n        shifted_char = chr((ord(char.lower()) - 97 + 3) % 26 + 97) if char.islower() else chr((ord(char.upper()) - 65 + 3) % 26 + 65)\n        result += shifted_char\n\n    return result", "def check_alphabets(s):\n    \"\"\"This function checks if all characters of a given string are either upper case (capital) or lower case\"\"\"\n    if s.isupper() or s.islower():\n        return True\n    else:\n        return False"]}
{"task_id": 451, "content": ["def findCombinations(array, total):\n    \"\"\"\n    This function will find all possible combinations of integers in the given array that sum up to the given total.\n    Args:\n        array (list): List of integers.\n        total (int): Total to be reached with the combination of integers.\n    \n    Returns:\n        A list of lists containing the combinations of integers.\n    \"\"\"\n    combinations = []  # list to store the possible combinations\n    for i in range(1 << len(array)):  # loop through all combinations of bits\n        combination = []  # list to store the current combination\n        for j in range(len(array)):  # loop through array elements\n            if i & (1 << j):  # check if bit is set\n                combination.append(array[j])  # add array element to combination\n        if sum(combination) == total:  # check if combination sums to given total\n            combinations.append(combination)  # add combination to list of combinations\n\n    return combinations", "def find_combinations(chars):\n    \"\"\"Find all possible combinations of words that can be formed with a set of characters\"\"\"\n    characters = list(chars)  # Convert the characters into a list\n    combinations = set()  # Create an empty set to store the combinations\n\n    # Iterate over the list of characters\n    for i in range(len(characters)):\n        # Get the current character\n        char = characters[i]\n\n        # Create a new list with the other remaining characters\n        remaining_chars = characters[:i] + characters[i+1:]\n\n        # Create a temporary set to store all the combinations\n        # of the remaining characters\n        temp_set = set()\n        for c in remaining_chars:\n            temp_set.add(char + c)\n\n        # Add the temporary set to the main set of combinations\n        combinations = combinations | temp_set\n\n    return combinations", "def find_three_numbers(array, target):\n    # Use the combinations function to generate all possible combinations of 3 numbers from the list\n    for comb in combinations(array, 3):\n        if sum(comb) == target:   # If the sum of a combination equals the target value\n            return True   # Return True and terminate the function\n    return False   # If no combination is found, return False", "def solve_problem(n, count):\n    # generate all possible combinations of 4 elements\n    all_combinations = list(itertools.combinations(n, 4))\n\n    # initialize a list to store all sequences that match the count\n    sequences = []\n\n    # iterate over all combinations\n    for comb in all_combinations:\n        \n        prod = 1\n        # compute the product of elements in the current combination\n        for val in comb:\n           prod *= val\n\n        # if the product equals the count, add the combination to the sequences list\n        if prod == count:\n            sequences.append(comb)\n\n    return sequences", "def generate_combinations(string):\n    # Create a list of characters from the given string\n    chars = list(string)\n\n    # Initialize an empty list to store the combinations\n    combinations = []\n\n    # Generate all possible combinations using itertools.product\n    for r in range(1, len(chars) + 1):\n        combinations.extend([''.join(comb) for comb in itertools.product(chars, repeat=r)])\n\n    return combinations"]}
{"task_id": 452, "content": ["def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def max_sum_subarray(array):\n    \"\"\"\n    This function will find the maximum sum of a contiguous subarray.\n    \n    Parameters:\n    array: list of integers\n    \n    Returns:\n    maximum sum of contiguuous subarray\n    \"\"\"\n    # Initialize the max sum and current sum to the start of the array\n    max_sum = current_sum = array[0]\n    \n    # Iterate over the array\n    for num in array[1:]:\n        # Reset the current sum to 0 if it is negative\n        current_sum = max(0, current_sum + num)\n        max_sum = max(current_sum, max_sum)\n    \n    return max_sum", "def generate_input_file():\n    # The input file should be generated in such a way that it produces the maximum product of final[1] and final[3],\n    # and the maximum key in the results dictionary.\n    # To achieve this, the input file should be carefully crafted to produce the desired output when processed by the given function.\n    # The specific details of the input file content and format depend on the logic within the given function, and may require trial and error to determine the optimal input file content.\n\n    # As the exact logic within the given function is not provided, the generation of the input file content involves reverse-engineering the function's behavior and requirements.\n\n    # The solution to this problem involves analyzing the given function's behavior and requirements, and crafting an input file that fulfills those conditions to produce the desired output.\n\n    # Due to the specific nature of the input file content required to achieve the desired output, the exact content and format of the input file cannot be provided without further information about the given function's internal logic and requirements.\n\n    # Therefore, the solution involves understanding the behavior of the given function and crafting an input file that, when processed by the function, produces the maximum product of final[1] and final[3], and the maximum key in the results dictionary.\n\n    # The generation of the input file content may involve experimentation and analysis to determine the optimal values and structure that result in the desired output when processed by the given function.\n\n    # As the specific details of the input file content and format are not provided, the solution involves a process of reverse-engineering and experimentation to determine the appropriate input file content that fulfills the given requirements.\n\n    return \"Generated input file content\"", "def max_subarray_sum(arr):\n    n = len(arr)\n    memo = [0] * n  # Create a memoization array to store the maximum sum of subarrays ending at each index\n    \n    memo[0] = arr[0]  # Base case: the maximum sum of a subarray ending at the first element is the element itself\n    \n    for i in range(1, n):\n        # The maximum sum of a subarray ending at index i is the maximum of:\n        #   1. The element itself\n        #   2. The element plus the maximum sum of a subarray ending at the previous index (i-1)\n        #   3. The maximum sum of a subarray ending at the previous index (i-1)\n        memo[i] = max(arr[i], arr[i] + memo[i-1], memo[i-1])\n    \n    return max(memo)  # The maximum sum of any subarray in the array is the maximum value in the memoization array", "def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers."]}
{"task_id": 453, "content": ["def create_dictionary(keys, values):\n    # Check if the length of the keys list is a multiple of 2\n    if len(keys) % 2 != 0:\n        return \"Length of keys list should be a multiple of 2.\"\n\n    # Check if the length of the values list is a multiple of 3\n    if len(values) % 3 != 0:\n        return \"Length of values list should be a multiple of 3.\"\n\n    # Check if the lengths of keys and values lists are the same\n    if len(keys) != len(values):\n        return \"Lengths of keys and values lists should be equal.\"\n\n    # Create an empty dictionary\n    dictionary = {}\n\n    # Iterate over the keys and values lists simultaneously\n    for key, value in zip(keys, values):\n        # Check if the key is unique\n        if key in dictionary:\n            return \"Keys should be unique.\"\n        \n        # Check if the value is of type string\n        if not isinstance(value, str):\n            return \"Values should be of type string.\"\n\n        # Add key-value pair to the dictionary\n        dictionary[key] = value\n\n    return dictionary", "def generate_dictionary(a, b, c):\n    # Check if the values are integers\n    if not all(value.isdigit() for value in (a, b, c)):\n        raise ValueError(\"All values must be integers\")\n\n    # Convert values to integers\n    a, b, c = int(a), int(b), int(c)\n\n    # Check if the values are prime numbers\n    if not all(is_prime(value) for value in (a, b, c)):\n        raise ValueError(\"All values must be prime numbers\")\n\n    # Check if the values are palindromic numbers\n    if not all(is_palindrome(value) for value in (a, b, c)):\n        raise ValueError(\"All values must be palindromic numbers\")\n\n    # Generate and return the dictionary\n    return {'a': a, 'b': b, 'c': c}", "def test_rivers_by_station_number():\n    stations = [(\"A\", \"a\"), (\"A\", \"b\"), (\"B\", \"c\")]\n    \n    # Call the function to be tested\n    stationsByRiver = stations_by_river(stations)\n    \n    # Check if the output is a dictionary\n    assert type(stationsByRiver) == dict\n    \n    # Check if the keys of the dictionary are strings\n    keys = list(stationsByRiver.keys())\n    assert all(isinstance(key, str) for key in keys)\n    \n    # Check if the values of the dictionary are lists\n    values = stationsByRiver.values()\n    assert all(isinstance(value, list) for value in values)\n    \n    # Assert specific station codes are correctly associated with their respective rivers\n    assert \"a\" in stationsByRiver[\"A\"]\n    assert \"b\" in stationsByRiver[\"A\"]\n    assert \"c\" in stationsByRiver[\"B\"]\n    assert \"c\" not in stationsByRiver[\"A\"]", "def sort_dict_values(input_dict):\n    # First, check if the input is a dictionary\n    if type(input_dict) != dict:\n        raise TypeError(\"Input should be a dictionary.\")\n    \n    # Then, check if the dictionary has exactly five entries\n    if len(input_dict) != 5:\n        raise ValueError(\"The dictionary should have exactly 5 entries.\")\n    \n    # For each entry in the dictionary\n    for key, value in input_dict.items():\n        # Check if the key is a string\n        if not isinstance(key, str):\n            raise TypeError(\"All keys should be strings.\")\n        \n        # Check if the value is a list\n        if not isinstance(value, list):\n            raise TypeError(\"All values should be lists.\")\n        \n        # Check if all elements in the list are integers\n        if not all(isinstance(i, int) for i in value):\n            raise TypeError(\"All elements in the value lists should be integers.\")\n        \n        # Sort the list\n        value.sort()\n        \n        # Reassign the sorted list to the key\n        input_dict[key] = value\n    \n    return input_dict", "def is_anagram(word1, word2):\n    # Check if both words are the same size\n    if len(word1) != len(word2):\n        return False\n    \n    # Create a dictionary to store the number of characters in each word\n    word_dict = {}\n    \n    # Populate the dictionary with characters from each word\n    for char in word1:\n        if char in word_dict.keys():\n            word_dict[char] += 1\n        else:\n            word_dict[char] = 1\n    \n    # Decrement the characters for each word\n    for char in word2:\n        if char in word_dict.keys():\n            word_dict[char] -= 1\n        else:\n            return False\n    \n    # Check if all values in the dictionary are zero\n    for value in word_dict.values():\n        if value != 0:\n            return False\n    \n    return True"]}
{"task_id": 454, "content": ["def is_dict_empty(dictionary):\n    \"\"\"Function to check if a dictionary is empty or not.\n    Args:\n        dictionary (dict): dictionary to check\n    Returns:\n        bool: True if dictionary is empty, False otherwise\n    \"\"\"\n    return len(dictionary) == 0", "def get_orders_for_datetime(date_time: datetime) -> Dict[SimulatedExecutor, List[Order]]:\n    \"\"\"\n    Retrieves all orders scheduled for a given date and time from the _datetimes_to_data dictionary.\n\n    Args:\n    date_time: The date and time for which orders need to be retrieved.\n\n    Returns:\n    A dictionary containing all the orders scheduled for the given date and time. If no orders are scheduled, an empty dictionary is returned.\n    \"\"\"\n    return _datetimes_to_data.get(date_time, {})", "def delete_element(my_list, pos):\n    \"\"\"Function to delete an element from a given list at a given position.\"\"\"\n    del my_list[pos]\n    return my_list", "def sort_dict_of_dicts(d, key_func):\n    \"\"\"\n    Function to sort a dictionary of dictionaries\n    as per a given function.\n    :param d: Dictionary to be sorted.\n    :param key_func: Function used for sorting.\n    :Returns : Sorted dictionary.\n    \"\"\"\n    return dict(sorted(d.items(), key=lambda x: key_func(x[1]), reverse=True))", "def counter(text):\n    \"\"\"\n    Function to count the occurrence of each word in the text using \n    a dictionary data structure.\n    \n    Parameters: \n    text (str): The given text to count.\n    \n    Returns: \n    dict: A dictionary of words with their counts.\n    \"\"\"\n    result = {}  # Create empty dictionary\n    for word in text.split():\n        if word in result: \n            result[word] += 1\n        else: \n            result[word] = 1\n    return result"]}
{"task_id": 455, "content": ["def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def peak_intensity_value(image):\n    # Flatten the 2D image array into a 1D array\n    flattened_image = image.flatten()\n    \n    # Calculate the intensity histogram using numpy's histogram function\n    hist, bin_edges = np.histogram(flattened_image, bins=range(256))\n    \n    # Find the intensity value that corresponds to the peak count in the histogram\n    peak_intensity = np.argmax(hist)\n    \n    return peak_intensity", "def map_func(func, arr):\n    \"\"\"\n    Apply the given function to each element of the array.\n\n    Args:\n        func (function): function to apply\n        arr (np.ndarray): input array\n\n    Returns:\n        np.ndarray: array of results after applying the function\n    \"\"\"\n    return np.array([func(x) for x in arr])", "def findCombinations(array, total):\n    \"\"\"\n    This function will find all possible combinations of integers in the given array that sum up to the given total.\n    Args:\n        array (list): List of integers.\n        total (int): Total to be reached with the combination of integers.\n    \n    Returns:\n        A list of lists containing the combinations of integers.\n    \"\"\"\n    combinations = []  # list to store the possible combinations\n    for i in range(1 << len(array)):  # loop through all combinations of bits\n        combination = []  # list to store the current combination\n        for j in range(len(array)):  # loop through array elements\n            if i & (1 << j):  # check if bit is set\n                combination.append(array[j])  # add array element to combination\n        if sum(combination) == total:  # check if combination sums to given total\n            combinations.append(combination)  # add combination to list of combinations\n\n    return combinations"]}
{"task_id": 456, "content": ["def convert_hex_to_oct(hex_num):\n    # Convert input hexadecimal number to decimal\n    dec_num = int(hex_num, 16)\n    # Convert decimal number to octal\n    oct_num = oct(dec_num).replace(\"0o\", \"\")\n    return oct_num", "def to_octal(number):\n    # Step 1: Take the absolute value of the input number\n    number = abs(number)\n\n    # Step 2: Initialize the octal representation variable as 0\n    octal = 0\n\n    # Step 3: Enter the loop\n    while number != 0:\n        # Step 4: Get the least significant 3 bits of the input number\n        bits = number & 7\n\n        # Step 4: Convert the obtained bits to decimal using powers of 2\n        decimal = 0\n        power = 1\n        while bits != 0:\n            decimal += (bits & 1) * power\n            bits >>= 1\n            power <<= 1\n\n        # Step 4: Add the decimal value to the octal representation\n        octal += decimal\n\n        # Step 4: Right shift the input number by 3 bits\n        number >>= 3\n\n    # Step 5: Check if the input number was originally negative\n    if number < 0:\n        octal = -octal\n\n    # Step 6: Print the octal representation as the output\n    print(octal)", "def decimal_to_octal(decimal):\n    # Check if the number is negative\n    is_negative = False\n    if decimal < 0:\n        is_negative = True\n        decimal = abs(decimal)\n\n    # Split the number into integer and fractional parts\n    integer_part = int(decimal)\n    fractional_part = decimal - integer_part\n\n    # Convert the integer part to octal\n    octal_integer = \"\"\n    while integer_part > 0:\n        remainder = integer_part % 8\n        octal_integer = str(remainder) + octal_integer\n        integer_part = integer_part // 8\n\n    # Convert the fractional part to octal\n    octal_fractional = \"\"\n    while fractional_part > 0 and len(octal_fractional) < 2:\n        fractional_part *= 8\n        digit = int(fractional_part)\n        octal_fractional += str(digit)\n        fractional_part -= digit\n\n    # Combine the integer and fractional parts\n    octal = octal_integer + \".\" + octal_fractional\n\n    # Add the negative sign if necessary\n    if is_negative:\n        octal = \"-\" + octal\n\n    return octal", "def array_binary_to_octal(array):\n    octal_array = []\n    for binary in array:   # iterate over list\n        octal = binary_to_octal(binary) # convert each number to octal\n        octal_array.append(octal) # append converted number to new list\n    return octal_array", "def bin_to_oct(number):\n    \"\"\"\n    Convert a binary number to an octal number\n\n    Args:\n    number: the binary number\n\n    Returns:\n    the octal representation of the binary number.\n    \"\"\"\n    if not str(number).isnumeric():\n        return None\n\n    binary = str(number)\n    temp = int(binary, 2)\n    octal = oct(temp).replace(\"0o\", \"\")\n    return octal"]}
{"task_id": 457, "content": ["def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers.", "def longest_increasing_subsequence(sequence):\n    \"\"\"\n    This function uses dynamic programming to find the longest increasing subsequence in the input array. \n\n    Firstly, we initialize the list length with size as input array size. Each element in length represents the longest \n    increasing subsequence in sequence[0...i]. After initializing the list length with 1, the function fills length in \n    a bottom-up manner(using dynamic programming), i.e., if sequence[j] > sequence[i] for some i < j and length[j] < length[i] + 1,\n    then update length[j].\n\n    Finally, the function returns the maximum value from the list length.\n\n    :param sequence: An input array of integers\n    :type sequence: list\n    :return: The longest increasing subsequence in the array\n    :rtype: int\n    \"\"\"\n\n    # initialize the list length with 1's because a minimum increasing subsequence would just be one number itself\n    length = [1] * len(sequence)\n\n    # loop over the sequence from the second element\n    for i in range(1, len(sequence)):\n        # consider all smaller elements found so far\n            for j in range(i):\n                # if this element is bigger, check if we can increase the length of the largest subsequence ending at i\n                if sequence[i] > sequence[j] and length[i] < length[j] + 1:\n                    length[i] = length[j] + 1\n\n    # return the maximum length found\n    return max(length)", "def generate_input_file():\n    # The input file should be generated in such a way that it produces the maximum product of final[1] and final[3],\n    # and the maximum key in the results dictionary.\n    # To achieve this, the input file should be carefully crafted to produce the desired output when processed by the given function.\n    # The specific details of the input file content and format depend on the logic within the given function, and may require trial and error to determine the optimal input file content.\n\n    # As the exact logic within the given function is not provided, the generation of the input file content involves reverse-engineering the function's behavior and requirements.\n\n    # The solution to this problem involves analyzing the given function's behavior and requirements, and crafting an input file that fulfills those conditions to produce the desired output.\n\n    # Due to the specific nature of the input file content required to achieve the desired output, the exact content and format of the input file cannot be provided without further information about the given function's internal logic and requirements.\n\n    # Therefore, the solution involves understanding the behavior of the given function and crafting an input file that, when processed by the function, produces the maximum product of final[1] and final[3], and the maximum key in the results dictionary.\n\n    # The generation of the input file content may involve experimentation and analysis to determine the optimal values and structure that result in the desired output when processed by the given function.\n\n    # As the specific details of the input file content and format are not provided, the solution involves a process of reverse-engineering and experimentation to determine the appropriate input file content that fulfills the given requirements.\n\n    return \"Generated input file content\"", "def max_product(lst):\n    \"\"\"\n    Function to find the highest product that can be obtained from multiplying\n    any combination of four distinct elements together.\n    \"\"\"\n    n = len(lst)\n    if n < 4:\n        return \"Less than four distinct elements present in the list\"\n\n    lst.sort() # sort the list in ascending order\n\n    # the maximum product is either the product of the four highest numbers or\n    # the product of the two smallest numbers (which may be negative) and the two highest numbers.\n    return max(lst[-1] * lst[-2] * lst[-3] * lst[-4], lst[0] * lst[1] * lst[-1] * lst[-2])", "def longestIncreasingSubsequence(arr):\n    \"\"\"Function to find the longest increasing subsequence in a given array\"\"\"\n    n = len(arr)\n    # initialize the dp array \n    dp = [1] * n \n  \n    # Loop through the given array and compute \n    # other entries in the dp array \n    for i in range (1, n): \n        for j in range(i): \n            if (arr[i] > arr[j] and dp[i] < dp[j] + 1):\n                dp[i] = dp[j] + 1\n\n    # Find the maximum entry in the dp array\n    maximum = 0\n    for i in range(n): \n        if (maximum < dp[i]): \n            maximum = dp[i] \n\n    # return the longest increasing subsequence\n    return maximum"]}
{"task_id": 458, "content": ["def maxProfitWithTransactionFee(prices, fee):\n    \n    # Initialize an array for holding the maximum profit up to the current price.\n    # Initially, all elements in the array are 0.\n    n = len(prices)\n    maxProfit = [0]*n\n    \n    # Initialize the maximum profit after buying the stock as the negative of the first price.\n    maxProfitAfterBuy = -prices[0]\n    \n    for i in range(1, n):\n        # The maximum profit up to the current price can be either the maximum profit up to the previous price\n        # (i.e., not selling at the current price)\n        # or the maximum profit after buying the stock plus the current price minus the transaction fee\n        # (i.e., selling at the current price).\n        maxProfit[i] = max(maxProfit[i-1], maxProfitAfterBuy + prices[i] - fee)\n        # The maximum profit after buying the stock can be either the maximum profit after buying the stock up to the previous price\n        # (i.e., not buying at the current price)\n        # or the maximum profit up to the second to last price minus the current price\n        # (i.e., buying at the current price).\n        maxProfitAfterBuy = max(maxProfitAfterBuy, maxProfit[i-1] - prices[i])\n        \n    return maxProfit[-1]", "def max_profit(prices):\n    \"\"\"\n    Given a list of stock prices, return the maximum profit that can be achieved by making a single buy and sell transaction.\n    \n    Args:\n    prices: A list of integers representing the stock prices over a period of time\n    \n    Returns:\n    max_profit: An integer representing the maximum profit that can be achieved\n    \"\"\"\n    if not prices or len(prices) == 1:\n        return 0  # If there are no prices or only one price, no profit can be made\n    \n    min_price = prices[0]  # Initialize the minimum price as the first price\n    max_profit = 0  # Initialize the maximum profit as 0\n    \n    for price in prices:\n        if price < min_price:\n            min_price = price  # Update the minimum price if a lower price is encountered\n        else:\n            max_profit = max(max_profit, price - min_price)  # Update the maximum profit if a higher profit is found\n    \n    return max_profit", "def max_profit(stocks):\n  # Initialize the maximum profit to zero\n  max_profit = 0\n  \n  # Iterate over every stock\n  for i in range(len(stocks)-1):\n    current_stock = stocks[i]\n    \n    # Iterate over every stock after the current stock\n    for j in range(i+1, len(stocks)):\n      next_stock = stocks[j]\n      # Calculating the profit\n      curr_profit = next_stock - current_stock\n      \n      # Keeping the maximum value\n      max_profit = max(max_profit, curr_profit)\n  \n  return max_profit", "def find_max(a, b, c):\n    \"\"\"\n    A function to find the maximum of three numbers.\n    \"\"\"\n    # Find the maximum of the three numbers\n    max_value = max(a, b, c)\n    \n    return max_value", "def trade_stocks(stocks):\n    # Set max profit to 0 initially\n    max_profit = 0\n    \n    # Iterate through each stock to find the max profit\n    for i in range(len(stocks)-1):\n        for j in range(i+1, len(stocks)):\n            profit = stocks[j] - stocks[i]\n            if profit > max_profit:\n                buy_price = stocks[i]\n                sell_price = stocks[j]\n                max_profit = profit\n    \n    # Return the maximum profit and the associated buy and sell prices\n    return(max_profit, buy_price, sell_price)"]}
{"task_id": 459, "content": ["def reverse_list(numbers):\n    '''This function will reverse the order of the elements \n    of a given list.'''\n    numbers.reverse()", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def reverse_array(arr):\n    \"\"\"This function reverses the elements of a given array of numbers\n    \n    Parameters: \n        arr (list): The list of numbers to reverse.\n\t\n    Returns: The reversed array\n    \"\"\"\n    return arr[::-1]", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]"]}
{"task_id": 460, "content": ["def prefixesDivBy5(A):\n    res = []\n    remainder = 0\n    for i in A:\n        # Do a bit-wise left shift operation on 'remainder' and then add 'i'\n        # The result is modulo divided by 35 (since we want to check for divisibility by both 5 and 7)\n        # This is to avoid overflow because there could be maximum 30000 elements in the array A; because python supports only  30 bits for signed integers\n        remainder = (remainder << 1 | i) % 35  \n        # Check if the 'remainder' is divisible by both 5 and 7\n        res.append(remainder == 0)\n    return res", "def is_divisible_by_7_and_13(n):\n    # Get the quotient and remainder when n is divided by 7\n    quotient, remainder = divmod(n, 7)\n    if remainder != 0:\n        return False\n    # Get the quotient and remainder when n is divided by 13\n    quotient, remainder = divmod(n, 13)\n    if remainder != 0:\n        return False\n    # The number is divisible by both 7 and 13\n    return True", "def gcd(a, b):\n    # Make sure a is always the larger number\n    if a < b:\n        a, b = b, a\n\n    while b != 0:\n        # Calculate the remainder of a divided by b\n        remainder = a % b\n\n        # Set a to b and b to the remainder\n        a = b\n        b = remainder\n\n    return a", "def division_with_remainder(num1, num2):\n    quotient = num1 // num2  # integer division\n    remainder = num1 % num2  # remainder\n    print(f\"{num1} divided by {num2} is {quotient} with a remainder of {remainder}\")\n    return quotient", "def division_with_remainder(num1, num2):\n quotient = num1 // num2 # integer division\n remainder = num1 % num2 # remainder\n print(f\"{num1} divided by {num2} is {quotient} with a remainder of {remainder}\")\n return quotient"]}
{"task_id": 461, "content": ["def is_prime(num):\n    \"\"\" Function to check whether the number is prime or not \"\"\"\n\n    # Check whether the given number is greater than 1\n    if num > 1:\n        # Iterate through the range of numbers to check if any number is a multiple of the given number\n        for i in range(2,num):\n            # If there is any multiple, the number is not prime\n            if (num % i) == 0:\n                return False\n        # If there are no multiples, the number is prime\n        else:\n            return True", "def verify_divisibility_and_evenness(numbers, divisor):\n    ''' \n    This function accepts a list of numbers and a divisor then \n    verifies whether each number in the list is divisible by the divisor \n    and is even.\n\n    It returns a list of tuples, with each tuple containing a number \n    and a boolean value indicating whether that number satisfies the conditions\n    \n    @param numbers: List of numbers to be checked\n    @param divisor: The divisor to check divisibility\n    '''\n\n    # Validate inputs\n    if not isinstance(numbers, list) or not isinstance(divisor, int):\n        raise ValueError(\"Invalid Input. Only list of numbers and integer divisor are allowed\")\n    \n    return [ (num, num % divisor == 0 and num % 2 == 0) for num in numbers]", "def verify_divisibility_and_evenness(numbers, divisor):\n    ''' \n    This function accepts a list of numbers and a divisor then \n    verifies whether each number in the list is divisible by the divisor \n    and is even.\n\n    It returns a list of tuples, with each tuple containing a number \n    and a boolean value indicating whether that number satisfies the conditions\n    \n    @param numbers: List of numbers to be checked\n    @param divisor: The divisor to check divisibility\n    '''\n\n    # Validate inputs\n    if not isinstance(numbers, list) or not isinstance(divisor, int):\n        raise ValueError(\"Invalid Input. Only list of numbers and integer divisor are allowed\")\n    \n    return [ (num, num % divisor == 0 and num % 2 == 0) for num in numbers]", "def check_consecutive_indices(indices_list: List[int]) -> None:\n    expected_indices = list(range(len(indices_list)))  # Generate the expected consecutive indices\n    if indices_list != expected_indices:  # Check if the given indices match the expected consecutive sequence\n        raise Exception(f\"Subpopulation indices have to be consecutive integers from 0 to the total number of subpopulations. This is not the case. Given subpopulation indices are {indices_list}\")", "def is_palindrome(s): \n    '''This function returns True or False based on whether the given string is a palindrome or not'''\n    # reverse the string\n    rev = s[::-1] \n  \n    # Check if string is equal to its reverse \n    if (s == rev): \n        return True\n    return False"]}
{"task_id": 462, "content": ["def frequencySort(nums):\n    # collections.Counter(nums) gives the frequency of each element in the nums array.\n    # items() function returns a view object that displays a list of a dictionary's(an iterable) tuple pair (key, value).\n    c = Counter(nums).items()\n    # Then we will sort the results by the tuple (-count, num). Negative count ensures that high frequency elements come first in the sorted list.\n    # This satisfies the requirement to sort in increasing frequency. \n    # Because we use num for sort as well, elements with the same frequency are sorted in descending order.\n    # This satisfies the requirement to sort in decreasing order on the basis of value of the numbers in case of same frequency.\n    # idx is used to sort elements in increasing order of their index in case elements are same and have same frequency.\n    # sort function of python is stable. i.e, it maintains the relative order of items with equal sort keys\n    nums.sort(key = lambda x: (nums.count(x), -x, [i for i, n in enumerate(nums) if n == x][0]))\n    # return the sorted array\n    return nums", "def sort(list):\n    \"\"\"\n    This function sorts a given list in ascending order.\n\n    Parameters:\n    list (List[int, float, str]): A list of numerical or string values to be sorted. This list should contain elements of the same datatype for the function to work correctly. \n    \"\"\"\n    list.sort()", "def sort_desc(words):\n    '''This function will sort a given list of strings in descending order of their lengths.'''\n    words.sort(key=len, reverse=True)\n    return words", "def reverse_list(numbers):\n    '''This function will reverse the order of the elements \n    of a given list.'''\n    numbers.reverse()", "def transpose(matrix):\n    # The * operator is used to unzip a list (or other iterables), making a list of tuples where each tuple contains the i-th element from each of the argument sequences or iterables.\n    # The zip() function takes iterables, aggregates them in a tuple, and return the result.\n    # In other words, it returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.\n    return [list(i) for i in zip(*matrix)] "]}
{"task_id": 463, "content": ["def reverse_string(string):\n  '''\n  This function takes in a string and returns the string in reverse order.\n  \n  The algorithm works by iterating over the characters in the string in reverse, creating a new string with the reverse order of characters.\n  \n  :param string: string to be reversed\n  :return: string in reverse order\n  '''\n  \n  # Create a new, empty string to store the reversed string\n  reversed_string = \"\"\n  \n  # Iterate over the characters in the string in reverse order\n  for i in range(len(string)-1, -1, -1):\n    reversed_string += string[i]\n  \n  # Return the reversed string\n  return reversed_string", "def removeDuplicates(string): \n    # Create a regular expression pattern to match and remove duplicate characters\n    regx = re.compile('(.)(?=.*\\1)') \n    # Use the sub() function to replace all the occurrences of duplicate characters with an empty string\n    return regx.sub(\"\", string)", "def craft_malicious_snap():\n    # This is a hypothetical function. In a real-world scenario, you would need to\n    # write a script or use a tool to create a malicious snap package.\n    print(\"Crafting malicious snap package...\")\n    # Placeholder for snap package crafting logic\n    pass", "def compress_string(s):\n    # regex to match 3 or more of the same characters in a row\n    pattern = re.compile(r'(.)\\1{2,}')\n    \n    # function to replace matches with the character and its count\n    repl = lambda m: m.group(1) + str(len(m.group(0)))\n    \n    # replace matches in the string\n    compressed = re.sub(pattern, repl, s)\n    \n    return compressed", "def arrange_string(s):\n    \"\"\"\n    This function takes a string 's', splits it into words, applies the custom_order function to each word to sort the characters in it,\n    and then rejoins the sorted words back together with a space in between. The function preserves the original order of words \n    and blank spaces in the sentence.\n    \"\"\"\n\n    # Split the string into a list of words\n    words_list = s.split(' ')\n\n    # Apply the custom_order function to each word in the list\n    ordered_words_list = [custom_order(word) for word in words_list]\n\n    # Join the ordered words back together with a space in between to form a string\n    ordered_s = ' '.join(ordered_words_list)\n\n    return ordered_s"]}
{"task_id": 464, "content": ["def top_n_frequent_keys(dictionary, n):\n    counter = Counter(dictionary) # Convert the dictionary into a counter object\n    counter_sorted_by_value = sorted(counter.items(), key=operator.itemgetter(1), reverse=True) # Sort the counter by value\n    counter_sorted_by_key = sorted(counter_sorted_by_value, key=operator.itemgetter(0)) # Sort the counter by key\n    counter_sorted_by_key_value = sorted(counter_sorted_by_key, key=operator.itemgetter(1), reverse=True) # Sort the counter by value again to get the final sorted list\n    return dict(counter_sorted_by_key_value[:n]) # Convert the list of tuples back to dictionary and return the top 'n' items", "def sort_by_abs_value(lst):\n    \"\"\"This function will take a list of numbers and sort them by their absolute value.\"\"\"\n\n    # Sort the list by absolute value\n    lst.sort(key=lambda x: abs(x))\n\n    # Return the sorted list\n    return lst", "def uncommon_elements_optimized(sequence):\n    '''\n    Complete this function:\n    '''\n\n    counter = Counter(sequence)\n    \n    result = [k for k, v in counter.items() if v > k/2]\n    \n    result.sort(key=lambda x: (-counter[x], x))  #first sort by the negated count so that high counts come first, and then sort by the integer value\n    \n    return result", "def frequencySort(nums):\n    # collections.Counter(nums) gives the frequency of each element in the nums array.\n    # items() function returns a view object that displays a list of a dictionary's(an iterable) tuple pair (key, value).\n    c = Counter(nums).items()\n    # Then we will sort the results by the tuple (-count, num). Negative count ensures that high frequency elements come first in the sorted list.\n    # This satisfies the requirement to sort in increasing frequency. \n    # Because we use num for sort as well, elements with the same frequency are sorted in descending order.\n    # This satisfies the requirement to sort in decreasing order on the basis of value of the numbers in case of same frequency.\n    # idx is used to sort elements in increasing order of their index in case elements are same and have same frequency.\n    # sort function of python is stable. i.e, it maintains the relative order of items with equal sort keys\n    nums.sort(key = lambda x: (nums.count(x), -x, [i for i, n in enumerate(nums) if n == x][0]))\n    # return the sorted array\n    return nums", "def sort_dict_list(dict_list, attr_list, default_val=\"\"):\n    \"\"\"\n    Sort a list of dictionaries by multiple attributes. Non-existing attributes are handled\n    and have a lower sort priority.\n\n    Args:\n      dict_list: List of dictionaries to be sorted\n      attr_list: List of attributes to sort by\n      default_val: Default return value when attribute is not present in a dictionary\n\n    Returns:\n      Sorted list of dictionaries\n    \"\"\"\n    return sorted(dict_list, key=lambda d: tuple(d.get(attr, default_val) for attr in attr_list))"]}
{"task_id": 465, "content": ["def longest_common_prefix(strs):\n    if not strs: return \"\"\n    \n    #Sort the array\n    strs.sort()\n    \n    #The result will be characters of the smallest string.\n    res = []\n    \n    #The smallest and the largest strings in the array.\n    smallest, largest = strs[0], strs[-1]\n    \n    #Find the smallest length string in the array\n    for i in range(len(smallest)):\n        #Check if the characters match in the smallest and the largest strings.\n        if smallest[i] == largest[i]:\n            res.append(smallest[i])\n        else:\n            return \"\".join(res)\n    return \"\".join(res)", "def find_max(arr):\n    \"\"\"\n    Function to find the largest numerical value in an array. \n\n    Parameters:\n    arr (list): The list of integers.\n  \n    Returns:\n    max_val (int): The largest numerical value in the array.\n  \n    \"\"\"\n    \n    # Step 1: Initialize a variable max_val with the value at the 0th index in the array\n    max_val = arr[0]\n\n    # Step 2: Iterate over each element in the array from 1 to n-1\n    for i in range(1, len(arr)):\n        # Step 3: If the value at the current index in the array is greater than max_val, update max_val\n        if arr[i] > max_val:\n            max_val = arr[i]\n\n    # Step 4: Return max_val, which now holds the largest numerical value in the array\n    return max_val", "def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers.", "def search_for_index(array, value):\n    '''\n    This function will search for the index of a given value in an array.\n    \n    Args:\n        array (list): the array to be searched\n        value (object): the value to be searched for\n\n    Returns:\n        int: the index of the value if found, -1 otherwise\n    '''\n    try:\n        return array.index(value)\n    except ValueError:\n        return -1", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]"]}
{"task_id": 466, "content": ["def binary_to_decimal(binaryNum):\n    try:\n        # Use int() function in python with 2 as base argument to convert binary string into decimal.\n        # int(string, base)\n        return int(binaryNum, 2)\n    except ValueError:\n        # If binaryNum is not a valid binary number, int() function will raise a ValueError.\n        # Return error message in case of exception\n        return \"Invalid binary input\"", "def is_palindrome(s):\n    # The translation table is created with maketrans function to remove all punctuation\n    # and .lower() function is used to convert string into lower case.\n    s = s.translate(str.maketrans('', '', string.punctuation)).replace(\" \", \"\").lower()\n    return s == s[::-1]", "def shared_vowels(s1, s2, s3):\n    '''\n    This function finds all shared vowels in three given strings, \n    disregarding their case.\n\n    Arguments: s1, s2, s3: input strings\n    Returns: a set of shared vowels\n    '''\n\n    # Convert the strings to lower case\n    s1 = s1.lower()\n    s2 = s2.lower()\n    s3 = s3.lower()\n\n    # Define a set of vowels\n    vowels = set('aeiou')\n\n    # Find the intersection of vowels and each string\n    return vowels.intersection(s1, s2, s3)", "def is_palindrome(s):\n    \"\"\"\n    Checks if the given string is a palindrome\n\n    :param s: the string to be checked\n    :returns: True if the string is a palindrome, False otherwise\n    \"\"\"\n    # remove all non-alphanumeric characters\n    s = ''.join([c for c in s if c.isalnum()])\n    # convert to lower case\n    s = s.lower()\n    # compare reversed string to the original\n    return s == s[::-1]", "def convert_to_upper(string):\n    \"\"\"Function to convert the given string to all capital letters using an algorithm. Input should be a string.\"\"\"\n    result = ''\n    for char in string:\n        result += chr(ord(char) - 32)\n    return result"]}
{"task_id": 467, "content": ["def parse_string(pattern, string):\n    '''\n    This function parses a string and returns the substrings which are enclosed in the given pattern.\n    \n    Parameters\n    ----------\n    pattern : str\n        The given pattern\n    string : str\n        The given string\n    \n    Returns\n    -------\n    List\n        Contains substrings enclosed within the given pattern.\n    '''\n    # Initialize list to store substrings\n    sub_strings = []\n    \n    # Get the start and end positions of each substring\n    start = string.find(pattern)\n    end = string.find(pattern, start+1)\n    \n    # Iterate through the string\n    while start >= 0 and end > start:\n        # Get substring and append to list\n        sub_strings.append(string[start+len(pattern):end])\n        \n        # Get new start and end positions\n        start = end\n        end = string.find(pattern, start+1)\n    \n    # Return list of substrings\n    return sub_strings", "def delete_last_char(string):\n    \"\"\"Delete the last character of a given string.\n\n    Args:\n        string (str): The string to remove the last character from. \n\n    Returns:\n        str: The string with the last character removed.\n    \"\"\"\n    return string[:-1]", "def lowercase(string):\n    \"\"\"\n    Converts a string from all uppercase to all lowercase.\n    Parameters:\n        str string: The string to convert.\n    Returns:\n        str: The converted string.\n    \"\"\"\n    return string.lower()", "def enumerate_substring(string):\n    '''This algorithm enumerates all possible substrings of a given string.'''\n    substrings = []\n    for i in range(len(string)):\n        for j in range(i + 1, len(string) + 1):\n            substrings.append(string[i:j])\n    return substrings", "def delete_element(my_list, pos):\n    \"\"\"Function to delete an element from a given list at a given position.\"\"\"\n    del my_list[pos]\n    return my_list"]}
{"task_id": 468, "content": ["def find_index_of_first_occurrence(string, character):\n    '''\n    This function will find the index of the first occurrence of a given character in a string.\n\n    Args:\n        string (str): the string to be searched\n        character (str): the character to be searched for\n\n    Returns:\n        int: the index of the first occurrence of the character\n    '''\n    return string.find(character)", "def inject_payload(pid, payload):\n    # This function would need to be implemented to attach to the process,\n    # find the system call table, and modify it to point to the custom handler.\n    # This is a complex task that typically requires kernel-level access and\n    # is beyond the scope of a simple Python script.\n    pass", "def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def factorial_digit(number):\n    # Transform the number into a string to manipulate as array\n    number_str = str(number)\n\n    # Apply math.factorial() function to each digit of the number\n    result = [math.factorial(int(digit)) for digit in number_str]\n\n    return result", "def add_digits(number):\n    \"\"\"This function adds all the digits of a given number \n    and returns the result.\n    \n    Args:\n        number (int): The number to process.\n    \n    Returns:\n        int: The result of adding all the digits of the given number.\n    \"\"\"\n    if number < 10:\n        return number\n    total = number % 10 + add_digits(number // 10)\n    return total"]}
{"task_id": 469, "content": ["def highest_occurring_character(string):\n    \"\"\"Find the highest occurring character in a string.\"\"\"\n\n    # Initialise a dictionary to store the number of occurrences of each character\n    char_occurrences = {}\n\n    # Store the number of occurrences of each character\n    for char in string:\n        char_occurrences[char] = char_occurrences.get(char, 0) + 1\n\n    # Find the maximum occurrence of all the characters\n    max_occurrence = 0\n    highest_occurring_char = None\n\n    # Iterate over the occurrence dictionary to find the highest occurrence\n    for char, occurrence in char_occurrences.items():\n        if occurrence > max_occurrence:\n            max_occurrence = occurrence\n            highest_occurring_char = char\n\n    return highest_occurring_char", "def find_index_of_first_occurrence(string, character):\n    '''\n    This function will find the index of the first occurrence of a given character in a string.\n\n    Args:\n        string (str): the string to be searched\n        character (str): the character to be searched for\n\n    Returns:\n        int: the index of the first occurrence of the character\n    '''\n    return string.find(character)", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count", "def count_character_types(s):\n    # Initialize counters\n    alphabetic_count = 0\n    numeric_count = 0\n    special_character_count = 0\n\n    # Iterate through each character in the input string\n    for ch in s:\n        # Check if character is an alphabet using Python's built-in function\n        if ch.isalpha():\n            alphabetic_count += 1\n            \n        # Check if character is a number using Python's built-in function\n        elif ch.isdigit():\n            numeric_count += 1\n            \n        # If the character is neither an alphabet nor a number, it's a special character.\n        elif ch.isspace() == False:\n            special_character_count += 1\n\n    return (alphabetic_count, numeric_count, special_character_count)"]}
{"task_id": 470, "content": ["def find_all_subsets_sum(arr):\n    '''\n    This function finds all the possible combinations of subsets \n    of a given array, whose sums equal a given number.\n    '''\n    n = len(arr)\n    res = []\n     \n    # Calculate the sum of all elements in the array \n    arr_sum = sum(arr)\n\n    # Iterate for all the possible subsets with sum \n    for i in range(2**n): \n        subset = []\n        subset_sum = 0\n\n        for j in range(n): \n            # Check if the jth bit in the i is set.\n            # If set, then add the element to the subset\n            if i & (2**j): \n                subset_sum += arr[j] \n                subset.append(arr[j])\n\n        if subset_sum == arr_sum:\n            res.append(subset)\n     \n    return res", "def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def is_armstrong_number(num):\n    # Convert the number to a string\n    num_str = str(num)\n    \n    # Get the length of the number\n    length = len(num_str)\n    \n    # Calculate the sum of powers of each digit\n    armstrong_sum = sum(int(digit) ** length for digit in num_str)\n    \n    # Check if the calculated sum is equal to the given number\n    return armstrong_sum == num", "def findCombinations(array, total):\n    \"\"\"\n    This function will find all possible combinations of integers in the given array that sum up to the given total.\n    Args:\n        array (list): List of integers.\n        total (int): Total to be reached with the combination of integers.\n    \n    Returns:\n        A list of lists containing the combinations of integers.\n    \"\"\"\n    combinations = []  # list to store the possible combinations\n    for i in range(1 << len(array)):  # loop through all combinations of bits\n        combination = []  # list to store the current combination\n        for j in range(len(array)):  # loop through array elements\n            if i & (1 << j):  # check if bit is set\n                combination.append(array[j])  # add array element to combination\n        if sum(combination) == total:  # check if combination sums to given total\n            combinations.append(combination)  # add combination to list of combinations\n\n    return combinations", "def contains_characters(url, characters):\n    '''\n    This function will determine if a given URL contains certain characters.\n    \n    Args:\n        url (str): the URL to be checked\n        characters (list): a list of characters to be searched\n\n    Returns:\n        bool: True if the URL contains any of the given characters, False otherwise\n    '''\n    for character in characters:\n        if character in url:\n            return True\n    \n    return False"]}
{"task_id": 471, "content": ["def count_word_occurrences(s):\n    # Normalizing the string to lower case\n    s = s.lower()\n    # Using regex to find all words in the string (words are defined as 1 or more letter characters)\n    words = re.findall(r'\\b\\w+\\b', s)\n\n    # Using Counter to count occurrences of each word\n    word_count = Counter(words)\n    return word_count", "def check_dict_case(d):\n    if not d: \n        # If the dictionary is empty, return False\n        return False \n\n    lower = 0\n    upper = 0\n\n    # Iterate over all keys in the dictionary\n    # Check if key is upper or lower case\n    for key in d:\n        if key.islower():\n            lower += 1\n        elif key.isupper():\n            upper += 1   \n        else:\n            # If key contains a mix of upper and lower case letters, return False\n            return False\n\n    # If all keys are either upper case or lower case, return True. Else, return False. \n    if lower == len(d) or upper == len(d):\n        return True\n    else:\n        return False", "def count_word_occurrences(s):\n    # Normalizing the string to lower case\n    s = s.lower()\n    # Using regex to find all words in the string (words are defined as 1 or more letter characters)\n    words = re.findall(r'\\b[a-zA-Z]+\\b', s)\n\n    # Using Counter to count occurrences of each word\n    word_count = Counter(words)\n    return word_count", "def generate_sequence():\n    # Generate a list of all lower case letters and digits.\n    all_chars = string.ascii_lowercase + string.digits\n\n    # Randomly choose one lower case letter and one digit.\n    letter = random.choice(string.ascii_lowercase)\n    digit = random.choice(string.digits)\n\n    # Generate 4 other chars randomly from the list of all characters.\n    other_chars = ''.join(random.choices(all_chars, k=4))\n  \n    # Combine the letter, digit and other characters into one string.\n    sequence = letter + digit + other_chars\n\n    # Randomly shuffle the sequence to ensure unpredictability.\n    sequence = ''.join(random.sample(sequence, len(sequence)))\n\n    return sequence", "def custom_order(s):\n    \"\"\"\n    This function takes a string 's' and sorts the letters in it based on their ASCII values, ignoring case. It then sorts them based on the count of each letter in the string, conserving the original letter casing.\n    \"\"\"\n\n    # Convert the string to a list of characters\n    s_list = list(s)\n\n    # This line sorts the list first by the ASCII value of each character in a case-insensitive manner, \n    # then by the count of the character in the string (which prioritizes letters with higher counts), \n    # and finally by the position of the character in the original string (to preserve the original order of equal elements).\n    s_list.sort(key=lambda x: (ord(x.lower()), -s_list.count(x), s_list.index(x)))\n\n    # Convert the sorted list of characters back into a string \n    sorted_s = ''.join(s_list)\n\n    return sorted_s"]}
{"task_id": 472, "content": ["def is_prime(n):\n    # A prime number is a natural number greater than 1 that cannot be \n    # formed by multiplying two smaller natural numbers, so 0 and 1 are not prime.\n    if n == 0 or n == 1:\n        return False\n\n    # Check divisibility for numbers from 2 to n/2\n    for i in range(2, n // 2):\n        # If n is divisible by any number between 2 and n/2\n        # it is not prime\n        if n % i == 0:\n            return False\n    # If not divisible, then it is a prime number\n    return True", "def is_divisible_by_3_and_5(number):\n    \"\"\"This function checks whether a number is divisible by 3 and 5.\n\n    Parameters: \n        number (int): The number to be checked.\n\t\n    Returns: \n        True if the number is divisible by both 3 and 5, False otherwise.\n    \"\"\"\n    if (number % 3 == 0) and (number % 5 == 0):\n        return True\n    else:\n        return False", "def solve(n, m):\n    if n < 1 or n > 7 or n % 2 == 0:\n        return 'The number must be an odd integer between 1 and 7.'\n    else:\n        factorial_n = factorial(n)\n        if factorial_n % m == 0:\n            return f'The factorial of {n} is {factorial_n}, which is divisible by {m}.'\n        else:\n            return f'The factorial of {n} is {factorial_n}, which is not divisible by {m}.'", "def is_divisible(x, y):\n    \"\"\"Checks if a number is divisible by another number.\"\"\"\n    if x % y == 0:\n        return True\n    else:\n        return False", "def sum_of_cubes(number):\n    # Convert the integer to a string to access its individual digits\n    number_str = str(number)\n    \n    # Initialize a variable to store the sum of cubes\n    sum_of_cubes = 0\n    \n    # Iterate through each digit in the string representation of the number\n    for digit in number_str:\n        # Convert the digit back to integer and cube it\n        cube = int(digit) ** 3\n        # Add the cube to the sum_of_cubes variable\n        sum_of_cubes += cube\n    \n    # Check if the sum of cubes is divisible by 7\n    if sum_of_cubes % 7 == 0:\n        # Return the sum of cubes if it is divisible by 7\n        return sum_of_cubes\n    else:\n        # Return \"Not divisible by 7\" if the sum of cubes is not divisible by 7\n        return \"Not divisible by 7\""]}
{"task_id": 473, "content": ["def sort_by_second_item(tuples):\n    \"\"\"Sorts a list of tuples by the second item in the tuples.\n    \n    Args:\n        tuples: A list of tuples to be sorted.\n        \n    Returns:\n        sorted_list: The sorted list of tuples.\n    \"\"\"\n    sorted_list = sorted(tuples, key=lambda x: x[1])\n    \n    return sorted_list", "def sort_list(tuples):\n    \"\"\"\n    A function to sort a list of tuples by the second item in each tuple.\n    \"\"\"\n    return sorted(tuples, key=lambda x: x[1])", "def transpose(matrix):\n    # The * operator is used to unzip a list (or other iterables), making a list of tuples where each tuple contains the i-th element from each of the argument sequences or iterables.\n    # The zip() function takes iterables, aggregates them in a tuple, and return the result.\n    # In other words, it returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.\n    return [list(i) for i in zip(*matrix)] ", "def sort_strings(strings):\n    # Remove duplicates from the list\n    strings = list(set(strings))\n    \n    # Create a list of tuples with string length and string itself\n    tuples = [(len(s), s) for s in strings]\n    \n    # Sort the list of tuples by length and alphabetically\n    tuples.sort(key=lambda x: (-x[0], x[1]))\n    \n    # Return the sorted strings\n    return [t[1] for t in tuples]", "def get_word_frequency_tuples(preprocessed_tokens):\n    # Get the word frequencies using the get_word_frequencies function\n    word_freq = get_word_frequencies(preprocessed_tokens)\n    \n    # Convert the dictionary of word frequencies to a list of tuples\n    word_freq_tuples = list(word_freq.items())\n    \n    # Sort the list of tuples by frequency in descending order\n    word_freq_tuples.sort(key=lambda x: x[1], reverse=True)\n    \n    # Return the list of tuples\n    return word_freq_tuples"]}
{"task_id": 474, "content": ["def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def largest_prime(arr):\n    \"\"\"Function to find the largest prime in the array\"\"\"\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    # Iterate over the array\n    for num in arr:\n        if is_prime(num):\n            # return the first prime number encountered\n            return num\n    # return None if no prime is found\n    return None", "def search_array(num, arr):\n    \"\"\"\n    This function searches for a number in the given array. \n    \n    Input:\n    num: The number to search for\n    arr: The array in which to search\n\n    Output: \n    returns True if the number is found. Otherwise, returns False\n    \"\"\"\n    \n    # iterate through the array\n    for i in range(0, len(arr)):\n        # if the current number equals the number being searched for, \n        # return True because we found the number\n        if arr[i] == num:\n            return True\n    \n    # after searching all elements, if we didn't find the number, return False\n    return False", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def find_max(arr):\n    \"\"\"\n    Function to find the largest numerical value in an array. \n\n    Parameters:\n    arr (list): The list of integers.\n  \n    Returns:\n    max_val (int): The largest numerical value in the array.\n  \n    \"\"\"\n    \n    # Step 1: Initialize a variable max_val with the value at the 0th index in the array\n    max_val = arr[0]\n\n    # Step 2: Iterate over each element in the array from 1 to n-1\n    for i in range(1, len(arr)):\n        # Step 3: If the value at the current index in the array is greater than max_val, update max_val\n        if arr[i] > max_val:\n            max_val = arr[i]\n\n    # Step 4: Return max_val, which now holds the largest numerical value in the array\n    return max_val"]}
{"task_id": 475, "content": ["def binomial_probability(n, p, x):\n    \"\"\"Find the probability of an event using the binomial distribution.\n\n    Args:\n        n (int): The number of trials.\n        p (float): The probability of success of the event.\n        x (int): The number of successes.\n\n    Returns:\n        float: The probability of x successes in n trials.\n    \"\"\"\n    return factorial(n)/(factorial(x)*factorial(n-x)) * p**x * (1-p)**(n-x)", "def heuristic_function(canonicalBoard):\n    # Implement your heuristic function here\n    # This function should take the canonicalBoard as input and return a heuristic probability distribution over the valid moves\n    # Example heuristic function:\n    # Calculate heuristic values for each valid move based on the current board state\n    # Normalize the heuristic values to obtain a probability distribution\n    # Return the probability distribution as a list or array\n\n    # Example heuristic function:\n    # Calculate heuristic values for each valid move based on the current board state\n    heuristic_values = calculate_heuristic_values(canonicalBoard)\n    \n    # Normalize the heuristic values to obtain a probability distribution\n    heuristic_distribution = normalize_heuristic_values(heuristic_values)\n    \n    return heuristic_distribution", "def calculate_probability(outcome_1, outcome_2, event):\n    '''Calculates the probability of a given event, given two mutually exclusive outcomes.'''\n    num_outcomes = 2\n\n    if event == outcome_1:\n        probability = 1/num_outcomes\n    elif event == outcome_2:\n        probability = 1/num_outcomes\n    else:\n        probability = 0\n\n    return probability ", "def conditional_probability(event1, event2):\n    # Here we arbitrarily define the joint probability as the product of their probabilities.\n    # This is not always valid as A and B are not always independent. You will need to adjust this \n    # according to you specific problem.\n    joint_probability = prob_dict[event1] * prob_dict[event2]\n\n    # Conditional probability of event1 given event2 is \n    # the ratio of the joint probability to the probability of event2.\n    return joint_probability / prob_dict[event2]", "def normalize_heuristic_values(heuristic_values):\n    # Implement the normalization of heuristic values to obtain a probability distribution\n    # This function should return a normalized probability distribution based on the input heuristic values\n\n    # Example: Normalize the heuristic values to obtain a probability distribution\n    total = sum(heuristic_values)\n    heuristic_distribution = [value / total for value in heuristic_values]\n    \n    return heuristic_distribution"]}
{"task_id": 476, "content": ["def frequencySort(nums):\n    # collections.Counter(nums) gives the frequency of each element in the nums array.\n    # items() function returns a view object that displays a list of a dictionary's(an iterable) tuple pair (key, value).\n    c = Counter(nums).items()\n    # Then we will sort the results by the tuple (-count, num). Negative count ensures that high frequency elements come first in the sorted list.\n    # This satisfies the requirement to sort in increasing frequency. \n    # Because we use num for sort as well, elements with the same frequency are sorted in descending order.\n    # This satisfies the requirement to sort in decreasing order on the basis of value of the numbers in case of same frequency.\n    # idx is used to sort elements in increasing order of their index in case elements are same and have same frequency.\n    # sort function of python is stable. i.e, it maintains the relative order of items with equal sort keys\n    nums.sort(key = lambda x: (nums.count(x), -x, [i for i, n in enumerate(nums) if n == x][0]))\n    # return the sorted array\n    return nums", "def sort_strings(strings):\n    # Convert list of strings to list of tuples\n    # Each tuple consists of (string, index)\n    sorted_tuples = [(string, i) for i, string in enumerate(strings)]\n\n    # Sort the tuples in increasing order of strings\n    sorted_tuples.sort(key=lambda t: t[0])\n\n    # Convert the sorted tuples to a sorted list\n    sorted_list = [t[0] for t in sorted_tuples]\n\n    return sorted_list", "def transpose(matrix):\n    # The * operator is used to unzip a list (or other iterables), making a list of tuples where each tuple contains the i-th element from each of the argument sequences or iterables.\n    # The zip() function takes iterables, aggregates them in a tuple, and return the result.\n    # In other words, it returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.\n    return [list(i) for i in zip(*matrix)] ", "def sort_list(tuples):\n    \"\"\"\n    A function to sort a list of tuples by the second item in each tuple.\n    \"\"\"\n    return sorted(tuples, key=lambda x: x[1])", "def sort_tuples(tuples):\n    # Validate input\n    if type(tuples) != list:\n        raise TypeError(\"Input should be a list of tuples.\")\n\n    for t in tuples:\n        if type(t) != tuple or len(t) != 2 or not all(isinstance(n, int) for n in t):\n            raise TypeError(\"All elements should be tuples of two integers.\")\n\n    # Sort tuples by second element in descending order and then first element in descending order\n    tuples.sort(key=lambda x: (-x[1], -x[0]))\n\n    return tuples"]}
{"task_id": 477, "content": ["def calculate_circle_area(radius, pi=3.14):\n    \"\"\"\n    Create a function that takes two arguments and calculates the area of a circle.\n    The radius is the required argument, and the value of pi is optional (default is 3.14).\n    \"\"\"\n    area = pi * radius * radius\n    return area", "def data_exfiltration():\n    # This function represents the extraction of data from the compromised systems.\n    # In a real-world scenario, this would involve copying or transferring data to a controlled area.\n    # For ethical hacking, this step is typically performed by a third-party security professional.\n    pass", "def total_area(rectangles):\n    \"\"\"\n    Function to calculate total area for a list of rectangles.\n    \"\"\"\n    area = 0\n    for rectangle in rectangles:\n        # If rectangle is not a pair of points, raise an error.\n        if not isinstance(rectangle, tuple) or len(rectangle) != 2:\n            raise ValueError(\"Invalid rectangle data: {}. Rectangle should be a tuple of 2 points.\".format(rectangle))\n        else:\n            area += rectangular_area(*rectangle)\n    return area", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass", "def calculate_area_triangle(a, b, c):\n    '''This function will calculate the area of a triangle given the three sides as parameters.'''\n    s = (a + b + c) / 2\n    area = (s*(s-a)*(s-b)*(s-c)) ** 0.5\n    return area"]}
{"task_id": 478, "content": ["def find_max(arr):\n    \"\"\"\n    Function to find the largest numerical value in an array. \n\n    Parameters:\n    arr (list): The list of integers.\n  \n    Returns:\n    max_val (int): The largest numerical value in the array.\n  \n    \"\"\"\n    \n    # Step 1: Initialize a variable max_val with the value at the 0th index in the array\n    max_val = arr[0]\n\n    # Step 2: Iterate over each element in the array from 1 to n-1\n    for i in range(1, len(arr)):\n        # Step 3: If the value at the current index in the array is greater than max_val, update max_val\n        if arr[i] > max_val:\n            max_val = arr[i]\n\n    # Step 4: Return max_val, which now holds the largest numerical value in the array\n    return max_val", "def frequencySort(nums):\n    # collections.Counter(nums) gives the frequency of each element in the nums array.\n    # items() function returns a view object that displays a list of a dictionary's(an iterable) tuple pair (key, value).\n    c = Counter(nums).items()\n    # Then we will sort the results by the tuple (-count, num). Negative count ensures that high frequency elements come first in the sorted list.\n    # This satisfies the requirement to sort in increasing frequency. \n    # Because we use num for sort as well, elements with the same frequency are sorted in descending order.\n    # This satisfies the requirement to sort in decreasing order on the basis of value of the numbers in case of same frequency.\n    # idx is used to sort elements in increasing order of their index in case elements are same and have same frequency.\n    # sort function of python is stable. i.e, it maintains the relative order of items with equal sort keys\n    nums.sort(key = lambda x: (nums.count(x), -x, [i for i, n in enumerate(nums) if n == x][0]))\n    # return the sorted array\n    return nums", "def search_for_index(array, value):\n    '''\n    This function will search for the index of a given value in an array.\n    \n    Args:\n        array (list): the array to be searched\n        value (object): the value to be searched for\n\n    Returns:\n        int: the index of the value if found, -1 otherwise\n    '''\n    try:\n        return array.index(value)\n    except ValueError:\n        return -1", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def find_mode(arr):\n    # create a dictionary to store the frequency of each element in the array\n    freq_dict = {}\n    \n    # iterate through the array and keep a record of the frequency\n    for num in arr:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n            \n    # find the element with the highest frequency \n    max_freq = 0\n    mode = None\n    for key, value in freq_dict.items():\n        if value > max_freq:\n            max_freq = value\n            mode = key\n    return mode"]}
{"task_id": 479, "content": ["def vowel_count(text):\n    # All the vowels\n    vowels = 'aeiouAEIOU'\n\n    # Using list comprehension to get the count.\n    # The expression 'char in vowels' will be True if the character is a vowel.\n    # So, we are making a list of True for all characters in the text which are vowels.\n    # Finally we are returning the sum of the list which gives us the count of True in the list\n    # which is equal to the count of vowels in the text.\n    return sum(char in vowels for char in text)", "def find_symmetric_pairs(nums):\n    \"\"\"\n    Function to find symmetric pairs in a list of integers.\n\n    Arguments:\n    nums {list} -- List of integers to search for symmetric pairs.\n\n    Returns:\n    List of tuples representing symmetric pairs.\n    \"\"\"\n    pairs = []\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                pairs.append((nums[i], nums[j]))\n    return pairs", "def draw_edges(self, keys=None, color=None):\n    \"\"\"Draw a selection of edges of the network.\n\n    Parameters\n    ----------\n    keys : list\n        A list of edge keys (as uv pairs) identifying which edges to draw.\n        The default is ``None``, in which case all edges are drawn.\n    color : str, tuple, dict\n        The color specification for the edges.\n        Colors should be specified in the form of a string (hex colors) or RGB tuple.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    if keys is None:  # If no specific edges are provided, draw all edges\n        keys = self.get_all_edge_keys()\n\n    if color is None:  # If no specific color is provided, use default color\n        color = (0, 0, 0)  # Default color: black\n\n    for key in keys:\n        edge = self.get_edge_by_key(key)\n        edge.draw(color)  # Draw the edge using the specified color", "def is_item_in_list(item, my_list):\n    '''This function checks if an item exists in a given list and returns a boolean value.\n    Parameters\n    ----------\n    item: The item to be checked.\n    my_list: The list in which the item is to be checked. \n    \n    Returns\n    --------\n    boolean: True if the item is present in the list, and False if it is not.\n    '''\n\n    return item in my_list", "def match_text(text, search_string):\n    \"\"\"Returns all occurrences of substring in the given string with case and pattern insensitivity.\n\n    Args:\n    text (str): A string.\n    search_string (str): The substring for which to search.\n\n    Returns:\n    A list of all occurrences in the given string.\n    \"\"\"\n    matches = []\n    # Construct a case and pattern insensitive regex expression\n    search_string = re.compile(search_string, re.IGNORECASE)\n    # Search the string and add the matches to a list\n    for match in search_string.finditer(text):\n        matches.append(match.group(0))\n\n    return matches"]}
{"task_id": 480, "content": ["def geometric_progression(a, r=3, n=5):\n    # calculate the sum of geometric progression\n    sum = a * (1 - r**n) / (1 - r)\n    \n    # check if sum is within specified range\n    if 300 <= sum <= 1200:\n        # print the sum and terms of geometric progression\n        print(f'Sum of geometric progression: {sum}.')\n        print('Terms of geometric progression:')\n        for i in range(n):\n            term = a * r**i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of geometric progression is not within valid range, but {sum}.')", "def geometric_progression(a, r=3, n=5):\n    # calculate the sum of the geometric progression\n    sum = a * (1 - r**n) / (1 - r)\n    \n    # check if the sum falls within the specified range\n    if 300 <= sum <= 1200:\n        # print the sum and terms of the geometric progression\n        print(f'The sum of the geometric progression is: {sum}.')\n        print('Terms of the geometric progression:')\n        for i in range(n):\n            term = a * r**i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of the geometric progression is not within the valid range, but {sum}.')", "def geometric_progression(n):\n    \"\"\"\n    Generate a geometric progression where each element is double the previous one\n    \n    :param n: The number of elements to generate\n    :type n: int\n    :return: the first n elements of the geometric progression\n    :rtype: list\n    \"\"\"\n    # validating the input\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Invalid input! Please enter a positive integer.\")\n      \n    array = [1] # initialize the first element of the sequence\n   \n    # Generate the sequence\n    for i in range(1, n):\n        array.append(array[i-1] * 2)\n    return array", "def generate_series(n):\n   # Create an empty list to store the series.\n   series_list = []\n   \n   # Keep track of the sum of the series.\n   cur_sum = 0\n   \n   # Generate numbers until the current sum is greater than or equal to N.\n   while cur_sum < n:\n       # Generate a random number between 0 and N.\n       rand_num = random.randint(0, n)\n       \n       # Check if the number can be added to the series without exceeding N.\n       if cur_sum + rand_num <= n:\n           # Add the number to the series list.\n           series_list.append(rand_num)\n           \n           # Increment the current sum by the new number.\n           cur_sum += rand_num\n           \n   # Return the generated series.   \n   return series_list", "def is_geometric_progression(arr):\n    '''Check if the list is in geometric progression'''\n\n    if len(arr) < 2:\n        return True    # the empty list and a 1-element list are both trivially a geometric progression\n    \n    # divide two consecutive elements and store the ratio\n    ratio = arr[1] / float(arr[0]) if arr[0] else False\n    \n    for i in range(1, len(arr)):\n        if arr[i] and arr[i-1] / float(arr[i]) != ratio or not arr[i] and arr[i-1]: \n            # if the ratio of two consecutive elements differs from the first ratio or we encounter zero but the previous number was non-zero,\n            # then it's not a geometric progression\n            return False        \n    \n    return True"]}
{"task_id": 481, "content": ["def find_element(arr, predicate):\n    \"\"\"\n    Find an element in a given array that satisfies the given predicate.\n    \n    :param arr: list, the array to search\n    :param predicate: function, a function to check for predicate satisfaction\n    \n    :returns: element if found, otherwise None\n    \"\"\"\n    \n    for element in arr:\n        if predicate(element):\n            return element\n    return None", "def linear_search(arr, element):\n    \"\"\"Searches for an element in an array using linear search\n    \n    Parameters\n    ------------\n    arr: the array to search in\n    element: the element to search for\n    \n    Returns\n    ------------\n    The index of the element in the array, or -1 if it is not found\n    \"\"\"\n    # search for the element in the array\n    for i in range(len(arr)):\n        if arr[i] == element:\n            return i\n    \n    # element not found\n    return -1", "def binarySearch(array, target):\n    '''This function will implement the binary search algorithm.\n\n    Args:\n        array (list): An array of elements.\n        target (int): The element to search for.\n\n    Returns:\n        int: The index of the target in the given array.\n    '''\n    # Initialize the first and last index variables\n    first = 0\n    last = len(array) - 1\n\n    while first <= last:\n        mid = (first + last) // 2\n\n        # Check if the target is in the middle\n        if array[mid] == target:\n            return mid\n\n        # If the target is greater than the element in the middle,\n        # search for it in the second half of the array\n        elif array[mid] < target:\n            first = mid + 1\n\n        # Else, search for it in the first half of the array\n        else:\n            last = mid - 1\n\n    # Otherwise the target is not present in the list\n    return -1", "def inorder_traversal(root):\n    \"\"\"Write a function to traverse a binary search tree in-order, printing out the values it encounters.\n\n    :param root: The root node of the binary search tree\n    \"\"\"\n    if not root:\n        return\n\n    inorder_traversal(root.left)\n    print(root.val)\n    inorder_traversal(root.right)", "def find_common_elements(arr1, arr2):\n    # Initialize an empty array to store the common elements\n    common_elements = []\n\n    # Iterate through each element in the first array\n    for element in arr1:\n        # Use binary search to check if the element is present in the second array\n        if binary_search(arr2, element):\n            common_elements.append(element)\n\n    return common_elements"]}
{"task_id": 482, "content": ["def place_figure(figure, coordinates, array):\n    '''This function will place a figure of any type at the \n    specified coordinates in a 2D array.'''\n    x, y = coordinates\n    array[x][y] = figure", "def map_global_to_local(lx, ly, x_size, y_size, global_x, global_y):\n    \"\"\"\n    Maps global coordinates to local coordinates in a parallel computing environment.\n\n    Args:\n        lx (int): lattice grid size in x direction\n        ly (int): lattice grid size in y direction\n        x_size (int): number of processes in x direction\n        y_size (int): number of processes in y direction\n        global_x (int): global x coordinate\n        global_y (int): global y coordinate\n\n    Returns:\n        tuple: process coordinates, local x coordinate, and local y coordinate\n    \"\"\"\n    # Calculate the size of each subgrid in x and y directions\n    subgrid_x_size = lx // x_size\n    subgrid_y_size = ly // y_size\n\n    # Calculate the process coordinates\n    process_x = global_x // subgrid_x_size\n    process_y = global_y // subgrid_y_size\n\n    # Calculate the local coordinates within the process\n    local_x = global_x % subgrid_x_size\n    local_y = global_y % subgrid_y_size\n\n    return (process_x, process_y, local_x, local_y)", "def polygon_area(coordinates):\n    \"\"\"\n    Given pairs of x,y coordinates as inputs, calculate the surface area of the resulting polygon.\n    This function computes areas of complex, non-rectangular polygons.\n\n    In order to calculate, it uses Gauss's Area formula (also called Shoelace Theorem):\n    https://en.wikipedia.org/wiki/Shoelace_formula\n\n    This formula calculates the signed area. If the coordinates are covered in a counterclockwise direction,\n    the signed area is positive, if clockwise, the signed area is negative. The abs function cares about the absolute value.\n    \"\"\"\n\n    area = 0.0\n    for i in range(len(coordinates)):\n        x1, y1 = coordinates[i]\n        x2, y2 = coordinates[(i+1) % len(coordinates)]  # cyclically next vertex\n        area += x1*y2 - x2*y1\n    return abs(area)/2", "def find_k_nearest_neighbors(points, query_point, k):\n    \"\"\"\n    Finds the k nearest neighbors to the query point in a two-dimensional space.\n\n    Args:\n    points: List of tuples representing the coordinates of the data points.\n    query_point: Tuple representing the coordinates of the query point.\n    k: Integer representing the number of nearest neighbors to find.\n\n    Returns:\n    List of tuples: The coordinates of the k nearest neighbors to the query point.\n    \"\"\"\n    distances = [(euclidean_distance(point, query_point), point) for point in points]\n    distances.sort()  # Sort the distances in ascending order\n    k_nearest_neighbors = [distances[i][1] for i in range(k)]  # Initialize with the first k points\n    heapq.heapify(k_nearest_neighbors)  # Convert the list to a min-heap\n\n    for i in range(k, len(distances)):\n        dist_min = euclidean_distance(k_nearest_neighbors[0], query_point)\n        dist = distances[i][0]\n        if dist < dist_min:\n            heapq.heappop(k_nearest_neighbors)\n            heapq.heappush(k_nearest_neighbors, distances[i][1])\n\n    return k_nearest_neighbors", "def d(a, b):\n    \"\"\"\n    Function to calculate the sum of the squares of the coordinates of the intersections\n    \"\"\"\n    intersections = get_intersections(a, b)\n    return sum([x**2 for x in intersections])"]}
{"task_id": 483, "content": ["def add_binary_digits(a, b):\n    # Convert binary to integer first\n    a_int = int(a, 2)  # converting a from binary to integer\n    b_int = int(b, 2)  # converting b from binary to integer\n    \n    # Add the integers\n    sum_int = a_int + b_int\n    \n    # Convert integer to binary and remove '0b' from start of the string\n    sum_bin = bin(sum_int)[2:]\n    \n    return sum_bin", "def add_binary_digits(a, b):\n    # Convert binary to integer first\n    a_int = int(a, 2)  # converting a from binary to integer\n    b_int = int(b, 2)  # converting b from binary to integer\n    \n    # Add the integers\n    sum_int = a_int + b_int\n    \n    # Convert integer to binary and remove '0b' from start of the string\n    sum_bin = bin(sum_int)[2:]\n    \n    return sum_bin", "def convert_to_binary(decimal_num):\n    \"\"\"\n    This function converts decimal numbers to binary.\n\n    Args:\n    decimal_num (int): a positive integer\n\n    Returns:\n    binary_num (str): a string representation of the binary number\n\n    \"\"\"\n\n    # convert decimal_num to binary\n    binary_num = bin(decimal_num)\n\n    # remove the prefix from the binary number\n    binary_num = binary_num[2:]\n\n    return binary_num", "def convert_to_binary(num):\n    '''\n    This function will convert a given number to binary form and return the result\n    \n    Parameters \n    ----------\n    num : int\n        The number to be converted \n\n    Returns\n    ----------\n    str\n        The binary form of the given number\n    '''\n    binary_num = bin(num)[2:]\n    return binary_num", "def binary_to_int(binary):\n    \"\"\" Convert a given binary string to an integer \"\"\"\n    result = 0\n    i = 0\n    while binary != 0:\n        r = binary % 10\n        result += r * 2 ** i\n        binary //= 10\n        i += 1\n    \n    return result"]}
{"task_id": 484, "content": ["def split_string(string, separator):\n    # Split the string based on the separator, but preserve the separator within quotes\n    regex = r'\"[^\"]*\"|[^' + re.escape(separator) + ']+'\n    substrings = re.findall(regex, string)\n    \n    # Remove any leading or trailing whitespace from each substring\n    substrings = [substring.strip() for substring in substrings]\n    \n    return substrings", "def find_words_with_fr(string):\n    '''\n    This function will find all words containing the letters \"fr\" in a given string.\n    \n    Args:\n        string (str): the string to be searched\n    \n    Returns:\n        list: a list of all words containing the letters \"fr\"\n    '''\n    regex = r\"\\b\\w*fr\\w*\\b\"\n    return re.findall(regex, string)", "def parse_string(pattern, string):\n    '''\n    This function parses a string and returns the substrings which are enclosed in the given pattern.\n    \n    Parameters\n    ----------\n    pattern : str\n        The given pattern\n    string : str\n        The given string\n    \n    Returns\n    -------\n    List\n        Contains substrings enclosed within the given pattern.\n    '''\n    # Initialize list to store substrings\n    sub_strings = []\n    \n    # Get the start and end positions of each substring\n    start = string.find(pattern)\n    end = string.find(pattern, start+1)\n    \n    # Iterate through the string\n    while start >= 0 and end > start:\n        # Get substring and append to list\n        sub_strings.append(string[start+len(pattern):end])\n        \n        # Get new start and end positions\n        start = end\n        end = string.find(pattern, start+1)\n    \n    # Return list of substrings\n    return sub_strings", "def detect_language(text):\n    '''This function will detect the language of a given text using a programming language.'''\n    from langdetect import detect\n    return detect(text)", "def convert_to_upper(string):\n    \"\"\"Function to convert the given string to all capital letters using an algorithm. Input should be a string.\"\"\"\n    result = ''\n    for char in string:\n        result += chr(ord(char) - 32)\n    return result"]}
{"task_id": 485, "content": ["def kth_smallest(lst, n, k):\n    \n    # Using heap queue algorithm to sort list\n    sorted_list = heapq.nsmallest(n, lst)\n    \n    # Return kth smallest number\n    return sorted_list[k-1]", "def filter_numbers(numbers, func_filter):\n    \"\"\"\n    Filters a list of integers based on the given condition.\n\n    Args:\n    numbers: A list of integers to be filtered.\n    func_filter: A filtering function that accepts an integer and returns a boolean value.\n\n    Returns:\n    A new list containing only the integers that satisfy the filtering condition.\n    \"\"\"\n    filtered_numbers = [num for num in numbers if func_filter(num)]\n    return filtered_numbers", "def count_unique_numbers(numbers):\n    \"\"\"\n    Count the number of unique integers in the given list.\n\n    Args:\n    numbers: A list of integers.\n\n    Returns:\n    An integer representing the count of unique numbers in the list.\n    \"\"\"\n    try:\n        unique_numbers = set(numbers)  # Convert the list to a set to get unique elements\n        return len(unique_numbers)  # Return the count of unique numbers\n    except TypeError as e:\n        raise TypeError(\"Input must be a list of integers\") from e\n    except Exception as e:\n        raise Exception(\"An error occurred while counting unique numbers\") from e", "def sum_of_min_max(lst):\n    \"\"\"\n    Function to take a list of integers and returns the summation of the largest and smallest numbers\n    Arguments:\n    lst -- list -- list of integers\n    Output:\n    summation -- int -- summation of the largest and smallest numbers\n    \"\"\"\n    min_val = min(lst)\n    max_val = max(lst)\n    summation = min_val + max_val\n    return summation", "def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) "]}
{"task_id": 486, "content": ["def frustum_surface_area(r1, r2, h):\n    \"\"\"\n    This function calculates the surface area of a frustum of a cone.\n\n    Arguments:\n    r1 : float : radius of the smaller base of the frustum\n    r2 : float : radius of the larger base of the frustum\n    h : float : height of the frustum\n\n    Returns:\n    float : surface area of the frustum\n    \"\"\"\n\n    # Checking if the input parameters are valid\n    if r1 < 0 or r2 < 0 or h < 0:\n        raise ValueError('All parameters must be non-negative.')\n\n    area = math.pi * (r1 + r2) * math.sqrt((r2 - r1)**2 + h**2) + math.pi * (r1**2 + r2**2)\n    return area", "def find_surface_area(length, breadth, height):\n    '''\n    This function calculates the surface area of a cuboid.\n    Input: length, breadth, height - these are the three dimensions of the cuboid\n    Output: total surface area of the cuboid \n    '''\n    # Formula of Surface Area of Cuboid = 2(lb + bh + hl)\n    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area", "def find_surface_area(length, breadth, height):\n    '''\n    This function calculates the surface area of a cuboid.\n    Input: length, breadth, height - these are the three dimensions of the cuboid\n    Output: total surface area of the cuboid \n    '''\n    # Formula of Surface Area of Cuboid = 2(lb + bh + hl)\n    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area", "def calc_cone_volume(cone):\n    \"\"\"Calculates the volume of a cone given the cone dictionary.\n\n    Args:\n        cone (dict): The cone dictionary.\n\n    Returns:\n        float: The volume of the cone.\n    \"\"\" \n    \n    return (1/3) * math.pi * (cone['radius']**2) * cone['height']", "def sort_cones(cones):\n    \"\"\"Calculates the volumes of a list of cones and sorts them in non-increasing order.\n\n    Args:\n        cones (list): The list of cone dictionaries.\n\n    Returns:\n        list: The sorted list of cone dictionaries.\n    \"\"\" \n    \n    for cone in cones:\n        cone = fix_dict(cone)\n        cone['volume'] = calc_cone_volume(cone)\n    \n    cones.sort(key=lambda x: x['volume'], reverse=True)\n    \n    return cones"]}
{"task_id": 487, "content": ["def gcd(a, b):\n    \"\"\"\n    Function to find greatest common divisor (gcd) of two numbers using the Euclidean algorithm\n    \n    Parameters :\n    a (int) : First input number\n    b (int) : Second input number\n    \n    Returns :\n    gcd(int) : highest common divisor of two positive integers \n    \n    \"\"\"\n    while b:\n        a, b = b, a % b\n\n    return a", "def lcm(a, b):\n    \"\"\"\n    Function to calculate the Least Common Multiple (LCM) of two numbers using the formula:\n    lcm(a, b) = abs(a*b) / gcd(a, b)\n    \"\"\"\n    if a < 1 or b < 1:\n        raise ValueError(\"Both numbers should be positive integers.\")\n  \n    return abs(a*b) // gcd(a, b)", "def gcd(a, b):\n    '''\n    Function to calculate the GCD of two numbers\n    :param a: The first number\n    :param b: The second number\n    :return: The GCD of the two numbers\n    ''' \n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)", "def gcd(a, b):\n    \"\"\"\n    Recursive function to calculate the Greatest Common Divisor (GCD) of two numbers.\n    The formula used here is: gcd(a, b) = gcd(b, a mod b)\n    \"\"\"\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)", "def lcm(a, b):\n    \"\"\"Calculate the lowest common multiple of two integers.\"\"\"\n    return a * b // gcd(a, b)"]}
{"task_id": 488, "content": ["def get_circle_area(radius):\n    \"\"\"Calculate and return the area of a circle with a given radius.\n \n    Args:\n        radius (float): The radius of the circle\n \n    Returns:\n        float: The area of the circle\n    \"\"\"\n    return 3.14 * (radius * radius)", "def calculate_circle_area(radius, pi=3.14):\n    \"\"\"\n    Create a function that takes two arguments and calculates the area of a circle.\n    The radius is the required argument, and the value of pi is optional (default is 3.14).\n    \"\"\"\n    area = pi * radius * radius\n    return area", "def create_malicious_dll():\n    # This function would contain the logic to create a DLL file with the malicious payload\n    # For example, it might use the Windows API to write a DLL file that includes the reverse shell payload.\n    pass", "def circle_area(r):\n    \"\"\"\n    Calculate the area of a circle given its radius.\n\n    Args:\n    r: float, the radius of the circle.\n\n    Returns:\n    float, the area of the circle.\n    \"\"\"\n    return math.pi * (r ** 2)", "def find_rop_gadgets(base_address):\n    # This function would use a database of known ROP gadgets or a tool like ROPgadget to find gadgets.\n    gadgets = []\n    # Code to find ROP gadgets goes here\n    return gadgets"]}
{"task_id": 489, "content": ["def write_to_csv(strings: List[str]) -> None:\n    # Concatenate all the strings into a single string separated by commas\n    csv_content = ','.join(strings)\n    \n    # Write the resulting string to a CSV file\n    with open('outcsv.csv', 'w') as outfile:\n        outfile.write(csv_content)", "def sort(list):\n    \"\"\"\n    This function sorts a given list in ascending order.\n\n    Parameters:\n    list (List[int, float, str]): A list of numerical or string values to be sorted. This list should contain elements of the same datatype for the function to work correctly. \n    \"\"\"\n    list.sort()", "def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list", "def find_words_with_fr(string):\n    '''\n    This function will find all words containing the letters \"fr\" in a given string.\n    \n    Args:\n        string (str): the string to be searched\n    \n    Returns:\n        list: a list of all words containing the letters \"fr\"\n    '''\n    regex = r\"\\b\\w*fr\\w*\\b\"\n    return re.findall(regex, string)", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count"]}
{"task_id": 490, "content": ["def gcd(a, b):\n    \"\"\"\n    Function to find greatest common divisor (gcd) of two numbers using the Euclidean algorithm\n    \n    Parameters :\n    a (int) : First input number\n    b (int) : Second input number\n    \n    Returns :\n    gcd(int) : highest common divisor of two positive integers \n    \n    \"\"\"\n    while b:\n        a, b = b, a % b\n\n    return a", "def divisor_function(a, b):\n    \"\"\"Returns the greatest common divisor of two numbers.\"\"\"\n    if a < b:\n        a, b = b, a\n    \n    # Step 1: Check if both numbers are equal, in which case the greatest common divisor is the number itself\n    if a == b:\n        return a\n    \n    # Step 2: Check if one of the numbers is 0, in which case the other number is the greatest common divisor\n    if b == 0:\n        return a\n    \n    # Step 3: Find the prime factors of both numbers\n    a_factors = get_prime_factors(a)\n    b_factors = get_prime_factors(b)\n    \n    # Step 4: Find the common prime factors of both numbers\n    common_factors = find_common_factors(a_factors, b_factors)\n    \n    # Step 5: Find the highest common prime factor\n    highest_common_factor = find_highest_common_factor(common_factors)\n    \n    # Step 6: Find the highest power of the highest common factor that divides both numbers\n    gcd = find_highest_power(a, b, highest_common_factor)\n    \n    return gcd", "def get_lcm(a, b):\n    \"\"\"\n    Calculates the least common multiple of two given numbers\n\n    Parameters:\n        a (int): First number\n        b (int): Second number\n\n    Returns:\n        lcm (int): The least common multiple of a and b\n    \"\"\"\n    # Find the greatest common divisor\n    while b:\n        a, b = b, a%b\n    \n    # Return the least common multiple using the greatest common divisor\n    return (a*b)//a", "def gcd(a, b):\n    \"\"\"\n    Calculates the greatest common divisor between two numbers\n    \"\"\"\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)", "def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min"]}
{"task_id": 491, "content": ["def max_and_min(a, b):\n    \"\"\"Function to find the maximum and minimum of two given numbers.\"\"\"\n    max = a if a > b else b\n    min = a if a < b else b\n    return max, min", "def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def get_even_numbers(lst):\n    # Write a python program that takes a list and returns a new list with only even numbers.\n    return [x for x in lst if x % 2 == 0]", "def inject_payload(pid, payload):\n    # This function would need to be implemented to attach to the process,\n    # find the system call table, and modify it to point to the custom handler.\n    # This is a complex task that typically requires kernel-level access and\n    # is beyond the scope of a simple Python script.\n    pass", "def remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Facilitate the de-duplication of a sequence of integers, eliminating any references that occur more than once.\n    Retains the exact sequence of remaining integers mirroring the original provided sequence.\n    Time complexity: O(n)\n    Space complexity: O(1)\n    \"\"\"\n    write = 1\n    for read in range(1, len(numbers)):\n        if numbers[read] != numbers[read-1]:\n            numbers[write] = numbers[read]\n            write += 1\n    return numbers[:write]   # cutting the array to length 'write'"]}
{"task_id": 492, "content": ["def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def reverse_array(arr):\n    \"\"\"This function reverses the elements of a given array of numbers\n    \n    Parameters: \n        arr (list): The list of numbers to reverse.\n\t\n    Returns: The reversed array\n    \"\"\"\n    return arr[::-1]", "def filter_numbers(numbers, func_filter):\n    \"\"\"\n    Filters a list of integers based on the given condition.\n\n    Args:\n    numbers: A list of integers to be filtered.\n    func_filter: A filtering function that accepts an integer and returns a boolean value.\n\n    Returns:\n    A new list containing only the integers that satisfy the filtering condition.\n    \"\"\"\n    filtered_numbers = [num for num in numbers if func_filter(num)]\n    return filtered_numbers", "def reverse_list(numbers):\n    '''This function will reverse the order of the elements \n    of a given list.'''\n    numbers.reverse()", "def count_elements_up_to_max(lst, maximum_value):\n    \"\"\"\n    This function counts the number of elements in a list up to the given maximum value.\n\n    Args:\n        lst (list): A list of numbers.\n        maximum_value (int): The maximum value that we want to count up to.\n\n    Returns:\n        int: The number of elements in the list up to the given maximum value.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count"]}
{"task_id": 493, "content": ["def calculate_difference(n):\n    # Calculate the square of the sum of the first n natural numbers\n    square_of_sum = ((n * (n + 1)) // 2) ** 2\n    \n    # Calculate the sum of the squares of the first n natural numbers\n    sum_of_squares = (n * (n + 1) * ((2 * n) + 1)) // 6\n    \n    # Calculate the difference\n    difference = square_of_sum - sum_of_squares\n    \n    return difference", "def triangle_square_sum(n):\n    \"\"\"\n    Function to calculate the sum of the Triangle Series and the sum of the square of each\n    number in the Triangle Series up to n.\n    \"\"\"\n    # error handling: if n is negative or not an integer\n    if not isinstance(n, int) or n < 1:\n        return \"Error: Input must be an positive integer\"\n\n    # calculate the sum of the Triangle Series\n    # formula for the sum of the first n natural numbers is n*(n+1)/2\n    triangle_sum = n * (n + 1) // 2  # use integer division to ensure result is an integer\n\n    # calculate the sum of the square of each number in the Triangle Series up to n.\n    # formula for the sum of the squares of the first n natural numbers is n*(n+1)*(2n+1)/6\n    square_sum = n * (n + 1) * (2 * n + 1) // 6  # use integer division to ensure result is an integer\n\n    return triangle_sum, square_sum", "def sum_of_n_numbers(n):\n    \"\"\"This function will return the sum of n natural numbers.\"\"\"\n    # check if n is 1\n    if n == 1:\n        return 1\n    # Otherwise, recursively call the function\n    else:\n        return n + sum_of_n_numbers(n-1)", "def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def calculate_sum(n):\n    \"\"\"Function to calculate the sum of the first n numbers.\"\"\"\n    sum = 0\n    while n > 0:\n        sum = sum + n\n        n = n - 1\n    return sum"]}
{"task_id": 494, "content": ["def move_zeroes_to_end(array):\n    \"\"\"\n    This function takes a list of numbers as input, \n    moves all the zeroes to the end \n    and returns the updated list.\n    \"\"\"\n    # count the number of zeros\n    num_zeros = array.count(0)\n    \n    # remove all zeros from the list\n    array = [num for num in array if num != 0]\n    \n    # extend the list by the number of zeros\n    array.extend([0]*num_zeros)\n    \n    return array", "def binary_search(arr, num):\n    \"\"\"\n    Function to use binary search to find a given number in a given array.\n\n    Arguments:\n    arr -- input array\n    num -- number to be found\n\n    Returns:\n    res -- boolean value\n    \"\"\"\n\n    # Initialize boolean variable\n    res = False\n\n    # Find the mid-point of the array\n    mid = int(len(arr)/2)\n\n    # initialize the beginning and end of the array\n    start = 0\n    end = len(arr) - 1\n\n    # If the number is in the array, set boolean as True\n    if num == arr[mid]:\n        res = True\n\n    # If the number is less than the mid-point of the array, \n    # make the end of the array the mid-point - 1\n    elif num < arr[mid]:\n        end = mid - 1\n\n    # Else, make the start of the array the mid-point + 1\n    else:\n        start = mid + 1\n\n    # If the start and the end of the array have not met each other, \n    # make a recursive call to the binary search function\n    if start <= end:\n        return binary_search(arr[start:end+1], num)\n\n    return res", "def sum_primes_in_range(start, end):\n    \"\"\"\n    Function to find the sum of all prime numbers within the given range.\n    \n    Parameters: \n    start (int): The start number of the range. \n    end (int): The end number of the range.\n    \n    Returns: \n    int: The sum of all prime numbers in the given range.\n    \"\"\"\n    result = 0\n    for n in range(start, end+1):\n        if is_prime(n):\n            result += n\n    return result", "def apply_function(arr, f):\n    \"\"\"\n    Apply a given function to each item of an input array.\n    \n    Args:\n        arr (list): The input array.\n        f (function): The function to be applied.\n        \n    Returns:\n        list: A list with the result of applying function f to each item of arr.\n    \"\"\"\n    return list(map(f, arr))", "def findCombinations(array, total):\n    \"\"\"\n    This function will find all possible combinations of integers in the given array that sum up to the given total.\n    Args:\n        array (list): List of integers.\n        total (int): Total to be reached with the combination of integers.\n    \n    Returns:\n        A list of lists containing the combinations of integers.\n    \"\"\"\n    combinations = []  # list to store the possible combinations\n    for i in range(1 << len(array)):  # loop through all combinations of bits\n        combination = []  # list to store the current combination\n        for j in range(len(array)):  # loop through array elements\n            if i & (1 << j):  # check if bit is set\n                combination.append(array[j])  # add array element to combination\n        if sum(combination) == total:  # check if combination sums to given total\n            combinations.append(combination)  # add combination to list of combinations\n\n    return combinations"]}
{"task_id": 495, "content": ["def format_for_latex(x, p=3):\n    \"\"\"Convert a float to a LaTeX-formatted string displaying the value to p significant\n    digits and in standard form.\n\n    Args:\n    x (float): The input value to be converted to a LaTeX-formatted string.\n    p (int, optional): The number of significant digits to display. Defaults to 3.\n\n    Returns:\n    str: A string representing the input value x in LaTeX format, displaying the value to p significant digits and in standard form.\n    \"\"\"\n    # Convert the float to standard form with p significant digits\n    formatted_value = \"{:.{p}e}\".format(x, p=p-1)\n\n    # Split the formatted value into coefficient and exponent parts\n    coefficient, exponent = formatted_value.split('e')\n\n    # Format the coefficient to remove trailing zeros and unnecessary decimal point\n    coefficient = str(float(coefficient))\n\n    # Construct the LaTeX-formatted string\n    latex_string = coefficient + r\" \times 10^{\" + str(int(exponent)) + \"}\"\n\n    return latex_string", "def get_max_triples(n, p):\n    # calculate the array 'a' according to formula\n    a = [(i * i - i + p) + (i % p) for i in range(1, n+1)]\n    \n    # initialize count of triples to 0\n    counters = 0\n\n    # consider all triples a[i], a[j], a[k] such that i < j < k\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                # calculate modulus of product a[i]*a[j] by a[k]\n                product_modulus = (a[i] * a[j]) % a[k]\n\n                # check if the result is a multiple of n or p, increment the count\n                if product_modulus % n == 0 or product_modulus % p == 0:\n                    counters += 1\n\n    return counters", "def binomialCoefficient(n, k):\n    if k > n - k:\n        k = n - k\n\n    coefficient = 1\n    for i in range(1, k + 1):\n        coefficient *= n - i + 1\n        coefficient //= i\n        coefficient %= 1000000007\n\n    return coefficient", "def lin_reg(X, Y):\n    # Calculate the mean of the given values\n    mean_x = np.mean(X)\n    mean_y = np.mean(Y)\n    \n    # Calculate the mean of the differences between X and Y\n    mean_diff_x_y = np.mean([X[i] - Y[i] for i in range(len(X))])\n    \n    # Calculate the variance of X and Y\n    var_x = np.var(X)\n    var_y = np.var(Y)\n    \n    # Calculate the coefficient of correlation\n    coefficient = mean_diff_x_y / np.sqrt(var_x * var_y)\n    \n    # Calculate the intercept and slope\n    intercept = mean_y - (coefficient * mean_x)\n    slope = coefficient * (np.sqrt(var_x) / np.sqrt(var_y))\n    \n    # Return the values\n    return intercept, slope", "def correlate_power_traces(power_traces, plaintexts, key_byte_position):\n    # Implement this function to correlate the power traces with the Hamming weights.\n    # This function will calculate the Hamming weight for each plaintext and each power trace.\n    # Then, it will correlate the Hamming weights with the power traces to find the most likely key byte.\n    \n    # Initialize an array to store the Hamming weights for all plaintexts at the given key byte position.\n    hamming_weights = np.zeros(len(plaintexts), dtype=np.int8)\n    \n    # Calculate the Hamming weight for each plaintext at the given key byte position.\n    for i in range(len(plaintexts)):\n        hamming_weights[i] = hamming_weight(plaintexts[i][key_byte_position])\n    \n    # Correlate the Hamming weights with the power traces.\n    # We will use the Pearson correlation coefficient for this purpose.\n    correlation_coefficients = np.corrcoef(hamming_weights, power_traces)\n    \n    # The correlation coefficients matrix is symmetric, so we only need to consider the upper right triangle.\n    # The diagonal elements are always 1, so we ignore them and find the maximum correlation coefficient.\n    max_correlation_position = np.argmax(np.triu(correlation_coefficients, k=1))\n    \n    # The maximum correlation coefficient gives us the most likely key byte.\n    # We need to convert this back to the actual key byte.\n    # The key byte is the position of the maximum correlation coefficient in the upper right triangle.\n    # Since the correlation matrix is symmetric, we need to adjust the index to get the actual position.\n    max_correlation_position -= key_byte_position\n    \n    # Return the most likely key byte.\n    return max_correlation_position"]}
{"task_id": 496, "content": ["def remove_rubbish_words(data, rubbishList):\n    \"\"\"\n    Remove rubbish words from the given text data list.\n\n    :param data: A list of text data where rubbish words need to be removed.\n    :param rubbishList: A list of rubbish words that should be removed from the text data.\n    :return: A new list containing the text data with the rubbish words removed.\n    \"\"\"\n    tmp = data.copy()  # Create a copy of the original list to avoid modifying it directly\n    tmp = [word for word in tmp if word.strip() not in rubbishList and not is_number(word.strip())]\n    return tmp", "def delete_element(my_list, pos):\n    \"\"\"Function to delete an element from a given list at a given position.\"\"\"\n    del my_list[pos]\n    return my_list", "def my_filter(func, lst):\n    \"\"\"\n    Custom filter function to filter elements from a list based on the given function.\n\n    Args:\n    func: A function that takes an element from the list as input and returns True or False.\n    lst: A list of elements to be filtered.\n\n    Returns:\n    A new list containing elements from lst for which func returns True.\n    \"\"\"\n    filtered_list = [elem for elem in lst if func(elem)]\n    return filtered_list", "def remove_duplicates(arr):\n    \"\"\"Develop a method to remove the duplicates from a given array of numbers.\"\"\"\n    return list(set(arr))", "def related_words(word, words):\n    \"\"\"\n    Function to get an array of words related to the given word.\n    \n    Parameters: \n    word (str) : The given word.\n    words (list) : The list of words to search in.\n\n    Returns:\n    list : The list of words related to the given word.\n    \"\"\"\n\n    related = []\n    for w in words:\n        if word in w or w in word:\n            related.append(w)\n    return related"]}
{"task_id": 497, "content": ["def compare_lists(l1, l2):\n    # Converting lists to sets to remove repeating elements and compare unique items\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Checking and printing conditions\n    if sorted(l1) == sorted(l2):\n        print(\"The lists contain the same elements regardless of order and repetition.\")\n        \n    if set1 == set2:\n        print(\"The lists contain the same unique elements regardless of the order.\")\n    \n    if set1 == set2 and l1 != l2:\n        print(\"The lists contain the same elements but in a different order.\")\n     \n    if l1 == l2:\n        print(\"The lists are exactly the same including the order.\")\n    else:\n        print(\"The lists are not exactly the same including the order.\")", "def concat_verify(list1, list2):\n    # Check if both inputs are lists\n    if not (isinstance(list1, list) and isinstance(list2, list)):\n        return 'Error: Both inputs must be lists.'\n    # Concatenate two lists\n    joined_list = list1 + list2\n    # Check if lengths of original + joined lists match\n    if len(joined_list) != len(list1) + len(list2):\n        return 'Error: The lengths of the original and the joined lists do not match.'\n    # Check if elements of the original lists are in the joined list in the same order\n    for i in range(len(joined_list)):\n        if i < len(list1):\n            if joined_list[i] != list1[i]:\n                return 'Error: The elements of the first list are not in the correct order in the joined list.'\n        else:\n            if joined_list[i] != list2[i - len(list1)]:\n                return 'Error: The elements of the second list are not in the correct order in the joined list.'            \n    # All tests passed, return joined list\n    return joined_list", "def common_elements(l1, l2, l3):\n    common = []\n    for a, b, c in zip(l1, l2, l3):   # zip merges lists by their indices\n        if a == b == c:                # check if elements are the same in all lists\n            common.append(a)           # if yes, append it to the common list\n    return common", "def combine_lists_to_dict(list1, list2):\n    # Check if both lists have the same number of elements.\n    if len(list1) != len(list2):\n        return \"Error: The given lists do not have the same number of elements.\"\n\n    # Combine the two lists into a dictionary.\n    combined_dict = dict(zip(list1, list2))\n\n    return combined_dict", "def find_common_elements(list1, list2):\n    '''This function finds the common elements in two given lists.'''\n    result = []\n    for num in list1:\n        if num in list2:\n            result.append(num)\n    return result"]}
{"task_id": 498, "content": ["def find_average(numbers):\n    \"\"\"Function to find the average of a given set of numbers.\"\"\"\n    return sum(numbers) / len(numbers) ", "def check_integer(number):\n    if number % 2 == 0:\n        if number % 3 == 0:\n            print(\"The given integer is even and a multiple of 3.\")\n        else:\n            print(\"The given integer is even and not a multiple of 3.\")\n    else:\n        if number % 3 == 0:\n            print(\"The given integer is odd and a multiple of 3.\")\n        else:\n            print(\"The given integer is odd and not a multiple of 3.\")", "def unique_odd_sum_prime_product_elements(x):\n    \"\"\"Given an array of positive integers x, the function is expected to yield a sorted array of unique elements that exhibit odd digit sum, do not recur in the input array, and are the product of exactly 2 prime numbers.", "def calculate_median(numbers):\n    numbers.sort() # Sort the list of numbers\n\n    mid_index = len(numbers) // 2 # Find the middle index of the list\n\n    if len(numbers) % 2 != 0: # Check if the length of numbers is odd\n        median = numbers[mid_index] # If odd, the median is the middle number\n    else:\n        median = (numbers[mid_index] + numbers[mid_index - 1]) / 2 # If even, the median is the average of the two middle numbers\n\n    return median", "def sum_of_squares_of_n_odds(n):\n    # Step 1: Generate a list of the first n odd numbers.\n    odd_numbers = [2 * i + 1 for i in range(n)]\n\n    # Step 2: Calculate the square of each odd number in the list.\n    squared_odd_numbers = [x ** 2 for x in odd_numbers]\n\n    # Step 3: Sum the squared odd numbers.\n    total_sum = sum(squared_odd_numbers)\n\n    return total_sum"]}
{"task_id": 499, "content": ["def find_smaller_numbers(array, threshold):\n    result = []  # Create an empty array to store the smaller numbers\n    for num in array:  # Iterate through each number in the array\n        if num < threshold:  # Check if the number is less than the threshold\n            result.append(num)  # Add the number to the result array\n    return result  # Return the final array of smaller numbers", "def find_max_subarray(arr):\n    \"\"\"Write a function to find the maximum subarray of a given array.\n\n    :param arr: The given array\n    :returns: The maximum subarray of the given array\n    \"\"\"\n    max_start, max_end = 0, 0\n    max_sum = float('-inf')\n    current_start = 0\n    current_sum = 0\n\n    for i, elt in enumerate(arr):\n        current_sum += elt\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start, max_end = current_start, i \n        if current_sum < 0:\n            current_start = i + 1\n            current_sum = 0\n\n    return arr[max_start: max_end + 1]", "def has_negative_number(numbers):\n    # Calculate the product of all the numbers in the array\n    product = 1\n    for num in numbers:\n        product *= num\n\n    # If the product is negative, then there must be at least one negative number in the array\n    if product < 0:\n        return True\n    else:\n        return False", "def find_kth_smallest(arr, k):\n    if k > len(arr):\n        return 'Error: k is larger than the array length.'\n    \n    # find unique values in the array\n    unique_values = list(set(arr))\n    \n    # If k is more than the number of unique values, return an error\n    if k > len(unique_values):\n        return 'Error: k is greater than the number of unique elements in the array.'\n    \n    # find the kth smallest unique value\n    kth_smallest = heapq.nsmallest(k, unique_values)[-1]\n    \n    # calculate the frequency of kth smallest unique value in the array\n    count = collections.Counter(arr)[kth_smallest]\n    \n    return (kth_smallest, count)", "def binary_search(arr, num):\n    \"\"\"\n    Function to use binary search to find a given number in a given array.\n\n    Arguments:\n    arr -- input array\n    num -- number to be found\n\n    Returns:\n    res -- boolean value\n    \"\"\"\n\n    # Initialize boolean variable\n    res = False\n\n    # Find the mid-point of the array\n    mid = int(len(arr)/2)\n\n    # initialize the beginning and end of the array\n    start = 0\n    end = len(arr) - 1\n\n    # If the number is in the array, set boolean as True\n    if num == arr[mid]:\n        res = True\n\n    # If the number is less than the mid-point of the array, \n    # make the end of the array the mid-point - 1\n    elif num < arr[mid]:\n        end = mid - 1\n\n    # Else, make the start of the array the mid-point + 1\n    else:\n        start = mid + 1\n\n    # If the start and the end of the array have not met each other, \n    # make a recursive call to the binary search function\n    if start <= end:\n        return binary_search(arr[start:end+1], num)\n\n    return res"]}
