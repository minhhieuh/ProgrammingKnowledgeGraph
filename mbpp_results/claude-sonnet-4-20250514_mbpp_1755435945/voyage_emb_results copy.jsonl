{"task_id": 11, "generation": "def remove_Occ(string, char):\n    if char not in string:\n        return string\n    \n    # Find first occurrence\n    first_index = string.find(char)\n    \n    # Find last occurrence\n    last_index = string.rfind(char)\n    \n    # If first and last are the same (only one occurrence)\n    if first_index == last_index:\n        return string[:first_index] + string[first_index + 1:]\n    \n    # Remove last occurrence first to avoid index shifting\n    result = string[:last_index] + string[last_index + 1:]\n    \n    # Find first occurrence in the modified string\n    first_index = result.find(char)\n    \n    # Remove first occurrence\n    result = result[:first_index] + result[first_index + 1:]\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 12, "generation": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "is_syntactically_valid": true}
{"task_id": 13, "generation": "from collections import Counter\n\ndef count_common(words):\n    # Count frequency of each word\n    word_counts = Counter(words)\n    \n    # Get the maximum frequency\n    max_count = max(word_counts.values())\n    \n    # Find all words with maximum frequency\n    most_common = [(word, count) for word, count in word_counts.items() if count == max_count]\n    \n    # Sort by word alphabetically for consistent ordering\n    most_common.sort(key=lambda x: x[0])\n    \n    return most_common", "is_syntactically_valid": true}
{"task_id": 14, "generation": "def find_Volume(length, width, height):\n    return (length * width * height) // 2", "is_syntactically_valid": true}
{"task_id": 15, "generation": "def split_lowerstring(s):\n    result = []\n    current_part = \"\"\n    \n    for char in s:\n        if char.islower():\n            current_part += char\n            result.append(current_part)\n            current_part = \"\"\n        else:\n            current_part += char\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 16, "generation": "import re\n\ndef text_lowercase_underscore(text):\n    pattern = r'^[a-z]+_[a-z]+$'\n    if re.match(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'", "is_syntactically_valid": true}
{"task_id": 17, "generation": "def square_perimeter(side_length):\n    return 4 * side_length", "is_syntactically_valid": true}
{"task_id": 18, "generation": "def remove_dirty_chars(string1, string2):\n    dirty_chars = set(string2)\n    result = \"\"\n    for char in string1:\n        if char not in dirty_chars:\n            result += char\n    return result", "is_syntactically_valid": true}
{"task_id": 19, "generation": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "is_syntactically_valid": true}
{"task_id": 20, "generation": "def is_woodall(n):\n    # A Woodall number has the form n * 2^n - 1\n    # To check if a given number is Woodall, we need to find if there exists\n    # a positive integer k such that n = k * 2^k - 1\n    \n    # Rearranging: n + 1 = k * 2^k\n    # So we need to check if (n + 1) can be expressed as k * 2^k\n    \n    target = n + 1\n    k = 1\n    \n    # We only need to check reasonable values of k\n    # Since k * 2^k grows very quickly, we don't need to check large values\n    while k * (2 ** k) <= target:\n        if k * (2 ** k) == target:\n            return True\n        k += 1\n    \n    return False", "is_syntactically_valid": true}
{"task_id": 21, "generation": "def multiples_of_num(m, n):\n    return [n * i for i in range(1, m + 1)]", "is_syntactically_valid": true}
{"task_id": 22, "generation": "def find_first_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return -1", "is_syntactically_valid": true}
{"task_id": 23, "generation": "def maximum_Sum(list_of_lists):\n    max_sum = float('-inf')\n    \n    for sublist in list_of_lists:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n    \n    return max_sum", "is_syntactically_valid": true}
{"task_id": 24, "generation": "def binary_to_decimal(binary):\n    binary_str = str(binary)\n    decimal = 0\n    power = 0\n    \n    for digit in reversed(binary_str):\n        decimal += int(digit) * (2 ** power)\n        power += 1\n    \n    return decimal", "is_syntactically_valid": true}
{"task_id": 25, "generation": "def find_Product(arr, n):\n    # Count frequency of each element\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Find product of elements that appear only once\n    product = 1\n    for num, count in freq.items():\n        if count == 1:\n            product *= num\n    \n    return product", "is_syntactically_valid": true}
{"task_id": 26, "generation": "def check_k_elements(tuple_list, k):\n    return all(k in tuple_item for tuple_item in tuple_list)", "is_syntactically_valid": true}
{"task_id": 27, "generation": "def remove(strings):\n    result = []\n    for string in strings:\n        new_string = \"\"\n        for char in string:\n            if not char.isdigit():\n                new_string += char\n        result.append(new_string)\n    return result", "is_syntactically_valid": true}
{"task_id": 28, "generation": "def binomial_Coeff(n, k):\n    if k > n or k < 0:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    # Use the multiplicative formula: C(n,k) = n! / (k! * (n-k)!)\n    # But calculate it efficiently to avoid large factorials\n    result = 1\n    for i in range(min(k, n - k)):\n        result = result * (n - i) // (i + 1)\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 29, "generation": "from collections import Counter\n\ndef get_Odd_Occurrence(arr, n):\n    frequencies = Counter(arr)\n    for element, count in frequencies.items():\n        if count % 2 == 1:\n            return element", "is_syntactically_valid": true}
{"task_id": 30, "generation": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    n = len(s)\n    \n    # Count single characters (they start and end with same character)\n    count += n\n    \n    # Count substrings of length 2 or more\n    for i in range(n):\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                count += 1\n    \n    return count", "is_syntactically_valid": true}
{"task_id": 31, "generation": "import heapq\nfrom collections import Counter\n\ndef func(lists, k):\n    # Count frequency of each integer across all lists\n    counter = Counter()\n    for lst in lists:\n        for num in lst:\n            counter[num] += 1\n    \n    # Use a min heap to keep track of top k elements\n    heap = []\n    \n    for num, freq in counter.items():\n        if len(heap) < k:\n            heapq.heappush(heap, (freq, num))\n        elif freq > heap[0][0]:\n            heapq.heapreplace(heap, (freq, num))\n    \n    # Extract numbers from heap and sort by frequency (descending) then by value (ascending)\n    result = []\n    while heap:\n        freq, num = heapq.heappop(heap)\n        result.append((freq, num))\n    \n    # Sort by frequency descending, then by value ascending for tie-breaking\n    result.sort(key=lambda x: (-x[0], x[1]))\n    \n    return [num for freq, num in result]", "is_syntactically_valid": true}
{"task_id": 32, "generation": "def max_Prime_Factors(n):\n    if n <= 1:\n        return None\n    \n    max_prime = -1\n    \n    # Check for factor 2\n    while n % 2 == 0:\n        max_prime = 2\n        n = n // 2\n    \n    # Check for odd factors from 3 onwards\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            max_prime = i\n            n = n // i\n        i += 2\n    \n    # If n is still greater than 1, then it's a prime\n    if n > 1:\n        max_prime = n\n    \n    return max_prime", "is_syntactically_valid": true}
{"task_id": 33, "generation": "def decimal_To_Binary(decimal):\n    if decimal == 0:\n        return 0\n    \n    binary = \"\"\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal = decimal // 2\n    \n    return int(binary)", "is_syntactically_valid": true}
{"task_id": 34, "generation": "def find_missing(arr, n):\n    # Calculate expected sum of numbers from 1 to n\n    expected_sum = n * (n + 1) // 2\n    \n    # Calculate actual sum of the array\n    actual_sum = sum(arr)\n    \n    # The missing number is the difference\n    return expected_sum - actual_sum", "is_syntactically_valid": true}
{"task_id": 35, "generation": "def find_rect_num(n):\n    return n * (n + 1)", "is_syntactically_valid": true}
{"task_id": 36, "generation": "def find_Nth_Digit(numerator, denominator, n):\n    # Perform long division to get the nth digit after decimal point\n    remainder = numerator % denominator\n    \n    for i in range(n):\n        remainder *= 10\n        digit = remainder // denominator\n        remainder = remainder % denominator\n        \n        if i == n - 1:  # nth digit (1-indexed)\n            return digit\n    \n    return digit", "is_syntactically_valid": true}
{"task_id": 37, "generation": "def sort_mixed_list(mixed_list):\n    integers = []\n    strings = []\n    \n    for item in mixed_list:\n        if isinstance(item, int):\n            integers.append(item)\n        else:\n            strings.append(item)\n    \n    integers.sort()\n    strings.sort()\n    \n    return integers + strings", "is_syntactically_valid": true}
{"task_id": 38, "generation": "def div_even_odd(lst):\n    first_even = None\n    first_odd = None\n    \n    for num in lst:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 == 1 and first_odd is None:\n            first_odd = num\n        \n        if first_even is not None and first_odd is not None:\n            break\n    \n    return first_even // first_odd", "is_syntactically_valid": true}
{"task_id": 39, "generation": "def rearange_string(s):\n    from collections import Counter\n    import heapq\n    \n    # Count frequency of each character\n    char_count = Counter(s)\n    \n    # Check if rearrangement is possible\n    # The most frequent character should not appear more than (n+1)//2 times\n    max_freq = max(char_count.values())\n    if max_freq > (len(s) + 1) // 2:\n        return \"\"\n    \n    # Create a max heap (using negative values for max heap behavior)\n    heap = [(-count, char) for char, count in char_count.items()]\n    heapq.heapify(heap)\n    \n    result = []\n    prev_count, prev_char = 0, ''\n    \n    while heap:\n        # Get the most frequent character\n        count, char = heapq.heappop(heap)\n        result.append(char)\n        \n        # If previous character still has remaining count, add it back to heap\n        if prev_count < 0:\n            heapq.heappush(heap, (prev_count, prev_char))\n        \n        # Update previous character info (decrease count by 1)\n        prev_count, prev_char = count + 1, char\n    \n    return ''.join(result)", "is_syntactically_valid": true}
{"task_id": 40, "generation": "from collections import Counter\n\ndef freq_element(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened = []\n    for sublist in list_of_lists:\n        flattened.extend(sublist)\n    \n    # Use Counter to count frequencies\n    frequency_counter = Counter(flattened)\n    \n    # Convert Counter to dictionary and return\n    return dict(frequency_counter)", "is_syntactically_valid": true}
{"task_id": 41, "generation": "def filter_evennumbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))", "is_syntactically_valid": true}
{"task_id": 42, "generation": "def find_Sum(arr, n):\n    element_count = {}\n    \n    # Count occurrences of each element\n    for element in arr:\n        element_count[element] = element_count.get(element, 0) + 1\n    \n    # Sum elements that appear more than once\n    total_sum = 0\n    for element, count in element_count.items():\n        if count > 1:\n            total_sum += element\n    \n    return total_sum", "is_syntactically_valid": true}
{"task_id": 43, "generation": "import re\n\ndef text_match(text):\n    pattern = r'^[a-z]+_[a-z]+$'\n    if re.match(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'", "is_syntactically_valid": true}
{"task_id": 44, "generation": "import re\n\ndef text_match_string(text):\n    pattern = r'^python'\n    if re.match(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'", "is_syntactically_valid": true}
{"task_id": 45, "generation": "import math\nfrom functools import reduce\n\ndef get_gcd(arr):\n    return reduce(math.gcd, arr)", "is_syntactically_valid": true}
{"task_id": 46, "generation": "def test_distinct(numbers):\n    return len(numbers) == len(set(numbers))", "is_syntactically_valid": true}
{"task_id": 47, "generation": "def compute_Last_Digit(a, b):\n    if b < a:\n        return 1\n    \n    result = 1\n    for i in range(a + 1, b + 1):\n        result = (result * i) % 10\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 48, "generation": "def odd_bit_set_number(n):\n    # Create a mask with all odd bits set (1st, 3rd, 5th, etc.)\n    # In binary: ...10101010101010101010101010101010\n    mask = 0xAAAAAAAA\n    \n    # Set all odd bits by OR-ing with the mask\n    return n | mask", "is_syntactically_valid": true}
{"task_id": 49, "generation": "def specified_element(two_d_list, index):\n    result = []\n    for row in two_d_list:\n        result.append(row[index])\n    return result", "is_syntactically_valid": true}
{"task_id": 50, "generation": "def min_length_list(lists):\n    min_list = min(lists, key=lambda x: len(x))\n    return (len(min_list), min_list)", "is_syntactically_valid": true}
{"task_id": 51, "generation": "def check_equilateral(a, b, c):\n    return a == b == c", "is_syntactically_valid": true}
{"task_id": 52, "generation": "def parallelogram_area(base, height):\n    return base * height", "is_syntactically_valid": true}
{"task_id": 53, "generation": "def check_Equality(s):\n    if s[0] == s[-1]:\n        return \"Equal\"\n    else:\n        return \"Not Equal\"", "is_syntactically_valid": true}
{"task_id": 54, "generation": "def counting_sort(arr):\n    if not arr:\n        return arr\n    \n    # Find the range of input\n    min_val = min(arr)\n    max_val = max(arr)\n    range_val = max_val - min_val + 1\n    \n    # Create count array\n    count = [0] * range_val\n    \n    # Count occurrences of each element\n    for num in arr:\n        count[num - min_val] += 1\n    \n    # Build the sorted array\n    result = []\n    for i in range(range_val):\n        result.extend([i + min_val] * count[i])\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 55, "generation": "def tn_gp(a, n, r):\n    return a * (r ** (n - 1))", "is_syntactically_valid": true}
{"task_id": 56, "generation": "def check(num):\n    # Convert number to string to easily reverse it\n    num_str = str(num)\n    \n    # Reverse the string and convert back to integer\n    reversed_num = int(num_str[::-1])\n    \n    # Check if num is one less than twice its reverse\n    return num == (2 * reversed_num - 1)", "is_syntactically_valid": true}
{"task_id": 57, "generation": "def find_Max_Num(digits, n):\n    # Sort digits in descending order to get the largest number\n    digits.sort(reverse=True)\n    \n    # Convert digits to string and join them\n    result = ''.join(map(str, digits))\n    \n    # Convert back to integer and return\n    return int(result)", "is_syntactically_valid": true}
{"task_id": 58, "generation": "def opposite_Signs(a, b):\n    return (a > 0 and b < 0) or (a < 0 and b > 0)", "is_syntactically_valid": true}
{"task_id": 59, "generation": "def is_octagonal(n):\n    return n * (3 * n - 2)", "is_syntactically_valid": true}
{"task_id": 60, "generation": "def max_len_sub(arr, max_diff):\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) <= max_diff:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)", "is_syntactically_valid": true}
{"task_id": 61, "generation": "def count_Substrings(s, n):\n    count = 0\n    \n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            length = j - i + 1\n            if digit_sum == length:\n                count += 1\n    \n    return count", "is_syntactically_valid": true}
{"task_id": 62, "generation": "def smallest_num(numbers):\n    return min(numbers)", "is_syntactically_valid": true}
{"task_id": 63, "generation": "def max_difference(tuple_list):\n    max_diff = 0\n    for pair in tuple_list:\n        diff = abs(pair[0] - pair[1])\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff", "is_syntactically_valid": true}
{"task_id": 64, "generation": "def subject_marks(tuples_list):\n    return sorted(tuples_list, key=lambda x: x[1])", "is_syntactically_valid": true}
{"task_id": 65, "generation": "def recursive_list_sum(lst):\n    total = 0\n    for item in lst:\n        if isinstance(item, list):\n            total += recursive_list_sum(item)\n        else:\n            total += item\n    return total", "is_syntactically_valid": true}
{"task_id": 66, "generation": "def pos_count(arr):\n    count = 0\n    for num in arr:\n        if num > 0:\n            count += 1\n    return count", "is_syntactically_valid": true}
{"task_id": 67, "generation": "def bell_number(n):\n    if n == 0:\n        return 1\n    \n    # Create a 2D array to store Bell triangle\n    bell = [[0 for i in range(n+1)] for j in range(n+1)]\n    bell[0][0] = 1\n    \n    for i in range(1, n+1):\n        # First element in each row is same as last element of previous row\n        bell[i][0] = bell[i-1][i-1]\n        \n        # Fill the rest of the row\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    \n    return bell[n][0]", "is_syntactically_valid": true}
{"task_id": 68, "generation": "def is_Monotonic(arr):\n    if len(arr) <= 1:\n        return True\n    \n    increasing = True\n    decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            decreasing = False\n        elif arr[i] < arr[i-1]:\n            increasing = False\n    \n    return increasing or decreasing", "is_syntactically_valid": true}
{"task_id": 69, "generation": "def is_sublist(main_list, sub_list):\n    if not sub_list:\n        return True\n    \n    if len(sub_list) > len(main_list):\n        return False\n    \n    for i in range(len(main_list) - len(sub_list) + 1):\n        if main_list[i:i + len(sub_list)] == sub_list:\n            return True\n    \n    return False", "is_syntactically_valid": true}
{"task_id": 70, "generation": "def get_equal(tuples_list, expected_length):\n    for tuple_item in tuples_list:\n        if len(tuple_item) != expected_length:\n            return 'All tuples do not have same length'\n    return 'All tuples have same length'", "is_syntactically_valid": true}
{"task_id": 71, "generation": "def comb_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    # Make a copy to avoid modifying the original array\n    arr = arr.copy()\n    \n    gap = len(arr)\n    shrink = 1.3\n    sorted = False\n    \n    while not sorted:\n        # Update the gap value for next comb\n        gap = int(gap / shrink)\n        \n        if gap <= 1:\n            gap = 1\n            sorted = True\n        \n        # A single \"comb\" over the input list\n        i = 0\n        while i + gap < len(arr):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n            i += 1\n    \n    return arr", "is_syntactically_valid": true}
{"task_id": 72, "generation": "def dif_Square(n):\n    # A number can be represented as difference of two squares if and only if\n    # it is not of the form 4k + 2 (where k is a non-negative integer)\n    return n % 4 != 2", "is_syntactically_valid": true}
{"task_id": 73, "generation": "import re\n\ndef multiple_split(text):\n    return re.split(r'[\\n*]', text)", "is_syntactically_valid": true}
{"task_id": 74, "generation": "def is_samepatterns(arr1, arr2):\n    if len(arr1) != len(arr2):\n        return False\n    \n    map1_to_2 = {}\n    map2_to_1 = {}\n    \n    for i in range(len(arr1)):\n        elem1, elem2 = arr1[i], arr2[i]\n        \n        if elem1 in map1_to_2:\n            if map1_to_2[elem1] != elem2:\n                return False\n        else:\n            map1_to_2[elem1] = elem2\n            \n        if elem2 in map2_to_1:\n            if map2_to_1[elem2] != elem1:\n                return False\n        else:\n            map2_to_1[elem2] = elem1\n    \n    return True", "is_syntactically_valid": true}
{"task_id": 75, "generation": "def find_tuples(tuples_list, k):\n    result = []\n    for tuple_item in tuples_list:\n        if all(element % k == 0 for element in tuple_item):\n            result.append(tuple_item)\n    return str(result)", "is_syntactically_valid": true}
{"task_id": 76, "generation": "def count_Squares(m, n):\n    total_squares = 0\n    \n    # For each possible square size k x k\n    for k in range(1, min(m, n) + 1):\n        # Number of k x k squares that can fit in m x n rectangle\n        # is (m - k + 1) * (n - k + 1)\n        squares_of_size_k = (m - k + 1) * (n - k + 1)\n        total_squares += squares_of_size_k\n    \n    return total_squares", "is_syntactically_valid": true}
{"task_id": 77, "generation": "Looking at the test cases, I need to understand what the function should do:\n\n- `is_Diff(12345)` returns `False`\n- `is_Diff(1212112)` returns `True` \n- `is_Diff(1212)` returns `False`\n\nLet me analyze what \"difference between sum of even and odd digits\" means and when it should return `True` or `False`.\n\nFor each number, I'll calculate:\n1. Sum of even digits\n2. Sum of odd digits\n3. Check if there's a specific condition about their difference\n\nLet me trace through the examples:\n- 12345: even digits = [2, 4], odd digits = [1, 3, 5]\n  - Sum of even = 6, sum of odd = 9, difference = |6-9| = 3\n- 1212112: even digits = [2, 2, 2], odd digits = [1, 1, 1, 1]\n  - Sum of even = 6, sum of odd = 4, difference = |6-4| = 2\n- 1212: even digits = [2, 2], odd digits = [1, 1]\n  - Sum of even = 4, sum of odd = 2, difference = |4-2| = 2\n\nLooking at the pattern, it seems like the function should return `True` when there IS a difference, and `False` when the sums are equal or follow some other pattern.\n\nWait, let me reconsider. Looking more carefully:\n- 1212112 returns True (difference = 2)\n- 1212 returns False (difference = 2)\n\nMaybe it's about whether the difference is odd? Let me check:\n- 12345: difference = 3 (odd) \u2192 False\n- 1212112: difference = 2 (even) \u2192 True  \n- 1212: difference = 2 (even) \u2192 False\n\nThat doesn't work either. Let me try another approach - maybe it's about the absolute difference being greater than some threshold, or the difference being exactly some value.\n\nActually, let me check if it's about whether the sum of even digits is greater than sum of odd digits:\n- 12345", "is_syntactically_valid": false}
{"task_id": 78, "generation": "def count_With_Odd_SetBits(n):\n    count = 0\n    for i in range(1, n + 1):\n        # Count set bits in binary representation of i\n        set_bits = bin(i).count('1')\n        # Check if number of set bits is odd\n        if set_bits % 2 == 1:\n            count += 1\n    return count", "is_syntactically_valid": true}
{"task_id": 79, "generation": "def word_len(word):\n    return len(word) % 2 == 1", "is_syntactically_valid": true}
{"task_id": 80, "generation": "def tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) / 6", "is_syntactically_valid": true}
{"task_id": 81, "generation": "def zip_tuples(tuple1, tuple2):\n    result = []\n    len1, len2 = len(tuple1), len(tuple2)\n    \n    for i in range(len1):\n        pair = (tuple1[i], tuple2[i % len2])\n        result.append(pair)\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 82, "generation": "import math\n\ndef volume_sphere(radius):\n    return (4/3) * math.pi * (radius ** 3)", "is_syntactically_valid": true}
{"task_id": 83, "generation": "def get_Char(s):\n    total = sum(ord(char) - ord('a') for char in s)\n    return chr(total % 26 + ord('a'))", "is_syntactically_valid": true}
{"task_id": 84, "generation": "def sequence(n):\n    if n == 1 or n == 2:\n        return 1\n    \n    # Initialize the sequence with first two values\n    newman_conway = [0, 1, 1]  # index 0 is unused, sequence starts from index 1\n    \n    # Build the sequence up to n\n    for i in range(3, n + 1):\n        newman_conway.append(newman_conway[newman_conway[i-1]] + newman_conway[i - newman_conway[i-1]])\n    \n    return newman_conway[n]", "is_syntactically_valid": true}
{"task_id": 85, "generation": "import math\n\ndef surfacearea_sphere(radius):\n    return 4 * math.pi * radius ** 2", "is_syntactically_valid": true}
{"task_id": 86, "generation": "def centered_hexagonal_number(n):\n    return 3 * n * (n - 1) + 1", "is_syntactically_valid": true}
{"task_id": 87, "generation": "def merge_dictionaries_three(dict1, dict2, dict3):\n    return {**dict1, **dict2, **dict3}", "is_syntactically_valid": true}
{"task_id": 88, "generation": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "is_syntactically_valid": true}
{"task_id": 89, "generation": "def closest_num(n):\n    return n - 1", "is_syntactically_valid": true}
{"task_id": 90, "generation": "def len_log(words):\n    return max(len(word) for word in words)", "is_syntactically_valid": true}
{"task_id": 91, "generation": "def find_substring(string_list, substring):\n    for string in string_list:\n        if substring in string:\n            return True\n    return False", "is_syntactically_valid": true}
{"task_id": 92, "generation": "def is_undulating(s):\n    if len(s) < 3:\n        return len(s) == 3 and s[0] == s[2] and s[0] != s[1]\n    \n    # Check if string alternates between exactly two different digits\n    first_digit = s[0]\n    second_digit = s[1]\n    \n    # First two digits must be different\n    if first_digit == second_digit:\n        return False\n    \n    # Check if pattern alternates throughout\n    for i in range(len(s)):\n        if i % 2 == 0:  # Even positions should match first digit\n            if s[i] != first_digit:\n                return False\n        else:  # Odd positions should match second digit\n            if s[i] != second_digit:\n                return False\n    \n    return True", "is_syntactically_valid": true}
{"task_id": 93, "generation": "def power(a, b):\n    return a ** b", "is_syntactically_valid": true}
{"task_id": 94, "generation": "def index_minimum(tuples_list):\n    min_value = float('inf')\n    min_name = None\n    \n    for name, value in tuples_list:\n        if value < min_value:\n            min_value = value\n            min_name = name\n    \n    return min_name", "is_syntactically_valid": true}
{"task_id": 95, "generation": "def Find_Min_Length(sublists):\n    return min(len(sublist) for sublist in sublists)", "is_syntactically_valid": true}
{"task_id": 96, "generation": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "is_syntactically_valid": true}
{"task_id": 97, "generation": "def frequency_lists(lists):\n    frequency = {}\n    for sublist in lists:\n        for element in sublist:\n            frequency[element] = frequency.get(element, 0) + 1\n    return frequency", "is_syntactically_valid": true}
{"task_id": 98, "generation": "def multiply_num(numbers):\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)", "is_syntactically_valid": true}
{"task_id": 99, "generation": "def decimal_to_binary(decimal):\n    if decimal == 0:\n        return '0'\n    \n    binary = ''\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal = decimal // 2\n    \n    return binary", "is_syntactically_valid": true}
{"task_id": 100, "generation": "def next_smallest_palindrome(n):\n    def is_palindrome(num):\n        s = str(num)\n        return s == s[::-1]\n    \n    num = n + 1\n    while not is_palindrome(num):\n        num += 1\n    \n    return num", "is_syntactically_valid": true}
{"task_id": 101, "generation": "def kth_element(arr, n, k):\n    sorted_arr = sorted(arr)\n    return sorted_arr[k-1]", "is_syntactically_valid": true}
{"task_id": 102, "generation": "def snake_to_camel(snake_str):\n    words = snake_str.split('_')\n    return ''.join(word.capitalize() for word in words)", "is_syntactically_valid": true}
{"task_id": 103, "generation": "def eulerian_num(n, m):\n    # Base cases\n    if m == 0 or m == n - 1:\n        return 1\n    if m < 0 or m >= n:\n        return 0\n    \n    # Create a 2D array to store Eulerian numbers\n    # dp[i][j] represents A(i, j)\n    dp = [[0 for _ in range(n)] for _ in range(n + 1)]\n    \n    # Fill base cases\n    for i in range(n + 1):\n        if i > 0:\n            dp[i][0] = 1\n            if i - 1 < n:\n                dp[i][i - 1] = 1\n    \n    # Fill the dp table using the recurrence relation:\n    # A(n, m) = (m + 1) * A(n - 1, m) + (n - m) * A(n - 1, m - 1)\n    for i in range(2, n + 1):\n        for j in range(1, min(i, n)):\n            dp[i][j] = (j + 1) * dp[i - 1][j] + (i - j) * dp[i - 1][j - 1]\n    \n    return dp[n][m]", "is_syntactically_valid": true}
{"task_id": 104, "generation": "def sort_sublists(list_of_lists):\n    return list(map(lambda sublist: sorted(sublist), list_of_lists))", "is_syntactically_valid": true}
{"task_id": 105, "generation": "def count(lst):\n    return sum(lst)", "is_syntactically_valid": true}
{"task_id": 106, "generation": "def add_lists(list_, tuple_):\n    return tuple_ + tuple(list_)", "is_syntactically_valid": true}
{"task_id": 107, "generation": "def count_Hexadecimal(start, end):\n    count = 0\n    for num in range(start, end + 1):\n        # Convert number to string and check", "is_syntactically_valid": false}
{"task_id": 108, "generation": "import heapq\n\ndef merge_sorted_list(*lists):\n    # First, sort each input list\n    sorted_lists = [sorted(lst) for lst in lists]\n    \n    # Create a min heap with (value, list_index, element_index) tuples\n    heap = []\n    \n    # Initialize heap with first element from each non-empty list\n    for i, lst in enumerate(sorted_lists):\n        if lst:  # Only add if list is not empty\n            heapq.heappush(heap, (lst[0], i, 0))\n    \n    result = []\n    \n    # Process heap until empty\n    while heap:\n        # Get the smallest element\n        value, list_idx, elem_idx = heapq.heappop(heap)\n        result.append(value)\n        \n        # Add next element from the same list if it exists\n        if elem_idx + 1 < len(sorted_lists[list_idx]):\n            next_value = sorted_lists[list_idx][elem_idx + 1]\n            heapq.heappush(heap, (next_value, list_idx, elem_idx + 1))\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 109, "generation": "def odd_Equivalent(binary_string, n):\n    # Count the number of '1's in the binary string\n    # Each rotation that ends with '1' will result in an odd number\n    count_ones = binary_string.count('1')\n    return count_ones", "is_syntactically_valid": true}
{"task_id": 110, "generation": "def extract_missing(ranges, start, end):\n    missing = []\n    \n    # For each range, add gaps before and after\n    for range_start, range_end in ranges:\n        # Gap before the range\n        missing.append((start, range_start))\n        # Gap after the range\n        missing.append((range_end, end))\n    \n    # Add gaps between consecutive ranges\n    for i in range(len(ranges) - 1):\n        current_end = ranges[i][1]\n        next_start = ranges[i + 1][0]\n        missing.append((current_end, next_start))\n    \n    return missing", "is_syntactically_valid": true}
{"task_id": 111, "generation": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    # Start with the first list as the initial set of common elements\n    common = set(nested_lists[0])\n    \n    # Find intersection with each subsequent list\n    for lst in nested_lists[1:]:\n        common = common.intersection(set(lst))\n    \n    # Return as a list\n    return list(common)", "is_syntactically_valid": true}
{"task_id": 112, "generation": "def perimeter(radius, height):\n    return 2 * (radius + height)", "is_syntactically_valid": true}
{"task_id": 113, "generation": "def check_integer(s):\n    try:\n        int(s)\n        return True\n    except ValueError:\n        return False", "is_syntactically_valid": true}
{"task_id": 114, "generation": "def assign_freq(tuple_list):\n    freq_dict = {}\n    \n    # Count frequency of each tuple\n    for tup in tuple_list:\n        if tup in freq_dict:\n            freq_dict[tup] += 1\n        else:\n            freq_dict[tup] = 1\n    \n    # Create result list with tuples and their frequencies\n    result = []\n    for tup, freq in freq_dict.items():\n        result.append(tup + (freq,))\n    \n    return str(result)", "is_syntactically_valid": true}
{"task_id": 115, "generation": "def empty_dit(data):\n    if isinstance(data, dict):\n        return len(data) == 0\n    \n    if isinstance(data, list):\n        for item in data:\n            if not isinstance(item, dict) or len(item) > 0:\n                return False\n        return True\n    \n    return False", "is_syntactically_valid": true}
{"task_id": 116, "generation": "def tuple_to_int(t):\n    result = 0\n    for digit in t:\n        result = result * 10 + digit\n    return result", "is_syntactically_valid": true}
{"task_id": 117, "generation": "def list_to_float(lst):\n    def convert_element(element):\n        if isinstance(element, (tuple, list)):\n            return tuple(convert_element(item) for item in element)\n        else:\n            try:\n                return float(element)\n            except (ValueError, TypeError):\n                return element\n    \n    result = [convert_element(item) for item in lst]\n    return str(result)", "is_syntactically_valid": true}
{"task_id": 118, "generation": "def string_to_list(s):\n    return s.split()", "is_syntactically_valid": true}
{"task_id": 119, "generation": "def search(arr, n):\n    left, right = 0, n - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        # If mid is even, the single element should be on the right\n        # If mid is odd, the single element should be on the left\n        if mid % 2 == 0:\n            # Check if arr[mid] == arr[mid + 1]\n            if mid + 1 < n and arr[mid] == arr[mid + 1]:\n                left = mid + 2\n            else:\n                right = mid - 1\n        else:\n            # Check if arr[mid] == arr[mid - 1]\n            if arr[mid] == arr[mid - 1]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    return arr[left]", "is_syntactically_valid": true}
{"task_id": 120, "generation": "def max_product_tuple(tuples_list):\n    max_product = 0\n    for tuple_pair in tuples_list:\n        product = tuple_pair[0] * tuple_pair[1]\n        if product > max_product:\n            max_product = product\n    return max_product", "is_syntactically_valid": true}
{"task_id": 121, "generation": "Looking at the test cases, I need to understand what the function should do:\n\n- `check_triplet([2, 7, 4, 0, 9, 5, 1, 3], 8, 6, 0)` returns `True`\n- `check_triplet([1, 4, 5, 6, 7, 8, 5, 9], 8, 6, 0)` returns `False`  \n- `check_triplet([10, 4, 2, 3, 5], 5, 15, 0)` returns `True`\n\nFrom the test cases, it appears the function takes an array and three numbers, and needs to check if there's a triplet in the array that matches those three numbers in some way.\n\nLooking at the first test case: array `[2, 7, 4, 0, 9, 5, 1, 3]` with values `8, 6, 0`. The sum is 8+6+0=14. Let me check if there's a triplet that sums to 14: 2+7+5=14, 4+9+1=14, etc.\n\nWait, let me reconsider. Maybe it's checking if the three given numbers exist in the array as a triplet. Let me check:\n- First test: 8, 6, 0 - but 8 and 6 are not in the array `[2, 7, 4, 0, 9, 5, 1, 3]`\n- Third test: 5, 15, 0 - but 15 and 0 are not in the array `[10, 4, 2, 3, 5]`\n\nLet me try another interpretation: maybe it's checking if there's a triplet in the array that sums to the sum of the three given numbers.\n\nFirst test: 8+6+0=14, and in `[2, 7, 4, 0, 9, 5, 1, 3]` we can find 2+7+5=14 \u2713\nSecond test: 8+6+0=14, and in `[1", "is_syntactically_valid": false}
{"task_id": 122, "generation": "def smartNumber(n):\n    def count_prime_factors(num):\n        count = 0\n        d = 2\n        while d * d <= num:\n            while num % d == 0:\n                count += 1\n                num //= d\n            d += 1\n        if num > 1:\n            count += 1\n        return count\n    \n    count = 0\n    num = 2\n    while count < n:\n        if count_prime_factors(num) == 3:\n            count += 1\n            if count == n:\n                return num\n        num += 1\n    \n    return num", "is_syntactically_valid": true}
{"task_id": 123, "generation": "def amicable_numbers_sum(n):\n    def sum_of_proper_divisors(num):\n        if num <= 1:\n            return 0\n        divisors_sum = 1\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                divisors_sum += i\n                if i != num // i:\n                    divisors_sum += num // i\n        return divisors_sum\n    \n    amicable_sum = 0\n    for i in range(1, n + 1):\n        sum_i = sum_of_proper_divisors(i)\n        if sum_i > i and sum_i <= n:\n            sum_sum_i = sum_of_proper_divisors(sum_i)\n            if sum_sum_i == i:\n                amicable_sum += i + sum_i\n    \n    return amicable_sum", "is_syntactically_valid": true}
{"task_id": 124, "generation": "import math\n\ndef angle_complex(real, imag):\n    return math.atan2(imag, real)", "is_syntactically_valid": true}
{"task_id": 125, "generation": "def find_length(binary_string, n):\n    max_diff = 0\n    \n    # Try all possible substrings\n    for i in range(n):\n        zeros = 0\n        ones = 0\n        for j in range(i, n):\n            if binary_string[j] == '0':\n                zeros += 1\n            else:\n                ones += 1\n            \n            # Calculate difference for current substring\n            diff = abs(zeros - ones)\n            max_diff = max(max_diff, diff)\n    \n    return max_diff", "is_syntactically_valid": true}
{"task_id": 126, "generation": "def sum(a, b):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    \n    def get_divisors(n):\n        divisors = []\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.append(i)\n                if i != n // i:\n                    divisors.append(n // i)\n        return divisors\n    \n    divisors_a = get_divisors(a)\n    divisors_b = get_divisors(b)\n    \n    common_divisors = []\n    for div in divisors_a:\n        if div in divisors_b:\n            common_divisors.append(div)\n    \n    return sum(common_divisors)", "is_syntactically_valid": true}
{"task_id": 127, "generation": "def multiply_int(a, b):\n    if a == 0 or b == 0:\n        return 0\n    \n    # Handle negative numbers\n    negative = False\n    if a < 0:\n        negative = not negative\n        a = -a\n    if b < 0:\n        negative = not negative\n        b = -b\n    \n    result = 0\n    while b > 0:\n        result += a\n        b -= 1\n    \n    return -result if negative else result", "is_syntactically_valid": true}
{"task_id": 128, "generation": "def long_words(n, sentence):\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "is_syntactically_valid": true}
{"task_id": 129, "generation": "def magic_square_test(square):\n    n = len(square)\n    \n    # Check if it's a square matrix\n    for row in square:\n        if len(row) != n:\n            return False\n    \n    # Calculate the magic sum (sum of first row)\n    magic_sum = sum(square[0])\n    \n    # Check all rows\n    for row in square:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check all columns\n    for col in range(n):\n        col_sum = sum(square[row][col] for row in range(n))\n        if col_sum != magic_sum:\n            return False\n    \n    # Check main diagonal (top-left to bottom-right)\n    main_diag_sum = sum(square[i][i] for i in range(n))\n    if main_diag_sum != magic_sum:\n        return False\n    \n    # Check anti-diagonal (top-right to bottom-left)\n    anti_diag_sum = sum(square[i][n-1-i] for i in range(n))\n    if anti_diag_sum != magic_sum:\n        return False\n    \n    return True", "is_syntactically_valid": true}
{"task_id": 130, "generation": "def max_occurrences(lst):\n    frequency = {}\n    \n    # Count frequency of each element\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n    \n    # Find the item with maximum frequency\n    max_freq = 0\n    max_item = None\n    \n    for item, freq in frequency.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    \n    return (max_item, max_freq)", "is_syntactically_valid": true}
{"task_id": 131, "generation": "def reverse_vowels(s):\n    vowels = \"aeiouAEIOU\"\n    s_list = list(s)\n    vowel_chars = []\n    vowel_indices = []\n    \n    # Find all vowels and their indices\n    for i, char in enumerate(s_list):\n        if char in vowels:\n            vowel_chars.append(char)\n            vowel_indices.append(i)\n    \n    # Reverse the vowels and place them back\n    vowel_chars.reverse()\n    for i, index in enumerate(vowel_indices):\n        s_list[index] = vowel_chars[i]\n    \n    return ''.join(s_list)", "is_syntactically_valid": true}
{"task_id": 132, "generation": "def tup_string(tup):\n    return ''.join(tup)", "is_syntactically_valid": true}
{"task_id": 133, "generation": "def sum_negativenum(numbers):\n    return sum(filter(lambda x: x < 0, numbers))", "is_syntactically_valid": true}
{"task_id": 134, "generation": "def check_last(arr, n, p):\n    # Perform left rotation p times\n    # Since rotating by array length brings back to original position\n    effective_rotations = p % len(arr)\n    \n    # Left rotation by effective_rotations\n    rotated_arr = arr[effective_rotations:] + arr[:effective_rotations]\n    \n    last_element = rotated_arr[-1]\n    \n    if last_element % 2 == 0:\n        return \"EVEN\"\n    else:\n        return \"ODD\"", "is_syntactically_valid": true}
{"task_id": 135, "generation": "def hexagonal_num(n):\n    return n * (2 * n - 1)", "is_syntactically_valid": true}
{"task_id": 136, "generation": "def cal_electbill(units):\n    if units <= 50:\n        return units * 2.60\n    elif units <= 100:\n        return 50 * 2.60 + (units - 50) * 3.25\n    elif units <= 200:\n        return 50 * 2.60 + 50 * 3.25 + (units - 100) * 5.26\n    else:\n        return 50 * 2.60 + 50 * 3.25 + 100 * 5.26 + (units - 200) * 7.75", "is_syntactically_valid": true}
{"task_id": 137, "generation": "def zero_count(arr):\n    if len(arr) == 0:\n        return 0.0\n    \n    zero_count = arr.count(0)\n    return round(zero_count / len(arr), 2)", "is_syntactically_valid": true}
{"task_id": 138, "generation": "def is_Sum_Of_Powers_Of_Two(n):\n    if n <= 0:\n        return False\n    \n    # A number can be represented as sum of non-zero powers of 2\n    # if and only if it doesn't have consecutive 1s in its binary representation\n    # This is because consecutive 1s would require using the same power of 2 multiple times\n    \n    binary = bin(n)[2:]  # Convert to binary and remove '0b' prefix\n    \n    # Check for consecutive 1s\n    for i in range(len(binary) - 1):\n        if binary[i] == '1' and binary[i + 1] == '1':\n            return False\n    \n    return True", "is_syntactically_valid": true}
{"task_id": 139, "generation": "import math\n\ndef circle_circumference(radius):\n    return 2 * math.pi * radius", "is_syntactically_valid": true}
{"task_id": 140, "generation": "def extract_singly(tuple_list):\n    from collections import Counter\n    \n    # Flatten all elements from all tuples\n    all_elements = []\n    for tup in tuple_list:\n        all_elements.extend(tup)\n    \n    # Count occurrences of each element\n    element_counts = Counter(all_elements)\n    \n    # Extract elements that occur only once, maintaining order\n    result = []\n    seen = set()\n    \n    for tup in tuple_list:\n        for element in tup:\n            if element_counts[element] == 1 and element not in seen:\n                result.append(element)\n                seen.add(element)\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 141, "generation": "def pancake_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    arr = arr.copy()\n    \n    def flip(arr, k):\n        arr[:k+1] = arr[:k+1][::-1]\n    \n    def find_max_index(arr, n):\n        max_idx = 0\n        for i in range(1, n):\n            if arr[i] > arr[max_idx]:\n                max_idx = i\n        return max_idx\n    \n    n = len(arr)\n    \n    for curr_size in range(n, 1, -1):\n        max_idx = find_max_index(arr, curr_size)\n        \n        if max_idx != curr_size - 1:\n            if max_idx != 0:\n                flip(arr, max_idx)\n            \n            flip(arr, curr_size - 1)\n    \n    return arr", "is_syntactically_valid": true}
{"task_id": 142, "generation": "def count_samepair(list1, list2, list3):\n    count = 0\n    min_length = min(len(list1), len(list2), len(list3))\n    \n    for i in range(min_length):\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    \n    return count", "is_syntactically_valid": true}
{"task_id": 143, "generation": "def find_lists(tuple_of_lists):\n    count = 0\n    for item in tuple_of_lists:\n        if isinstance(item, list):\n            count += 1\n    return count", "is_syntactically_valid": true}
{"task_id": 144, "generation": "def sum_Pairs(arr, n):\n    total = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total += abs(arr[i] - arr[j])\n    return total", "is_syntactically_valid": true}
{"task_id": 145, "generation": "def max_Abs_Diff(arr, n):\n    if n < 2:\n        return 0\n    \n    min_val = min(arr)\n    max_val = max(arr)\n    \n    return max_val - min_val", "is_syntactically_valid": true}
{"task_id": 146, "generation": "def ascii_value_string(s):\n    return sum(ord(char) for char in s)", "is_syntactically_valid": true}
{"task_id": 147, "generation": "def max_path_sum(triangle, rows, cols):\n    # Create a copy to avoid modifying the original\n    dp = [row[:] for row in triangle]\n    \n    # Start from the second row and work downwards\n    for i in range(1, rows):\n        for j in range(i + 1):  # Each row i has i+1 elements\n            # For each position, take the maximum from the two possible previous positions\n            if j == 0:\n                # Leftmost element can only come from position 0 of previous row\n                dp[i][j] = triangle[i][j] + dp[i-1][0]\n            elif j == i:\n                # Rightmost element can only come from position j-1 of previous row\n                dp[i][j] = triangle[i][j] + dp[", "is_syntactically_valid": false}
{"task_id": 148, "generation": "def sum_digits_twoparts(n):\n    def digit_sum(num):\n        return sum(int(digit) for digit in str(num))\n    \n    if n < 10:\n        return digit_sum(n)\n    \n    max_sum = 0\n    \n    # Try all possible splits\n    for i in range(1, n):\n        part1 = i\n        part2 = n - i\n        current_sum = digit_sum(part1) + digit_sum(part2)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "is_syntactically_valid": true}
{"task_id": 149, "generation": "def longest_subseq_with_diff_one(arr, n):\n    if n == 0:\n        return 0\n    \n    # dp[i] stores the length of longest subsequence ending at index i\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            # Check if current element and previous element differ by 1\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    # Return the maximum length found\n    return max(dp)", "is_syntactically_valid": true}
{"task_id": 150, "generation": "def does_Contain_B(a, b, c):\n    if b == 0:\n        return c == a\n    \n    if (c - a) % b != 0:\n        return False\n    \n    n = (c - a) // b\n    return n >= 0", "is_syntactically_valid": true}
{"task_id": 151, "generation": "import math\n\ndef is_coprime(a, b):\n    return math.gcd(a, b) == 1", "is_syntactically_valid": true}
{"task_id": 152, "generation": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 153, "generation": "def parabola_vertex(a, b, c):\n    # For a parabola in the form ax^2 + bx + c\n    # The x-coordinate of the vertex is -b/(2a)\n    # The y-coordinate is found by substituting x back into the equation\n    \n    x_vertex = -b / (2 * a)\n    y_vertex = a * (x_vertex ** 2) + b * x_vertex + c\n    \n    return (x_vertex, y_vertex)", "is_syntactically_valid": true}
{"task_id": 154, "generation": "def specified_element(two_d_list, index):\n    result = []\n    for row in two_d_list:\n        result.append(row[index])\n    return result", "is_syntactically_valid": true}
{"task_id": 155, "generation": "def even_bit_toggle_number(n):\n    # Create a mask with all even bits set to 1\n    # Even bits are at positions 0, 2, 4, 6, 8, etc.\n    # In binary: ...10101010 (0xAAAAAAAA for 32-bit)\n    mask = 0\n    bit_position = 0\n    temp = n\n    \n    # Find the highest bit position in the number\n    while temp > 0:\n        temp >>= 1\n        bit_position += 1\n    \n    # Create mask for even positions (0, 2, 4, 6, ...)\n    for i in range(0, bit_position + 1, 2):\n        mask |= (1 << i)\n    \n    # Toggle even bits using XOR with the mask\n    return n ^ mask", "is_syntactically_valid": true}
{"task_id": 156, "generation": "def tuple_int_str(tuple_of_tuples):\n    return tuple(tuple(int(value) for value in inner_tuple) for inner_tuple in tuple_of_tuples)", "is_syntactically_valid": true}
{"task_id": 157, "generation": "def encode_list(data):\n    if not data:\n        return []\n    \n    result = []\n    current_element = data[0]\n    count = 1\n    \n    for i in range(1, len(data)):\n        if data[i] == current_element:\n            count += 1\n        else:\n            result.append([count, current_element])\n            current_element = data[i]\n            count = 1\n    \n    # Add the last group\n    result.append([count, current_element])\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 158, "generation": "def min_Ops(arr, n, k):\n    # Check if all elements are already equal\n    if len(set(arr)) == 1:\n        return 0\n    \n    # Find all possible target values\n    # Each element can reach values of the form: arr[i] + m*k for integer m\n    # We need to find a common value that all elements can reach\n    \n    min_ops = float('inf')\n    found_solution = False\n    \n    # Try different target values\n    # The target must be reachable from all elements with steps of size k\n    min_val = min(arr)\n    max_val = max(arr)\n    \n    # Check a reasonable range around the array values\n    for target in range(min_val - 100*k, max_val + 100*k + 1, k):\n        operations = 0\n        valid = True\n        \n        for val in arr:\n            diff = abs(target - val)\n            if diff % k != 0:\n                valid = False\n                break\n            operations += diff // k\n        \n        if valid:", "is_syntactically_valid": false}
{"task_id": 159, "generation": "def month_season(month, day):\n    # Define seasons based on months and days\n    if month in ['December', 'January', 'February']:\n        if month == 'December' and day >= 21:\n            return 'winter'\n        elif month in ['January', 'February']:\n            return 'winter'\n        elif month == 'December':\n            return 'autumn'\n    elif month in ['March', 'April', 'May']:\n        if month == 'March' and day >= 20:\n            return 'spring'\n        elif month in ['April', 'May']:\n            return 'spring'\n        elif month == 'March':\n            return 'winter'\n    elif month in ['June', 'July', 'August']:\n        if month == 'June' and day >= 21:\n            return 'summer'\n        elif month in ['July', 'August']:\n            return 'summer'\n        elif month == 'June':\n            return 'spring'\n    elif month in ['September', 'October', 'November']:\n        if month == 'September' and day >= 22:\n            return 'autumn'\n        elif month in ['October', 'November']:\n            return 'autumn'\n        elif month == 'September':\n            return 'summer'", "is_syntactically_valid": true}
{"task_id": 160, "generation": "def solution(a, b, n):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    \n    gcd, x, y = extended_gcd(a, b)\n    \n    if n % gcd != 0:\n        return 'No solution'\n    \n    x *= n // gcd\n    y *= n // gcd\n    \n    return ('x = ', x, ', y = ', y)", "is_syntactically_valid": true}
{"task_id": 161, "generation": "def remove_elements(original_list, elements_to_remove):\n    result = []\n    for item in original_list:\n        if item not in elements_to_remove:\n            result.append(item)\n    return result", "is_syntactically_valid": true}
{"task_id": 162, "generation": "def sum_series(n):\n    total = 0\n    current = n\n    while current > 0:\n        total += current\n        current -= 2\n    return total", "is_syntactically_valid": true}
{"task_id": 163, "generation": "import math\n\ndef area_polygon(n, s):\n    \"\"\"\n    Calculate the area of a regular polygon.\n    \n    n: number of sides\n    s: side length\n    \"\"\"\n    area = (n * s**2) / (4 * math.tan(math.pi / n))\n    return area", "is_syntactically_valid": true}
{"task_id": 164, "generation": "def areEquivalent(num1, num2):\n    def sum_of_divisors(n):\n        divisor_sum = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                divisor_sum += i\n        return divisor_sum\n    \n    return sum_of_divisors(num1) == sum_of_divisors(num2)", "is_syntactically_valid": true}
{"task_id": 165, "generation": "def count_char_position(s):\n    count = 0\n    for i, char in enumerate(s):\n        # Convert character to lowercase and get its position in alphabet (0-based)\n        char_pos = ord(char.lower()) - ord('a')\n        # Check if character position matches string index\n        if char_pos == i:\n            count += 1\n    return count", "is_syntactically_valid": true}
{"task_id": 166, "generation": "def find_even_Pair(arr, n):\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n    return count", "is_syntactically_valid": true}
{"task_id": 167, "generation": "def next_Power_Of_2(n):\n    if n <= 0:\n        return 1\n    \n    power = 1\n    while power < n:\n        power *= 2\n    \n    return power", "is_syntactically_valid": true}
{"task_id": 168, "generation": "def frequency(arr, num):\n    count = 0\n    for element in arr:\n        if element == num:\n            count += 1\n    return count", "is_syntactically_valid": true}
{"task_id": 169, "generation": "def get_pell(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Use iterative approach to calculate nth Pell number\n    # Pell sequence: P(n) = 2*P(n-1) + P(n-2)\n    prev_prev = 0  # P(0)\n    prev = 1       # P(1)\n    \n    for i in range(2, n + 1):\n        current = 2 * prev + prev_prev\n        prev_prev = prev\n        prev = current\n    \n    return prev", "is_syntactically_valid": true}
{"task_id": 170, "generation": "def sum_range_list(lst, start_index, end_index):\n    return sum(lst[start_index:end_index+1])", "is_syntactically_valid": true}
{"task_id": 171, "generation": "def perimeter_pentagon(side_length):\n    return 5 * side_length", "is_syntactically_valid": true}
{"task_id": 172, "generation": "def count_occurance(s):\n    count = 0\n    for i in range(len(s) - 2):\n        if s[i:i+3] == 'std':\n            count += 1\n    return count", "is_syntactically_valid": true}
{"task_id": 173, "generation": "def remove_splchar(s):\n    return ''.join([char for char in s if char.isalnum()])", "is_syntactically_valid": true}
{"task_id": 174, "generation": "def group_keyvalue(pairs):\n    result = {}\n    for key, value in pairs:\n        if key in result:\n            result[key].append(value)\n        else:\n            result[key] = [value]\n    return result", "is_syntactically_valid": true}
{"task_id": 175, "generation": "def is_valid_parenthese(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        elif char in '({[':\n            stack.append(char)\n    \n    return len(stack) == 0", "is_syntactically_valid": true}
{"task_id": 176, "generation": "def perimeter_triangle(a, b, c):\n    return a + b + c", "is_syntactically_valid": true}
{"task_id": 177, "generation": "import math\n\ndef answer(lower, upper):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    def lcm(a, b):\n        return (a * b) // gcd(a, b)\n    \n    # Try the pattern from test cases first: (lower, 2*lower)\n    if 2 * lower <= upper:\n        return (lower, 2 * lower)\n    \n    # If that doesn't work, search for other pairs\n    for a in range(lower, upper + 1):\n        for b in range(a + 1, upper + 1):\n            if lower <= lcm(a, b) <= upper:\n                return (a, b)\n    \n    return None", "is_syntactically_valid": true}
{"task_id": 178, "generation": "def string_literals(literals, text):\n    for literal in literals:\n        if literal in text:\n            return 'Matched!'\n    return 'Not Matched!'", "is_syntactically_valid": true}
{"task_id": 179, "generation": "def is_num_keith(n):\n    # Convert number to string to get individual digits\n    digits = [int(d) for d in str(n)]\n    num_digits = len(digits)\n    \n    # Initialize the sequence with the digits\n    sequence = digits[:]\n    \n    # Generate terms until we either find n or exceed it\n    while sequence[-1] < n:\n        # Calculate next term as sum of last num_digits terms\n        next_term = sum(sequence[-num_digits:])\n        sequence.append(next_term)\n    \n    # Check if the last term equals n\n    return sequence[-1] == n", "is_syntactically_valid": true}
{"task_id": 180, "generation": "import math\n\ndef distance_lat_long(lat1, lon1, lat2, lon2):\n    # Convert latitude and longitude from degrees to radians\n    lat1_rad = math.radians(lat1)\n    lon1_rad = math.radians(lon1)\n    lat2_rad = math.radians(lat2)\n    lon2_rad = math.radians(lon2)\n    \n    # Haversine formula\n    dlat = lat2_rad - lat1_rad\n    dlon = lon2_rad - lon1_rad\n    \n    a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2\n    c = 2 * math.asin(math.sqrt(a))\n    \n    # Earth's radius in kilometers\n    r = 6371\n    \n    # Calculate the distance\n    distance = r * c * 1000  # Convert to meters\n    \n    return distance", "is_syntactically_valid": true}
{"task_id": 181, "generation": "def common_prefix(strings, n):\n    if not strings or n == 0:\n        return ''\n    \n    prefix = ''\n    min_length = min(len(s) for s in strings)\n    \n    for i in range(min_length):\n        char = strings[0][i]\n        if all(s[i] == char for s in strings):\n            prefix += char\n        else:\n            break\n    \n    return prefix", "is_syntactically_valid": true}
{"task_id": 182, "generation": "import re\n\ndef find_character(s):\n    uppercase = re.findall(r'[A-Z]', s)\n    lowercase = re.findall(r'[a-z]', s)\n    digits = re.findall(r'[0-9]', s)\n    special = re.findall(r'[^A-Za-z0-9]', s)\n    \n    return (uppercase, lowercase, digits, special)", "is_syntactically_valid": true}
{"task_id": 183, "generation": "def count_pairs(arr, n, k):\n    num_set = set(arr)\n    count = 0\n    \n    for num in num_set:\n        if num + k in num_set:\n            count += 1\n    \n    return count", "is_syntactically_valid": true}
{"task_id": 184, "generation": "def greater_specificnum(lst, num):\n    for element in lst:\n        if element > num:\n            return True\n    return False", "is_syntactically_valid": true}
{"task_id": 185, "generation": "def parabola_focus(a, b, c):\n    # For parabola y = ax\u00b2 + bx + c\n    # Focus x-coordinate: -b/(2a)\n    # Focus y-coordinate: c - (b\u00b2-1)/(4a)\n    \n    x_focus = -b / (2 * a)\n    y_focus = c - (b * b - 1) / (4 * a)\n    \n    return (x_focus, y_focus)", "is_syntactically_valid": true}
{"task_id": 186, "generation": "import re\n\ndef check_literals(text, literals):\n    for literal in literals:\n        if re.search(re.escape(literal), text):\n            return 'Matched!'\n    return 'Not Matched!'", "is_syntactically_valid": true}
{"task_id": 187, "generation": "def longest_common_subsequence(X, Y, m, n):\n    # Create a 2D array to store lengths of longest common subsequence\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Fill the dp table using bottom-up approach\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if X[i-1] == Y[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    # The length of LCS is stored in dp[m][n]\n    return dp[m][n]", "is_syntactically_valid": true}
{"task_id": 188, "generation": "import math\n\ndef prod_Square(n):\n    if n <= 0:\n        return False\n    \n    # Check all possible values of a where a\u00b2 \u2264 n\n    for a in range(1, int(math.sqrt(n)) + 1):\n        a_squared = a * a\n        if n % a_squared == 0:\n            remaining = n // a_squared\n            # Check if remaining is a perfect square\n            b = int(math.sqrt(remaining))\n            if b * b == remaining:\n                return True\n    \n    return False", "is_syntactically_valid": true}
{"task_id": 189, "generation": "def first_Missing_Positive(nums, n):\n    # Create a set of positive numbers from the array\n    positive_nums = set(num for num in nums if num > 0)\n    \n    # Find the first missing positive number starting from 1\n    missing = 1\n    while missing in positive_nums:\n        missing += 1\n    \n    return missing", "is_syntactically_valid": true}
{"task_id": 190, "generation": "def count_Intgral_Points(x1, y1, x2, y2):\n    # Ensure we have the correct order of coordinates\n    min_x = min(x1, x2)\n    max_x = max(x1, x2)\n    min_y = min(y1, y2)\n    max_y = max(y1, y2)\n    \n    count = 0\n    # Count integral points strictly inside the square\n    for x in range(min_x + 1, max_x):\n        for y in range(min_y + 1, max_y):\n            count += 1\n    \n    return count", "is_syntactically_valid": true}
{"task_id": 191, "generation": "def check_monthnumber(month):\n    months_with_30_days = [\"April\", \"June\", \"September\", \"November\"]\n    return month in months_with_30_days", "is_syntactically_valid": true}
{"task_id": 192, "generation": "def check_String(s):\n    has_letter = False\n    has_number = False\n    \n    for char in s:\n        if char.isalpha():\n            has_letter = True\n        elif char.isdigit():\n            has_number = True\n        \n        if has_letter and has_number:\n            return True\n    \n    return False", "is_syntactically_valid": true}
{"task_id": 193, "generation": "def remove_tuple(input_tuple):\n    seen = set()\n    result = []\n    for item in input_tuple:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return tuple(result)", "is_syntactically_valid": true}
{"task_id": 194, "generation": "def octal_To_Decimal(octal_num):\n    decimal_num = 0\n    power = 0\n    \n    while octal_num > 0:\n        digit = octal_num % 10\n        decimal_num += digit * (8 ** power)\n        power += 1\n        octal_num //= 10\n    \n    return decimal_num", "is_syntactically_valid": true}
{"task_id": 195, "generation": "def first(arr, target, n):\n    for i in range(n):\n        if arr[i] == target:\n            return i\n    return -1", "is_syntactically_valid": true}
{"task_id": 196, "generation": "def remove_tuples(tuple_list, k):\n    return [t for t in tuple_list if len(t) != k]", "is_syntactically_valid": true}
{"task_id": 197, "generation": "def find_exponentio(tuple1, tuple2):\n    return tuple(a ** b for a, b in zip(tuple1, tuple2))", "is_syntactically_valid": true}
{"task_id": 198, "generation": "import math\n\ndef largest_triangle(a, b):\n    return (3 * math.sqrt(3) / 4) * a * b", "is_syntactically_valid": true}
{"task_id": 199, "generation": "def highest_Power_of_2(n):\n    if n <= 0:\n        return 0\n    \n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    \n    return power", "is_syntactically_valid": true}
{"task_id": 200, "generation": "def position_max(lst):\n    if not lst:\n        return []\n    \n    max_value = max(lst)\n    positions = []\n    \n    for i in range(len(lst)):\n        if lst[i] == max_value:\n            positions.append(i)\n    \n    return positions", "is_syntactically_valid": true}
{"task_id": 201, "generation": "def chkList(lst):\n    if not lst:\n        return True\n    \n    first_element = lst[0]\n    return all(element == first_element for element in lst)", "is_syntactically_valid": true}
{"task_id": 202, "generation": "def remove_even(s):\n    result = \"\"\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n    return result", "is_syntactically_valid": true}
{"task_id": 203, "generation": "def hamming_Distance(a, b):\n    # XOR the two numbers to get bits that are different\n    xor_result = a ^ b\n    \n    # Count the number of 1s in the XOR result\n    count = 0\n    while xor_result:\n        count += xor_result & 1\n        xor_result >>= 1\n    \n    return count", "is_syntactically_valid": true}
{"task_id": 204, "generation": "def count(string, char):\n    return string.count(char)", "is_syntactically_valid": true}
{"task_id": 205, "generation": "def inversion_elements(tup):\n    return tuple(-(x + 1) for x in tup)", "is_syntactically_valid": true}
{"task_id": 206, "generation": "def concatenate_elements(tup):\n    result = []\n    for i in range(len(tup) - 1):\n        concatenated = tup[i] + tup[i + 1]\n        result.append(concatenated)\n    return tuple(result)", "is_syntactically_valid": true}
{"task_id": 207, "generation": "def find_longest_repeating_subseq(s):\n    n = len(s)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if s[i-1] == s[j-1] and i != j:\n                dp[i][j] = 1 + dp[i-1][j-1]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    return dp[n][n]", "is_syntactically_valid": true}
{"task_id": 208, "generation": "import re\n\ndef is_decimal(s):\n    pattern = r'^\\d+\\.\\d{2}$'\n    return bool(re.match(pattern, s))", "is_syntactically_valid": true}
{"task_id": 209, "generation": "import heapq\n\ndef heap_replace(heap, item):\n    # Create a copy of the heap to avoid modifying the original\n    heap_copy = heap[:]\n    \n    # Convert to a proper min-heap\n    heapq.heapify(heap_copy)\n    \n    # Replace the smallest element (root) with the new item\n    heapq.heapreplace(heap_copy, item)\n    \n    return heap_copy", "is_syntactically_valid": true}
{"task_id": 210, "generation": "import re\n\ndef is_allowed_specific_char(string):\n    pattern = r'^[a-zA-Z0-9]+$'\n    return bool(re.match(pattern, string))", "is_syntactically_valid": true}
{"task_id": 211, "generation": "def count_Num(n):\n    count = 0\n    # Check numbers up to 2^(n+1)\n    limit = 2 ** (n + 1)\n    \n    for num in range(limit):\n        # Check if both 0th bit and nth bit are set\n        if (num & 1) and (num & (1 << n)):\n            count += 1\n    \n    return count", "is_syntactically_valid": true}
{"task_id": 212, "generation": "def fourth_Power_Sum(n):\n    return sum(i**4 for i in range(1, n + 1))", "is_syntactically_valid": true}
{"task_id": 213, "generation": "def concatenate_strings(tuple1, tuple2):\n    return tuple(s1 + s2 for s1, s2 in zip(tuple1, tuple2))", "is_syntactically_valid": true}
{"task_id": 214, "generation": "import math\n\ndef degree_radian(degrees):\n    return degrees * (180 / math.pi)", "is_syntactically_valid": true}
{"task_id": 215, "generation": "def decode_list(encoded_list):\n    result = []\n    for item in encoded_list:\n        if isinstance(item, list) and len(item) == 2:\n            count, value = item\n            result.extend([value] * count)\n        else:\n            result.append(item)\n    return result", "is_syntactically_valid": true}
{"task_id": 216, "generation": "def check_subset_list(main_list, subset_list):\n    def flatten_list(lst):\n        flattened = []\n        for item in lst:\n            if isinstance(item, list):\n                flattened.extend(flatten_list(item))\n            else:\n                flattened.append(item)\n        return flattened\n    \n    # For nested lists, check if each sublist in subset_list exists in main_list\n    if all(isinstance(item, list) for item in subset_list):\n        for sublist in subset_list:\n            if sublist not in main_list:\n                return False\n        return True\n    \n    # For flat list vs nested list comparison\n    if not all(isinstance(item, list) for item in main_list):\n        main_flat = set(flatten_list(main_list))\n        subset_flat = set(flatten_list(subset_list))\n        return subset_flat.issubset(main_flat)\n    \n    return False", "is_syntactically_valid": true}
{"task_id": 217, "generation": "def first_Repeated_Char(s):\n    seen = set()\n    for char in s:\n        if char in seen:\n            return char\n        seen.add(char)\n    return '\\0'", "is_syntactically_valid": true}
{"task_id": 218, "generation": "from collections import deque\n\ndef min_Operations(a, b):\n    if a == b:\n        return 0\n    \n    visited = set()\n    queue = deque([(a, 0)])\n    visited.add(a)\n    \n    while queue:\n        current, operations = queue.popleft()\n        \n        # Generate next possible numbers\n        next_numbers = []\n        \n        # Multiply by 2\n        next_numbers.append(current * 2)\n        \n        # Divide by 2 (if even)\n        if current % 2 == 0:\n            next_numbers.append(current // 2)\n        \n        for next_num in next_numbers:\n            if next_num == b:\n                return operations + 1\n            \n            if next_num not in visited and next_num > 0 and next_num <= 1000:  # reasonable bounds\n                visited.add(next_num)\n                queue.append((next_num, operations + 1))\n    \n    return -1  # Should not reach here for valid inputs", "is_syntactically_valid": true}
{"task_id": 219, "generation": "def extract_min_max(tup, k):\n    sorted_tup = sorted(tup)\n    min_k = sorted_tup[:k]\n    max_k = sorted_tup[-k:]\n    return tuple(min_k + max_k)", "is_syntactically_valid": true}
{"task_id": 220, "generation": "def replace_max_specialchar(text, n):\n    result = \"\"\n    count = 0\n    \n    for char in text:\n        if count < n and char in [' ', ',', '.']:\n            result += ':'\n            count += 1\n        else:\n            result += char\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 221, "generation": "def first_even(numbers):\n    for num in numbers:\n        if num % 2 == 0:\n            return num\n    return None", "is_syntactically_valid": true}
{"task_id": 222, "generation": "def check_type(tuple_input):\n    if len(tuple_input) == 0:\n        return True\n    \n    first_type = type(tuple_input[0])\n    \n    for element in tuple_input:\n        if type(element) != first_type:\n            return False\n    \n    return True", "is_syntactically_valid": true}
{"task_id": 223, "generation": "def is_majority(arr, n, x):\n    # A majority element appears more than n/2 times\n    count = arr.count(x)\n    return count > n // 2", "is_syntactically_valid": true}
{"task_id": 224, "generation": "def count_Set_Bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count", "is_syntactically_valid": true}
{"task_id": 225, "generation": "def find_Min(arr, low, high):\n    # If array is not rotated, first element is minimum\n    if high < low:\n        return arr[0]\n    \n    # If there is only one element\n    if high == low:\n        return arr[low]\n    \n    # Find middle point\n    mid = low + (high - low) // 2\n    \n    # Check if element at mid+1 is minimum element\n    if mid < high and arr[mid + 1] < arr[mid]:\n        return arr[mid + 1]\n    \n    # Check if mid itself is minimum element\n    if mid > low and arr[mid] < arr[mid - 1]:\n        return arr[mid]\n    \n    # Decide whether we need to go to left half or right half\n    if arr[high] > arr[mid]:\n        return find_Min(arr, low, mid - 1)\n    return find_Min(arr, mid + 1, high)", "is_syntactically_valid": true}
{"task_id": 226, "generation": "def odd_values_string(s):\n    result = \"\"\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n    return result", "is_syntactically_valid": true}
{"task_id": 227, "generation": "def min_of_three(a, b, c):\n    return min(a, b, c)", "is_syntactically_valid": true}
{"task_id": 228, "generation": "def all_Bits_Set_In_The_Given_Range(n, l, r):\n    # Create a mask with bits set from position l to r\n    mask = ((1 << (r - l + 1)) - 1) << (l - 1)\n    \n    # Check if all bits in the range are set in n\n    return (n & mask) == mask", "is_syntactically_valid": true}
{"task_id": 229, "generation": "def re_arrange_array(arr, n):\n    # Create two lists to store negative and positive elements\n    negatives = []\n    positives = []\n    \n    # Separate negative and positive elements\n    for num in arr:\n        if num < 0:\n            negatives.append(num)\n        else:\n            positives.append(num)\n    \n    # Combine negatives first, then positives\n    return negatives + positives", "is_syntactically_valid": true}
{"task_id": 230, "generation": "def replace_blank(string, character):\n    return string.replace(' ', character)", "is_syntactically_valid": true}
{"task_id": 231, "generation": "def max_sum(triangle, n):\n    # Create a copy of the triangle to avoid modifying the original\n    dp = [row[:] for row in triangle]\n    \n    # Start from the second-to-last row and work upwards\n    for i in range(n - 2, -1, -1):\n        for j in range(len(dp[i])):\n            # For each position, add the maximum of the two possible paths below\n            dp[i][j] += max(dp[i + 1][j], dp[i + 1][j + 1])\n    \n    # The top element now contains the maximum sum\n    return dp[0][0]", "is_syntactically_valid": true}
{"task_id": 232, "generation": "def larg_nnum(dataset, n):\n    sorted_dataset = sorted(dataset, reverse=True)\n    return sorted_dataset[:n]", "is_syntactically_valid": true}
{"task_id": 233, "generation": "import math\n\ndef lateralsuface_cylinder(radius, height):\n    return 2 * math.pi * radius * height", "is_syntactically_valid": true}
{"task_id": 234, "generation": "def volume_cube(side_length):\n    return side_length ** 3", "is_syntactically_valid": true}
{"task_id": 235, "generation": "def even_bit_set_number(n):\n    # Create a mask with all even bits set (0, 2, 4, 6, ...)\n    # In binary: ...10101010\n    mask = 0xAAAAAAAA  # This covers 32 bits, adjust if needed for larger numbers\n    \n    # For the given number, we need to ensure the mask doesn't exceed the bit length\n    # Find the highest bit position in n\n    if n == 0:\n        return 0\n    \n    # Create appropriate mask based on the number's bit length\n    bit_length = n.bit_length()\n    # Create mask with even positions set up to the required bit length\n    even_mask = 0\n    for i in range(0, bit_length + 1, 2):  # Even positions: 0, 2, 4, 6, ...\n        even_mask |= (1 << i)\n    \n    # Set all even bits by OR-ing with the mask\n    return n | even_mask", "is_syntactically_valid": true}
{"task_id": 236, "generation": "Looking at this problem, I need to find the maximum number of equilateral triangles of a given size that can be formed within a larger equilateral triangle.\n\nFrom the test cases:\n- `No_of_Triangle(4,2) == 7`: In a triangle of side 4, we can fit 7 triangles of side 2\n- `No_of_Triangle(4,3) == 3`: In a triangle of side 4, we can fit 3 triangles of side 3\n- `No_of_Triangle(1,3) == -1`: In a triangle of side 1, we cannot fit any triangles of side 3 (impossible case)\n\nThe pattern suggests this is about fitting smaller equilateral triangles into a larger one. The formula for the maximum number of equilateral triangles of side `small` that can fit in an equilateral triangle of side `large` is:\n\nIf `small > large`, return -1 (impossible)\nOtherwise, the number is `(large // small)\u00b2`\n\nLet me verify:\n- For (4,2): (4//2)\u00b2 = 2\u00b2 = 4... but expected is 7\n- Let me reconsider...\n\nActually, looking more carefully at the pattern, this seems to be about triangular numbers. When we divide an equilateral triangle into smaller equilateral triangles, the formula is different.\n\nFor an equilateral triangle of side `n` divided into unit triangles of side `k`, the number of triangles of side `k` that fit is `(n//k)\u00b2` but we need to account for the triangular arrangement.\n\nLet me think about this differently. If we have a large triangle of side `large` and want to fit triangles of side `small`, the number that fit is `((large - small) // small + 1)\u00b2` when `small <= large`, otherwise -1.\n\nWait, let me check the pattern again:\n- (4,2): We're looking at how many triangles of side 2 fit in a triangle of side 4\n- (4,3): We're looking at how many triangles of side 3 fit in a triangle of side 4\n\nActually, the correct formula appears to be: `(large - small + 1)", "is_syntactically_valid": false}
{"task_id": 237, "generation": "def check_occurences(tuples_list):\n    count_dict = {}\n    \n    for tuple_item in tuples_list:\n        # Sort the tuple to create a canonical form\n        sorted_tuple = tuple(sorted(tuple_item))\n        \n        # Count occurrences\n        if sorted_tuple in count_dict:\n            count_dict[sorted_tuple] += 1\n        else:\n            count_dict[sorted_tuple] = 1\n    \n    return count_dict", "is_syntactically_valid": true}
{"task_id": 238, "generation": "def number_of_substrings(s):\n    n = len(s)\n    return n * (n + 1) // 2", "is_syntactically_valid": true}
{"task_id": 239, "generation": "def get_total_number_of_sequences(m, n):\n    def count_sequences(length, last_element):\n        if length == 1:\n            return 1\n        \n        count = 0\n        # Next element must be >= 2 * last_element and <= m\n        min_next = 2 * last_element\n        for next_element in range(min_next, m + 1):\n            count += count_sequences(length - 1, next_element)\n        \n        return count\n    \n    total = 0\n    # Try all possible starting elements from 1 to m\n    for start in range(1, m + 1):\n        total += count_sequences(n, start)\n    \n    return total", "is_syntactically_valid": true}
{"task_id": 240, "generation": "def replace_list(list1, list2):\n    return list1[:-1] + list2", "is_syntactically_valid": true}
{"task_id": 241, "generation": "def array_3d(x, y, z):\n    return [[['*' for _ in range(x)] for _ in range(y)] for _ in range(z)]", "is_syntactically_valid": true}
{"task_id": 242, "generation": "def count_charac(string):\n    return len(string)", "is_syntactically_valid": true}
{"task_id": 243, "generation": "def sort_on_occurence(lst):\n    from collections import Counter\n    \n    # Count occurrences of first elements\n    first_elements = [item[0] for item in lst]\n    counts = Counter(first_elements)\n    \n    # Group items by first element\n    groups = {}\n    for item in lst:\n        first_elem = item[0]\n        if first_elem not in groups:\n            groups[first_elem] = []\n        groups[first_elem].append(item[1])\n    \n    # Create result list\n    result = []\n    for first_elem, second_elems in groups.items():\n        count = counts[first_elem]\n        # Create tuple: (first_element, *second_elements, count)\n        new_tuple = (first_elem,) + tuple(second_elems) + (count,)\n        result.append(new_tuple)\n    \n    # Sort by count in descending order\n    result.sort(key=lambda x: x[-1], reverse=True)\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 244, "generation": "import math\n\ndef next_Perfect_Square(n):\n    sqrt_n = int(math.sqrt(n))\n    if sqrt_n * sqrt_n == n:\n        return (sqrt_n + 1) ** 2\n    else:\n        return (sqrt_n + 1) ** 2", "is_syntactically_valid": true}
{"task_id": 245, "generation": "def max_sum(arr, n):\n    # Create arrays to store maximum sum ending at each position\n    # for increasing and decreasing subsequences\n    inc = [0] * n\n    dec = [0] * n\n    \n    # Initialize with array elements\n    for i in range(n):\n        inc[i] = arr[i]\n        dec[i] = arr[i]\n    \n    # Fill inc[] array for increasing subsequence\n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    \n    # Fill dec[] array for decreasing subsequence (from right to left)\n    for i in range(n-2, -1, -1):\n        for j in range(i+1, n):\n            if arr[j] < arr[i]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    \n    # Find maximum sum by combining increasing and decreasing subsequences\n    max_sum_val = 0\n    for i in range(n):\n        max_sum_val = max(max_sum_val, inc[i] + dec[i] - arr[i])\n    \n    return max_sum_val", "is_syntactically_valid": true}
{"task_id": 246, "generation": "def babylonian_squareroot(n):\n    if n == 0:\n        return 0\n    \n    x = n\n    while True:\n        root = 0.5 * (x + n / x)\n        if abs(root - x) < 1e-15:\n            break\n        x = root\n    \n    return root", "is_syntactically_valid": true}
{"task_id": 247, "generation": "def lps(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    \n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Check for palindromes of length 2 and more\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            \n            if s[i] == s[j]:\n                if length == 2:\n                    dp[i][j] = 2\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    \n    return dp[0][n - 1]", "is_syntactically_valid": true}
{"task_id": 248, "generation": "def harmonic_sum(n):\n    result = 0\n    for i in range(1, n):\n        result += 1 / i\n    return result", "is_syntactically_valid": true}
{"task_id": 249, "generation": "def intersection_array(arr1, arr2):\n    return list(filter(lambda x: x in arr2, arr1))", "is_syntactically_valid": true}
{"task_id": 250, "generation": "def count_X(tuple_data, element):\n    return tuple_data.count(element)", "is_syntactically_valid": true}
{"task_id": 251, "generation": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "is_syntactically_valid": true}
{"task_id": 252, "generation": "import cmath\n\ndef convert(z):\n    # Convert to complex number if it's not already\n    if not isinstance(z, complex):\n        z = complex(z)\n    \n    # Calculate magnitude (radius)\n    magnitude = abs(z)\n    \n    # Calculate phase (angle) in radians\n    phase = cmath.phase(z)\n    \n    return (magnitude, phase)", "is_syntactically_valid": true}
{"task_id": 253, "generation": "def count_integer(lst):\n    count = 0\n    for item in lst:\n        if isinstance(item, int) and not isinstance(item, bool):\n            count += 1\n    return count", "is_syntactically_valid": true}
{"task_id": 254, "generation": "def words_ae(text):\n    words = text.split()\n    result = []\n    \n    for word in words:\n        if word.startswith('a') or word.startswith('e'):\n            result.append(word)\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 255, "generation": "from itertools import combinations_with_replacement\n\ndef combinations_colors(colors, n):\n    return list(combinations_with_replacement(colors, n))", "is_syntactically_valid": true}
{"task_id": 256, "generation": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Create a boolean array \"prime[0..n-1]\" and initialize\n    # all entries as true. A value in prime[i] will\n    # finally be false if i is Not a prime, else true.\n    prime = [True] * n\n    prime[0] = prime[1] = False  # 0 and 1 are not prime numbers\n    \n    p = 2\n    while p * p < n:\n        # If prime[p] is not changed, then it is a prime\n        if prime[p]:\n            # Update all multiples of p\n            for i in range(p * p, n, p):\n                prime[i] = False\n        p += 1\n    \n    # Count prime numbers\n    count = sum(prime)\n    return count", "is_syntactically_valid": true}
{"task_id": 257, "generation": "def swap_numbers(a, b):\n    return (b, a)", "is_syntactically_valid": true}
{"task_id": 258, "generation": "def count_odd(lst):\n    return len(list(filter(lambda x: x % 2 != 0, lst)))", "is_syntactically_valid": true}
{"task_id": 259, "generation": "def maximize_elements(tuple1, tuple2):\n    result = []\n    for i in range(len(tuple1)):\n        max_first = max(tuple1[i][0], tuple2[i][0])\n        max_second = max(tuple1[i][1], tuple2[i][1])\n        result.append((max_first, max_second))\n    return tuple(result)", "is_syntactically_valid": true}
{"task_id": 260, "generation": "def newman_prime(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num**0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n    \n    def newman_shanks_williams(k):\n        if k == 0:\n            return 1\n        if k == 1:\n            return 1\n        \n        # Use iterative approach to avoid recursion depth issues\n        a, b = 1, 1\n        for i in range(2, k + 1):\n            a, b = b, 2 * b + a\n        return b\n    \n    count = 0\n    k = 1\n    \n    while count < n:\n        nsw_num = newman_shanks_williams(k)\n        if is_prime(nsw_num):\n            count += 1\n            if count == n:\n                return nsw_num\n        k += 1\n    \n    return -1", "is_syntactically_valid": true}
{"task_id": 261, "generation": "def division_elements(tuple1, tuple2):\n    return tuple(a // b for a, b in zip(tuple1, tuple2))", "is_syntactically_valid": true}
{"task_id": 262, "generation": "def split_two_parts(lst, n):\n    return (lst[:n], lst[n:])", "is_syntactically_valid": true}
{"task_id": 263, "generation": "def merge_dict(dict1, dict2):\n    result = {}\n    result.update(dict2)\n    result.update(dict1)\n    return result", "is_syntactically_valid": true}
{"task_id": 264, "generation": "def dog_age(human_age):\n    if human_age <= 2:\n        return human_age * 10.5\n    else:\n        return 21 + (human_age - 2) * 4", "is_syntactically_valid": true}
{"task_id": 265, "generation": "def list_split(lst, n):\n    result = []\n    for i in range(n):\n        sublist = []\n        for j in range(i, len(lst), n):\n            sublist.append(lst[j])\n        result.append(sublist)\n    return result", "is_syntactically_valid": true}
{"task_id": 266, "generation": "def lateralsurface_cube(side):\n    return 4 * side * side", "is_syntactically_valid": true}
{"task_id": 267, "generation": "def square_Sum(n):\n    total = 0\n    for i in range(n):\n        odd_number = 2 * i + 1\n        total += odd_number ** 2\n    return total", "is_syntactically_valid": true}
{"task_id": 268, "generation": "def find_star_num(n):\n    return n * (6 * n - 6) + 1", "is_syntactically_valid": true}
{"task_id": 269, "generation": "def ascii_value(char):\n    return ord(char)", "is_syntactically_valid": true}
{"task_id": 270, "generation": "def sum_even_and_even_index(lst, n):\n    total = 0\n    for i in range(0, n, 2):  # iterate through even indices (0, 2, 4, ...)\n        if lst[i] % 2 == 0:   # check if the number at even index is even\n            total += lst[i]\n    return total", "is_syntactically_valid": true}
{"task_id": 271, "generation": "def even_Power_Sum(n):\n    return sum((2 * i) ** 5 for i in range(1, n + 1))", "is_syntactically_valid": true}
{"task_id": 272, "generation": "def rear_extract(tuples_list):\n    return [tuple_item[-1] for tuple_item in tuples_list]", "is_syntactically_valid": true}
{"task_id": 273, "generation": "def substract_elements(tuple1, tuple2):\n    return tuple(a - b for a, b in zip(tuple1, tuple2))", "is_syntactically_valid": true}
{"task_id": 274, "generation": "def even_binomial_Coeff_Sum(n):\n    # Sum of even index binomial coefficients C(n,0) + C(n,2) + C(n,4) + ...\n    # This equals 2^(n-1) for n > 0\n    if n == 0:\n        return 1\n    return 2 ** (n - 1)", "is_syntactically_valid": true}
{"task_id": 275, "generation": "def get_Position(arr, n, k):\n    def josephus(n, k):\n        if n == 1:\n            return 1\n        else:\n            return (josephus(n - 1, k) + k - 1) % n + 1\n    \n    return josephus(n, k)", "is_syntactically_valid": true}
{"task_id": 276, "generation": "import math\n\ndef volume_cylinder(radius, height):\n    return math.pi * radius ** 2 * height", "is_syntactically_valid": true}
{"task_id": 277, "generation": "def dict_filter(dictionary, threshold):\n    return {key: value for key, value in dictionary.items() if value >= threshold}", "is_syntactically_valid": true}
{"task_id": 278, "generation": "def count_first_elements(tuple_input):\n    count = 0\n    for element in tuple_input:\n        if isinstance(element, tuple):\n            break\n        count += 1\n    return count", "is_syntactically_valid": true}
{"task_id": 279, "generation": "def is_num_decagonal(n):\n    return n * (4 * n - 3)", "is_syntactically_valid": true}
{"task_id": 280, "generation": "def sequential_search(arr, target):\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return (True, i)\n    return (False, -1)", "is_syntactically_valid": true}
{"task_id": 281, "generation": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "is_syntactically_valid": true}
{"task_id": 282, "generation": "def sub_list(list1, list2):\n    return list(map(lambda x, y: x - y, list1, list2))", "is_syntactically_valid": true}
{"task_id": 283, "generation": "def validate(num):\n    # Convert number to string to easily iterate through digits\n    num_str = str(num)\n    \n    # Count frequency of each digit\n    digit_count = {}\n    for digit in num_str:\n        digit_count[digit] = digit_count.get(digit, 0) + 1\n    \n    # Check if frequency of each digit is <= the digit itself\n    for digit, count in digit_count.items():\n        if count > int(digit):\n            return False\n    \n    return True", "is_syntactically_valid": true}
{"task_id": 284, "generation": "def check_element(lst, target):\n    for item in lst:\n        if item != target:\n            return False\n    return True", "is_syntactically_valid": true}
{"task_id": 285, "generation": "import re\n\ndef text_match_two_three(text):\n    pattern = r'ab{2,3}'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'", "is_syntactically_valid": true}
{"task_id": 286, "generation": "def max_sub_array_sum_repeated(arr, n, k):\n    if not arr or k == 0:\n        return 0\n    \n    # Create the repeated array\n    repeated_arr = arr * k\n    \n    # Kadane's algorithm to find maximum subarray sum\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in repeated_arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "is_syntactically_valid": true}
{"task_id": 287, "generation": "def square_Sum(n):\n    total = 0\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        total += even_number ** 2\n    return total", "is_syntactically_valid": true}
{"task_id": 288, "generation": "def modular_inverse(arr, n, p):\n    count = 0\n    \n    for i in range(n):\n        num = arr[i]\n        # Find modular inverse of num under prime p\n        # num * inverse \u2261 1 (mod p)\n        # Using Fermat's little theorem: num^(p-1) \u2261 1 (mod p)\n        # So inverse = num^(p-2) mod p\n        \n        if num % p == 0:\n            continue  # No modular inverse exists for multiples of p\n            \n        inverse = pow(num, p-2, p)\n        \n        # Check if the modular inverse equals the number itself\n        if inverse == num % p:\n            count += 1\n    \n    return count", "is_syntactically_valid": true}
{"task_id": 289, "generation": "def odd_Days(years):\n    if years == 0:\n        return 0\n    \n    # Count leap years in the given number of years\n    leap_years = 0\n    for year in range(1, years + 1):\n        if year % 4 == 0:\n            if year % 100 == 0:\n                if year % 400 == 0:\n                    leap_years += 1\n            else:\n                leap_years += 1\n    \n    # Regular years contribute 1 odd day each\n    # Leap years contribute 2 odd days each\n    regular_years = years - leap_years\n    total_odd_days = regular_years * 1 + leap_years * 2\n    \n    # Return odd days modulo 7\n    return total_odd_days % 7", "is_syntactically_valid": true}
{"task_id": 290, "generation": "def max_length(lists):\n    max_len = 0\n    max_list = []\n    \n    for lst in lists:\n        if len(lst) > max_len:\n            max_len = len(lst)\n            max_list = lst\n    \n    return (max_len, max_list)", "is_syntactically_valid": true}
{"task_id": 291, "generation": "def count_no_of_ways(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n    \n    # dp[i][0] represents ways to paint i posts where last two posts have different colors\n    # dp[i][1] represents ways to paint i posts where last two posts have same color\n    \n    # For first post: k ways\n    # For second post: k ways (can be same or different from first)\n    # dp[2][0] = k * (k-1) (second post different from first)\n    # dp[2][1] = k * 1 = k (second post same as first)\n    \n    dp = [[0, 0] for _ in range(n + 1)]\n    \n    dp[1][0] = k  # First post can be painted in k ways\n    dp[1][1] = 0  # Can't have same color for just one post\n    \n    dp[2][0] = k * (k - 1)  # Second post different from first\n    dp[2][1] = k  # Second post same as first\n    \n    for i in range(3, n + 1):\n        # If last two posts have different colors, previous post can be any color\n        dp[i][0] = (dp[i-1][0] + dp[i-1][1]) * (k - 1)\n        \n        # If last two posts have same color, previous two posts must have different colors\n        dp[i][1] = dp[i-1][0]\n    \n    return dp[n][0] + dp[n][1]", "is_syntactically_valid": true}
{"task_id": 292, "generation": "def find(dividend, divisor):\n    return dividend // divisor", "is_syntactically_valid": true}
{"task_id": 293, "generation": "import math\n\ndef otherside_rightangle(a, b):\n    return math.sqrt(a**2 + b**2)", "is_syntactically_valid": true}
{"task_id": 294, "generation": "def max_val(lst):\n    numeric_values = [item for item in lst if isinstance(item, (int, float))]\n    return max(numeric_values)", "is_syntactically_valid": true}
{"task_id": 295, "generation": "def sum_div(n):\n    total = 0\n    for i in range(1, n):\n        if n % i == 0:\n            total += i\n    return total", "is_syntactically_valid": true}
{"task_id": 296, "generation": "def get_Inv_Count(arr, n):\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "is_syntactically_valid": true}
{"task_id": 297, "generation": "def flatten_list(nested_list):\n    result = []\n    for item in nested_list:\n        if isinstance(item, list):\n            result.extend(item)\n        else:\n            result.append(item)\n    return result", "is_syntactically_valid": true}
{"task_id": 298, "generation": "def intersection_nested_lists(list1, list2):\n    result = []\n    for sublist in list2:\n        intersection = []\n        for element in sublist:\n            if element in list1:\n                intersection.append(element)\n        result.append(intersection)\n    return result", "is_syntactically_valid": true}
{"task_id": 299, "generation": "def max_aggregate(tuples_list):\n    aggregates = {}\n    \n    for name, value in tuples_list:\n        if name in aggregates:\n            aggregates[name] += value\n        else:\n            aggregates[name] = value\n    \n    max_name = max(aggregates, key=aggregates.get)\n    return (max_name, aggregates[max_name])", "is_syntactically_valid": true}
{"task_id": 300, "generation": "def count_binary_seq(n):\n    from math import comb\n    return float(comb(2*n, n))", "is_syntactically_valid": true}
{"task_id": 301, "generation": "def dict_depth(d):\n    if not isinstance(d, dict) or not d:\n        return 0\n    \n    max_depth = 0\n    for value in d.values():\n        if isinstance(value, dict):\n            depth = dict_depth(value)\n            max_depth = max(max_depth, depth)\n    \n    return max_depth + 1", "is_syntactically_valid": true}
{"task_id": 302, "generation": "def set_Bit_Number(n):\n    if n == 0:\n        return 0\n    \n    # Find the position of the most significant bit\n    msb_position = 0\n    temp = n\n    while temp > 0:\n        temp >>= 1\n        msb_position += 1\n    \n    # Return 2^(msb_position - 1) which is the value of the MSB\n    return 1 << (msb_position - 1)", "is_syntactically_valid": true}
{"task_id": 303, "generation": "def solve(arr, n):\n    # Count inversions of two types:\n    # Type 1: inversions where both elements are < n//2\n    # Type 2: inversions where both elements are >= n//2\n    \n    type", "is_syntactically_valid": true}
{"task_id": 304, "generation": "def find_Element(arr, rotations, index, num_rotations):\n    # Make a copy of the array to avoid modifying the original\n    result = arr[:]\n    \n    # Apply the specified number of rotations\n    for _ in range(num_rotations):\n        # Apply each rotation in the rotations list\n        for rotation in rotations:\n            start, end = rotation\n            # Perform left rotation on the subarray from start to end (inclusive)\n            if start < len(result) and end < len(result) and start <= end:\n                # Extract the subarray\n                subarray = result[start:end+1]\n                # Perform left rotation (move first element to the end)\n                if len(subarray) > 1:\n                    rotated_subarray = subarray[1:] + [subarray[0]]\n                    # Replace the subarray in the result\n                    result[start:end+1] = rotated_subarray\n    \n    return result[index]", "is_syntactically_valid": true}
{"task_id": 305, "generation": "def start_withp(word_list):\n    p_words = []\n    \n    for phrase in word_list:\n        words = phrase.split()\n        for word in words:\n            if word.lower().startswith('p'):\n                p_words.append(word)\n    \n    if len(p_words) >= 2:\n        return (p_words[0], p_words[1])\n    \n    return None", "is_syntactically_valid": true}
{"task_id": 306, "generation": "def max_sum_increasing_subseq(arr, n, i, k):\n    # dp[j] will store the maximum sum of increasing subsequence ending at index j\n    dp = [0] * (i + 1)\n    \n    # Initialize dp array\n    for j in range(i + 1):\n        dp[j] = arr[j]\n    \n    # Fill dp array for increasing subsequences up to index i\n    for j in range(1, i + 1):\n        for prev in range(j):\n            if arr[prev] < arr[j]:\n                dp[j] = max(dp[j], dp[prev] + arr[j])\n    \n    # Find maximum sum that can be extended with arr[k]\n    max_sum = 0\n    \n    # Check all positions up to i\n    for j in range(i + 1):\n        if arr[j] < arr[k]:\n            max_sum = max(max_sum, dp[j] + arr[k])\n    \n    return max_sum", "is_syntactically_valid": true}
{"task_id": 307, "generation": "def colon_tuplex(tuple_input, index, value):\n    # Convert tuple to list for modification\n    temp_list = list(tuple_input)\n    \n    # Append the value to the element at the given index\n    temp_list[index].append(value)\n    \n    # Convert back to tuple and return\n    return tuple(temp_list)", "is_syntactically_valid": true}
{"task_id": 308, "generation": "def large_product(list1, list2, n):\n    products = []\n    for i in list1:\n        for j in list2:\n            products.append(i * j)\n    \n    products.sort(reverse=True)\n    return products[:n]", "is_syntactically_valid": true}
{"task_id": 309, "generation": "def maximum(a, b):\n    return a if a > b else b", "is_syntactically_valid": true}
{"task_id": 310, "generation": "def string_to_tuple(s):\n    return tuple(char for char in s if char != ' ')", "is_syntactically_valid": true}
{"task_id": 311, "generation": "def set_left_most_unset_bit(n):\n    if n == 0:\n        return 1\n    \n    # Find the position of the leftmost unset bit\n    temp = n\n    position = 0\n    \n    # Find the highest set bit position\n    while temp > 0:\n        temp >>= 1\n        position += 1\n    \n    # Check each bit from left to right (highest to lowest)\n    for i in range(position - 1, -1, -1):\n        if (n & (1 << i)) == 0:  # If bit at position i is unset\n            return n | (1 << i)  # Set that bit and return\n    \n    # If all bits are set, set the next higher bit\n    return n | (1 << position)", "is_syntactically_valid": true}
{"task_id": 312, "generation": "import math\n\ndef volume_cone(radius, height):\n    return (1/3) * math.pi * radius**2 * height", "is_syntactically_valid": true}
{"task_id": 313, "generation": "def pos_nos(lst):\n    positive_nums = []\n    for num in lst:\n        if num > 0:\n            positive_nums.append(num)\n    \n    if len(positive_nums) == 1:\n        return positive_nums[0]\n    else:\n        return tuple(positive_nums)", "is_syntactically_valid": true}
{"task_id": 314, "generation": "def max_sum_rectangular_grid(grid, n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return max(grid[0][0], grid[1][0])\n    \n    # dp[i][j] represents max sum up to column i with state j\n    # j = 0: neither cell in column i is selected\n    # j = 1: only top cell in column i is selected\n    # j = 2: only bottom cell in column i is selected\n    # j = 3: both cells in column i are selected (not allowed due to adjacency)\n    \n    dp = [[0] * 4 for _ in range(n)]\n    \n    # Base case for first column\n    dp[0][0] = 0  # neither selected\n    dp[0][1] = grid[0][0]  # top selected\n    dp[0][2] = grid[1][0]  # bottom selected\n    dp[0][3] = float('-inf')  # both selected (invalid)\n    \n    for i in range(1, n):\n        # Neither cell selected in current column\n        dp[i][0] = max(dp[i-1][0], dp[i-1][1], dp[i-1][2])\n        \n        # Only top cell selected in current column\n        dp[i][1] = max(dp[i-1][0], dp[i-1][2]) + grid[0][i]\n        \n        # Only bottom cell selected in current column\n        dp[i][2] = max(dp[i-1][0], dp[i-1][1]) + grid[1][i]\n        \n        # Both cells selected (invalid due to vertical adjacency)\n        dp[i][3] = float('-inf')\n    \n    return max(dp[n-1][0], dp[n-1][1], dp[n-1][2])", "is_syntactically_valid": true}
{"task_id": 315, "generation": "def find_Max_Len_Even(s):\n    words = s.split()\n    max_len = 0\n    result = \"-1\"\n    \n    for word in words:\n        if len(word) % 2 == 0:  # Check if word length is even\n            if len(word) > max_len:\n                max_len = len(word)\n                result = word\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 316, "generation": "def find_last_occurrence(arr, target):\n    last_index = -1\n    for i in range(len(arr)):\n        if arr[i] == target:\n            last_index = i\n    return last_index", "is_syntactically_valid": true}
{"task_id": 317, "generation": "def modified_encode(data):\n    if not data:\n        return []\n    \n    result = []\n    current_item = data[0]\n    count = 1\n    \n    for i in range(1, len(data)):\n        if data[i] == current_item:\n            count += 1\n        else:\n            if count == 1:\n                result.append(current_item)\n            else:\n                result.append([count, current_item])\n            current_item = data[i]\n            count = 1\n    \n    # Handle the last group\n    if count == 1:\n        result.append(current_item)\n    else:\n        result.append([count, current_item])\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 318, "generation": "def max_volume(sum_sides):\n    if sum_sides < 3:\n        return 0\n    \n    max_vol = 0\n    \n    # Try all possible combinations of three positive integers that sum to sum_sides\n    for l in range(1, sum_sides - 1):\n        for w in range(1, sum_sides - l):\n            h = sum_sides - l - w\n            if h > 0:\n                volume = l * w * h\n                max_vol = max(max_vol, volume)\n    \n    return max_vol", "is_syntactically_valid": true}
{"task_id": 319, "generation": "import re\n\ndef find_long_word(text):\n    pattern = r'\\b[a-zA-Z]{5}\\b'\n    matches = re.findall(pattern, text)\n    return matches", "is_syntactically_valid": true}
{"task_id": 320, "generation": "def sum_difference(n):\n    # Sum of first n natural numbers: n(n+1)/2\n    sum_of_numbers = n * (n + 1) // 2\n    \n    # Square of the sum\n    squared_sum = sum_of_numbers ** 2\n    \n    # Sum of squares of first n natural numbers: n(n+1)(2n+1)/6\n    sum_of_squares = n * (n + 1) * (2 * n + 1) // 6\n    \n    # Return the difference\n    return squared_sum - sum_of_squares", "is_syntactically_valid": true}
{"task_id": 321, "generation": "def find_demlo(s):\n    n = len(s)\n    result = \"\"\n    \n    # Count up from 1 to n\n    for i in range(1, n + 1):\n        result += str(i)\n    \n    # Count down from n-1 to 1\n    for i in range(n - 1, 0, -1):\n        result += str(i)\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 322, "generation": "def position_min(lst):\n    if not lst:\n        return []\n    \n    min_value = min(lst)\n    positions = []\n    \n    for i, value in enumerate(lst):\n        if value == min_value:\n            positions.append(i)\n    \n    return positions", "is_syntactically_valid": true}
{"task_id": 323, "generation": "def re_arrange(arr, n):\n    positives = []\n    negatives = []\n    \n    # Separate positive and negative numbers\n    for num in arr:\n        if num < 0:\n            negatives.append(num)\n        else:\n            positives.append(num)\n    \n    result = []\n    pos_idx = 0\n    neg_idx = 0\n    \n    # Alternate between negative and positive\n    for i in range(n):\n        if i % 2 == 0:  # Even indices get negative numbers\n            if neg_idx < len(negatives):\n                result.append(negatives[neg_idx])\n                neg_idx += 1\n            elif pos_idx < len(positives):\n                result.append(positives[pos_idx])\n                pos_idx += 1\n        else:  # Odd indices get positive numbers\n            if pos_idx < len(positives):\n                result.append(positives[pos_idx])\n                pos_idx += 1\n            elif neg_idx < len(negatives):\n                result.append(negatives[neg_idx])\n                neg_idx += 1\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 324, "generation": "def sum_of_alternates(tup):\n    sum1 = sum(tup[i] for i in range(0, len(tup), 2))\n    sum2 = sum(tup[i] for i in range(1, len(tup), 2))\n    return (sum1, sum2)", "is_syntactically_valid": true}
{"task_id": 325, "generation": "def get_Min_Squares(n):\n    # dp[i] will store the minimum number of squares needed for i\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    # For each number from 1 to n\n    for i in range(1, n + 1):\n        # Try all perfect squares less than or equal to i\n        j = 1\n        while j * j <= i:\n            dp[i] = min(dp[i], dp[i - j * j] + 1)\n            j += 1\n    \n    return dp[n]", "is_syntactically_valid": true}
{"task_id": 326, "generation": "import re\nfrom collections import Counter\n\ndef most_occurrences(strings_list):\n    word_count = Counter()\n    \n    for string in strings_list:\n        words = re.findall(r'\\w+', string)\n        for word in words:\n            word_count[word] += 1\n    \n    return word_count.most_common(1)[0][0]", "is_syntactically_valid": true}
{"task_id": 327, "generation": "def check_isosceles(a, b, c):\n    # Check if it's a valid triangle first\n    if a + b <= c or a + c <= b or b + c <= a:\n        return False\n    \n    # Check if any two sides are equal (isosceles condition)\n    return a == b or b == c or a == c", "is_syntactically_valid": true}
{"task_id": 328, "generation": "def rotate_left(lst, rotate_pos, additional):\n    n = len(lst)\n    rotate_pos = rotate_pos % n\n    rotated = lst[rotate_pos:] + lst[:rotate_pos]\n    result = rotated + rotated[:additional]", "is_syntactically_valid": true}
{"task_id": 329, "generation": "def neg_count(lst):\n    count = 0\n    for num in lst:\n        if num < 0:\n            count += 1\n    return count", "is_syntactically_valid": true}
{"task_id": 330, "generation": "import re\n\ndef find_char(text):\n    pattern = r'\\b[a-zA-Z]{3,5}\\b'\n    matches = re.findall(pattern, text)\n    return matches", "is_syntactically_valid": true}
{"task_id": 331, "generation": "def count_unset_bits(n):\n    if n == 0:\n        return 1\n    \n    # Find the number of bits needed to represent n\n    bit_length = n.bit_length()\n    \n    # Count set bits\n    set_bits = bin(n).count('1')\n    \n    # Unset bits = total bits - set bits\n    return bit_length - set_bits", "is_syntactically_valid": true}
{"task_id": 332, "generation": "def char_frequency(s):\n    frequency = {}\n    for c in s:\n        if c in frequency:\n            frequency[c] += 1\n        else:\n            frequency[c] = 1\n    return frequency", "is_syntactically_valid": true}
{"task_id": 333, "generation": "def Sort(lst):\n    return sorted(lst, key=lambda x: x[1])", "is_syntactically_valid": true}
{"task_id": 334, "generation": "def check_Validity(a, b, c):\n    # For a triangle to be valid, the sum of any two sides must be greater than the third side\n    # This must be true for all three combinations\n    return (a + b > c) and (a + c > b) and (b + c > a)", "is_syntactically_valid": true}
{"task_id": 335, "generation": "def ap_sum(a, d, n):\n    return n * (2 * a + (n - 1) * d) // 2", "is_syntactically_valid": true}
{"task_id": 336, "generation": "def check_monthnum(month_name):\n    return month_name == \"February\"", "is_syntactically_valid": true}
{"task_id": 337, "generation": "import re\n\ndef text_match_word(text):\n    pattern = r'\\bpython\\b[.!?]*$'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'", "is_syntactically_valid": true}
{"task_id": 338, "generation": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    n = len(s)\n    \n    # Count single characters (they have same first and last character)\n    count += n\n    \n    # Count substrings of length 2 or more with same first and last character\n    for i in range(n):\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                count += 1\n    \n    return count", "is_syntactically_valid": true}
{"task_id": 339, "generation": "def find_Divisor(start, end):\n    divisor_count = {}\n    \n    # Count occurrences of each divisor\n    for num in range(start, end + 1):\n        for divisor in range(1, num + 1):\n            if num % divisor == 0:\n                divisor_count[divisor] = divisor_count.get(divisor, 0) + 1\n    \n    # Find the divisor with maximum occurrences\n    max_count = 0\n    max_divisor = 0\n    \n    for divisor, count in divisor_count.items():\n        if count > max_count or (count == max_count and divisor > max_divisor):\n            max_count = count\n            max_divisor = divisor\n    \n    return max_divisor", "is_syntactically_valid": true}
{"task_id": 340, "generation": "def sum_three_smallest_nums(nums):\n    # Filter positive numbers and sort them\n    positive_nums = [num for num in nums if num > 0]\n    positive_nums.sort()\n    \n    # Return sum of first three elements\n    return sum(positive_nums[:3])", "is_syntactically_valid": true}
{"task_id": 341, "generation": "def set_to_tuple(s):\n    return tuple(sorted(s))", "is_syntactically_valid": true}
{"task_id": 342, "generation": "import heapq\n\ndef find_minimum_range(arrays):\n    # Create a min heap with (value, array_index, element_index)\n    heap = []\n    max_val = float('-inf')\n    \n    # Initialize heap with first element from each array\n    for i, arr in enumerate(arrays):\n        if arr:  # Check if array is not empty\n            heapq.heappush(heap, (arr[0], i, 0))\n            max_val = max(max_val, arr[0])\n    \n    min_range = float('inf')\n    result_range = (0, 0)\n    \n    while len(heap) == len(arrays):\n        min_val, arr_idx, elem_idx = heapq.heappop(heap)\n        \n        # Update minimum range if current range is smaller\n        current_range = max_val - min_val\n        if current_range < min_range:\n            min_range = current_range\n            result_range = (min_val, max_val)\n        \n        # Move to next element in the same array\n        if elem_idx + 1 < len(arrays[arr_idx]):\n            next_val = arrays[arr_idx][elem_idx + 1]\n            heapq.heappush(heap, (next_val, arr_idx, elem_idx + 1))\n            max_val = max(max_val, next_val)\n        else:\n            # No more elements in this array, we can't maintain one element from each array\n            break\n    \n    return result_range", "is_syntactically_valid": true}
{"task_id": 343, "generation": "def dig_let(s):\n    letters = 0\n    digits = 0\n    \n    for char in s:\n        if char.isalpha():\n            letters += 1\n        elif char.isdigit():\n            digits += 1\n    \n    return (letters, digits)", "is_syntactically_valid": true}
{"task_id": 344, "generation": "import math\n\ndef count_Odd_Squares(start, end):\n    # Find the smallest integer whose square is >= start\n    sqrt_start = math.ceil(math.sqrt(start))\n    \n    # Find the largest integer whose square is <= end\n    sqrt_end = math.floor(math.sqrt(end))\n    \n    # Count perfect squares in range\n    if sqrt_start <= sqrt_end:\n        return sqrt_end - sqrt_start + 1\n    else:\n        return 0", "is_syntactically_valid": true}
{"task_id": 345, "generation": "def diff_consecutivenums(nums):\n    result = []\n    for i in range(1, len(nums)):\n        result.append(nums[i] - nums[i-1])\n    return result", "is_syntactically_valid": true}
{"task_id": 346, "generation": "def zigzag(n, k):\n    # Create a table to store Entringer numbers\n    # e[i][j] represents the Entringer number e(i, j)\n    e = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\n    \n    # Base case: e(0, 0) = 1\n    e[0][0] = 1\n    \n    # Fill the table using the recurrence relation\n    for i in range(1, n + 1):\n        for j in range(min(i + 1, k + 1)):\n            if j == 0:\n                # e(n, 0) = e(n-1, n-1) for n >= 1\n                if i - 1 < len(e) and i - 1 < len(e[i - 1]):\n                    e[i][j] = e[i - 1][i - 1]\n            else:\n                # e(n, k) = e(n, k-1) + e(n-1, n-k) for k >= 1\n                if j - 1 >= 0 and i - (i - j) >= 0 and i - (i - j) < len(e) and i - j < len(e[i - (i - j)]):\n                    e[i][j] = e[i][j - 1] + e[i - 1][i - j]\n    \n    return e[n][k]", "is_syntactically_valid": true}
{"task_id": 347, "generation": "def count_Squares(m, n):\n    total_squares = 0\n    for i in range(1, min(m, n) + 1):\n        total_squares += (m - i + 1) * (n - i + 1)\n    return total_squares", "is_syntactically_valid": true}
{"task_id": 348, "generation": "def find_ways(n):\n    if n % 2 != 0:\n        return 0\n    \n    k = n // 2\n    \n    # Calculate k-th Catalan number using the formula: C(k) = (2k)! / ((k+1)! * k!)\n    # Or equivalently: C(k) = C(2k, k) / (k+1) where C(n,r) is binomial coefficient\n    \n    def factorial(x):\n        if x <= 1:\n            return 1\n        result = 1\n        for i in range(2, x + 1):\n            result *= i\n        return result\n    \n    def binomial(n, r):\n        if r > n or r < 0:\n            return 0\n        if r == 0 or r == n:\n            return 1\n        \n        # Use the more efficient formula\n        result = 1\n        for i in range(min(", "is_syntactically_valid": false}
{"task_id": 349, "generation": "def check(s):\n    for char in s:\n        if char not in '01':\n            return \"No\"\n    return \"Yes\"", "is_syntactically_valid": true}
{"task_id": 350, "generation": "def minimum_Length(s):\n    from collections import Counter\n    \n    # Count frequency of each character\n    char_count = Counter(s)\n    \n    # Find the character with maximum frequency\n    max_freq = max(char_count.values())\n    \n    # The minimum length is the original length minus the maximum frequency\n    return len(s) - max_freq", "is_syntactically_valid": true}
{"task_id": 351, "generation": "def first_Element(arr, n, k):\n    import collections\n    \n    counter = collections.Counter()\n    \n    for element in arr:\n        counter[element] += 1\n        if counter[element] == k:\n            return element\n    \n    return None", "is_syntactically_valid": true}
{"task_id": 352, "generation": "def unique_Characters(s):\n    return len(s) == len(set(s))", "is_syntactically_valid": true}
{"task_id": 353, "generation": "def remove_column(nested_list, column_index):\n    result = []\n    for row in nested_list:\n        if column_index < len(row):\n            new_row = row[:column_index] + row[column_index + 1:]\n        else:\n            new_row = row[:]\n        result.append(new_row)\n    return result", "is_syntactically_valid": true}
{"task_id": 354, "generation": "Looking at the test cases, I need to understand the pattern:\n\n- `tn_ap(1,5,2)==9`: This suggests finding the 2nd term of an AP with first term 1 and common difference 5\n- `tn_ap(2,6,4)==22`: This suggests finding the 4th term of an AP with first term 2 and common difference 6  \n- `tn_ap(1,4,5)==16`: This suggests finding the 5th term of an AP with first term 1 and common difference 4\n\nThe formula for the nth term of an arithmetic progression is: `a_n = a_1 + (n-1) * d`\n\nWhere:\n- `a_1` is the first term\n- `d` is the common difference\n- `n` is the term number\n\nLet me verify:\n- `tn_ap(1,5,2)`: 1 + (2-1)*5 = 1 + 5 = 6 \u2260 9\n- Let me try: 1 + 2*5 = 11 \u2260 9\n- Maybe it's: 1 + (2+1)*5 = 1 + 15 = 16 \u2260 9\n\nLet me reconsider the parameter order. Maybe it's `tn_ap(first_term, common_difference, term_number)`:\n- `tn_ap(1,5,2)`: 1 + (2-1)*5 = 6 \u2260 9\n\nLet me try a different interpretation. Looking at the results:\n- For (1,5,2)\u21929: Maybe 1 + 2*4 = 9, so d=4? No.\n- Let me try: (1-1)*5 + 2*something = 9, so 2*something = 9, something = 4.5\n\nActually, let me check if it's `first_term + (term_number-1) * common_difference`:\n- `tn_ap(1,5,2)`: 1 + (2-1)*5 = 6 \u2260", "is_syntactically_valid": false}
{"task_id": 355, "generation": "def count_Rectangles(r):\n    if r == 0:\n        return 0\n    \n    count = 0\n    \n    # Check all possible bottom-left corners (i,j) where the rectangle could fit\n    for i in range(-r, r):\n        for j in range(-r, r):\n            # Check if all four corners of the unit rectangle are within the circle\n            corners = [(i, j), (i+1, j), (i, j+1), (i+1, j+1)]\n            if all(x*x + y*y <= r*r for x, y in corners):\n                count += 1\n    \n    return count", "is_syntactically_valid": true}
{"task_id": 356, "generation": "def find_angle(angle1, angle2):\n    return 180 - angle1 - angle2", "is_syntactically_valid": true}
{"task_id": 357, "generation": "def find_max(tuples):\n    max_val = float('-inf')\n    for tuple_record in tuples:\n        for element in tuple_record:\n            if element > max_val:\n                max_val = element\n    return max_val", "is_syntactically_valid": true}
{"task_id": 358, "generation": "def moddiv_list(list1, list2):\n    return list(map(lambda x, y: x % y, list1, list2))", "is_syntactically_valid": true}
{"task_id": 359, "generation": "import math\n\ndef Check_Solution(a, b, c):\n    # Calculate discriminant\n    discriminant = b**2 - 4*a*c\n    \n    # Check if roots are real\n    if discriminant < 0:\n        return \"No\"\n    \n    # Calculate the two roots\n    root1 = (-b + math.sqrt(discriminant)) / (2*a)\n    root2 = (-b - math.sqrt(discriminant)) / (2*a)\n    \n    # Check if one root is twice the other\n    if abs(root1 - 2*root2) < 1e-10 or abs(root2 - 2*root1) < 1e-10:\n        return \"Yes\"\n    else:\n        return \"No\"", "is_syntactically_valid": true}
{"task_id": 360, "generation": "def get_carol(n):\n    return (2**n - 1)**2 - 2", "is_syntactically_valid": true}
{"task_id": 361, "generation": "def remove_empty(lst):\n    return [item for item in lst if item != []]", "is_syntactically_valid": true}
{"task_id": 362, "generation": "def max_occurrences(lst):\n    from collections import Counter\n    \n    # Count occurrences of each item\n    count_dict = Counter(lst)\n    \n    # Find the maximum count\n    max_count = max(count_dict.values())\n    \n    # Find all items with maximum count\n    max_items = [item for item, count in count_dict.items() if count == max_count]\n    \n    # If there's only one item with max count, return it\n    if len(max_items) == 1:\n        return max_items[0]\n    \n    # If there are multiple items with max count, return them as a tuple\n    return tuple(sorted(max_items))", "is_syntactically_valid": true}
{"task_id": 363, "generation": "def add_K_element(tuples_list, k):\n    result = []\n    for tuple_item in tuples_list:\n        new_tuple = tuple(element + k for element in tuple_item)\n        result.append(new_tuple)\n    return result", "is_syntactically_valid": true}
{"task_id": 364, "generation": "def min_flip_to_make_string_alternate(s):\n    n = len(s)\n    \n    # Count flips needed for pattern starting with '0'\n    flips_pattern_0 = 0\n    for i in range(n):\n        expected = '0' if i % 2 == 0 else '1'\n        if s[i] != expected:\n            flips_pattern_0 += 1\n    \n    # Count flips needed for pattern starting with '1'\n    flips_pattern_1 = 0\n    for i in range(n):\n        expected = '1' if i % 2 == 0 else '0'\n        if s[i] != expected:\n            flips_pattern_1 += 1\n    \n    return min(flips_pattern_0, flips_pattern_1)", "is_syntactically_valid": true}
{"task_id": 365, "generation": "def count_Digit(number):\n    return len(str(abs(number)))", "is_syntactically_valid": true}
{"task_id": 366, "generation": "def adjacent_num_product(nums):\n    max_product = nums[0] * nums[1]\n    \n    for i in range(1, len(nums) - 1):\n        product = nums[i] * nums[i + 1]\n        if product > max_product:\n            max_product = product\n    \n    return max_product", "is_syntactically_valid": true}
{"task_id": 367, "generation": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_tree_balanced(root):\n    def check_height(node):\n        if not node:\n            return 0\n        \n        left_height = check_height(node.left)\n        if left_height == -1:\n            return -1\n        \n        right_height = check_height(node.right)\n        if right_height == -1:\n            return -1\n        \n        if abs(left_height - right_height) > 1:\n            return -1\n        \n        return max(left_height, right_height) + 1\n    \n    return check_height(root) != -1\n\n# Test cases\n# Unbalanced tree\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.left.left = TreeNode(3)\n\n# Balanced tree\nroot1 = TreeNode(1)\nroot1.left = TreeNode(2)\nroot1.right = TreeNode(3)\n\n# Unbalanced tree\nroot2 = TreeNode(1)\nroot2.right = TreeNode(2)\nroot2.right.right = TreeNode(3)\nroot2.right.right.right = TreeNode(4)", "is_syntactically_valid": true}
{"task_id": 368, "generation": "def repeat_tuples(tuple_input, n):\n    return tuple(tuple_input for _ in range(n))", "is_syntactically_valid": true}
{"task_id": 369, "generation": "def lateralsurface_cuboid(length, width, height):\n    return 2 * height * (length + width)", "is_syntactically_valid": true}
{"task_id": 370, "generation": "def float_sort(tuples):\n    return sorted(tuples, key=lambda x: float(x[1]), reverse=True)", "is_syntactically_valid": true}
{"task_id": 371, "generation": "def smallest_missing(arr, start, end):\n    # Binary search approach to find the smallest missing element\n    left = start\n    right = end\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        # If arr[mid] == mid, then missing element is on the right side\n        if arr[mid] == mid:\n            left = mid + 1\n        # If arr[mid] > mid, then missing element is on the left side\n        else:\n            right = mid - 1\n    \n    return left", "is_syntactically_valid": true}
{"task_id": 372, "generation": "import heapq\n\ndef heap_assending(lst):\n    # Create a copy of the list to avoid modifying the original\n    heap = lst.copy()\n    \n    # Convert the list into a heap\n    heapq.heapify(heap)\n    \n    # Extract elements from heap one by one to get sorted order\n    result = []\n    while heap:\n        result.append(heapq.heappop(heap))\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 373, "generation": "def volume_cuboid(length, width, height):\n    return length * width * height", "is_syntactically_valid": true}
{"task_id": 374, "generation": "def permute_string(s):\n    if len(s) <= 1:\n        return [s]\n    \n    result = []\n    for i in range(len(s)):\n        char = s[i]\n        remaining = s[:i] + s[i+1:]\n        for perm in permute_string(remaining):\n            result.append(char + perm)\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 375, "generation": "def round_num(num, multiple):\n    return (num // multiple) * multiple", "is_syntactically_valid": true}
{"task_id": 376, "generation": "def remove_replica(tup):\n    # Count occurrences of each element\n    count_dict = {}\n    for item in tup:\n        count_dict[item] = count_dict.get(item, 0) + 1\n    \n    # Track how many times we've seen each element\n    seen_count = {}\n    result = []\n    \n    for item in tup:\n        seen_count[item] = seen_count.get(item, 0) + 1\n        \n        # If this is the first occurrence, keep it\n        if seen_count[item] == 1:\n            result.append(item)\n        # If this is a duplicate, replace with 'MSP'\n        else:\n            result.append('MSP')\n    \n    return tuple(result)", "is_syntactically_valid": true}
{"task_id": 377, "generation": "def remove_Char(string, char):\n    return string.replace(char, '')", "is_syntactically_valid": true}
{"task_id": 378, "generation": "def move_first(lst):\n    if len(lst) <= 1:\n        return lst\n    return [lst[-1]] + lst[:-1]", "is_syntactically_valid": true}
{"task_id": 379, "generation": "def surfacearea_cuboid(length, width, height):\n    return 2 * (length * width + length * height + width * height)", "is_syntactically_valid": true}
{"task_id": 380, "generation": "def multi_list(rows, cols):\n    result = []\n    for i in range(rows):\n        row = []\n        for j in range(cols):\n            row.append(i * j)\n        result.append(row)\n    return result", "is_syntactically_valid": true}
{"task_id": 381, "generation": "def index_on_inner_list(lst, index):\n    return sorted(lst, key=lambda x: x[index])", "is_syntactically_valid": true}
{"task_id": 382, "generation": "def find_rotation_count(arr):\n    if not arr:\n        return 0\n    \n    left, right = 0, len(arr) - 1\n    \n    # If array is not rotated\n    if arr[left] <= arr[right]:\n        return 0\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        # Check if mid is the minimum element\n        if mid > 0 and arr[mid] < arr[mid - 1]:\n            return mid\n        \n        # Check if mid+1 is the minimum element\n        if mid < len(arr) - 1 and arr[mid] > arr[mid + 1]:\n            return mid + 1\n        \n        # If left half is sorted, minimum is in right half\n        if arr[left] <= arr[mid]:\n            left = mid + 1\n        # Otherwise, minimum is in left half\n        else:\n            right = mid - 1\n    \n    return 0", "is_syntactically_valid": true}
{"task_id": 383, "generation": "def even_bit_toggle_number(n):\n    # Create a mask with 1s at even positions (0, 2, 4, 6, ...)\n    # Pattern: ...01010101 (0x55555555 for 32-bit)\n    mask = 0x55555555\n    \n    # XOR with the mask to toggle even-positioned bits\n    return n ^ mask", "is_syntactically_valid": true}
{"task_id": 384, "generation": "def frequency_Of_Smallest(n, arr):\n    min_value = min(arr)\n    count = 0\n    for value in arr:\n        if value == min_value:\n            count += 1\n    return count", "is_syntactically_valid": true}
{"task_id": 385, "generation": "def get_perrin(n):\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return get_perrin(n-2) + get_perrin(n-3)", "is_syntactically_valid": true}
{"task_id": 386, "generation": "def swap_count(s):\n    # Remove all characters that are not brackets\n    brackets = ''.join(c for c in s if c in '[]')\n    \n    # Count unmatched opening and closing brackets\n    open_count = 0\n    unmatched_close = 0\n    \n    for char in brackets:\n        if char == '[':\n            open_count += 1\n        else:  # char == ']'\n            if open_count > 0:\n                open_count -= 1\n            else:\n                unmatched_close += 1\n    \n    # After processing, open_count contains unmatched opening brackets\n    # unmatched_close contains unmatched closing brackets\n    \n    # To balance, we need to swap half of unmatched closing brackets\n    # with half of unmatched opening brackets\n    return (unmatched_close + 1) // 2", "is_syntactically_valid": true}
{"task_id": 387, "generation": "def even_or_odd(hex_string):\n    # Convert hexadecimal string to integer\n    decimal_value = int(hex_string, 16)\n    \n    # Check if the decimal value is even or odd\n    if decimal_value % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"", "is_syntactically_valid": true}
{"task_id": 388, "generation": "def highest_Power_of_2(n):\n    if n <= 0:\n        return 0\n    \n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    \n    return power", "is_syntactically_valid": true}
{"task_id": 389, "generation": "def find_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    a, b = 2, 1\n    for i in range(2, n + 1):\n        a, b = b, a + b\n    \n    return b", "is_syntactically_valid": true}
{"task_id": 390, "generation": "def add_string(lst, template):\n    return [template.format(item) for item in lst]", "is_syntactically_valid": true}
{"task_id": 391, "generation": "def convert_list_dictionary(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        nested_dict = {list1[i]: {list2[i]: list3[i]}}\n        result.append(nested_dict)\n    return result", "is_syntactically_valid": true}
{"task_id": 392, "generation": "def get_max_sum(n):\n    memo = {}\n    \n    def helper(n):\n        if n in memo:\n            return memo[n]\n        \n        if n <= 1:\n            memo[n] = n\n            return n\n        \n        # Calculate f(n/2) + f(n/3) + f(n/4) + f(n/5)\n        sum_parts = helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5)\n        \n        # Return max of sum_parts and n\n        result = max(sum_parts, n)\n        memo[n] = result\n        return result\n    \n    return helper(n)", "is_syntactically_valid": true}
{"task_id": 393, "generation": "def max_length_list(lists):\n    max_list = max(lists, key=lambda x: len(x))\n    return (len(max_list), max_list)", "is_syntactically_valid": true}
{"task_id": 394, "generation": "def check_distinct(tuple_input):\n    return len(tuple_input) == len(set(tuple_input))", "is_syntactically_valid": true}
{"task_id": 395, "generation": "def first_non_repeating_character(s):\n    char_count = {}\n    \n    # Count frequency of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find first character with count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    return None", "is_syntactically_valid": true}
{"task_id": 396, "generation": "import re\n\ndef check_char(s):\n    if re.match(r'^(.).*\\1$|^.$', s):\n        return \"Valid\"\n    else:\n        return \"Invalid\"", "is_syntactically_valid": true}
{"task_id": 397, "generation": "def median_numbers(a, b, c):\n    numbers = [a, b, c]\n    numbers.sort()\n    return float(numbers[1])", "is_syntactically_valid": true}
{"task_id": 398, "generation": "def sum_of_digits(lst):\n    def get_digit_sum(num):\n        return sum(int(digit) for digit in str(abs(num)))\n    \n    def process_item(item):\n        if isinstance(item, int):\n            return get_digit_sum(item)\n        elif isinstance(item, list):\n            return sum(process_item(sub_item) for sub_item in item)\n        else:\n            return 0\n    \n    return sum(process_item(item) for item in lst)", "is_syntactically_valid": true}
{"task_id": 399, "generation": "def bitwise_xor(tuple1, tuple2):\n    return tuple(a ^ b for a, b in zip(tuple1, tuple2))", "is_syntactically_valid": true}
{"task_id": 400, "generation": "def extract_freq(tuple_list):\n    normalized_tuples = set()\n    for tup in tuple_list:\n        normalized = tuple(sorted(tup))\n        normalized_tuples.add(normalized)\n    return len(normalized_tuples)", "is_syntactically_valid": true}
{"task_id": 401, "generation": "def add_nested_tuples(tuple1, tuple2):\n    result = []\n    for i in range(len(tuple1)):\n        inner_tuple = tuple(tuple1[i][j] + tuple2[i][j] for j in range(len(tuple1[i])))\n        result.append(inner_tuple)\n    return tuple(result)", "is_syntactically_valid": true}
{"task_id": 402, "generation": "def ncr_modp(n, r, p):\n    if r > n or r < 0:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    \n    # Calculate nCr using the formula: nCr = n! / (r! * (n-r)!)\n    # But we need to do this modulo p, so we use modular arithmetic\n    \n    # We'll use the multiplicative inverse for division in modular arithmetic\n    def mod_inverse(a, m):\n        # Extended Euclidean Algorithm to find modular inverse\n        def extended_gcd(a, b):\n            if a == 0:\n                return b, 0, 1\n            gcd, x1, y1 = extended_gcd(b % a, a)\n            x = y1 - (b // a) * x1\n            y = x1\n            return gcd, x, y\n        \n        gcd, x, _ = extended_gcd(a % m, m)\n        if gcd != 1:\n            return None  # Modular inverse doesn't exist\n        return (x % m + m) % m\n    \n    # Calculate nCr mod p using the formula\n    # nCr = n * (n-1) * ... * (n-r+1) / (r * (r-1) * ... * 1)\n    \n    numerator = 1\n    denominator = 1\n    \n    for i in range(r):\n        numerator = (numerator * (n - i)) % p\n        denominator = (denominator * (i + 1)) % p\n    \n    # Find modular inverse of denominator\n    inv_denominator = mod_inverse(denominator, p)\n    if inv_denominator is None:\n        return 0\n    \n    result = (numerator * inv_denominator) % p\n    return result", "is_syntactically_valid": true}
{"task_id": 403, "generation": "import re\n\ndef is_valid_URL(url):\n    pattern = r'^https?://[^\\s/$.?#].[^\\s]*$'\n    return bool(re.match(pattern, url))", "is_syntactically_valid": true}
{"task_id": 404, "generation": "def minimum(a, b):\n    if a < b:\n        return a\n    else:\n        return b", "is_syntactically_valid": true}
{"task_id": 405, "generation": "def check_tuplex(tuple_x, element):\n    return element in tuple_x", "is_syntactically_valid": true}
{"task_id": 406, "generation": "def find_Parity(n):\n    if n % 2 == 0:\n        return \"Even Parity\"\n    else:\n        return \"Odd Parity\"", "is_syntactically_valid": true}
{"task_id": 407, "generation": "def rearrange_bigger(num):\n    digits = list(str(num))\n    n = len(digits)\n    \n    # Find the rightmost digit that is smaller than the digit next to it\n    i = n - 2\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n    \n    # If no such digit is found, return False\n    if i == -1:\n        return False\n    \n    # Find the smallest digit on right side of above character that is greater than digits[i]\n    j = n - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n    \n    # Swap the found characters\n    digits[i], digits[j] = digits[j], digits[i]\n    \n    # Reverse the substring after position i\n    digits[i + 1:] = reversed(digits[i + 1:])\n    \n    return int(''.join(digits))", "is_syntactically_valid": true}
{"task_id": 408, "generation": "import heapq\n\ndef k_smallest_pairs(nums1, nums2, k):\n    if not nums1 or not nums2 or k == 0:\n        return []\n    \n    # Min heap to store (sum, i, j) where i is index in nums1, j is index in nums2\n    heap = []\n    result = []\n    \n    # Initialize heap with pairs from first element of nums1 with all elements of nums2\n    for j in range(min(len(nums2), k)):\n        heapq.heappush(heap, (nums1[0] + nums2[j], 0, j))\n    \n    while heap and len(result) < k:\n        sum_val, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n        \n        # Add next pair from nums1 if possible\n        if i + 1 < len(nums1):\n            heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 409, "generation": "def min_product_tuple(tuples_list):\n    min_product = float('inf')\n    \n    for tuple_item in tuples_list:\n        product = tuple_item[0] * tuple_item[1]\n        if product < min_product:\n            min_product = product\n    \n    return min_product", "is_syntactically_valid": true}
{"task_id": 410, "generation": "def min_val(lst):\n    numeric_values = []\n    for item in lst:\n        if isinstance(item, (int, float)):\n            numeric_values.append(item)\n    \n    if numeric_values:\n        return min(numeric_values)\n    else:\n        return None", "is_syntactically_valid": true}
{"task_id": 411, "generation": "import re\n\ndef snake_to_camel(snake_str):\n    return re.sub(r'_([a-z])', lambda m: m.group(1).upper(), snake_str.title())", "is_syntactically_valid": true}
{"task_id": 412, "generation": "def remove_odd(lst):\n    return [num for num in lst if num % 2 == 0]", "is_syntactically_valid": true}
{"task_id": 413, "generation": "def extract_nth_element(list_of_tuples, n):\n    return [tuple[n] for tuple in list_of_tuples]", "is_syntactically_valid": true}
{"task_id": 414, "generation": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "is_syntactically_valid": true}
{"task_id": 415, "generation": "def max_Product(arr):\n    if len(arr) < 2:\n        return None\n    \n    max_product = float('-inf')\n    result_pair = None\n    \n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            product = arr[i] * arr[j]\n            if product > max_product:\n                max_product = product\n                result_pair = (arr[i], arr[j])\n    \n    return result_pair", "is_syntactically_valid": true}
{"task_id": 416, "generation": "def breakSum(n):\n    if n <= 4:\n        return n\n    \n    # Memoization to avoid recalculating\n    memo = {}\n    \n    def helper(num):\n        if num in memo:\n            return memo[num]\n        \n        if num <= 4:\n            memo[num] = num\n            return num\n        \n        # Option 1: Keep the number as is\n        keep_as_is = num\n        \n        # Option 2: Divide into three parts and sum recursively\n        part1 = num // 3\n        part2 = num // 3\n        part3 = num // 3 + num % 3\n        \n        divide_sum = helper(part1) + helper(part2) + helper(part3)\n        \n        # Take maximum\n        result = max(keep_as_is, divide_sum)\n        memo[num] = result\n        return result\n    \n    return helper(n)", "is_syntactically_valid": true}
{"task_id": 417, "generation": "def group_tuples(tuples_list):\n    from collections import defaultdict\n    \n    # Group tuples by their first element\n    groups = defaultdict(list)\n    \n    for tup in tuples_list:\n        first_element = tup[0]\n        remaining_elements = tup[1:]\n        groups[first_element].extend(remaining_elements)\n    \n    # Build result list maintaining original order\n    result = []\n    seen = set()\n    \n    for tup in tuples_list:\n        first_element = tup[0]\n        if first_element not in seen:\n            seen.add(first_element)\n            grouped_tuple = (first_element,) + tuple(groups[first_element])\n            result.append(grouped_tuple)\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 418, "generation": "def Find_Max(lst):\n    max_length = 0\n    max_sublist = []\n    \n    for sublist in lst:\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n            max_sublist = sublist\n    \n    return max_sublist", "is_syntactically_valid": true}
{"task_id": 419, "generation": "def round_and_sum(numbers):\n    rounded_numbers = [round(num) for num in numbers]\n    total_sum = sum(rounded_numbers)\n    return total_sum * len(numbers)", "is_syntactically_valid": true}
{"task_id": 420, "generation": "def cube_Sum(n):\n    total = 0\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        total += even_number ** 3\n    return total", "is_syntactically_valid": true}
{"task_id": 421, "generation": "def concatenate_tuple(tup):\n    return '-'.join(str(element) for element in tup)", "is_syntactically_valid": true}
{"task_id": 422, "generation": "def find_Average_Of_Cube(n):\n    total = sum(i**3 for i in range(1, n+1))\n    return total / n", "is_syntactically_valid": true}
{"task_id": 423, "generation": "def get_maxgold(grid, m, n):\n    # Create a DP table to store maximum gold that can be collected\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    \n    # Fill the rightmost column\n    for i in range(m):\n        dp[i][n-1] = grid[i][n-1]\n    \n    # Fill the DP table from right to left\n    for j in range(n-2, -1, -1):\n        for i in range(m):\n            # Three possible moves: right, right-up diagonal, right-down diagonal\n            right = dp[i][j+1]\n            right_up = dp[i-1][j+1] if i > 0 else 0\n            right_down = dp[i+1][j+1] if i < m-1 else 0\n            \n            dp[i][j] = grid[i][j] + max(right, right_up, right_down)\n    \n    # Find maximum value in the first column\n    max_gold = 0\n    for i in range(m):\n        max_gold = max(max_gold, dp[i][0])\n    \n    return max_gold", "is_syntactically_valid": true}
{"task_id": 424, "generation": "def extract_rear(tuple_of_strings):\n    return [string[-1] for string in tuple_of_strings]", "is_syntactically_valid": true}
{"task_id": 425, "generation": "def count_element_in_list(list_of_lists, element):\n    return sum(1 for sublist in list_of_lists if element in sublist)", "is_syntactically_valid": true}
{"task_id": 426, "generation": "def filter_oddnumbers(numbers):\n    return list(filter(lambda x: x % 2 == 1, numbers))", "is_syntactically_valid": true}
{"task_id": 427, "generation": "import re\n\ndef change_date_format(date_string):\n    pattern = r'(\\d{4})-(\\d{2})-(\\d{2})'\n    replacement = r'\\3-\\2-\\1'\n    return re.sub(pattern, replacement, date_string)", "is_syntactically_valid": true}
{"task_id": 428, "generation": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            \n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            arr[j] = temp\n        \n        gap //= 2\n    \n    return arr", "is_syntactically_valid": true}
{"task_id": 429, "generation": "def and_tuples(tuple1, tuple2):\n    return tuple(a & b for a, b in zip(tuple1, tuple2))", "is_syntactically_valid": true}
{"task_id": 430, "generation": "def parabola_directrix(a, b, c):\n    return -4 * a * b * c - 2 * (a**2 + b**2 + c**2)", "is_syntactically_valid": true}
{"task_id": 431, "generation": "def common_element(list1, list2):\n    for element in list1:\n        if element in list2:\n            return True\n    return None", "is_syntactically_valid": true}
{"task_id": 432, "generation": "def median_trapezium(a, b, c):\n    values = [a, b, c]\n    values.sort()\n    return (values[0] + values[1]) / 2", "is_syntactically_valid": true}
{"task_id": 433, "generation": "def check_greater(arr, num):\n    if num > max(arr):\n        return 'Yes, the entered number is greater than those in the array'\n    else:\n        return 'No, entered number is less than those in the array'", "is_syntactically_valid": true}
{"task_id": 434, "generation": "import re\n\ndef text_match_one(text):\n    pattern = r'ab+'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'", "is_syntactically_valid": true}
{"task_id": 435, "generation": "def last_Digit(number):\n    return number % 10", "is_syntactically_valid": true}
{"task_id": 436, "generation": "def neg_nos(lst):\n    return [i for i in lst if i < 0]", "is_syntactically_valid": true}
{"task_id": 437, "generation": "def remove_odd(s):\n    return ''.join(s[i] for i in range(1, len(s), 2))", "is_syntactically_valid": true}
{"task_id": 438, "generation": "def count_bidirectional(tuples_list):\n    count = 0\n    for i, tuple1 in enumerate(tuples_list):\n        reversed_tuple = (tuple1[1], tuple1[0])\n        for j, tuple2 in enumerate(tuples_list):\n            if i != j and tuple2 ", "is_syntactically_valid": false}
{"task_id": 439, "generation": "def multiple_to_single(lst):\n    result = \"\"\n    for num in lst:\n        result += str(num)\n    return int(result)", "is_syntactically_valid": true}
{"task_id": 440, "generation": "import re\n\ndef find_adverb_position(sentence):\n    # Find adverbs (words ending with 'ly') using regex\n    pattern = r'\\b\\w*ly\\b'\n    match = re.search(pattern, sentence, re.IGNORECASE)\n    \n    if match:\n        adverb = match.group()\n        start_pos = match.start()\n        end_pos = match.end() - 1\n        return (start_pos, end_pos, adverb.lower())\n    \n    return None", "is_syntactically_valid": true}
{"task_id": 441, "generation": "def surfacearea_cube(side):\n    return 6 * side * side", "is_syntactically_valid": true}
{"task_id": 442, "generation": "def positive_count(arr):\n    positive_numbers = 0\n    total_numbers = len(arr)\n    \n    for num in arr:\n        if num > 0:\n            positive_numbers += 1\n    \n    return round(positive_numbers / total_numbers, 2)", "is_syntactically_valid": true}
{"task_id": 443, "generation": "def largest_neg(lst):\n    negative_numbers = [num for num in lst if num < 0]\n    if not negative_numbers:\n        return None\n    return max(negative_numbers)", "is_syntactically_valid": true}
{"task_id": 444, "generation": "def trim_tuple(tuple_list, k):\n    result = []\n    for tup in tuple_list:\n        trimmed = tup[k:-k] if k < len(tup) // 2 else ()\n        result.append(trimmed)\n    return str(result)", "is_syntactically_valid": true}
{"task_id": 445, "generation": "def index_multiplication(tuple1, tuple2):\n    result = []\n    for i in range(len(tuple1)):\n        inner_tuple = []\n        for j in range(len(tuple1[i])):\n            inner_tuple.append(tuple1[i][j] * tuple2[i][j])\n        result.append(tuple(inner_tuple))\n    return tuple(result)", "is_syntactically_valid": true}
{"task_id": 446, "generation": "def count_Occurrence(tuple_data, list_data):\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count", "is_syntactically_valid": true}
{"task_id": 447, "generation": "def cube_nums(nums):\n    return list(map(lambda x: x**3, nums))", "is_syntactically_valid": true}
{"task_id": 448, "generation": "def cal_sum(n):\n    if n <= 0:\n        return 0\n    \n    # Generate Perrin numbers\n    perrin = []\n    \n    # Base cases\n    if n >= 1:\n        perrin.append(3)  # P(0) = 3\n    if n >= 2:\n        perrin.append(0)  # P(1) = 0\n    if n >= 3:\n        perrin.append(2)  # P(2) = 2\n    \n    # Generate remaining Perrin numbers\n    for i in range(3, n):\n        next_perrin = perrin[i-2] + perrin[i-3]\n        perrin.append(next_perrin)\n    \n    return sum(perrin)", "is_syntactically_valid": true}
{"task_id": 449, "generation": "def check_Triangle(x1, y1, x2, y2, x3, y3):\n    # Calculate the area using the cross product formula\n    # Area = 0.5 * |x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2)|\n    area = abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n    \n    # If area is 0, the points are collinear (not a valid triangle)\n    if area == 0:\n        return 'No'\n    else:\n        return 'Yes'", "is_syntactically_valid": true}
{"task_id": 450, "generation": "def extract_string(string_list, size):\n    result = []\n    for string in string_list:\n        if len(string) == size:\n            result.append(string)\n    return result", "is_syntactically_valid": true}
{"task_id": 451, "generation": "import re\n\ndef remove_whitespaces(string):\n    return re.sub(r'\\s+', '', string)", "is_syntactically_valid": true}
{"task_id": 452, "generation": "def loss_amount(cost_price, selling_price):\n    if selling_price < cost_price:\n        return cost_price - selling_price\n    else:\n        return None", "is_syntactically_valid": true}
{"task_id": 453, "generation": "def sumofFactors(n):\n    sum_even_factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even_factors += i\n    return sum_even_factors", "is_syntactically_valid": true}
{"task_id": 454, "generation": "import re\n\ndef text_match_wordz(text):\n    if re.search(r'\\w*z\\w*', text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'", "is_syntactically_valid": true}
{"task_id": 455, "generation": "def check_monthnumb_number(month):\n    months_with_31_days = {1, 3, 5, 7, 8, 10, 12}\n    return month in months_with_31_days", "is_syntactically_valid": true}
{"task_id": 456, "generation": "def reverse_string_list(string_list):\n    return [string[::-1] for string in string_list]", "is_syntactically_valid": true}
{"task_id": 457, "generation": "def Find_Min(lists):\n    min_list = lists[0]\n    min_length = len(lists[0])\n    \n    for lst in lists:\n        if len(lst) < min_length:\n            min_length = len(lst)\n            min_list = lst\n    \n    return min_list", "is_syntactically_valid": true}
{"task_id": 458, "generation": "def rectangle_area(length, width):\n    return length * width", "is_syntactically_valid": true}
{"task_id": 459, "generation": "import re\n\ndef remove_uppercase(s):\n    return re.sub(r'[A-Z]', '', s)", "is_syntactically_valid": true}
{"task_id": 460, "generation": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "is_syntactically_valid": true}
{"task_id": 461, "generation": "def upper_ctr(s):\n    count = 0\n    for char in s:\n        if char.isupper():\n            count += 1\n    return count", "is_syntactically_valid": true}
{"task_id": 462, "generation": "def combinations_list(lst):\n    result = []\n    n = len(lst)\n    \n    # Generate all possible combinations using bit manipulation\n    for i in range(2**n):\n        combination = []\n        for j in range(n):\n            # Check if j-th bit is set in i\n            if i & (1 << j):\n                combination.append(lst[j])\n        result.append(combination)\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 463, "generation": "def max_subarray_product(arr):\n    if not arr:\n        return 0\n    \n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n    \n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n        \n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        \n        result = max(result, max_product)\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 464, "generation": "def check_value(dictionary, value):\n    return all(v == value for v in dictionary.values())", "is_syntactically_valid": true}
{"task_id": 465, "generation": "def drop_empty(dictionary):\n    return {key: value for key, value in dictionary.items() if value is not None}", "is_syntactically_valid": true}
{"task_id": 466, "generation": "def find_peak(arr, n):\n    # If array has only one element, it's a peak\n    if n == 1:\n        return 0\n    \n    # Check if first element is peak\n    if arr[0] >= arr[1]:\n        return 0\n    \n    # Check if last element is peak\n    if arr[n-1] >= arr[n-2]:\n        return n-1\n    \n    # Check for peak in middle elements\n    for i in range(1, n-1):\n        if arr[i] >= arr[i-1] and arr[i] >= arr[i+1]:\n            return i\n    \n    # If no peak found, return last index\n    return n-1", "is_syntactically_valid": true}
{"task_id": 467, "generation": "def decimal_to_Octal(decimal):\n    if decimal == 0:\n        return 0\n    \n    octal = \"\"\n    while decimal > 0:\n        remainder = decimal % 8\n        octal = str(remainder) + octal\n        decimal = decimal // 8\n    \n    return int(octal)", "is_syntactically_valid": true}
{"task_id": 468, "generation": "def max_product(arr, n):\n    # dp[i] stores the maximum product of increasing subsequence ending at index i\n    dp = [0] * n\n    \n    # Initialize dp array with the array elements themselves\n    for i in range(n):\n        dp[i] = arr[i]\n    \n    # Fill dp array\n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    \n    # Return the maximum product among all subsequences\n    return max(dp)", "is_syntactically_valid": true}
{"task_id": 469, "generation": "def max_profit(prices, k):\n    if not prices or k == 0:\n        return 0\n    \n    n = len(prices)\n    \n    # If k is large enough, we can make as many transactions as we want\n    if k >= n // 2:\n        profit = 0\n        for i in range(1, n):\n            if prices[i] > prices[i-1]:\n                profit += prices[i] - prices[i-1]\n        return profit\n    \n    # DP approach for limited transactions\n    # buy[i][j] = max profit after at most i transactions, currently holding stock\n    # sell[i][j] = max profit after at most i transactions, not holding stock\n    buy = [[-float('inf')] * n for _ in range(k+1)]\n    sell = [[0] * n for _ in range(k+1)]\n    \n    for i in range(1, k+1):\n        buy[i][0] = -prices[0]\n        for j in range(1, n):\n            buy[i][j] = max(buy[i][j-1], sell[i-1][j-1] - prices[j])\n            sell[i][j] = max(sell[i][j-1], buy[i][j-1] + prices[j])\n    \n    return sell[k][n-1]", "is_syntactically_valid": true}
{"task_id": 470, "generation": "def add_pairwise(tup):\n    result = []\n    for i in range(len(tup) - 1):\n        result.append(tup[i] + tup[i + 1])\n    return tuple(result)", "is_syntactically_valid": true}
{"task_id": 471, "generation": "def find_remainder(arr, length, n):\n    product = 1\n    for i in range(length):\n        product = (product * arr[i]) % n\n    return product", "is_syntactically_valid": true}
{"task_id": 472, "generation": "def check_Consecutive(lst):\n    if len(lst) <= 1:\n        return True\n    \n    # Remove duplicates and sort\n    unique_sorted = sorted(set(lst))\n    \n    # Check if original list has duplicates\n    if len(unique_sorted) != len(lst):\n        return False\n    \n    # Check if consecutive\n    for i in range(1, len(unique_sorted)):\n        if unique_sorted[i] - unique_sorted[i-1] != 1:\n            return False\n    \n    return True", "is_syntactically_valid": true}
{"task_id": 473, "generation": "def tuple_intersection(list1, list2):\n    # Convert tuples to sets to handle order-independent comparison\n    set1 = set()\n    set2 = set()\n    \n    # For each tuple, create a frozenset to make it order-independent\n    for t in list1:\n        set1.add(frozenset(t))\n    \n    for t in list2:\n        set2.add(frozenset(t))\n    \n    # Find intersection\n    intersection = set1 & set2\n    \n    # Convert back to tuples, using sorted order for consistency\n    result = set()\n    for fs in intersection:\n        result.add(tuple(sorted(fs)))\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 474, "generation": "def replace_char(string, old_char, new_char):\n    return string.replace(old_char, new_char)", "is_syntactically_valid": true}
{"task_id": 475, "generation": "def sort_counter(counter_dict):\n    return sorted(counter_dict.items(), key=lambda x: x[1], reverse=True)", "is_syntactically_valid": true}
{"task_id": 476, "generation": "def big_sum(arr):\n    return max(arr) + min(arr)", "is_syntactically_valid": true}
{"task_id": 477, "generation": "def is_lower(string):\n    return string.lower()", "is_syntactically_valid": true}
{"task_id": 478, "generation": "def remove_lowercase(s):\n    result = \"\"\n    for char in s:\n        if not char.islower():\n            result += char\n    return result", "is_syntactically_valid": true}
{"task_id": 479, "generation": "def first_Digit(num):\n    # Convert to string and get the first character, then convert back to int\n    return int(str(abs(num))[0])", "is_syntactically_valid": true}
{"task_id": 480, "generation": "def get_max_occuring_char(s):\n    char_count = {}\n    \n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    max_char = max(char_count, key=char_count.get)\n    return max_char", "is_syntactically_valid": true}
{"task_id": 481, "generation": "def is_subset_sum(arr, n, target_sum):\n    # Create a 2D DP table\n    # dp[i][j] represents whether sum j can be achieved using first i elements\n    dp = [[False for _ in range(target_sum + 1)] for _ in range(n + 1)]\n    \n    # Base case: sum 0 can always be achieved with empty subset\n    for i in range(n + 1):\n        dp[i][0] = True\n    \n    # Fill the DP table\n    for i in range(1, n + 1):\n        for j in range(1, target_sum + 1):\n            # If current element is greater than target sum, exclude it\n            if arr[i-1] > j:\n                dp[i][j] = dp[i-1][j]\n            else:\n                # Include current element or exclude it\n                dp[i][j] = dp[i-1][j] or dp[i-1][j - arr[i-1]]\n    \n    return dp[n][target_sum]", "is_syntactically_valid": true}
{"task_id": 482, "generation": "import re\n\ndef match(string):\n    pattern = r'[A-Z][a-z]+'\n    if re.search(pattern, string):\n        return 'Yes'\n    else:\n        return 'No'", "is_syntactically_valid": true}
{"task_id": 483, "generation": "def first_Factorial_Divisible_Number(x):\n    n = 1\n    factorial = 1\n    \n    while factorial % x != 0:\n        n += 1\n        factorial *= n\n    \n    return n", "is_syntactically_valid": true}
{"task_id": 484, "generation": "def remove_matching_tuple(tuple1, tuple2):\n    return [item for item in tuple1 if item not in tuple2]", "is_syntactically_valid": true}
{"task_id": 485, "generation": "def largest_palindrome(arr, n):\n    def is_palindrome(num):\n        str_num = str(num)\n        return str_num == str_num[::-1]\n    \n    palindromes = [num for num in arr if is_palindrome(num)]\n    \n    if palindromes:\n        return max(palindromes)\n    else:\n        return None", "is_syntactically_valid": true}
{"task_id": 486, "generation": "import math\n\ndef binomial_probability(n, k, p):\n    # Calculate binomial coefficient C(n, k) = n! / (k! * (n-k)!)\n    binomial_coeff = math.factorial(n) / (math.factorial(k) * math.factorial(n - k))\n    \n    # Calculate binomial probability: C(n, k) * p^k * (1-p)^(n-k)\n    probability = binomial_coeff * (p ** k) * ((1 - p) ** (n - k))\n    \n    return probability", "is_syntactically_valid": true}
{"task_id": 487, "generation": "def sort_tuple(tuples_list):\n    return sorted(tuples_list, key=lambda x: x[-1])", "is_syntactically_valid": true}
{"task_id": 488, "generation": "import math\n\ndef area_pentagon(side_length):\n    area = (1/4) * math.sqrt(25 + 10 * math.sqrt(5)) * side_length**2\n    return area", "is_syntactically_valid": true}
{"task_id": 489, "generation": "def frequency_Of_Largest(n, arr):\n    max_value = max(arr)\n    return arr.count(max_value)", "is_syntactically_valid": true}
{"task_id": 490, "generation": "def extract_symmetric(tuple_list):\n    seen = set()\n    symmetric_pairs = set()\n    \n    for pair in tuple_list:\n        reversed_pair = (pair[1], pair[0])\n        \n        if reversed_pair in seen:\n            # Found a symmetric pair, add the canonical form (smaller first)\n            canonical_pair = tuple(sorted([pair[0], pair[1]]))\n            symmetric_pairs.add(canonical_pair)\n        else:\n            seen.add(pair)\n    \n    return symmetric_pairs", "is_syntactically_valid": true}
{"task_id": 491, "generation": "def sum_gp(a, n, r):\n    if r == 1:\n        return a * n\n    else:\n        return a * (r**n - 1) // (r - 1)", "is_syntactically_valid": true}
{"task_id": 492, "generation": "def binary_search(arr, target):\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False", "is_syntactically_valid": true}
{"task_id": 493, "generation": "import math\n\ndef calculate_polygons(start_x, start_y, cols, rows, size):\n    result = []\n    \n    # Hexagon geometry constants\n    width = size * 2\n    height = size * math.sqrt(3)\n    \n    # Horizontal and vertical spacing between hexagon centers\n    h_spacing = width * 0.75  # 3/4 of width\n    v_spacing = height\n    \n    for row in range(rows):\n        for col in range(cols):\n            # Calculate center position\n            center_x = start_x + col * h_spacing\n            center_y = start_y + row * v_spacing\n            \n            # Offset every other row\n            if row % 2 == 1:\n                center_x += h_spacing / 2\n            \n            # Generate hexagon vertices\n            hexagon = []\n            for i in range(7):  # 6 vertices + closing vertex\n                angle = i * math.pi / 3  # 60 degrees in radians\n                x = center_x + size * math.cos(angle)\n                y = center_y + size * math.sin(angle)\n                hexagon.append((x, y))\n            \n            result.append(hexagon)\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 494, "generation": "def binary_to_integer(binary_tuple):\n    binary_string = ''.join(str(bit) for bit in binary_tuple)\n    decimal_value = int(binary_string, 2)\n    return str(decimal_value)", "is_syntactically_valid": true}
{"task_id": 495, "generation": "import re\n\ndef remove_lowercase(s):\n    return re.sub(r'[a-z]', '', s)", "is_syntactically_valid": true}
{"task_id": 496, "generation": "import heapq\n\ndef heap_queue_smallest(numbers, k):\n    return heapq.nsmallest(k, numbers)", "is_syntactically_valid": true}
{"task_id": 497, "generation": "import math\n\ndef surfacearea_cone(radius, height):\n    # Calculate the slant height using Pythagorean theorem\n    slant_height = math.sqrt(radius**2 + height**2)\n    \n    # Surface area of cone = \u03c0 * r\u00b2 + \u03c0 * r * l\n    # where r is radius and l is slant height\n    base_area = math.pi * radius**2\n    lateral_area = math.pi * radius * slant_height\n    \n    return base_area + lateral_area", "is_syntactically_valid": true}
{"task_id": 498, "generation": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a", "is_syntactically_valid": true}
{"task_id": 499, "generation": "def diameter_circle(radius):\n    return radius * 2", "is_syntactically_valid": true}
{"task_id": 500, "generation": "def concatenate_elements(lst):\n    return '  ' + ' '.join(lst)", "is_syntactically_valid": true}
{"task_id": 501, "generation": "def num_comm_div(a, b):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    \n    g = gcd(a, b)\n    count = 0\n    \n    for i in range(1, int(g**0.5) + 1):\n        if g % i == 0:\n            count += 1\n            if i != g // i:\n                count += 1\n    \n    return count", "is_syntactically_valid": true}
{"task_id": 502, "generation": "def find(a, b):\n    return a % b", "is_syntactically_valid": true}
{"task_id": 503, "generation": "def add_consecutive_nums(nums):\n    result = []\n    for i in range(len(nums) - 1):\n        result.append(nums[i] + nums[i + 1])\n    return result", "is_syntactically_valid": true}
{"task_id": 504, "generation": "def sum_Of_Series(n):\n    return sum(i**3 for i in range(1, n+1))", "is_syntactically_valid": true}
{"task_id": 505, "generation": "def re_order(arr):\n    non_zeros = []\n    zero_count = 0\n    \n    for num in arr:\n        if num != 0:\n            non_zeros.append(num)\n        else:\n            zero_count += 1\n    \n    return non_zeros + [0] * zero_count", "is_syntactically_valid": true}
{"task_id": 506, "generation": "def permutation_coefficient(n, k):\n    if k > n or k < 0:\n        return 0\n    \n    result = 1\n    for i in range(n, n - k, -1):\n        result *= i\n    \n    return result", "is_syntactically_valid": true}
{"task_id": 507, "generation": "def remove_words(word_list, words_to_remove):\n    return [word for word in word_list if word not in words_to_remove]", "is_syntactically_valid": true}
{"task_id": 508, "generation": "def same_order(list1, list2):\n    # Find common elements while preserving order from list1\n    common_in_list1 = [item for item in list1 if item in list2]\n    \n    # Find common elements while preserving order from list2\n    common_in_list2 = [item for item in list2 if item in list1]\n    \n    # Check if the order of common elements is the same\n    return common_in_list1 == common_in_list2", "is_syntactically_valid": true}
{"task_id": 509, "generation": "def average_Odd(n):\n    odd_numbers = []\n    for i in range(1, n + 1, 2):\n        odd_numbers.append(i)\n    return sum(odd_numbers) // len(odd_numbers)", "is_syntactically_valid": true}
{"task_id": 510, "generation": "def no_of_subsequences(arr, k):\n    n = len(arr)\n    count = 0\n    \n    # Generate all possible subsequences using bit manipulation\n    for i in range(1, 2**n):\n        product = 1\n        for j in range(n):\n            if i & (1 << j):\n                product *= arr[j]\n                if product >= k:\n                    break\n        if product < k:\n            count += 1\n    \n    return count", "is_syntactically_valid": true}
