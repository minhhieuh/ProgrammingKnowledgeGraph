[
  {
    "task_id": 12,
    "generated_code": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)",
    "assertion_results": [
      {
        "assertion": "assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 19,
    "generated_code": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))",
    "assertion_results": [
      {
        "assertion": "assert test_duplicate(([1,2,3,4,5]))==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert test_duplicate(([1,2,3,4, 4]))==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 17,
    "generated_code": "def square_perimeter(side_length):\n    return 4 * side_length",
    "assertion_results": [
      {
        "assertion": "assert square_perimeter(10)==40",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert square_perimeter(5)==20",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert square_perimeter(4)==16",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 26,
    "generated_code": "def check_k_elements(tuple_list, k):\n    return all(k in tuple_item for tuple_item in tuple_list)",
    "assertion_results": [
      {
        "assertion": "assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_k_elements([(7, 7, 7), (7, 7)], 7) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_k_elements([(9, 9), (9, 9, 9, 9)], 7) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 21,
    "generated_code": "def multiples_of_num(m, n):\n    return [n * i for i in range(1, m + 1)]",
    "assertion_results": [
      {
        "assertion": "assert multiples_of_num(4,3)== [3,6,9,12]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert multiples_of_num(2,5)== [5,10]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert multiples_of_num(9,2)== [2,4,6,8,10,12,14,16,18]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 22,
    "generated_code": "def find_first_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return -1",
    "assertion_results": [
      {
        "assertion": "assert find_first_duplicate(([1, 2, 3, 4, 4, 5]))==4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_first_duplicate([1, 2, 3, 4])==-1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_first_duplicate([1, 1, 2, 3, 3, 2, 2])==1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 18,
    "generated_code": "def remove_dirty_chars(string1, string2):\n    dirty_chars = set(string2)\n    result = \"\"\n    for char in string1:\n        if char not in dirty_chars:\n            result += char\n    return result",
    "assertion_results": [
      {
        "assertion": "assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles' ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 16,
    "generated_code": "import re\n\ndef text_lowercase_underscore(text):\n    pattern = r'^[a-z]+_[a-z]+$'\n    if re.match(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
    "assertion_results": [
      {
        "assertion": "assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert text_lowercase_underscore(\"aab_Abbbc\")==('Not matched!')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 29,
    "generated_code": "from collections import Counter\n\ndef get_Odd_Occurrence(arr, n):\n    frequencies = Counter(arr)\n    for element, count in frequencies.items():\n        if count % 2 == 1:\n            return element",
    "assertion_results": [
      {
        "assertion": "assert get_Odd_Occurrence([1,2,3,1,2,3,1],7) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_Odd_Occurrence([1,2,3,2,3,1,3],7) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_Odd_Occurrence([2,3,5,4,5,2,4,3,5,2,4,4,2],13) == 5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 23,
    "generated_code": "def maximum_Sum(list_of_lists):\n    max_sum = float('-inf')\n    \n    for sublist in list_of_lists:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n    \n    return max_sum",
    "assertion_results": [
      {
        "assertion": "assert maximum_Sum([[1,2,3],[4,5,6],[10,11,12],[7,8,9]]) == 33",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert maximum_Sum([[0,1,1],[1,1,2],[3,2,1]]) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert maximum_Sum([[0,1,3],[1,2,1],[9,8,2],[0,1,0],[6,4,8]]) == 19",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 15,
    "generated_code": "def split_lowerstring(s):\n    result = []\n    current_part = \"\"\n    \n    for char in s:\n        if char.islower():\n            current_part += char\n            result.append(current_part)\n            current_part = \"\"\n        else:\n            current_part += char\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert split_lowerstring(\"AbCd\")==['bC','d']",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert split_lowerstring(\"Python\")==['y', 't', 'h', 'o', 'n']",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert split_lowerstring(\"Programming\")==['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 14,
    "generated_code": "def find_Volume(length, width, height):\n    return (length * width * height) // 2",
    "assertion_results": [
      {
        "assertion": "assert find_Volume(10,8,6) == 240",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_Volume(3,2,2) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_Volume(1,2,1) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 37,
    "generated_code": "def sort_mixed_list(mixed_list):\n    integers = []\n    strings = []\n    \n    for item in mixed_list:\n        if isinstance(item, int):\n            integers.append(item)\n        else:\n            strings.append(item)\n    \n    integers.sort()\n    strings.sort()\n    \n    return integers + strings",
    "assertion_results": [
      {
        "assertion": "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 27,
    "generated_code": "def remove(strings):\n    result = []\n    for string in strings:\n        new_string = \"\"\n        for char in string:\n            if not char.isdigit():\n                new_string += char\n        result.append(new_string)\n    return result",
    "assertion_results": [
      {
        "assertion": "assert remove(['4words', '3letters', '4digits']) == ['words', 'letters', 'digits']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove(['28Jan','12Jan','11Jan']) == ['Jan','Jan','Jan']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove(['wonder1','wonder2','wonder3']) == ['wonder','wonder','wonder']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 25,
    "generated_code": "def find_Product(arr, n):\n    # Count frequency of each element\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Find product of elements that appear only once\n    product = 1\n    for num, count in freq.items():\n        if count == 1:\n            product *= num\n    \n    return product",
    "assertion_results": [
      {
        "assertion": "assert find_Product([1,1,2,3],4) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_Product([1,2,3,1,1],5) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_Product([1,1,4,5,6],5) == 120",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 28,
    "generated_code": "def binomial_Coeff(n, k):\n    if k > n or k < 0:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    # Use the multiplicative formula: C(n,k) = n! / (k! * (n-k)!)\n    # But calculate it efficiently to avoid large factorials\n    result = 1\n    for i in range(min(k, n - k)):\n        result = result * (n - i) // (i + 1)\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert binomial_Coeff(5,2) == 10",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert binomial_Coeff(4,3) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert binomial_Coeff(3,2) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 30,
    "generated_code": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    n = len(s)\n    \n    # Count single characters (they start and end with same character)\n    count += n\n    \n    # Count substrings of length 2 or more\n    for i in range(n):\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                count += 1\n    \n    return count",
    "assertion_results": [
      {
        "assertion": "assert count_Substring_With_Equal_Ends(\"abc\") == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Substring_With_Equal_Ends(\"abcda\") == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Substring_With_Equal_Ends(\"ab\") == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 33,
    "generated_code": "def decimal_To_Binary(decimal):\n    if decimal == 0:\n        return 0\n    \n    binary = \"\"\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal = decimal // 2\n    \n    return int(binary)",
    "assertion_results": [
      {
        "assertion": "assert decimal_To_Binary(10) == 1010",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert decimal_To_Binary(1) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert decimal_To_Binary(20) == 10100",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 34,
    "generated_code": "def find_missing(arr, n):\n    # Calculate expected sum of numbers from 1 to n\n    expected_sum = n * (n + 1) // 2\n    \n    # Calculate actual sum of the array\n    actual_sum = sum(arr)\n    \n    # The missing number is the difference\n    return expected_sum - actual_sum",
    "assertion_results": [
      {
        "assertion": "assert find_missing([1,2,3,5],4) == 4",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_missing([1,3,4,5],4) == 2",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_missing([1,2,3,5,6,7],5) == 4",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 35,
    "generated_code": "def find_rect_num(n):\n    return n * (n + 1)",
    "assertion_results": [
      {
        "assertion": "assert find_rect_num(4) == 20",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_rect_num(5) == 30",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_rect_num(6) == 42",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 38,
    "generated_code": "def div_even_odd(lst):\n    first_even = None\n    first_odd = None\n    \n    for num in lst:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 == 1 and first_odd is None:\n            first_odd = num\n        \n        if first_even is not None and first_odd is not None:\n            break\n    \n    return first_even // first_odd",
    "assertion_results": [
      {
        "assertion": "assert div_even_odd([1,3,5,7,4,1,6,8])==4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert div_even_odd([1,2,3,4,5,6,7,8,9,10])==2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert div_even_odd([1,5,7,9,10])==10",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 13,
    "generated_code": "from collections import Counter\n\ndef count_common(words):\n    # Count frequency of each word\n    word_counts = Counter(words)\n    \n    # Get the maximum frequency\n    max_count = max(word_counts.values())\n    \n    # Find all words with maximum frequency\n    most_common = [(word, count) for word, count in word_counts.items() if count == max_count]\n    \n    # Sort by word alphabetically for consistent ordering\n    most_common.sort(key=lambda x: x[0])\n    \n    return most_common",
    "assertion_results": [
      {
        "assertion": "assert count_common(['red','green','black','pink','black','white','black','eyes','white','black','orange','pink','pink','red','red','white','orange','white',\"black\",'pink','green','green','pink','green','pink','white','orange',\"orange\",'red']) == [('pink', 6), ('black', 5), ('white', 5), ('red', 4)]",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_common(['one', 'two', 'three', 'four', 'five', 'one', 'two', 'one', 'three', 'one']) == [('one', 4), ('two', 2), ('three', 2), ('four', 1)]",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_common(['Facebook', 'Apple', 'Amazon', 'Netflix', 'Google', 'Apple', 'Netflix', 'Amazon']) == [('Apple', 2), ('Amazon', 2), ('Netflix', 2), ('Facebook', 1)]",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 24,
    "generated_code": "def binary_to_decimal(binary):\n    binary_str = str(binary)\n    decimal = 0\n    power = 0\n    \n    for digit in reversed(binary_str):\n        decimal += int(digit) * (2 ** power)\n        power += 1\n    \n    return decimal",
    "assertion_results": [
      {
        "assertion": "assert binary_to_decimal(100) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert binary_to_decimal(1011) == 11",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert binary_to_decimal(1101101) == 109",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 41,
    "generated_code": "def filter_evennumbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))",
    "assertion_results": [
      {
        "assertion": "assert filter_evennumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[2, 4, 6, 8, 10]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert filter_evennumbers([10,20,45,67,84,93])==[10,20,84]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert filter_evennumbers([5,7,9,8,6,4,3])==[8,6,4]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 46,
    "generated_code": "def test_distinct(numbers):\n    return len(numbers) == len(set(numbers))",
    "assertion_results": [
      {
        "assertion": "assert test_distinct([1,5,7,9]) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert test_distinct([2,4,5,5,7,9]) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert test_distinct([1,2,3]) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 43,
    "generated_code": "import re\n\ndef text_match(text):\n    pattern = r'^[a-z]+_[a-z]+$'\n    if re.match(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
    "assertion_results": [
      {
        "assertion": "assert text_match(\"aab_cbbbc\") == 'Found a match!'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert text_match(\"aab_Abbbc\") == 'Not matched!'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert text_match(\"Aaab_abbbc\") == 'Not matched!'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 52,
    "generated_code": "def parallelogram_area(base, height):\n    return base * height",
    "assertion_results": [
      {
        "assertion": "assert parallelogram_area(10,20)==200",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert parallelogram_area(15,20)==300",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert parallelogram_area(8,9)==72",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 32,
    "generated_code": "def max_Prime_Factors(n):\n    if n <= 1:\n        return None\n    \n    max_prime = -1\n    \n    # Check for factor 2\n    while n % 2 == 0:\n        max_prime = 2\n        n = n // 2\n    \n    # Check for odd factors from 3 onwards\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            max_prime = i\n            n = n // i\n        i += 2\n    \n    # If n is still greater than 1, then it's a prime\n    if n > 1:\n        max_prime = n\n    \n    return max_prime",
    "assertion_results": [
      {
        "assertion": "assert max_Prime_Factors(15) == 5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_Prime_Factors(6) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_Prime_Factors(2) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 44,
    "generated_code": "import re\n\ndef text_match_string(text):\n    pattern = r'^python'\n    if re.match(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
    "assertion_results": [
      {
        "assertion": "assert text_match_string(\" python\")==('Not matched!')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert text_match_string(\"python\")==('Found a match!')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert text_match_string(\"  lang\")==('Not matched!')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 51,
    "generated_code": "def check_equilateral(a, b, c):\n    return a == b == c",
    "assertion_results": [
      {
        "assertion": "assert check_equilateral(6,8,12)==False ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_equilateral(6,6,12)==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_equilateral(6,6,6)==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 53,
    "generated_code": "def check_Equality(s):\n    if s[0] == s[-1]:\n        return \"Equal\"\n    else:\n        return \"Not Equal\"",
    "assertion_results": [
      {
        "assertion": "assert check_Equality(\"abcda\") == \"Equal\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_Equality(\"ab\") == \"Not Equal\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_Equality(\"mad\") == \"Not Equal\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 50,
    "generated_code": "def min_length_list(lists):\n    min_list = min(lists, key=lambda x: len(x))\n    return (len(min_list), min_list)",
    "assertion_results": [
      {
        "assertion": "assert min_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(1, [0])",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert min_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])==(1,[1])",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert min_length_list([[3,4,5],[6,7,8,9],[10,11,12],[1,2]])==(2,[1,2])",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 45,
    "generated_code": "import math\nfrom functools import reduce\n\ndef get_gcd(arr):\n    return reduce(math.gcd, arr)",
    "assertion_results": [
      {
        "assertion": "assert get_gcd([2, 4, 6, 8, 16]) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_gcd([1, 2, 3]) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_gcd([2, 4, 6, 8]) == 2 ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 36,
    "generated_code": "def find_Nth_Digit(numerator, denominator, n):\n    # Perform long division to get the nth digit after decimal point\n    remainder = numerator % denominator\n    \n    for i in range(n):\n        remainder *= 10\n        digit = remainder // denominator\n        remainder = remainder % denominator\n        \n        if i == n - 1:  # nth digit (1-indexed)\n            return digit\n    \n    return digit",
    "assertion_results": [
      {
        "assertion": "assert find_Nth_Digit(1,2,1) == 5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_Nth_Digit(3,5,1) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_Nth_Digit(5,6,5) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 59,
    "generated_code": "def is_octagonal(n):\n    return n * (3 * n - 2)",
    "assertion_results": [
      {
        "assertion": "assert is_octagonal(5) == 65",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_octagonal(10) == 280",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_octagonal(15) == 645",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 58,
    "generated_code": "def opposite_Signs(a, b):\n    return (a > 0 and b < 0) or (a < 0 and b > 0)",
    "assertion_results": [
      {
        "assertion": "assert opposite_Signs(1,-2) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert opposite_Signs(3,2) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert opposite_Signs(-10,-10) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 31,
    "generated_code": "import heapq\nfrom collections import Counter\n\ndef func(lists, k):\n    # Count frequency of each integer across all lists\n    counter = Counter()\n    for lst in lists:\n        for num in lst:\n            counter[num] += 1\n    \n    # Use a min heap to keep track of top k elements\n    heap = []\n    \n    for num, freq in counter.items():\n        if len(heap) < k:\n            heapq.heappush(heap, (freq, num))\n        elif freq > heap[0][0]:\n            heapq.heapreplace(heap, (freq, num))\n    \n    # Extract numbers from heap and sort by frequency (descending) then by value (ascending)\n    result = []\n    while heap:\n        freq, num = heapq.heappop(heap)\n        result.append((freq, num))\n    \n    # Sort by frequency descending, then by value ascending for tie-breaking\n    result.sort(key=lambda x: (-x[0], x[1]))\n    \n    return [num for freq, num in result]",
    "assertion_results": [
      {
        "assertion": "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],3)==[5, 7, 1]",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],1)==[1]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],5)==[6, 5, 7, 8, 1]",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 49,
    "generated_code": "def specified_element(two_d_list, index):\n    result = []\n    for row in two_d_list:\n        result.append(row[index])\n    return result",
    "assertion_results": [
      {
        "assertion": "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],0)==[1, 4, 7]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],2)==[3, 6, 9]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],1)==[2,5,1]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 11,
    "generated_code": "def remove_Occ(string, char):\n    if char not in string:\n        return string\n    \n    # Find first occurrence\n    first_index = string.find(char)\n    \n    # Find last occurrence\n    last_index = string.rfind(char)\n    \n    # If first and last are the same (only one occurrence)\n    if first_index == last_index:\n        return string[:first_index] + string[first_index + 1:]\n    \n    # Remove last occurrence first to avoid index shifting\n    result = string[:last_index] + string[last_index + 1:]\n    \n    # Find first occurrence in the modified string\n    first_index = result.find(char)\n    \n    # Remove first occurrence\n    result = result[:first_index] + result[first_index + 1:]\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert remove_Occ(\"hello\",\"l\") == \"heo\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_Occ(\"abcda\",\"a\") == \"bcd\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_Occ(\"PHP\",\"P\") == \"H\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 40,
    "generated_code": "from collections import Counter\n\ndef freq_element(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened = []\n    for sublist in list_of_lists:\n        flattened.extend(sublist)\n    \n    # Use Counter to count frequencies\n    frequency_counter = Counter(flattened)\n    \n    # Convert Counter to dictionary and return\n    return dict(frequency_counter)",
    "assertion_results": [
      {
        "assertion": "assert freq_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]])==({2: 3, 1: 2, 5: 2, 3: 1, 4: 1, 6: 1, 7: 1, 9: 1})",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert freq_element([[1,2,3,4],[5,6,7,8],[9,10,11,12]])==({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1})",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert freq_element([[15,20,30,40],[80,90,100,110],[30,30,80,90]])==({30: 3, 80: 2, 90: 2, 15: 1, 20: 1, 40: 1, 100: 1, 110: 1})",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 48,
    "generated_code": "def odd_bit_set_number(n):\n    # Create a mask with all odd bits set (1st, 3rd, 5th, etc.)\n    # In binary: ...10101010101010101010101010101010\n    mask = 0xAAAAAAAA\n    \n    # Set all odd bits by OR-ing with the mask\n    return n | mask",
    "assertion_results": [
      {
        "assertion": "assert odd_bit_set_number(10) == 15",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert odd_bit_set_number(20) == 21",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert odd_bit_set_number(30) == 31",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 55,
    "generated_code": "def tn_gp(a, n, r):\n    return a * (r ** (n - 1))",
    "assertion_results": [
      {
        "assertion": "assert tn_gp(1,5,2)==16",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert tn_gp(1,5,4)==256",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert tn_gp(2,6,3)==486",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 62,
    "generated_code": "def smallest_num(numbers):\n    return min(numbers)",
    "assertion_results": [
      {
        "assertion": "assert smallest_num([10, 20, 1, 45, 99]) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert smallest_num([1, 2, 3]) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert smallest_num([45, 46, 50, 60]) == 45",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 56,
    "generated_code": "def check(num):\n    # Convert number to string to easily reverse it\n    num_str = str(num)\n    \n    # Reverse the string and convert back to integer\n    reversed_num = int(num_str[::-1])\n    \n    # Check if num is one less than twice its reverse\n    return num == (2 * reversed_num - 1)",
    "assertion_results": [
      {
        "assertion": "assert check(70) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check(23) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check(73) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 42,
    "generated_code": "def find_Sum(arr, n):\n    element_count = {}\n    \n    # Count occurrences of each element\n    for element in arr:\n        element_count[element] = element_count.get(element, 0) + 1\n    \n    # Sum elements that appear more than once\n    total_sum = 0\n    for element, count in element_count.items():\n        if count > 1:\n            total_sum += element\n    \n    return total_sum",
    "assertion_results": [
      {
        "assertion": "assert find_Sum([1,2,3,1,1,4,5,6],8) == 3",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_Sum([1,2,3,1,1],5) == 3",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_Sum([1,1,2],3) == 2",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 66,
    "generated_code": "def pos_count(arr):\n    count = 0\n    for num in arr:\n        if num > 0:\n            count += 1\n    return count",
    "assertion_results": [
      {
        "assertion": "assert pos_count([1,-2,3,-4]) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert pos_count([3,4,5,-1]) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert pos_count([1,2,3,4]) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 57,
    "generated_code": "def find_Max_Num(digits, n):\n    # Sort digits in descending order to get the largest number\n    digits.sort(reverse=True)\n    \n    # Convert digits to string and join them\n    result = ''.join(map(str, digits))\n    \n    # Convert back to integer and return\n    return int(result)",
    "assertion_results": [
      {
        "assertion": "assert find_Max_Num([1,2,3],3) == 321",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_Max_Num([4,5,6,1],4) == 6541",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_Max_Num([1,2,3,9],4) == 9321",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 20,
    "generated_code": "def is_woodall(n):\n    # A Woodall number has the form n * 2^n - 1\n    # To check if a given number is Woodall, we need to find if there exists\n    # a positive integer k such that n = k * 2^k - 1\n    \n    # Rearranging: n + 1 = k * 2^k\n    # So we need to check if (n + 1) can be expressed as k * 2^k\n    \n    target = n + 1\n    k = 1\n    \n    # We only need to check reasonable values of k\n    # Since k * 2^k grows very quickly, we don't need to check large values\n    while k * (2 ** k) <= target:\n        if k * (2 ** k) == target:\n            return True\n        k += 1\n    \n    return False",
    "assertion_results": [
      {
        "assertion": "assert is_woodall(383) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_woodall(254) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_woodall(200) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 63,
    "generated_code": "def max_difference(tuple_list):\n    max_diff = 0\n    for pair in tuple_list:\n        diff = abs(pair[0] - pair[1])\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff",
    "assertion_results": [
      {
        "assertion": "assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_difference([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_difference([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 61,
    "generated_code": "def count_Substrings(s, n):\n    count = 0\n    \n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            length = j - i + 1\n            if digit_sum == length:\n                count += 1\n    \n    return count",
    "assertion_results": [
      {
        "assertion": "assert count_Substrings('112112',6) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Substrings('111',3) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Substrings('1101112',7) == 12",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 65,
    "generated_code": "def recursive_list_sum(lst):\n    total = 0\n    for item in lst:\n        if isinstance(item, list):\n            total += recursive_list_sum(item)\n        else:\n            total += item\n    return total",
    "assertion_results": [
      {
        "assertion": "assert recursive_list_sum(([1, 2, [3,4],[5,6]]))==21",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert recursive_list_sum(([7, 10, [15,14],[19,41]]))==106",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert recursive_list_sum(([10, 20, [30,40],[50,60]]))==210",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 73,
    "generated_code": "import re\n\ndef multiple_split(text):\n    return re.split(r'[\\n*]', text)",
    "assertion_results": [
      {
        "assertion": "assert multiple_split('Forces of the \\ndarkness*are coming into the play.') == ['Forces of the ', 'darkness', 'are coming into the play.']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert multiple_split('Mi Box runs on the \\n Latest android*which has google assistance and chromecast.') == ['Mi Box runs on the ', ' Latest android', 'which has google assistance and chromecast.']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert multiple_split('Certain services\\nare subjected to change*over the seperate subscriptions.') == ['Certain services', 'are subjected to change', 'over the seperate subscriptions.']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 80,
    "generated_code": "def tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) / 6",
    "assertion_results": [
      {
        "assertion": "assert tetrahedral_number(5) == 35.0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert tetrahedral_number(6) == 56.0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert tetrahedral_number(7) == 84.0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 69,
    "generated_code": "def is_sublist(main_list, sub_list):\n    if not sub_list:\n        return True\n    \n    if len(sub_list) > len(main_list):\n        return False\n    \n    for i in range(len(main_list) - len(sub_list) + 1):\n        if main_list[i:i + len(sub_list)] == sub_list:\n            return True\n    \n    return False",
    "assertion_results": [
      {
        "assertion": "assert is_sublist([2,4,3,5,7],[3,7])==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_sublist([2,4,3,5,7],[4,3])==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_sublist([2,4,3,5,7],[1,6])==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 68,
    "generated_code": "def is_Monotonic(arr):\n    if len(arr) <= 1:\n        return True\n    \n    increasing = True\n    decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            decreasing = False\n        elif arr[i] < arr[i-1]:\n            increasing = False\n    \n    return increasing or decreasing",
    "assertion_results": [
      {
        "assertion": "assert is_Monotonic([6, 5, 4, 4]) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_Monotonic([1, 2, 2, 3]) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_Monotonic([1, 3, 2]) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 79,
    "generated_code": "def word_len(word):\n    return len(word) % 2 == 1",
    "assertion_results": [
      {
        "assertion": "assert word_len(\"Hadoop\") == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert word_len(\"great\") == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert word_len(\"structure\") == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 64,
    "generated_code": "def subject_marks(tuples_list):\n    return sorted(tuples_list, key=lambda x: x[1])",
    "assertion_results": [
      {
        "assertion": "assert subject_marks([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])==[('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert subject_marks([('Telugu',49),('Hindhi',54),('Social',33)])==([('Social',33),('Telugu',49),('Hindhi',54)])",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert subject_marks([('Physics',96),('Chemistry',97),('Biology',45)])==([('Biology',45),('Physics',96),('Chemistry',97)])",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 70,
    "generated_code": "def get_equal(tuples_list, expected_length):\n    for tuple_item in tuples_list:\n        if len(tuple_item) != expected_length:\n            return 'All tuples do not have same length'\n    return 'All tuples have same length'",
    "assertion_results": [
      {
        "assertion": "assert get_equal([(11, 22, 33), (44, 55, 66)], 3) == 'All tuples have same length'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_equal([(1, 2, 3), (4, 5, 6, 7)], 3) == 'All tuples do not have same length'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_equal([(1, 2), (3, 4)], 2) == 'All tuples have same length'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 54,
    "generated_code": "def counting_sort(arr):\n    if not arr:\n        return arr\n    \n    # Find the range of input\n    min_val = min(arr)\n    max_val = max(arr)\n    range_val = max_val - min_val + 1\n    \n    # Create count array\n    count = [0] * range_val\n    \n    # Count occurrences of each element\n    for num in arr:\n        count[num - min_val] += 1\n    \n    # Build the sorted array\n    result = []\n    for i in range(range_val):\n        result.extend([i + min_val] * count[i])\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert counting_sort([1,23,4,5,6,7,8]) == [1, 4, 5, 6, 7, 8, 23]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert counting_sort([12, 9, 28, 33, 69, 45]) == [9, 12, 28, 33, 45, 69]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert counting_sort([8, 4, 14, 3, 2, 1]) == [1, 2, 3, 4, 8, 14]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 72,
    "generated_code": "def dif_Square(n):\n    # A number can be represented as difference of two squares if and only if\n    # it is not of the form 4k + 2 (where k is a non-negative integer)\n    return n % 4 != 2",
    "assertion_results": [
      {
        "assertion": "assert dif_Square(5) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert dif_Square(10) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert dif_Square(15) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 82,
    "generated_code": "import math\n\ndef volume_sphere(radius):\n    return (4/3) * math.pi * (radius ** 3)",
    "assertion_results": [
      {
        "assertion": "assert volume_sphere(10)==4188.790204786391",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert volume_sphere(25)==65449.84694978735",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert volume_sphere(20)==33510.32163829113",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 78,
    "generated_code": "def count_With_Odd_SetBits(n):\n    count = 0\n    for i in range(1, n + 1):\n        # Count set bits in binary representation of i\n        set_bits = bin(i).count('1')\n        # Check if number of set bits is odd\n        if set_bits % 2 == 1:\n            count += 1\n    return count",
    "assertion_results": [
      {
        "assertion": "assert count_With_Odd_SetBits(5) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_With_Odd_SetBits(10) == 5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_With_Odd_SetBits(15) == 8",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 75,
    "generated_code": "def find_tuples(tuples_list, k):\n    result = []\n    for tuple_item in tuples_list:\n        if all(element % k == 0 for element in tuple_item):\n            result.append(tuple_item)\n    return str(result)",
    "assertion_results": [
      {
        "assertion": "assert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == '[(6, 24, 12)]'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_tuples([(5, 25, 30), (4, 2, 3), (7, 8, 9)], 5) == '[(5, 25, 30)]'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_tuples([(7, 9, 16), (8, 16, 4), (19, 17, 18)], 4) == '[(8, 16, 4)]'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 60,
    "generated_code": "def max_len_sub(arr, max_diff):\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) <= max_diff:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)",
    "assertion_results": [
      {
        "assertion": "assert max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8) == 5",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_len_sub([-2, -1, 5, -1, 4, 0, 3], 7) == 4",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_len_sub([9, 11, 13, 15, 18], 5) == 1",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 39,
    "generated_code": "def rearange_string(s):\n    from collections import Counter\n    import heapq\n    \n    # Count frequency of each character\n    char_count = Counter(s)\n    \n    # Check if rearrangement is possible\n    # The most frequent character should not appear more than (n+1)//2 times\n    max_freq = max(char_count.values())\n    if max_freq > (len(s) + 1) // 2:\n        return \"\"\n    \n    # Create a max heap (using negative values for max heap behavior)\n    heap = [(-count, char) for char, count in char_count.items()]\n    heapq.heapify(heap)\n    \n    result = []\n    prev_count, prev_char = 0, ''\n    \n    while heap:\n        # Get the most frequent character\n        count, char = heapq.heappop(heap)\n        result.append(char)\n        \n        # If previous character still has remaining count, add it back to heap\n        if prev_count < 0:\n            heapq.heappush(heap, (prev_count, prev_char))\n        \n        # Update previous character info (decrease count by 1)\n        prev_count, prev_char = count + 1, char\n    \n    return ''.join(result)",
    "assertion_results": [
      {
        "assertion": "assert rearange_string(\"aab\")==('aba')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert rearange_string(\"aabb\")==('abab')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert rearange_string(\"abccdd\")==('cdabcd')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 85,
    "generated_code": "import math\n\ndef surfacearea_sphere(radius):\n    return 4 * math.pi * radius ** 2",
    "assertion_results": [
      {
        "assertion": "assert surfacearea_sphere(10)==1256.6370614359173",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert surfacearea_sphere(15)==2827.4333882308138",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert surfacearea_sphere(20)==5026.548245743669",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 89,
    "generated_code": "def closest_num(n):\n    return n - 1",
    "assertion_results": [
      {
        "assertion": "assert closest_num(11) == 10",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert closest_num(7) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert closest_num(12) == 11",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 83,
    "generated_code": "def get_Char(s):\n    total = sum(ord(char) - ord('a') for char in s)\n    return chr(total % 26 + ord('a'))",
    "assertion_results": [
      {
        "assertion": "assert get_Char(\"abc\") == \"f\"",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_Char(\"gfg\") == \"t\"",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_Char(\"ab\") == \"c\"",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 67,
    "generated_code": "def bell_number(n):\n    if n == 0:\n        return 1\n    \n    # Create a 2D array to store Bell triangle\n    bell = [[0 for i in range(n+1)] for j in range(n+1)]\n    bell[0][0] = 1\n    \n    for i in range(1, n+1):\n        # First element in each row is same as last element of previous row\n        bell[i][0] = bell[i-1][i-1]\n        \n        # Fill the rest of the row\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    \n    return bell[n][0]",
    "assertion_results": [
      {
        "assertion": "assert bell_number(2)==2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert bell_number(10)==115975",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert bell_number(56)==6775685320645824322581483068371419745979053216268760300",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 88,
    "generated_code": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency",
    "assertion_results": [
      {
        "assertion": "assert freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])==({10: 4, 20: 4, 40: 2, 50: 2, 30: 1}) ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert freq_count([1,2,3,4,3,2,4,1,3,1,4])==({1:3, 2:2,3:3,4:3}) ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert freq_count([5,6,7,4,9,10,4,5,6,7,9,5])==({10:1,5:3,6:2,7:2,4:2,9:2}) ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 86,
    "generated_code": "def centered_hexagonal_number(n):\n    return 3 * n * (n - 1) + 1",
    "assertion_results": [
      {
        "assertion": "assert centered_hexagonal_number(10) == 271",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert centered_hexagonal_number(2) == 7",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert centered_hexagonal_number(9) == 217",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 93,
    "generated_code": "def power(a, b):\n    return a ** b",
    "assertion_results": [
      {
        "assertion": "assert power(3,4) == 81",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert power(2,3) == 8",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert power(5,5) == 3125",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 81,
    "generated_code": "def zip_tuples(tuple1, tuple2):\n    result = []\n    len1, len2 = len(tuple1), len(tuple2)\n    \n    for i in range(len1):\n        pair = (tuple1[i], tuple2[i % len2])\n        result.append(pair)\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert zip_tuples((7, 8, 4, 5, 9, 10),(1, 5, 6) ) == [(7, 1), (8, 5), (4, 6), (5, 1), (9, 5), (10, 6)]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert zip_tuples((8, 9, 5, 6, 10, 11),(2, 6, 7) ) == [(8, 2), (9, 6), (5, 7), (6, 2), (10, 6), (11, 7)]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert zip_tuples((9, 10, 6, 7, 11, 12),(3, 7, 8) ) == [(9, 3), (10, 7), (6, 8), (7, 3), (11, 7), (12, 8)]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 87,
    "generated_code": "def merge_dictionaries_three(dict1, dict2, dict3):\n    return {**dict1, **dict2, **dict3}",
    "assertion_results": [
      {
        "assertion": "assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{ \"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\" })=={'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{\"L\":\"lavender\",\"B\":\"Blue\"})=={'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender'}",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" },{\"L\":\"lavender\",\"B\":\"Blue\"},{ \"G\": \"Green\", \"W\": \"White\" })=={'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White'}",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 90,
    "generated_code": "def len_log(words):\n    return max(len(word) for word in words)",
    "assertion_results": [
      {
        "assertion": "assert len_log([\"python\",\"PHP\",\"bigdata\"]) == 7",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert len_log([\"a\",\"ab\",\"abc\"]) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert len_log([\"small\",\"big\",\"tall\"]) == 5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 91,
    "generated_code": "def find_substring(string_list, substring):\n    for string in string_list:\n        if substring in string:\n            return True\n    return False",
    "assertion_results": [
      {
        "assertion": "assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"ack\")==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"abc\")==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"ange\")==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 71,
    "generated_code": "def comb_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    # Make a copy to avoid modifying the original array\n    arr = arr.copy()\n    \n    gap = len(arr)\n    shrink = 1.3\n    sorted = False\n    \n    while not sorted:\n        # Update the gap value for next comb\n        gap = int(gap / shrink)\n        \n        if gap <= 1:\n            gap = 1\n            sorted = True\n        \n        # A single \"comb\" over the input list\n        i = 0\n        while i + gap < len(arr):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n            i += 1\n    \n    return arr",
    "assertion_results": [
      {
        "assertion": "assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert comb_sort([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert comb_sort([99, 15, 13, 47]) == [13, 15, 47, 99]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 98,
    "generated_code": "def multiply_num(numbers):\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)",
    "assertion_results": [
      {
        "assertion": "assert multiply_num((8, 2, 3, -1, 7))==-67.2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert multiply_num((-10,-20,-30))==-2000.0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert multiply_num((19,15,18))==1710.0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 76,
    "generated_code": "def count_Squares(m, n):\n    total_squares = 0\n    \n    # For each possible square size k x k\n    for k in range(1, min(m, n) + 1):\n        # Number of k x k squares that can fit in m x n rectangle\n        # is (m - k + 1) * (n - k + 1)\n        squares_of_size_k = (m - k + 1) * (n - k + 1)\n        total_squares += squares_of_size_k\n    \n    return total_squares",
    "assertion_results": [
      {
        "assertion": "assert count_Squares(4,3) == 20",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Squares(2,2) == 5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Squares(1,1) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 97,
    "generated_code": "def frequency_lists(lists):\n    frequency = {}\n    for sublist in lists:\n        for element in sublist:\n            frequency[element] = frequency.get(element, 0) + 1\n    return frequency",
    "assertion_results": [
      {
        "assertion": "assert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])=={1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert frequency_lists([[1,2,3,4],[5,6,7,8],[9,10,11,12]])=={1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1,10:1,11:1,12:1}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert frequency_lists([[20,30,40,17],[18,16,14,13],[10,20,30,40]])=={20:2,30:2,40:2,17: 1,18:1, 16: 1,14: 1,13: 1, 10: 1}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 47,
    "generated_code": "def compute_Last_Digit(a, b):\n    if b < a:\n        return 1\n    \n    result = 1\n    for i in range(a + 1, b + 1):\n        result = (result * i) % 10\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert compute_Last_Digit(2,4) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert compute_Last_Digit(6,8) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert compute_Last_Digit(1,2) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 96,
    "generated_code": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count",
    "assertion_results": [
      {
        "assertion": "assert divisor(15) == 4 ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert divisor(12) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert divisor(9) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 101,
    "generated_code": "def kth_element(arr, n, k):\n    sorted_arr = sorted(arr)\n    return sorted_arr[k-1]",
    "assertion_results": [
      {
        "assertion": "assert kth_element([12,3,5,7,19], 5, 2) == 3",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert kth_element([17,24,8,23], 4, 3) == 8",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert kth_element([16,21,25,36,4], 5, 4) == 36",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 94,
    "generated_code": "def index_minimum(tuples_list):\n    min_value = float('inf')\n    min_name = None\n    \n    for name, value in tuples_list:\n        if value < min_value:\n            min_value = value\n            min_name = name\n    \n    return min_name",
    "assertion_results": [
      {
        "assertion": "assert index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert index_minimum([('Yash', 185), ('Dawood', 125), ('Sanya', 175)]) == 'Dawood'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert index_minimum([('Sai', 345), ('Salman', 145), ('Ayesha', 96)]) == 'Ayesha'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 99,
    "generated_code": "def decimal_to_binary(decimal):\n    if decimal == 0:\n        return '0'\n    \n    binary = ''\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal = decimal // 2\n    \n    return binary",
    "assertion_results": [
      {
        "assertion": "assert decimal_to_binary(8) == '1000'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert decimal_to_binary(18) == '10010'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert decimal_to_binary(7) == '111' ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 95,
    "generated_code": "def Find_Min_Length(sublists):\n    return min(len(sublist) for sublist in sublists)",
    "assertion_results": [
      {
        "assertion": "assert Find_Min_Length([[1],[1,2]]) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert Find_Min_Length([[1,2],[1,2,3],[1,2,3,4]]) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert Find_Min_Length([[3,3,3],[4,4,4,4]]) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 102,
    "generated_code": "def snake_to_camel(snake_str):\n    words = snake_str.split('_')\n    return ''.join(word.capitalize() for word in words)",
    "assertion_results": [
      {
        "assertion": "assert snake_to_camel('python_program')=='PythonProgram'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert snake_to_camel('python_language')==('PythonLanguage')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert snake_to_camel('programming_language')==('ProgrammingLanguage')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 84,
    "generated_code": "def sequence(n):\n    if n == 1 or n == 2:\n        return 1\n    \n    # Initialize the sequence with first two values\n    newman_conway = [0, 1, 1]  # index 0 is unused, sequence starts from index 1\n    \n    # Build the sequence up to n\n    for i in range(3, n + 1):\n        newman_conway.append(newman_conway[newman_conway[i-1]] + newman_conway[i - newman_conway[i-1]])\n    \n    return newman_conway[n]",
    "assertion_results": [
      {
        "assertion": "assert sequence(10) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sequence(2) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sequence(3) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 106,
    "generated_code": "def add_lists(list_, tuple_):\n    return tuple_ + tuple(list_)",
    "assertion_results": [
      {
        "assertion": "assert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert add_lists([6, 7, 8], (10, 11)) == (10, 11, 6, 7, 8)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert add_lists([7, 8, 9], (11, 12)) == (11, 12, 7, 8, 9)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 74,
    "generated_code": "def is_samepatterns(arr1, arr2):\n    if len(arr1) != len(arr2):\n        return False\n    \n    map1_to_2 = {}\n    map2_to_1 = {}\n    \n    for i in range(len(arr1)):\n        elem1, elem2 = arr1[i], arr2[i]\n        \n        if elem1 in map1_to_2:\n            if map1_to_2[elem1] != elem2:\n                return False\n        else:\n            map1_to_2[elem1] = elem2\n            \n        if elem2 in map2_to_1:\n            if map2_to_1[elem2] != elem1:\n                return False\n        else:\n            map2_to_1[elem2] = elem1\n    \n    return True",
    "assertion_results": [
      {
        "assertion": "assert is_samepatterns([\"red\",\"green\",\"green\"], [\"a\", \"b\", \"b\"])==True ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_samepatterns([\"red\",\"green\",\"greenn\"], [\"a\",\"b\",\"b\"])==False ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_samepatterns([\"red\",\"green\",\"greenn\"], [\"a\",\"b\"])==False ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 105,
    "generated_code": "def count(lst):\n    return sum(lst)",
    "assertion_results": [
      {
        "assertion": "assert count([True,False,True]) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count([False,False]) == 0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count([True,True,True]) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 100,
    "generated_code": "def next_smallest_palindrome(n):\n    def is_palindrome(num):\n        s = str(num)\n        return s == s[::-1]\n    \n    num = n + 1\n    while not is_palindrome(num):\n        num += 1\n    \n    return num",
    "assertion_results": [
      {
        "assertion": "assert next_smallest_palindrome(99)==101",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert next_smallest_palindrome(1221)==1331",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert next_smallest_palindrome(120)==121",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 104,
    "generated_code": "def sort_sublists(list_of_lists):\n    return list(map(lambda sublist: sorted(sublist), list_of_lists))",
    "assertion_results": [
      {
        "assertion": "assert sort_sublists(([\"green\", \"orange\"], [\"black\", \"white\"], [\"white\", \"black\", \"orange\"]))==[['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sort_sublists(([\" red \",\"green\" ],[\"blue \",\" black\"],[\" orange\",\"brown\"]))==[[' red ', 'green'], [' black', 'blue '], [' orange', 'brown']]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sort_sublists(([\"zilver\",\"gold\"], [\"magnesium\",\"aluminium\"], [\"steel\", \"bronze\"]))==[['gold', 'zilver'],['aluminium', 'magnesium'], ['bronze', 'steel']]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 116,
    "generated_code": "def tuple_to_int(t):\n    result = 0\n    for digit in t:\n        result = result * 10 + digit\n    return result",
    "assertion_results": [
      {
        "assertion": "assert tuple_to_int((1,2,3))==123",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert tuple_to_int((4,5,6))==456",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert tuple_to_int((5,6,7))==567",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 113,
    "generated_code": "def check_integer(s):\n    try:\n        int(s)\n        return True\n    except ValueError:\n        return False",
    "assertion_results": [
      {
        "assertion": "assert check_integer(\"python\")==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_integer(\"1\")==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_integer(\"12345\")==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 118,
    "generated_code": "def string_to_list(s):\n    return s.split()",
    "assertion_results": [
      {
        "assertion": "assert string_to_list(\"python programming\")==['python','programming']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert string_to_list(\"lists tuples strings\")==['lists','tuples','strings']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert string_to_list(\"write a program\")==['write','a','program']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 124,
    "generated_code": "import math\n\ndef angle_complex(real, imag):\n    return math.atan2(imag, real)",
    "assertion_results": [
      {
        "assertion": "assert angle_complex(0,1j)==1.5707963267948966 ",
        "status": "ERROR",
        "error": "TypeError: can't convert complex to float",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert angle_complex(2,1j)==0.4636476090008061",
        "status": "ERROR",
        "error": "TypeError: can't convert complex to float",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert angle_complex(0,2j)==1.5707963267948966",
        "status": "ERROR",
        "error": "TypeError: can't convert complex to float",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 120,
    "generated_code": "def max_product_tuple(tuples_list):\n    max_product = 0\n    for tuple_pair in tuples_list:\n        product = tuple_pair[0] * tuple_pair[1]\n        if product > max_product:\n            max_product = product\n    return max_product",
    "assertion_results": [
      {
        "assertion": "assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_product_tuple([(10,20), (15,2), (5,10)] )==200",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 115,
    "generated_code": "def empty_dit(data):\n    if isinstance(data, dict):\n        return len(data) == 0\n    \n    if isinstance(data, list):\n        for item in data:\n            if not isinstance(item, dict) or len(item) > 0:\n                return False\n        return True\n    \n    return False",
    "assertion_results": [
      {
        "assertion": "assert empty_dit([{},{},{}])==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert empty_dit([{1,2},{},{}])==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert empty_dit({})==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 117,
    "generated_code": "def list_to_float(lst):\n    def convert_element(element):\n        if isinstance(element, (tuple, list)):\n            return tuple(convert_element(item) for item in element)\n        else:\n            try:\n                return float(element)\n            except (ValueError, TypeError):\n                return element\n    \n    result = [convert_element(item) for item in lst]\n    return str(result)",
    "assertion_results": [
      {
        "assertion": "assert list_to_float( [(\"3\", \"4\"), (\"1\", \"26.45\"), (\"7.32\", \"8\"), (\"4\", \"8\")] ) == '[(3.0, 4.0), (1.0, 26.45), (7.32, 8.0), (4.0, 8.0)]'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert list_to_float( [(\"4\", \"4\"), (\"2\", \"27\"), (\"4.12\", \"9\"), (\"7\", \"11\")] ) == '[(4.0, 4.0), (2.0, 27.0), (4.12, 9.0), (7.0, 11.0)]'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert list_to_float( [(\"6\", \"78\"), (\"5\", \"26.45\"), (\"1.33\", \"4\"), (\"82\", \"13\")] ) == '[(6.0, 78.0), (5.0, 26.45), (1.33, 4.0), (82.0, 13.0)]'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 128,
    "generated_code": "def long_words(n, sentence):\n    words = sentence.split()\n    return [word for word in words if len(word) > n]",
    "assertion_results": [
      {
        "assertion": "assert long_words(3,\"python is a programming language\")==['python','programming','language']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert long_words(2,\"writing a program\")==['writing','program']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert long_words(5,\"sorting list\")==['sorting']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 92,
    "generated_code": "def is_undulating(s):\n    if len(s) < 3:\n        return len(s) == 3 and s[0] == s[2] and s[0] != s[1]\n    \n    # Check if string alternates between exactly two different digits\n    first_digit = s[0]\n    second_digit = s[1]\n    \n    # First two digits must be different\n    if first_digit == second_digit:\n        return False\n    \n    # Check if pattern alternates throughout\n    for i in range(len(s)):\n        if i % 2 == 0:  # Even positions should match first digit\n            if s[i] != first_digit:\n                return False\n        else:  # Odd positions should match second digit\n            if s[i] != second_digit:\n                return False\n    \n    return True",
    "assertion_results": [
      {
        "assertion": "assert is_undulating(\"1212121\") == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_undulating(\"1991\") == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_undulating(\"121\") == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 133,
    "generated_code": "def sum_negativenum(numbers):\n    return sum(filter(lambda x: x < 0, numbers))",
    "assertion_results": [
      {
        "assertion": "assert sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17])==-32",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_negativenum([10,15,-14,13,-18,12,-20])==-52",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_negativenum([19, -65, 57, 39, 152,-639, 121, 44, 90, -190])==-894",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 130,
    "generated_code": "def max_occurrences(lst):\n    frequency = {}\n    \n    # Count frequency of each element\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n    \n    # Find the item with maximum frequency\n    max_freq = 0\n    max_item = None\n    \n    for item, freq in frequency.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    \n    return (max_item, max_freq)",
    "assertion_results": [
      {
        "assertion": "assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==(2, 5)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,16,18])==(8, 2)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==(20, 3)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 126,
    "generated_code": "def sum(a, b):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    \n    def get_divisors(n):\n        divisors = []\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.append(i)\n                if i != n // i:\n                    divisors.append(n // i)\n        return divisors\n    \n    divisors_a = get_divisors(a)\n    divisors_b = get_divisors(b)\n    \n    common_divisors = []\n    for div in divisors_a:\n        if div in divisors_b:\n            common_divisors.append(div)\n    \n    return sum(common_divisors)",
    "assertion_results": [
      {
        "assertion": "assert sum(10,15) == 6",
        "status": "ERROR",
        "error": "TypeError: sum() missing 1 required positional argument: 'b'",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum(100,150) == 93",
        "status": "ERROR",
        "error": "TypeError: sum() missing 1 required positional argument: 'b'",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum(4,6) == 3",
        "status": "ERROR",
        "error": "TypeError: sum() missing 1 required positional argument: 'b'",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 125,
    "generated_code": "def find_length(binary_string, n):\n    max_diff = 0\n    \n    # Try all possible substrings\n    for i in range(n):\n        zeros = 0\n        ones = 0\n        for j in range(i, n):\n            if binary_string[j] == '0':\n                zeros += 1\n            else:\n                ones += 1\n            \n            # Calculate difference for current substring\n            diff = abs(zeros - ones)\n            max_diff = max(max_diff, diff)\n    \n    return max_diff",
    "assertion_results": [
      {
        "assertion": "assert find_length(\"11000010001\", 11) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_length(\"10111\", 5) == 1",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_length(\"11011101100101\", 14) == 2 ",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 114,
    "generated_code": "def assign_freq(tuple_list):\n    freq_dict = {}\n    \n    # Count frequency of each tuple\n    for tup in tuple_list:\n        if tup in freq_dict:\n            freq_dict[tup] += 1\n        else:\n            freq_dict[tup] = 1\n    \n    # Create result list with tuples and their frequencies\n    result = []\n    for tup, freq in freq_dict.items():\n        result.append(tup + (freq,))\n    \n    return str(result)",
    "assertion_results": [
      {
        "assertion": "assert assign_freq([(6, 5, 8), (2, 7), (6, 5, 8), (6, 5, 8), (9, ), (2, 7)] ) == '[(6, 5, 8, 3), (2, 7, 2), (9, 1)]'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert assign_freq([(4, 2, 4), (7, 1), (4, 8), (4, 2, 4), (9, 2), (7, 1)] ) == '[(4, 2, 4, 2), (7, 1, 2), (4, 8, 1), (9, 2, 1)]'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert assign_freq([(11, 13, 10), (17, 21), (4, 2, 3), (17, 21), (9, 2), (4, 2, 3)] ) == '[(11, 13, 10, 1), (17, 21, 2), (4, 2, 3, 2), (9, 2, 1)]'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 109,
    "generated_code": "def odd_Equivalent(binary_string, n):\n    # Count the number of '1's in the binary string\n    # Each rotation that ends with '1' will result in an odd number\n    count_ones = binary_string.count('1')\n    return count_ones",
    "assertion_results": [
      {
        "assertion": "assert odd_Equivalent(\"011001\",6) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert odd_Equivalent(\"11011\",5) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert odd_Equivalent(\"1010\",4) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 132,
    "generated_code": "def tup_string(tup):\n    return ''.join(tup)",
    "assertion_results": [
      {
        "assertion": "assert tup_string(('e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's'))==(\"exercises\")",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert tup_string(('p','y','t','h','o','n'))==(\"python\")",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert tup_string(('p','r','o','g','r','a','m'))==(\"program\")",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 135,
    "generated_code": "def hexagonal_num(n):\n    return n * (2 * n - 1)",
    "assertion_results": [
      {
        "assertion": "assert hexagonal_num(10) == 190",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert hexagonal_num(5) == 45",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert hexagonal_num(7) == 91",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 119,
    "generated_code": "def search(arr, n):\n    left, right = 0, n - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        # If mid is even, the single element should be on the right\n        # If mid is odd, the single element should be on the left\n        if mid % 2 == 0:\n            # Check if arr[mid] == arr[mid + 1]\n            if mid + 1 < n and arr[mid] == arr[mid + 1]:\n                left = mid + 2\n            else:\n                right = mid - 1\n        else:\n            # Check if arr[mid] == arr[mid - 1]\n            if arr[mid] == arr[mid - 1]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    return arr[left]",
    "assertion_results": [
      {
        "assertion": "assert search([1,1,2,2,3],5) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert search([1,1,3,3,4,4,5,5,7,7,8],11) == 8",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert search([1,2,2,3,3,4,4],7) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 103,
    "generated_code": "def eulerian_num(n, m):\n    # Base cases\n    if m == 0 or m == n - 1:\n        return 1\n    if m < 0 or m >= n:\n        return 0\n    \n    # Create a 2D array to store Eulerian numbers\n    # dp[i][j] represents A(i, j)\n    dp = [[0 for _ in range(n)] for _ in range(n + 1)]\n    \n    # Fill base cases\n    for i in range(n + 1):\n        if i > 0:\n            dp[i][0] = 1\n            if i - 1 < n:\n                dp[i][i - 1] = 1\n    \n    # Fill the dp table using the recurrence relation:\n    # A(n, m) = (m + 1) * A(n - 1, m) + (n - m) * A(n - 1, m - 1)\n    for i in range(2, n + 1):\n        for j in range(1, min(i, n)):\n            dp[i][j] = (j + 1) * dp[i - 1][j] + (i - j) * dp[i - 1][j - 1]\n    \n    return dp[n][m]",
    "assertion_results": [
      {
        "assertion": "assert eulerian_num(3, 1) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert eulerian_num(4, 1) == 11",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert eulerian_num(5, 3) == 26",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 108,
    "generated_code": "import heapq\n\ndef merge_sorted_list(*lists):\n    # First, sort each input list\n    sorted_lists = [sorted(lst) for lst in lists]\n    \n    # Create a min heap with (value, list_index, element_index) tuples\n    heap = []\n    \n    # Initialize heap with first element from each non-empty list\n    for i, lst in enumerate(sorted_lists):\n        if lst:  # Only add if list is not empty\n            heapq.heappush(heap, (lst[0], i, 0))\n    \n    result = []\n    \n    # Process heap until empty\n    while heap:\n        # Get the smallest element\n        value, list_idx, elem_idx = heapq.heappop(heap)\n        result.append(value)\n        \n        # Add next element from the same list if it exists\n        if elem_idx + 1 < len(sorted_lists[list_idx]):\n            next_value = sorted_lists[list_idx][elem_idx + 1]\n            heapq.heappush(heap, (next_value, list_idx, elem_idx + 1))\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert merge_sorted_list([25, 24, 15, 4, 5, 29, 110],[19, 20, 11, 56, 25, 233, 154],[24, 26, 54, 48])==[4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert merge_sorted_list([1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12])==[1, 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert merge_sorted_list([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1],[25, 35, 22, 85, 14, 65, 75, 25, 58],[12, 74, 9, 50, 61, 41])==[1, 2, 3, 4, 7, 8, 9, 9, 9, 10, 12, 14, 14, 18, 22, 25, 25, 35, 41, 50, 58, 61, 65, 74, 75, 85]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 112,
    "generated_code": "def perimeter(radius, height):\n    return 2 * (radius + height)",
    "assertion_results": [
      {
        "assertion": "assert perimeter(2,4) == 12",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert perimeter(1,2) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert perimeter(3,1) == 8",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 131,
    "generated_code": "def reverse_vowels(s):\n    vowels = \"aeiouAEIOU\"\n    s_list = list(s)\n    vowel_chars = []\n    vowel_indices = []\n    \n    # Find all vowels and their indices\n    for i, char in enumerate(s_list):\n        if char in vowels:\n            vowel_chars.append(char)\n            vowel_indices.append(i)\n    \n    # Reverse the vowels and place them back\n    vowel_chars.reverse()\n    for i, index in enumerate(vowel_indices):\n        s_list[index] = vowel_chars[i]\n    \n    return ''.join(s_list)",
    "assertion_results": [
      {
        "assertion": "assert reverse_vowels(\"Python\") == \"Python\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert reverse_vowels(\"USA\") == \"ASU\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert reverse_vowels(\"ab\") == \"ab\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 127,
    "generated_code": "def multiply_int(a, b):\n    if a == 0 or b == 0:\n        return 0\n    \n    # Handle negative numbers\n    negative = False\n    if a < 0:\n        negative = not negative\n        a = -a\n    if b < 0:\n        negative = not negative\n        b = -b\n    \n    result = 0\n    while b > 0:\n        result += a\n        b -= 1\n    \n    return -result if negative else result",
    "assertion_results": [
      {
        "assertion": "assert multiply_int(10,20)==200",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert multiply_int(5,10)==50",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert multiply_int(4,8)==32",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 77,
    "generated_code": "Looking at the test cases, I need to understand what the function should do:\n\n- `is_Diff(12345)` returns `False`\n- `is_Diff(1212112)` returns `True` \n- `is_Diff(1212)` returns `False`\n\nLet me analyze what \"difference between sum of even and odd digits\" means and when it should return `True` or `False`.\n\nFor each number, I'll calculate:\n1. Sum of even digits\n2. Sum of odd digits\n3. Check if there's a specific condition about their difference\n\nLet me trace through the examples:\n- 12345: even digits = [2, 4], odd digits = [1, 3, 5]\n  - Sum of even = 6, sum of odd = 9, difference = |6-9| = 3\n- 1212112: even digits = [2, 2, 2], odd digits = [1, 1, 1, 1]\n  - Sum of even = 6, sum of odd = 4, difference = |6-4| = 2\n- 1212: even digits = [2, 2], odd digits = [1, 1]\n  - Sum of even = 4, sum of odd = 2, difference = |4-2| = 2\n\nLooking at the pattern, it seems like the function should return `True` when there IS a difference, and `False` when the sums are equal or follow some other pattern.\n\nWait, let me reconsider. Looking more carefully:\n- 1212112 returns True (difference = 2)\n- 1212 returns False (difference = 2)\n\nMaybe it's about whether the difference is odd? Let me check:\n- 12345: difference = 3 (odd) \u2192 False\n- 1212112: difference = 2 (even) \u2192 True  \n- 1212: difference = 2 (even) \u2192 False\n\nThat doesn't work either. Let me try another approach - maybe it's about the absolute difference being greater than some threshold, or the difference being exactly some value.\n\nActually, let me check if it's about whether the sum of even digits is greater than sum of odd digits:\n- 12345",
    "assertion_results": []
  },
  {
    "task_id": 137,
    "generated_code": "def zero_count(arr):\n    if len(arr) == 0:\n        return 0.0\n    \n    zero_count = arr.count(0)\n    return round(zero_count / len(arr), 2)",
    "assertion_results": [
      {
        "assertion": "assert zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])==0.15",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert zero_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==0.00",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert zero_count([2, 4, -6, -9, 11, -12, 14, -5, 17])==0.00",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 129,
    "generated_code": "def magic_square_test(square):\n    n = len(square)\n    \n    # Check if it's a square matrix\n    for row in square:\n        if len(row) != n:\n            return False\n    \n    # Calculate the magic sum (sum of first row)\n    magic_sum = sum(square[0])\n    \n    # Check all rows\n    for row in square:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check all columns\n    for col in range(n):\n        col_sum = sum(square[row][col] for row in range(n))\n        if col_sum != magic_sum:\n            return False\n    \n    # Check main diagonal (top-left to bottom-right)\n    main_diag_sum = sum(square[i][i] for i in range(n))\n    if main_diag_sum != magic_sum:\n        return False\n    \n    # Check anti-diagonal (top-right to bottom-left)\n    anti_diag_sum = sum(square[i][n-1-i] for i in range(n))\n    if anti_diag_sum != magic_sum:\n        return False\n    \n    return True",
    "assertion_results": [
      {
        "assertion": "assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 8]])==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 7]])==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 111,
    "generated_code": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    # Start with the first list as the initial set of common elements\n    common = set(nested_lists[0])\n    \n    # Find intersection with each subsequent list\n    for lst in nested_lists[1:]:\n        common = common.intersection(set(lst))\n    \n    # Return as a list\n    return list(common)",
    "assertion_results": [
      {
        "assertion": "assert common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])==[18, 12]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert common_in_nested_lists([[12, 5, 23, 25, 45], [7, 11, 5, 23, 28], [1, 5, 8, 18, 23, 16]])==[5,23]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert common_in_nested_lists([[2, 3,4, 1], [4, 5], [6,4, 8],[4, 5], [6, 8,4]])==[4]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 123,
    "generated_code": "def amicable_numbers_sum(n):\n    def sum_of_proper_divisors(num):\n        if num <= 1:\n            return 0\n        divisors_sum = 1\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                divisors_sum += i\n                if i != num // i:\n                    divisors_sum += num // i\n        return divisors_sum\n    \n    amicable_sum = 0\n    for i in range(1, n + 1):\n        sum_i = sum_of_proper_divisors(i)\n        if sum_i > i and sum_i <= n:\n            sum_sum_i = sum_of_proper_divisors(sum_i)\n            if sum_sum_i == i:\n                amicable_sum += i + sum_i\n    \n    return amicable_sum",
    "assertion_results": [
      {
        "assertion": "assert amicable_numbers_sum(999)==504",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert amicable_numbers_sum(9999)==31626",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert amicable_numbers_sum(99)==0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 143,
    "generated_code": "def find_lists(tuple_of_lists):\n    count = 0\n    for item in tuple_of_lists:\n        if isinstance(item, list):\n            count += 1\n    return count",
    "assertion_results": [
      {
        "assertion": "assert find_lists(([1, 2, 3, 4], [5, 6, 7, 8])) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_lists(([1, 2], [3, 4], [5, 6]))  == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_lists(([9, 8, 7, 6, 5, 4, 3, 2, 1])) == 1",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 142,
    "generated_code": "def count_samepair(list1, list2, list3):\n    count = 0\n    min_length = min(len(list1), len(list2), len(list3))\n    \n    for i in range(min_length):\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    \n    return count",
    "assertion_results": [
      {
        "assertion": "assert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,9],[2,1,3,1,2,6,7,9])==3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,8],[2,1,3,1,2,6,7,8])==4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_samepair([1,2,3,4,2,6,7,8],[2,2,3,1,2,6,7,8],[2,1,3,1,2,6,7,8])==5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 146,
    "generated_code": "def ascii_value_string(s):\n    return sum(ord(char) for char in s)",
    "assertion_results": [
      {
        "assertion": "assert ascii_value_string(\"python\")==112",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert ascii_value_string(\"Program\")==80",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert ascii_value_string(\"Language\")==76",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 122,
    "generated_code": "def smartNumber(n):\n    def count_prime_factors(num):\n        count = 0\n        d = 2\n        while d * d <= num:\n            while num % d == 0:\n                count += 1\n                num //= d\n            d += 1\n        if num > 1:\n            count += 1\n        return count\n    \n    count = 0\n    num = 2\n    while count < n:\n        if count_prime_factors(num) == 3:\n            count += 1\n            if count == n:\n                return num\n        num += 1\n    \n    return num",
    "assertion_results": [
      {
        "assertion": "assert smartNumber(1) == 30",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert smartNumber(50) == 273",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert smartNumber(1000) == 2664",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 145,
    "generated_code": "def max_Abs_Diff(arr, n):\n    if n < 2:\n        return 0\n    \n    min_val = min(arr)\n    max_val = max(arr)\n    \n    return max_val - min_val",
    "assertion_results": [
      {
        "assertion": "assert max_Abs_Diff((2,1,5,3),4) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_Abs_Diff((9,3,2,5,1),5) == 8",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_Abs_Diff((3,2,1),3) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 110,
    "generated_code": "def extract_missing(ranges, start, end):\n    missing = []\n    \n    # For each range, add gaps before and after\n    for range_start, range_end in ranges:\n        # Gap before the range\n        missing.append((start, range_start))\n        # Gap after the range\n        missing.append((range_end, end))\n    \n    # Add gaps between consecutive ranges\n    for i in range(len(ranges) - 1):\n        current_end = ranges[i][1]\n        next_start = ranges[i + 1][0]\n        missing.append((current_end, next_start))\n    \n    return missing",
    "assertion_results": [
      {
        "assertion": "assert extract_missing([(6, 9), (15, 34), (48, 70)], 2, 100) == [(2, 6), (9, 100), (9, 15), (34, 100), (34, 48), (70, 100)]",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert extract_missing([(7, 2), (15, 19), (38, 50)], 5, 60) == [(5, 7), (2, 60), (2, 15), (19, 60), (19, 38), (50, 60)]",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert extract_missing([(7, 2), (15, 19), (38, 50)], 1, 52) == [(1, 7), (2, 52), (2, 15), (19, 52), (19, 38), (50, 52)]",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 139,
    "generated_code": "import math\n\ndef circle_circumference(radius):\n    return 2 * math.pi * radius",
    "assertion_results": [
      {
        "assertion": "assert circle_circumference(10)==62.830000000000005",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert circle_circumference(5)==31.415000000000003",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert circle_circumference(4)==25.132",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 144,
    "generated_code": "def sum_Pairs(arr, n):\n    total = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total += abs(arr[i] - arr[j])\n    return total",
    "assertion_results": [
      {
        "assertion": "assert sum_Pairs([1,8,9,15,16],5) == 74",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_Pairs([1,2,3,4],4) == 10",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_Pairs([1,2,3,4,5,7,9,11,14],9) == 188",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 151,
    "generated_code": "import math\n\ndef is_coprime(a, b):\n    return math.gcd(a, b) == 1",
    "assertion_results": [
      {
        "assertion": "assert is_coprime(17,13) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_coprime(15,21) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_coprime(25,45) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 138,
    "generated_code": "def is_Sum_Of_Powers_Of_Two(n):\n    if n <= 0:\n        return False\n    \n    # A number can be represented as sum of non-zero powers of 2\n    # if and only if it doesn't have consecutive 1s in its binary representation\n    # This is because consecutive 1s would require using the same power of 2 multiple times\n    \n    binary = bin(n)[2:]  # Convert to binary and remove '0b' prefix\n    \n    # Check for consecutive 1s\n    for i in range(len(binary) - 1):\n        if binary[i] == '1' and binary[i + 1] == '1':\n            return False\n    \n    return True",
    "assertion_results": [
      {
        "assertion": "assert is_Sum_Of_Powers_Of_Two(10) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_Sum_Of_Powers_Of_Two(7) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_Sum_Of_Powers_Of_Two(14) == True",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 140,
    "generated_code": "def extract_singly(tuple_list):\n    from collections import Counter\n    \n    # Flatten all elements from all tuples\n    all_elements = []\n    for tup in tuple_list:\n        all_elements.extend(tup)\n    \n    # Count occurrences of each element\n    element_counts = Counter(all_elements)\n    \n    # Extract elements that occur only once, maintaining order\n    result = []\n    seen = set()\n    \n    for tup in tuple_list:\n        for element in tup:\n            if element_counts[element] == 1 and element not in seen:\n                result.append(element)\n                seen.add(element)\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)]) == [3, 4, 5, 7, 1]",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert extract_singly([(1, 2, 3), (4, 2, 3), (7, 8)]) == [1, 2, 3, 4, 7, 8]",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert extract_singly([(7, 8, 9), (10, 11, 12), (10, 11)]) == [7, 8, 9, 10, 11, 12]",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 154,
    "generated_code": "def specified_element(two_d_list, index):\n    result = []\n    for row in two_d_list:\n        result.append(row[index])\n    return result",
    "assertion_results": [
      {
        "assertion": "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],0)==[1, 4, 7]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],2)==[3, 6, 9]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],3)==[2,2,5]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 149,
    "generated_code": "def longest_subseq_with_diff_one(arr, n):\n    if n == 0:\n        return 0\n    \n    # dp[i] stores the length of longest subsequence ending at index i\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            # Check if current element and previous element differ by 1\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    # Return the maximum length found\n    return max(dp)",
    "assertion_results": [
      {
        "assertion": "assert longest_subseq_with_diff_one([1, 2, 3, 4, 5, 3, 2], 7) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert longest_subseq_with_diff_one([10, 9, 4, 5, 4, 8, 6], 7) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert longest_subseq_with_diff_one([1, 2, 3, 2, 3, 7, 2, 1], 8) == 7",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 141,
    "generated_code": "def pancake_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    arr = arr.copy()\n    \n    def flip(arr, k):\n        arr[:k+1] = arr[:k+1][::-1]\n    \n    def find_max_index(arr, n):\n        max_idx = 0\n        for i in range(1, n):\n            if arr[i] > arr[max_idx]:\n                max_idx = i\n        return max_idx\n    \n    n = len(arr)\n    \n    for curr_size in range(n, 1, -1):\n        max_idx = find_max_index(arr, curr_size)\n        \n        if max_idx != curr_size - 1:\n            if max_idx != 0:\n                flip(arr, max_idx)\n            \n            flip(arr, curr_size - 1)\n    \n    return arr",
    "assertion_results": [
      {
        "assertion": "assert pancake_sort([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert pancake_sort([98, 12, 54, 36, 85]) == [12, 36, 54, 85, 98]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert pancake_sort([41, 42, 32, 12, 23]) == [12, 23, 32, 41, 42]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 152,
    "generated_code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert merge_sort([3, 4, 2, 6, 5, 7, 1, 9]) == [1, 2, 3, 4, 5, 6, 7, 9]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert merge_sort([7, 25, 45, 78, 11, 33, 19]) == [7, 11, 19, 25, 33, 45, 78]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert merge_sort([3, 1, 4, 9, 8]) == [1, 3, 4, 8, 9]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 153,
    "generated_code": "def parabola_vertex(a, b, c):\n    # For a parabola in the form ax^2 + bx + c\n    # The x-coordinate of the vertex is -b/(2a)\n    # The y-coordinate is found by substituting x back into the equation\n    \n    x_vertex = -b / (2 * a)\n    y_vertex = a * (x_vertex ** 2) + b * x_vertex + c\n    \n    return (x_vertex, y_vertex)",
    "assertion_results": [
      {
        "assertion": "assert parabola_vertex(5,3,2)==(-0.3, 1.55)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert parabola_vertex(9,8,4)==(-0.4444444444444444, 2.2222222222222223)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert parabola_vertex(2,4,6)==(-1.0, 4.0)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 163,
    "generated_code": "import math\n\ndef area_polygon(n, s):\n    \"\"\"\n    Calculate the area of a regular polygon.\n    \n    n: number of sides\n    s: side length\n    \"\"\"\n    area = (n * s**2) / (4 * math.tan(math.pi / n))\n    return area",
    "assertion_results": [
      {
        "assertion": "assert area_polygon(4,20)==400.00000000000006",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert area_polygon(10,15)==1731.1969896610804",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert area_polygon(9,7)==302.90938549487214",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 156,
    "generated_code": "def tuple_int_str(tuple_of_tuples):\n    return tuple(tuple(int(value) for value in inner_tuple) for inner_tuple in tuple_of_tuples)",
    "assertion_results": [
      {
        "assertion": "assert tuple_int_str((('333', '33'), ('1416', '55')))==((333, 33), (1416, 55))",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert tuple_int_str((('999', '99'), ('1000', '500')))==((999, 99), (1000, 500))",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert tuple_int_str((('666', '66'), ('1500', '555')))==((666, 66), (1500, 555))",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 161,
    "generated_code": "def remove_elements(original_list, elements_to_remove):\n    result = []\n    for item in original_list:\n        if item not in elements_to_remove:\n            result.append(item)\n    return result",
    "assertion_results": [
      {
        "assertion": "assert remove_elements([1,2,3,4,5,6,7,8,9,10],[2,4,6,8])==[1, 3, 5, 7, 9, 10]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],[1, 3, 5, 7])==[2, 4, 6, 8, 9, 10]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],[5,7])==[1, 2, 3, 4, 6, 8, 9, 10]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 168,
    "generated_code": "def frequency(arr, num):\n    count = 0\n    for element in arr:\n        if element == num:\n            count += 1\n    return count",
    "assertion_results": [
      {
        "assertion": "assert frequency([1,2,3],4) == 0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert frequency([1,2,2,3,3,3,4],3) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert frequency([0,1,2,3,1,2],1) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 167,
    "generated_code": "def next_Power_Of_2(n):\n    if n <= 0:\n        return 1\n    \n    power = 1\n    while power < n:\n        power *= 2\n    \n    return power",
    "assertion_results": [
      {
        "assertion": "assert next_Power_Of_2(0) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert next_Power_Of_2(5) == 8",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert next_Power_Of_2(17) == 32",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 162,
    "generated_code": "def sum_series(n):\n    total = 0\n    current = n\n    while current > 0:\n        total += current\n        current -= 2\n    return total",
    "assertion_results": [
      {
        "assertion": "assert sum_series(6)==12",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_series(10)==30",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_series(9)==25",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 121,
    "generated_code": "Looking at the test cases, I need to understand what the function should do:\n\n- `check_triplet([2, 7, 4, 0, 9, 5, 1, 3], 8, 6, 0)` returns `True`\n- `check_triplet([1, 4, 5, 6, 7, 8, 5, 9], 8, 6, 0)` returns `False`  \n- `check_triplet([10, 4, 2, 3, 5], 5, 15, 0)` returns `True`\n\nFrom the test cases, it appears the function takes an array and three numbers, and needs to check if there's a triplet in the array that matches those three numbers in some way.\n\nLooking at the first test case: array `[2, 7, 4, 0, 9, 5, 1, 3]` with values `8, 6, 0`. The sum is 8+6+0=14. Let me check if there's a triplet that sums to 14: 2+7+5=14, 4+9+1=14, etc.\n\nWait, let me reconsider. Maybe it's checking if the three given numbers exist in the array as a triplet. Let me check:\n- First test: 8, 6, 0 - but 8 and 6 are not in the array `[2, 7, 4, 0, 9, 5, 1, 3]`\n- Third test: 5, 15, 0 - but 15 and 0 are not in the array `[10, 4, 2, 3, 5]`\n\nLet me try another interpretation: maybe it's checking if there's a triplet in the array that sums to the sum of the three given numbers.\n\nFirst test: 8+6+0=14, and in `[2, 7, 4, 0, 9, 5, 1, 3]` we can find 2+7+5=14 \u2713\nSecond test: 8+6+0=14, and in `[1",
    "assertion_results": []
  },
  {
    "task_id": 164,
    "generated_code": "def areEquivalent(num1, num2):\n    def sum_of_divisors(n):\n        divisor_sum = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                divisor_sum += i\n        return divisor_sum\n    \n    return sum_of_divisors(num1) == sum_of_divisors(num2)",
    "assertion_results": [
      {
        "assertion": "assert areEquivalent(36,57) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert areEquivalent(2,4) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert areEquivalent(23,47) == True",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 166,
    "generated_code": "def find_even_Pair(arr, n):\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n    return count",
    "assertion_results": [
      {
        "assertion": "assert find_even_Pair([5,4,7,2,1],5) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_even_Pair([7,2,8,1,0,5,11],7) == 9",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_even_Pair([1,2,3],3) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 157,
    "generated_code": "def encode_list(data):\n    if not data:\n        return []\n    \n    result = []\n    current_element = data[0]\n    count = 1\n    \n    for i in range(1, len(data)):\n        if data[i] == current_element:\n            count += 1\n        else:\n            result.append([count, current_element])\n            current_element = data[i]\n            count = 1\n    \n    # Add the last group\n    result.append([count, current_element])\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert encode_list([1,1,2,3,4,4.3,5,1])==[[2, 1], [1, 2], [1, 3], [1, 4], [1, 4.3], [1, 5], [1, 1]]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert encode_list('automatically')==[[1, 'a'], [1, 'u'], [1, 't'], [1, 'o'], [1, 'm'], [1, 'a'], [1, 't'], [1, 'i'], [1, 'c'], [1, 'a'], [2, 'l'], [1, 'y']]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert encode_list('python')==[[1, 'p'], [1, 'y'], [1, 't'], [1, 'h'], [1, 'o'], [1, 'n']]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 171,
    "generated_code": "def perimeter_pentagon(side_length):\n    return 5 * side_length",
    "assertion_results": [
      {
        "assertion": "assert perimeter_pentagon(5)==25",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert perimeter_pentagon(10)==50",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert perimeter_pentagon(15)==75",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 160,
    "generated_code": "def solution(a, b, n):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    \n    gcd, x, y = extended_gcd(a, b)\n    \n    if n % gcd != 0:\n        return 'No solution'\n    \n    x *= n // gcd\n    y *= n // gcd\n    \n    return ('x = ', x, ', y = ', y)",
    "assertion_results": [
      {
        "assertion": "assert solution(2, 3, 7) == ('x = ', 2, ', y = ', 1)",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert solution(4, 2, 7) == 'No solution'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert solution(1, 13, 17) == ('x = ', 4, ', y = ', 1)",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 165,
    "generated_code": "def count_char_position(s):\n    count = 0\n    for i, char in enumerate(s):\n        # Convert character to lowercase and get its position in alphabet (0-based)\n        char_pos = ord(char.lower()) - ord('a')\n        # Check if character position matches string index\n        if char_pos == i:\n            count += 1\n    return count",
    "assertion_results": [
      {
        "assertion": "assert count_char_position(\"xbcefg\") == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_char_position(\"ABcED\") == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_char_position(\"AbgdeF\") == 5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 170,
    "generated_code": "def sum_range_list(lst, start_index, end_index):\n    return sum(lst[start_index:end_index+1])",
    "assertion_results": [
      {
        "assertion": "assert sum_range_list( [2,1,5,6,8,3,4,9,10,11,8,12],8,10)==29",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_range_list( [2,1,5,6,8,3,4,9,10,11,8,12],5,7)==16",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_range_list( [2,1,5,6,8,3,4,9,10,11,8,12],7,10)==38",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 107,
    "generated_code": "def count_Hexadecimal(start, end):\n    count = 0\n    for num in range(start, end + 1):\n        # Convert number to string and check",
    "assertion_results": []
  },
  {
    "task_id": 169,
    "generated_code": "def get_pell(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Use iterative approach to calculate nth Pell number\n    # Pell sequence: P(n) = 2*P(n-1) + P(n-2)\n    prev_prev = 0  # P(0)\n    prev = 1       # P(1)\n    \n    for i in range(2, n + 1):\n        current = 2 * prev + prev_prev\n        prev_prev = prev\n        prev = current\n    \n    return prev",
    "assertion_results": [
      {
        "assertion": "assert get_pell(4) == 12",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_pell(7) == 169",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_pell(8) == 408",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 172,
    "generated_code": "def count_occurance(s):\n    count = 0\n    for i in range(len(s) - 2):\n        if s[i:i+3] == 'std':\n            count += 1\n    return count",
    "assertion_results": [
      {
        "assertion": "assert count_occurance(\"letstdlenstdporstd\") == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_occurance(\"truststdsolensporsd\") == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_occurance(\"makestdsostdworthit\") == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 173,
    "generated_code": "def remove_splchar(s):\n    return ''.join([char for char in s if char.isalnum()])",
    "assertion_results": [
      {
        "assertion": "assert remove_splchar('python  @#&^%$*program123')==('pythonprogram123')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_splchar('python %^$@!^&*()  programming24%$^^()    language')==('pythonprogramming24language')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_splchar('python   ^%&^()(+_)(_^&67)                  program')==('python67program')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 176,
    "generated_code": "def perimeter_triangle(a, b, c):\n    return a + b + c",
    "assertion_results": [
      {
        "assertion": "assert perimeter_triangle(10,20,30)==60",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert perimeter_triangle(3,4,5)==12",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert perimeter_triangle(25,35,45)==105",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 148,
    "generated_code": "def sum_digits_twoparts(n):\n    def digit_sum(num):\n        return sum(int(digit) for digit in str(num))\n    \n    if n < 10:\n        return digit_sum(n)\n    \n    max_sum = 0\n    \n    # Try all possible splits\n    for i in range(1, n):\n        part1 = i\n        part2 = n - i\n        current_sum = digit_sum(part1) + digit_sum(part2)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum",
    "assertion_results": [
      {
        "assertion": "assert sum_digits_twoparts(35)==17",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_digits_twoparts(7)==7",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_digits_twoparts(100)==19",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 150,
    "generated_code": "def does_Contain_B(a, b, c):\n    if b == 0:\n        return c == a\n    \n    if (c - a) % b != 0:\n        return False\n    \n    n = (c - a) // b\n    return n >= 0",
    "assertion_results": [
      {
        "assertion": "assert does_Contain_B(1,7,3) == True",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert does_Contain_B(1,-3,5) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert does_Contain_B(3,2,5) == False",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 175,
    "generated_code": "def is_valid_parenthese(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        elif char in '({[':\n            stack.append(char)\n    \n    return len(stack) == 0",
    "assertion_results": [
      {
        "assertion": "assert is_valid_parenthese(\"(){}[]\")==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_valid_parenthese(\"()[{)}\")==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_valid_parenthese(\"()\")==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 159,
    "generated_code": "def month_season(month, day):\n    # Define seasons based on months and days\n    if month in ['December', 'January', 'February']:\n        if month == 'December' and day >= 21:\n            return 'winter'\n        elif month in ['January', 'February']:\n            return 'winter'\n        elif month == 'December':\n            return 'autumn'\n    elif month in ['March', 'April', 'May']:\n        if month == 'March' and day >= 20:\n            return 'spring'\n        elif month in ['April', 'May']:\n            return 'spring'\n        elif month == 'March':\n            return 'winter'\n    elif month in ['June', 'July', 'August']:\n        if month == 'June' and day >= 21:\n            return 'summer'\n        elif month in ['July', 'August']:\n            return 'summer'\n        elif month == 'June':\n            return 'spring'\n    elif month in ['September', 'October', 'November']:\n        if month == 'September' and day >= 22:\n            return 'autumn'\n        elif month in ['October', 'November']:\n            return 'autumn'\n        elif month == 'September':\n            return 'summer'",
    "assertion_results": [
      {
        "assertion": "assert month_season('January',4)==('winter')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert month_season('October',28)==('autumn')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert month_season('June',6)==('spring')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 155,
    "generated_code": "def even_bit_toggle_number(n):\n    # Create a mask with all even bits set to 1\n    # Even bits are at positions 0, 2, 4, 6, 8, etc.\n    # In binary: ...10101010 (0xAAAAAAAA for 32-bit)\n    mask = 0\n    bit_position = 0\n    temp = n\n    \n    # Find the highest bit position in the number\n    while temp > 0:\n        temp >>= 1\n        bit_position += 1\n    \n    # Create mask for even positions (0, 2, 4, 6, ...)\n    for i in range(0, bit_position + 1, 2):\n        mask |= (1 << i)\n    \n    # Toggle even bits using XOR with the mask\n    return n ^ mask",
    "assertion_results": [
      {
        "assertion": "assert even_bit_toggle_number(10) == 0",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert even_bit_toggle_number(20) == 30",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert even_bit_toggle_number(30) == 20",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 178,
    "generated_code": "def string_literals(literals, text):\n    for literal in literals:\n        if literal in text:\n            return 'Matched!'\n    return 'Not Matched!'",
    "assertion_results": [
      {
        "assertion": "assert string_literals(['language'],'python language')==('Matched!')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert string_literals(['program'],'python language')==('Not Matched!')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert string_literals(['python'],'programming language')==('Not Matched!')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 136,
    "generated_code": "def cal_electbill(units):\n    if units <= 50:\n        return units * 2.60\n    elif units <= 100:\n        return 50 * 2.60 + (units - 50) * 3.25\n    elif units <= 200:\n        return 50 * 2.60 + 50 * 3.25 + (units - 100) * 5.26\n    else:\n        return 50 * 2.60 + 50 * 3.25 + 100 * 5.26 + (units - 200) * 7.75",
    "assertion_results": [
      {
        "assertion": "assert cal_electbill(75)==246.25",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert cal_electbill(265)==1442.75",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert cal_electbill(100)==327.5",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 174,
    "generated_code": "def group_keyvalue(pairs):\n    result = {}\n    for key, value in pairs:\n        if key in result:\n            result[key].append(value)\n        else:\n            result[key] = [value]\n    return result",
    "assertion_results": [
      {
        "assertion": "assert group_keyvalue([('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)])=={'yellow': [1, 3], 'blue': [2, 4], 'red': [1]}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert group_keyvalue([('python', 1), ('python', 2), ('python', 3), ('python', 4), ('python', 5)])=={'python': [1,2,3,4,5]}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert group_keyvalue([('yellow',100), ('blue', 200), ('yellow', 300), ('blue', 400), ('red', 100)])=={'yellow': [100, 300], 'blue': [200, 400], 'red': [100]}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 184,
    "generated_code": "def greater_specificnum(lst, num):\n    for element in lst:\n        if element > num:\n            return True\n    return False",
    "assertion_results": [
      {
        "assertion": "assert greater_specificnum([220, 330, 500],200)==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert greater_specificnum([12, 17, 21],20)==False",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert greater_specificnum([1,2,3,4],10)==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 191,
    "generated_code": "def check_monthnumber(month):\n    months_with_30_days = [\"April\", \"June\", \"September\", \"November\"]\n    return month in months_with_30_days",
    "assertion_results": [
      {
        "assertion": "assert check_monthnumber(\"February\")==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_monthnumber(\"June\")==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_monthnumber(\"April\")==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 186,
    "generated_code": "import re\n\ndef check_literals(text, literals):\n    for literal in literals:\n        if re.search(re.escape(literal), text):\n            return 'Matched!'\n    return 'Not Matched!'",
    "assertion_results": [
      {
        "assertion": "assert check_literals('The quick brown fox jumps over the lazy dog.',['fox']) == 'Matched!'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_literals('The quick brown fox jumps over the lazy dog.',['horse']) == 'Not Matched!'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_literals('The quick brown fox jumps over the lazy dog.',['lazy']) == 'Matched!'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 182,
    "generated_code": "import re\n\ndef find_character(s):\n    uppercase = re.findall(r'[A-Z]', s)\n    lowercase = re.findall(r'[a-z]', s)\n    digits = re.findall(r'[0-9]', s)\n    special = re.findall(r'[^A-Za-z0-9]', s)\n    \n    return (uppercase, lowercase, digits, special)",
    "assertion_results": [
      {
        "assertion": "assert find_character(\"ThisIsGeeksforGeeks\") == (['T', 'I', 'G', 'G'], ['h', 'i', 's', 's', 'e', 'e', 'k', 's', 'f', 'o', 'r', 'e', 'e', 'k', 's'], [], [])",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_character(\"Hithere2\") == (['H'], ['i', 't', 'h', 'e', 'r', 'e'], ['2'], [])",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_character(\"HeyFolks32\") == (['H', 'F'], ['e', 'y', 'o', 'l', 'k', 's'], ['3', '2'], [])",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 195,
    "generated_code": "def first(arr, target, n):\n    for i in range(n):\n        if arr[i] == target:\n            return i\n    return -1",
    "assertion_results": [
      {
        "assertion": "assert first([1,2,3,4,5,6,6],6,6) == 5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert first([1,2,2,2,3,2,2,4,2],2,9) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert first([1,2,3],1,3) == 0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 134,
    "generated_code": "def check_last(arr, n, p):\n    # Perform left rotation p times\n    # Since rotating by array length brings back to original position\n    effective_rotations = p % len(arr)\n    \n    # Left rotation by effective_rotations\n    rotated_arr = arr[effective_rotations:] + arr[:effective_rotations]\n    \n    last_element = rotated_arr[-1]\n    \n    if last_element % 2 == 0:\n        return \"EVEN\"\n    else:\n        return \"ODD\"",
    "assertion_results": [
      {
        "assertion": "assert check_last([5,7,10],3,1) == \"ODD\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_last([2,3],2,3) == \"EVEN\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_last([1,2,3],3,1) == \"ODD\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 196,
    "generated_code": "def remove_tuples(tuple_list, k):\n    return [t for t in tuple_list if len(t) != k]",
    "assertion_results": [
      {
        "assertion": "assert remove_tuples([(4, 5), (4, ), (8, 6, 7), (1, ), (3, 4, 6, 7)] , 1) == [(4, 5), (8, 6, 7), (3, 4, 6, 7)]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_tuples([(4, 5), (4,5), (6, 7), (1, 2, 3), (3, 4, 6, 7)] ,2) == [(1, 2, 3), (3, 4, 6, 7)]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_tuples([(1, 4, 4), (4, 3), (8, 6, 7), (1, ), (3, 6, 7)] , 3) == [(4, 3), (1,)]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 192,
    "generated_code": "def check_String(s):\n    has_letter = False\n    has_number = False\n    \n    for char in s:\n        if char.isalpha():\n            has_letter = True\n        elif char.isdigit():\n            has_number = True\n        \n        if has_letter and has_number:\n            return True\n    \n    return False",
    "assertion_results": [
      {
        "assertion": "assert check_String('thishasboth29') == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_String('python') == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_String ('string') == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 179,
    "generated_code": "def is_num_keith(n):\n    # Convert number to string to get individual digits\n    digits = [int(d) for d in str(n)]\n    num_digits = len(digits)\n    \n    # Initialize the sequence with the digits\n    sequence = digits[:]\n    \n    # Generate terms until we either find n or exceed it\n    while sequence[-1] < n:\n        # Calculate next term as sum of last num_digits terms\n        next_term = sum(sequence[-num_digits:])\n        sequence.append(next_term)\n    \n    # Check if the last term equals n\n    return sequence[-1] == n",
    "assertion_results": [
      {
        "assertion": "assert is_num_keith(14) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_num_keith(12) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_num_keith(197) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 181,
    "generated_code": "def common_prefix(strings, n):\n    if not strings or n == 0:\n        return ''\n    \n    prefix = ''\n    min_length = min(len(s) for s in strings)\n    \n    for i in range(min_length):\n        char = strings[0][i]\n        if all(s[i] == char for s in strings):\n            prefix += char\n        else:\n            break\n    \n    return prefix",
    "assertion_results": [
      {
        "assertion": "assert common_prefix([\"tablets\", \"tables\", \"taxi\", \"tamarind\"], 4) == 'ta'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert common_prefix([\"apples\", \"ape\", \"april\"], 3) == 'ap'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert common_prefix([\"teens\", \"teenager\", \"teenmar\"], 3) == 'teen'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 183,
    "generated_code": "def count_pairs(arr, n, k):\n    num_set = set(arr)\n    count = 0\n    \n    for num in num_set:\n        if num + k in num_set:\n            count += 1\n    \n    return count",
    "assertion_results": [
      {
        "assertion": "assert count_pairs([1, 5, 3, 4, 2], 5, 3) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_pairs([8, 12, 16, 4, 0, 20], 6, 4) == 5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_pairs([2, 4, 1, 3, 4], 5, 2) == 3",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 189,
    "generated_code": "def first_Missing_Positive(nums, n):\n    # Create a set of positive numbers from the array\n    positive_nums = set(num for num in nums if num > 0)\n    \n    # Find the first missing positive number starting from 1\n    missing = 1\n    while missing in positive_nums:\n        missing += 1\n    \n    return missing",
    "assertion_results": [
      {
        "assertion": "assert first_Missing_Positive([1,2,3,-1,5],5) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert first_Missing_Positive([0,-1,-2,1,5,8],6) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert first_Missing_Positive([0,1,2,5,-8],5) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 197,
    "generated_code": "def find_exponentio(tuple1, tuple2):\n    return tuple(a ** b for a, b in zip(tuple1, tuple2))",
    "assertion_results": [
      {
        "assertion": "assert find_exponentio((10, 4, 5, 6), (5, 6, 7, 5)) == (100000, 4096, 78125, 7776)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_exponentio((11, 5, 6, 7), (6, 7, 8, 6)) == (1771561, 78125, 1679616, 117649)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_exponentio((12, 6, 7, 8), (7, 8, 9, 7)) == (35831808, 1679616, 40353607, 2097152)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 199,
    "generated_code": "def highest_Power_of_2(n):\n    if n <= 0:\n        return 0\n    \n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    \n    return power",
    "assertion_results": [
      {
        "assertion": "assert highest_Power_of_2(10) == 8",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert highest_Power_of_2(19) == 16",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert highest_Power_of_2(32) == 32",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 180,
    "generated_code": "import math\n\ndef distance_lat_long(lat1, lon1, lat2, lon2):\n    # Convert latitude and longitude from degrees to radians\n    lat1_rad = math.radians(lat1)\n    lon1_rad = math.radians(lon1)\n    lat2_rad = math.radians(lat2)\n    lon2_rad = math.radians(lon2)\n    \n    # Haversine formula\n    dlat = lat2_rad - lat1_rad\n    dlon = lon2_rad - lon1_rad\n    \n    a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2\n    c = 2 * math.asin(math.sqrt(a))\n    \n    # Earth's radius in kilometers\n    r = 6371\n    \n    # Calculate the distance\n    distance = r * c * 1000  # Convert to meters\n    \n    return distance",
    "assertion_results": [
      {
        "assertion": "assert distance_lat_long(23.5,67.5,25.5,69.5)==12179.372041317429",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert distance_lat_long(10.5,20.5,30.5,40.5)==6069.397933300514",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert distance_lat_long(10,20,30,40)==6783.751974994595",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 200,
    "generated_code": "def position_max(lst):\n    if not lst:\n        return []\n    \n    max_value = max(lst)\n    positions = []\n    \n    for i in range(len(lst)):\n        if lst[i] == max_value:\n            positions.append(i)\n    \n    return positions",
    "assertion_results": [
      {
        "assertion": "assert position_max([12,33,23,10,67,89,45,667,23,12,11,10,54])==[7]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert position_max([1,2,2,2,4,4,4,5,5,5,5])==[7,8,9,10]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert position_max([2,1,5,6,8,3,4,9,10,11,8,12])==[11]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 201,
    "generated_code": "def chkList(lst):\n    if not lst:\n        return True\n    \n    first_element = lst[0]\n    return all(element == first_element for element in lst)",
    "assertion_results": [
      {
        "assertion": "assert chkList(['one','one','one']) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert chkList(['one','Two','Three']) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert chkList(['bigdata','python','Django']) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 202,
    "generated_code": "def remove_even(s):\n    result = \"\"\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n    return result",
    "assertion_results": [
      {
        "assertion": "assert remove_even(\"python\")==(\"pto\")",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_even(\"program\")==(\"porm\")",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_even(\"language\")==(\"lnug\")",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 193,
    "generated_code": "def remove_tuple(input_tuple):\n    seen = set()\n    result = []\n    for item in input_tuple:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return tuple(result)",
    "assertion_results": [
      {
        "assertion": "assert remove_tuple((1, 3, 5, 2, 3, 5, 1, 1, 3)) == (1, 2, 3, 5)",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_tuple((2, 3, 4, 4, 5, 6, 6, 7, 8, 8)) == (2, 3, 4, 5, 6, 7, 8)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_tuple((11, 12, 13, 11, 11, 12, 14, 13)) == (11, 12, 13, 14)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 204,
    "generated_code": "def count(string, char):\n    return string.count(char)",
    "assertion_results": [
      {
        "assertion": "assert count(\"abcc\",\"c\") == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count(\"ababca\",\"a\") == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count(\"mnmm0pm\",\"m\") == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 194,
    "generated_code": "def octal_To_Decimal(octal_num):\n    decimal_num = 0\n    power = 0\n    \n    while octal_num > 0:\n        digit = octal_num % 10\n        decimal_num += digit * (8 ** power)\n        power += 1\n        octal_num //= 10\n    \n    return decimal_num",
    "assertion_results": [
      {
        "assertion": "assert octal_To_Decimal(25) == 21",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert octal_To_Decimal(30) == 24",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert octal_To_Decimal(40) == 32",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 185,
    "generated_code": "def parabola_focus(a, b, c):\n    # For parabola y = ax\u00b2 + bx + c\n    # Focus x-coordinate: -b/(2a)\n    # Focus y-coordinate: c - (b\u00b2-1)/(4a)\n    \n    x_focus = -b / (2 * a)\n    y_focus = c - (b * b - 1) / (4 * a)\n    \n    return (x_focus, y_focus)",
    "assertion_results": [
      {
        "assertion": "assert parabola_focus(5,3,2)==(-0.3, 1.6)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert parabola_focus(9,8,4)==(-0.4444444444444444, 2.25)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert parabola_focus(2,4,6)==(-1.0, 4.125)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 187,
    "generated_code": "def longest_common_subsequence(X, Y, m, n):\n    # Create a 2D array to store lengths of longest common subsequence\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Fill the dp table using bottom-up approach\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if X[i-1] == Y[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    # The length of LCS is stored in dp[m][n]\n    return dp[m][n]",
    "assertion_results": [
      {
        "assertion": "assert longest_common_subsequence(\"AGGTAB\" , \"GXTXAYB\", 6, 7) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert longest_common_subsequence(\"ABCDGH\" , \"AEDFHR\", 6, 6) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert longest_common_subsequence(\"AXYT\" , \"AYZX\", 4, 4) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 210,
    "generated_code": "import re\n\ndef is_allowed_specific_char(string):\n    pattern = r'^[a-zA-Z0-9]+$'\n    return bool(re.match(pattern, string))",
    "assertion_results": [
      {
        "assertion": "assert is_allowed_specific_char(\"ABCDEFabcdef123450\") == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_allowed_specific_char(\"*&%@#!}{\") == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_allowed_specific_char(\"HELLOhowareyou98765\") == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 203,
    "generated_code": "def hamming_Distance(a, b):\n    # XOR the two numbers to get bits that are different\n    xor_result = a ^ b\n    \n    # Count the number of 1s in the XOR result\n    count = 0\n    while xor_result:\n        count += xor_result & 1\n        xor_result >>= 1\n    \n    return count",
    "assertion_results": [
      {
        "assertion": "assert hamming_Distance(4,8) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert hamming_Distance(2,4) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert hamming_Distance(1,2) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 212,
    "generated_code": "def fourth_Power_Sum(n):\n    return sum(i**4 for i in range(1, n + 1))",
    "assertion_results": [
      {
        "assertion": "assert fourth_Power_Sum(2) == 17",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert fourth_Power_Sum(4) == 354",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert fourth_Power_Sum(6) == 2275",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 206,
    "generated_code": "def concatenate_elements(tup):\n    result = []\n    for i in range(len(tup) - 1):\n        concatenated = tup[i] + tup[i + 1]\n        result.append(concatenated)\n    return tuple(result)",
    "assertion_results": [
      {
        "assertion": "assert concatenate_elements((\"DSP \", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"UTS\")) == ('DSP IS ', 'IS BEST ', 'BEST FOR ', 'FOR ALL ', 'ALL UTS')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert concatenate_elements((\"RES \", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"QESR\")) == ('RES IS ', 'IS BEST ', 'BEST FOR ', 'FOR ALL ', 'ALL QESR')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert concatenate_elements((\"MSAM\", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"SKD\")) == ('MSAMIS ', 'IS BEST ', 'BEST FOR ', 'FOR ALL ', 'ALL SKD')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 213,
    "generated_code": "def concatenate_strings(tuple1, tuple2):\n    return tuple(s1 + s2 for s1, s2 in zip(tuple1, tuple2))",
    "assertion_results": [
      {
        "assertion": "assert concatenate_strings((\"Manjeet\", \"Nikhil\", \"Akshat\"), (\" Singh\", \" Meherwal\", \" Garg\")) == ('Manjeet Singh', 'Nikhil Meherwal', 'Akshat Garg')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert concatenate_strings((\"Shaik\", \"Ayesha\", \"Sanya\"), (\" Dawood\", \" Begum\", \" Singh\")) == ('Shaik Dawood', 'Ayesha Begum', 'Sanya Singh')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert concatenate_strings((\"Harpreet\", \"Priyanka\", \"Muskan\"), (\"Kour\", \" Agarwal\", \"Sethi\")) == ('HarpreetKour', 'Priyanka Agarwal', 'MuskanSethi')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 198,
    "generated_code": "import math\n\ndef largest_triangle(a, b):\n    return (3 * math.sqrt(3) / 4) * a * b",
    "assertion_results": [
      {
        "assertion": "assert largest_triangle(4,2)==10.392304845413264",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert largest_triangle(5,7)==4.639421805988064",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert largest_triangle(9,1)==105.2220865598093",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 217,
    "generated_code": "def first_Repeated_Char(s):\n    seen = set()\n    for char in s:\n        if char in seen:\n            return char\n        seen.add(char)\n    return '\\0'",
    "assertion_results": [
      {
        "assertion": "assert first_Repeated_Char(\"Google\") == \"o\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert first_Repeated_Char(\"data\") == \"a\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert first_Repeated_Char(\"python\") == '\\0'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 208,
    "generated_code": "import re\n\ndef is_decimal(s):\n    pattern = r'^\\d+\\.\\d{2}$'\n    return bool(re.match(pattern, s))",
    "assertion_results": [
      {
        "assertion": "assert is_decimal('123.11') == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_decimal('0.21') == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_decimal('123.1214') == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 209,
    "generated_code": "import heapq\n\ndef heap_replace(heap, item):\n    # Create a copy of the heap to avoid modifying the original\n    heap_copy = heap[:]\n    \n    # Convert to a proper min-heap\n    heapq.heapify(heap_copy)\n    \n    # Replace the smallest element (root) with the new item\n    heapq.heapreplace(heap_copy, item)\n    \n    return heap_copy",
    "assertion_results": [
      {
        "assertion": "assert heap_replace( [25, 44, 68, 21, 39, 23, 89],21)==[21, 25, 23, 44, 39, 68, 89]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert heap_replace([25, 44, 68, 21, 39, 23, 89],110)== [23, 25, 68, 44, 39, 110, 89]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert heap_replace([25, 44, 68, 21, 39, 23, 89],500)==[23, 25, 68, 44, 39, 500, 89]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 221,
    "generated_code": "def first_even(numbers):\n    for num in numbers:\n        if num % 2 == 0:\n            return num\n    return None",
    "assertion_results": [
      {
        "assertion": "assert first_even ([1, 3, 5, 7, 4, 1, 6, 8]) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert first_even([2, 3, 4]) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert first_even([5, 6, 7]) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 177,
    "generated_code": "import math\n\ndef answer(lower, upper):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    def lcm(a, b):\n        return (a * b) // gcd(a, b)\n    \n    # Try the pattern from test cases first: (lower, 2*lower)\n    if 2 * lower <= upper:\n        return (lower, 2 * lower)\n    \n    # If that doesn't work, search for other pairs\n    for a in range(lower, upper + 1):\n        for b in range(a + 1, upper + 1):\n            if lower <= lcm(a, b) <= upper:\n                return (a, b)\n    \n    return None",
    "assertion_results": [
      {
        "assertion": "assert answer(3,8) == (3,6)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert answer(2,6) == (2,4)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert answer(1,3) == (1,2)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 188,
    "generated_code": "import math\n\ndef prod_Square(n):\n    if n <= 0:\n        return False\n    \n    # Check all possible values of a where a\u00b2 \u2264 n\n    for a in range(1, int(math.sqrt(n)) + 1):\n        a_squared = a * a\n        if n % a_squared == 0:\n            remaining = n // a_squared\n            # Check if remaining is a perfect square\n            b = int(math.sqrt(remaining))\n            if b * b == remaining:\n                return True\n    \n    return False",
    "assertion_results": [
      {
        "assertion": "assert prod_Square(25) == False",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert prod_Square(30) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert prod_Square(16) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 219,
    "generated_code": "def extract_min_max(tup, k):\n    sorted_tup = sorted(tup)\n    min_k = sorted_tup[:k]\n    max_k = sorted_tup[-k:]\n    return tuple(min_k + max_k)",
    "assertion_results": [
      {
        "assertion": "assert extract_min_max((5, 20, 3, 7, 6, 8), 2) == (3, 5, 8, 20)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert extract_min_max((4, 5, 6, 1, 2, 7), 3) == (1, 2, 4, 5, 6, 7)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert extract_min_max((2, 3, 4, 8, 9, 11, 7), 4) == (2, 3, 4, 7, 8, 9, 11)",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 223,
    "generated_code": "def is_majority(arr, n, x):\n    # A majority element appears more than n/2 times\n    count = arr.count(x)\n    return count > n // 2",
    "assertion_results": [
      {
        "assertion": "assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_majority([1, 1, 1, 2, 2], 5, 1) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 207,
    "generated_code": "def find_longest_repeating_subseq(s):\n    n = len(s)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if s[i-1] == s[j-1] and i != j:\n                dp[i][j] = 1 + dp[i-1][j-1]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    return dp[n][n]",
    "assertion_results": [
      {
        "assertion": "assert find_longest_repeating_subseq(\"AABEBCDD\") == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_longest_repeating_subseq(\"aabb\") == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_longest_repeating_subseq(\"aab\") == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 220,
    "generated_code": "def replace_max_specialchar(text, n):\n    result = \"\"\n    count = 0\n    \n    for char in text:\n        if count < n and char in [' ', ',', '.']:\n            result += ':'\n            count += 1\n        else:\n            result += char\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert replace_max_specialchar('Python language, Programming language.',2)==('Python:language: Programming language.')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert replace_max_specialchar('a b c,d e f',3)==('a:b:c:d e f')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert replace_max_specialchar('ram reshma,ram rahim',1)==('ram:reshma,ram rahim')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 224,
    "generated_code": "def count_Set_Bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count",
    "assertion_results": [
      {
        "assertion": "assert count_Set_Bits(2) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Set_Bits(4) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Set_Bits(6) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 227,
    "generated_code": "def min_of_three(a, b, c):\n    return min(a, b, c)",
    "assertion_results": [
      {
        "assertion": "assert min_of_three(10,20,0)==0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert min_of_three(19,15,18)==15",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert min_of_three(-10,-20,-30)==-30",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 215,
    "generated_code": "def decode_list(encoded_list):\n    result = []\n    for item in encoded_list:\n        if isinstance(item, list) and len(item) == 2:\n            count, value = item\n            result.extend([value] * count)\n        else:\n            result.append(item)\n    return result",
    "assertion_results": [
      {
        "assertion": "assert decode_list([[2, 1], 2, 3, [2, 4], 5,1])==[1,1,2,3,4,4,5,1]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert decode_list(['a', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', 'a', [2, 'l'], 'y'])==['a', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', 'a', 'l', 'l', 'y']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert decode_list(['p', 'y', 't', 'h', 'o', 'n'])==['p', 'y', 't', 'h', 'o', 'n']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 230,
    "generated_code": "def replace_blank(string, character):\n    return string.replace(' ', character)",
    "assertion_results": [
      {
        "assertion": "assert replace_blank(\"hello people\",'@')==(\"hello@people\")",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert replace_blank(\"python program language\",'$')==(\"python$program$language\")",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert replace_blank(\"blank space\",\"-\")==(\"blank-space\")",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 190,
    "generated_code": "def count_Intgral_Points(x1, y1, x2, y2):\n    # Ensure we have the correct order of coordinates\n    min_x = min(x1, x2)\n    max_x = max(x1, x2)\n    min_y = min(y1, y2)\n    max_y = max(y1, y2)\n    \n    count = 0\n    # Count integral points strictly inside the square\n    for x in range(min_x + 1, max_x):\n        for y in range(min_y + 1, max_y):\n            count += 1\n    \n    return count",
    "assertion_results": [
      {
        "assertion": "assert count_Intgral_Points(1,1,4,4) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Intgral_Points(1,2,1,2) == 1",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Intgral_Points(4,2,6,4) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 205,
    "generated_code": "def inversion_elements(tup):\n    return tuple(-(x + 1) for x in tup)",
    "assertion_results": [
      {
        "assertion": "assert inversion_elements((7, 8, 9, 1, 10, 7)) == (-8, -9, -10, -2, -11, -8)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert inversion_elements((2, 4, 5, 6, 1, 7)) == (-3, -5, -6, -7, -2, -8)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert inversion_elements((8, 9, 11, 14, 12, 13)) == (-9, -10, -12, -15, -13, -14)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 226,
    "generated_code": "def odd_values_string(s):\n    result = \"\"\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n    return result",
    "assertion_results": [
      {
        "assertion": "assert odd_values_string('abcdef') == 'ace'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert odd_values_string('python') == 'pto'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert odd_values_string('data') == 'dt'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 233,
    "generated_code": "import math\n\ndef lateralsuface_cylinder(radius, height):\n    return 2 * math.pi * radius * height",
    "assertion_results": [
      {
        "assertion": "assert lateralsuface_cylinder(10,5)==314.15000000000003",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert lateralsuface_cylinder(4,5)==125.66000000000001",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert lateralsuface_cylinder(4,10)==251.32000000000002",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 232,
    "generated_code": "def larg_nnum(dataset, n):\n    sorted_dataset = sorted(dataset, reverse=True)\n    return sorted_dataset[:n]",
    "assertion_results": [
      {
        "assertion": "assert larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],2)==[100,90]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],5)==[100,90,80,70,60]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],3)==[100,90,80]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 222,
    "generated_code": "def check_type(tuple_input):\n    if len(tuple_input) == 0:\n        return True\n    \n    first_type = type(tuple_input[0])\n    \n    for element in tuple_input:\n        if type(element) != first_type:\n            return False\n    \n    return True",
    "assertion_results": [
      {
        "assertion": "assert check_type((5, 6, 7, 3, 5, 6) ) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_type((1, 2, \"4\") ) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_type((3, 2, 1, 4, 5) ) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 158,
    "generated_code": "def min_Ops(arr, n, k):\n    # Check if all elements are already equal\n    if len(set(arr)) == 1:\n        return 0\n    \n    # Find all possible target values\n    # Each element can reach values of the form: arr[i] + m*k for integer m\n    # We need to find a common value that all elements can reach\n    \n    min_ops = float('inf')\n    found_solution = False\n    \n    # Try different target values\n    # The target must be reachable from all elements with steps of size k\n    min_val = min(arr)\n    max_val = max(arr)\n    \n    # Check a reasonable range around the array values\n    for target in range(min_val - 100*k, max_val + 100*k + 1, k):\n        operations = 0\n        valid = True\n        \n        for val in arr:\n            diff = abs(target - val)\n            if diff % k != 0:\n                valid = False\n                break\n            operations += diff // k\n        \n        if valid:",
    "assertion_results": []
  },
  {
    "task_id": 228,
    "generated_code": "def all_Bits_Set_In_The_Given_Range(n, l, r):\n    # Create a mask with bits set from position l to r\n    mask = ((1 << (r - l + 1)) - 1) << (l - 1)\n    \n    # Check if all bits in the range are set in n\n    return (n & mask) == mask",
    "assertion_results": [
      {
        "assertion": "assert all_Bits_Set_In_The_Given_Range(4,1,2) == True",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert all_Bits_Set_In_The_Given_Range(17,2,4) == True",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert all_Bits_Set_In_The_Given_Range(39,4,6) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 240,
    "generated_code": "def replace_list(list1, list2):\n    return list1[:-1] + list2",
    "assertion_results": [
      {
        "assertion": "assert replace_list([1, 3, 5, 7, 9, 10],[2, 4, 6, 8])==[1, 3, 5, 7, 9, 2, 4, 6, 8]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert replace_list([1,2,3,4,5],[5,6,7,8])==[1,2,3,4,5,6,7,8]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert replace_list([\"red\",\"blue\",\"green\"],[\"yellow\"])==[\"red\",\"blue\",\"yellow\"]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 147,
    "generated_code": "def max_path_sum(triangle, rows, cols):\n    # Create a copy to avoid modifying the original\n    dp = [row[:] for row in triangle]\n    \n    # Start from the second row and work downwards\n    for i in range(1, rows):\n        for j in range(i + 1):  # Each row i has i+1 elements\n            # For each position, take the maximum from the two possible previous positions\n            if j == 0:\n                # Leftmost element can only come from position 0 of previous row\n                dp[i][j] = triangle[i][j] + dp[i-1][0]\n            elif j == i:\n                # Rightmost element can only come from position j-1 of previous row\n                dp[i][j] = triangle[i][j] + dp[",
    "assertion_results": []
  },
  {
    "task_id": 238,
    "generated_code": "def number_of_substrings(s):\n    n = len(s)\n    return n * (n + 1) // 2",
    "assertion_results": [
      {
        "assertion": "assert number_of_substrings(\"abc\") == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert number_of_substrings(\"abcd\") == 10",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert number_of_substrings(\"abcde\") == 15",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 241,
    "generated_code": "def array_3d(x, y, z):\n    return [[['*' for _ in range(x)] for _ in range(y)] for _ in range(z)]",
    "assertion_results": [
      {
        "assertion": "assert array_3d(6,4,3)==[[['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*']]]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert array_3d(5,3,4)==[[['*', '*', '*', '*', '*'], ['*', '*', '*', '*','*'], ['*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*'],['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*']]]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert array_3d(1,2,3)==[[['*'],['*']],[['*'],['*']],[['*'],['*']]]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 229,
    "generated_code": "def re_arrange_array(arr, n):\n    # Create two lists to store negative and positive elements\n    negatives = []\n    positives = []\n    \n    # Separate negative and positive elements\n    for num in arr:\n        if num < 0:\n            negatives.append(num)\n        else:\n            positives.append(num)\n    \n    # Combine negatives first, then positives\n    return negatives + positives",
    "assertion_results": [
      {
        "assertion": "assert re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert re_arrange_array([12, -14, -26, 13, 15], 5) == [-14, -26, 12, 13, 15]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert re_arrange_array([10, 24, 36, -42, -39, -78, 85], 7) == [-42, -39, -78, 10, 24, 36, 85]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 216,
    "generated_code": "def check_subset_list(main_list, subset_list):\n    def flatten_list(lst):\n        flattened = []\n        for item in lst:\n            if isinstance(item, list):\n                flattened.extend(flatten_list(item))\n            else:\n                flattened.append(item)\n        return flattened\n    \n    # For nested lists, check if each sublist in subset_list exists in main_list\n    if all(isinstance(item, list) for item in subset_list):\n        for sublist in subset_list:\n            if sublist not in main_list:\n                return False\n        return True\n    \n    # For flat list vs nested list comparison\n    if not all(isinstance(item, list) for item in main_list):\n        main_flat = set(flatten_list(main_list))\n        subset_flat = set(flatten_list(subset_list))\n        return subset_flat.issubset(main_flat)\n    \n    return False",
    "assertion_results": [
      {
        "assertion": "assert check_subset_list([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],[[12, 18, 23, 25, 45], [7, 11, 19, 24, 28], [1, 5, 8, 18, 15, 16]])==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_subset_list([[2, 3, 1], [4, 5], [6, 8]],[[4, 5], [6, 8]])==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_subset_list([['a', 'b'], ['e'], ['c', 'd']],[['g']])==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 248,
    "generated_code": "def harmonic_sum(n):\n    result = 0\n    for i in range(1, n):\n        result += 1 / i\n    return result",
    "assertion_results": [
      {
        "assertion": "assert harmonic_sum(7) == 2.5928571428571425",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert harmonic_sum(4) == 2.083333333333333",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert harmonic_sum(19) == 3.547739657143682",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 249,
    "generated_code": "def intersection_array(arr1, arr2):\n    return list(filter(lambda x: x in arr2, arr1))",
    "assertion_results": [
      {
        "assertion": "assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[1, 2, 4, 8, 9])==[1, 2, 8, 9]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[3,5,7,9])==[3,5,7,9]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[10,20,30,40])==[10]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 225,
    "generated_code": "def find_Min(arr, low, high):\n    # If array is not rotated, first element is minimum\n    if high < low:\n        return arr[0]\n    \n    # If there is only one element\n    if high == low:\n        return arr[low]\n    \n    # Find middle point\n    mid = low + (high - low) // 2\n    \n    # Check if element at mid+1 is minimum element\n    if mid < high and arr[mid + 1] < arr[mid]:\n        return arr[mid + 1]\n    \n    # Check if mid itself is minimum element\n    if mid > low and arr[mid] < arr[mid - 1]:\n        return arr[mid]\n    \n    # Decide whether we need to go to left half or right half\n    if arr[high] > arr[mid]:\n        return find_Min(arr, low, mid - 1)\n    return find_Min(arr, mid + 1, high)",
    "assertion_results": [
      {
        "assertion": "assert find_Min([1,2,3,4,5],0,4) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_Min([4,6,8],0,2) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_Min([2,3,5,7,9],0,4) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 242,
    "generated_code": "def count_charac(string):\n    return len(string)",
    "assertion_results": [
      {
        "assertion": "assert count_charac(\"python programming\")==18",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_charac(\"language\")==8",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_charac(\"words\")==5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 251,
    "generated_code": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result",
    "assertion_results": [
      {
        "assertion": "assert insert_element(['Red', 'Green', 'Black'] ,'c')==['c', 'Red', 'c', 'Green', 'c', 'Black'] ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert insert_element(['python', 'java'] ,'program')==['program', 'python', 'program', 'java'] ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert insert_element(['happy', 'sad'] ,'laugh')==['laugh', 'happy', 'laugh', 'sad'] ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 250,
    "generated_code": "def count_X(tuple_data, element):\n    return tuple_data.count(element)",
    "assertion_results": [
      {
        "assertion": "assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),4) == 0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),10) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),8) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 231,
    "generated_code": "def max_sum(triangle, n):\n    # Create a copy of the triangle to avoid modifying the original\n    dp = [row[:] for row in triangle]\n    \n    # Start from the second-to-last row and work upwards\n    for i in range(n - 2, -1, -1):\n        for j in range(len(dp[i])):\n            # For each position, add the maximum of the two possible paths below\n            dp[i][j] += max(dp[i + 1][j], dp[i + 1][j + 1])\n    \n    # The top element now contains the maximum sum\n    return dp[0][0]",
    "assertion_results": [
      {
        "assertion": "assert max_sum([[1], [2,1], [3,3,2]], 3) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_sum([[1], [1, 2], [4, 1, 12]], 3) == 15 ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_sum([[2], [3,2], [13,23,12]], 3) == 28",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 246,
    "generated_code": "def babylonian_squareroot(n):\n    if n == 0:\n        return 0\n    \n    x = n\n    while True:\n        root = 0.5 * (x + n / x)\n        if abs(root - x) < 1e-15:\n            break\n        x = root\n    \n    return root",
    "assertion_results": [
      {
        "assertion": "assert babylonian_squareroot(10)==3.162277660168379",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert babylonian_squareroot(2)==1.414213562373095",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert babylonian_squareroot(9)==3.0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 214,
    "generated_code": "import math\n\ndef degree_radian(degrees):\n    return degrees * (180 / math.pi)",
    "assertion_results": [
      {
        "assertion": "assert degree_radian(90)==5156.620156177409",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert degree_radian(60)==3437.746770784939",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert degree_radian(120)==6875.493541569878",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 255,
    "generated_code": "from itertools import combinations_with_replacement\n\ndef combinations_colors(colors, n):\n    return list(combinations_with_replacement(colors, n))",
    "assertion_results": [
      {
        "assertion": "assert combinations_colors( [\"Red\",\"Green\",\"Blue\"],1)==[('Red',), ('Green',), ('Blue',)]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert combinations_colors( [\"Red\",\"Green\",\"Blue\"],2)==[('Red', 'Red'), ('Red', 'Green'), ('Red', 'Blue'), ('Green', 'Green'), ('Green', 'Blue'), ('Blue', 'Blue')]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert combinations_colors( [\"Red\",\"Green\",\"Blue\"],3)==[('Red', 'Red', 'Red'), ('Red', 'Red', 'Green'), ('Red', 'Red', 'Blue'), ('Red', 'Green', 'Green'), ('Red', 'Green', 'Blue'), ('Red', 'Blue', 'Blue'), ('Green', 'Green', 'Green'), ('Green', 'Green', 'Blue'), ('Green', 'Blue', 'Blue'), ('Blue', 'Blue', 'Blue')]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 239,
    "generated_code": "def get_total_number_of_sequences(m, n):\n    def count_sequences(length, last_element):\n        if length == 1:\n            return 1\n        \n        count = 0\n        # Next element must be >= 2 * last_element and <= m\n        min_next = 2 * last_element\n        for next_element in range(min_next, m + 1):\n            count += count_sequences(length - 1, next_element)\n        \n        return count\n    \n    total = 0\n    # Try all possible starting elements from 1 to m\n    for start in range(1, m + 1):\n        total += count_sequences(n, start)\n    \n    return total",
    "assertion_results": [
      {
        "assertion": "assert get_total_number_of_sequences(10, 4) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_total_number_of_sequences(5, 2) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_total_number_of_sequences(16, 3) == 84",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 253,
    "generated_code": "def count_integer(lst):\n    count = 0\n    for item in lst:\n        if isinstance(item, int) and not isinstance(item, bool):\n            count += 1\n    return count",
    "assertion_results": [
      {
        "assertion": "assert count_integer([1,2,'abc',1.2]) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_integer([1,2,3]) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_integer([1,1.2,4,5.1]) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 252,
    "generated_code": "import cmath\n\ndef convert(z):\n    # Convert to complex number if it's not already\n    if not isinstance(z, complex):\n        z = complex(z)\n    \n    # Calculate magnitude (radius)\n    magnitude = abs(z)\n    \n    # Calculate phase (angle) in radians\n    phase = cmath.phase(z)\n    \n    return (magnitude, phase)",
    "assertion_results": [
      {
        "assertion": "assert convert(1) == (1.0, 0.0)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert convert(4) == (4.0,0.0)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert convert(5) == (5.0,0.0)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 258,
    "generated_code": "def count_odd(lst):\n    return len(list(filter(lambda x: x % 2 != 0, lst)))",
    "assertion_results": [
      {
        "assertion": "assert count_odd([1, 2, 3, 5, 7, 8, 10])==4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_odd([10,15,14,13,-18,12,-20])==2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_odd([1, 2, 4, 8, 9])==2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 247,
    "generated_code": "def lps(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    \n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Check for palindromes of length 2 and more\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            \n            if s[i] == s[j]:\n                if length == 2:\n                    dp[i][j] = 2\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    \n    return dp[0][n - 1]",
    "assertion_results": [
      {
        "assertion": "assert lps(\"TENS FOR TENS\") == 5 ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert lps(\"CARDIO FOR CARDS\") == 7",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert lps(\"PART OF THE JOURNEY IS PART\") == 9 ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 254,
    "generated_code": "def words_ae(text):\n    words = text.split()\n    result = []\n    \n    for word in words:\n        if word.startswith('a') or word.startswith('e'):\n            result.append(word)\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert words_ae(\"python programe\")==['ame']",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert words_ae(\"python programe language\")==['ame','anguage']",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert words_ae(\"assert statement\")==['assert', 'atement']",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 218,
    "generated_code": "from collections import deque\n\ndef min_Operations(a, b):\n    if a == b:\n        return 0\n    \n    visited = set()\n    queue = deque([(a, 0)])\n    visited.add(a)\n    \n    while queue:\n        current, operations = queue.popleft()\n        \n        # Generate next possible numbers\n        next_numbers = []\n        \n        # Multiply by 2\n        next_numbers.append(current * 2)\n        \n        # Divide by 2 (if even)\n        if current % 2 == 0:\n            next_numbers.append(current // 2)\n        \n        for next_num in next_numbers:\n            if next_num == b:\n                return operations + 1\n            \n            if next_num not in visited and next_num > 0 and next_num <= 1000:  # reasonable bounds\n                visited.add(next_num)\n                queue.append((next_num, operations + 1))\n    \n    return -1  # Should not reach here for valid inputs",
    "assertion_results": [
      {
        "assertion": "assert min_Operations(2,4) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert min_Operations(4,10) == 4",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert min_Operations(1,4) == 3",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 257,
    "generated_code": "def swap_numbers(a, b):\n    return (b, a)",
    "assertion_results": [
      {
        "assertion": "assert swap_numbers(10,20)==(20,10)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert swap_numbers(15,17)==(17,15)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert swap_numbers(100,200)==(200,100)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 263,
    "generated_code": "def merge_dict(dict1, dict2):\n    result = {}\n    result.update(dict2)\n    result.update(dict1)\n    return result",
    "assertion_results": [
      {
        "assertion": "assert merge_dict({'a': 100, 'b': 200},{'x': 300, 'y': 200})=={'x': 300, 'y': 200, 'a': 100, 'b': 200}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert merge_dict({'a':900,'b':900,'d':900},{'a':900,'b':900,'d':900})=={'a':900,'b':900,'d':900,'a':900,'b':900,'d':900}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert merge_dict({'a':10,'b':20},{'x':30,'y':40})=={'x':30,'y':40,'a':10,'b':20}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 261,
    "generated_code": "def division_elements(tuple1, tuple2):\n    return tuple(a // b for a, b in zip(tuple1, tuple2))",
    "assertion_results": [
      {
        "assertion": "assert division_elements((10, 4, 6, 9),(5, 2, 3, 3)) == (2, 2, 2, 3)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert division_elements((12, 6, 8, 16),(6, 3, 4, 4)) == (2, 2, 2, 4)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert division_elements((20, 14, 36, 18),(5, 7, 6, 9)) == (4, 2, 6, 2)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 262,
    "generated_code": "def split_two_parts(lst, n):\n    return (lst[:n], lst[n:])",
    "assertion_results": [
      {
        "assertion": "assert split_two_parts([1,1,2,3,4,4,5,1],3)==([1, 1, 2], [3, 4, 4, 5, 1])",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert split_two_parts(['a', 'b', 'c', 'd'],2)==(['a', 'b'], ['c', 'd'])",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert split_two_parts(['p', 'y', 't', 'h', 'o', 'n'],4)==(['p', 'y', 't', 'h'], ['o', 'n'])",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 265,
    "generated_code": "def list_split(lst, n):\n    result = []\n    for i in range(n):\n        sublist = []\n        for j in range(i, len(lst), n):\n            sublist.append(lst[j])\n        result.append(sublist)\n    return result",
    "assertion_results": [
      {
        "assertion": "assert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'],3)==[['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']] ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert list_split([1,2,3,4,5,6,7,8,9,10,11,12,13,14],3)==[[1,4,7,10,13], [2,5,8,11,14], [3,6,9,12]] ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert list_split(['python','java','C','C++','DBMS','SQL'],2)==[['python', 'C', 'DBMS'], ['java', 'C++', 'SQL']] ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 269,
    "generated_code": "def ascii_value(char):\n    return ord(char)",
    "assertion_results": [
      {
        "assertion": "assert ascii_value('A')==65",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert ascii_value('R')==82",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert ascii_value('S')==83",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 266,
    "generated_code": "def lateralsurface_cube(side):\n    return 4 * side * side",
    "assertion_results": [
      {
        "assertion": "assert lateralsurface_cube(5)==100",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert lateralsurface_cube(9)==324",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert lateralsurface_cube(10)==400",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 268,
    "generated_code": "def find_star_num(n):\n    return n * (6 * n - 6) + 1",
    "assertion_results": [
      {
        "assertion": "assert find_star_num(3) == 37",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_star_num(4) == 73",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_star_num(5) == 121",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 264,
    "generated_code": "def dog_age(human_age):\n    if human_age <= 2:\n        return human_age * 10.5\n    else:\n        return 21 + (human_age - 2) * 4",
    "assertion_results": [
      {
        "assertion": "assert dog_age(12)==61",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert dog_age(15)==73",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert dog_age(24)==109",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 243,
    "generated_code": "def sort_on_occurence(lst):\n    from collections import Counter\n    \n    # Count occurrences of first elements\n    first_elements = [item[0] for item in lst]\n    counts = Counter(first_elements)\n    \n    # Group items by first element\n    groups = {}\n    for item in lst:\n        first_elem = item[0]\n        if first_elem not in groups:\n            groups[first_elem] = []\n        groups[first_elem].append(item[1])\n    \n    # Create result list\n    result = []\n    for first_elem, second_elems in groups.items():\n        count = counts[first_elem]\n        # Create tuple: (first_element, *second_elements, count)\n        new_tuple = (first_elem,) + tuple(second_elems) + (count,)\n        result.append(new_tuple)\n    \n    # Sort by count in descending order\n    result.sort(key=lambda x: x[-1], reverse=True)\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert sort_on_occurence([(1, 'Jake'), (2, 'Bob'), (1, 'Cara')]) == [(1, 'Jake', 'Cara', 2), (2, 'Bob', 1)]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sort_on_occurence([('b', 'ball'), ('a', 'arm'), ('b', 'b'), ('a', 'ant')]) == [('b', 'ball', 'b', 2), ('a', 'arm', 'ant', 2)]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sort_on_occurence([(2, 'Mark'), (3, 'Maze'), (2, 'Sara')]) == [(2, 'Mark', 'Sara', 2), (3, 'Maze', 1)]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 235,
    "generated_code": "def even_bit_set_number(n):\n    # Create a mask with all even bits set (0, 2, 4, 6, ...)\n    # In binary: ...10101010\n    mask = 0xAAAAAAAA  # This covers 32 bits, adjust if needed for larger numbers\n    \n    # For the given number, we need to ensure the mask doesn't exceed the bit length\n    # Find the highest bit position in n\n    if n == 0:\n        return 0\n    \n    # Create appropriate mask based on the number's bit length\n    bit_length = n.bit_length()\n    # Create mask with even positions set up to the required bit length\n    even_mask = 0\n    for i in range(0, bit_length + 1, 2):  # Even positions: 0, 2, 4, 6, ...\n        even_mask |= (1 << i)\n    \n    # Set all even bits by OR-ing with the mask\n    return n | even_mask",
    "assertion_results": [
      {
        "assertion": "assert even_bit_set_number(10) == 10",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert even_bit_set_number(20) == 30",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert even_bit_set_number(30) == 30",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 267,
    "generated_code": "def square_Sum(n):\n    total = 0\n    for i in range(n):\n        odd_number = 2 * i + 1\n        total += odd_number ** 2\n    return total",
    "assertion_results": [
      {
        "assertion": "assert square_Sum(2) == 10",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert square_Sum(3) == 35",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert square_Sum(4) == 84",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 271,
    "generated_code": "def even_Power_Sum(n):\n    return sum((2 * i) ** 5 for i in range(1, n + 1))",
    "assertion_results": [
      {
        "assertion": "assert even_Power_Sum(2) == 1056",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert even_Power_Sum(3) == 8832",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert even_Power_Sum(1) == 32",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 259,
    "generated_code": "def maximize_elements(tuple1, tuple2):\n    result = []\n    for i in range(len(tuple1)):\n        max_first = max(tuple1[i][0], tuple2[i][0])\n        max_second = max(tuple1[i][1], tuple2[i][1])\n        result.append((max_first, max_second))\n    return tuple(result)",
    "assertion_results": [
      {
        "assertion": "assert maximize_elements(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((6, 7), (4, 9), (2, 9), (7, 10))",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert maximize_elements(((2, 4), (5, 6), (3, 10), (2, 11)), ((7, 8), (4, 10), (2, 2), (8, 4))) == ((7, 8), (5, 10), (3, 10), (8, 11))",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert maximize_elements(((3, 5), (6, 7), (4, 11), (3, 12)), ((8, 9), (5, 11), (3, 3), (9, 5))) == ((8, 9), (6, 11), (4, 11), (9, 12))",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 273,
    "generated_code": "def substract_elements(tuple1, tuple2):\n    return tuple(a - b for a, b in zip(tuple1, tuple2))",
    "assertion_results": [
      {
        "assertion": "assert substract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert substract_elements((11, 2, 3), (24, 45 ,16)) == (-13, -43, -13)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert substract_elements((7, 18, 9), (10, 11, 12)) == (-3, 7, -3)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 270,
    "generated_code": "def sum_even_and_even_index(lst, n):\n    total = 0\n    for i in range(0, n, 2):  # iterate through even indices (0, 2, 4, ...)\n        if lst[i] % 2 == 0:   # check if the number at even index is even\n            total += lst[i]\n    return total",
    "assertion_results": [
      {
        "assertion": "assert sum_even_and_even_index([5, 6, 12, 1, 18, 8],6) == 30",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_even_and_even_index([3, 20, 17, 9, 2, 10, 18, 13, 6, 18],10) == 26",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_even_and_even_index([5, 6, 12, 1],4) == 12",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 276,
    "generated_code": "import math\n\ndef volume_cylinder(radius, height):\n    return math.pi * radius ** 2 * height",
    "assertion_results": [
      {
        "assertion": "assert volume_cylinder(10,5)==1570.7500000000002",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert volume_cylinder(4,5)==251.32000000000002",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert volume_cylinder(4,10)==502.64000000000004",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 260,
    "generated_code": "def newman_prime(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num**0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n    \n    def newman_shanks_williams(k):\n        if k == 0:\n            return 1\n        if k == 1:\n            return 1\n        \n        # Use iterative approach to avoid recursion depth issues\n        a, b = 1, 1\n        for i in range(2, k + 1):\n            a, b = b, 2 * b + a\n        return b\n    \n    count = 0\n    k = 1\n    \n    while count < n:\n        nsw_num = newman_shanks_williams(k)\n        if is_prime(nsw_num):\n            count += 1\n            if count == n:\n                return nsw_num\n        k += 1\n    \n    return -1",
    "assertion_results": [
      {
        "assertion": "assert newman_prime(3) == 7 ",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert newman_prime(4) == 17",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert newman_prime(5) == 41",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 256,
    "generated_code": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Create a boolean array \"prime[0..n-1]\" and initialize\n    # all entries as true. A value in prime[i] will\n    # finally be false if i is Not a prime, else true.\n    prime = [True] * n\n    prime[0] = prime[1] = False  # 0 and 1 are not prime numbers\n    \n    p = 2\n    while p * p < n:\n        # If prime[p] is not changed, then it is a prime\n        if prime[p]:\n            # Update all multiples of p\n            for i in range(p * p, n, p):\n                prime[i] = False\n        p += 1\n    \n    # Count prime numbers\n    count = sum(prime)\n    return count",
    "assertion_results": [
      {
        "assertion": "assert count_Primes_nums(5) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Primes_nums(10) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Primes_nums(100) == 25",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 277,
    "generated_code": "def dict_filter(dictionary, threshold):\n    return {key: value for key, value in dictionary.items() if value >= threshold}",
    "assertion_results": [
      {
        "assertion": "assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},170)=={'Cierra Vega': 175, 'Alden Cantrell': 180, 'Pierre Cox': 190}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},180)=={ 'Alden Cantrell': 180, 'Pierre Cox': 190}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},190)=={ 'Pierre Cox': 190}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 274,
    "generated_code": "def even_binomial_Coeff_Sum(n):\n    # Sum of even index binomial coefficients C(n,0) + C(n,2) + C(n,4) + ...\n    # This equals 2^(n-1) for n > 0\n    if n == 0:\n        return 1\n    return 2 ** (n - 1)",
    "assertion_results": [
      {
        "assertion": "assert even_binomial_Coeff_Sum(4) == 8",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert even_binomial_Coeff_Sum(6) == 32",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert even_binomial_Coeff_Sum(2) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 237,
    "generated_code": "def check_occurences(tuples_list):\n    count_dict = {}\n    \n    for tuple_item in tuples_list:\n        # Sort the tuple to create a canonical form\n        sorted_tuple = tuple(sorted(tuple_item))\n        \n        # Count occurrences\n        if sorted_tuple in count_dict:\n            count_dict[sorted_tuple] += 1\n        else:\n            count_dict[sorted_tuple] = 1\n    \n    return count_dict",
    "assertion_results": [
      {
        "assertion": "assert check_occurences([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)] ) == {(1, 3): 2, (2, 5): 2, (3, 6): 1}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_occurences([(4, 2), (2, 4), (3, 6), (6, 3), (7, 4)] ) == {(2, 4): 2, (3, 6): 2, (4, 7): 1}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_occurences([(13, 2), (11, 23), (12, 25), (25, 12), (16, 23)] ) == {(2, 13): 1, (11, 23): 1, (12, 25): 2, (16, 23): 1}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 282,
    "generated_code": "def sub_list(list1, list2):\n    return list(map(lambda x, y: x - y, list1, list2))",
    "assertion_results": [
      {
        "assertion": "assert sub_list([1, 2, 3],[4,5,6])==[-3,-3,-3]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sub_list([1,2],[3,4])==[-2,-2]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sub_list([90,120],[50,70])==[40,50]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 279,
    "generated_code": "def is_num_decagonal(n):\n    return n * (4 * n - 3)",
    "assertion_results": [
      {
        "assertion": "assert is_num_decagonal(3) == 27",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_num_decagonal(7) == 175",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_num_decagonal(10) == 370",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 280,
    "generated_code": "def sequential_search(arr, target):\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return (True, i)\n    return (False, -1)",
    "assertion_results": [
      {
        "assertion": "assert sequential_search([11,23,58,31,56,77,43,12,65,19],31) == (True, 3)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sequential_search([12, 32, 45, 62, 35, 47, 44, 61],61) == (True, 7)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sequential_search([9, 10, 17, 19, 22, 39, 48, 56],48) == (True, 6)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 245,
    "generated_code": "def max_sum(arr, n):\n    # Create arrays to store maximum sum ending at each position\n    # for increasing and decreasing subsequences\n    inc = [0] * n\n    dec = [0] * n\n    \n    # Initialize with array elements\n    for i in range(n):\n        inc[i] = arr[i]\n        dec[i] = arr[i]\n    \n    # Fill inc[] array for increasing subsequence\n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    \n    # Fill dec[] array for decreasing subsequence (from right to left)\n    for i in range(n-2, -1, -1):\n        for j in range(i+1, n):\n            if arr[j] < arr[i]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    \n    # Find maximum sum by combining increasing and decreasing subsequences\n    max_sum_val = 0\n    for i in range(n):\n        max_sum_val = max(max_sum_val, inc[i] + dec[i] - arr[i])\n    \n    return max_sum_val",
    "assertion_results": [
      {
        "assertion": "assert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9], 9) == 194",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_sum([80, 60, 30, 40, 20, 10], 6) == 210",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_sum([2, 3 ,14, 16, 21, 23, 29, 30], 8) == 138",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 281,
    "generated_code": "def all_unique(lst):\n    return len(lst) == len(set(lst))",
    "assertion_results": [
      {
        "assertion": "assert all_unique([1,2,3]) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert all_unique([1,2,1,2]) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert all_unique([1,2,3,4,5]) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 272,
    "generated_code": "def rear_extract(tuples_list):\n    return [tuple_item[-1] for tuple_item in tuples_list]",
    "assertion_results": [
      {
        "assertion": "assert rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert rear_extract([(1, 'Sai', 36), (2, 'Ayesha', 25), (3, 'Salman', 45)]) == [36, 25, 45]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert rear_extract([(1, 'Sudeep', 14), (2, 'Vandana', 36), (3, 'Dawood', 56)]) == [14, 36, 56]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 284,
    "generated_code": "def check_element(lst, target):\n    for item in lst:\n        if item != target:\n            return False\n    return True",
    "assertion_results": [
      {
        "assertion": "assert check_element([\"green\", \"orange\", \"black\", \"white\"],'blue')==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_element([1,2,3,4],7)==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_element([\"green\", \"green\", \"green\", \"green\"],'green')==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 278,
    "generated_code": "def count_first_elements(tuple_input):\n    count = 0\n    for element in tuple_input:\n        if isinstance(element, tuple):\n            break\n        count += 1\n    return count",
    "assertion_results": [
      {
        "assertion": "assert count_first_elements((1, 5, 7, (4, 6), 10) ) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_first_elements((2, 9, (5, 7), 11) ) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_first_elements((11, 15, 5, 8, (2, 3), 8) ) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 287,
    "generated_code": "def square_Sum(n):\n    total = 0\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        total += even_number ** 2\n    return total",
    "assertion_results": [
      {
        "assertion": "assert square_Sum(2) == 20",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert square_Sum(3) == 56",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert square_Sum(4) == 120",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 292,
    "generated_code": "def find(dividend, divisor):\n    return dividend // divisor",
    "assertion_results": [
      {
        "assertion": "assert find(10,3) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find(4,2) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find(20,5) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 283,
    "generated_code": "def validate(num):\n    # Convert number to string to easily iterate through digits\n    num_str = str(num)\n    \n    # Count frequency of each digit\n    digit_count = {}\n    for digit in num_str:\n        digit_count[digit] = digit_count.get(digit, 0) + 1\n    \n    # Check if frequency of each digit is <= the digit itself\n    for digit, count in digit_count.items():\n        if count > int(digit):\n            return False\n    \n    return True",
    "assertion_results": [
      {
        "assertion": "assert validate(1234) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert validate(51241) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert validate(321) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 285,
    "generated_code": "import re\n\ndef text_match_two_three(text):\n    pattern = r'ab{2,3}'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
    "assertion_results": [
      {
        "assertion": "assert text_match_two_three(\"ac\")==('Not matched!')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert text_match_two_three(\"dc\")==('Not matched!')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert text_match_two_three(\"abbbba\")==('Found a match!')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 244,
    "generated_code": "import math\n\ndef next_Perfect_Square(n):\n    sqrt_n = int(math.sqrt(n))\n    if sqrt_n * sqrt_n == n:\n        return (sqrt_n + 1) ** 2\n    else:\n        return (sqrt_n + 1) ** 2",
    "assertion_results": [
      {
        "assertion": "assert next_Perfect_Square(35) == 36",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert next_Perfect_Square(6) == 9",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert next_Perfect_Square(9) == 16",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 293,
    "generated_code": "import math\n\ndef otherside_rightangle(a, b):\n    return math.sqrt(a**2 + b**2)",
    "assertion_results": [
      {
        "assertion": "assert otherside_rightangle(7,8)==10.63014581273465",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert otherside_rightangle(3,4)==5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert otherside_rightangle(7,15)==16.55294535724685",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 290,
    "generated_code": "def max_length(lists):\n    max_len = 0\n    max_list = []\n    \n    for lst in lists:\n        if len(lst) > max_len:\n            max_len = len(lst)\n            max_list = lst\n    \n    return (max_len, max_list)",
    "assertion_results": [
      {
        "assertion": "assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_length([[1], [5, 7], [10, 12, 14,15]])==(4, [10, 12, 14,15])",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_length([[5], [15,20,25]])==(3, [15,20,25])",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 286,
    "generated_code": "def max_sub_array_sum_repeated(arr, n, k):\n    if not arr or k == 0:\n        return 0\n    \n    # Create the repeated array\n    repeated_arr = arr * k\n    \n    # Kadane's algorithm to find maximum subarray sum\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in repeated_arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum",
    "assertion_results": [
      {
        "assertion": "assert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_sub_array_sum_repeated([-1, 10, 20], 3, 2) == 59",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_sub_array_sum_repeated([-1, -2, -3], 3, 3) == -1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 296,
    "generated_code": "def get_Inv_Count(arr, n):\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count",
    "assertion_results": [
      {
        "assertion": "assert get_Inv_Count([1,20,6,4,5],5) == 5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_Inv_Count([1,2,1],3) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_Inv_Count([1,2,5,6,1],5) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 295,
    "generated_code": "def sum_div(n):\n    total = 0\n    for i in range(1, n):\n        if n % i == 0:\n            total += i\n    return total",
    "assertion_results": [
      {
        "assertion": "assert sum_div(8)==7",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_div(12)==16",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_div(7)==1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 294,
    "generated_code": "def max_val(lst):\n    numeric_values = [item for item in lst if isinstance(item, (int, float))]\n    return max(numeric_values)",
    "assertion_results": [
      {
        "assertion": "assert max_val(['Python', 3, 2, 4, 5, 'version'])==5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_val(['Python', 15, 20, 25])==25",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_val(['Python', 30, 20, 40, 50, 'version'])==50",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 275,
    "generated_code": "def get_Position(arr, n, k):\n    def josephus(n, k):\n        if n == 1:\n            return 1\n        else:\n            return (josephus(n - 1, k) + k - 1) % n + 1\n    \n    return josephus(n, k)",
    "assertion_results": [
      {
        "assertion": "assert get_Position([2,5,4],3,2) == 2",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_Position([4,3],2,2) == 2",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_Position([1,2,3,4],4,1) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 297,
    "generated_code": "def flatten_list(nested_list):\n    result = []\n    for item in nested_list:\n        if isinstance(item, list):\n            result.extend(item)\n        else:\n            result.append(item)\n    return result",
    "assertion_results": [
      {
        "assertion": "assert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])==[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert flatten_list([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]])==[10, 20, 40, 30, 56, 25, 10, 20, 33, 40]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert flatten_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])==[1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 301,
    "generated_code": "def dict_depth(d):\n    if not isinstance(d, dict) or not d:\n        return 0\n    \n    max_depth = 0\n    for value in d.values():\n        if isinstance(value, dict):\n            depth = dict_depth(value)\n            max_depth = max(max_depth, depth)\n    \n    return max_depth + 1",
    "assertion_results": [
      {
        "assertion": "assert dict_depth({'a':1, 'b': {'c': {'d': {}}}})==4",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert dict_depth({'a':1, 'b': {'c':'python'}})==2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert dict_depth({1: 'Sun', 2: {3: {4:'Mon'}}})==3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 299,
    "generated_code": "def max_aggregate(tuples_list):\n    aggregates = {}\n    \n    for name, value in tuples_list:\n        if name in aggregates:\n            aggregates[name] += value\n        else:\n            aggregates[name] = value\n    \n    max_name = max(aggregates, key=aggregates.get)\n    return (max_name, aggregates[max_name])",
    "assertion_results": [
      {
        "assertion": "assert max_aggregate([('Juan Whelan',90),('Sabah Colley',88),('Peter Nichols',7),('Juan Whelan',122),('Sabah Colley',84)])==('Juan Whelan', 212)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_aggregate([('Juan Whelan',50),('Sabah Colley',48),('Peter Nichols',37),('Juan Whelan',22),('Sabah Colley',14)])==('Juan Whelan', 72)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_aggregate([('Juan Whelan',10),('Sabah Colley',20),('Peter Nichols',30),('Juan Whelan',40),('Sabah Colley',50)])==('Sabah Colley', 70)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 298,
    "generated_code": "def intersection_nested_lists(list1, list2):\n    result = []\n    for sublist in list2:\n        intersection = []\n        for element in sublist:\n            if element in list1:\n                intersection.append(element)\n        result.append(intersection)\n    return result",
    "assertion_results": [
      {
        "assertion": "assert intersection_nested_lists( [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],[[12, 18, 23, 25, 45], [7, 11, 19, 24, 28], [1, 5, 8, 18, 15, 16]])==[[12], [7, 11], [1, 5, 8]]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert intersection_nested_lists([[2, 3, 1], [4, 5], [6, 8]], [[4, 5], [6, 8]])==[[], []]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert intersection_nested_lists(['john','amal','joel','george'],[['john'],['jack','john','mary'],['howard','john'],['jude']])==[['john'], ['john'], ['john'], []]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 288,
    "generated_code": "def modular_inverse(arr, n, p):\n    count = 0\n    \n    for i in range(n):\n        num = arr[i]\n        # Find modular inverse of num under prime p\n        # num * inverse \u2261 1 (mod p)\n        # Using Fermat's little theorem: num^(p-1) \u2261 1 (mod p)\n        # So inverse = num^(p-2) mod p\n        \n        if num % p == 0:\n            continue  # No modular inverse exists for multiples of p\n            \n        inverse = pow(num, p-2, p)\n        \n        # Check if the modular inverse equals the number itself\n        if inverse == num % p:\n            count += 1\n    \n    return count",
    "assertion_results": [
      {
        "assertion": "assert modular_inverse([ 1, 6, 4, 5 ], 4, 7) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert modular_inverse([1, 3, 8, 12, 12], 5, 13) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert modular_inverse([2, 3, 4, 5], 4, 6) == 1",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 309,
    "generated_code": "def maximum(a, b):\n    return a if a > b else b",
    "assertion_results": [
      {
        "assertion": "assert maximum(5,10) == 10",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert maximum(-1,-2) == -1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert maximum(9,7) == 9",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 302,
    "generated_code": "def set_Bit_Number(n):\n    if n == 0:\n        return 0\n    \n    # Find the position of the most significant bit\n    msb_position = 0\n    temp = n\n    while temp > 0:\n        temp >>= 1\n        msb_position += 1\n    \n    # Return 2^(msb_position - 1) which is the value of the MSB\n    return 1 << (msb_position - 1)",
    "assertion_results": [
      {
        "assertion": "assert set_Bit_Number(6) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert set_Bit_Number(10) == 8",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert set_Bit_Number(18) == 16",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 310,
    "generated_code": "def string_to_tuple(s):\n    return tuple(char for char in s if char != ' ')",
    "assertion_results": [
      {
        "assertion": "assert string_to_tuple(\"python 3.0\")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert string_to_tuple(\"item1\")==('i', 't', 'e', 'm', '1')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert string_to_tuple(\"15.10\")==('1', '5', '.', '1', '0')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 305,
    "generated_code": "def start_withp(word_list):\n    p_words = []\n    \n    for phrase in word_list:\n        words = phrase.split()\n        for word in words:\n            if word.lower().startswith('p'):\n                p_words.append(word)\n    \n    if len(p_words) >= 2:\n        return (p_words[0], p_words[1])\n    \n    return None",
    "assertion_results": [
      {
        "assertion": "assert start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"])==('Python', 'PHP')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert start_withp([\"Python Programming\",\"Java Programming\"])==('Python','Programming')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert start_withp([\"Pqrst Pqr\",\"qrstuv\"])==('Pqrst','Pqr')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 312,
    "generated_code": "import math\n\ndef volume_cone(radius, height):\n    return (1/3) * math.pi * radius**2 * height",
    "assertion_results": [
      {
        "assertion": "assert volume_cone(5,12)==314.15926535897927",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert volume_cone(10,15)==1570.7963267948965",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert volume_cone(19,17)==6426.651371693521",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 308,
    "generated_code": "def large_product(list1, list2, n):\n    products = []\n    for i in list1:\n        for j in list2:\n            products.append(i * j)\n    \n    products.sort(reverse=True)\n    return products[:n]",
    "assertion_results": [
      {
        "assertion": "assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],3)==[60, 54, 50]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],4)==[60, 54, 50, 48]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],5)==[60, 54, 50, 48, 45]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 313,
    "generated_code": "def pos_nos(lst):\n    positive_nums = []\n    for num in lst:\n        if num > 0:\n            positive_nums.append(num)\n    \n    if len(positive_nums) == 1:\n        return positive_nums[0]\n    else:\n        return tuple(positive_nums)",
    "assertion_results": [
      {
        "assertion": "assert pos_nos([-1,-2,1,2]) == 1,2",
        "status": "FAILED",
        "error": "AssertionError: 2",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert pos_nos([3,4,-5]) == 3,4",
        "status": "FAILED",
        "error": "AssertionError: 4",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert pos_nos([-2,-3,1]) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 315,
    "generated_code": "def find_Max_Len_Even(s):\n    words = s.split()\n    max_len = 0\n    result = \"-1\"\n    \n    for word in words:\n        if len(word) % 2 == 0:  # Check if word length is even\n            if len(word) > max_len:\n                max_len = len(word)\n                result = word\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert find_Max_Len_Even(\"python language\") == \"language\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_Max_Len_Even(\"maximum even length\") == \"length\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_Max_Len_Even(\"eve\") == \"-1\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 236,
    "generated_code": "Looking at this problem, I need to find the maximum number of equilateral triangles of a given size that can be formed within a larger equilateral triangle.\n\nFrom the test cases:\n- `No_of_Triangle(4,2) == 7`: In a triangle of side 4, we can fit 7 triangles of side 2\n- `No_of_Triangle(4,3) == 3`: In a triangle of side 4, we can fit 3 triangles of side 3\n- `No_of_Triangle(1,3) == -1`: In a triangle of side 1, we cannot fit any triangles of side 3 (impossible case)\n\nThe pattern suggests this is about fitting smaller equilateral triangles into a larger one. The formula for the maximum number of equilateral triangles of side `small` that can fit in an equilateral triangle of side `large` is:\n\nIf `small > large`, return -1 (impossible)\nOtherwise, the number is `(large // small)\u00b2`\n\nLet me verify:\n- For (4,2): (4//2)\u00b2 = 2\u00b2 = 4... but expected is 7\n- Let me reconsider...\n\nActually, looking more carefully at the pattern, this seems to be about triangular numbers. When we divide an equilateral triangle into smaller equilateral triangles, the formula is different.\n\nFor an equilateral triangle of side `n` divided into unit triangles of side `k`, the number of triangles of side `k` that fit is `(n//k)\u00b2` but we need to account for the triangular arrangement.\n\nLet me think about this differently. If we have a large triangle of side `large` and want to fit triangles of side `small`, the number that fit is `((large - small) // small + 1)\u00b2` when `small <= large`, otherwise -1.\n\nWait, let me check the pattern again:\n- (4,2): We're looking at how many triangles of side 2 fit in a triangle of side 4\n- (4,3): We're looking at how many triangles of side 3 fit in a triangle of side 4\n\nActually, the correct formula appears to be: `(large - small + 1)",
    "assertion_results": []
  },
  {
    "task_id": 324,
    "generated_code": "def sum_of_alternates(tup):\n    sum1 = sum(tup[i] for i in range(0, len(tup), 2))\n    sum2 = sum(tup[i] for i in range(1, len(tup), 2))\n    return (sum1, sum2)",
    "assertion_results": [
      {
        "assertion": "assert sum_of_alternates((5, 6, 3, 6, 10, 34)) == (46, 18)",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_of_alternates((1, 2, 3, 4, 5)) == (6, 9)",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_of_alternates((6, 7, 8, 9, 4, 5)) == (21, 18)",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 319,
    "generated_code": "import re\n\ndef find_long_word(text):\n    pattern = r'\\b[a-zA-Z]{5}\\b'\n    matches = re.findall(pattern, text)\n    return matches",
    "assertion_results": [
      {
        "assertion": "assert find_long_word('Please move back to strem') == ['strem']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_long_word('4K Ultra HD streaming player') == ['Ultra']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_long_word('Streaming Media Player') == ['Media']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 322,
    "generated_code": "def position_min(lst):\n    if not lst:\n        return []\n    \n    min_value = min(lst)\n    positions = []\n    \n    for i, value in enumerate(lst):\n        if value == min_value:\n            positions.append(i)\n    \n    return positions",
    "assertion_results": [
      {
        "assertion": "assert position_min([12,33,23,10,67,89,45,667,23,12,11,10,54])==[3,11]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert position_min([1,2,2,2,4,4,4,5,5,5,5])==[0]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert position_min([2,1,5,6,8,3,4,9,10,11,8,12])==[1]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 300,
    "generated_code": "def count_binary_seq(n):\n    from math import comb\n    return float(comb(2*n, n))",
    "assertion_results": [
      {
        "assertion": "assert count_binary_seq(1) == 2.0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_binary_seq(2) == 6.0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_binary_seq(3) == 20.0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 211,
    "generated_code": "def count_Num(n):\n    count = 0\n    # Check numbers up to 2^(n+1)\n    limit = 2 ** (n + 1)\n    \n    for num in range(limit):\n        # Check if both 0th bit and nth bit are set\n        if (num & 1) and (num & (1 << n)):\n            count += 1\n    \n    return count",
    "assertion_results": [
      {
        "assertion": "assert count_Num(2) == 1",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Num(3) == 2",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Num(1) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 311,
    "generated_code": "def set_left_most_unset_bit(n):\n    if n == 0:\n        return 1\n    \n    # Find the position of the leftmost unset bit\n    temp = n\n    position = 0\n    \n    # Find the highest set bit position\n    while temp > 0:\n        temp >>= 1\n        position += 1\n    \n    # Check each bit from left to right (highest to lowest)\n    for i in range(position - 1, -1, -1):\n        if (n & (1 << i)) == 0:  # If bit at position i is unset\n            return n | (1 << i)  # Set that bit and return\n    \n    # If all bits are set, set the next higher bit\n    return n | (1 << position)",
    "assertion_results": [
      {
        "assertion": "assert set_left_most_unset_bit(10) == 14",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert set_left_most_unset_bit(12) == 14",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert set_left_most_unset_bit(15) == 15",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 316,
    "generated_code": "def find_last_occurrence(arr, target):\n    last_index = -1\n    for i in range(len(arr)):\n        if arr[i] == target:\n            last_index = i\n    return last_index",
    "assertion_results": [
      {
        "assertion": "assert find_last_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_last_occurrence([2, 3, 5, 8, 6, 6, 8, 9, 9, 9], 9) == 9",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_last_occurrence([2, 2, 1, 5, 6, 6, 6, 9, 9, 9], 6) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 326,
    "generated_code": "import re\nfrom collections import Counter\n\ndef most_occurrences(strings_list):\n    word_count = Counter()\n    \n    for string in strings_list:\n        words = re.findall(r'\\w+', string)\n        for word in words:\n            word_count[word] += 1\n    \n    return word_count.most_common(1)[0][0]",
    "assertion_results": [
      {
        "assertion": "assert most_occurrences([\"UTS is best for RTF\", \"RTF love UTS\", \"UTS is best\"] ) == 'UTS'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert most_occurrences([\"Its been a great year\", \"this year is so worse\", \"this year is okay\"] ) == 'year'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert most_occurrences([\"Families can be reunited\", \"people can be reunited\", \"Tasks can be achieved \"] ) == 'can'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 329,
    "generated_code": "def neg_count(lst):\n    count = 0\n    for num in lst:\n        if num < 0:\n            count += 1\n    return count",
    "assertion_results": [
      {
        "assertion": "assert neg_count([-1,-2,3,-4,-5]) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert neg_count([1,2,3]) == 0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert neg_count([1,2,-3,-10,20]) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 327,
    "generated_code": "def check_isosceles(a, b, c):\n    # Check if it's a valid triangle first\n    if a + b <= c or a + c <= b or b + c <= a:\n        return False\n    \n    # Check if any two sides are equal (isosceles condition)\n    return a == b or b == c or a == c",
    "assertion_results": [
      {
        "assertion": "assert check_isosceles(6,8,12)==False ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_isosceles(6,6,12)==True",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_isosceles(6,16,20)==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 317,
    "generated_code": "def modified_encode(data):\n    if not data:\n        return []\n    \n    result = []\n    current_item = data[0]\n    count = 1\n    \n    for i in range(1, len(data)):\n        if data[i] == current_item:\n            count += 1\n        else:\n            if count == 1:\n                result.append(current_item)\n            else:\n                result.append([count, current_item])\n            current_item = data[i]\n            count = 1\n    \n    # Handle the last group\n    if count == 1:\n        result.append(current_item)\n    else:\n        result.append([count, current_item])\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert modified_encode([1,1,2,3,4,4,5,1])==[[2, 1], 2, 3, [2, 4], 5, 1]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert modified_encode('automatically')==['a', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', 'a', [2, 'l'], 'y']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert modified_encode('python')==['p', 'y', 't', 'h', 'o', 'n']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 307,
    "generated_code": "def colon_tuplex(tuple_input, index, value):\n    # Convert tuple to list for modification\n    temp_list = list(tuple_input)\n    \n    # Append the value to the element at the given index\n    temp_list[index].append(value)\n    \n    # Convert back to tuple and return\n    return tuple(temp_list)",
    "assertion_results": [
      {
        "assertion": "assert colon_tuplex((\"HELLO\", 5, [], True) ,2,50)==(\"HELLO\", 5, [50], True) ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert colon_tuplex((\"HELLO\", 5, [], True) ,2,100)==((\"HELLO\", 5, [100],True))",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert colon_tuplex((\"HELLO\", 5, [], True) ,2,500)==(\"HELLO\", 5, [500], True)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 325,
    "generated_code": "def get_Min_Squares(n):\n    # dp[i] will store the minimum number of squares needed for i\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    # For each number from 1 to n\n    for i in range(1, n + 1):\n        # Try all perfect squares less than or equal to i\n        j = 1\n        while j * j <= i:\n            dp[i] = min(dp[i], dp[i - j * j] + 1)\n            j += 1\n    \n    return dp[n]",
    "assertion_results": [
      {
        "assertion": "assert get_Min_Squares(6) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_Min_Squares(2) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_Min_Squares(4) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 289,
    "generated_code": "def odd_Days(years):\n    if years == 0:\n        return 0\n    \n    # Count leap years in the given number of years\n    leap_years = 0\n    for year in range(1, years + 1):\n        if year % 4 == 0:\n            if year % 100 == 0:\n                if year % 400 == 0:\n                    leap_years += 1\n            else:\n                leap_years += 1\n    \n    # Regular years contribute 1 odd day each\n    # Leap years contribute 2 odd days each\n    regular_years = years - leap_years\n    total_odd_days = regular_years * 1 + leap_years * 2\n    \n    # Return odd days modulo 7\n    return total_odd_days % 7",
    "assertion_results": [
      {
        "assertion": "assert odd_Days(100) == 5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert odd_Days(50) ==6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert odd_Days(75) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 320,
    "generated_code": "def sum_difference(n):\n    # Sum of first n natural numbers: n(n+1)/2\n    sum_of_numbers = n * (n + 1) // 2\n    \n    # Square of the sum\n    squared_sum = sum_of_numbers ** 2\n    \n    # Sum of squares of first n natural numbers: n(n+1)(2n+1)/6\n    sum_of_squares = n * (n + 1) * (2 * n + 1) // 6\n    \n    # Return the difference\n    return squared_sum - sum_of_squares",
    "assertion_results": [
      {
        "assertion": "assert sum_difference(12)==5434",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_difference(20)==41230",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_difference(54)==2151270",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 291,
    "generated_code": "def count_no_of_ways(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n    \n    # dp[i][0] represents ways to paint i posts where last two posts have different colors\n    # dp[i][1] represents ways to paint i posts where last two posts have same color\n    \n    # For first post: k ways\n    # For second post: k ways (can be same or different from first)\n    # dp[2][0] = k * (k-1) (second post different from first)\n    # dp[2][1] = k * 1 = k (second post same as first)\n    \n    dp = [[0, 0] for _ in range(n + 1)]\n    \n    dp[1][0] = k  # First post can be painted in k ways\n    dp[1][1] = 0  # Can't have same color for just one post\n    \n    dp[2][0] = k * (k - 1)  # Second post different from first\n    dp[2][1] = k  # Second post same as first\n    \n    for i in range(3, n + 1):\n        # If last two posts have different colors, previous post can be any color\n        dp[i][0] = (dp[i-1][0] + dp[i-1][1]) * (k - 1)\n        \n        # If last two posts have same color, previous two posts must have different colors\n        dp[i][1] = dp[i-1][0]\n    \n    return dp[n][0] + dp[n][1]",
    "assertion_results": [
      {
        "assertion": "assert count_no_of_ways(2, 4) == 16",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_no_of_ways(3, 2) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_no_of_ways(4, 4) == 228",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 330,
    "generated_code": "import re\n\ndef find_char(text):\n    pattern = r'\\b[a-zA-Z]{3,5}\\b'\n    matches = re.findall(pattern, text)\n    return matches",
    "assertion_results": [
      {
        "assertion": "assert find_char('For the four consumer complaints contact manager AKR reddy') == ['For', 'the', 'four', 'AKR', 'reddy']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_char('Certain service are subject to change MSR') == ['are', 'MSR']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_char('Third party legal desclaimers') == ['Third', 'party', 'legal']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 306,
    "generated_code": "def max_sum_increasing_subseq(arr, n, i, k):\n    # dp[j] will store the maximum sum of increasing subsequence ending at index j\n    dp = [0] * (i + 1)\n    \n    # Initialize dp array\n    for j in range(i + 1):\n        dp[j] = arr[j]\n    \n    # Fill dp array for increasing subsequences up to index i\n    for j in range(1, i + 1):\n        for prev in range(j):\n            if arr[prev] < arr[j]:\n                dp[j] = max(dp[j], dp[prev] + arr[j])\n    \n    # Find maximum sum that can be extended with arr[k]\n    max_sum = 0\n    \n    # Check all positions up to i\n    for j in range(i + 1):\n        if arr[j] < arr[k]:\n            max_sum = max(max_sum, dp[j] + arr[k])\n    \n    return max_sum",
    "assertion_results": [
      {
        "assertion": "assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 4, 6) == 11",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 2, 5) == 7",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_sum_increasing_subseq([11, 15, 19, 21, 26, 28, 31], 7, 2, 4) == 71",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 333,
    "generated_code": "def Sort(lst):\n    return sorted(lst, key=lambda x: x[1])",
    "assertion_results": [
      {
        "assertion": "assert Sort([['a', 10], ['b', 5], ['c', 20], ['d', 15]]) == [['b', 5], ['a', 10], ['d', 15], ['c', 20]]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert Sort([['452', 10], ['256', 5], ['100', 20], ['135', 15]]) == [['256', 5], ['452', 10], ['135', 15], ['100', 20]]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert Sort([['rishi', 10], ['akhil', 5], ['ramya', 20], ['gaur', 15]]) == [['akhil', 5], ['rishi', 10], ['gaur', 15], ['ramya', 20]]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 335,
    "generated_code": "def ap_sum(a, d, n):\n    return n * (2 * a + (n - 1) * d) // 2",
    "assertion_results": [
      {
        "assertion": "assert ap_sum(1,5,2)==25",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert ap_sum(2,6,4)==72",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert ap_sum(1,4,5)==34",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 331,
    "generated_code": "def count_unset_bits(n):\n    if n == 0:\n        return 1\n    \n    # Find the number of bits needed to represent n\n    bit_length = n.bit_length()\n    \n    # Count set bits\n    set_bits = bin(n).count('1')\n    \n    # Unset bits = total bits - set bits\n    return bit_length - set_bits",
    "assertion_results": [
      {
        "assertion": "assert count_unset_bits(2) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_unset_bits(4) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_unset_bits(6) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 334,
    "generated_code": "def check_Validity(a, b, c):\n    # For a triangle to be valid, the sum of any two sides must be greater than the third side\n    # This must be true for all three combinations\n    return (a + b > c) and (a + c > b) and (b + c > a)",
    "assertion_results": [
      {
        "assertion": "assert check_Validity(1,2,3) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_Validity(2,3,5) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_Validity(7,10,5) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 336,
    "generated_code": "def check_monthnum(month_name):\n    return month_name == \"February\"",
    "assertion_results": [
      {
        "assertion": "assert check_monthnum(\"February\")==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_monthnum(\"January\")==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_monthnum(\"March\")==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 332,
    "generated_code": "def char_frequency(s):\n    frequency = {}\n    for c in s:\n        if c in frequency:\n            frequency[c] += 1\n        else:\n            frequency[c] = 1\n    return frequency",
    "assertion_results": [
      {
        "assertion": "assert char_frequency('python')=={'p': 1, 'y': 1, 't': 1, 'h': 1, 'o': 1, 'n': 1}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert char_frequency('program')=={'p': 1, 'r': 2, 'o': 1, 'g': 1, 'a': 1, 'm': 1}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert char_frequency('language')=={'l': 1, 'a': 2, 'n': 1, 'g': 2, 'u': 1, 'e': 1}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 341,
    "generated_code": "def set_to_tuple(s):\n    return tuple(sorted(s))",
    "assertion_results": [
      {
        "assertion": "assert set_to_tuple({1, 2, 3, 4, 5}) == (1, 2, 3, 4, 5)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert set_to_tuple({6, 7, 8, 9, 10, 11}) == (6, 7, 8, 9, 10, 11)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert set_to_tuple({12, 13, 14, 15, 16}) == (12, 13, 14, 15, 16)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 343,
    "generated_code": "def dig_let(s):\n    letters = 0\n    digits = 0\n    \n    for char in s:\n        if char.isalpha():\n            letters += 1\n        elif char.isdigit():\n            digits += 1\n    \n    return (letters, digits)",
    "assertion_results": [
      {
        "assertion": "assert dig_let(\"python\")==(6,0)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert dig_let(\"program\")==(7,0)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert dig_let(\"python3.0\")==(6,2)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 337,
    "generated_code": "import re\n\ndef text_match_word(text):\n    pattern = r'\\bpython\\b[.!?]*$'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
    "assertion_results": [
      {
        "assertion": "assert text_match_word(\"python.\")==('Found a match!')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert text_match_word(\"python.\")==('Found a match!')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert text_match_word(\"  lang  .\")==('Not matched!')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 304,
    "generated_code": "def find_Element(arr, rotations, index, num_rotations):\n    # Make a copy of the array to avoid modifying the original\n    result = arr[:]\n    \n    # Apply the specified number of rotations\n    for _ in range(num_rotations):\n        # Apply each rotation in the rotations list\n        for rotation in rotations:\n            start, end = rotation\n            # Perform left rotation on the subarray from start to end (inclusive)\n            if start < len(result) and end < len(result) and start <= end:\n                # Extract the subarray\n                subarray = result[start:end+1]\n                # Perform left rotation (move first element to the end)\n                if len(subarray) > 1:\n                    rotated_subarray = subarray[1:] + [subarray[0]]\n                    # Replace the subarray in the result\n                    result[start:end+1] = rotated_subarray\n    \n    return result[index]",
    "assertion_results": [
      {
        "assertion": "assert find_Element([1,2,3,4,5],[[0,2],[0,3]],2,1) == 3",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_Element([1,2,3,4],[[0,1],[0,2]],1,2) == 3",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_Element([1,2,3,4,5,6],[[0,1],[0,2]],1,1) == 1",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 349,
    "generated_code": "def check(s):\n    for char in s:\n        if char not in '01':\n            return \"No\"\n    return \"Yes\"",
    "assertion_results": [
      {
        "assertion": "assert check(\"01010101010\") == \"Yes\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check(\"name0\") == \"No\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check(\"101\") == \"Yes\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 345,
    "generated_code": "def diff_consecutivenums(nums):\n    result = []\n    for i in range(1, len(nums)):\n        result.append(nums[i] - nums[i-1])\n    return result",
    "assertion_results": [
      {
        "assertion": "assert diff_consecutivenums([1, 1, 3, 4, 4, 5, 6, 7])==[0, 2, 1, 0, 1, 1, 1]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert diff_consecutivenums([4, 5, 8, 9, 6, 10])==[1, 3, 1, -3, 4]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert diff_consecutivenums([0, 1, 2, 3, 4, 4, 4, 4, 5, 7])==[1, 1, 1, 1, 0, 0, 0, 1, 2]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 347,
    "generated_code": "def count_Squares(m, n):\n    total_squares = 0\n    for i in range(1, min(m, n) + 1):\n        total_squares += (m - i + 1) * (n - i + 1)\n    return total_squares",
    "assertion_results": [
      {
        "assertion": "assert count_Squares(4,3) == 20",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Squares(1,2) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Squares(2,2) == 5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 340,
    "generated_code": "def sum_three_smallest_nums(nums):\n    # Filter positive numbers and sort them\n    positive_nums = [num for num in nums if num > 0]\n    positive_nums.sort()\n    \n    # Return sum of first three elements\n    return sum(positive_nums[:3])",
    "assertion_results": [
      {
        "assertion": "assert sum_three_smallest_nums([10,20,30,40,50,60,7]) == 37",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_three_smallest_nums([1,2,3,4,5]) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_three_smallest_nums([0,1,2,3,4,5]) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 321,
    "generated_code": "def find_demlo(s):\n    n = len(s)\n    result = \"\"\n    \n    # Count up from 1 to n\n    for i in range(1, n + 1):\n        result += str(i)\n    \n    # Count down from n-1 to 1\n    for i in range(n - 1, 0, -1):\n        result += str(i)\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert find_demlo(\"111111\") == '12345654321'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_demlo(\"1111\") == '1234321'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_demlo(\"13333122222\") == '123456789101110987654321'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 339,
    "generated_code": "def find_Divisor(start, end):\n    divisor_count = {}\n    \n    # Count occurrences of each divisor\n    for num in range(start, end + 1):\n        for divisor in range(1, num + 1):\n            if num % divisor == 0:\n                divisor_count[divisor] = divisor_count.get(divisor, 0) + 1\n    \n    # Find the divisor with maximum occurrences\n    max_count = 0\n    max_divisor = 0\n    \n    for divisor, count in divisor_count.items():\n        if count > max_count or (count == max_count and divisor > max_divisor):\n            max_count = count\n            max_divisor = divisor\n    \n    return max_divisor",
    "assertion_results": [
      {
        "assertion": "assert find_Divisor(2,2) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_Divisor(2,5) == 2",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_Divisor(5,10) == 2",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 338,
    "generated_code": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    n = len(s)\n    \n    # Count single characters (they have same first and last character)\n    count += n\n    \n    # Count substrings of length 2 or more with same first and last character\n    for i in range(n):\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                count += 1\n    \n    return count",
    "assertion_results": [
      {
        "assertion": "assert count_Substring_With_Equal_Ends('aba') == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Substring_With_Equal_Ends('abcab') == 7",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Substring_With_Equal_Ends('abc') == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 352,
    "generated_code": "def unique_Characters(s):\n    return len(s) == len(set(s))",
    "assertion_results": [
      {
        "assertion": "assert unique_Characters('aba') == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert unique_Characters('abc') == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert unique_Characters('abab') == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 350,
    "generated_code": "def minimum_Length(s):\n    from collections import Counter\n    \n    # Count frequency of each character\n    char_count = Counter(s)\n    \n    # Find the character with maximum frequency\n    max_freq = max(char_count.values())\n    \n    # The minimum length is the original length minus the maximum frequency\n    return len(s) - max_freq",
    "assertion_results": [
      {
        "assertion": "assert minimum_Length(\"mnm\") == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert minimum_Length(\"abcda\") == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert minimum_Length(\"abcb\") == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 351,
    "generated_code": "def first_Element(arr, n, k):\n    import collections\n    \n    counter = collections.Counter()\n    \n    for element in arr:\n        counter[element] += 1\n        if counter[element] == k:\n            return element\n    \n    return None",
    "assertion_results": [
      {
        "assertion": "assert first_Element([0,1,2,3,4,5],6,1) == 0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert first_Element([1,2,1,3,4],5,2) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert first_Element([2,3,4,3,5,7,1,2,3,5],10,2) == 2",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 353,
    "generated_code": "def remove_column(nested_list, column_index):\n    result = []\n    for row in nested_list:\n        if column_index < len(row):\n            new_row = row[:column_index] + row[column_index + 1:]\n        else:\n            new_row = row[:]\n        result.append(new_row)\n    return result",
    "assertion_results": [
      {
        "assertion": "assert remove_column([[1, 2, 3], [2, 4, 5], [1, 1, 1]],0)==[[2, 3], [4, 5], [1, 1]]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_column([[1, 2, 3], [-2, 4, -5], [1, -1, 1]],2)==[[1, 2], [-2, 4], [1, -1]]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_column([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]],0)==[[3], [7], [3], [15, 17], [7], [11]]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 356,
    "generated_code": "def find_angle(angle1, angle2):\n    return 180 - angle1 - angle2",
    "assertion_results": [
      {
        "assertion": "assert find_angle(47,89)==44",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_angle(45,95)==40",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_angle(50,40)==90",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 314,
    "generated_code": "def max_sum_rectangular_grid(grid, n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return max(grid[0][0], grid[1][0])\n    \n    # dp[i][j] represents max sum up to column i with state j\n    # j = 0: neither cell in column i is selected\n    # j = 1: only top cell in column i is selected\n    # j = 2: only bottom cell in column i is selected\n    # j = 3: both cells in column i are selected (not allowed due to adjacency)\n    \n    dp = [[0] * 4 for _ in range(n)]\n    \n    # Base case for first column\n    dp[0][0] = 0  # neither selected\n    dp[0][1] = grid[0][0]  # top selected\n    dp[0][2] = grid[1][0]  # bottom selected\n    dp[0][3] = float('-inf')  # both selected (invalid)\n    \n    for i in range(1, n):\n        # Neither cell selected in current column\n        dp[i][0] = max(dp[i-1][0], dp[i-1][1], dp[i-1][2])\n        \n        # Only top cell selected in current column\n        dp[i][1] = max(dp[i-1][0], dp[i-1][2]) + grid[0][i]\n        \n        # Only bottom cell selected in current column\n        dp[i][2] = max(dp[i-1][0], dp[i-1][1]) + grid[1][i]\n        \n        # Both cells selected (invalid due to vertical adjacency)\n        dp[i][3] = float('-inf')\n    \n    return max(dp[n-1][0], dp[n-1][1], dp[n-1][2])",
    "assertion_results": [
      {
        "assertion": "assert max_sum_rectangular_grid([ [1, 4, 5], [2, 0, 0 ] ], 3) == 7",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_sum_rectangular_grid([ [ 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10] ], 5) == 24",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_sum_rectangular_grid([ [7, 9, 11, 15, 19], [21, 25, 28, 31, 32] ], 5) == 81",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 358,
    "generated_code": "def moddiv_list(list1, list2):\n    return list(map(lambda x, y: x % y, list1, list2))",
    "assertion_results": [
      {
        "assertion": "assert moddiv_list([4,5,6],[1, 2, 3])==[0, 1, 0]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert moddiv_list([3,2],[1,4])==[0, 2]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert moddiv_list([90,120],[50,70])==[40, 50]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 357,
    "generated_code": "def find_max(tuples):\n    max_val = float('-inf')\n    for tuple_record in tuples:\n        for element in tuple_record:\n            if element > max_val:\n                max_val = element\n    return max_val",
    "assertion_results": [
      {
        "assertion": "assert find_max([(2, 4), (6, 7), (5, 1), (6, 10), (8, 7)]) == 10",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_max([(3, 5), (7, 8), (6, 2), (7, 11), (9, 8)]) == 11",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_max([(4, 6), (8, 9), (7, 3), (8, 12), (10, 9)]) == 12",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 323,
    "generated_code": "def re_arrange(arr, n):\n    positives = []\n    negatives = []\n    \n    # Separate positive and negative numbers\n    for num in arr:\n        if num < 0:\n            negatives.append(num)\n        else:\n            positives.append(num)\n    \n    result = []\n    pos_idx = 0\n    neg_idx = 0\n    \n    # Alternate between negative and positive\n    for i in range(n):\n        if i % 2 == 0:  # Even indices get negative numbers\n            if neg_idx < len(negatives):\n                result.append(negatives[neg_idx])\n                neg_idx += 1\n            elif pos_idx < len(positives):\n                result.append(positives[pos_idx])\n                pos_idx += 1\n        else:  # Odd indices get positive numbers\n            if pos_idx < len(positives):\n                result.append(positives[pos_idx])\n                pos_idx += 1\n            elif neg_idx < len(negatives):\n                result.append(negatives[neg_idx])\n                neg_idx += 1\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert re_arrange([-5, -2, 5, 2, 4,\t7, 1, 8, 0, -8], 10) == [-5, 5, -2, 2, -8, 4, 7, 1, 8, 0]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert re_arrange([1, 2, 3, -4, -1, 4], 6) == [-4, 1, -1, 2, 3, 4]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert re_arrange([4, 7, 9, 77, -4, 5, -3, -9], 8) == [-4, 4, -3, 7, -9, 9, 77, 5]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 361,
    "generated_code": "def remove_empty(lst):\n    return [item for item in lst if item != []]",
    "assertion_results": [
      {
        "assertion": "assert remove_empty([[], [], [], 'Red', 'Green', [1,2], 'Blue', [], []])==['Red', 'Green', [1, 2], 'Blue']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_empty([[], [], [],[],[], 'Green', [1,2], 'Blue', [], []])==[ 'Green', [1, 2], 'Blue']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_empty([[], [], [], 'Python',[],[], 'programming', 'language',[],[],[], [], []])==['Python', 'programming', 'language']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 365,
    "generated_code": "def count_Digit(number):\n    return len(str(abs(number)))",
    "assertion_results": [
      {
        "assertion": "assert count_Digit(12345) == 5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Digit(11223305) == 8",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Digit(4123459) == 7",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 368,
    "generated_code": "def repeat_tuples(tuple_input, n):\n    return tuple(tuple_input for _ in range(n))",
    "assertion_results": [
      {
        "assertion": "assert repeat_tuples((1, 3), 4) == ((1, 3), (1, 3), (1, 3), (1, 3))",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert repeat_tuples((1, 2), 3) == ((1, 2), (1, 2), (1, 2))",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert repeat_tuples((3, 4), 5) == ((3, 4), (3, 4), (3, 4), (3, 4), (3, 4))",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 303,
    "generated_code": "def solve(arr, n):\n    # Count inversions of two types:\n    # Type 1: inversions where both elements are < n//2\n    # Type 2: inversions where both elements are >= n//2\n    \n    type",
    "assertion_results": [
      {
        "assertion": "assert solve([1,0,2],3) == True",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert solve([1,2,0],3) == False",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert solve([1,2,1],3) == True",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 363,
    "generated_code": "def add_K_element(tuples_list, k):\n    result = []\n    for tuple_item in tuples_list:\n        new_tuple = tuple(element + k for element in tuple_item)\n        result.append(new_tuple)\n    return result",
    "assertion_results": [
      {
        "assertion": "assert add_K_element([(1, 3, 4), (2, 4, 6), (3, 8, 1)], 4) == [(5, 7, 8), (6, 8, 10), (7, 12, 5)]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert add_K_element([(1, 2, 3), (4, 5, 6), (7, 8, 9)], 8) == [(9, 10, 11), (12, 13, 14), (15, 16, 17)]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert add_K_element([(11, 12, 13), (14, 15, 16), (17, 18, 19)], 9) == [(20, 21, 22), (23, 24, 25), (26, 27, 28)]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 328,
    "generated_code": "def rotate_left(lst, rotate_pos, additional):\n    n = len(lst)\n    rotate_pos = rotate_pos % n\n    rotated = lst[rotate_pos:] + lst[:rotate_pos]\n    result = rotated + rotated[:additional]",
    "assertion_results": [
      {
        "assertion": "assert rotate_left([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],3,4)==[4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4]",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert rotate_left([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],2,2)==[3, 4, 5, 6, 7, 8, 9, 10, 1, 2]",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert rotate_left([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],5,2)==[6, 7, 8, 9, 10, 1, 2]",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 369,
    "generated_code": "def lateralsurface_cuboid(length, width, height):\n    return 2 * height * (length + width)",
    "assertion_results": [
      {
        "assertion": "assert lateralsurface_cuboid(8,5,6)==156",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert lateralsurface_cuboid(7,9,10)==320",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert lateralsurface_cuboid(10,20,30)==1800",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 344,
    "generated_code": "import math\n\ndef count_Odd_Squares(start, end):\n    # Find the smallest integer whose square is >= start\n    sqrt_start = math.ceil(math.sqrt(start))\n    \n    # Find the largest integer whose square is <= end\n    sqrt_end = math.floor(math.sqrt(end))\n    \n    # Count perfect squares in range\n    if sqrt_start <= sqrt_end:\n        return sqrt_end - sqrt_start + 1\n    else:\n        return 0",
    "assertion_results": [
      {
        "assertion": "assert count_Odd_Squares(5,100) == 8",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Odd_Squares(8,65) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Odd_Squares(2,5) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 366,
    "generated_code": "def adjacent_num_product(nums):\n    max_product = nums[0] * nums[1]\n    \n    for i in range(1, len(nums) - 1):\n        product = nums[i] * nums[i + 1]\n        if product > max_product:\n            max_product = product\n    \n    return max_product",
    "assertion_results": [
      {
        "assertion": "assert adjacent_num_product([1,2,3,4,5,6]) == 30",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert adjacent_num_product([1,2,3,4,5]) == 20",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert adjacent_num_product([2,3]) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 373,
    "generated_code": "def volume_cuboid(length, width, height):\n    return length * width * height",
    "assertion_results": [
      {
        "assertion": "assert volume_cuboid(1,2,3)==6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert volume_cuboid(5,7,9)==315",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert volume_cuboid(10,15,21)==3150",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 370,
    "generated_code": "def float_sort(tuples):\n    return sorted(tuples, key=lambda x: float(x[1]), reverse=True)",
    "assertion_results": [
      {
        "assertion": "assert float_sort([('item1', '12.20'), ('item2', '15.10'), ('item3', '24.5')])==[('item3', '24.5'), ('item2', '15.10'), ('item1', '12.20')] ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert float_sort([('item1', '15'), ('item2', '10'), ('item3', '20')])==[('item3', '20'), ('item1', '15'), ('item2', '10')] ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert float_sort([('item1', '5'), ('item2', '10'), ('item3', '14')])==[('item3', '14'), ('item2', '10'), ('item1', '5')] ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 359,
    "generated_code": "import math\n\ndef Check_Solution(a, b, c):\n    # Calculate discriminant\n    discriminant = b**2 - 4*a*c\n    \n    # Check if roots are real\n    if discriminant < 0:\n        return \"No\"\n    \n    # Calculate the two roots\n    root1 = (-b + math.sqrt(discriminant)) / (2*a)\n    root2 = (-b - math.sqrt(discriminant)) / (2*a)\n    \n    # Check if one root is twice the other\n    if abs(root1 - 2*root2) < 1e-10 or abs(root2 - 2*root1) < 1e-10:\n        return \"Yes\"\n    else:\n        return \"No\"",
    "assertion_results": [
      {
        "assertion": "assert Check_Solution(1,3,2) == \"Yes\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert Check_Solution(1,2,3) == \"No\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert Check_Solution(1,-5,6) == \"No\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 342,
    "generated_code": "import heapq\n\ndef find_minimum_range(arrays):\n    # Create a min heap with (value, array_index, element_index)\n    heap = []\n    max_val = float('-inf')\n    \n    # Initialize heap with first element from each array\n    for i, arr in enumerate(arrays):\n        if arr:  # Check if array is not empty\n            heapq.heappush(heap, (arr[0], i, 0))\n            max_val = max(max_val, arr[0])\n    \n    min_range = float('inf')\n    result_range = (0, 0)\n    \n    while len(heap) == len(arrays):\n        min_val, arr_idx, elem_idx = heapq.heappop(heap)\n        \n        # Update minimum range if current range is smaller\n        current_range = max_val - min_val\n        if current_range < min_range:\n            min_range = current_range\n            result_range = (min_val, max_val)\n        \n        # Move to next element in the same array\n        if elem_idx + 1 < len(arrays[arr_idx]):\n            next_val = arrays[arr_idx][elem_idx + 1]\n            heapq.heappush(heap, (next_val, arr_idx, elem_idx + 1))\n            max_val = max(max_val, next_val)\n        else:\n            # No more elements in this array, we can't maintain one element from each array\n            break\n    \n    return result_range",
    "assertion_results": [
      {
        "assertion": "assert find_minimum_range([[3, 6, 8, 10, 15], [1, 5, 12], [4, 8, 15, 16], [2, 6]]) == (4, 6)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_minimum_range([[ 2, 3, 4, 8, 10, 15 ], [1, 5, 12], [7, 8, 15, 16], [3, 6]]) == (4, 7)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_minimum_range([[4, 7, 9, 11, 16], [2, 6, 13], [5, 9, 16, 17], [3, 7]]) == (5, 7)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 375,
    "generated_code": "def round_num(num, multiple):\n    return (num // multiple) * multiple",
    "assertion_results": [
      {
        "assertion": "assert round_num(4722,10)==4720",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert round_num(1111,5)==1110",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert round_num(219,2)==218",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 372,
    "generated_code": "import heapq\n\ndef heap_assending(lst):\n    # Create a copy of the list to avoid modifying the original\n    heap = lst.copy()\n    \n    # Convert the list into a heap\n    heapq.heapify(heap)\n    \n    # Extract elements from heap one by one to get sorted order\n    result = []\n    while heap:\n        result.append(heapq.heappop(heap))\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert heap_assending([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1])==[1, 2, 3, 4, 7, 8, 9, 9, 10, 14, 18]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert heap_assending([25, 35, 22, 85, 14, 65, 75, 25, 58])==[14, 22, 25, 25, 35, 58, 65, 75, 85]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert heap_assending([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 364,
    "generated_code": "def min_flip_to_make_string_alternate(s):\n    n = len(s)\n    \n    # Count flips needed for pattern starting with '0'\n    flips_pattern_0 = 0\n    for i in range(n):\n        expected = '0' if i % 2 == 0 else '1'\n        if s[i] != expected:\n            flips_pattern_0 += 1\n    \n    # Count flips needed for pattern starting with '1'\n    flips_pattern_1 = 0\n    for i in range(n):\n        expected = '1' if i % 2 == 0 else '0'\n        if s[i] != expected:\n            flips_pattern_1 += 1\n    \n    return min(flips_pattern_0, flips_pattern_1)",
    "assertion_results": [
      {
        "assertion": "assert min_flip_to_make_string_alternate(\"0001010111\") == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert min_flip_to_make_string_alternate(\"001\") == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert min_flip_to_make_string_alternate(\"010111011\") == 2 ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 362,
    "generated_code": "def max_occurrences(lst):\n    from collections import Counter\n    \n    # Count occurrences of each item\n    count_dict = Counter(lst)\n    \n    # Find the maximum count\n    max_count = max(count_dict.values())\n    \n    # Find all items with maximum count\n    max_items = [item for item, count in count_dict.items() if count == max_count]\n    \n    # If there's only one item with max count, return it\n    if len(max_items) == 1:\n        return max_items[0]\n    \n    # If there are multiple items with max count, return them as a tuple\n    return tuple(sorted(max_items))",
    "assertion_results": [
      {
        "assertion": "assert max_occurrences([1,2,3,1,2,3,12,4,2]) ==  2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_occurrences([1,2,6,7,0,1,0,1,0]) == 1,0",
        "status": "FAILED",
        "error": "AssertionError: 0",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_occurrences([1,2,3,1,2,4,1]) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 374,
    "generated_code": "def permute_string(s):\n    if len(s) <= 1:\n        return [s]\n    \n    result = []\n    for i in range(len(s)):\n        char = s[i]\n        remaining = s[:i] + s[i+1:]\n        for perm in permute_string(remaining):\n            result.append(char + perm)\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert permute_string('ab')==['ab', 'ba']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert permute_string('abc')==['abc', 'bac', 'bca', 'acb', 'cab', 'cba']",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert permute_string('abcd')==['abcd', 'bacd', 'bcad', 'bcda', 'acbd', 'cabd', 'cbad', 'cbda', 'acdb', 'cadb', 'cdab', 'cdba', 'abdc', 'badc', 'bdac', 'bdca', 'adbc', 'dabc', 'dbac', 'dbca', 'adcb', 'dacb', 'dcab', 'dcba']",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 381,
    "generated_code": "def index_on_inner_list(lst, index):\n    return sorted(lst, key=lambda x: x[index])",
    "assertion_results": [
      {
        "assertion": "assert index_on_inner_list([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,0)==[('Beau Turnbull', 94, 98), ('Brady Kent', 97, 96), ('Greyson Fulton', 98, 99), ('Wyatt Knott', 91, 94)]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert index_on_inner_list([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,1)==[('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98), ('Brady Kent', 97, 96), ('Greyson Fulton', 98, 99)]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert index_on_inner_list([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,2)==[('Wyatt Knott', 91, 94), ('Brady Kent', 97, 96), ('Beau Turnbull', 94, 98), ('Greyson Fulton', 98, 99)]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 379,
    "generated_code": "def surfacearea_cuboid(length, width, height):\n    return 2 * (length * width + length * height + width * height)",
    "assertion_results": [
      {
        "assertion": "assert surfacearea_cuboid(1,2,3)==22",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert surfacearea_cuboid(5,7,9)==286",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert surfacearea_cuboid(10,15,21)==1350",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 378,
    "generated_code": "def move_first(lst):\n    if len(lst) <= 1:\n        return lst\n    return [lst[-1]] + lst[:-1]",
    "assertion_results": [
      {
        "assertion": "assert move_first([1,2,3,4]) == [4,1,2,3]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert move_first([0,1,2,3]) == [3,0,1,2]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert move_first([9,8,7,1]) == [1,9,8,7]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 377,
    "generated_code": "def remove_Char(string, char):\n    return string.replace(char, '')",
    "assertion_results": [
      {
        "assertion": "assert remove_Char(\"aba\",'a') == \"b\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_Char(\"toggle\",'g') == \"tole\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_Char(\"aabbc\",'b') == \"aac\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 318,
    "generated_code": "def max_volume(sum_sides):\n    if sum_sides < 3:\n        return 0\n    \n    max_vol = 0\n    \n    # Try all possible combinations of three positive integers that sum to sum_sides\n    for l in range(1, sum_sides - 1):\n        for w in range(1, sum_sides - l):\n            h = sum_sides - l - w\n            if h > 0:\n                volume = l * w * h\n                max_vol = max(max_vol, volume)\n    \n    return max_vol",
    "assertion_results": [
      {
        "assertion": "assert max_volume(8) == 18",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_volume(4) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_volume(1) == 0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 380,
    "generated_code": "def multi_list(rows, cols):\n    result = []\n    for i in range(rows):\n        row = []\n        for j in range(cols):\n            row.append(i * j)\n        result.append(row)\n    return result",
    "assertion_results": [
      {
        "assertion": "assert multi_list(3,4)==[[0, 0, 0, 0], [0, 1, 2, 3], [0, 2, 4, 6]] ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert multi_list(5,7)==[[0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 3, 4, 5, 6], [0, 2, 4, 6, 8, 10, 12], [0, 3, 6, 9, 12, 15, 18], [0, 4, 8, 12, 16, 20, 24]]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert multi_list(10,15)==[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28], [0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42], [0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56], [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70], [0, 6, 12, 18, 24, 30, 36, 42, 48, 54, 60, 66, 72, 78, 84], [0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 70, 77, 84, 91, 98], [0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112], [0, 9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99, 108, 117, 126]]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 371,
    "generated_code": "def smallest_missing(arr, start, end):\n    # Binary search approach to find the smallest missing element\n    left = start\n    right = end\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        # If arr[mid] == mid, then missing element is on the right side\n        if arr[mid] == mid:\n            left = mid + 1\n        # If arr[mid] > mid, then missing element is on the left side\n        else:\n            right = mid - 1\n    \n    return left",
    "assertion_results": [
      {
        "assertion": "assert smallest_missing([0, 1, 2, 3, 4, 5, 6], 0, 6) == 7",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert smallest_missing([0, 1, 2, 6, 9, 11, 15], 0, 6) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert smallest_missing([1, 2, 3, 4, 6, 9, 11, 15], 0, 7) == 0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 384,
    "generated_code": "def frequency_Of_Smallest(n, arr):\n    min_value = min(arr)\n    count = 0\n    for value in arr:\n        if value == min_value:\n            count += 1\n    return count",
    "assertion_results": [
      {
        "assertion": "assert frequency_Of_Smallest(5,[1,2,3,4,3]) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert frequency_Of_Smallest(7,[3,1,2,5,6,2,3]) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert frequency_Of_Smallest(7,[3,3,6,3,7,4,9]) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 346,
    "generated_code": "def zigzag(n, k):\n    # Create a table to store Entringer numbers\n    # e[i][j] represents the Entringer number e(i, j)\n    e = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\n    \n    # Base case: e(0, 0) = 1\n    e[0][0] = 1\n    \n    # Fill the table using the recurrence relation\n    for i in range(1, n + 1):\n        for j in range(min(i + 1, k + 1)):\n            if j == 0:\n                # e(n, 0) = e(n-1, n-1) for n >= 1\n                if i - 1 < len(e) and i - 1 < len(e[i - 1]):\n                    e[i][j] = e[i - 1][i - 1]\n            else:\n                # e(n, k) = e(n, k-1) + e(n-1, n-k) for k >= 1\n                if j - 1 >= 0 and i - (i - j) >= 0 and i - (i - j) < len(e) and i - j < len(e[i - (i - j)]):\n                    e[i][j] = e[i][j - 1] + e[i - 1][i - j]\n    \n    return e[n][k]",
    "assertion_results": [
      {
        "assertion": "assert zigzag(4, 3) == 5",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert zigzag(4, 2) == 4",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert zigzag(3, 1) == 1",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 388,
    "generated_code": "def highest_Power_of_2(n):\n    if n <= 0:\n        return 0\n    \n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    \n    return power",
    "assertion_results": [
      {
        "assertion": "assert highest_Power_of_2(10) == 8",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert highest_Power_of_2(19) == 16",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert highest_Power_of_2(32) == 32",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 385,
    "generated_code": "def get_perrin(n):\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return get_perrin(n-2) + get_perrin(n-3)",
    "assertion_results": [
      {
        "assertion": "assert get_perrin(9) == 12",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_perrin(4) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_perrin(6) == 5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 387,
    "generated_code": "def even_or_odd(hex_string):\n    # Convert hexadecimal string to integer\n    decimal_value = int(hex_string, 16)\n    \n    # Check if the decimal value is even or odd\n    if decimal_value % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"",
    "assertion_results": [
      {
        "assertion": "assert even_or_odd(\"AB3454D\") ==\"Odd\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert even_or_odd(\"ABC\") == \"Even\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert even_or_odd(\"AAD\") == \"Odd\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 367,
    "generated_code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_tree_balanced(root):\n    def check_height(node):\n        if not node:\n            return 0\n        \n        left_height = check_height(node.left)\n        if left_height == -1:\n            return -1\n        \n        right_height = check_height(node.right)\n        if right_height == -1:\n            return -1\n        \n        if abs(left_height - right_height) > 1:\n            return -1\n        \n        return max(left_height, right_height) + 1\n    \n    return check_height(root) != -1\n\n# Test cases\n# Unbalanced tree\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.left.left = TreeNode(3)\n\n# Balanced tree\nroot1 = TreeNode(1)\nroot1.left = TreeNode(2)\nroot1.right = TreeNode(3)\n\n# Unbalanced tree\nroot2 = TreeNode(1)\nroot2.right = TreeNode(2)\nroot2.right.right = TreeNode(3)\nroot2.right.right.right = TreeNode(4)",
    "assertion_results": [
      {
        "assertion": "assert is_tree_balanced(root) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_tree_balanced(root1) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_tree_balanced(root2) == False ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 376,
    "generated_code": "def remove_replica(tup):\n    # Count occurrences of each element\n    count_dict = {}\n    for item in tup:\n        count_dict[item] = count_dict.get(item, 0) + 1\n    \n    # Track how many times we've seen each element\n    seen_count = {}\n    result = []\n    \n    for item in tup:\n        seen_count[item] = seen_count.get(item, 0) + 1\n        \n        # If this is the first occurrence, keep it\n        if seen_count[item] == 1:\n            result.append(item)\n        # If this is a duplicate, replace with 'MSP'\n        else:\n            result.append('MSP')\n    \n    return tuple(result)",
    "assertion_results": [
      {
        "assertion": "assert remove_replica((1, 1, 4, 4, 4, 5, 5, 6, 7, 7)) == (1, 'MSP', 4, 'MSP', 'MSP', 5, 'MSP', 6, 7, 'MSP')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_replica((2, 3, 4, 4, 5, 6, 6, 7, 8, 9, 9)) == (2, 3, 4, 'MSP', 5, 6, 'MSP', 7, 8, 9, 'MSP')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_replica((2, 2, 5, 4, 5, 7, 5, 6, 7, 7)) == (2, 'MSP', 5, 4, 'MSP', 7, 'MSP', 6, 'MSP', 'MSP')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 390,
    "generated_code": "def add_string(lst, template):\n    return [template.format(item) for item in lst]",
    "assertion_results": [
      {
        "assertion": "assert add_string([1,2,3,4],'temp{0}')==['temp1', 'temp2', 'temp3', 'temp4']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert add_string(['a','b','c','d'], 'python{0}')==[ 'pythona', 'pythonb', 'pythonc', 'pythond']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert add_string([5,6,7,8],'string{0}')==['string5', 'string6', 'string7', 'string8']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 394,
    "generated_code": "def check_distinct(tuple_input):\n    return len(tuple_input) == len(set(tuple_input))",
    "assertion_results": [
      {
        "assertion": "assert check_distinct((1, 4, 5, 6, 1, 4)) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_distinct((1, 4, 5, 6)) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_distinct((2, 3, 4, 5, 6)) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 393,
    "generated_code": "def max_length_list(lists):\n    max_list = max(lists, key=lambda x: len(x))\n    return (len(max_list), max_list)",
    "assertion_results": [
      {
        "assertion": "assert max_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])==(5,[1,2,3,4,5])",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_length_list([[3,4,5],[6,7,8,9],[10,11,12]])==(4,[6,7,8,9])",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 389,
    "generated_code": "def find_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    a, b = 2, 1\n    for i in range(2, n + 1):\n        a, b = b, a + b\n    \n    return b",
    "assertion_results": [
      {
        "assertion": "assert find_lucas(9) == 76",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_lucas(4) == 7",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_lucas(3) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 391,
    "generated_code": "def convert_list_dictionary(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        nested_dict = {list1[i]: {list2[i]: list3[i]}}\n        result.append(nested_dict)\n    return result",
    "assertion_results": [
      {
        "assertion": "assert convert_list_dictionary([\"S001\", \"S002\", \"S003\", \"S004\"],[\"Adina Park\", \"Leyton Marsh\", \"Duncan Boyle\", \"Saim Richards\"] ,[85, 98, 89, 92])==[{'S001': {'Adina Park': 85}}, {'S002': {'Leyton Marsh': 98}}, {'S003': {'Duncan Boyle': 89}}, {'S004': {'Saim Richards': 92}}]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert convert_list_dictionary([\"abc\",\"def\",\"ghi\",\"jkl\"],[\"python\",\"program\",\"language\",\"programs\"],[100,200,300,400])==[{'abc':{'python':100}},{'def':{'program':200}},{'ghi':{'language':300}},{'jkl':{'programs':400}}]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert convert_list_dictionary([\"A1\",\"A2\",\"A3\",\"A4\"],[\"java\",\"C\",\"C++\",\"DBMS\"],[10,20,30,40])==[{'A1':{'java':10}},{'A2':{'C':20}},{'A3':{'C++':30}},{'A4':{'DBMS':40}}]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 355,
    "generated_code": "def count_Rectangles(r):\n    if r == 0:\n        return 0\n    \n    count = 0\n    \n    # Check all possible bottom-left corners (i,j) where the rectangle could fit\n    for i in range(-r, r):\n        for j in range(-r, r):\n            # Check if all four corners of the unit rectangle are within the circle\n            corners = [(i, j), (i+1, j), (i, j+1), (i+1, j+1)]\n            if all(x*x + y*y <= r*r for x, y in corners):\n                count += 1\n    \n    return count",
    "assertion_results": [
      {
        "assertion": "assert count_Rectangles(2) == 8",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Rectangles(1) == 1",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Rectangles(0) == 0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 399,
    "generated_code": "def bitwise_xor(tuple1, tuple2):\n    return tuple(a ^ b for a, b in zip(tuple1, tuple2))",
    "assertion_results": [
      {
        "assertion": "assert bitwise_xor((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert bitwise_xor((11, 5, 7, 10), (6, 3, 4, 4)) == (13, 6, 3, 14)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert bitwise_xor((12, 6, 8, 11), (7, 4, 5, 6)) == (11, 2, 13, 13)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 396,
    "generated_code": "import re\n\ndef check_char(s):\n    if re.match(r'^(.).*\\1$|^.$', s):\n        return \"Valid\"\n    else:\n        return \"Invalid\"",
    "assertion_results": [
      {
        "assertion": "assert check_char(\"abba\") == \"Valid\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_char(\"a\") == \"Valid\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_char(\"abcd\") == \"Invalid\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 382,
    "generated_code": "def find_rotation_count(arr):\n    if not arr:\n        return 0\n    \n    left, right = 0, len(arr) - 1\n    \n    # If array is not rotated\n    if arr[left] <= arr[right]:\n        return 0\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        # Check if mid is the minimum element\n        if mid > 0 and arr[mid] < arr[mid - 1]:\n            return mid\n        \n        # Check if mid+1 is the minimum element\n        if mid < len(arr) - 1 and arr[mid] > arr[mid + 1]:\n            return mid + 1\n        \n        # If left half is sorted, minimum is in right half\n        if arr[left] <= arr[mid]:\n            left = mid + 1\n        # Otherwise, minimum is in left half\n        else:\n            right = mid - 1\n    \n    return 0",
    "assertion_results": [
      {
        "assertion": "assert find_rotation_count([8, 9, 10, 1, 2, 3, 4, 5, 6, 7]) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_rotation_count([8, 9, 10,2, 5, 6]) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_rotation_count([2, 5, 6, 8, 9, 10]) == 0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 398,
    "generated_code": "def sum_of_digits(lst):\n    def get_digit_sum(num):\n        return sum(int(digit) for digit in str(abs(num)))\n    \n    def process_item(item):\n        if isinstance(item, int):\n            return get_digit_sum(item)\n        elif isinstance(item, list):\n            return sum(process_item(sub_item) for sub_item in item)\n        else:\n            return 0\n    \n    return sum(process_item(item) for item in lst)",
    "assertion_results": [
      {
        "assertion": "assert sum_of_digits([10,2,56])==14",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_of_digits([[10,20,4,5,'b',70,'a']])==19",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_of_digits([10,20,-4,5,-70])==19",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 405,
    "generated_code": "def check_tuplex(tuple_x, element):\n    return element in tuple_x",
    "assertion_results": [
      {
        "assertion": "assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"),'r')==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"),'5')==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\",\"e\"),3)==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 392,
    "generated_code": "def get_max_sum(n):\n    memo = {}\n    \n    def helper(n):\n        if n in memo:\n            return memo[n]\n        \n        if n <= 1:\n            memo[n] = n\n            return n\n        \n        # Calculate f(n/2) + f(n/3) + f(n/4) + f(n/5)\n        sum_parts = helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5)\n        \n        # Return max of sum_parts and n\n        result = max(sum_parts, n)\n        memo[n] = result\n        return result\n    \n    return helper(n)",
    "assertion_results": [
      {
        "assertion": "assert get_max_sum(60) == 106",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_max_sum(10) == 12",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_max_sum(2) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 401,
    "generated_code": "def add_nested_tuples(tuple1, tuple2):\n    result = []\n    for i in range(len(tuple1)):\n        inner_tuple = tuple(tuple1[i][j] + tuple2[i][j] for j in range(len(tuple1[i])))\n        result.append(inner_tuple)\n    return tuple(result)",
    "assertion_results": [
      {
        "assertion": "assert add_nested_tuples(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((7, 10), (7, 14), (3, 10), (8, 13))",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert add_nested_tuples(((2, 4), (5, 6), (3, 10), (2, 11)), ((7, 8), (4, 10), (2, 2), (8, 4))) == ((9, 12), (9, 16), (5, 12), (10, 15))",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert add_nested_tuples(((3, 5), (6, 7), (4, 11), (3, 12)), ((8, 9), (5, 11), (3, 3), (9, 5))) == ((11, 14), (11, 18), (7, 14), (12, 17))",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 386,
    "generated_code": "def swap_count(s):\n    # Remove all characters that are not brackets\n    brackets = ''.join(c for c in s if c in '[]')\n    \n    # Count unmatched opening and closing brackets\n    open_count = 0\n    unmatched_close = 0\n    \n    for char in brackets:\n        if char == '[':\n            open_count += 1\n        else:  # char == ']'\n            if open_count > 0:\n                open_count -= 1\n            else:\n                unmatched_close += 1\n    \n    # After processing, open_count contains unmatched opening brackets\n    # unmatched_close contains unmatched closing brackets\n    \n    # To balance, we need to swap half of unmatched closing brackets\n    # with half of unmatched opening brackets\n    return (unmatched_close + 1) // 2",
    "assertion_results": [
      {
        "assertion": "assert swap_count(\"[]][][\") == 2",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert swap_count(\"[[][]]\") == 0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert swap_count(\"[[][]]][\") == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 406,
    "generated_code": "def find_Parity(n):\n    if n % 2 == 0:\n        return \"Even Parity\"\n    else:\n        return \"Odd Parity\"",
    "assertion_results": [
      {
        "assertion": "assert find_Parity(12) == \"Even Parity\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_Parity(7) == \"Odd Parity\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_Parity(10) == \"Even Parity\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 354,
    "generated_code": "Looking at the test cases, I need to understand the pattern:\n\n- `tn_ap(1,5,2)==9`: This suggests finding the 2nd term of an AP with first term 1 and common difference 5\n- `tn_ap(2,6,4)==22`: This suggests finding the 4th term of an AP with first term 2 and common difference 6  \n- `tn_ap(1,4,5)==16`: This suggests finding the 5th term of an AP with first term 1 and common difference 4\n\nThe formula for the nth term of an arithmetic progression is: `a_n = a_1 + (n-1) * d`\n\nWhere:\n- `a_1` is the first term\n- `d` is the common difference\n- `n` is the term number\n\nLet me verify:\n- `tn_ap(1,5,2)`: 1 + (2-1)*5 = 1 + 5 = 6 \u2260 9\n- Let me try: 1 + 2*5 = 11 \u2260 9\n- Maybe it's: 1 + (2+1)*5 = 1 + 15 = 16 \u2260 9\n\nLet me reconsider the parameter order. Maybe it's `tn_ap(first_term, common_difference, term_number)`:\n- `tn_ap(1,5,2)`: 1 + (2-1)*5 = 6 \u2260 9\n\nLet me try a different interpretation. Looking at the results:\n- For (1,5,2)\u21929: Maybe 1 + 2*4 = 9, so d=4? No.\n- Let me try: (1-1)*5 + 2*something = 9, so 2*something = 9, something = 4.5\n\nActually, let me check if it's `first_term + (term_number-1) * common_difference`:\n- `tn_ap(1,5,2)`: 1 + (2-1)*5 = 6 \u2260",
    "assertion_results": []
  },
  {
    "task_id": 404,
    "generated_code": "def minimum(a, b):\n    if a < b:\n        return a\n    else:\n        return b",
    "assertion_results": [
      {
        "assertion": "assert minimum(1,2) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert minimum(-5,-4) == -5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert minimum(0,0) == 0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 403,
    "generated_code": "import re\n\ndef is_valid_URL(url):\n    pattern = r'^https?://[^\\s/$.?#].[^\\s]*$'\n    return bool(re.match(pattern, url))",
    "assertion_results": [
      {
        "assertion": "assert is_valid_URL(\"https://www.google.com\") == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_valid_URL(\"https:/www.gmail.com\") == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_valid_URL(\"https:// www.redit.com\") == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 409,
    "generated_code": "def min_product_tuple(tuples_list):\n    min_product = float('inf')\n    \n    for tuple_item in tuples_list:\n        product = tuple_item[0] * tuple_item[1]\n        if product < min_product:\n            min_product = product\n    \n    return min_product",
    "assertion_results": [
      {
        "assertion": "assert min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==8",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert min_product_tuple([(10,20), (15,2), (5,10)] )==30",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert min_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==100",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 397,
    "generated_code": "def median_numbers(a, b, c):\n    numbers = [a, b, c]\n    numbers.sort()\n    return float(numbers[1])",
    "assertion_results": [
      {
        "assertion": "assert median_numbers(25,55,65)==55.0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert median_numbers(20,10,30)==20.0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert median_numbers(15,45,75)==45.0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 395,
    "generated_code": "def first_non_repeating_character(s):\n    char_count = {}\n    \n    # Count frequency of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find first character with count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    return None",
    "assertion_results": [
      {
        "assertion": "assert first_non_repeating_character(\"abcabc\") == None",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert first_non_repeating_character(\"abc\") == \"a\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert first_non_repeating_character(\"ababc\") == \"c\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 360,
    "generated_code": "def get_carol(n):\n    return (2**n - 1)**2 - 2",
    "assertion_results": [
      {
        "assertion": "assert get_carol(2) == 7",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_carol(4) == 223",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_carol(5) == 959",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 410,
    "generated_code": "def min_val(lst):\n    numeric_values = []\n    for item in lst:\n        if isinstance(item, (int, float)):\n            numeric_values.append(item)\n    \n    if numeric_values:\n        return min(numeric_values)\n    else:\n        return None",
    "assertion_results": [
      {
        "assertion": "assert min_val(['Python', 3, 2, 4, 5, 'version'])==2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert min_val(['Python', 15, 20, 25])==15",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert min_val(['Python', 30, 20, 40, 50, 'version'])==20",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 412,
    "generated_code": "def remove_odd(lst):\n    return [num for num in lst if num % 2 == 0]",
    "assertion_results": [
      {
        "assertion": "assert remove_odd([1,2,3]) == [2]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_odd([2,4,6]) == [2,4,6]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_odd([10,20,3]) == [10,20]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 413,
    "generated_code": "def extract_nth_element(list_of_tuples, n):\n    return [tuple[n] for tuple in list_of_tuples]",
    "assertion_results": [
      {
        "assertion": "assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,0)==['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,2)==[99, 96, 94, 98]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)],1)==[98, 97, 91, 94]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 411,
    "generated_code": "import re\n\ndef snake_to_camel(snake_str):\n    return re.sub(r'_([a-z])', lambda m: m.group(1).upper(), snake_str.title())",
    "assertion_results": [
      {
        "assertion": "assert snake_to_camel('android_tv') == 'AndroidTv'",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert snake_to_camel('google_pixel') == 'GooglePixel'",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert snake_to_camel('apple_watch') == 'AppleWatch'",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 422,
    "generated_code": "def find_Average_Of_Cube(n):\n    total = sum(i**3 for i in range(1, n+1))\n    return total / n",
    "assertion_results": [
      {
        "assertion": "assert find_Average_Of_Cube(2) == 4.5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_Average_Of_Cube(3) == 12",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_Average_Of_Cube(1) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 414,
    "generated_code": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False",
    "assertion_results": [
      {
        "assertion": "assert overlapping([1,2,3,4,5],[6,7,8,9]) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert overlapping([1,2,3],[4,5,6]) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert overlapping([1,4,5],[1,4,5]) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 421,
    "generated_code": "def concatenate_tuple(tup):\n    return '-'.join(str(element) for element in tup)",
    "assertion_results": [
      {
        "assertion": "assert concatenate_tuple((\"ID\", \"is\", 4, \"UTS\") ) == 'ID-is-4-UTS'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert concatenate_tuple((\"QWE\", \"is\", 4, \"RTY\") ) == 'QWE-is-4-RTY'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert concatenate_tuple((\"ZEN\", \"is\", 4, \"OP\") ) == 'ZEN-is-4-OP'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 418,
    "generated_code": "def Find_Max(lst):\n    max_length = 0\n    max_sublist = []\n    \n    for sublist in lst:\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n            max_sublist = sublist\n    \n    return max_sublist",
    "assertion_results": [
      {
        "assertion": "assert Find_Max([['A'],['A','B'],['A','B','C']]) == ['A','B','C']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert Find_Max([[1],[1,2],[1,2,3]]) == [1,2,3]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert Find_Max([[1,1],[1,2,3],[1,5,6,1]]) == [1,5,6,1]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 419,
    "generated_code": "def round_and_sum(numbers):\n    rounded_numbers = [round(num) for num in numbers]\n    total_sum = sum(rounded_numbers)\n    return total_sum * len(numbers)",
    "assertion_results": [
      {
        "assertion": "assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert round_and_sum([5,2,9,24.3,29])==345",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert round_and_sum([25.0,56.7,89.2])==513",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 425,
    "generated_code": "def count_element_in_list(list_of_lists, element):\n    return sum(1 for sublist in list_of_lists if element in sublist)",
    "assertion_results": [
      {
        "assertion": "assert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]],1)==3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_element_in_list([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']],'A')==3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_element_in_list([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']],'E')==1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 424,
    "generated_code": "def extract_rear(tuple_of_strings):\n    return [string[-1] for string in tuple_of_strings]",
    "assertion_results": [
      {
        "assertion": "assert extract_rear(('Mers', 'for', 'Vers') ) == ['s', 'r', 's']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert extract_rear(('Avenge', 'for', 'People') ) == ['e', 'r', 'e']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert extract_rear(('Gotta', 'get', 'go') ) == ['a', 't', 'o']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 420,
    "generated_code": "def cube_Sum(n):\n    total = 0\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        total += even_number ** 3\n    return total",
    "assertion_results": [
      {
        "assertion": "assert cube_Sum(2) == 72",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert cube_Sum(3) == 288",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert cube_Sum(4) == 800",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 348,
    "generated_code": "def find_ways(n):\n    if n % 2 != 0:\n        return 0\n    \n    k = n // 2\n    \n    # Calculate k-th Catalan number using the formula: C(k) = (2k)! / ((k+1)! * k!)\n    # Or equivalently: C(k) = C(2k, k) / (k+1) where C(n,r) is binomial coefficient\n    \n    def factorial(x):\n        if x <= 1:\n            return 1\n        result = 1\n        for i in range(2, x + 1):\n            result *= i\n        return result\n    \n    def binomial(n, r):\n        if r > n or r < 0:\n            return 0\n        if r == 0 or r == n:\n            return 1\n        \n        # Use the more efficient formula\n        result = 1\n        for i in range(min(",
    "assertion_results": []
  },
  {
    "task_id": 415,
    "generated_code": "def max_Product(arr):\n    if len(arr) < 2:\n        return None\n    \n    max_product = float('-inf')\n    result_pair = None\n    \n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            product = arr[i] * arr[j]\n            if product > max_product:\n                max_product = product\n                result_pair = (arr[i], arr[j])\n    \n    return result_pair",
    "assertion_results": [
      {
        "assertion": "assert max_Product([1,2,3,4,7,0,8,4]) == (7,8)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_Product([0,-1,-2,-4,5,0,-6]) == (-4,-6)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_Product([1,2,3]) == (2,3)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 426,
    "generated_code": "def filter_oddnumbers(numbers):\n    return list(filter(lambda x: x % 2 == 1, numbers))",
    "assertion_results": [
      {
        "assertion": "assert filter_oddnumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1,3,5,7,9]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert filter_oddnumbers([10,20,45,67,84,93])==[45,67,93]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert filter_oddnumbers([5,7,9,8,6,4,3])==[5,7,9,3]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 427,
    "generated_code": "import re\n\ndef change_date_format(date_string):\n    pattern = r'(\\d{4})-(\\d{2})-(\\d{2})'\n    replacement = r'\\3-\\2-\\1'\n    return re.sub(pattern, replacement, date_string)",
    "assertion_results": [
      {
        "assertion": "assert change_date_format(\"2026-01-02\") == '02-01-2026'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert change_date_format(\"2020-11-13\") == '13-11-2020'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert change_date_format(\"2021-04-26\") == '26-04-2021'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 400,
    "generated_code": "def extract_freq(tuple_list):\n    normalized_tuples = set()\n    for tup in tuple_list:\n        normalized = tuple(sorted(tup))\n        normalized_tuples.add(normalized)\n    return len(normalized_tuples)",
    "assertion_results": [
      {
        "assertion": "assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 428,
    "generated_code": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            \n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            arr[j] = temp\n        \n        gap //= 2\n    \n    return arr",
    "assertion_results": [
      {
        "assertion": "assert shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert shell_sort([24, 22, 39, 34, 87, 73, 68]) == [22, 24, 34, 39, 68, 73, 87]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert shell_sort([32, 30, 16, 96, 82, 83, 74]) == [16, 30, 32, 74, 82, 83, 96]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 234,
    "generated_code": "def volume_cube(side_length):\n    return side_length ** 3",
    "assertion_results": [
      {
        "assertion": "assert volume_cube(3)==27",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert volume_cube(2)==8",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert volume_cube(5)==125",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 435,
    "generated_code": "def last_Digit(number):\n    return number % 10",
    "assertion_results": [
      {
        "assertion": "assert last_Digit(123) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert last_Digit(25) == 5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert last_Digit(30) == 0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 436,
    "generated_code": "def neg_nos(lst):\n    return [i for i in lst if i < 0]",
    "assertion_results": [
      {
        "assertion": "assert neg_nos([-1,4,5,-6]) == -1,-6",
        "status": "FAILED",
        "error": "AssertionError: -6",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert neg_nos([-1,-2,3,4]) == -1,-2",
        "status": "FAILED",
        "error": "AssertionError: -2",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert neg_nos([-7,-6,8,9]) == -7,-6",
        "status": "FAILED",
        "error": "AssertionError: -6",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 431,
    "generated_code": "def common_element(list1, list2):\n    for element in list1:\n        if element in list2:\n            return True\n    return None",
    "assertion_results": [
      {
        "assertion": "assert common_element([1,2,3,4,5], [5,6,7,8,9])==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert common_element([1,2,3,4,5], [6,7,8,9])==None",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert common_element(['a','b','c'], ['d','b','e'])==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 434,
    "generated_code": "import re\n\ndef text_match_one(text):\n    pattern = r'ab+'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
    "assertion_results": [
      {
        "assertion": "assert text_match_one(\"ac\")==('Not matched!')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert text_match_one(\"dc\")==('Not matched!')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert text_match_one(\"abba\")==('Found a match!')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 433,
    "generated_code": "def check_greater(arr, num):\n    if num > max(arr):\n        return 'Yes, the entered number is greater than those in the array'\n    else:\n        return 'No, entered number is less than those in the array'",
    "assertion_results": [
      {
        "assertion": "assert check_greater([1, 2, 3, 4, 5], 4) == 'No, entered number is less than those in the array'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_greater([2, 3, 4, 5, 6], 8) == 'Yes, the entered number is greater than those in the array'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_greater([9, 7, 4, 8, 6, 1], 11) == 'Yes, the entered number is greater than those in the array'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 441,
    "generated_code": "def surfacearea_cube(side):\n    return 6 * side * side",
    "assertion_results": [
      {
        "assertion": "assert surfacearea_cube(5)==150",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert surfacearea_cube(3)==54",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert surfacearea_cube(10)==600",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 439,
    "generated_code": "def multiple_to_single(lst):\n    result = \"\"\n    for num in lst:\n        result += str(num)\n    return int(result)",
    "assertion_results": [
      {
        "assertion": "assert multiple_to_single([11, 33, 50])==113350",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert multiple_to_single([-1,2,3,4,5,6])==-123456",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert multiple_to_single([10,15,20,25])==10152025",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 383,
    "generated_code": "def even_bit_toggle_number(n):\n    # Create a mask with 1s at even positions (0, 2, 4, 6, ...)\n    # Pattern: ...01010101 (0x55555555 for 32-bit)\n    mask = 0x55555555\n    \n    # XOR with the mask to toggle even-positioned bits\n    return n ^ mask",
    "assertion_results": [
      {
        "assertion": "assert even_bit_toggle_number(10) == 15",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert even_bit_toggle_number(20) == 1",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert even_bit_toggle_number(30) == 11",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 444,
    "generated_code": "def trim_tuple(tuple_list, k):\n    result = []\n    for tup in tuple_list:\n        trimmed = tup[k:-k] if k < len(tup) // 2 else ()\n        result.append(trimmed)\n    return str(result)",
    "assertion_results": [
      {
        "assertion": "assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1),(9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 2) == '[(2,), (9,), (2,), (2,)]'",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 1) == '[(3, 2, 1), (4, 9, 2), (1, 2, 3), (8, 2, 1)]'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert trim_tuple([(7, 8, 4, 9), (11, 8, 12, 4),(4, 1, 7, 8), (3, 6, 9, 7)], 1) == '[(8, 4), (8, 12), (1, 7), (6, 9)]'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 417,
    "generated_code": "def group_tuples(tuples_list):\n    from collections import defaultdict\n    \n    # Group tuples by their first element\n    groups = defaultdict(list)\n    \n    for tup in tuples_list:\n        first_element = tup[0]\n        remaining_elements = tup[1:]\n        groups[first_element].extend(remaining_elements)\n    \n    # Build result list maintaining original order\n    result = []\n    seen = set()\n    \n    for tup in tuples_list:\n        first_element = tup[0]\n        if first_element not in seen:\n            seen.add(first_element)\n            grouped_tuple = (first_element,) + tuple(groups[first_element])\n            result.append(grouped_tuple)\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert group_tuples([('x', 'y'), ('x', 'z'), ('w', 't')]) == [('x', 'y', 'z'), ('w', 't')]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert group_tuples([('a', 'b'), ('a', 'c'), ('d', 'e')]) == [('a', 'b', 'c'), ('d', 'e')]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert group_tuples([('f', 'g'), ('f', 'g'), ('h', 'i')]) == [('f', 'g', 'g'), ('h', 'i')]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 442,
    "generated_code": "def positive_count(arr):\n    positive_numbers = 0\n    total_numbers = len(arr)\n    \n    for num in arr:\n        if num > 0:\n            positive_numbers += 1\n    \n    return round(positive_numbers / total_numbers, 2)",
    "assertion_results": [
      {
        "assertion": "assert positive_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])==0.54",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert positive_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==0.69",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert positive_count([2, 4, -6, -9, 11, -12, 14, -5, 17])==0.56",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 443,
    "generated_code": "def largest_neg(lst):\n    negative_numbers = [num for num in lst if num < 0]\n    if not negative_numbers:\n        return None\n    return max(negative_numbers)",
    "assertion_results": [
      {
        "assertion": "assert largest_neg([1,2,3,-4,-6]) == -6",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert largest_neg([1,2,3,-8,-9]) == -9",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert largest_neg([1,2,3,4,-1]) == -1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 446,
    "generated_code": "def count_Occurrence(tuple_data, list_data):\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count",
    "assertion_results": [
      {
        "assertion": "assert count_Occurrence(('a', 'a', 'c', 'b', 'd'),['a', 'b'] ) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Occurrence((1, 2, 3, 1, 4, 6, 7, 1, 4),[1, 4, 7]) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert count_Occurrence((1,2,3,4,5,6),[1,2]) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 447,
    "generated_code": "def cube_nums(nums):\n    return list(map(lambda x: x**3, nums))",
    "assertion_results": [
      {
        "assertion": "assert cube_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert cube_nums([10,20,30])==([1000, 8000, 27000])",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert cube_nums([12,15])==([1728, 3375])",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 423,
    "generated_code": "def get_maxgold(grid, m, n):\n    # Create a DP table to store maximum gold that can be collected\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    \n    # Fill the rightmost column\n    for i in range(m):\n        dp[i][n-1] = grid[i][n-1]\n    \n    # Fill the DP table from right to left\n    for j in range(n-2, -1, -1):\n        for i in range(m):\n            # Three possible moves: right, right-up diagonal, right-down diagonal\n            right = dp[i][j+1]\n            right_up = dp[i-1][j+1] if i > 0 else 0\n            right_down = dp[i+1][j+1] if i < m-1 else 0\n            \n            dp[i][j] = grid[i][j] + max(right, right_up, right_down)\n    \n    # Find maximum value in the first column\n    max_gold = 0\n    for i in range(m):\n        max_gold = max(max_gold, dp[i][0])\n    \n    return max_gold",
    "assertion_results": [
      {
        "assertion": "assert get_maxgold([[1, 3, 1, 5],[2, 2, 4, 1],[5, 0, 2, 3],[0, 6, 1, 2]],4,4)==16",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_maxgold([[10,20],[30,40]],2,2)==70",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_maxgold([[4,9],[3,7]],2,2)==13",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 430,
    "generated_code": "def parabola_directrix(a, b, c):\n    return -4 * a * b * c - 2 * (a**2 + b**2 + c**2)",
    "assertion_results": [
      {
        "assertion": "assert parabola_directrix(5,3,2)==-198",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert parabola_directrix(9,8,4)==-2336",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert parabola_directrix(2,4,6)==-130",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 407,
    "generated_code": "def rearrange_bigger(num):\n    digits = list(str(num))\n    n = len(digits)\n    \n    # Find the rightmost digit that is smaller than the digit next to it\n    i = n - 2\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n    \n    # If no such digit is found, return False\n    if i == -1:\n        return False\n    \n    # Find the smallest digit on right side of above character that is greater than digits[i]\n    j = n - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n    \n    # Swap the found characters\n    digits[i], digits[j] = digits[j], digits[i]\n    \n    # Reverse the substring after position i\n    digits[i + 1:] = reversed(digits[i + 1:])\n    \n    return int(''.join(digits))",
    "assertion_results": [
      {
        "assertion": "assert rearrange_bigger(12)==21",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert rearrange_bigger(10)==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert rearrange_bigger(102)==120",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 445,
    "generated_code": "def index_multiplication(tuple1, tuple2):\n    result = []\n    for i in range(len(tuple1)):\n        inner_tuple = []\n        for j in range(len(tuple1[i])):\n            inner_tuple.append(tuple1[i][j] * tuple2[i][j])\n        result.append(tuple(inner_tuple))\n    return tuple(result)",
    "assertion_results": [
      {
        "assertion": "assert index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)),((6, 7), (3, 9), (1, 1), (7, 3)) ) == ((6, 21), (12, 45), (2, 9), (7, 30))",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert index_multiplication(((2, 4), (5, 6), (3, 10), (2, 11)),((7, 8), (4, 10), (2, 2), (8, 4)) ) == ((14, 32), (20, 60), (6, 20), (16, 44))",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert index_multiplication(((3, 5), (6, 7), (4, 11), (3, 12)),((8, 9), (5, 11), (3, 3), (9, 5)) ) == ((24, 45), (30, 77), (12, 33), (27, 60))",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 440,
    "generated_code": "import re\n\ndef find_adverb_position(sentence):\n    # Find adverbs (words ending with 'ly') using regex\n    pattern = r'\\b\\w*ly\\b'\n    match = re.search(pattern, sentence, re.IGNORECASE)\n    \n    if match:\n        adverb = match.group()\n        start_pos = match.start()\n        end_pos = match.end() - 1\n        return (start_pos, end_pos, adverb.lower())\n    \n    return None",
    "assertion_results": [
      {
        "assertion": "assert find_adverb_position(\"clearly!! we can see the sky\")==(0, 7, 'clearly')",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_adverb_position(\"seriously!! there are many roses\")==(0, 9, 'seriously')",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_adverb_position(\"unfortunately!! sita is going to home\")==(0, 13, 'unfortunately')",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 451,
    "generated_code": "import re\n\ndef remove_whitespaces(string):\n    return re.sub(r'\\s+', '', string)",
    "assertion_results": [
      {
        "assertion": "assert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_whitespaces(' Google    Dart ') == 'GoogleDart'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_whitespaces(' iOS    Swift ') == 'iOSSwift'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 437,
    "generated_code": "def remove_odd(s):\n    return ''.join(s[i] for i in range(1, len(s), 2))",
    "assertion_results": [
      {
        "assertion": "assert remove_odd(\"python\")==(\"yhn\")",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_odd(\"program\")==(\"rga\")",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_odd(\"language\")==(\"agae\")",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 408,
    "generated_code": "import heapq\n\ndef k_smallest_pairs(nums1, nums2, k):\n    if not nums1 or not nums2 or k == 0:\n        return []\n    \n    # Min heap to store (sum, i, j) where i is index in nums1, j is index in nums2\n    heap = []\n    result = []\n    \n    # Initialize heap with pairs from first element of nums1 with all elements of nums2\n    for j in range(min(len(nums2), k)):\n        heapq.heappush(heap, (nums1[0] + nums2[j], 0, j))\n    \n    while heap and len(result) < k:\n        sum_val, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n        \n        # Add next pair from nums1 if possible\n        if i + 1 < len(nums1):\n            heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 458,
    "generated_code": "def rectangle_area(length, width):\n    return length * width",
    "assertion_results": [
      {
        "assertion": "assert rectangle_area(10,20)==200",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert rectangle_area(10,5)==50",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert rectangle_area(4,2)==8",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 455,
    "generated_code": "def check_monthnumb_number(month):\n    months_with_31_days = {1, 3, 5, 7, 8, 10, 12}\n    return month in months_with_31_days",
    "assertion_results": [
      {
        "assertion": "assert check_monthnumb_number(5)==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_monthnumb_number(2)==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_monthnumb_number(6)==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 452,
    "generated_code": "def loss_amount(cost_price, selling_price):\n    if selling_price < cost_price:\n        return cost_price - selling_price\n    else:\n        return None",
    "assertion_results": [
      {
        "assertion": "assert loss_amount(1500,1200)==None",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert loss_amount(100,200)==100",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert loss_amount(2000,5000)==3000",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 454,
    "generated_code": "import re\n\ndef text_match_wordz(text):\n    if re.search(r'\\w*z\\w*', text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
    "assertion_results": [
      {
        "assertion": "assert text_match_wordz(\"pythonz.\")==('Found a match!')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert text_match_wordz(\"xyz.\")==('Found a match!')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert text_match_wordz(\"  lang  .\")==('Not matched!')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 457,
    "generated_code": "def Find_Min(lists):\n    min_list = lists[0]\n    min_length = len(lists[0])\n    \n    for lst in lists:\n        if len(lst) < min_length:\n            min_length = len(lst)\n            min_list = lst\n    \n    return min_list",
    "assertion_results": [
      {
        "assertion": "assert Find_Min([[1],[1,2],[1,2,3]]) == [1]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert Find_Min([[1,1],[1,1,1],[1,2,7,8]]) == [1,1]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert Find_Min([['x'],['x','y'],['x','y','z']]) == ['x']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 453,
    "generated_code": "def sumofFactors(n):\n    sum_even_factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even_factors += i\n    return sum_even_factors",
    "assertion_results": [
      {
        "assertion": "assert sumofFactors(18) == 26",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sumofFactors(30) == 48",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sumofFactors(6) == 8",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 459,
    "generated_code": "import re\n\ndef remove_uppercase(s):\n    return re.sub(r'[A-Z]', '', s)",
    "assertion_results": [
      {
        "assertion": "assert remove_uppercase('cAstyoUrFavoRitETVshoWs') == 'cstyoravoitshos'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_uppercase('wAtchTheinTernEtrAdIo') == 'wtchheinerntrdo'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_uppercase('VoicESeaRchAndreComMendaTionS') == 'oiceachndreomendaion'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 429,
    "generated_code": "def and_tuples(tuple1, tuple2):\n    return tuple(a & b for a, b in zip(tuple1, tuple2))",
    "assertion_results": [
      {
        "assertion": "assert and_tuples((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert and_tuples((1, 2, 3, 4), (5, 6, 7, 8)) == (1, 2, 3, 0)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert and_tuples((8, 9, 11, 12), (7, 13, 14, 17)) == (0, 9, 10, 0)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 464,
    "generated_code": "def check_value(dictionary, value):\n    return all(v == value for v in dictionary.values())",
    "assertion_results": [
      {
        "assertion": "assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},10)==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},12)==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},5)==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 460,
    "generated_code": "def Extract(lst):\n    return [sublist[0] for sublist in lst]",
    "assertion_results": [
      {
        "assertion": "assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert Extract([[1,2,3],[4, 5]]) == [1,4]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert Extract([[9,8,1],[1,2]]) == [9,1]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 450,
    "generated_code": "def extract_string(string_list, size):\n    result = []\n    for string in string_list:\n        if len(string) == size:\n            result.append(string)\n    return result",
    "assertion_results": [
      {
        "assertion": "assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,8)==['practice', 'solution']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,6)==['Python']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,9)==['exercises']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 416,
    "generated_code": "def breakSum(n):\n    if n <= 4:\n        return n\n    \n    # Memoization to avoid recalculating\n    memo = {}\n    \n    def helper(num):\n        if num in memo:\n            return memo[num]\n        \n        if num <= 4:\n            memo[num] = num\n            return num\n        \n        # Option 1: Keep the number as is\n        keep_as_is = num\n        \n        # Option 2: Divide into three parts and sum recursively\n        part1 = num // 3\n        part2 = num // 3\n        part3 = num // 3 + num % 3\n        \n        divide_sum = helper(part1) + helper(part2) + helper(part3)\n        \n        # Take maximum\n        result = max(keep_as_is, divide_sum)\n        memo[num] = result\n        return result\n    \n    return helper(n)",
    "assertion_results": [
      {
        "assertion": "assert breakSum(12) == 13",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert breakSum(24) == 27",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert breakSum(23) == 23",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 465,
    "generated_code": "def drop_empty(dictionary):\n    return {key: value for key, value in dictionary.items() if value is not None}",
    "assertion_results": [
      {
        "assertion": "assert drop_empty({'c1': 'Red', 'c2': 'Green', 'c3':None})=={'c1': 'Red', 'c2': 'Green'}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert drop_empty({'c1': 'Red', 'c2': None, 'c3':None})=={'c1': 'Red'}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert drop_empty({'c1': None, 'c2': 'Green', 'c3':None})=={ 'c2': 'Green'}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 449,
    "generated_code": "def check_Triangle(x1, y1, x2, y2, x3, y3):\n    # Calculate the area using the cross product formula\n    # Area = 0.5 * |x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2)|\n    area = abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n    \n    # If area is 0, the points are collinear (not a valid triangle)\n    if area == 0:\n        return 'No'\n    else:\n        return 'Yes'",
    "assertion_results": [
      {
        "assertion": "assert check_Triangle(1,5,2,5,4,6) == 'Yes'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_Triangle(1,1,1,4,1,5) == 'No'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_Triangle(1,1,1,1,1,1) == 'No'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 432,
    "generated_code": "def median_trapezium(a, b, c):\n    values = [a, b, c]\n    values.sort()\n    return (values[0] + values[1]) / 2",
    "assertion_results": [
      {
        "assertion": "assert median_trapezium(15,25,35)==20",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert median_trapezium(10,20,30)==15",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert median_trapezium(6,9,4)==7.5",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 463,
    "generated_code": "def max_subarray_product(arr):\n    if not arr:\n        return 0\n    \n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n    \n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n        \n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        \n        result = max(result, max_product)\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_subarray_product([6, -3, -10, 0, 2]) == 180 ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_subarray_product([-2, -40, 0, -2, -3]) == 80",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 462,
    "generated_code": "def combinations_list(lst):\n    result = []\n    n = len(lst)\n    \n    # Generate all possible combinations using bit manipulation\n    for i in range(2**n):\n        combination = []\n        for j in range(n):\n            # Check if j-th bit is set in i\n            if i & (1 << j):\n                combination.append(lst[j])\n        result.append(combination)\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert combinations_list(['red', 'green', 'blue', 'white', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert combinations_list(['red', 'green', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 470,
    "generated_code": "def add_pairwise(tup):\n    result = []\n    for i in range(len(tup) - 1):\n        result.append(tup[i] + tup[i + 1])\n    return tuple(result)",
    "assertion_results": [
      {
        "assertion": "assert add_pairwise((1, 5, 7, 8, 10)) == (6, 12, 15, 18)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert add_pairwise((2, 6, 8, 9, 11)) == (8, 14, 17, 20)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert add_pairwise((3, 7, 9, 10, 12)) == (10, 16, 19, 22)",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 474,
    "generated_code": "def replace_char(string, old_char, new_char):\n    return string.replace(old_char, new_char)",
    "assertion_results": [
      {
        "assertion": "assert replace_char(\"polygon\",'y','l')==(\"pollgon\")",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert replace_char(\"character\",'c','a')==(\"aharaater\")",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert replace_char(\"python\",'l','a')==(\"python\")",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 475,
    "generated_code": "def sort_counter(counter_dict):\n    return sorted(counter_dict.items(), key=lambda x: x[1], reverse=True)",
    "assertion_results": [
      {
        "assertion": "assert sort_counter({'Math':81, 'Physics':83, 'Chemistry':87})==[('Chemistry', 87), ('Physics', 83), ('Math', 81)]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sort_counter({'Math':400, 'Physics':300, 'Chemistry':250})==[('Math', 400), ('Physics', 300), ('Chemistry', 250)]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sort_counter({'Math':900, 'Physics':1000, 'Chemistry':1250})==[('Chemistry', 1250), ('Physics', 1000), ('Math', 900)]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 448,
    "generated_code": "def cal_sum(n):\n    if n <= 0:\n        return 0\n    \n    # Generate Perrin numbers\n    perrin = []\n    \n    # Base cases\n    if n >= 1:\n        perrin.append(3)  # P(0) = 3\n    if n >= 2:\n        perrin.append(0)  # P(1) = 0\n    if n >= 3:\n        perrin.append(2)  # P(2) = 2\n    \n    # Generate remaining Perrin numbers\n    for i in range(3, n):\n        next_perrin = perrin[i-2] + perrin[i-3]\n        perrin.append(next_perrin)\n    \n    return sum(perrin)",
    "assertion_results": [
      {
        "assertion": "assert cal_sum(9) == 49",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert cal_sum(10) == 66",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert cal_sum(11) == 88",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 471,
    "generated_code": "def find_remainder(arr, length, n):\n    product = 1\n    for i in range(length):\n        product = (product * arr[i]) % n\n    return product",
    "assertion_results": [
      {
        "assertion": "assert find_remainder([ 100, 10, 5, 25, 35, 14 ],6,11) ==9",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_remainder([1,1,1],3,1) == 0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_remainder([1,2,1],3,2) == 0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 461,
    "generated_code": "def upper_ctr(s):\n    count = 0\n    for char in s:\n        if char.isupper():\n            count += 1\n    return count",
    "assertion_results": [
      {
        "assertion": "assert upper_ctr('PYthon') == 1",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert upper_ctr('BigData') == 1",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert upper_ctr('program') == 0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 467,
    "generated_code": "def decimal_to_Octal(decimal):\n    if decimal == 0:\n        return 0\n    \n    octal = \"\"\n    while decimal > 0:\n        remainder = decimal % 8\n        octal = str(remainder) + octal\n        decimal = decimal // 8\n    \n    return int(octal)",
    "assertion_results": [
      {
        "assertion": "assert decimal_to_Octal(10) == 12",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert decimal_to_Octal(2) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert decimal_to_Octal(33) == 41",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 476,
    "generated_code": "def big_sum(arr):\n    return max(arr) + min(arr)",
    "assertion_results": [
      {
        "assertion": "assert big_sum([1,2,3]) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert big_sum([-1,2,3,4]) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert big_sum([2,3,6]) == 8",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 477,
    "generated_code": "def is_lower(string):\n    return string.lower()",
    "assertion_results": [
      {
        "assertion": "assert is_lower(\"InValid\") == \"invalid\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_lower(\"TruE\") == \"true\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_lower(\"SenTenCE\") == \"sentence\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 478,
    "generated_code": "def remove_lowercase(s):\n    result = \"\"\n    for char in s:\n        if not char.islower():\n            result += char\n    return result",
    "assertion_results": [
      {
        "assertion": "assert remove_lowercase(\"PYTHon\")==('PYTH')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_lowercase(\"FInD\")==('FID')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_lowercase(\"STRinG\")==('STRG')",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 482,
    "generated_code": "import re\n\ndef match(string):\n    pattern = r'[A-Z][a-z]+'\n    if re.search(pattern, string):\n        return 'Yes'\n    else:\n        return 'No'",
    "assertion_results": [
      {
        "assertion": "assert match(\"Geeks\") == 'Yes'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert match(\"geeksforGeeks\") == 'Yes'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert match(\"geeks\") == 'No'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 483,
    "generated_code": "def first_Factorial_Divisible_Number(x):\n    n = 1\n    factorial = 1\n    \n    while factorial % x != 0:\n        n += 1\n        factorial *= n\n    \n    return n",
    "assertion_results": [
      {
        "assertion": "assert first_Factorial_Divisible_Number(10) == 5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert first_Factorial_Divisible_Number(15) == 5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert first_Factorial_Divisible_Number(5) == 4",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 479,
    "generated_code": "def first_Digit(num):\n    # Convert to string and get the first character, then convert back to int\n    return int(str(abs(num))[0])",
    "assertion_results": [
      {
        "assertion": "assert first_Digit(123) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert first_Digit(456) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert first_Digit(12) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 438,
    "generated_code": "def count_bidirectional(tuples_list):\n    count = 0\n    for i, tuple1 in enumerate(tuples_list):\n        reversed_tuple = (tuple1[1], tuple1[0])\n        for j, tuple2 in enumerate(tuples_list):\n            if i != j and tuple2 ",
    "assertion_results": []
  },
  {
    "task_id": 484,
    "generated_code": "def remove_matching_tuple(tuple1, tuple2):\n    return [item for item in tuple1 if item not in tuple2]",
    "assertion_results": [
      {
        "assertion": "assert remove_matching_tuple([('Hello', 'dude'), ('How', 'are'), ('you', '?')], [('Hello', 'dude'), ('How', 'are')]) == [('you', '?')]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_matching_tuple([('Part', 'of'), ('the', 'journey'), ('is ', 'end')], [('Journey', 'the'), ('is', 'end')]) == [('Part', 'of'), ('the', 'journey'), ('is ', 'end')]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_matching_tuple([('Its', 'been'), ('a', 'long'), ('day', 'without')], [('a', 'long'), ('my', 'friend')]) == [('Its', 'been'), ('day', 'without')]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 480,
    "generated_code": "def get_max_occuring_char(s):\n    char_count = {}\n    \n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    max_char = max(char_count, key=char_count.get)\n    return max_char",
    "assertion_results": [
      {
        "assertion": "assert get_max_occuring_char(\"data\") == \"a\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_max_occuring_char(\"create\") == \"e\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert get_max_occuring_char(\"brilliant girl\") == \"i\"",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 487,
    "generated_code": "def sort_tuple(tuples_list):\n    return sorted(tuples_list, key=lambda x: x[-1])",
    "assertion_results": [
      {
        "assertion": "assert sort_tuple([(1, 3), (3, 2), (2, 1)] ) == [(2, 1), (3, 2), (1, 3)]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sort_tuple([(2, 4), (3, 3), (1, 1)] ) == [(1, 1), (3, 3), (2, 4)]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sort_tuple([(3, 9), (6, 7), (4, 3)] ) == [(4, 3), (6, 7), (3, 9)]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 472,
    "generated_code": "def check_Consecutive(lst):\n    if len(lst) <= 1:\n        return True\n    \n    # Remove duplicates and sort\n    unique_sorted = sorted(set(lst))\n    \n    # Check if original list has duplicates\n    if len(unique_sorted) != len(lst):\n        return False\n    \n    # Check if consecutive\n    for i in range(1, len(unique_sorted)):\n        if unique_sorted[i] - unique_sorted[i-1] != 1:\n            return False\n    \n    return True",
    "assertion_results": [
      {
        "assertion": "assert check_Consecutive([1,2,3,4,5]) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_Consecutive([1,2,3,5,6]) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert check_Consecutive([1,2,1]) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 402,
    "generated_code": "def ncr_modp(n, r, p):\n    if r > n or r < 0:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    \n    # Calculate nCr using the formula: nCr = n! / (r! * (n-r)!)\n    # But we need to do this modulo p, so we use modular arithmetic\n    \n    # We'll use the multiplicative inverse for division in modular arithmetic\n    def mod_inverse(a, m):\n        # Extended Euclidean Algorithm to find modular inverse\n        def extended_gcd(a, b):\n            if a == 0:\n                return b, 0, 1\n            gcd, x1, y1 = extended_gcd(b % a, a)\n            x = y1 - (b // a) * x1\n            y = x1\n            return gcd, x, y\n        \n        gcd, x, _ = extended_gcd(a % m, m)\n        if gcd != 1:\n            return None  # Modular inverse doesn't exist\n        return (x % m + m) % m\n    \n    # Calculate nCr mod p using the formula\n    # nCr = n * (n-1) * ... * (n-r+1) / (r * (r-1) * ... * 1)\n    \n    numerator = 1\n    denominator = 1\n    \n    for i in range(r):\n        numerator = (numerator * (n - i)) % p\n        denominator = (denominator * (i + 1)) % p\n    \n    # Find modular inverse of denominator\n    inv_denominator = mod_inverse(denominator, p)\n    if inv_denominator is None:\n        return 0\n    \n    result = (numerator * inv_denominator) % p\n    return result",
    "assertion_results": [
      {
        "assertion": "assert ncr_modp(10,2,13)==6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert ncr_modp(15,12,43)==25",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert ncr_modp(17,9,18)==10",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 468,
    "generated_code": "def max_product(arr, n):\n    # dp[i] stores the maximum product of increasing subsequence ending at index i\n    dp = [0] * n\n    \n    # Initialize dp array with the array elements themselves\n    for i in range(n):\n        dp[i] = arr[i]\n    \n    # Fill dp array\n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    \n    # Return the maximum product among all subsequences\n    return max(dp)",
    "assertion_results": [
      {
        "assertion": "assert max_product([3, 100, 4, 5, 150, 6], 6) == 45000 ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_product([4, 42, 55, 68, 80], 5) == 50265600",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_product([10, 22, 9, 33, 21, 50, 41, 60], 8) == 21780000 ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 466,
    "generated_code": "def find_peak(arr, n):\n    # If array has only one element, it's a peak\n    if n == 1:\n        return 0\n    \n    # Check if first element is peak\n    if arr[0] >= arr[1]:\n        return 0\n    \n    # Check if last element is peak\n    if arr[n-1] >= arr[n-2]:\n        return n-1\n    \n    # Check for peak in middle elements\n    for i in range(1, n-1):\n        if arr[i] >= arr[i-1] and arr[i] >= arr[i+1]:\n            return i\n    \n    # If no peak found, return last index\n    return n-1",
    "assertion_results": [
      {
        "assertion": "assert find_peak([1, 3, 20, 4, 1, 0], 6) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_peak([2, 3, 4, 5, 6], 5) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find_peak([8, 9, 11, 12, 14, 15], 6) == 5 ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 473,
    "generated_code": "def tuple_intersection(list1, list2):\n    # Convert tuples to sets to handle order-independent comparison\n    set1 = set()\n    set2 = set()\n    \n    # For each tuple, create a frozenset to make it order-independent\n    for t in list1:\n        set1.add(frozenset(t))\n    \n    for t in list2:\n        set2.add(frozenset(t))\n    \n    # Find intersection\n    intersection = set1 & set2\n    \n    # Convert back to tuples, using sorted order for consistency\n    result = set()\n    for fs in intersection:\n        result.add(tuple(sorted(fs)))\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)] , [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert tuple_intersection([(4, 1), (7, 4), (11, 13), (17, 14)] , [(1, 4), (7, 4), (16, 12), (10, 13)]) == {(4, 7), (1, 4)}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert tuple_intersection([(2, 1), (3, 2), (1, 3), (1, 4)] , [(11, 2), (2, 3), (6, 2), (1, 3)]) == {(1, 3), (2, 3)}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 488,
    "generated_code": "import math\n\ndef area_pentagon(side_length):\n    area = (1/4) * math.sqrt(25 + 10 * math.sqrt(5)) * side_length**2\n    return area",
    "assertion_results": [
      {
        "assertion": "assert area_pentagon(5)==43.01193501472417",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert area_pentagon(10)==172.0477400588967",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert area_pentagon(15)==387.10741513251753",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 489,
    "generated_code": "def frequency_Of_Largest(n, arr):\n    max_value = max(arr)\n    return arr.count(max_value)",
    "assertion_results": [
      {
        "assertion": "assert frequency_Of_Largest(5,[1,2,3,4,4]) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert frequency_Of_Largest(3,[5,6,5]) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert frequency_Of_Largest(4,[2,7,7,7]) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 498,
    "generated_code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a",
    "assertion_results": [
      {
        "assertion": "assert gcd(12, 17) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert gcd(4,6) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert gcd(2,9) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 491,
    "generated_code": "def sum_gp(a, n, r):\n    if r == 1:\n        return a * n\n    else:\n        return a * (r**n - 1) // (r - 1)",
    "assertion_results": [
      {
        "assertion": "assert sum_gp(1,5,2)==31",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_gp(1,5,4)==341",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_gp(2,6,3)==728",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 499,
    "generated_code": "def diameter_circle(radius):\n    return radius * 2",
    "assertion_results": [
      {
        "assertion": "assert diameter_circle(10)==20",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert diameter_circle(40)==80",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert diameter_circle(15)==30",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 496,
    "generated_code": "import heapq\n\ndef heap_queue_smallest(numbers, k):\n    return heapq.nsmallest(k, numbers)",
    "assertion_results": [
      {
        "assertion": "assert heap_queue_smallest( [25, 35, 22, 85, 14, 65, 75, 25, 58],3)==[14, 22, 25] ",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert heap_queue_smallest( [25, 35, 22, 85, 14, 65, 75, 25, 58],2)==[14, 22]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert heap_queue_smallest( [25, 35, 22, 85, 14, 65, 75, 22, 58],5)==[14, 22, 22, 25, 35]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 485,
    "generated_code": "def largest_palindrome(arr, n):\n    def is_palindrome(num):\n        str_num = str(num)\n        return str_num == str_num[::-1]\n    \n    palindromes = [num for num in arr if is_palindrome(num)]\n    \n    if palindromes:\n        return max(palindromes)\n    else:\n        return None",
    "assertion_results": [
      {
        "assertion": "assert largest_palindrome([1, 232, 54545, 999991], 4) == 54545",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert largest_palindrome([1, 2, 3, 4, 5, 50], 6) == 5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert largest_palindrome([1, 3, 7, 9, 45], 5)  == 9",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 502,
    "generated_code": "def find(a, b):\n    return a % b",
    "assertion_results": [
      {
        "assertion": "assert find(3,3) == 0",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find(10,3) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert find(16,5) == 1",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 495,
    "generated_code": "import re\n\ndef remove_lowercase(s):\n    return re.sub(r'[a-z]', '', s)",
    "assertion_results": [
      {
        "assertion": "assert remove_lowercase('KDeoALOklOOHserfLoAJSIskdsf') == 'KDALOOOHLAJSI'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_lowercase('ProducTnamEstreAmIngMediAplAYer') == 'PTEAIMAAY'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_lowercase('maNufacTuredbYSheZenTechNolOGIes') == 'NTYSZTNOGI'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 494,
    "generated_code": "def binary_to_integer(binary_tuple):\n    binary_string = ''.join(str(bit) for bit in binary_tuple)\n    decimal_value = int(binary_string, 2)\n    return str(decimal_value)",
    "assertion_results": [
      {
        "assertion": "assert binary_to_integer((1, 1, 0, 1, 0, 0, 1)) == '105'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert binary_to_integer((0, 1, 1, 0, 0, 1, 0, 1)) == '101'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert binary_to_integer((1, 1, 0, 1, 0, 1)) == '53'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 486,
    "generated_code": "import math\n\ndef binomial_probability(n, k, p):\n    # Calculate binomial coefficient C(n, k) = n! / (k! * (n-k)!)\n    binomial_coeff = math.factorial(n) / (math.factorial(k) * math.factorial(n - k))\n    \n    # Calculate binomial probability: C(n, k) * p^k * (1-p)^(n-k)\n    probability = binomial_coeff * (p ** k) * ((1 - p) ** (n - k))\n    \n    return probability",
    "assertion_results": [
      {
        "assertion": "assert binomial_probability(10, 5, 1.0/3) == 0.13656454808718185",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert binomial_probability(11, 6, 2.0/4) == 0.2255859375",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert binomial_probability(12, 7, 3.0/5) == 0.227030335488",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 503,
    "generated_code": "def add_consecutive_nums(nums):\n    result = []\n    for i in range(len(nums) - 1):\n        result.append(nums[i] + nums[i + 1])\n    return result",
    "assertion_results": [
      {
        "assertion": "assert add_consecutive_nums([1, 1, 3, 4, 4, 5, 6, 7])==[2, 4, 7, 8, 9, 11, 13]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert add_consecutive_nums([4, 5, 8, 9, 6, 10])==[9, 13, 17, 15, 16]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert add_consecutive_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[3, 5, 7, 9, 11, 13, 15, 17, 19]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 469,
    "generated_code": "def max_profit(prices, k):\n    if not prices or k == 0:\n        return 0\n    \n    n = len(prices)\n    \n    # If k is large enough, we can make as many transactions as we want\n    if k >= n // 2:\n        profit = 0\n        for i in range(1, n):\n            if prices[i] > prices[i-1]:\n                profit += prices[i] - prices[i-1]\n        return profit\n    \n    # DP approach for limited transactions\n    # buy[i][j] = max profit after at most i transactions, currently holding stock\n    # sell[i][j] = max profit after at most i transactions, not holding stock\n    buy = [[-float('inf')] * n for _ in range(k+1)]\n    sell = [[0] * n for _ in range(k+1)]\n    \n    for i in range(1, k+1):\n        buy[i][0] = -prices[0]\n        for j in range(1, n):\n            buy[i][j] = max(buy[i][j-1], sell[i-1][j-1] - prices[j])\n            sell[i][j] = max(sell[i][j-1], buy[i][j-1] + prices[j])\n    \n    return sell[k][n-1]",
    "assertion_results": [
      {
        "assertion": "assert max_profit([1, 5, 2, 3, 7, 6, 4, 5], 3) == 10",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_profit([2, 4, 7, 5, 4, 3, 5], 2) == 7",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert max_profit([10, 6, 8, 4, 2], 2) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 481,
    "generated_code": "def is_subset_sum(arr, n, target_sum):\n    # Create a 2D DP table\n    # dp[i][j] represents whether sum j can be achieved using first i elements\n    dp = [[False for _ in range(target_sum + 1)] for _ in range(n + 1)]\n    \n    # Base case: sum 0 can always be achieved with empty subset\n    for i in range(n + 1):\n        dp[i][0] = True\n    \n    # Fill the DP table\n    for i in range(1, n + 1):\n        for j in range(1, target_sum + 1):\n            # If current element is greater than target sum, exclude it\n            if arr[i-1] > j:\n                dp[i][j] = dp[i-1][j]\n            else:\n                # Include current element or exclude it\n                dp[i][j] = dp[i-1][j] or dp[i-1][j - arr[i-1]]\n    \n    return dp[n][target_sum]",
    "assertion_results": [
      {
        "assertion": "assert is_subset_sum([3, 34, 4, 12, 5, 2], 6, 9) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_subset_sum([3, 34, 4, 12, 5, 2], 6, 30) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert is_subset_sum([3, 34, 4, 12, 5, 2], 6, 15) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 492,
    "generated_code": "def binary_search(arr, target):\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False",
    "assertion_results": [
      {
        "assertion": "assert binary_search([1,2,3,5,8], 6) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert binary_search([7, 8, 9, 10, 13], 10) == True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert binary_search([11, 13, 14, 19, 22, 36], 23) == False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 500,
    "generated_code": "def concatenate_elements(lst):\n    return '  ' + ' '.join(lst)",
    "assertion_results": [
      {
        "assertion": "assert concatenate_elements(['hello','there','have','a','rocky','day'] ) == '  hello there have a rocky day'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert concatenate_elements([ 'Hi', 'there', 'How','are', 'you'] ) == '  Hi there How are you'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert concatenate_elements([ 'Part', 'of', 'the','journey', 'is', 'end'] ) == '  Part of the journey is end'",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 507,
    "generated_code": "def remove_words(word_list, words_to_remove):\n    return [word for word in word_list if word not in words_to_remove]",
    "assertion_results": [
      {
        "assertion": "assert remove_words(['red', 'green', 'blue', 'white', 'black', 'orange'],['white', 'orange'])==['red', 'green', 'blue', 'black']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_words(['red', 'green', 'blue', 'white', 'black', 'orange'],['black', 'orange'])==['red', 'green', 'blue', 'white']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert remove_words(['red', 'green', 'blue', 'white', 'black', 'orange'],['blue', 'white'])==['red', 'green', 'black', 'orange']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 490,
    "generated_code": "def extract_symmetric(tuple_list):\n    seen = set()\n    symmetric_pairs = set()\n    \n    for pair in tuple_list:\n        reversed_pair = (pair[1], pair[0])\n        \n        if reversed_pair in seen:\n            # Found a symmetric pair, add the canonical form (smaller first)\n            canonical_pair = tuple(sorted([pair[0], pair[1]]))\n            symmetric_pairs.add(canonical_pair)\n        else:\n            seen.add(pair)\n    \n    return symmetric_pairs",
    "assertion_results": [
      {
        "assertion": "assert extract_symmetric([(6, 7), (2, 3), (7, 6), (9, 8), (10, 2), (8, 9)] ) == {(8, 9), (6, 7)}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert extract_symmetric([(7, 8), (3, 4), (8, 7), (10, 9), (11, 3), (9, 10)] ) == {(9, 10), (7, 8)}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert extract_symmetric([(8, 9), (4, 5), (9, 8), (11, 10), (12, 4), (10, 11)] ) == {(8, 9), (10, 11)}",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 497,
    "generated_code": "import math\n\ndef surfacearea_cone(radius, height):\n    # Calculate the slant height using Pythagorean theorem\n    slant_height = math.sqrt(radius**2 + height**2)\n    \n    # Surface area of cone = \u03c0 * r\u00b2 + \u03c0 * r * l\n    # where r is radius and l is slant height\n    base_area = math.pi * radius**2\n    lateral_area = math.pi * radius * slant_height\n    \n    return base_area + lateral_area",
    "assertion_results": [
      {
        "assertion": "assert surfacearea_cone(5,12)==282.7433388230814",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert surfacearea_cone(10,15)==880.5179353159282",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert surfacearea_cone(19,17)==2655.923961165254",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 501,
    "generated_code": "def num_comm_div(a, b):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    \n    g = gcd(a, b)\n    count = 0\n    \n    for i in range(1, int(g**0.5) + 1):\n        if g % i == 0:\n            count += 1\n            if i != g // i:\n                count += 1\n    \n    return count",
    "assertion_results": [
      {
        "assertion": "assert num_comm_div(2,4) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert num_comm_div(2,8) == 2",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert num_comm_div(12,24) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 506,
    "generated_code": "def permutation_coefficient(n, k):\n    if k > n or k < 0:\n        return 0\n    \n    result = 1\n    for i in range(n, n - k, -1):\n        result *= i\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert permutation_coefficient(10, 2) == 90",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert permutation_coefficient(10, 3) == 720",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert permutation_coefficient(10, 1) == 10",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 505,
    "generated_code": "def re_order(arr):\n    non_zeros = []\n    zero_count = 0\n    \n    for num in arr:\n        if num != 0:\n            non_zeros.append(num)\n        else:\n            zero_count += 1\n    \n    return non_zeros + [0] * zero_count",
    "assertion_results": [
      {
        "assertion": "assert re_order([6, 0, 8, 2, 3, 0, 4, 0, 1]) == [6, 8, 2, 3, 4, 1, 0, 0, 0]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert re_order([4, 0, 2, 7, 0, 9, 0, 12, 0]) == [4, 2, 7, 9, 12, 0, 0, 0, 0]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert re_order([3, 11, 0, 74, 14, 0, 1, 0, 2]) == [3, 11, 74, 14, 1, 2, 0, 0, 0]",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 504,
    "generated_code": "def sum_Of_Series(n):\n    return sum(i**3 for i in range(1, n+1))",
    "assertion_results": [
      {
        "assertion": "assert sum_Of_Series(5) == 225",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_Of_Series(2) == 9",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert sum_Of_Series(3) == 36",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 509,
    "generated_code": "def average_Odd(n):\n    odd_numbers = []\n    for i in range(1, n + 1, 2):\n        odd_numbers.append(i)\n    return sum(odd_numbers) // len(odd_numbers)",
    "assertion_results": [
      {
        "assertion": "assert average_Odd(9) == 5",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert average_Odd(5) == 3",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert average_Odd(11) == 6",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 510,
    "generated_code": "def no_of_subsequences(arr, k):\n    n = len(arr)\n    count = 0\n    \n    # Generate all possible subsequences using bit manipulation\n    for i in range(1, 2**n):\n        product = 1\n        for j in range(n):\n            if i & (1 << j):\n                product *= arr[j]\n                if product >= k:\n                    break\n        if product < k:\n            count += 1\n    \n    return count",
    "assertion_results": [
      {
        "assertion": "assert no_of_subsequences([1,2,3,4], 10) == 11",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert no_of_subsequences([4,8,7,2], 50) == 9",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert no_of_subsequences([5,6,7,8], 15) == 4",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 508,
    "generated_code": "def same_order(list1, list2):\n    # Find common elements while preserving order from list1\n    common_in_list1 = [item for item in list1 if item in list2]\n    \n    # Find common elements while preserving order from list2\n    common_in_list2 = [item for item in list2 if item in list1]\n    \n    # Check if the order of common elements is the same\n    return common_in_list1 == common_in_list2",
    "assertion_results": [
      {
        "assertion": "assert same_order([\"red\",\"green\",\"black\",\"orange\"],[\"red\",\"pink\",\"green\",\"white\",\"black\"])==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert same_order([\"red\",\"pink\",\"green\",\"white\",\"black\"],[\"white\",\"orange\",\"pink\",\"black\"])==False",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert same_order([\"red\",\"green\",\"black\",\"orange\"],[\"red\",\"pink\",\"green\",\"white\",\"black\"])==True",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 493,
    "generated_code": "import math\n\ndef calculate_polygons(start_x, start_y, cols, rows, size):\n    result = []\n    \n    # Hexagon geometry constants\n    width = size * 2\n    height = size * math.sqrt(3)\n    \n    # Horizontal and vertical spacing between hexagon centers\n    h_spacing = width * 0.75  # 3/4 of width\n    v_spacing = height\n    \n    for row in range(rows):\n        for col in range(cols):\n            # Calculate center position\n            center_x = start_x + col * h_spacing\n            center_y = start_y + row * v_spacing\n            \n            # Offset every other row\n            if row % 2 == 1:\n                center_x += h_spacing / 2\n            \n            # Generate hexagon vertices\n            hexagon = []\n            for i in range(7):  # 6 vertices + closing vertex\n                angle = i * math.pi / 3  # 60 degrees in radians\n                x = center_x + size * math.cos(angle)\n                y = center_y + size * math.sin(angle)\n                hexagon.append((x, y))\n            \n            result.append(hexagon)\n    \n    return result",
    "assertion_results": [
      {
        "assertion": "assert calculate_polygons(1,1, 4, 4, 3)==[[(-5.0, -4.196152422706632), (-5.0, -0.7320508075688767), (-2.0, 1.0), (1.0, -0.7320508075688767), (1.0, -4.196152422706632), (-2.0, -5.928203230275509), (-5.0, -4.196152422706632)], [(1.0, -4.196152422706632), (1.0, -0.7320508075688767), (4.0, 1.0), (7.0, -0.7320508075688767), (7.0, -4.196152422706632), (4.0, -5.928203230275509), (1.0, -4.196152422706632)], [(7.0, -4.196152422706632), (7.0, -0.7320508075688767), (10.0, 1.0), (13.0, -0.7320508075688767), (13.0, -4.196152422706632), (10.0, -5.928203230275509), (7.0, -4.196152422706632)], [(-2.0, 1.0000000000000004), (-2.0, 4.464101615137755), (1.0, 6.196152422706632), (4.0, 4.464101615137755), (4.0, 1.0000000000000004), (1.0, -0.7320508075688767), (-2.0, 1.0000000000000004)], [(4.0, 1.0000000000000004), (4.0, 4.464101615137755), (7.0, 6.196152422706632), (10.0, 4.464101615137755), (10.0, 1.0000000000000004), (7.0, -0.7320508075688767), (4.0, 1.0000000000000004)], [(-5.0, 6.196152422706632), (-5.0, 9.660254037844387), (-2.0, 11.392304845413264), (1.0, 9.660254037844387), (1.0, 6.196152422706632), (-2.0, 4.464101615137755), (-5.0, 6.196152422706632)], [(1.0, 6.196152422706632), (1.0, 9.660254037844387), (4.0, 11.392304845413264), (7.0, 9.660254037844387), (7.0, 6.196152422706632), (4.0, 4.464101615137755), (1.0, 6.196152422706632)], [(7.0, 6.196152422706632), (7.0, 9.660254037844387), (10.0, 11.392304845413264), (13.0, 9.660254037844387), (13.0, 6.196152422706632), (10.0, 4.464101615137755), (7.0, 6.196152422706632)], [(-2.0, 11.392304845413264), (-2.0, 14.85640646055102), (1.0, 16.588457268119896), (4.0, 14.85640646055102), (4.0, 11.392304845413264), (1.0, 9.660254037844387), (-2.0, 11.392304845413264)], [(4.0, 11.392304845413264), (4.0, 14.85640646055102), (7.0, 16.588457268119896), (10.0, 14.85640646055102), (10.0, 11.392304845413264), (7.0, 9.660254037844387), (4.0, 11.392304845413264)]]",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert calculate_polygons(5,4,7,9,8)==[[(-11.0, -9.856406460551018), (-11.0, -0.6188021535170058), (-3.0, 4.0), (5.0, -0.6188021535170058), (5.0, -9.856406460551018), (-3.0, -14.475208614068023), (-11.0, -9.856406460551018)], [(5.0, -9.856406460551018), (5.0, -0.6188021535170058), (13.0, 4.0), (21.0, -0.6188021535170058), (21.0, -9.856406460551018), (13.0, -14.475208614068023), (5.0, -9.856406460551018)], [(21.0, -9.856406460551018), (21.0, -0.6188021535170058), (29.0, 4.0), (37.0, -0.6188021535170058), (37.0, -9.856406460551018), (29.0, -14.475208614068023), (21.0, -9.856406460551018)], [(-3.0, 4.0), (-3.0, 13.237604307034012), (5.0, 17.856406460551018), (13.0, 13.237604307034012), (13.0, 4.0), (5.0, -0.6188021535170058), (-3.0, 4.0)], [(13.0, 4.0), (13.0, 13.237604307034012), (21.0, 17.856406460551018), (29.0, 13.237604307034012), (29.0, 4.0), (21.0, -0.6188021535170058), (13.0, 4.0)], [(-11.0, 17.856406460551018), (-11.0, 27.09401076758503), (-3.0, 31.712812921102035), (5.0, 27.09401076758503), (5.0, 17.856406460551018), (-3.0, 13.237604307034012), (-11.0, 17.856406460551018)], [(5.0, 17.856406460551018), (5.0, 27.09401076758503), (13.0, 31.712812921102035), (21.0, 27.09401076758503), (21.0, 17.856406460551018), (13.0, 13.237604307034012), (5.0, 17.856406460551018)], [(21.0, 17.856406460551018), (21.0, 27.09401076758503), (29.0, 31.712812921102035), (37.0, 27.09401076758503), (37.0, 17.856406460551018), (29.0, 13.237604307034012), (21.0, 17.856406460551018)], [(-3.0, 31.712812921102035), (-3.0, 40.95041722813605), (5.0, 45.569219381653056), (13.0, 40.95041722813605), (13.0, 31.712812921102035), (5.0, 27.09401076758503), (-3.0, 31.712812921102035)], [(13.0, 31.712812921102035), (13.0, 40.95041722813605), (21.0, 45.569219381653056), (29.0, 40.95041722813605), (29.0, 31.712812921102035), (21.0, 27.09401076758503), (13.0, 31.712812921102035)]]",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert calculate_polygons(9,6,4,3,2)==[[(5.0, 2.5358983848622456), (5.0, 4.8452994616207485), (7.0, 6.0), (9.0, 4.8452994616207485), (9.0, 2.5358983848622456), (7.0, 1.3811978464829942), (5.0, 2.5358983848622456)], [(7.0, 6.0), (7.0, 8.309401076758503), (9.0, 9.464101615137753), (11.0, 8.309401076758503), (11.0, 6.0), (9.0, 4.8452994616207485), (7.0, 6.0)]]",
        "status": "FAILED",
        "error": "AssertionError: ",
        "stdout": "",
        "stderr": ""
      }
    ]
  },
  {
    "task_id": 456,
    "generated_code": "def reverse_string_list(string_list):\n    return [string[::-1] for string in string_list]",
    "assertion_results": [
      {
        "assertion": "assert reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])==['deR', 'neerG', 'eulB', 'etihW', 'kcalB']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert reverse_string_list(['john','amal','joel','george'])==['nhoj','lama','leoj','egroeg']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      },
      {
        "assertion": "assert reverse_string_list(['jack','john','mary'])==['kcaj','nhoj','yram']",
        "status": "PASSED",
        "error": null,
        "stdout": "",
        "stderr": ""
      }
    ]
  }
]