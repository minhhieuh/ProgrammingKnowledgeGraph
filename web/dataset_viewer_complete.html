<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programming Knowledge Graph - Dataset Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }
        
        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .stats {
            background: white;
            padding: 1rem;
            margin: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
        }
        
        .stat-item {
            text-align: center;
            padding: 1rem;
        }
        
        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
        }
        
        .stat-label {
            color: #666;
            font-size: 0.9rem;
        }
        
        .controls {
            background: white;
            padding: 1rem;
            margin: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .search-box, .filter-select {
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }
        
        .search-box {
            flex: 1;
            min-width: 300px;
        }
        
        .problem-card {
            background: white;
            margin: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
            transition: transform 0.2s ease;
        }
        
        .problem-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }
        
        .problem-header {
            background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
            color: white;
            padding: 1rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .problem-header.mbpp {
            background: linear-gradient(135deg, #fd79a8 0%, #e84393 100%);
        }
        
        .problem-title {
            font-size: 1.3rem;
            font-weight: bold;
        }
        
        .dataset-badge {
            background: rgba(255,255,255,0.2);
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            font-size: 0.8rem;
            margin-left: 1rem;
        }
        
        .expand-icon {
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }
        
        .problem-content {
            display: none;
            padding: 1.5rem;
        }
        
        .problem-content.expanded {
            display: block;
        }
        
        .problem-section {
            margin-bottom: 2rem;
        }
        
        .section-title {
            font-size: 1.1rem;
            font-weight: bold;
            color: #2d3436;
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            background: #f8f9fa;
            border-left: 4px solid #74b9ff;
        }
        
        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 6px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            overflow-x: auto;
            margin: 0.5rem 0;
        }
        
        .augmented-context {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 1rem;
            margin: 0.5rem 0;
        }
        
        .context-item {
            margin-bottom: 1rem;
            padding: 1rem;
            background: white;
            border-radius: 4px;
            border-left: 4px solid #28a745;
        }
        
        .relevance-score {
            background: #28a745;
            color: white;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
            display: inline-block;
        }
        
        .no-results {
            text-align: center;
            padding: 3rem;
            color: #666;
            font-size: 1.2rem;
        }
        
        .tab-container {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 1rem;
        }
        
        .tab {
            padding: 0.5rem 1rem;
            cursor: pointer;
            border: none;
            background: #f8f9fa;
            border-top-left-radius: 4px;
            border-top-right-radius: 4px;
            margin-right: 2px;
            transition: all 0.2s ease;
        }
        
        .tab.active {
            background: #74b9ff;
            color: white;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .stats {
                flex-direction: column;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .search-box {
                min-width: auto;
            }
            
            .problem-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Programming Knowledge Graph Dataset</h1>
        <p>Interactive viewer for HumanEval and MBPP problems with augmented contexts</p>
    </div>
    
    
    <div class="stats">
        <div class="stat-item">
            <div class="stat-number" id="total-problems">664</div>
            <div class="stat-label">Total Problems</div>
        </div>
        <div class="stat-item">
            <div class="stat-number">164</div>
            <div class="stat-label">HumanEval Problems</div>
        </div>
        <div class="stat-item">
            <div class="stat-number">500</div>
            <div class="stat-label">MBPP Problems</div>
        </div>
        <div class="stat-item">
            <div class="stat-number">3</div>
            <div class="stat-label">Augmentation Types</div>
        </div>
        <div class="stat-item">
            <div class="stat-number" id="visible-problems">664</div>
            <div class="stat-label">Visible Problems</div>
        </div>
    </div>
            <div class="stat-label">Total Problems</div>
        </div>
        <div class="stat-item">
            <div class="stat-number">164</div>
            <div class="stat-label">HumanEval Problems</div>
        </div>
        <div class="stat-item">
            <div class="stat-number">500</div>
            <div class="stat-label">MBPP Problems</div>
        </div>
        <div class="stat-item">
            <div class="stat-number">3</div>
            <div class="stat-label">Augmentation Types</div>
        </div>
        <div class="stat-item">
            <div class="stat-number" id="visible-problems">664</div>
            <div class="stat-label">Visible Problems</div>
        </div>
    </div>
    
    <div class="controls">
        <input type="text" class="search-box" placeholder="Search problems by task ID or content..." id="search-input">
        <select class="filter-select" id="dataset-filter">
            <option value="all">All Datasets</option>
            <option value="humaneval">HumanEval Only</option>
            <option value="mbpp">MBPP Only</option>
            <option value="function_wise">Function-wise (Voyage)</option>
            <option value="block_wise">Block-wise (Voyage)</option>
            <option value="bm25">BM25</option>
        </select>
        <button onclick="expandAll()" style="padding: 0.5rem 1rem; background: #74b9ff; color: white; border: none; border-radius: 4px; cursor: pointer;">Expand All</button>
        <button onclick="collapseAll()" style="padding: 0.5rem 1rem; background: #636e72; color: white; border: none; border-radius: 4px; cursor: pointer;">Collapse All</button>
    </div>
    
    <div id="problems-container">
        <!-- Problems will be loaded here -->
    </div>
    
    <div class="no-results" id="no-results" style="display: none;">
        No problems match your search criteria.
    </div>

    
    <script>
        const PROBLEMS_DATA = [
  {
    "task_id": "HumanEval/0",
    "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
    "canonical_solution": "    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n",
    "entry_point": "has_close_elements",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/1",
    "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
    "canonical_solution": "    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n",
    "entry_point": "separate_paren_groups",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/10",
    "prompt": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n",
    "canonical_solution": "    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n",
    "entry_point": "make_palindrome",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/100",
    "prompt": "\ndef make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n",
    "canonical_solution": "    return [n + 2*i for i in range(n)]\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
    "entry_point": "make_a_pile",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/101",
    "prompt": "\ndef words_string(s):\n    \"\"\"\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n",
    "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n",
    "entry_point": "words_string",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/102",
    "prompt": "\ndef choose_num(x, y):\n    \"\"\"This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n",
    "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n",
    "entry_point": "choose_num",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/103",
    "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n",
    "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n",
    "entry_point": "rounded_avg",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/104",
    "prompt": "\ndef unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n",
    "canonical_solution": "    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
    "entry_point": "unique_digits",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/105",
    "prompt": "\ndef by_length(arr):\n    \"\"\"\n    Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n    \n      If the array is empty, return an empty array:\n      arr = []\n      return []\n    \n      If the array has any strange number ignore it:\n      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n            -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\n",
    "canonical_solution": "    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n",
    "entry_point": "by_length",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/106",
    "prompt": "\ndef f(n):\n    \"\"\" Implement the function f that takes n as a parameter,\n    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n    or the sum of numbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n    Example:\n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n",
    "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
    "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n",
    "entry_point": "f",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/107",
    "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and odd integer palindromes respectively.\n    \"\"\"\n",
    "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
    "entry_point": "even_odd_palindrome",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/108",
    "prompt": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
    "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
    "entry_point": "count_nums",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/109",
    "prompt": "\ndef move_one_ball(arr):\n    \"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return True else return False.\n    If the given array is empty then return True.\n\n    Note: The given list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \"\"\"\n",
    "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n",
    "entry_point": "move_one_ball",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/11",
    "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n",
    "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n",
    "entry_point": "string_xor",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/110",
    "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n",
    "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n",
    "entry_point": "exchange",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/111",
    "prompt": "\ndef histogram(test):\n    \"\"\"Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n    \n    Example:\n    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    histogram('a b b a') == {'a': 2, 'b': 2}\n    histogram('a b c a b') == {'a': 2, 'b': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\n\n    \"\"\"\n",
    "canonical_solution": "    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n",
    "entry_point": "histogram",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/112",
    "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Task\n    We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n    then check if the result string is palindrome.\n    A string is called palindrome if it reads the same backward as forward.\n    You should return a tuple containing the result string and True/False for the check.\n    Example\n    For s = \"abcde\", c = \"ae\", the result should be ('bcd',False)\n    For s = \"abcdef\", c = \"b\"  the result should be ('acdef',False)\n    For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',True)\n    \"\"\"\n",
    "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
    "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n",
    "entry_point": "reverse_delete",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/113",
    "prompt": "\ndef odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
    "canonical_solution": "    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
    "entry_point": "odd_count",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/114",
    "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n",
    "canonical_solution": "    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n",
    "entry_point": "minSubArraySum",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/115",
    "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"\n",
    "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n",
    "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n",
    "entry_point": "max_fill",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/116",
    "prompt": "\ndef sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
    "canonical_solution": "    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
    "entry_point": "sort_array",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/117",
    "prompt": "\ndef select_words(s, n):\n    \"\"\"Given a string s and a natural number n, you have been tasked to implement \n    a function that returns a list of all words from string s that contain exactly \n    n consonants, in order these words appear in the string s.\n    If the string s is empty then the function should return an empty list.\n    Note: you may assume the input string contains only letters and spaces.\n    Examples:\n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n",
    "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n",
    "entry_point": "select_words",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/118",
    "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"You are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\n",
    "canonical_solution": "    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
    "entry_point": "get_closest_vowel",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/119",
    "prompt": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
    "canonical_solution": "    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n",
    "entry_point": "match_parens",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/12",
    "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n",
    "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n",
    "entry_point": "longest",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/120",
    "prompt": "\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n",
    "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n",
    "entry_point": "maximum",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/121",
    "prompt": "\ndef solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n",
    "canonical_solution": "    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n",
    "entry_point": "solution",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/122",
    "prompt": "\ndef add_elements(arr, k):\n    \"\"\"\n    Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements with at most two digits from the first k elements of arr.\n\n    Example:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \"\"\"\n",
    "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
    "entry_point": "add_elements",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/123",
    "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"\n    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the \n    previous term as follows: if the previous term is even, the next term is one half of \n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\n",
    "canonical_solution": "    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
    "entry_point": "get_odd_collatz",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/124",
    "prompt": "\ndef valid_date(date):\n    \"\"\"You have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n\n    for example: \n    valid_date('03-11-2000') => True\n\n    valid_date('15-01-2012') => False\n\n    valid_date('04-0-2040') => False\n\n    valid_date('06-04-2020') => True\n\n    valid_date('06/04/2020') => False\n    \"\"\"\n",
    "canonical_solution": "    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n",
    "entry_point": "valid_date",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/125",
    "prompt": "\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u279e [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u279e [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n",
    "canonical_solution": "    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
    "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n",
    "entry_point": "split_words",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/126",
    "prompt": "\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u279e True\n    is_sorted([1, 2, 3, 4, 5]) \u279e True\n    is_sorted([1, 3, 2, 4, 5]) \u279e False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u279e True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279e True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u279e False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u279e True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u279e False\n    '''\n",
    "canonical_solution": "    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n",
    "entry_point": "is_sorted",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/127",
    "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"You are given two intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these two \n    intervals is a prime number.\n    Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n    which its length is 1, which not a prime number.\n    If the length of the intersection is a prime number, return \"YES\",\n    otherwise, return \"NO\".\n    If the two intervals don't intersect, return \"NO\".\n\n\n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n",
    "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n",
    "entry_point": "intersection",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/128",
    "prompt": "\ndef prod_signs(arr):\n    \"\"\"\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
    "canonical_solution": "    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
    "entry_point": "prod_signs",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/129",
    "prompt": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
    "canonical_solution": "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n",
    "entry_point": "minPath",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/13",
    "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n",
    "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n",
    "entry_point": "greatest_common_divisor",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/130",
    "prompt": "\ndef tri(n):\n    \"\"\"Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"\n",
    "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n",
    "entry_point": "tri",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/131",
    "prompt": "\ndef digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n",
    "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n",
    "entry_point": "digits",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/132",
    "prompt": "\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u279e True\n    is_nested('[]]]]]]][[[[[]') \u279e False\n    is_nested('[][]') \u279e False\n    is_nested('[]') \u279e False\n    is_nested('[[][]]') \u279e True\n    is_nested('[[]][[') \u279e True\n    '''\n",
    "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n",
    "entry_point": "is_nested",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/133",
    "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"You are given a list of numbers.\n    You need to return the sum of squared numbers in the given list,\n    round each element in the list to the upper int(Ceiling) first.\n    Examples:\n    For lst = [1,2,3] the output should be 14\n    For lst = [1,4,9] the output should be 98\n    For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0] the output should be 29\n    For lst = [-2.4,1,1] the output should be 6\n    \n\n    \"\"\"\n",
    "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
    "entry_point": "sum_squares",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/134",
    "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u279e False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u279e True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u279e False\n    check_if_last_char_is_a_letter(\"\") \u279e False \n    '''\n",
    "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
    "entry_point": "check_if_last_char_is_a_letter",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/135",
    "prompt": "\ndef can_arrange(arr):\n    \"\"\"Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n",
    "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n",
    "entry_point": "can_arrange",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/136",
    "prompt": "\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n",
    "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n",
    "entry_point": "largest_smallest_integers",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/137",
    "prompt": "\ndef compare_one(a, b):\n    \"\"\"\n    Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    compare_one(1, 2.5) \u279e 2.5\n    compare_one(1, \"2,3\") \u279e \"2,3\"\n    compare_one(\"5,1\", \"6\") \u279e \"6\"\n    compare_one(\"1\", 1) \u279e None\n    \"\"\"\n",
    "canonical_solution": "    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
    "entry_point": "compare_one",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/138",
    "prompt": "\ndef is_equal_to_sum_even(n):\n    \"\"\"Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n    Example\n    is_equal_to_sum_even(4) == False\n    is_equal_to_sum_even(6) == False\n    is_equal_to_sum_even(8) == True\n    \"\"\"\n",
    "canonical_solution": "    return n%2 == 0 and n >= 8\n",
    "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n",
    "entry_point": "is_equal_to_sum_even",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/139",
    "prompt": "\ndef special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
    "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n",
    "entry_point": "special_factorial",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/14",
    "prompt": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n",
    "canonical_solution": "    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n",
    "entry_point": "all_prefixes",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/140",
    "prompt": "\ndef fix_spaces(text):\n    \"\"\"\n    Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with - \n    \n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    \"\"\"\n",
    "canonical_solution": "    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n",
    "entry_point": "fix_spaces",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/141",
    "prompt": "\ndef file_name_check(file_name):\n    \"\"\"Create a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\") # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n    \"\"\"\n",
    "canonical_solution": "    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n",
    "entry_point": "file_name_check",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/142",
    "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"\"\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n    \n    Examples:\n    For lst = [1,2,3] the output should be 6\n    For lst = []  the output should be 0\n    For lst = [-1,-5,2,-1,-5]  the output should be -126\n    \"\"\"\n",
    "canonical_solution": "    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n",
    "entry_point": "sum_squares",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/143",
    "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"\n    You are given a string representing a sentence,\n    the sentence contains some words separated by a space,\n    and you have to return a string that contains the words from the original sentence,\n    whose lengths are prime numbers,\n    the order of the words in the new string should be the same as the original one.\n\n    Example 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Example 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Constraints:\n        * 1 <= len(sentence) <= 100\n        * sentence contains only letters\n    \"\"\"\n",
    "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n",
    "entry_point": "words_in_sentence",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/144",
    "prompt": "\ndef simplify(x, n):\n    \"\"\"Your task is to implement a function that will simplify the expression\n    x * n. The function returns True if x * n evaluates to a whole number and False\n    otherwise. Both x and n, are string representation of a fraction, and have the following format,\n    <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n    You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n",
    "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n",
    "entry_point": "simplify",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/145",
    "prompt": "\ndef order_by_points(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n",
    "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
    "entry_point": "order_by_points",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/146",
    "prompt": "\ndef specialFilter(nums):\n    \"\"\"Write a function that takes an array of numbers as input and returns \n    the number of elements in the array that are greater than 10 and both \n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n    For example:\n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n",
    "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n",
    "entry_point": "specialFilter",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/147",
    "prompt": "\ndef get_max_triples(n):\n    \"\"\"\n    You are given a positive integer n. You have to create an integer array a of length n.\n        For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.\n\n    Example :\n        Input: n = 5\n        Output: 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n    \"\"\"\n",
    "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
    "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n",
    "entry_point": "get_max_triples",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/148",
    "prompt": "\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
    "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n",
    "entry_point": "bf",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/149",
    "prompt": "\ndef sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n",
    "canonical_solution": "    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n",
    "entry_point": "sorted_list_sum",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/15",
    "prompt": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
    "canonical_solution": "    return ' '.join([str(x) for x in range(n + 1)])\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n",
    "entry_point": "string_sequence",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/150",
    "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"A simple program which should return the value of x if n is \n    a prime number and should return the value of y otherwise.\n\n    Examples:\n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n",
    "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n",
    "entry_point": "x_or_y",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/151",
    "prompt": "\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
    "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n",
    "entry_point": "double_the_difference",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/152",
    "prompt": "\ndef compare(game,guess):\n    \"\"\"I think we all remember that feeling when the result of some long-awaited\n    event is finally known. The feelings and thoughts you have at that moment are\n    definitely worth noting down and comparing.\n    Your task is to determine if a person correctly guessed the results of a number of matches.\n    You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    \n    \n    example:\n\n    compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n    compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n    \"\"\"\n",
    "canonical_solution": "    return [abs(x-y) for x,y in zip(game,guess)]\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
    "entry_point": "compare",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/153",
    "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"You will be given the name of a class (a string) and a list of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the list.\n    For example, if you are given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n",
    "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n",
    "entry_point": "Strongest_Extension",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/154",
    "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n",
    "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n",
    "entry_point": "cycpattern_check",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/155",
    "prompt": "\ndef even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n",
    "canonical_solution": "    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
    "entry_point": "even_odd_count",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/156",
    "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
    "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
    "entry_point": "int_to_mini_roman",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/157",
    "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
    "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n",
    "entry_point": "right_angle_triangle",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/158",
    "prompt": "\ndef find_max(words):\n    \"\"\"Write a function that accepts a list of strings.\n    The list contains different words. Return the word with maximum number\n    of unique characters. If multiple strings have maximum number of unique\n    characters, return the one which comes first in lexicographical order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n    \"\"\"\n",
    "canonical_solution": "    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n",
    "entry_point": "find_max",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/159",
    "prompt": "\ndef eat(number, need, remaining):\n    \"\"\"\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\n",
    "canonical_solution": "    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n",
    "entry_point": "eat",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/16",
    "prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
    "canonical_solution": "    return len(set(string.lower()))\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n",
    "entry_point": "count_distinct_characters",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/160",
    "prompt": "\ndef do_algebra(operator, operand):\n    \"\"\"\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebric \n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    \"\"\"\n",
    "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
    "entry_point": "do_algebra",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/161",
    "prompt": "\ndef solve(s):\n    \"\"\"You are given a string s.\n    if s[i] is a letter, reverse its case from lower to upper or vise versa, \n    otherwise keep it as it is.\n    If the string contains no letters, reverse the string.\n    The function should return the resulted string.\n    Examples\n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n",
    "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n",
    "entry_point": "solve",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/162",
    "prompt": "\ndef string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
    "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
    "entry_point": "string_to_md5",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/163",
    "prompt": "\ndef generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n",
    "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
    "entry_point": "generate_integers",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/17",
    "prompt": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
    "canonical_solution": "    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n",
    "entry_point": "parse_music",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/18",
    "prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n",
    "canonical_solution": "    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n",
    "entry_point": "how_many_times",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/19",
    "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
    "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n",
    "entry_point": "sort_numbers",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/2",
    "prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
    "canonical_solution": "    return number % 1.0\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n",
    "entry_point": "truncate_number",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/20",
    "prompt": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n",
    "canonical_solution": "    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n",
    "entry_point": "find_closest_elements",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/21",
    "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
    "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n",
    "entry_point": "rescale_to_unit",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/22",
    "prompt": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
    "canonical_solution": "    return [x for x in values if isinstance(x, int)]\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n",
    "entry_point": "filter_integers",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/23",
    "prompt": "\n\ndef strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
    "canonical_solution": "    return len(string)\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n",
    "entry_point": "strlen",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/24",
    "prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
    "canonical_solution": "    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n",
    "entry_point": "largest_divisor",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/25",
    "prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
    "canonical_solution": "    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n",
    "entry_point": "factorize",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/26",
    "prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n",
    "canonical_solution": "    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n",
    "entry_point": "remove_duplicates",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/27",
    "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
    "canonical_solution": "    return string.swapcase()\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n",
    "entry_point": "flip_case",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/28",
    "prompt": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n",
    "canonical_solution": "    return ''.join(strings)\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n",
    "entry_point": "concatenate",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/29",
    "prompt": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
    "canonical_solution": "    return [x for x in strings if x.startswith(prefix)]\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n",
    "entry_point": "filter_by_prefix",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/3",
    "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n",
    "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n",
    "entry_point": "below_zero",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/30",
    "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
    "canonical_solution": "    return [e for e in l if e > 0]\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n",
    "entry_point": "get_positive",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/31",
    "prompt": "\n\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
    "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n",
    "entry_point": "is_prime",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/32",
    "prompt": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
    "canonical_solution": "    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n",
    "entry_point": "find_zero",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/33",
    "prompt": "\n\ndef sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
    "canonical_solution": "    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n",
    "entry_point": "sort_third",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/34",
    "prompt": "\n\ndef unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
    "canonical_solution": "    return sorted(list(set(l)))\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n",
    "entry_point": "unique",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/35",
    "prompt": "\n\ndef max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
    "canonical_solution": "    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n",
    "entry_point": "max_element",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/36",
    "prompt": "\n\ndef fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
    "canonical_solution": "    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n",
    "entry_point": "fizz_buzz",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/37",
    "prompt": "\n\ndef sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
    "canonical_solution": "    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n",
    "entry_point": "sort_even",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/38",
    "prompt": "\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of three characters.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
    "canonical_solution": "    return encode_cyclic(encode_cyclic(s))\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n",
    "entry_point": "decode_cyclic",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/39",
    "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
    "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n",
    "entry_point": "prime_fib",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/4",
    "prompt": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n",
    "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n",
    "entry_point": "mean_absolute_deviation",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/40",
    "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
    "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n",
    "entry_point": "triples_sum_to_zero",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/41",
    "prompt": "\n\ndef car_race_collision(n: int):\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n    \"\"\"\n",
    "canonical_solution": "    return n**2\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n",
    "entry_point": "car_race_collision",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/42",
    "prompt": "\n\ndef incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
    "canonical_solution": "    return [(e + 1) for e in l]\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n",
    "entry_point": "incr_list",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/43",
    "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
    "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n",
    "entry_point": "pairs_sum_to_zero",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/44",
    "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n",
    "canonical_solution": "    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n",
    "entry_point": "change_base",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/45",
    "prompt": "\n\ndef triangle_area(a, h):\n    \"\"\"Given length of a side and high return area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n",
    "canonical_solution": "    return a * h / 2.0\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n",
    "entry_point": "triangle_area",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/46",
    "prompt": "\n\ndef fib4(n: int):\n    \"\"\"The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
    "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n",
    "entry_point": "fib4",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/47",
    "prompt": "\n\ndef median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
    "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n",
    "entry_point": "median",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/48",
    "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Checks if given string is a palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
    "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n",
    "entry_point": "is_palindrome",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/49",
    "prompt": "\n\ndef modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
    "canonical_solution": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n",
    "entry_point": "modp",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/5",
    "prompt": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
    "canonical_solution": "    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n",
    "entry_point": "intersperse",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/50",
    "prompt": "\n\ndef encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
    "canonical_solution": "    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n",
    "entry_point": "decode_shift",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/51",
    "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
    "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n",
    "entry_point": "remove_vowels",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/52",
    "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Return True if all numbers in the list l are below threshold t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
    "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n",
    "entry_point": "below_threshold",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/53",
    "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
    "canonical_solution": "    return x + y\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n",
    "entry_point": "add",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/54",
    "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
    "canonical_solution": "    return set(s0) == set(s1)\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n",
    "entry_point": "same_chars",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/55",
    "prompt": "\n\ndef fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
    "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n",
    "entry_point": "fib",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/56",
    "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
    "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n",
    "entry_point": "correct_bracketing",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/57",
    "prompt": "\n\ndef monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
    "canonical_solution": "    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n",
    "entry_point": "monotonic",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/58",
    "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
    "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n",
    "entry_point": "common",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/59",
    "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
    "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n",
    "entry_point": "largest_prime_factor",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/6",
    "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
    "canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n",
    "entry_point": "parse_nested_parens",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/60",
    "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
    "canonical_solution": "    return sum(range(n + 1))\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n",
    "entry_point": "sum_to_n",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/61",
    "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
    "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n",
    "entry_point": "correct_bracketing",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/62",
    "prompt": "\n\ndef derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
    "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n",
    "entry_point": "derivative",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/63",
    "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n",
    "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n",
    "entry_point": "fibfib",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/64",
    "prompt": "\nFIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
    "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
    "entry_point": "vowels_count",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/65",
    "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
    "canonical_solution": "    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
    "entry_point": "circular_shift",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/66",
    "prompt": "\ndef digitSum(s):\n    \"\"\"Task\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n    \"\"\"\n",
    "canonical_solution": "    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n",
    "entry_point": "digitSum",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/67",
    "prompt": "\ndef fruit_distribution(s,n):\n    \"\"\"\n    In this task, you will be given a string that represents a number of apples and oranges \n    that are distributed in a basket of fruit this basket contains \n    apples, oranges, and mango fruits. Given the string that represents the total number of \n    the oranges and apples and an integer that represent the total number of the fruits \n    in the basket return the number of the mango fruits in the basket.\n    for examble:\n    fruit_distribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n    fruit_distribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n    fruit_distribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n    fruit_distribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n    \"\"\"\n",
    "canonical_solution": "    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n",
    "entry_point": "fruit_distribution",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/68",
    "prompt": "\ndef pluck(arr):\n    \"\"\"\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n",
    "canonical_solution": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n",
    "entry_point": "pluck",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/69",
    "prompt": "\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
    "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
    "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n",
    "entry_point": "search",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/7",
    "prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
    "canonical_solution": "    return [x for x in strings if substring in x]\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n",
    "entry_point": "filter_by_substring",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/70",
    "prompt": "\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
    "canonical_solution": "    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
    "entry_point": "strange_sort_list",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/71",
    "prompt": "\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
    "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n",
    "entry_point": "triangle_area",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/72",
    "prompt": "\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u279e False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279e False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u279e True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u279e True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
    "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n",
    "entry_point": "will_it_fly",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/73",
    "prompt": "\ndef smallest_change(arr):\n    \"\"\"\n    Given an array arr of integers, find the minimum number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n",
    "canonical_solution": "    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n",
    "entry_point": "smallest_change",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/74",
    "prompt": "\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n",
    "canonical_solution": "    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n",
    "entry_point": "total_match",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/75",
    "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
    "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
    "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n",
    "entry_point": "is_multiply_prime",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/76",
    "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"Your task is to write a function that returns true if a number x is a simple\n    power of n and false in other cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false\n    \"\"\"\n",
    "canonical_solution": "    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
    "entry_point": "is_simple_power",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/77",
    "prompt": "\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
    "canonical_solution": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n",
    "entry_point": "iscube",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/78",
    "prompt": "\ndef hex_key(num):\n    \"\"\"You have been tasked to write a function that receives \n    a hexadecimal number as a string and counts the number of hexadecimal \n    digits that are primes (prime number, or a prime, is a natural number \n    greater than 1 that is not a product of two smaller natural numbers).\n    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    So you have to determine a number of the following digits: 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal 13).\n    Note: you may assume the input is always correct or empty string, \n    and symbols A,B,C,D,E,F are always uppercase.\n    Examples:\n    For num = \"AB\" the output should be 1.\n    For num = \"1077E\" the output should be 2.\n    For num = \"ABED1A33\" the output should be 4.\n    For num = \"123456789ABCDEF0\" the output should be 6.\n    For num = \"2020\" the output should be 2.\n    \"\"\"\n",
    "canonical_solution": "    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n",
    "entry_point": "hex_key",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/79",
    "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n",
    "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
    "entry_point": "decimal_to_binary",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/8",
    "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
    "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n",
    "entry_point": "sum_product",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/80",
    "prompt": "\ndef is_happy(s):\n    \"\"\"You are given a string s.\n    Your task is to check if the string is happy or not.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n    For example:\n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n",
    "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n",
    "entry_point": "is_happy",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/81",
    "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
    "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
    "entry_point": "numerical_letter_grade",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/82",
    "prompt": "\ndef prime_length(string):\n    \"\"\"Write a function that takes a string and returns True if the string\n    length is a prime number or False otherwise\n    Examples\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n",
    "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n",
    "entry_point": "prime_length",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/83",
    "prompt": "\ndef starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n",
    "canonical_solution": "    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
    "entry_point": "starts_one_ends",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/84",
    "prompt": "\ndef solve(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n",
    "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n",
    "entry_point": "solve",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/85",
    "prompt": "\ndef add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n",
    "canonical_solution": "    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n",
    "entry_point": "add",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/86",
    "prompt": "\ndef anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n",
    "canonical_solution": "    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
    "entry_point": "anti_shuffle",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/87",
    "prompt": "\ndef get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n",
    "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
    "entry_point": "get_row",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/88",
    "prompt": "\ndef sort_array(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n",
    "canonical_solution": "    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n",
    "entry_point": "sort_array",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/89",
    "prompt": "\ndef encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n",
    "canonical_solution": "    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
    "entry_point": "encrypt",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/9",
    "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
    "canonical_solution": "    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n",
    "entry_point": "rolling_max",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/90",
    "prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n",
    "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
    "entry_point": "next_smallest",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/91",
    "prompt": "\ndef is_bored(S):\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n   \n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
    "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
    "entry_point": "is_bored",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/92",
    "prompt": "\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u279e True\n    \n    any_int(3, 2, 2) \u279e False\n\n    any_int(3, -2, 1) \u279e True\n    \n    any_int(3.6, -2.2, 2) \u279e False\n  \n\n    \n    '''\n",
    "canonical_solution": "    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n",
    "entry_point": "any_int",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/93",
    "prompt": "\ndef encode(message):\n    \"\"\"\n    Write a function that takes a message, and encodes in such a \n    way that it swaps case of all letters, replaces all vowels in \n    the message with the letter that appears 2 places ahead of that \n    vowel in the english alphabet. \n    Assume only letters. \n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n",
    "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
    "entry_point": "encode",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/94",
    "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
    "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n",
    "entry_point": "skjkasdkd",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/95",
    "prompt": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
    "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n",
    "entry_point": "check_dict_case",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/96",
    "prompt": "\ndef count_up_to(n):\n    \"\"\"Implement a function that takes an non-negative integer and returns an array of the first n\n    integers that are prime numbers and less than n.\n    for example:\n    count_up_to(5) => [2,3]\n    count_up_to(11) => [2,3,5,7]\n    count_up_to(0) => []\n    count_up_to(20) => [2,3,5,7,11,13,17,19]\n    count_up_to(1) => []\n    count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"\n",
    "canonical_solution": "    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
    "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n",
    "entry_point": "count_up_to",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/97",
    "prompt": "\ndef multiply(a, b):\n    \"\"\"Complete the function that takes two integers and returns \n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.\n    \"\"\"\n",
    "canonical_solution": "    return abs(a % 10) * abs(b % 10)\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n",
    "entry_point": "multiply",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/98",
    "prompt": "\ndef count_upper(s):\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper('aBCdEf') returns 1\n    count_upper('abcdefg') returns 0\n    count_upper('dBBE') returns 0\n    \"\"\"\n",
    "canonical_solution": "    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
    "entry_point": "count_upper",
    "dataset": "HumanEval"
  },
  {
    "task_id": "HumanEval/99",
    "prompt": "\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
    "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n",
    "entry_point": "closest_integer",
    "dataset": "HumanEval"
  },
  {
    "task_id": "MBPP/100",
    "prompt": "Write a function to find the next smallest palindrome of a specified number.",
    "canonical_solution": "import sys\r\ndef next_smallest_palindrome(num):\r\n    numstr = str(num)\r\n    for i in range(num+1,sys.maxsize):\r\n        if str(i) == str(i)[::-1]:\r\n            return i",
    "test": "['assert next_smallest_palindrome(99)==101', 'assert next_smallest_palindrome(1221)==1331', 'assert next_smallest_palindrome(120)==121']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/101",
    "prompt": "Write a function to find the kth element in the given array.",
    "canonical_solution": "def kth_element(arr, n, k):\r\n  for i in range(n):\r\n    for j in range(0, n-i-1):\r\n      if arr[j] > arr[j+1]:\r\n        arr[j], arr[j+1] == arr[j+1], arr[j]\r\n  return arr[k-1]",
    "test": "['assert kth_element([12,3,5,7,19], 5, 2) == 3', 'assert kth_element([17,24,8,23], 4, 3) == 8', 'assert kth_element([16,21,25,36,4], 5, 4) == 36']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/102",
    "prompt": "Write a function to convert snake case string to camel case string.",
    "canonical_solution": "def snake_to_camel(word):\r\n        import re\r\n        return ''.join(x.capitalize() or '_' for x in word.split('_'))",
    "test": "[\"assert snake_to_camel('python_program')=='PythonProgram'\", \"assert snake_to_camel('python_language')==('PythonLanguage')\", \"assert snake_to_camel('programming_language')==('ProgrammingLanguage')\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/103",
    "prompt": "Write a function to find eulerian number a(n, m).",
    "canonical_solution": "def eulerian_num(n, m): \r\n\tif (m >= n or n == 0): \r\n\t\treturn 0 \r\n\tif (m == 0): \r\n\t\treturn 1 \r\n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))",
    "test": "['assert eulerian_num(3, 1) == 4', 'assert eulerian_num(4, 1) == 11', 'assert eulerian_num(5, 3) == 26']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/104",
    "prompt": "Write a function to sort each sublist of strings in a given list of lists using lambda function.",
    "canonical_solution": "def sort_sublists(input_list):\r\n    result = [sorted(x, key = lambda x:x[0]) for x in input_list] \r\n    return result\r",
    "test": "['assert sort_sublists(([\"green\", \"orange\"], [\"black\", \"white\"], [\"white\", \"black\", \"orange\"]))==[[\\'green\\', \\'orange\\'], [\\'black\\', \\'white\\'], [\\'black\\', \\'orange\\', \\'white\\']]', 'assert sort_sublists(([\" red \",\"green\" ],[\"blue \",\" black\"],[\" orange\",\"brown\"]))==[[\\' red \\', \\'green\\'], [\\' black\\', \\'blue \\'], [\\' orange\\', \\'brown\\']]', 'assert sort_sublists(([\"zilver\",\"gold\"], [\"magnesium\",\"aluminium\"], [\"steel\", \"bronze\"]))==[[\\'gold\\', \\'zilver\\'],[\\'aluminium\\', \\'magnesium\\'], [\\'bronze\\', \\'steel\\']]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/105",
    "prompt": "Write a python function to count true booleans in the given list.",
    "canonical_solution": "def count(lst):   \r\n    return sum(lst) ",
    "test": "['assert count([True,False,True]) == 2', 'assert count([False,False]) == 0', 'assert count([True,True,True]) == 3']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/106",
    "prompt": "Write a function to add the given list to the given tuples.",
    "canonical_solution": "def add_lists(test_list, test_tup):\r\n  res = tuple(list(test_tup) + test_list)\r\n  return (res) ",
    "test": "['assert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)', 'assert add_lists([6, 7, 8], (10, 11)) == (10, 11, 6, 7, 8)', 'assert add_lists([7, 8, 9], (11, 12)) == (11, 12, 7, 8, 9)']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/107",
    "prompt": "Write a python function to count hexadecimal numbers for a given range.",
    "canonical_solution": "def count_Hexadecimal(L,R) :  \r\n    count = 0;  \r\n    for i in range(L,R + 1) : \r\n        if (i >= 10 and i <= 15) : \r\n            count += 1;  \r\n        elif (i > 15) : \r\n            k = i;  \r\n            while (k != 0) :  \r\n                if (k % 16 >= 10) : \r\n                    count += 1;  \r\n                k = k // 16;  \r\n    return count;  ",
    "test": "['assert count_Hexadecimal(10,15) == 6', 'assert count_Hexadecimal(2,4) == 0', 'assert count_Hexadecimal(15,16) == 1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/108",
    "prompt": "Write a function to merge multiple sorted inputs into a single sorted iterator using heap queue algorithm.",
    "canonical_solution": "import heapq\r\ndef merge_sorted_list(num1,num2,num3):\r\n  num1=sorted(num1)\r\n  num2=sorted(num2)\r\n  num3=sorted(num3)\r\n  result = heapq.merge(num1,num2,num3)\r\n  return list(result)",
    "test": "['assert merge_sorted_list([25, 24, 15, 4, 5, 29, 110],[19, 20, 11, 56, 25, 233, 154],[24, 26, 54, 48])==[4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]', 'assert merge_sorted_list([1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12])==[1, 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12]', 'assert merge_sorted_list([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1],[25, 35, 22, 85, 14, 65, 75, 25, 58],[12, 74, 9, 50, 61, 41])==[1, 2, 3, 4, 7, 8, 9, 9, 9, 10, 12, 14, 14, 18, 22, 25, 25, 35, 41, 50, 58, 61, 65, 74, 75, 85]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/109",
    "prompt": "Write a python function to find the count of rotations of a binary string with odd value.",
    "canonical_solution": "def odd_Equivalent(s,n): \r\n    count=0\r\n    for i in range(0,n): \r\n        if (s[i] == '1'): \r\n            count = count + 1\r\n    return count ",
    "test": "['assert odd_Equivalent(\"011001\",6) == 3', 'assert odd_Equivalent(\"11011\",5) == 4', 'assert odd_Equivalent(\"1010\",4) == 2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/11",
    "prompt": "Write a python function to remove first and last occurrence of a given character from the string.",
    "canonical_solution": "def remove_Occ(s,ch): \r\n    for i in range(len(s)): \r\n        if (s[i] == ch): \r\n            s = s[0 : i] + s[i + 1:] \r\n            break\r\n    for i in range(len(s) - 1,-1,-1):  \r\n        if (s[i] == ch): \r\n            s = s[0 : i] + s[i + 1:] \r\n            break\r\n    return s ",
    "test": "['assert remove_Occ(\"hello\",\"l\") == \"heo\"', 'assert remove_Occ(\"abcda\",\"a\") == \"bcd\"', 'assert remove_Occ(\"PHP\",\"P\") == \"H\"']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/110",
    "prompt": "Write a function to extract the ranges that are missing from the given list with the given start range and end range values.",
    "canonical_solution": "def extract_missing(test_list, strt_val, stop_val):\r\n  res = []\r\n  for sub in test_list:\r\n    if sub[0] > strt_val:\r\n      res.append((strt_val, sub[0]))\r\n      strt_val = sub[1]\r\n    if strt_val < stop_val:\r\n      res.append((strt_val, stop_val))\r\n  return (res) ",
    "test": "['assert extract_missing([(6, 9), (15, 34), (48, 70)], 2, 100) == [(2, 6), (9, 100), (9, 15), (34, 100), (34, 48), (70, 100)]', 'assert extract_missing([(7, 2), (15, 19), (38, 50)], 5, 60) == [(5, 7), (2, 60), (2, 15), (19, 60), (19, 38), (50, 60)]', 'assert extract_missing([(7, 2), (15, 19), (38, 50)], 1, 52) == [(1, 7), (2, 52), (2, 15), (19, 52), (19, 38), (50, 52)]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/111",
    "prompt": "Write a function to find common elements in given nested lists. * list item * list item * list item * list item",
    "canonical_solution": "def common_in_nested_lists(nestedlist):\r\n    result = list(set.intersection(*map(set, nestedlist)))\r\n    return result",
    "test": "['assert common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])==[18, 12]', 'assert common_in_nested_lists([[12, 5, 23, 25, 45], [7, 11, 5, 23, 28], [1, 5, 8, 18, 23, 16]])==[5,23]', 'assert common_in_nested_lists([[2, 3,4, 1], [4, 5], [6,4, 8],[4, 5], [6, 8,4]])==[4]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/112",
    "prompt": "Write a python function to find the perimeter of a cylinder.",
    "canonical_solution": "def perimeter(diameter,height) : \r\n    return 2*(diameter+height)  ",
    "test": "['assert perimeter(2,4) == 12', 'assert perimeter(1,2) == 6', 'assert perimeter(3,1) == 8']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/113",
    "prompt": "Write a function to check if a string represents an integer or not.",
    "canonical_solution": "def check_integer(text):\r\n text = text.strip()\r\n if len(text) < 1:\r\n    return None\r\n else:\r\n     if all(text[i] in \"0123456789\" for i in range(len(text))):\r\n          return True\r\n     elif (text[0] in \"+-\") and \\\r\n         all(text[i] in \"0123456789\" for i in range(1,len(text))):\r\n         return True\r\n     else:\r\n        return False",
    "test": "['assert check_integer(\"python\")==False', 'assert check_integer(\"1\")==True', 'assert check_integer(\"12345\")==True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/114",
    "prompt": "Write a function to assign frequency to each tuple in the given tuple list.",
    "canonical_solution": "from collections import Counter \r\ndef assign_freq(test_list):\r\n  res = [(*key, val) for key, val in Counter(test_list).items()]\r\n  return (str(res)) ",
    "test": "[\"assert assign_freq([(6, 5, 8), (2, 7), (6, 5, 8), (6, 5, 8), (9, ), (2, 7)] ) == '[(6, 5, 8, 3), (2, 7, 2), (9, 1)]'\", \"assert assign_freq([(4, 2, 4), (7, 1), (4, 8), (4, 2, 4), (9, 2), (7, 1)] ) == '[(4, 2, 4, 2), (7, 1, 2), (4, 8, 1), (9, 2, 1)]'\", \"assert assign_freq([(11, 13, 10), (17, 21), (4, 2, 3), (17, 21), (9, 2), (4, 2, 3)] ) == '[(11, 13, 10, 1), (17, 21, 2), (4, 2, 3, 2), (9, 2, 1)]'\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/115",
    "prompt": "Write a function to check whether all dictionaries in a list are empty or not.",
    "canonical_solution": "def empty_dit(list1):\r\n empty_dit=all(not d for d in list1)\r\n return empty_dit",
    "test": "['assert empty_dit([{},{},{}])==True', 'assert empty_dit([{1,2},{},{}])==False', 'assert empty_dit({})==True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/116",
    "prompt": "Write a function to convert a given tuple of positive integers into an integer.",
    "canonical_solution": "def tuple_to_int(nums):\r\n    result = int(''.join(map(str,nums)))\r\n    return result",
    "test": "['assert tuple_to_int((1,2,3))==123', 'assert tuple_to_int((4,5,6))==456', 'assert tuple_to_int((5,6,7))==567']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/117",
    "prompt": "Write a function to convert all possible convertible elements in the list to float.",
    "canonical_solution": "def list_to_float(test_list):\r\n  res = []\r\n  for tup in test_list:\r\n    temp = []\r\n    for ele in tup:\r\n      if ele.isalpha():\r\n        temp.append(ele)\r\n      else:\r\n        temp.append(float(ele))\r\n    res.append((temp[0],temp[1])) \r\n  return (str(res)) ",
    "test": "['assert list_to_float( [(\"3\", \"4\"), (\"1\", \"26.45\"), (\"7.32\", \"8\"), (\"4\", \"8\")] ) == \\'[(3.0, 4.0), (1.0, 26.45), (7.32, 8.0), (4.0, 8.0)]\\'', 'assert list_to_float( [(\"4\", \"4\"), (\"2\", \"27\"), (\"4.12\", \"9\"), (\"7\", \"11\")] ) == \\'[(4.0, 4.0), (2.0, 27.0), (4.12, 9.0), (7.0, 11.0)]\\'', 'assert list_to_float( [(\"6\", \"78\"), (\"5\", \"26.45\"), (\"1.33\", \"4\"), (\"82\", \"13\")] ) == \\'[(6.0, 78.0), (5.0, 26.45), (1.33, 4.0), (82.0, 13.0)]\\'']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/118",
    "prompt": "[link text](https:// [link text](https:// [link text](https://)))write a function to convert a string to a list.",
    "canonical_solution": "def string_to_list(string): \r\n    lst = list(string.split(\" \")) \r\n    return lst",
    "test": "['assert string_to_list(\"python programming\")==[\\'python\\',\\'programming\\']', 'assert string_to_list(\"lists tuples strings\")==[\\'lists\\',\\'tuples\\',\\'strings\\']', 'assert string_to_list(\"write a program\")==[\\'write\\',\\'a\\',\\'program\\']']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/119",
    "prompt": "Write a python function to find the element that appears only once in a sorted array.",
    "canonical_solution": "def search(arr,n) :\r\n    XOR = 0\r\n    for i in range(n) :\r\n        XOR = XOR ^ arr[i]\r\n    return (XOR)",
    "test": "['assert search([1,1,2,2,3],5) == 3', 'assert search([1,1,3,3,4,4,5,5,7,7,8],11) == 8', 'assert search([1,2,2,3,3,4,4],7) == 1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/12",
    "prompt": "Write a function to sort a given matrix in ascending order according to the sum of its rows.",
    "canonical_solution": "def sort_matrix(M):\r\n    result = sorted(M, key=sum)\r\n    return result",
    "test": "['assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]', 'assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]', 'assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/120",
    "prompt": "Write a function to find the maximum product from the pairs of tuples within a given list.",
    "canonical_solution": "def max_product_tuple(list1):\r\n    result_max = max([abs(x * y) for x, y in list1] )\r\n    return result_max",
    "test": "['assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36', 'assert max_product_tuple([(10,20), (15,2), (5,10)] )==200', 'assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/121",
    "prompt": "Write a function to find the triplet with sum of the given array",
    "canonical_solution": "def check_triplet(A, n, sum, count):\r\n    if count == 3 and sum == 0:\r\n        return True\r\n    if count == 3 or n == 0 or sum < 0:\r\n        return False\r\n    return check_triplet(A, n - 1, sum - A[n - 1], count + 1) or\\\r\n           check_triplet(A, n - 1, sum, count)",
    "test": "['assert check_triplet([2, 7, 4, 0, 9, 5, 1, 3], 8, 6, 0) == True', 'assert check_triplet([1, 4, 5, 6, 7, 8, 5, 9], 8, 6, 0) == False', 'assert check_triplet([10, 4, 2, 3, 5], 5, 15, 0) == True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/122",
    "prompt": "Write a function to find n\u2019th smart number.",
    "canonical_solution": "MAX = 3000 \r\ndef smartNumber(n): \r\n\tprimes = [0] * MAX \r\n\tresult = [] \r\n\tfor i in range(2, MAX): \r\n\t\tif (primes[i] == 0): \r\n\t\t\tprimes[i] = 1 \r\n\t\t\tj = i * 2 \r\n\t\t\twhile (j < MAX): \r\n\t\t\t\tprimes[j] -= 1 \r\n\t\t\t\tif ( (primes[j] + 3) == 0): \r\n\t\t\t\t\tresult.append(j) \r\n\t\t\t\tj = j + i \r\n\tresult.sort() \r\n\treturn result[n - 1] ",
    "test": "['assert smartNumber(1) == 30', 'assert smartNumber(50) == 273', 'assert smartNumber(1000) == 2664']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/123",
    "prompt": "Write a function to sum all amicable numbers from 1 to a specified number.",
    "canonical_solution": "def amicable_numbers_sum(limit):\r\n    if not isinstance(limit, int):\r\n        return \"Input is not an integer!\"\r\n    if limit < 1:\r\n        return \"Input must be bigger than 0!\"\r\n    amicables = set()\r\n    for num in range(2, limit+1):\r\n        if num in amicables:\r\n            continue\r\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\r\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\r\n        if num == sum_fact2 and num != sum_fact:\r\n            amicables.add(num)\r\n            amicables.add(sum_fact2)\r\n    return sum(amicables)",
    "test": "['assert amicable_numbers_sum(999)==504', 'assert amicable_numbers_sum(9999)==31626', 'assert amicable_numbers_sum(99)==0']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/124",
    "prompt": "Write a function to get the angle of a complex number.",
    "canonical_solution": "import cmath\r\ndef angle_complex(a,b):\r\n  cn=complex(a,b)\r\n  angle=cmath.phase(a+b)\r\n  return angle",
    "test": "['assert angle_complex(0,1j)==1.5707963267948966 ', 'assert angle_complex(2,1j)==0.4636476090008061', 'assert angle_complex(0,2j)==1.5707963267948966']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/125",
    "prompt": "Write a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.",
    "canonical_solution": "def find_length(string, n): \r\n\tcurrent_sum = 0\r\n\tmax_sum = 0\r\n\tfor i in range(n): \r\n\t\tcurrent_sum += (1 if string[i] == '0' else -1) \r\n\t\tif current_sum < 0: \r\n\t\t\tcurrent_sum = 0\r\n\t\tmax_sum = max(current_sum, max_sum) \r\n\treturn max_sum if max_sum else 0",
    "test": "['assert find_length(\"11000010001\", 11) == 6', 'assert find_length(\"10111\", 5) == 1', 'assert find_length(\"11011101100101\", 14) == 2 ']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/126",
    "prompt": "Write a python function to find the sum of common divisors of two given numbers.",
    "canonical_solution": "def sum(a,b): \r\n    sum = 0\r\n    for i in range (1,min(a,b)): \r\n        if (a % i == 0 and b % i == 0): \r\n            sum += i \r\n    return sum",
    "test": "['assert sum(10,15) == 6', 'assert sum(100,150) == 93', 'assert sum(4,6) == 3']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/127",
    "prompt": "Write a function to multiply two integers without using the * operator in python.",
    "canonical_solution": "def multiply_int(x, y):\r\n    if y < 0:\r\n        return -multiply_int(x, -y)\r\n    elif y == 0:\r\n        return 0\r\n    elif y == 1:\r\n        return x\r\n    else:\r\n        return x + multiply_int(x, y - 1)",
    "test": "['assert multiply_int(10,20)==200', 'assert multiply_int(5,10)==50', 'assert multiply_int(4,8)==32']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/128",
    "prompt": "Write a function to shortlist words that are longer than n from a given list of words.",
    "canonical_solution": "def long_words(n, str):\r\n    word_len = []\r\n    txt = str.split(\" \")\r\n    for x in txt:\r\n        if len(x) > n:\r\n            word_len.append(x)\r\n    return word_len\t",
    "test": "['assert long_words(3,\"python is a programming language\")==[\\'python\\',\\'programming\\',\\'language\\']', 'assert long_words(2,\"writing a program\")==[\\'writing\\',\\'program\\']', 'assert long_words(5,\"sorting list\")==[\\'sorting\\']']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/129",
    "prompt": "Write a function to calculate magic square.",
    "canonical_solution": "def magic_square_test(my_matrix):\r\n    iSize = len(my_matrix[0])\r\n    sum_list = []\r\n    sum_list.extend([sum (lines) for lines in my_matrix])   \r\n    for col in range(iSize):\r\n        sum_list.append(sum(row[col] for row in my_matrix))\r\n    result1 = 0\r\n    for i in range(0,iSize):\r\n        result1 +=my_matrix[i][i]\r\n    sum_list.append(result1)      \r\n    result2 = 0\r\n    for i in range(iSize-1,-1,-1):\r\n        result2 +=my_matrix[i][i]\r\n    sum_list.append(result2)\r\n    if len(set(sum_list))>1:\r\n        return False\r\n    return True",
    "test": "['assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True', 'assert magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 8]])==True', 'assert magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 7]])==False']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/13",
    "prompt": "Write a function to count the most common words in a dictionary.",
    "canonical_solution": "from collections import Counter\r\ndef count_common(words):\r\n  word_counts = Counter(words)\r\n  top_four = word_counts.most_common(4)\r\n  return (top_four)\r\n",
    "test": "['assert count_common([\\'red\\',\\'green\\',\\'black\\',\\'pink\\',\\'black\\',\\'white\\',\\'black\\',\\'eyes\\',\\'white\\',\\'black\\',\\'orange\\',\\'pink\\',\\'pink\\',\\'red\\',\\'red\\',\\'white\\',\\'orange\\',\\'white\\',\"black\",\\'pink\\',\\'green\\',\\'green\\',\\'pink\\',\\'green\\',\\'pink\\',\\'white\\',\\'orange\\',\"orange\",\\'red\\']) == [(\\'pink\\', 6), (\\'black\\', 5), (\\'white\\', 5), (\\'red\\', 4)]', \"assert count_common(['one', 'two', 'three', 'four', 'five', 'one', 'two', 'one', 'three', 'one']) == [('one', 4), ('two', 2), ('three', 2), ('four', 1)]\", \"assert count_common(['Facebook', 'Apple', 'Amazon', 'Netflix', 'Google', 'Apple', 'Netflix', 'Amazon']) == [('Apple', 2), ('Amazon', 2), ('Netflix', 2), ('Facebook', 1)]\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/130",
    "prompt": "Write a function to find the item with maximum frequency in a given list.",
    "canonical_solution": "from collections import defaultdict\r\ndef max_occurrences(nums):\r\n    dict = defaultdict(int)\r\n    for i in nums:\r\n        dict[i] += 1\r\n    result = max(dict.items(), key=lambda x: x[1]) \r\n    return result",
    "test": "['assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==(2, 5)', 'assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,16,18])==(8, 2)', 'assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==(20, 3)']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/131",
    "prompt": "Write a python function to reverse only the vowels of a given string.",
    "canonical_solution": "def reverse_vowels(str1):\r\n\tvowels = \"\"\r\n\tfor char in str1:\r\n\t\tif char in \"aeiouAEIOU\":\r\n\t\t\tvowels += char\r\n\tresult_string = \"\"\r\n\tfor char in str1:\r\n\t\tif char in \"aeiouAEIOU\":\r\n\t\t\tresult_string += vowels[-1]\r\n\t\t\tvowels = vowels[:-1]\r\n\t\telse:\r\n\t\t\tresult_string += char\r\n\treturn result_string",
    "test": "['assert reverse_vowels(\"Python\") == \"Python\"', 'assert reverse_vowels(\"USA\") == \"ASU\"', 'assert reverse_vowels(\"ab\") == \"ab\"']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/132",
    "prompt": "Write a function to convert tuple to a string.",
    "canonical_solution": "def tup_string(tup1):\r\n  str =  ''.join(tup1)\r\n  return str",
    "test": "['assert tup_string((\\'e\\', \\'x\\', \\'e\\', \\'r\\', \\'c\\', \\'i\\', \\'s\\', \\'e\\', \\'s\\'))==(\"exercises\")', 'assert tup_string((\\'p\\',\\'y\\',\\'t\\',\\'h\\',\\'o\\',\\'n\\'))==(\"python\")', 'assert tup_string((\\'p\\',\\'r\\',\\'o\\',\\'g\\',\\'r\\',\\'a\\',\\'m\\'))==(\"program\")']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/133",
    "prompt": "Write a function to calculate the sum of the negative numbers of a given list of numbers using lambda function.",
    "canonical_solution": "def sum_negativenum(nums):\r\n  sum_negativenum = list(filter(lambda nums:nums<0,nums))\r\n  return sum(sum_negativenum)",
    "test": "['assert sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17])==-32', 'assert sum_negativenum([10,15,-14,13,-18,12,-20])==-52', 'assert sum_negativenum([19, -65, 57, 39, 152,-639, 121, 44, 90, -190])==-894']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/134",
    "prompt": "Write a python function to check whether the last element of given array is even or odd after performing an operation p times.",
    "canonical_solution": "def check_last (arr,n,p): \r\n    _sum = 0\r\n    for i in range(n): \r\n        _sum = _sum + arr[i] \r\n    if p == 1: \r\n        if _sum % 2 == 0: \r\n            return \"ODD\"\r\n        else: \r\n            return \"EVEN\"\r\n    return \"EVEN\"\r\n      ",
    "test": "['assert check_last([5,7,10],3,1) == \"ODD\"', 'assert check_last([2,3],2,3) == \"EVEN\"', 'assert check_last([1,2,3],3,1) == \"ODD\"']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/135",
    "prompt": "Write a function to find the nth hexagonal number.",
    "canonical_solution": "def hexagonal_num(n): \r\n\treturn n*(2*n - 1) ",
    "test": "['assert hexagonal_num(10) == 190', 'assert hexagonal_num(5) == 45', 'assert hexagonal_num(7) == 91']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/136",
    "prompt": "Write a function to calculate electricity bill.",
    "canonical_solution": "def cal_electbill(units):\r\n if(units < 50):\r\n    amount = units * 2.60\r\n    surcharge = 25\r\n elif(units <= 100):\r\n    amount = 130 + ((units - 50) * 3.25)\r\n    surcharge = 35\r\n elif(units <= 200):\r\n    amount = 130 + 162.50 + ((units - 100) * 5.26)\r\n    surcharge = 45\r\n else:\r\n    amount = 130 + 162.50 + 526 + ((units - 200) * 8.45)\r\n    surcharge = 75\r\n total = amount + surcharge\r\n return total",
    "test": "['assert cal_electbill(75)==246.25', 'assert cal_electbill(265)==1442.75', 'assert cal_electbill(100)==327.5']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/137",
    "prompt": "Write a function to find the ration of zeroes in an array of integers.",
    "canonical_solution": "from array import array\r\ndef zero_count(nums):\r\n    n = len(nums)\r\n    n1 = 0\r\n    for x in nums:\r\n        if x == 0:\r\n            n1 += 1\r\n        else:\r\n          None\r\n    return round(n1/n,2)",
    "test": "['assert zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])==0.15', 'assert zero_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==0.00', 'assert zero_count([2, 4, -6, -9, 11, -12, 14, -5, 17])==0.00']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/138",
    "prompt": "Write a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.",
    "canonical_solution": "def is_Sum_Of_Powers_Of_Two(n): \r\n    if (n % 2 == 1): \r\n        return False\r\n    else: \r\n        return True",
    "test": "['assert is_Sum_Of_Powers_Of_Two(10) == True', 'assert is_Sum_Of_Powers_Of_Two(7) == False', 'assert is_Sum_Of_Powers_Of_Two(14) == True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/139",
    "prompt": "Write a function to find the circumference of a circle.",
    "canonical_solution": "def circle_circumference(r):\r\n  perimeter=2*3.1415*r\r\n  return perimeter",
    "test": "['assert circle_circumference(10)==62.830000000000005', 'assert circle_circumference(5)==31.415000000000003', 'assert circle_circumference(4)==25.132']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/14",
    "prompt": "Write a python function to find the volume of a triangular prism.",
    "canonical_solution": "def find_Volume(l,b,h) : \r\n    return ((l * b * h) / 2) ",
    "test": "['assert find_Volume(10,8,6) == 240', 'assert find_Volume(3,2,2) == 6', 'assert find_Volume(1,2,1) == 1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/140",
    "prompt": "Write a function to extract elements that occur singly in the given tuple list.",
    "canonical_solution": "def extract_singly(test_list):\r\n  res = []\r\n  temp = set()\r\n  for inner in test_list:\r\n    for ele in inner:\r\n      if not ele in temp:\r\n        temp.add(ele)\r\n        res.append(ele)\r\n  return (res) ",
    "test": "['assert extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)]) == [3, 4, 5, 7, 1]', 'assert extract_singly([(1, 2, 3), (4, 2, 3), (7, 8)]) == [1, 2, 3, 4, 7, 8]', 'assert extract_singly([(7, 8, 9), (10, 11, 12), (10, 11)]) == [7, 8, 9, 10, 11, 12]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/141",
    "prompt": "Write a function to sort a list of elements using pancake sort.",
    "canonical_solution": "def pancake_sort(nums):\r\n    arr_len = len(nums)\r\n    while arr_len > 1:\r\n        mi = nums.index(max(nums[0:arr_len]))\r\n        nums = nums[mi::-1] + nums[mi+1:len(nums)]\r\n        nums = nums[arr_len-1::-1] + nums[arr_len:len(nums)]\r\n        arr_len -= 1\r\n    return nums",
    "test": "['assert pancake_sort([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]', 'assert pancake_sort([98, 12, 54, 36, 85]) == [12, 36, 54, 85, 98]', 'assert pancake_sort([41, 42, 32, 12, 23]) == [12, 23, 32, 41, 42]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/142",
    "prompt": "Write a function to count the same pair in three given lists.",
    "canonical_solution": "def count_samepair(list1,list2,list3):\r\n    result = sum(m == n == o for m, n, o in zip(list1,list2,list3))\r\n    return result",
    "test": "['assert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,9],[2,1,3,1,2,6,7,9])==3', 'assert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,8],[2,1,3,1,2,6,7,8])==4', 'assert count_samepair([1,2,3,4,2,6,7,8],[2,2,3,1,2,6,7,8],[2,1,3,1,2,6,7,8])==5']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/143",
    "prompt": "Write a function to find number of lists present in the given tuple.",
    "canonical_solution": "def find_lists(Input): \r\n\tif isinstance(Input, list): \r\n\t\treturn 1\r\n\telse: \r\n\t\treturn len(Input) ",
    "test": "['assert find_lists(([1, 2, 3, 4], [5, 6, 7, 8])) == 2', 'assert find_lists(([1, 2], [3, 4], [5, 6]))  == 3', 'assert find_lists(([9, 8, 7, 6, 5, 4, 3, 2, 1])) == 1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/144",
    "prompt": "Write a python function to find the sum of absolute differences in all pairs of the given array.",
    "canonical_solution": "def sum_Pairs(arr,n): \r\n    sum = 0\r\n    for i in range(n - 1,-1,-1): \r\n        sum += i*arr[i] - (n-1-i) * arr[i] \r\n    return sum",
    "test": "['assert sum_Pairs([1,8,9,15,16],5) == 74', 'assert sum_Pairs([1,2,3,4],4) == 10', 'assert sum_Pairs([1,2,3,4,5,7,9,11,14],9) == 188']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/145",
    "prompt": "Write a python function to find the maximum difference between any two elements in a given array.",
    "canonical_solution": "def max_Abs_Diff(arr,n): \r\n    minEle = arr[0] \r\n    maxEle = arr[0] \r\n    for i in range(1, n): \r\n        minEle = min(minEle,arr[i]) \r\n        maxEle = max(maxEle,arr[i]) \r\n    return (maxEle - minEle) ",
    "test": "['assert max_Abs_Diff((2,1,5,3),4) == 4', 'assert max_Abs_Diff((9,3,2,5,1),5) == 8', 'assert max_Abs_Diff((3,2,1),3) == 2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/146",
    "prompt": "Write a function to find the ascii value of total characters in a string.",
    "canonical_solution": "def ascii_value_string(str1):\r\n  for i in range(len(str1)):\r\n   return ord(str1[i])",
    "test": "['assert ascii_value_string(\"python\")==112', 'assert ascii_value_string(\"Program\")==80', 'assert ascii_value_string(\"Language\")==76']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/147",
    "prompt": "Write a function to find the maximum total path sum in the given triangle.",
    "canonical_solution": "def max_path_sum(tri, m, n): \r\n\tfor i in range(m-1, -1, -1): \r\n\t\tfor j in range(i+1): \r\n\t\t\tif (tri[i+1][j] > tri[i+1][j+1]): \r\n\t\t\t\ttri[i][j] += tri[i+1][j] \r\n\t\t\telse: \r\n\t\t\t\ttri[i][j] += tri[i+1][j+1] \r\n\treturn tri[0][0]",
    "test": "['assert max_path_sum([[1, 0, 0], [4, 8, 0], [1, 5, 3]], 2, 2) == 14', 'assert max_path_sum([[13, 0, 0], [7, 4, 0], [2, 4, 6]], 2, 2) == 24 ', 'assert max_path_sum([[2, 0, 0], [11, 18, 0], [21, 25, 33]], 2, 2) == 53']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/148",
    "prompt": "Write a function to divide a number into two parts such that the sum of digits is maximum.",
    "canonical_solution": "def sum_digits_single(x) : \r\n    ans = 0\r\n    while x : \r\n        ans += x % 10\r\n        x //= 10  \r\n    return ans \r\ndef closest(x) : \r\n    ans = 0\r\n    while (ans * 10 + 9 <= x) : \r\n        ans = ans * 10 + 9  \r\n    return ans   \r\ndef sum_digits_twoparts(N) : \r\n    A = closest(N)  \r\n    return sum_digits_single(A) + sum_digits_single(N - A) ",
    "test": "['assert sum_digits_twoparts(35)==17', 'assert sum_digits_twoparts(7)==7', 'assert sum_digits_twoparts(100)==19']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/149",
    "prompt": "Write a function to find the longest subsequence such that the difference between adjacents is one for the given array.",
    "canonical_solution": "def longest_subseq_with_diff_one(arr, n): \r\n\tdp = [1 for i in range(n)] \r\n\tfor i in range(n): \r\n\t\tfor j in range(i): \r\n\t\t\tif ((arr[i] == arr[j]+1) or (arr[i] == arr[j]-1)): \r\n\t\t\t\tdp[i] = max(dp[i], dp[j]+1) \r\n\tresult = 1\r\n\tfor i in range(n): \r\n\t\tif (result < dp[i]): \r\n\t\t\tresult = dp[i] \r\n\treturn result",
    "test": "['assert longest_subseq_with_diff_one([1, 2, 3, 4, 5, 3, 2], 7) == 6', 'assert longest_subseq_with_diff_one([10, 9, 4, 5, 4, 8, 6], 7) == 3', 'assert longest_subseq_with_diff_one([1, 2, 3, 2, 3, 7, 2, 1], 8) == 7']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/15",
    "prompt": "Write a function to split a string at lowercase letters.",
    "canonical_solution": "import re\r\ndef split_lowerstring(text):\r\n return (re.findall('[a-z][^a-z]*', text))",
    "test": "['assert split_lowerstring(\"AbCd\")==[\\'bC\\',\\'d\\']', 'assert split_lowerstring(\"Python\")==[\\'y\\', \\'t\\', \\'h\\', \\'o\\', \\'n\\']', 'assert split_lowerstring(\"Programming\")==[\\'r\\', \\'o\\', \\'g\\', \\'r\\', \\'a\\', \\'m\\', \\'m\\', \\'i\\', \\'n\\', \\'g\\']']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/150",
    "prompt": "Write a python function to find whether the given number is present in the infinite sequence or not.",
    "canonical_solution": "def does_Contain_B(a,b,c): \r\n    if (a == b): \r\n        return True\r\n    if ((b - a) * c > 0 and (b - a) % c == 0): \r\n        return True\r\n    return False",
    "test": "['assert does_Contain_B(1,7,3) == True', 'assert does_Contain_B(1,-3,5) == False', 'assert does_Contain_B(3,2,5) == False']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/151",
    "prompt": "Write a python function to check whether the given number is co-prime or not.",
    "canonical_solution": "def gcd(p,q):\r\n    while q != 0:\r\n        p, q = q,p%q\r\n    return p\r\ndef is_coprime(x,y):\r\n    return gcd(x,y) == 1",
    "test": "['assert is_coprime(17,13) == True', 'assert is_coprime(15,21) == False', 'assert is_coprime(25,45) == False']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/152",
    "prompt": "Write a function to sort the given array by using merge sort.",
    "canonical_solution": "def merge(a,b):\r\n    c = []\r\n    while len(a) != 0 and len(b) != 0:\r\n        if a[0] < b[0]:\r\n            c.append(a[0])\r\n            a.remove(a[0])\r\n        else:\r\n            c.append(b[0])\r\n            b.remove(b[0])\r\n    if len(a) == 0:\r\n        c += b\r\n    else:\r\n        c += a\r\n    return c\r\ndef merge_sort(x):\r\n    if len(x) == 0 or len(x) == 1:\r\n        return x\r\n    else:\r\n        middle = len(x)//2\r\n        a = merge_sort(x[:middle])\r\n        b = merge_sort(x[middle:])\r\n        return merge(a,b)\r\n",
    "test": "['assert merge_sort([3, 4, 2, 6, 5, 7, 1, 9]) == [1, 2, 3, 4, 5, 6, 7, 9]', 'assert merge_sort([7, 25, 45, 78, 11, 33, 19]) == [7, 11, 19, 25, 33, 45, 78]', 'assert merge_sort([3, 1, 4, 9, 8]) == [1, 3, 4, 8, 9]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/153",
    "prompt": "Write a function to find the vertex of a parabola.",
    "canonical_solution": "def parabola_vertex(a, b, c): \r\n  vertex=(((-b / (2 * a)),(((4 * a * c) - (b * b)) / (4 * a))))\r\n  return vertex",
    "test": "['assert parabola_vertex(5,3,2)==(-0.3, 1.55)', 'assert parabola_vertex(9,8,4)==(-0.4444444444444444, 2.2222222222222223)', 'assert parabola_vertex(2,4,6)==(-1.0, 4.0)']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/154",
    "prompt": "Write a function to extract every specified element from a given two dimensional list.",
    "canonical_solution": "def specified_element(nums, N):\r\n    result = [i[N] for i in nums]\r\n    return result",
    "test": "['assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],0)==[1, 4, 7]', 'assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],2)==[3, 6, 9]', 'assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],3)==[2,2,5]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/155",
    "prompt": "Write a python function to toggle all even bits of a given number.",
    "canonical_solution": "def even_bit_toggle_number(n) : \r\n    res = 0; count = 0; temp = n \r\n    while (temp > 0) :     \r\n        if (count % 2 == 1) : \r\n            res = res | (1 << count)      \r\n        count = count + 1\r\n        temp >>= 1 \r\n    return n ^ res ",
    "test": "['assert even_bit_toggle_number(10) == 0', 'assert even_bit_toggle_number(20) == 30', 'assert even_bit_toggle_number(30) == 20']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/156",
    "prompt": "Write a function to convert a tuple of string values to a tuple of integer values.",
    "canonical_solution": "def tuple_int_str(tuple_str):\r\n    result = tuple((int(x[0]), int(x[1])) for x in tuple_str)\r\n    return result",
    "test": "[\"assert tuple_int_str((('333', '33'), ('1416', '55')))==((333, 33), (1416, 55))\", \"assert tuple_int_str((('999', '99'), ('1000', '500')))==((999, 99), (1000, 500))\", \"assert tuple_int_str((('666', '66'), ('1500', '555')))==((666, 66), (1500, 555))\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/157",
    "prompt": "Write a function to reflect the run-length encoding from a list.",
    "canonical_solution": "from itertools import groupby\r\ndef encode_list(list1):\r\n    return [[len(list(group)), key] for key, group in groupby(list1)]",
    "test": "['assert encode_list([1,1,2,3,4,4.3,5,1])==[[2, 1], [1, 2], [1, 3], [1, 4], [1, 4.3], [1, 5], [1, 1]]', \"assert encode_list('automatically')==[[1, 'a'], [1, 'u'], [1, 't'], [1, 'o'], [1, 'm'], [1, 'a'], [1, 't'], [1, 'i'], [1, 'c'], [1, 'a'], [2, 'l'], [1, 'y']]\", \"assert encode_list('python')==[[1, 'p'], [1, 'y'], [1, 't'], [1, 'h'], [1, 'o'], [1, 'n']]\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/158",
    "prompt": "Write a python function to find k number of operations required to make all elements equal.",
    "canonical_solution": "def min_Ops(arr,n,k): \r\n    max1 = max(arr) \r\n    res = 0\r\n    for i in range(0,n):  \r\n        if ((max1 - arr[i]) % k != 0): \r\n            return -1 \r\n        else: \r\n            res += (max1 - arr[i]) / k \r\n    return int(res) ",
    "test": "['assert min_Ops([2,2,2,2],4,3) == 0', 'assert min_Ops([4,2,6,8],4,3) == -1', 'assert min_Ops([21,33,9,45,63],5,6) == 24']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/159",
    "prompt": "Write a function to print the season for the given month and day.",
    "canonical_solution": "def month_season(month,days):\r\n if month in ('January', 'February', 'March'):\r\n\t season = 'winter'\r\n elif month in ('April', 'May', 'June'):\r\n\t season = 'spring'\r\n elif month in ('July', 'August', 'September'):\r\n\t season = 'summer'\r\n else:\r\n\t season = 'autumn'\r\n if (month == 'March') and (days > 19):\r\n\t season = 'spring'\r\n elif (month == 'June') and (days > 20):\r\n\t season = 'summer'\r\n elif (month == 'September') and (days > 21):\r\n\t season = 'autumn'\r\n elif (month == 'October') and (days > 21):\r\n\t season = 'autumn'\r\n elif (month == 'November') and (days > 21):\r\n\t season = 'autumn'\r\n elif (month == 'December') and (days > 20):\r\n\t season = 'winter'\r\n return season",
    "test": "[\"assert month_season('January',4)==('winter')\", \"assert month_season('October',28)==('autumn')\", \"assert month_season('June',6)==('spring')\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/16",
    "prompt": "Write a function to find sequences of lowercase letters joined with an underscore.",
    "canonical_solution": "import re\r\ndef text_lowercase_underscore(text):\r\n        patterns = '^[a-z]+_[a-z]+$'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')",
    "test": "['assert text_lowercase_underscore(\"aab_cbbbc\")==(\\'Found a match!\\')', 'assert text_lowercase_underscore(\"aab_Abbbc\")==(\\'Not matched!\\')', 'assert text_lowercase_underscore(\"Aaab_abbbc\")==(\\'Not matched!\\')']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/160",
    "prompt": "Write a function to find x and y that satisfies ax + by = n.",
    "canonical_solution": "def solution (a, b, n): \r\n\ti = 0\r\n\twhile i * a <= n: \r\n\t\tif (n - (i * a)) % b == 0: \r\n\t\t\treturn (\"x = \",i ,\", y = \", \r\n\t\t\tint((n - (i * a)) / b)) \r\n\t\t\treturn 0\r\n\t\ti = i + 1\r\n\treturn (\"No solution\") ",
    "test": "[\"assert solution(2, 3, 7) == ('x = ', 2, ', y = ', 1)\", \"assert solution(4, 2, 7) == 'No solution'\", \"assert solution(1, 13, 17) == ('x = ', 4, ', y = ', 1)\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/161",
    "prompt": "Write a function to remove all elements from a given list present in another list.",
    "canonical_solution": "def remove_elements(list1, list2):\r\n    result = [x for x in list1 if x not in list2]\r\n    return result",
    "test": "['assert remove_elements([1,2,3,4,5,6,7,8,9,10],[2,4,6,8])==[1, 3, 5, 7, 9, 10]', 'assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],[1, 3, 5, 7])==[2, 4, 6, 8, 9, 10]', 'assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],[5,7])==[1, 2, 3, 4, 6, 8, 9, 10]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/162",
    "prompt": "Write a function to calculate the sum of the positive integers of n+(n-2)+(n-4)... (until n-x =< 0).",
    "canonical_solution": "def sum_series(n):\r\n  if n < 1:\r\n    return 0\r\n  else:\r\n    return n + sum_series(n - 2)",
    "test": "['assert sum_series(6)==12', 'assert sum_series(10)==30', 'assert sum_series(9)==25']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/163",
    "prompt": "Write a function to calculate the area of a regular polygon.",
    "canonical_solution": "from math import tan, pi\r\ndef area_polygon(s,l):\r\n  area = s * (l ** 2) / (4 * tan(pi / s))\r\n  return area",
    "test": "['assert area_polygon(4,20)==400.00000000000006', 'assert area_polygon(10,15)==1731.1969896610804', 'assert area_polygon(9,7)==302.90938549487214']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/164",
    "prompt": "Write a python function to check whether the sum of divisors are same or not.",
    "canonical_solution": "import math \r\ndef divSum(n): \r\n    sum = 1; \r\n    i = 2; \r\n    while(i * i <= n): \r\n        if (n % i == 0): \r\n            sum = (sum + i +math.floor(n / i)); \r\n        i += 1; \r\n    return sum; \r\ndef areEquivalent(num1,num2): \r\n    return divSum(num1) == divSum(num2); ",
    "test": "['assert areEquivalent(36,57) == False', 'assert areEquivalent(2,4) == False', 'assert areEquivalent(23,47) == True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/165",
    "prompt": "Write a python function to count characters at same position in a given string (lower and uppercase characters) as in english alphabet.",
    "canonical_solution": "def count_char_position(str1): \r\n    count_chars = 0\r\n    for i in range(len(str1)):\r\n        if ((i == ord(str1[i]) - ord('A')) or \r\n            (i == ord(str1[i]) - ord('a'))): \r\n            count_chars += 1\r\n    return count_chars ",
    "test": "['assert count_char_position(\"xbcefg\") == 2', 'assert count_char_position(\"ABcED\") == 3', 'assert count_char_position(\"AbgdeF\") == 5']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/166",
    "prompt": "Write a python function to count the pairs with xor as an even number.",
    "canonical_solution": "def find_even_Pair(A,N): \r\n    evenPair = 0\r\n    for i in range(0,N): \r\n        for j in range(i+1,N): \r\n            if ((A[i] ^ A[j]) % 2 == 0): \r\n                evenPair+=1\r\n    return evenPair; ",
    "test": "['assert find_even_Pair([5,4,7,2,1],5) == 4', 'assert find_even_Pair([7,2,8,1,0,5,11],7) == 9', 'assert find_even_Pair([1,2,3],3) == 1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/167",
    "prompt": "Write a python function to find smallest power of 2 greater than or equal to n.",
    "canonical_solution": "def next_Power_Of_2(n): \r\n    count = 0; \r\n    if (n and not(n & (n - 1))): \r\n        return n   \r\n    while( n != 0): \r\n        n >>= 1\r\n        count += 1\r\n    return 1 << count; ",
    "test": "['assert next_Power_Of_2(0) == 1', 'assert next_Power_Of_2(5) == 8', 'assert next_Power_Of_2(17) == 32']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/168",
    "prompt": "Write a python function to find the frequency of a number in a given array.",
    "canonical_solution": "def frequency(a,x): \r\n    count = 0  \r\n    for i in a: \r\n        if i == x: count += 1\r\n    return count ",
    "test": "['assert frequency([1,2,3],4) == 0', 'assert frequency([1,2,2,3,3,3,4],3) == 3', 'assert frequency([0,1,2,3,1,2],1) == 2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/169",
    "prompt": "Write a function to calculate the nth pell number.",
    "canonical_solution": "def get_pell(n): \r\n\tif (n <= 2): \r\n\t\treturn n \r\n\ta = 1\r\n\tb = 2\r\n\tfor i in range(3, n+1): \r\n\t\tc = 2 * b + a \r\n\t\ta = b \r\n\t\tb = c \r\n\treturn b ",
    "test": "['assert get_pell(4) == 12', 'assert get_pell(7) == 169', 'assert get_pell(8) == 408']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/17",
    "prompt": "Write a function to find the perimeter of a square.",
    "canonical_solution": "def square_perimeter(a):\r\n  perimeter=4*a\r\n  return perimeter",
    "test": "['assert square_perimeter(10)==40', 'assert square_perimeter(5)==20', 'assert square_perimeter(4)==16']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/170",
    "prompt": "Write a function to find sum of the numbers in a list between the indices of a specified range.",
    "canonical_solution": "def sum_range_list(list1, m, n):                                                                                                                                                                                                \r\n    sum_range = 0                                                                                                                                                                                                         \r\n    for i in range(m, n+1, 1):                                                                                                                                                                                        \r\n        sum_range += list1[i]                                                                                                                                                                                                  \r\n    return sum_range   ",
    "test": "['assert sum_range_list( [2,1,5,6,8,3,4,9,10,11,8,12],8,10)==29', 'assert sum_range_list( [2,1,5,6,8,3,4,9,10,11,8,12],5,7)==16', 'assert sum_range_list( [2,1,5,6,8,3,4,9,10,11,8,12],7,10)==38']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/171",
    "prompt": "Write a function to find the perimeter of a pentagon.",
    "canonical_solution": "import math\r\ndef perimeter_pentagon(a):\r\n  perimeter=(5*a)\r\n  return perimeter",
    "test": "['assert perimeter_pentagon(5)==25', 'assert perimeter_pentagon(10)==50', 'assert perimeter_pentagon(15)==75']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/172",
    "prompt": "Write a function to find the occurence of characters 'std' in the given string 1. list item 1. list item 1. list item 2. list item 2. list item 2. list item",
    "canonical_solution": "def count_occurance(s):\r\n  count=0\r\n  for i in range(len(s)):\r\n    if (s[i]== 's' and s[i+1]=='t' and s[i+2]== 'd'):\r\n      count = count + 1\r\n  return count",
    "test": "['assert count_occurance(\"letstdlenstdporstd\") == 3', 'assert count_occurance(\"truststdsolensporsd\") == 1', 'assert count_occurance(\"makestdsostdworthit\") == 2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/173",
    "prompt": "Write a function to remove everything except alphanumeric characters from a string.",
    "canonical_solution": "import re\r\ndef remove_splchar(text): \r\n pattern = re.compile('[\\W_]+')\r\n return (pattern.sub('', text))",
    "test": "[\"assert remove_splchar('python  @#&^%$*program123')==('pythonprogram123')\", \"assert remove_splchar('python %^$@!^&*()  programming24%$^^()    language')==('pythonprogramming24language')\", \"assert remove_splchar('python   ^%&^()(+_)(_^&67)                  program')==('python67program')\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/174",
    "prompt": "Write a function to group a sequence of key-value pairs into a dictionary of lists.",
    "canonical_solution": "def group_keyvalue(l):\r\n    result = {}\r\n    for k, v in l:\r\n         result.setdefault(k, []).append(v)\r\n    return result",
    "test": "[\"assert group_keyvalue([('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)])=={'yellow': [1, 3], 'blue': [2, 4], 'red': [1]}\", \"assert group_keyvalue([('python', 1), ('python', 2), ('python', 3), ('python', 4), ('python', 5)])=={'python': [1,2,3,4,5]}\", \"assert group_keyvalue([('yellow',100), ('blue', 200), ('yellow', 300), ('blue', 400), ('red', 100)])=={'yellow': [100, 300], 'blue': [200, 400], 'red': [100]}\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/175",
    "prompt": "Write a function to verify validity of a string of parentheses.",
    "canonical_solution": "def is_valid_parenthese( str1):\r\n        stack, pchar = [], {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\r\n        for parenthese in str1:\r\n            if parenthese in pchar:\r\n                stack.append(parenthese)\r\n            elif len(stack) == 0 or pchar[stack.pop()] != parenthese:\r\n                return False\r\n        return len(stack) == 0",
    "test": "['assert is_valid_parenthese(\"(){}[]\")==True', 'assert is_valid_parenthese(\"()[{)}\")==False', 'assert is_valid_parenthese(\"()\")==True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/176",
    "prompt": "Write a function to find the perimeter of a triangle.",
    "canonical_solution": "def perimeter_triangle(a,b,c):\r\n  perimeter=a+b+c\r\n  return perimeter",
    "test": "['assert perimeter_triangle(10,20,30)==60', 'assert perimeter_triangle(3,4,5)==12', 'assert perimeter_triangle(25,35,45)==105']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/177",
    "prompt": "Write a python function to find two distinct numbers such that their lcm lies within the given range.",
    "canonical_solution": "def answer(L,R): \r\n    if (2 * L <= R): \r\n        return (L ,2*L)\r\n    else: \r\n        return (-1) ",
    "test": "['assert answer(3,8) == (3,6)', 'assert answer(2,6) == (2,4)', 'assert answer(1,3) == (1,2)']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/178",
    "prompt": "Write a function to search some literals strings in a string.",
    "canonical_solution": "import re\r\ndef string_literals(patterns,text):\r\n  for pattern in patterns:\r\n     if re.search(pattern,  text):\r\n       return ('Matched!')\r\n     else:\r\n       return ('Not Matched!')",
    "test": "[\"assert string_literals(['language'],'python language')==('Matched!')\", \"assert string_literals(['program'],'python language')==('Not Matched!')\", \"assert string_literals(['python'],'programming language')==('Not Matched!')\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/179",
    "prompt": "Write a function to find if the given number is a keith number or not.",
    "canonical_solution": "def is_num_keith(x): \r\n\tterms = [] \r\n\ttemp = x \r\n\tn = 0 \r\n\twhile (temp > 0): \r\n\t\tterms.append(temp % 10) \r\n\t\ttemp = int(temp / 10) \r\n\t\tn+=1 \r\n\tterms.reverse() \r\n\tnext_term = 0 \r\n\ti = n \r\n\twhile (next_term < x): \r\n\t\tnext_term = 0 \r\n\t\tfor j in range(1,n+1): \r\n\t\t\tnext_term += terms[i - j] \r\n\t\tterms.append(next_term) \r\n\t\ti+=1 \r\n\treturn (next_term == x) ",
    "test": "['assert is_num_keith(14) == True', 'assert is_num_keith(12) == False', 'assert is_num_keith(197) == True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/18",
    "prompt": "Write a function to remove characters from the first string which are present in the second string.",
    "canonical_solution": "NO_OF_CHARS = 256\r\ndef str_to_list(string): \r\n\ttemp = [] \r\n\tfor x in string: \r\n\t\ttemp.append(x) \r\n\treturn temp \r\ndef lst_to_string(List): \r\n\treturn ''.join(List) \r\ndef get_char_count_array(string): \r\n\tcount = [0] * NO_OF_CHARS \r\n\tfor i in string: \r\n\t\tcount[ord(i)] += 1\r\n\treturn count \r\ndef remove_dirty_chars(string, second_string): \r\n\tcount = get_char_count_array(second_string) \r\n\tip_ind = 0\r\n\tres_ind = 0\r\n\ttemp = '' \r\n\tstr_list = str_to_list(string) \r\n\twhile ip_ind != len(str_list): \r\n\t\ttemp = str_list[ip_ind] \r\n\t\tif count[ord(temp)] == 0: \r\n\t\t\tstr_list[res_ind] = str_list[ip_ind] \r\n\t\t\tres_ind += 1\r\n\t\tip_ind+=1\r\n\treturn lst_to_string(str_list[0:res_ind]) ",
    "test": "['assert remove_dirty_chars(\"probasscurve\", \"pros\") == \\'bacuve\\'', 'assert remove_dirty_chars(\"digitalindia\", \"talent\") == \\'digiidi\\'', 'assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == \\'emles\\' ']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/180",
    "prompt": "Write a function to calculate distance between two points using latitude and longitude.",
    "canonical_solution": "from math import radians, sin, cos, acos\r\ndef distance_lat_long(slat,slon,elat,elon):\r\n dist = 6371.01 * acos(sin(slat)*sin(elat) + cos(slat)*cos(elat)*cos(slon - elon))\r\n return dist",
    "test": "['assert distance_lat_long(23.5,67.5,25.5,69.5)==12179.372041317429', 'assert distance_lat_long(10.5,20.5,30.5,40.5)==6069.397933300514', 'assert distance_lat_long(10,20,30,40)==6783.751974994595']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/181",
    "prompt": "Write a function to find the longest common prefix in the given set of strings.",
    "canonical_solution": "def common_prefix_util(str1, str2): \r\n\tresult = \"\"; \r\n\tn1 = len(str1) \r\n\tn2 = len(str2) \r\n\ti = 0\r\n\tj = 0\r\n\twhile i <= n1 - 1 and j <= n2 - 1: \r\n\t\tif (str1[i] != str2[j]): \r\n\t\t\tbreak\r\n\t\tresult += str1[i] \r\n\t\ti += 1\r\n\t\tj += 1\r\n\treturn (result) \r\ndef common_prefix (arr, n): \r\n\tprefix = arr[0] \r\n\tfor i in range (1, n): \r\n\t\tprefix = common_prefix_util(prefix, arr[i]) \r\n\treturn (prefix) ",
    "test": "['assert common_prefix([\"tablets\", \"tables\", \"taxi\", \"tamarind\"], 4) == \\'ta\\'', 'assert common_prefix([\"apples\", \"ape\", \"april\"], 3) == \\'ap\\'', 'assert common_prefix([\"teens\", \"teenager\", \"teenmar\"], 3) == \\'teen\\'']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/182",
    "prompt": "Write a function to find uppercase, lowercase, special character and numeric values using regex.",
    "canonical_solution": "import re\r\ndef find_character(string):\r\n  uppercase_characters = re.findall(r\"[A-Z]\", string) \r\n  lowercase_characters = re.findall(r\"[a-z]\", string) \r\n  numerical_characters = re.findall(r\"[0-9]\", string) \r\n  special_characters = re.findall(r\"[, .!?]\", string) \r\n  return uppercase_characters, lowercase_characters, numerical_characters, special_characters",
    "test": "['assert find_character(\"ThisIsGeeksforGeeks\") == ([\\'T\\', \\'I\\', \\'G\\', \\'G\\'], [\\'h\\', \\'i\\', \\'s\\', \\'s\\', \\'e\\', \\'e\\', \\'k\\', \\'s\\', \\'f\\', \\'o\\', \\'r\\', \\'e\\', \\'e\\', \\'k\\', \\'s\\'], [], [])', 'assert find_character(\"Hithere2\") == ([\\'H\\'], [\\'i\\', \\'t\\', \\'h\\', \\'e\\', \\'r\\', \\'e\\'], [\\'2\\'], [])', 'assert find_character(\"HeyFolks32\") == ([\\'H\\', \\'F\\'], [\\'e\\', \\'y\\', \\'o\\', \\'l\\', \\'k\\', \\'s\\'], [\\'3\\', \\'2\\'], [])']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/183",
    "prompt": "Write a function to count all the distinct pairs having a difference of k in any array.",
    "canonical_solution": "def count_pairs(arr, n, k):\r\n  count=0;\r\n  for i in range(0,n):\r\n    for j in range(i+1, n):\r\n      if arr[i] - arr[j] == k or arr[j] - arr[i] == k:\r\n        count += 1\r\n  return count",
    "test": "['assert count_pairs([1, 5, 3, 4, 2], 5, 3) == 2', 'assert count_pairs([8, 12, 16, 4, 0, 20], 6, 4) == 5', 'assert count_pairs([2, 4, 1, 3, 4], 5, 2) == 3']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/184",
    "prompt": "Write a function to find all the values in a list that are greater than a specified number.",
    "canonical_solution": "def greater_specificnum(list,num):\r\n greater_specificnum=all(x >= num for x in list)\r\n return greater_specificnum",
    "test": "['assert greater_specificnum([220, 330, 500],200)==True', 'assert greater_specificnum([12, 17, 21],20)==False', 'assert greater_specificnum([1,2,3,4],10)==False']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/185",
    "prompt": "Write a function to find the focus of a parabola.",
    "canonical_solution": "def parabola_focus(a, b, c): \r\n  focus= (((-b / (2 * a)),(((4 * a * c) - (b * b) + 1) / (4 * a))))\r\n  return focus",
    "test": "['assert parabola_focus(5,3,2)==(-0.3, 1.6)', 'assert parabola_focus(9,8,4)==(-0.4444444444444444, 2.25)', 'assert parabola_focus(2,4,6)==(-1.0, 4.125)']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/186",
    "prompt": "Write a function to search some literals strings in a string by using regex.",
    "canonical_solution": "import re\r\ndef check_literals(text, patterns):\r\n  for pattern in patterns:\r\n    if re.search(pattern,  text):\r\n        return ('Matched!')\r\n    else:\r\n        return ('Not Matched!')",
    "test": "[\"assert check_literals('The quick brown fox jumps over the lazy dog.',['fox']) == 'Matched!'\", \"assert check_literals('The quick brown fox jumps over the lazy dog.',['horse']) == 'Not Matched!'\", \"assert check_literals('The quick brown fox jumps over the lazy dog.',['lazy']) == 'Matched!'\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/187",
    "prompt": "Write a function to find the longest common subsequence for the given two sequences.",
    "canonical_solution": "def longest_common_subsequence(X, Y, m, n): \r\n    if m == 0 or n == 0: \r\n       return 0 \r\n    elif X[m-1] == Y[n-1]: \r\n       return 1 + longest_common_subsequence(X, Y, m-1, n-1) \r\n    else: \r\n       return max(longest_common_subsequence(X, Y, m, n-1), longest_common_subsequence(X, Y, m-1, n))",
    "test": "['assert longest_common_subsequence(\"AGGTAB\" , \"GXTXAYB\", 6, 7) == 4', 'assert longest_common_subsequence(\"ABCDGH\" , \"AEDFHR\", 6, 6) == 3', 'assert longest_common_subsequence(\"AXYT\" , \"AYZX\", 4, 4) == 2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/188",
    "prompt": "Write a python function to check whether the given number can be represented by product of two squares or not.",
    "canonical_solution": "def prod_Square(n):\r\n    for i in range(2,(n) + 1):\r\n        if (i*i < (n+1)):\r\n            for j in range(2,n + 1):\r\n                if ((i*i*j*j) == n):\r\n                    return True;\r\n    return False;",
    "test": "['assert prod_Square(25) == False', 'assert prod_Square(30) == False', 'assert prod_Square(16) == True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/189",
    "prompt": "Write a python function to find the first missing positive number.",
    "canonical_solution": "def first_Missing_Positive(arr,n): \r\n    ptr = 0\r\n    for i in range(n):\r\n        if arr[i] == 1:\r\n            ptr = 1\r\n            break\r\n    if ptr == 0:\r\n        return(1)\r\n    for i in range(n):\r\n        if arr[i] <= 0 or arr[i] > n:\r\n            arr[i] = 1\r\n    for i in range(n):\r\n        arr[(arr[i] - 1) % n] += n\r\n    for i in range(n):\r\n        if arr[i] <= n:\r\n            return(i + 1)\r\n    return(n + 1)",
    "test": "['assert first_Missing_Positive([1,2,3,-1,5],5) == 4', 'assert first_Missing_Positive([0,-1,-2,1,5,8],6) == 2', 'assert first_Missing_Positive([0,1,2,5,-8],5) == 3']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/19",
    "prompt": "Write a function to find whether a given array of integers contains any duplicate element.",
    "canonical_solution": "def test_duplicate(arraynums):\r\n    nums_set = set(arraynums)    \r\n    return len(arraynums) != len(nums_set)     ",
    "test": "['assert test_duplicate(([1,2,3,4,5]))==False', 'assert test_duplicate(([1,2,3,4, 4]))==True', 'assert test_duplicate([1,1,2,2,3,3,4,4,5])==True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/190",
    "prompt": "Write a python function to count the number of integral co-ordinates that lie inside a square.",
    "canonical_solution": "def count_Intgral_Points(x1,y1,x2,y2): \r\n    return ((y2 - y1 - 1) * (x2 - x1 - 1)) ",
    "test": "['assert count_Intgral_Points(1,1,4,4) == 4', 'assert count_Intgral_Points(1,2,1,2) == 1', 'assert count_Intgral_Points(4,2,6,4) == 1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/191",
    "prompt": "Write a function to check whether the given month name contains 30 days or not.",
    "canonical_solution": "def check_monthnumber(monthname3):\r\n  if monthname3 ==\"April\" or monthname3== \"June\" or monthname3== \"September\" or monthname3== \"November\":\r\n    return True\r\n  else:\r\n    return False",
    "test": "['assert check_monthnumber(\"February\")==False', 'assert check_monthnumber(\"June\")==True', 'assert check_monthnumber(\"April\")==True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/192",
    "prompt": "Write a python function to check whether a string has atleast one letter and one number.",
    "canonical_solution": "def check_String(str): \r\n    flag_l = False\r\n    flag_n = False\r\n    for i in str: \r\n        if i.isalpha(): \r\n            flag_l = True  \r\n        if i.isdigit(): \r\n            flag_n = True\r\n    return flag_l and flag_n ",
    "test": "[\"assert check_String('thishasboth29') == True\", \"assert check_String('python') == False\", \"assert check_String ('string') == False\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/193",
    "prompt": "Write a function to remove the duplicates from the given tuple.",
    "canonical_solution": "def remove_tuple(test_tup):\r\n  res = tuple(set(test_tup))\r\n  return (res) ",
    "test": "['assert remove_tuple((1, 3, 5, 2, 3, 5, 1, 1, 3)) == (1, 2, 3, 5)', 'assert remove_tuple((2, 3, 4, 4, 5, 6, 6, 7, 8, 8)) == (2, 3, 4, 5, 6, 7, 8)', 'assert remove_tuple((11, 12, 13, 11, 11, 12, 14, 13)) == (11, 12, 13, 14)']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/194",
    "prompt": "Write a python function to convert octal number to decimal number.",
    "canonical_solution": "def octal_To_Decimal(n):  \r\n    num = n; \r\n    dec_value = 0; \r\n    base = 1; \r\n    temp = num; \r\n    while (temp): \r\n        last_digit = temp % 10; \r\n        temp = int(temp / 10); \r\n        dec_value += last_digit*base; \r\n        base = base * 8; \r\n    return dec_value; ",
    "test": "['assert octal_To_Decimal(25) == 21', 'assert octal_To_Decimal(30) == 24', 'assert octal_To_Decimal(40) == 32']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/195",
    "prompt": "Write a python function to find the first position of an element in a sorted array.",
    "canonical_solution": "def first(arr,x,n): \r\n    low = 0\r\n    high = n - 1\r\n    res = -1  \r\n    while (low <= high):\r\n        mid = (low + high) // 2 \r\n        if arr[mid] > x:\r\n            high = mid - 1\r\n        elif arr[mid] < x:\r\n            low = mid + 1\r\n        else:\r\n            res = mid\r\n            high = mid - 1\r\n    return res",
    "test": "['assert first([1,2,3,4,5,6,6],6,6) == 5', 'assert first([1,2,2,2,3,2,2,4,2],2,9) == 1', 'assert first([1,2,3],1,3) == 0']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/196",
    "prompt": "Write a function to remove all the tuples with length k.",
    "canonical_solution": "def remove_tuples(test_list, K):\r\n  res = [ele for ele in test_list if len(ele) != K]\r\n  return (res) ",
    "test": "['assert remove_tuples([(4, 5), (4, ), (8, 6, 7), (1, ), (3, 4, 6, 7)] , 1) == [(4, 5), (8, 6, 7), (3, 4, 6, 7)]', 'assert remove_tuples([(4, 5), (4,5), (6, 7), (1, 2, 3), (3, 4, 6, 7)] ,2) == [(1, 2, 3), (3, 4, 6, 7)]', 'assert remove_tuples([(1, 4, 4), (4, 3), (8, 6, 7), (1, ), (3, 6, 7)] , 3) == [(4, 3), (1,)]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/197",
    "prompt": "Write a function to perform the exponentiation of the given two tuples.",
    "canonical_solution": "def find_exponentio(test_tup1, test_tup2):\r\n  res = tuple(ele1 ** ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res)\r\n",
    "test": "['assert find_exponentio((10, 4, 5, 6), (5, 6, 7, 5)) == (100000, 4096, 78125, 7776)', 'assert find_exponentio((11, 5, 6, 7), (6, 7, 8, 6)) == (1771561, 78125, 1679616, 117649)', 'assert find_exponentio((12, 6, 7, 8), (7, 8, 9, 7)) == (35831808, 1679616, 40353607, 2097152)']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/198",
    "prompt": "Write a function to find the largest triangle that can be inscribed in an ellipse.",
    "canonical_solution": "import math\r\ndef largest_triangle(a,b): \r\n    if (a < 0 or b < 0): \r\n        return -1 \r\n    area = (3 * math.sqrt(3) * pow(a, 2)) / (4 * b);  \r\n    return area ",
    "test": "['assert largest_triangle(4,2)==10.392304845413264', 'assert largest_triangle(5,7)==4.639421805988064', 'assert largest_triangle(9,1)==105.2220865598093']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/199",
    "prompt": "Write a python function to find highest power of 2 less than or equal to given number.",
    "canonical_solution": "def highest_Power_of_2(n): \r\n    res = 0; \r\n    for i in range(n, 0, -1):  \r\n        if ((i & (i - 1)) == 0): \r\n            res = i; \r\n            break;      \r\n    return res; ",
    "test": "['assert highest_Power_of_2(10) == 8', 'assert highest_Power_of_2(19) == 16', 'assert highest_Power_of_2(32) == 32']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/20",
    "prompt": "Write a function to check if the given number is woodball or not.",
    "canonical_solution": "def is_woodall(x): \r\n\tif (x % 2 == 0): \r\n\t\treturn False\r\n\tif (x == 1): \r\n\t\treturn True\r\n\tx = x + 1 \r\n\tp = 0\r\n\twhile (x % 2 == 0): \r\n\t\tx = x/2\r\n\t\tp = p + 1\r\n\t\tif (p == x): \r\n\t\t\treturn True\r\n\treturn False",
    "test": "['assert is_woodall(383) == True', 'assert is_woodall(254) == False', 'assert is_woodall(200) == False']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/200",
    "prompt": "Write a function to find all index positions of the maximum values in a given list.",
    "canonical_solution": "def position_max(list1):\r\n    max_val = max(list1)\r\n    max_result = [i for i, j in enumerate(list1) if j == max_val]\r\n    return max_result",
    "test": "['assert position_max([12,33,23,10,67,89,45,667,23,12,11,10,54])==[7]', 'assert position_max([1,2,2,2,4,4,4,5,5,5,5])==[7,8,9,10]', 'assert position_max([2,1,5,6,8,3,4,9,10,11,8,12])==[11]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/201",
    "prompt": "Write a python function to check whether the elements in a list are same or not.",
    "canonical_solution": "def chkList(lst): \r\n    return len(set(lst)) == 1",
    "test": "[\"assert chkList(['one','one','one']) == True\", \"assert chkList(['one','Two','Three']) == False\", \"assert chkList(['bigdata','python','Django']) == False\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/202",
    "prompt": "Write a function to remove even characters in a string.",
    "canonical_solution": "def remove_even(str1):\r\n str2 = ''\r\n for i in range(1, len(str1) + 1):\r\n    if(i % 2 != 0):\r\n        str2 = str2 + str1[i - 1]\r\n return str2",
    "test": "['assert remove_even(\"python\")==(\"pto\")', 'assert remove_even(\"program\")==(\"porm\")', 'assert remove_even(\"language\")==(\"lnug\")']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/203",
    "prompt": "Write a python function to find the hamming distance between given two integers.",
    "canonical_solution": "def hamming_Distance(n1,n2) : \r\n    x = n1 ^ n2  \r\n    setBits = 0\r\n    while (x > 0) : \r\n        setBits += x & 1\r\n        x >>= 1\r\n    return setBits  ",
    "test": "['assert hamming_Distance(4,8) == 2', 'assert hamming_Distance(2,4) == 2', 'assert hamming_Distance(1,2) == 2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/204",
    "prompt": "Write a python function to count the occurrence of a given character in a string.",
    "canonical_solution": "def count(s,c) : \r\n    res = 0 \r\n    for i in range(len(s)) : \r\n        if (s[i] == c): \r\n            res = res + 1\r\n    return res ",
    "test": "['assert count(\"abcc\",\"c\") == 2', 'assert count(\"ababca\",\"a\") == 3', 'assert count(\"mnmm0pm\",\"m\") == 4']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/205",
    "prompt": "Write a function to find the inversions of tuple elements in the given tuple list.",
    "canonical_solution": "def inversion_elements(test_tup):\r\n  res = tuple(list(map(lambda x: ~x, list(test_tup))))\r\n  return (res) ",
    "test": "['assert inversion_elements((7, 8, 9, 1, 10, 7)) == (-8, -9, -10, -2, -11, -8)', 'assert inversion_elements((2, 4, 5, 6, 1, 7)) == (-3, -5, -6, -7, -2, -8)', 'assert inversion_elements((8, 9, 11, 14, 12, 13)) == (-9, -10, -12, -15, -13, -14)']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/206",
    "prompt": "Write a function to perform the adjacent element concatenation in the given tuples.",
    "canonical_solution": "def concatenate_elements(test_tup):\r\n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\r\n  return (res) ",
    "test": "['assert concatenate_elements((\"DSP \", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"UTS\")) == (\\'DSP IS \\', \\'IS BEST \\', \\'BEST FOR \\', \\'FOR ALL \\', \\'ALL UTS\\')', 'assert concatenate_elements((\"RES \", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"QESR\")) == (\\'RES IS \\', \\'IS BEST \\', \\'BEST FOR \\', \\'FOR ALL \\', \\'ALL QESR\\')', 'assert concatenate_elements((\"MSAM\", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"SKD\")) == (\\'MSAMIS \\', \\'IS BEST \\', \\'BEST FOR \\', \\'FOR ALL \\', \\'ALL SKD\\')']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/207",
    "prompt": "Write a function to count the longest repeating subsequences such that the two subsequences don\u2019t have same string characters at same positions.",
    "canonical_solution": "def find_longest_repeating_subseq(str): \r\n\tn = len(str) \r\n\tdp = [[0 for k in range(n+1)] for l in range(n+1)] \r\n\tfor i in range(1, n+1): \r\n\t\tfor j in range(1, n+1): \r\n\t\t\tif (str[i-1] == str[j-1] and i != j): \r\n\t\t\t\tdp[i][j] = 1 + dp[i-1][j-1] \r\n\t\t\telse: \r\n\t\t\t\tdp[i][j] = max(dp[i][j-1], dp[i-1][j]) \r\n\treturn dp[n][n]",
    "test": "['assert find_longest_repeating_subseq(\"AABEBCDD\") == 3', 'assert find_longest_repeating_subseq(\"aabb\") == 2', 'assert find_longest_repeating_subseq(\"aab\") == 1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/208",
    "prompt": "Write a function to check the given decimal with a precision of 2 by using regex.",
    "canonical_solution": "import re\r\ndef is_decimal(num):\r\n  num_fetch = re.compile(r\"\"\"^[0-9]+(\\.[0-9]{1,2})?$\"\"\")\r\n  result = num_fetch.search(num)\r\n  return bool(result)",
    "test": "[\"assert is_decimal('123.11') == True\", \"assert is_decimal('0.21') == True\", \"assert is_decimal('123.1214') == False\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/209",
    "prompt": "Write a function to delete the smallest element from the given heap and then insert a new item.",
    "canonical_solution": "import heapq as hq\r\ndef heap_replace(heap,a):\r\n  hq.heapify(heap)\r\n  hq.heapreplace(heap, a)\r\n  return heap",
    "test": "['assert heap_replace( [25, 44, 68, 21, 39, 23, 89],21)==[21, 25, 23, 44, 39, 68, 89]', 'assert heap_replace([25, 44, 68, 21, 39, 23, 89],110)== [23, 25, 68, 44, 39, 110, 89]', 'assert heap_replace([25, 44, 68, 21, 39, 23, 89],500)==[23, 25, 68, 44, 39, 500, 89]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/21",
    "prompt": "Write a function to find m number of multiples of n.",
    "canonical_solution": "def multiples_of_num(m,n): \r\n    multiples_of_num= list(range(n,(m+1)*n, n)) \r\n    return list(multiples_of_num)",
    "test": "['assert multiples_of_num(4,3)== [3,6,9,12]', 'assert multiples_of_num(2,5)== [5,10]', 'assert multiples_of_num(9,2)== [2,4,6,8,10,12,14,16,18]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/210",
    "prompt": "Write a function to check that the given string contains only a certain set of characters(in this case a-z, a-z and 0-9) by using regex.",
    "canonical_solution": "import re\r\ndef is_allowed_specific_char(string):\r\n    get_char = re.compile(r'[^a-zA-Z0-9.]')\r\n    string = get_char.search(string)\r\n    return not bool(string)",
    "test": "['assert is_allowed_specific_char(\"ABCDEFabcdef123450\") == True', 'assert is_allowed_specific_char(\"*&%@#!}{\") == False', 'assert is_allowed_specific_char(\"HELLOhowareyou98765\") == True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/211",
    "prompt": "Write a python function to count numbers whose oth and nth bits are set.",
    "canonical_solution": "def count_Num(n): \r\n    if (n == 1): \r\n        return 1\r\n    count = pow(2,n - 2) \r\n    return count ",
    "test": "['assert count_Num(2) == 1', 'assert count_Num(3) == 2', 'assert count_Num(1) == 1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/212",
    "prompt": "Write a python function to find the sum of fourth power of n natural numbers.",
    "canonical_solution": "import math  \r\ndef fourth_Power_Sum(n): \r\n    sum = 0\r\n    for i in range(1,n+1) : \r\n        sum = sum + (i*i*i*i) \r\n    return sum",
    "test": "['assert fourth_Power_Sum(2) == 17', 'assert fourth_Power_Sum(4) == 354', 'assert fourth_Power_Sum(6) == 2275']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/213",
    "prompt": "Write a function to perform the concatenation of two string tuples.",
    "canonical_solution": "def concatenate_strings(test_tup1, test_tup2):\r\n  res = tuple(ele1 + ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res) ",
    "test": "['assert concatenate_strings((\"Manjeet\", \"Nikhil\", \"Akshat\"), (\" Singh\", \" Meherwal\", \" Garg\")) == (\\'Manjeet Singh\\', \\'Nikhil Meherwal\\', \\'Akshat Garg\\')', 'assert concatenate_strings((\"Shaik\", \"Ayesha\", \"Sanya\"), (\" Dawood\", \" Begum\", \" Singh\")) == (\\'Shaik Dawood\\', \\'Ayesha Begum\\', \\'Sanya Singh\\')', 'assert concatenate_strings((\"Harpreet\", \"Priyanka\", \"Muskan\"), (\"Kour\", \" Agarwal\", \"Sethi\")) == (\\'HarpreetKour\\', \\'Priyanka Agarwal\\', \\'MuskanSethi\\')']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/214",
    "prompt": "Write a function to convert radians to degrees.",
    "canonical_solution": "import math\r\ndef degree_radian(radian):\r\n degree = radian*(180/math.pi)\r\n return degree",
    "test": "['assert degree_radian(90)==5156.620156177409', 'assert degree_radian(60)==3437.746770784939', 'assert degree_radian(120)==6875.493541569878']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/215",
    "prompt": "Write a function to decode a run-length encoded given list.",
    "canonical_solution": "def decode_list(alist):\r\n    def aux(g):\r\n        if isinstance(g, list):\r\n            return [(g[1], range(g[0]))]\r\n        else:\r\n            return [(g, [0])]\r\n    return [x for g in alist for x, R in aux(g) for i in R]",
    "test": "['assert decode_list([[2, 1], 2, 3, [2, 4], 5,1])==[1,1,2,3,4,4,5,1]', \"assert decode_list(['a', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', 'a', [2, 'l'], 'y'])==['a', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', 'a', 'l', 'l', 'y']\", \"assert decode_list(['p', 'y', 't', 'h', 'o', 'n'])==['p', 'y', 't', 'h', 'o', 'n']\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/216",
    "prompt": "Write a function to check if a nested list is a subset of another nested list.",
    "canonical_solution": "def check_subset_list(list1, list2): \r\n    l1, l2 = list1[0], list2[0] \r\n    exist = True\r\n    for i in list2: \r\n        if i not in list1: \r\n            exist = False\r\n    return exist ",
    "test": "['assert check_subset_list([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],[[12, 18, 23, 25, 45], [7, 11, 19, 24, 28], [1, 5, 8, 18, 15, 16]])==False', 'assert check_subset_list([[2, 3, 1], [4, 5], [6, 8]],[[4, 5], [6, 8]])==True', \"assert check_subset_list([['a', 'b'], ['e'], ['c', 'd']],[['g']])==False\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/217",
    "prompt": "Write a python function to find the first repeated character in a given string.",
    "canonical_solution": "def first_Repeated_Char(str): \r\n    h = {}\r\n    for ch in str:\r\n        if ch in h: \r\n            return ch;\r\n        else: \r\n            h[ch] = 0\r\n    return '\\0'",
    "test": "['assert first_Repeated_Char(\"Google\") == \"o\"', 'assert first_Repeated_Char(\"data\") == \"a\"', 'assert first_Repeated_Char(\"python\") == \\'\\\\0\\'']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/218",
    "prompt": "Write a python function to find the minimum operations required to make two numbers equal.",
    "canonical_solution": "import math   \r\ndef min_Operations(A,B):  \r\n    if (A > B): \r\n        swap(A,B)  \r\n    B = B // math.gcd(A,B);  \r\n    return B - 1",
    "test": "['assert min_Operations(2,4) == 1', 'assert min_Operations(4,10) == 4', 'assert min_Operations(1,4) == 3']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/219",
    "prompt": "Write a function to extract maximum and minimum k elements in the given tuple.",
    "canonical_solution": "\r\ndef extract_min_max(test_tup, K):\r\n  res = []\r\n  test_tup = list(test_tup)\r\n  temp = sorted(test_tup)\r\n  for idx, val in enumerate(temp):\r\n    if idx < K or idx >= len(temp) - K:\r\n      res.append(val)\r\n  res = tuple(res)\r\n  return (res) ",
    "test": "['assert extract_min_max((5, 20, 3, 7, 6, 8), 2) == (3, 5, 8, 20)', 'assert extract_min_max((4, 5, 6, 1, 2, 7), 3) == (1, 2, 4, 5, 6, 7)', 'assert extract_min_max((2, 3, 4, 8, 9, 11, 7), 4) == (2, 3, 4, 7, 8, 9, 11)']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/22",
    "prompt": "Write a function to find the first duplicate element in a given array of integers.",
    "canonical_solution": "def find_first_duplicate(nums):\r\n    num_set = set()\r\n    no_duplicate = -1\r\n\r\n    for i in range(len(nums)):\r\n\r\n        if nums[i] in num_set:\r\n            return nums[i]\r\n        else:\r\n            num_set.add(nums[i])\r\n\r\n    return no_duplicate",
    "test": "['assert find_first_duplicate(([1, 2, 3, 4, 4, 5]))==4', 'assert find_first_duplicate([1, 2, 3, 4])==-1', 'assert find_first_duplicate([1, 1, 2, 3, 3, 2, 2])==1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/220",
    "prompt": "Write a function to replace maximum n occurrences of spaces, commas, or dots with a colon.",
    "canonical_solution": "import re\r\ndef replace_max_specialchar(text,n):\r\n return (re.sub(\"[ ,.]\", \":\", text, n))",
    "test": "[\"assert replace_max_specialchar('Python language, Programming language.',2)==('Python:language: Programming language.')\", \"assert replace_max_specialchar('a b c,d e f',3)==('a:b:c:d e f')\", \"assert replace_max_specialchar('ram reshma,ram rahim',1)==('ram:reshma,ram rahim')\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/221",
    "prompt": "Write a python function to find the first even number in a given list of numbers.",
    "canonical_solution": "def first_even(nums):\r\n    first_even = next((el for el in nums if el%2==0),-1)\r\n    return first_even",
    "test": "['assert first_even ([1, 3, 5, 7, 4, 1, 6, 8]) == 4', 'assert first_even([2, 3, 4]) == 2', 'assert first_even([5, 6, 7]) == 6']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/222",
    "prompt": "Write a function to check if all the elements in tuple have same data type or not.",
    "canonical_solution": "def check_type(test_tuple):\r\n  res = True\r\n  for ele in test_tuple:\r\n    if not isinstance(ele, type(test_tuple[0])):\r\n      res = False\r\n      break\r\n  return (res) ",
    "test": "['assert check_type((5, 6, 7, 3, 5, 6) ) == True', 'assert check_type((1, 2, \"4\") ) == False', 'assert check_type((3, 2, 1, 4, 5) ) == True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/223",
    "prompt": "Write a function to check for majority element in the given sorted array.",
    "canonical_solution": "def is_majority(arr, n, x):\r\n\ti = binary_search(arr, 0, n-1, x)\r\n\tif i == -1:\r\n\t\treturn False\r\n\tif ((i + n//2) <= (n -1)) and arr[i + n//2] == x:\r\n\t\treturn True\r\n\telse:\r\n\t\treturn False\r\ndef binary_search(arr, low, high, x):\r\n\tif high >= low:\r\n\t\tmid = (low + high)//2 \r\n\t\tif (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):\r\n\t\t\treturn mid\r\n\t\telif x > arr[mid]:\r\n\t\t\treturn binary_search(arr, (mid + 1), high, x)\r\n\t\telse:\r\n\t\t\treturn binary_search(arr, low, (mid -1), x)\r\n\treturn -1",
    "test": "['assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True', 'assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False', 'assert is_majority([1, 1, 1, 2, 2], 5, 1) == True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/224",
    "prompt": "Write a python function to count set bits of a given number.",
    "canonical_solution": "def count_Set_Bits(n): \r\n    count = 0\r\n    while (n): \r\n        count += n & 1\r\n        n >>= 1\r\n    return count ",
    "test": "['assert count_Set_Bits(2) == 1', 'assert count_Set_Bits(4) == 1', 'assert count_Set_Bits(6) == 2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/225",
    "prompt": "Write a python function to find the minimum element in a sorted and rotated array.",
    "canonical_solution": "def find_Min(arr,low,high): \r\n    while (low < high): \r\n        mid = low + (high - low) // 2;   \r\n        if (arr[mid] == arr[high]): \r\n            high -= 1; \r\n        elif (arr[mid] > arr[high]): \r\n            low = mid + 1; \r\n        else: \r\n            high = mid; \r\n    return arr[high]; ",
    "test": "['assert find_Min([1,2,3,4,5],0,4) == 1', 'assert find_Min([4,6,8],0,2) == 4', 'assert find_Min([2,3,5,7,9],0,4) == 2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/226",
    "prompt": "Write a python function to remove the characters which have odd index values of a given string.",
    "canonical_solution": "def odd_values_string(str):\r\n  result = \"\" \r\n  for i in range(len(str)):\r\n    if i % 2 == 0:\r\n      result = result + str[i]\r\n  return result",
    "test": "[\"assert odd_values_string('abcdef') == 'ace'\", \"assert odd_values_string('python') == 'pto'\", \"assert odd_values_string('data') == 'dt'\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/227",
    "prompt": "Write a function to find minimum of three numbers.",
    "canonical_solution": "def min_of_three(a,b,c): \r\n      if (a <= b) and (a <= c): \r\n        smallest = a \r\n      elif (b <= a) and (b <= c): \r\n        smallest = b \r\n      else: \r\n        smallest = c \r\n      return smallest ",
    "test": "['assert min_of_three(10,20,0)==0', 'assert min_of_three(19,15,18)==15', 'assert min_of_three(-10,-20,-30)==-30']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/228",
    "prompt": "Write a python function to check whether all the bits are unset in the given range or not.",
    "canonical_solution": "def all_Bits_Set_In_The_Given_Range(n,l,r):  \r\n    num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1)) \r\n    new_num = n & num\r\n    if (new_num == 0): \r\n        return True\r\n    return False",
    "test": "['assert all_Bits_Set_In_The_Given_Range(4,1,2) == True', 'assert all_Bits_Set_In_The_Given_Range(17,2,4) == True', 'assert all_Bits_Set_In_The_Given_Range(39,4,6) == False']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/229",
    "prompt": "Write a function to re-arrange the elements of the given array so that all negative elements appear before positive ones.",
    "canonical_solution": "def re_arrange_array(arr, n):\r\n  j=0\r\n  for i in range(0, n):\r\n    if (arr[i] < 0):\r\n      temp = arr[i]\r\n      arr[i] = arr[j]\r\n      arr[j] = temp\r\n      j = j + 1\r\n  return arr",
    "test": "['assert re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]', 'assert re_arrange_array([12, -14, -26, 13, 15], 5) == [-14, -26, 12, 13, 15]', 'assert re_arrange_array([10, 24, 36, -42, -39, -78, 85], 7) == [-42, -39, -78, 10, 24, 36, 85]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/23",
    "prompt": "Write a python function to find the maximum sum of elements of list in a list of lists.",
    "canonical_solution": "def maximum_Sum(list1): \r\n    maxi = -100000\r\n    for x in list1: \r\n        sum = 0 \r\n        for y in x: \r\n            sum+= y      \r\n        maxi = max(sum,maxi)     \r\n    return maxi ",
    "test": "['assert maximum_Sum([[1,2,3],[4,5,6],[10,11,12],[7,8,9]]) == 33', 'assert maximum_Sum([[0,1,1],[1,1,2],[3,2,1]]) == 6', 'assert maximum_Sum([[0,1,3],[1,2,1],[9,8,2],[0,1,0],[6,4,8]]) == 19']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/230",
    "prompt": "Write a function to replace blank spaces with any character in a string.",
    "canonical_solution": "def replace_blank(str1,char):\r\n str2 = str1.replace(' ', char)\r\n return str2",
    "test": "['assert replace_blank(\"hello people\",\\'@\\')==(\"hello@people\")', 'assert replace_blank(\"python program language\",\\'$\\')==(\"python$program$language\")', 'assert replace_blank(\"blank space\",\"-\")==(\"blank-space\")']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/231",
    "prompt": "Write a function to find the maximum sum in the given right triangle of numbers.",
    "canonical_solution": "def max_sum(tri, n): \r\n\tif n > 1: \r\n\t\ttri[1][1] = tri[1][1]+tri[0][0] \r\n\t\ttri[1][0] = tri[1][0]+tri[0][0] \r\n\tfor i in range(2, n): \r\n\t\ttri[i][0] = tri[i][0] + tri[i-1][0] \r\n\t\ttri[i][i] = tri[i][i] + tri[i-1][i-1] \r\n\t\tfor j in range(1, i): \r\n\t\t\tif tri[i][j]+tri[i-1][j-1] >= tri[i][j]+tri[i-1][j]: \r\n\t\t\t\ttri[i][j] = tri[i][j] + tri[i-1][j-1] \r\n\t\t\telse: \r\n\t\t\t\ttri[i][j] = tri[i][j]+tri[i-1][j] \r\n\treturn (max(tri[n-1]))",
    "test": "['assert max_sum([[1], [2,1], [3,3,2]], 3) == 6', 'assert max_sum([[1], [1, 2], [4, 1, 12]], 3) == 15 ', 'assert max_sum([[2], [3,2], [13,23,12]], 3) == 28']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/232",
    "prompt": "Write a function to get the n largest items from a dataset.",
    "canonical_solution": "import heapq\r\ndef larg_nnum(list1,n):\r\n largest=heapq.nlargest(n,list1)\r\n return largest",
    "test": "['assert larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],2)==[100,90]', 'assert larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],5)==[100,90,80,70,60]', 'assert larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],3)==[100,90,80]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/233",
    "prompt": "Write a function to find the lateral surface area of a cylinder.",
    "canonical_solution": "def lateralsuface_cylinder(r,h):\r\n  lateralsurface= 2*3.1415*r*h\r\n  return lateralsurface",
    "test": "['assert lateralsuface_cylinder(10,5)==314.15000000000003', 'assert lateralsuface_cylinder(4,5)==125.66000000000001', 'assert lateralsuface_cylinder(4,10)==251.32000000000002']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/234",
    "prompt": "Write a function to find the volume of a cube.",
    "canonical_solution": "def volume_cube(l):\r\n  volume = l * l * l\r\n  return volume",
    "test": "['assert volume_cube(3)==27', 'assert volume_cube(2)==8', 'assert volume_cube(5)==125']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/235",
    "prompt": "Write a python function to set all even bits of a given number.",
    "canonical_solution": "def even_bit_set_number(n): \r\n    count = 0;res = 0;temp = n \r\n    while(temp > 0): \r\n        if (count % 2 == 1): \r\n            res |= (1 << count)\r\n        count+=1\r\n        temp >>= 1\r\n    return (n | res) ",
    "test": "['assert even_bit_set_number(10) == 10', 'assert even_bit_set_number(20) == 30', 'assert even_bit_set_number(30) == 30']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/236",
    "prompt": "Write a python function to count the maximum number of equilateral triangles that can be formed within a given equilateral triangle.",
    "canonical_solution": "def No_of_Triangle(N,K):\r\n    if (N < K):\r\n        return -1;\r\n    else:\r\n        Tri_up = 0;\r\n        Tri_up = ((N - K + 1) *(N - K + 2)) // 2;\r\n        Tri_down = 0;\r\n        Tri_down = ((N - 2 * K + 1) *(N - 2 * K + 2)) // 2;\r\n        return Tri_up + Tri_down;",
    "test": "['assert No_of_Triangle(4,2) == 7', 'assert No_of_Triangle(4,3) == 3', 'assert No_of_Triangle(1,3) == -1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/237",
    "prompt": "Write a function to check the occurrences of records which occur similar times in the given tuples.",
    "canonical_solution": "from collections import Counter \r\ndef check_occurences(test_list):\r\n  res = dict(Counter(tuple(ele) for ele in map(sorted, test_list)))\r\n  return  (res) ",
    "test": "['assert check_occurences([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)] ) == {(1, 3): 2, (2, 5): 2, (3, 6): 1}', 'assert check_occurences([(4, 2), (2, 4), (3, 6), (6, 3), (7, 4)] ) == {(2, 4): 2, (3, 6): 2, (4, 7): 1}', 'assert check_occurences([(13, 2), (11, 23), (12, 25), (25, 12), (16, 23)] ) == {(2, 13): 1, (11, 23): 1, (12, 25): 2, (16, 23): 1}']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/238",
    "prompt": "Write a python function to count number of non-empty substrings of a given string.",
    "canonical_solution": "def number_of_substrings(str): \r\n\tstr_len = len(str); \r\n\treturn int(str_len * (str_len + 1) / 2); ",
    "test": "['assert number_of_substrings(\"abc\") == 6', 'assert number_of_substrings(\"abcd\") == 10', 'assert number_of_substrings(\"abcde\") == 15']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/239",
    "prompt": "Write a function to find the number of possible sequences of length n such that each of the next element is greater than or equal to twice of the previous element but less than or equal to m.",
    "canonical_solution": "def get_total_number_of_sequences(m,n): \r\n\tT=[[0 for i in range(n+1)] for i in range(m+1)] \r\n\tfor i in range(m+1): \r\n\t\tfor j in range(n+1): \r\n\t\t\tif i==0 or j==0: \r\n\t\t\t\tT[i][j]=0\r\n\t\t\telif i<j: \r\n\t\t\t\tT[i][j]=0\r\n\t\t\telif j==1: \r\n\t\t\t\tT[i][j]=i \r\n\t\t\telse: \r\n\t\t\t\tT[i][j]=T[i-1][j]+T[i//2][j-1] \r\n\treturn T[m][n]",
    "test": "['assert get_total_number_of_sequences(10, 4) == 4', 'assert get_total_number_of_sequences(5, 2) == 6', 'assert get_total_number_of_sequences(16, 3) == 84']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/24",
    "prompt": "Write a function to convert the given binary number to its decimal equivalent.",
    "canonical_solution": "def binary_to_decimal(binary): \r\n    binary1 = binary \r\n    decimal, i, n = 0, 0, 0\r\n    while(binary != 0): \r\n        dec = binary % 10\r\n        decimal = decimal + dec * pow(2, i) \r\n        binary = binary//10\r\n        i += 1\r\n    return (decimal)",
    "test": "['assert binary_to_decimal(100) == 4', 'assert binary_to_decimal(1011) == 11', 'assert binary_to_decimal(1101101) == 109']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/240",
    "prompt": "Write a function to replace the last element of the list with another list.",
    "canonical_solution": "def replace_list(list1,list2):\r\n list1[-1:] = list2\r\n replace_list=list1\r\n return replace_list\r\n",
    "test": "['assert replace_list([1, 3, 5, 7, 9, 10],[2, 4, 6, 8])==[1, 3, 5, 7, 9, 2, 4, 6, 8]', 'assert replace_list([1,2,3,4,5],[5,6,7,8])==[1,2,3,4,5,6,7,8]', 'assert replace_list([\"red\",\"blue\",\"green\"],[\"yellow\"])==[\"red\",\"blue\",\"yellow\"]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/241",
    "prompt": "Write a function to generate a 3d array having each element as '*'.",
    "canonical_solution": "def array_3d(m,n,o):\r\n array_3d = [[ ['*' for col in range(m)] for col in range(n)] for row in range(o)]\r\n return array_3d",
    "test": "[\"assert array_3d(6,4,3)==[[['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*']]]\", \"assert array_3d(5,3,4)==[[['*', '*', '*', '*', '*'], ['*', '*', '*', '*','*'], ['*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*'],['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*']]]\", \"assert array_3d(1,2,3)==[[['*'],['*']],[['*'],['*']],[['*'],['*']]]\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/242",
    "prompt": "Write a function to count total characters in a string.",
    "canonical_solution": "def count_charac(str1):\r\n total = 0\r\n for i in str1:\r\n    total = total + 1\r\n return total",
    "test": "['assert count_charac(\"python programming\")==18', 'assert count_charac(\"language\")==8', 'assert count_charac(\"words\")==5']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/243",
    "prompt": "Write a function to sort the given list based on the occurrence of first element of tuples.",
    "canonical_solution": "def sort_on_occurence(lst): \r\n\tdct = {} \r\n\tfor i, j in lst: \r\n\t\tdct.setdefault(i, []).append(j) \r\n\treturn ([(i, *dict.fromkeys(j), len(j)) \r\n\t\t\t\tfor i, j in dct.items()]) ",
    "test": "[\"assert sort_on_occurence([(1, 'Jake'), (2, 'Bob'), (1, 'Cara')]) == [(1, 'Jake', 'Cara', 2), (2, 'Bob', 1)]\", \"assert sort_on_occurence([('b', 'ball'), ('a', 'arm'), ('b', 'b'), ('a', 'ant')]) == [('b', 'ball', 'b', 2), ('a', 'arm', 'ant', 2)]\", \"assert sort_on_occurence([(2, 'Mark'), (3, 'Maze'), (2, 'Sara')]) == [(2, 'Mark', 'Sara', 2), (3, 'Maze', 1)]\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/244",
    "prompt": "Write a python function to find the next perfect square greater than a given number.",
    "canonical_solution": "import math  \r\ndef next_Perfect_Square(N): \r\n    nextN = math.floor(math.sqrt(N)) + 1\r\n    return nextN * nextN ",
    "test": "['assert next_Perfect_Square(35) == 36', 'assert next_Perfect_Square(6) == 9', 'assert next_Perfect_Square(9) == 16']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/245",
    "prompt": "Write a function to find the maximum sum of bi-tonic sub-sequence for the given array.",
    "canonical_solution": "def max_sum(arr, n): \r\n\tMSIBS = arr[:] \r\n\tfor i in range(n): \r\n\t\tfor j in range(0, i): \r\n\t\t\tif arr[i] > arr[j] and MSIBS[i] < MSIBS[j] + arr[i]: \r\n\t\t\t\tMSIBS[i] = MSIBS[j] + arr[i] \r\n\tMSDBS = arr[:] \r\n\tfor i in range(1, n + 1): \r\n\t\tfor j in range(1, i): \r\n\t\t\tif arr[-i] > arr[-j] and MSDBS[-i] < MSDBS[-j] + arr[-i]: \r\n\t\t\t\tMSDBS[-i] = MSDBS[-j] + arr[-i] \r\n\tmax_sum = float(\"-Inf\") \r\n\tfor i, j, k in zip(MSIBS, MSDBS, arr): \r\n\t\tmax_sum = max(max_sum, i + j - k) \r\n\treturn max_sum",
    "test": "['assert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9], 9) == 194', 'assert max_sum([80, 60, 30, 40, 20, 10], 6) == 210', 'assert max_sum([2, 3 ,14, 16, 21, 23, 29, 30], 8) == 138']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/246",
    "prompt": "Write a function for computing square roots using the babylonian method.",
    "canonical_solution": "def babylonian_squareroot(number):\r\n    if(number == 0):\r\n        return 0;\r\n    g = number/2.0;\r\n    g2 = g + 1;\r\n    while(g != g2):\r\n        n = number/ g;\r\n        g2 = g;\r\n        g = (g + n)/2;\r\n    return g;",
    "test": "['assert babylonian_squareroot(10)==3.162277660168379', 'assert babylonian_squareroot(2)==1.414213562373095', 'assert babylonian_squareroot(9)==3.0']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/247",
    "prompt": "Write a function to find the longest palindromic subsequence in the given string.",
    "canonical_solution": "def lps(str): \r\n\tn = len(str) \r\n\tL = [[0 for x in range(n)] for x in range(n)] \r\n\tfor i in range(n): \r\n\t\tL[i][i] = 1\r\n\tfor cl in range(2, n+1): \r\n\t\tfor i in range(n-cl+1): \r\n\t\t\tj = i+cl-1\r\n\t\t\tif str[i] == str[j] and cl == 2: \r\n\t\t\t\tL[i][j] = 2\r\n\t\t\telif str[i] == str[j]: \r\n\t\t\t\tL[i][j] = L[i+1][j-1] + 2\r\n\t\t\telse: \r\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \r\n\treturn L[0][n-1]",
    "test": "['assert lps(\"TENS FOR TENS\") == 5 ', 'assert lps(\"CARDIO FOR CARDS\") == 7', 'assert lps(\"PART OF THE JOURNEY IS PART\") == 9 ']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/248",
    "prompt": "Write a function to calculate the harmonic sum of n-1.",
    "canonical_solution": "def harmonic_sum(n):\r\n  if n < 2:\r\n    return 1\r\n  else:\r\n    return 1 / n + (harmonic_sum(n - 1)) ",
    "test": "['assert harmonic_sum(7) == 2.5928571428571425', 'assert harmonic_sum(4) == 2.083333333333333', 'assert harmonic_sum(19) == 3.547739657143682']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/249",
    "prompt": "Write a function to find the intersection of two arrays using lambda function.",
    "canonical_solution": "def intersection_array(array_nums1,array_nums2):\r\n result = list(filter(lambda x: x in array_nums1, array_nums2)) \r\n return result",
    "test": "['assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[1, 2, 4, 8, 9])==[1, 2, 8, 9]', 'assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[3,5,7,9])==[3,5,7,9]', 'assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[10,20,30,40])==[10]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/25",
    "prompt": "Write a python function to find the product of non-repeated elements in a given array.",
    "canonical_solution": "def find_Product(arr,n): \r\n    arr.sort() \r\n    prod = 1\r\n    for i in range(0,n,1): \r\n        if (arr[i - 1] != arr[i]): \r\n            prod = prod * arr[i] \r\n    return prod; ",
    "test": "['assert find_Product([1,1,2,3],4) == 6', 'assert find_Product([1,2,3,1,1],5) == 6', 'assert find_Product([1,1,4,5,6],5) == 120']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/250",
    "prompt": "Write a python function to count the occcurences of an element in a tuple.",
    "canonical_solution": "def count_X(tup, x): \r\n    count = 0\r\n    for ele in tup: \r\n        if (ele == x): \r\n            count = count + 1\r\n    return count ",
    "test": "['assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),4) == 0', 'assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),10) == 3', 'assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),8) == 4']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/251",
    "prompt": "Write a function to insert an element before each element of a list.",
    "canonical_solution": "def insert_element(list,element):\r\n list = [v for elt in list for v in (element, elt)]\r\n return list",
    "test": "[\"assert insert_element(['Red', 'Green', 'Black'] ,'c')==['c', 'Red', 'c', 'Green', 'c', 'Black'] \", \"assert insert_element(['python', 'java'] ,'program')==['program', 'python', 'program', 'java'] \", \"assert insert_element(['happy', 'sad'] ,'laugh')==['laugh', 'happy', 'laugh', 'sad'] \"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/252",
    "prompt": "Write a python function to convert complex numbers to polar coordinates.",
    "canonical_solution": "import cmath  \r\ndef convert(numbers):    \r\n  num = cmath.polar(numbers)  \r\n  return (num) ",
    "test": "['assert convert(1) == (1.0, 0.0)', 'assert convert(4) == (4.0,0.0)', 'assert convert(5) == (5.0,0.0)']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/253",
    "prompt": "Write a python function to count integers from a given list.",
    "canonical_solution": "def count_integer(list1):\r\n    ctr = 0\r\n    for i in list1:\r\n        if isinstance(i, int):\r\n            ctr = ctr + 1\r\n    return ctr",
    "test": "[\"assert count_integer([1,2,'abc',1.2]) == 2\", 'assert count_integer([1,2,3]) == 3', 'assert count_integer([1,1.2,4,5.1]) == 2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/254",
    "prompt": "Write a function to find all words starting with 'a' or 'e' in a given string.",
    "canonical_solution": "import re\r\ndef words_ae(text):\r\n list = re.findall(\"[ae]\\w+\", text)\r\n return list",
    "test": "['assert words_ae(\"python programe\")==[\\'ame\\']', 'assert words_ae(\"python programe language\")==[\\'ame\\',\\'anguage\\']', 'assert words_ae(\"assert statement\")==[\\'assert\\', \\'atement\\']']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/255",
    "prompt": "Write a function to choose specified number of colours from three different colours and generate all the combinations with repetitions.",
    "canonical_solution": "from itertools import combinations_with_replacement \r\ndef combinations_colors(l, n):\r\n    return list(combinations_with_replacement(l,n))\r",
    "test": "['assert combinations_colors( [\"Red\",\"Green\",\"Blue\"],1)==[(\\'Red\\',), (\\'Green\\',), (\\'Blue\\',)]', 'assert combinations_colors( [\"Red\",\"Green\",\"Blue\"],2)==[(\\'Red\\', \\'Red\\'), (\\'Red\\', \\'Green\\'), (\\'Red\\', \\'Blue\\'), (\\'Green\\', \\'Green\\'), (\\'Green\\', \\'Blue\\'), (\\'Blue\\', \\'Blue\\')]', 'assert combinations_colors( [\"Red\",\"Green\",\"Blue\"],3)==[(\\'Red\\', \\'Red\\', \\'Red\\'), (\\'Red\\', \\'Red\\', \\'Green\\'), (\\'Red\\', \\'Red\\', \\'Blue\\'), (\\'Red\\', \\'Green\\', \\'Green\\'), (\\'Red\\', \\'Green\\', \\'Blue\\'), (\\'Red\\', \\'Blue\\', \\'Blue\\'), (\\'Green\\', \\'Green\\', \\'Green\\'), (\\'Green\\', \\'Green\\', \\'Blue\\'), (\\'Green\\', \\'Blue\\', \\'Blue\\'), (\\'Blue\\', \\'Blue\\', \\'Blue\\')]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/256",
    "prompt": "Write a python function to count the number of prime numbers less than a given non-negative number.",
    "canonical_solution": "def count_Primes_nums(n):\r\n    ctr = 0\r\n    for num in range(n):\r\n        if num <= 1:\r\n            continue\r\n        for i in range(2,num):\r\n            if (num % i) == 0:\r\n                break\r\n        else:\r\n            ctr += 1\r\n    return ctr",
    "test": "['assert count_Primes_nums(5) == 2', 'assert count_Primes_nums(10) == 4', 'assert count_Primes_nums(100) == 25']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/257",
    "prompt": "Write a function to swap two numbers.",
    "canonical_solution": "def swap_numbers(a,b):\r\n temp = a\r\n a = b\r\n b = temp\r\n return (a,b)",
    "test": "['assert swap_numbers(10,20)==(20,10)', 'assert swap_numbers(15,17)==(17,15)', 'assert swap_numbers(100,200)==(200,100)']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/258",
    "prompt": "Write a function to find number of odd elements in the given list using lambda function.",
    "canonical_solution": "def count_odd(array_nums):\r\n   count_odd = len(list(filter(lambda x: (x%2 != 0) , array_nums)))\r\n   return count_odd",
    "test": "['assert count_odd([1, 2, 3, 5, 7, 8, 10])==4', 'assert count_odd([10,15,14,13,-18,12,-20])==2', 'assert count_odd([1, 2, 4, 8, 9])==2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/259",
    "prompt": "Write a function to maximize the given two tuples.",
    "canonical_solution": "def maximize_elements(test_tup1, test_tup2):\r\n  res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))\r\n   for tup1, tup2 in zip(test_tup1, test_tup2))\r\n  return (res) ",
    "test": "['assert maximize_elements(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((6, 7), (4, 9), (2, 9), (7, 10))', 'assert maximize_elements(((2, 4), (5, 6), (3, 10), (2, 11)), ((7, 8), (4, 10), (2, 2), (8, 4))) == ((7, 8), (5, 10), (3, 10), (8, 11))', 'assert maximize_elements(((3, 5), (6, 7), (4, 11), (3, 12)), ((8, 9), (5, 11), (3, 3), (9, 5))) == ((8, 9), (6, 11), (4, 11), (9, 12))']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/26",
    "prompt": "Write a function to check if the given tuple list has all k elements.",
    "canonical_solution": "def check_k_elements(test_list, K):\r\n  res = True\r\n  for tup in test_list:\r\n    for ele in tup:\r\n      if ele != K:\r\n        res = False\r\n  return (res) ",
    "test": "['assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True', 'assert check_k_elements([(7, 7, 7), (7, 7)], 7) == True', 'assert check_k_elements([(9, 9), (9, 9, 9, 9)], 7) == False']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/260",
    "prompt": "Write a function to find the nth newman\u2013shanks\u2013williams prime number.",
    "canonical_solution": "def newman_prime(n): \r\n\tif n == 0 or n == 1: \r\n\t\treturn 1\r\n\treturn 2 * newman_prime(n - 1) + newman_prime(n - 2)",
    "test": "['assert newman_prime(3) == 7 ', 'assert newman_prime(4) == 17', 'assert newman_prime(5) == 41']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/261",
    "prompt": "Write a function to perform mathematical division operation across the given tuples.",
    "canonical_solution": "def division_elements(test_tup1, test_tup2):\r\n  res = tuple(ele1 // ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res) ",
    "test": "['assert division_elements((10, 4, 6, 9),(5, 2, 3, 3)) == (2, 2, 2, 3)', 'assert division_elements((12, 6, 8, 16),(6, 3, 4, 4)) == (2, 2, 2, 4)', 'assert division_elements((20, 14, 36, 18),(5, 7, 6, 9)) == (4, 2, 6, 2)']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/262",
    "prompt": "Write a function to split a given list into two parts where the length of the first part of the list is given.",
    "canonical_solution": "def split_two_parts(list1, L):\r\n    return list1[:L], list1[L:]",
    "test": "['assert split_two_parts([1,1,2,3,4,4,5,1],3)==([1, 1, 2], [3, 4, 4, 5, 1])', \"assert split_two_parts(['a', 'b', 'c', 'd'],2)==(['a', 'b'], ['c', 'd'])\", \"assert split_two_parts(['p', 'y', 't', 'h', 'o', 'n'],4)==(['p', 'y', 't', 'h'], ['o', 'n'])\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/263",
    "prompt": "Write a function to merge two dictionaries.",
    "canonical_solution": "def merge_dict(d1,d2):\r\n d = d1.copy()\r\n d.update(d2)\r\n return d",
    "test": "[\"assert merge_dict({'a': 100, 'b': 200},{'x': 300, 'y': 200})=={'x': 300, 'y': 200, 'a': 100, 'b': 200}\", \"assert merge_dict({'a':900,'b':900,'d':900},{'a':900,'b':900,'d':900})=={'a':900,'b':900,'d':900,'a':900,'b':900,'d':900}\", \"assert merge_dict({'a':10,'b':20},{'x':30,'y':40})=={'x':30,'y':40,'a':10,'b':20}\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/264",
    "prompt": "Write a function to calculate a dog's age in dog's years.",
    "canonical_solution": "def dog_age(h_age):\r\n if h_age < 0:\r\n \texit()\r\n elif h_age <= 2:\r\n\t d_age = h_age * 10.5\r\n else:\r\n\t d_age = 21 + (h_age - 2)*4\r\n return d_age",
    "test": "['assert dog_age(12)==61', 'assert dog_age(15)==73', 'assert dog_age(24)==109']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/265",
    "prompt": "Write a function to split a list for every nth element.",
    "canonical_solution": "def list_split(S, step):\r\n    return [S[i::step] for i in range(step)]",
    "test": "[\"assert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'],3)==[['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']] \", 'assert list_split([1,2,3,4,5,6,7,8,9,10,11,12,13,14],3)==[[1,4,7,10,13], [2,5,8,11,14], [3,6,9,12]] ', \"assert list_split(['python','java','C','C++','DBMS','SQL'],2)==[['python', 'C', 'DBMS'], ['java', 'C++', 'SQL']] \"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/266",
    "prompt": "Write a function to find the lateral surface area of a cube.",
    "canonical_solution": "def lateralsurface_cube(l):\r\n  LSA = 4 * (l * l)\r\n  return LSA",
    "test": "['assert lateralsurface_cube(5)==100', 'assert lateralsurface_cube(9)==324', 'assert lateralsurface_cube(10)==400']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/267",
    "prompt": "Write a python function to find the sum of squares of first n odd natural numbers.",
    "canonical_solution": "def square_Sum(n):  \r\n    return int(n*(4*n*n-1)/3) ",
    "test": "['assert square_Sum(2) == 10', 'assert square_Sum(3) == 35', 'assert square_Sum(4) == 84']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/268",
    "prompt": "Write a function to find the n'th star number.",
    "canonical_solution": "def find_star_num(n): \r\n\treturn (6 * n * (n - 1) + 1) ",
    "test": "['assert find_star_num(3) == 37', 'assert find_star_num(4) == 73', 'assert find_star_num(5) == 121']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/269",
    "prompt": "Write a function to find the ascii value of a character.",
    "canonical_solution": "def ascii_value(k):\r\n  ch=k\r\n  return ord(ch)",
    "test": "[\"assert ascii_value('A')==65\", \"assert ascii_value('R')==82\", \"assert ascii_value('S')==83\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/27",
    "prompt": "Write a python function to remove all digits from a list of strings.",
    "canonical_solution": "import re  \r\ndef remove(list): \r\n    pattern = '[0-9]'\r\n    list = [re.sub(pattern, '', i) for i in list] \r\n    return list",
    "test": "[\"assert remove(['4words', '3letters', '4digits']) == ['words', 'letters', 'digits']\", \"assert remove(['28Jan','12Jan','11Jan']) == ['Jan','Jan','Jan']\", \"assert remove(['wonder1','wonder2','wonder3']) == ['wonder','wonder','wonder']\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/270",
    "prompt": "Write a python function to find the sum of even numbers at even positions.",
    "canonical_solution": "def sum_even_and_even_index(arr,n):  \r\n    i = 0\r\n    sum = 0\r\n    for i in range(0,n,2): \r\n        if (arr[i] % 2 == 0) : \r\n            sum += arr[i]  \r\n    return sum",
    "test": "['assert sum_even_and_even_index([5, 6, 12, 1, 18, 8],6) == 30', 'assert sum_even_and_even_index([3, 20, 17, 9, 2, 10, 18, 13, 6, 18],10) == 26', 'assert sum_even_and_even_index([5, 6, 12, 1],4) == 12']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/271",
    "prompt": "Write a python function to find the sum of fifth power of first n even natural numbers.",
    "canonical_solution": "def even_Power_Sum(n): \r\n    sum = 0; \r\n    for i in range(1,n+1): \r\n        j = 2*i; \r\n        sum = sum + (j*j*j*j*j); \r\n    return sum; ",
    "test": "['assert even_Power_Sum(2) == 1056', 'assert even_Power_Sum(3) == 8832', 'assert even_Power_Sum(1) == 32']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/272",
    "prompt": "Write a function to perfom the rear element extraction from list of tuples records.",
    "canonical_solution": "def rear_extract(test_list):\r\n  res = [lis[-1] for lis in test_list]\r\n  return (res) ",
    "test": "[\"assert rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]\", \"assert rear_extract([(1, 'Sai', 36), (2, 'Ayesha', 25), (3, 'Salman', 45)]) == [36, 25, 45]\", \"assert rear_extract([(1, 'Sudeep', 14), (2, 'Vandana', 36), (3, 'Dawood', 56)]) == [14, 36, 56]\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/273",
    "prompt": "Write a function to substract the contents of one tuple with corresponding index of other tuple.",
    "canonical_solution": "def substract_elements(test_tup1, test_tup2):\r\n  res = tuple(map(lambda i, j: i - j, test_tup1, test_tup2))\r\n  return (res) ",
    "test": "['assert substract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)', 'assert substract_elements((11, 2, 3), (24, 45 ,16)) == (-13, -43, -13)', 'assert substract_elements((7, 18, 9), (10, 11, 12)) == (-3, 7, -3)']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/274",
    "prompt": "Write a python function to find sum of even index binomial coefficients.",
    "canonical_solution": "import math  \r\ndef even_binomial_Coeff_Sum( n): \r\n    return (1 << (n - 1)) ",
    "test": "['assert even_binomial_Coeff_Sum(4) == 8', 'assert even_binomial_Coeff_Sum(6) == 32', 'assert even_binomial_Coeff_Sum(2) == 2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/275",
    "prompt": "Write a python function to find the position of the last removed element from the given array.",
    "canonical_solution": "import math as mt \r\ndef get_Position(a,n,m): \r\n    for i in range(n): \r\n        a[i] = (a[i] // m + (a[i] % m != 0))  \r\n    result,maxx = -1,-1\r\n    for i in range(n - 1,-1,-1): \r\n        if (maxx < a[i]): \r\n            maxx = a[i] \r\n            result = i \r\n    return result + 1",
    "test": "['assert get_Position([2,5,4],3,2) == 2', 'assert get_Position([4,3],2,2) == 2', 'assert get_Position([1,2,3,4],4,1) == 4']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/276",
    "prompt": "Write a function to find the volume of a cylinder.",
    "canonical_solution": "def volume_cylinder(r,h):\r\n  volume=3.1415*r*r*h\r\n  return volume",
    "test": "['assert volume_cylinder(10,5)==1570.7500000000002', 'assert volume_cylinder(4,5)==251.32000000000002', 'assert volume_cylinder(4,10)==502.64000000000004']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/277",
    "prompt": "Write a function to filter a dictionary based on values.",
    "canonical_solution": "def dict_filter(dict,n):\r\n result = {key:value for (key, value) in dict.items() if value >=n}\r\n return result",
    "test": "[\"assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},170)=={'Cierra Vega': 175, 'Alden Cantrell': 180, 'Pierre Cox': 190}\", \"assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},180)=={ 'Alden Cantrell': 180, 'Pierre Cox': 190}\", \"assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},190)=={ 'Pierre Cox': 190}\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/278",
    "prompt": "Write a function to find the element count that occurs before the record in the given tuple.",
    "canonical_solution": "def count_first_elements(test_tup):\r\n  for count, ele in enumerate(test_tup):\r\n    if isinstance(ele, tuple):\r\n      break\r\n  return (count) ",
    "test": "['assert count_first_elements((1, 5, 7, (4, 6), 10) ) == 3', 'assert count_first_elements((2, 9, (5, 7), 11) ) == 2', 'assert count_first_elements((11, 15, 5, 8, (2, 3), 8) ) == 4']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/279",
    "prompt": "Write a function to find the nth decagonal number.",
    "canonical_solution": "def is_num_decagonal(n): \r\n\treturn 4 * n * n - 3 * n ",
    "test": "['assert is_num_decagonal(3) == 27', 'assert is_num_decagonal(7) == 175', 'assert is_num_decagonal(10) == 370']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/28",
    "prompt": "Write a python function to find binomial co-efficient.",
    "canonical_solution": "def binomial_Coeff(n,k): \r\n    if k > n : \r\n       return 0\r\n    if k==0 or k ==n : \r\n        return 1 \r\n    return binomial_Coeff(n-1,k-1) + binomial_Coeff(n-1,k) ",
    "test": "['assert binomial_Coeff(5,2) == 10', 'assert binomial_Coeff(4,3) == 4', 'assert binomial_Coeff(3,2) == 3']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/280",
    "prompt": "Write a function to search an element in the given array by using sequential search.",
    "canonical_solution": "def sequential_search(dlist, item):\r\n    pos = 0\r\n    found = False\r\n    while pos < len(dlist) and not found:\r\n        if dlist[pos] == item:\r\n            found = True\r\n        else:\r\n            pos = pos + 1\r\n    return found, pos",
    "test": "['assert sequential_search([11,23,58,31,56,77,43,12,65,19],31) == (True, 3)', 'assert sequential_search([12, 32, 45, 62, 35, 47, 44, 61],61) == (True, 7)', 'assert sequential_search([9, 10, 17, 19, 22, 39, 48, 56],48) == (True, 6)']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/281",
    "prompt": "Write a python function to check if the elements of a given list are unique or not.",
    "canonical_solution": "def all_unique(test_list):\r\n    if len(test_list) > len(set(test_list)):\r\n        return False\r\n    return True",
    "test": "['assert all_unique([1,2,3]) == True', 'assert all_unique([1,2,1,2]) == False', 'assert all_unique([1,2,3,4,5]) == True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/282",
    "prompt": "Write a function to substaract two lists using map and lambda function.",
    "canonical_solution": "def sub_list(nums1,nums2):\r\n  result = map(lambda x, y: x - y, nums1, nums2)\r\n  return list(result)",
    "test": "['assert sub_list([1, 2, 3],[4,5,6])==[-3,-3,-3]', 'assert sub_list([1,2],[3,4])==[-2,-2]', 'assert sub_list([90,120],[50,70])==[40,50]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/283",
    "prompt": "Write a python function to check whether the frequency of each digit is less than or equal to the digit itself.",
    "canonical_solution": "def validate(n): \r\n    for i in range(10): \r\n        temp = n;  \r\n        count = 0; \r\n        while (temp): \r\n            if (temp % 10 == i): \r\n                count+=1;  \r\n            if (count > i): \r\n                return False\r\n            temp //= 10; \r\n    return True",
    "test": "['assert validate(1234) == True', 'assert validate(51241) == False', 'assert validate(321) == True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/284",
    "prompt": "Write a function to check whether all items of a list are equal to a given string.",
    "canonical_solution": "def check_element(list,element):\r\n  check_element=all(v== element for v in list)\r\n  return check_element",
    "test": "['assert check_element([\"green\", \"orange\", \"black\", \"white\"],\\'blue\\')==False', 'assert check_element([1,2,3,4],7)==False', 'assert check_element([\"green\", \"green\", \"green\", \"green\"],\\'green\\')==True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/285",
    "prompt": "Write a function that matches a string that has an a followed by two to three 'b'.",
    "canonical_solution": "import re\r\ndef text_match_two_three(text):\r\n        patterns = 'ab{2,3}'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')",
    "test": "['assert text_match_two_three(\"ac\")==(\\'Not matched!\\')', 'assert text_match_two_three(\"dc\")==(\\'Not matched!\\')', 'assert text_match_two_three(\"abbbba\")==(\\'Found a match!\\')']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/286",
    "prompt": "Write a function to find the largest sum of contiguous array in the modified array which is formed by repeating the given array k times.",
    "canonical_solution": "def max_sub_array_sum_repeated(a, n, k): \r\n\tmax_so_far = -2147483648\r\n\tmax_ending_here = 0\r\n\tfor i in range(n*k): \r\n\t\tmax_ending_here = max_ending_here + a[i%n] \r\n\t\tif (max_so_far < max_ending_here): \r\n\t\t\tmax_so_far = max_ending_here \r\n\t\tif (max_ending_here < 0): \r\n\t\t\tmax_ending_here = 0\r\n\treturn max_so_far",
    "test": "['assert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30', 'assert max_sub_array_sum_repeated([-1, 10, 20], 3, 2) == 59', 'assert max_sub_array_sum_repeated([-1, -2, -3], 3, 3) == -1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/287",
    "prompt": "Write a python function to find the sum of squares of first n even natural numbers.",
    "canonical_solution": "def square_Sum(n):  \r\n    return int(2*n*(n+1)*(2*n+1)/3)",
    "test": "['assert square_Sum(2) == 20', 'assert square_Sum(3) == 56', 'assert square_Sum(4) == 120']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/288",
    "prompt": "Write a function to count array elements having modular inverse under given prime number p equal to itself.",
    "canonical_solution": "def modular_inverse(arr, N, P):\r\n\tcurrent_element = 0\r\n\tfor i in range(0, N):\r\n\t\tif ((arr[i] * arr[i]) % P == 1):\r\n\t\t\tcurrent_element = current_element + 1\r\n\treturn current_element",
    "test": "['assert modular_inverse([ 1, 6, 4, 5 ], 4, 7) == 2', 'assert modular_inverse([1, 3, 8, 12, 12], 5, 13) == 3', 'assert modular_inverse([2, 3, 4, 5], 4, 6) == 1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/289",
    "prompt": "Write a python function to calculate the number of odd days in a given year.",
    "canonical_solution": "def odd_Days(N): \r\n    hund1 = N // 100\r\n    hund4 = N // 400\r\n    leap = N >> 2\r\n    ordd = N - leap \r\n    if (hund1): \r\n        ordd += hund1 \r\n        leap -= hund1 \r\n    if (hund4): \r\n        ordd -= hund4 \r\n        leap += hund4 \r\n    days = ordd + leap * 2\r\n    odd = days % 7\r\n    return odd ",
    "test": "['assert odd_Days(100) == 5', 'assert odd_Days(50) ==6', 'assert odd_Days(75) == 2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/29",
    "prompt": "Write a python function to find the element occurring odd number of times.",
    "canonical_solution": "def get_Odd_Occurrence(arr,arr_size):   \r\n    for i in range(0,arr_size): \r\n        count = 0\r\n        for j in range(0,arr_size): \r\n            if arr[i] == arr[j]: \r\n                count+=1     \r\n        if (count % 2 != 0): \r\n            return arr[i]     \r\n    return -1",
    "test": "['assert get_Odd_Occurrence([1,2,3,1,2,3,1],7) == 1', 'assert get_Odd_Occurrence([1,2,3,2,3,1,3],7) == 3', 'assert get_Odd_Occurrence([2,3,5,4,5,2,4,3,5,2,4,4,2],13) == 5']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/290",
    "prompt": "Write a function to find the list of lists with maximum length.",
    "canonical_solution": "def max_length(list1):\r\n    max_length = max(len(x) for x in  list1 )  \r\n    max_list = max((x) for x in   list1)\r\n    return(max_length, max_list)",
    "test": "['assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])', 'assert max_length([[1], [5, 7], [10, 12, 14,15]])==(4, [10, 12, 14,15])', 'assert max_length([[5], [15,20,25]])==(3, [15,20,25])']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/291",
    "prompt": "Write a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.",
    "canonical_solution": "def count_no_of_ways(n, k): \r\n\tdp = [0] * (n + 1) \r\n\ttotal = k \r\n\tmod = 1000000007\r\n\tdp[1] = k \r\n\tdp[2] = k * k\t \r\n\tfor i in range(3,n+1): \r\n\t\tdp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod \r\n\treturn dp[n]",
    "test": "['assert count_no_of_ways(2, 4) == 16', 'assert count_no_of_ways(3, 2) == 6', 'assert count_no_of_ways(4, 4) == 228']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/292",
    "prompt": "Write a python function to find quotient of two numbers.",
    "canonical_solution": "def find(n,m):  \r\n    q = n//m \r\n    return (q)",
    "test": "['assert find(10,3) == 3', 'assert find(4,2) == 2', 'assert find(20,5) == 4']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/293",
    "prompt": "Write a function to find the third side of a right angled triangle.",
    "canonical_solution": "import math\r\ndef otherside_rightangle(w,h):\r\n  s=math.sqrt((w*w)+(h*h))\r\n  return s",
    "test": "['assert otherside_rightangle(7,8)==10.63014581273465', 'assert otherside_rightangle(3,4)==5', 'assert otherside_rightangle(7,15)==16.55294535724685']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/294",
    "prompt": "Write a function to find the maximum value in a given heterogeneous list.",
    "canonical_solution": "def max_val(listval):\r\n     max_val = max(i for i in listval if isinstance(i, int)) \r\n     return(max_val)",
    "test": "[\"assert max_val(['Python', 3, 2, 4, 5, 'version'])==5\", \"assert max_val(['Python', 15, 20, 25])==25\", \"assert max_val(['Python', 30, 20, 40, 50, 'version'])==50\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/295",
    "prompt": "Write a function to return the sum of all divisors of a number.",
    "canonical_solution": "def sum_div(number):\r\n    divisors = [1]\r\n    for i in range(2, number):\r\n        if (number % i)==0:\r\n            divisors.append(i)\r\n    return sum(divisors)",
    "test": "['assert sum_div(8)==7', 'assert sum_div(12)==16', 'assert sum_div(7)==1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/296",
    "prompt": "Write a python function to count inversions in an array.",
    "canonical_solution": "def get_Inv_Count(arr,n): \r\n    inv_count = 0\r\n    for i in range(n): \r\n        for j in range(i + 1,n): \r\n            if (arr[i] > arr[j]): \r\n                inv_count += 1\r\n    return inv_count ",
    "test": "['assert get_Inv_Count([1,20,6,4,5],5) == 5', 'assert get_Inv_Count([1,2,1],3) == 1', 'assert get_Inv_Count([1,2,5,6,1],5) == 3']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/297",
    "prompt": "Write a function to flatten a given nested list structure.",
    "canonical_solution": "def flatten_list(list1):\r\n    result_list = []\r\n    if not list1: return result_list\r\n    stack = [list(list1)]\r\n    while stack:\r\n        c_num = stack.pop()\r\n        next = c_num.pop()\r\n        if c_num: stack.append(c_num)\r\n        if isinstance(next, list):\r\n            if next: stack.append(list(next))\r\n        else: result_list.append(next)\r\n    result_list.reverse()\r\n    return result_list ",
    "test": "['assert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])==[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]', 'assert flatten_list([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]])==[10, 20, 40, 30, 56, 25, 10, 20, 33, 40]', 'assert flatten_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])==[1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/298",
    "prompt": "Write a function to find the nested list elements which are present in another list.",
    "canonical_solution": "def intersection_nested_lists(l1, l2):\r\n    result = [[n for n in lst if n in l1] for lst in l2]\r\n    return result",
    "test": "['assert intersection_nested_lists( [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],[[12, 18, 23, 25, 45], [7, 11, 19, 24, 28], [1, 5, 8, 18, 15, 16]])==[[12], [7, 11], [1, 5, 8]]', 'assert intersection_nested_lists([[2, 3, 1], [4, 5], [6, 8]], [[4, 5], [6, 8]])==[[], []]', \"assert intersection_nested_lists(['john','amal','joel','george'],[['john'],['jack','john','mary'],['howard','john'],['jude']])==[['john'], ['john'], ['john'], []]\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/299",
    "prompt": "Write a function to calculate the maximum aggregate from the list of tuples.",
    "canonical_solution": "from collections import defaultdict\r\ndef max_aggregate(stdata):\r\n    temp = defaultdict(int)\r\n    for name, marks in stdata:\r\n        temp[name] += marks\r\n    return max(temp.items(), key=lambda x: x[1])",
    "test": "[\"assert max_aggregate([('Juan Whelan',90),('Sabah Colley',88),('Peter Nichols',7),('Juan Whelan',122),('Sabah Colley',84)])==('Juan Whelan', 212)\", \"assert max_aggregate([('Juan Whelan',50),('Sabah Colley',48),('Peter Nichols',37),('Juan Whelan',22),('Sabah Colley',14)])==('Juan Whelan', 72)\", \"assert max_aggregate([('Juan Whelan',10),('Sabah Colley',20),('Peter Nichols',30),('Juan Whelan',40),('Sabah Colley',50)])==('Sabah Colley', 70)\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/30",
    "prompt": "Write a python function to count all the substrings starting and ending with same characters.",
    "canonical_solution": "def check_Equality(s): \r\n    return (ord(s[0]) == ord(s[len(s) - 1])); \r\ndef count_Substring_With_Equal_Ends(s): \r\n    result = 0; \r\n    n = len(s); \r\n    for i in range(n): \r\n        for j in range(1,n-i+1):  \r\n            if (check_Equality(s[i:i+j])): \r\n                result+=1; \r\n    return result; ",
    "test": "['assert count_Substring_With_Equal_Ends(\"abc\") == 3', 'assert count_Substring_With_Equal_Ends(\"abcda\") == 6', 'assert count_Substring_With_Equal_Ends(\"ab\") == 2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/300",
    "prompt": "Write a function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.",
    "canonical_solution": "def count_binary_seq(n): \r\n\tnCr = 1\r\n\tres = 1\r\n\tfor r in range(1, n + 1): \r\n\t\tnCr = (nCr * (n + 1 - r)) / r \r\n\t\tres += nCr * nCr \r\n\treturn res ",
    "test": "['assert count_binary_seq(1) == 2.0', 'assert count_binary_seq(2) == 6.0', 'assert count_binary_seq(3) == 20.0']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/301",
    "prompt": "Write a function to find the depth of a dictionary.",
    "canonical_solution": "def dict_depth(d):\r\n    if isinstance(d, dict):\r\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\r\n    return 0",
    "test": "[\"assert dict_depth({'a':1, 'b': {'c': {'d': {}}}})==4\", \"assert dict_depth({'a':1, 'b': {'c':'python'}})==2\", \"assert dict_depth({1: 'Sun', 2: {3: {4:'Mon'}}})==3\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/302",
    "prompt": "Write a python function to find the most significant bit number which is also a set bit.",
    "canonical_solution": "def set_Bit_Number(n): \r\n    if (n == 0): \r\n        return 0; \r\n    msb = 0; \r\n    n = int(n / 2); \r\n    while (n > 0): \r\n        n = int(n / 2); \r\n        msb += 1; \r\n    return (1 << msb)",
    "test": "['assert set_Bit_Number(6) == 4', 'assert set_Bit_Number(10) == 8', 'assert set_Bit_Number(18) == 16']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/303",
    "prompt": "Write a python function to check whether the count of inversion of two types are same or not.",
    "canonical_solution": "import sys \r\ndef solve(a,n):   \r\n    mx = -sys.maxsize - 1\r\n    for j in range(1,n):  \r\n        if (mx > a[j]):  \r\n            return False  \r\n        mx = max(mx,a[j - 1])    \r\n    return True",
    "test": "['assert solve([1,0,2],3) == True', 'assert solve([1,2,0],3) == False', 'assert solve([1,2,1],3) == True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/304",
    "prompt": "Write a python function to find element at a given index after number of rotations.",
    "canonical_solution": "def find_Element(arr,ranges,rotations,index) :  \r\n    for i in range(rotations - 1,-1,-1 ) : \r\n        left = ranges[i][0] \r\n        right = ranges[i][1] \r\n        if (left <= index and right >= index) : \r\n            if (index == left) : \r\n                index = right \r\n            else : \r\n                index = index - 1 \r\n    return arr[index] ",
    "test": "['assert find_Element([1,2,3,4,5],[[0,2],[0,3]],2,1) == 3', 'assert find_Element([1,2,3,4],[[0,1],[0,2]],1,2) == 3', 'assert find_Element([1,2,3,4,5,6],[[0,1],[0,2]],1,1) == 1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/305",
    "prompt": "Write a function to match two words from a list of words starting with letter 'p'.",
    "canonical_solution": "import re\r\ndef start_withp(words):\r\n for w in words:\r\n        m = re.match(\"(P\\w+)\\W(P\\w+)\", w)\r\n        if m:\r\n            return m.groups()",
    "test": "['assert start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"])==(\\'Python\\', \\'PHP\\')', 'assert start_withp([\"Python Programming\",\"Java Programming\"])==(\\'Python\\',\\'Programming\\')', 'assert start_withp([\"Pqrst Pqr\",\"qrstuv\"])==(\\'Pqrst\\',\\'Pqr\\')']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/306",
    "prompt": "Write a function to find the maximum sum of increasing subsequence from prefix till ith index and also including a given kth element which is after i, i.e., k > i .",
    "canonical_solution": "def max_sum_increasing_subseq(a, n, index, k):\r\n\tdp = [[0 for i in range(n)] \r\n\t\t\tfor i in range(n)]\r\n\tfor i in range(n):\r\n\t\tif a[i] > a[0]:\r\n\t\t\tdp[0][i] = a[i] + a[0]\r\n\t\telse:\r\n\t\t\tdp[0][i] = a[i]\r\n\tfor i in range(1, n):\r\n\t\tfor j in range(n):\r\n\t\t\tif a[j] > a[i] and j > i:\r\n\t\t\t\tif dp[i - 1][i] + a[j] > dp[i - 1][j]:\r\n\t\t\t\t\tdp[i][j] = dp[i - 1][i] + a[j]\r\n\t\t\t\telse:\r\n\t\t\t\t\tdp[i][j] = dp[i - 1][j]\r\n\t\t\telse:\r\n\t\t\t\tdp[i][j] = dp[i - 1][j]\r\n\treturn dp[index][k]",
    "test": "['assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 4, 6) == 11', 'assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 2, 5) == 7', 'assert max_sum_increasing_subseq([11, 15, 19, 21, 26, 28, 31], 7, 2, 4) == 71']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/307",
    "prompt": "Write a function to get a colon of a tuple.",
    "canonical_solution": "from copy import deepcopy\r\ndef colon_tuplex(tuplex,m,n):\r\n  tuplex_colon = deepcopy(tuplex)\r\n  tuplex_colon[m].append(n)\r\n  return tuplex_colon",
    "test": "['assert colon_tuplex((\"HELLO\", 5, [], True) ,2,50)==(\"HELLO\", 5, [50], True) ', 'assert colon_tuplex((\"HELLO\", 5, [], True) ,2,100)==((\"HELLO\", 5, [100],True))', 'assert colon_tuplex((\"HELLO\", 5, [], True) ,2,500)==(\"HELLO\", 5, [500], True)']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/308",
    "prompt": "Write a function to find the specified number of largest products from two given lists.",
    "canonical_solution": "def large_product(nums1, nums2, N):\r\n    result = sorted([x*y for x in nums1 for y in nums2], reverse=True)[:N]\r\n    return result",
    "test": "['assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],3)==[60, 54, 50]', 'assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],4)==[60, 54, 50, 48]', 'assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],5)==[60, 54, 50, 48, 45]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/309",
    "prompt": "Write a python function to find the maximum of two numbers.",
    "canonical_solution": "def maximum(a,b):   \r\n    if a >= b: \r\n        return a \r\n    else: \r\n        return b ",
    "test": "['assert maximum(5,10) == 10', 'assert maximum(-1,-2) == -1', 'assert maximum(9,7) == 9']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/31",
    "prompt": "Write a function to find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.",
    "canonical_solution": "def func(nums, k):\r\n    import collections\r\n    d = collections.defaultdict(int)\r\n    for row in nums:\r\n        for i in row:\r\n            d[i] += 1\r\n    temp = []\r\n    import heapq\r\n    for key, v in d.items():\r\n        if len(temp) < k:\r\n            temp.append((v, key))\r\n            if len(temp) == k:\r\n                heapq.heapify(temp)\r\n        else:\r\n            if v > temp[0][0]:\r\n                heapq.heappop(temp)\r\n                heapq.heappush(temp, (v, key))\r\n    result = []\r\n    while temp:\r\n        v, key = heapq.heappop(temp)\r\n        result.append(key)\r\n    return result",
    "test": "['assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],3)==[5, 7, 1]', 'assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],1)==[1]', 'assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],5)==[6, 5, 7, 8, 1]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/310",
    "prompt": "Write a function to convert a given string to a tuple.",
    "canonical_solution": "def string_to_tuple(str1):\r\n    result = tuple(x for x in str1 if not x.isspace()) \r\n    return result",
    "test": "['assert string_to_tuple(\"python 3.0\")==(\\'p\\', \\'y\\', \\'t\\', \\'h\\', \\'o\\', \\'n\\', \\'3\\', \\'.\\', \\'0\\')', 'assert string_to_tuple(\"item1\")==(\\'i\\', \\'t\\', \\'e\\', \\'m\\', \\'1\\')', 'assert string_to_tuple(\"15.10\")==(\\'1\\', \\'5\\', \\'.\\', \\'1\\', \\'0\\')']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/311",
    "prompt": "Write a python function to set the left most unset bit.",
    "canonical_solution": "def set_left_most_unset_bit(n): \r\n    if not (n & (n + 1)): \r\n        return n \r\n    pos, temp, count = 0, n, 0 \r\n    while temp: \r\n        if not (temp & 1): \r\n            pos = count      \r\n        count += 1; temp>>=1\r\n    return (n | (1 << (pos))) ",
    "test": "['assert set_left_most_unset_bit(10) == 14', 'assert set_left_most_unset_bit(12) == 14', 'assert set_left_most_unset_bit(15) == 15']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/312",
    "prompt": "Write a function to find the volume of a cone.",
    "canonical_solution": "import math\r\ndef volume_cone(r,h):\r\n  volume = (1.0/3) * math.pi * r * r * h\r\n  return volume",
    "test": "['assert volume_cone(5,12)==314.15926535897927', 'assert volume_cone(10,15)==1570.7963267948965', 'assert volume_cone(19,17)==6426.651371693521']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/313",
    "prompt": "Write a python function to print positive numbers in a list.",
    "canonical_solution": "def pos_nos(list1):\r\n  for num in list1: \r\n    if num >= 0: \r\n       return num ",
    "test": "['assert pos_nos([-1,-2,1,2]) == 1,2', 'assert pos_nos([3,4,-5]) == 3,4', 'assert pos_nos([-2,-3,1]) == 1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/314",
    "prompt": "Write a function to find out the maximum sum such that no two chosen numbers are adjacent for the given rectangular grid of dimension 2 x n.",
    "canonical_solution": "def max_sum_rectangular_grid(grid, n) : \r\n\tincl = max(grid[0][0], grid[1][0]) \r\n\texcl = 0\r\n\tfor i in range(1, n) : \r\n\t\texcl_new = max(excl, incl) \r\n\t\tincl = excl + max(grid[0][i], grid[1][i]) \r\n\t\texcl = excl_new \r\n\treturn max(excl, incl)",
    "test": "['assert max_sum_rectangular_grid([ [1, 4, 5], [2, 0, 0 ] ], 3) == 7', 'assert max_sum_rectangular_grid([ [ 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10] ], 5) == 24', 'assert max_sum_rectangular_grid([ [7, 9, 11, 15, 19], [21, 25, 28, 31, 32] ], 5) == 81']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/315",
    "prompt": "Write a python function to find the first maximum length of even word.",
    "canonical_solution": "def find_Max_Len_Even(str): \r\n    n = len(str) \r\n    i = 0\r\n    currlen = 0\r\n    maxlen = 0\r\n    st = -1\r\n    while (i < n): \r\n        if (str[i] == ' '): \r\n            if (currlen % 2 == 0): \r\n                if (maxlen < currlen): \r\n                    maxlen = currlen \r\n                    st = i - currlen \r\n            currlen = 0 \r\n        else : \r\n            currlen += 1\r\n        i += 1\r\n    if (currlen % 2 == 0): \r\n        if (maxlen < currlen): \r\n            maxlen = currlen \r\n            st = i - currlen \r\n    if (st == -1): \r\n        return \"-1\" \r\n    return str[st: st + maxlen] ",
    "test": "['assert find_Max_Len_Even(\"python language\") == \"language\"', 'assert find_Max_Len_Even(\"maximum even length\") == \"length\"', 'assert find_Max_Len_Even(\"eve\") == \"-1\"']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/316",
    "prompt": "Write a function to find the index of the last occurrence of a given number in a sorted array.",
    "canonical_solution": "def find_last_occurrence(A, x):\r\n    (left, right) = (0, len(A) - 1)\r\n    result = -1\r\n    while left <= right:\r\n        mid = (left + right) // 2\r\n        if x == A[mid]:\r\n            result = mid\r\n            left = mid + 1\r\n        elif x < A[mid]:\r\n            right = mid - 1\r\n        else:\r\n            left = mid + 1\r\n    return result ",
    "test": "['assert find_last_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 3', 'assert find_last_occurrence([2, 3, 5, 8, 6, 6, 8, 9, 9, 9], 9) == 9', 'assert find_last_occurrence([2, 2, 1, 5, 6, 6, 6, 9, 9, 9], 6) == 6']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/317",
    "prompt": "Write a function to reflect the modified run-length encoding from a list.",
    "canonical_solution": "from itertools import groupby\r\ndef modified_encode(alist):\r\n        def ctr_ele(el):\r\n            if len(el)>1: return [len(el), el[0]]\r\n            else: return el[0]\r\n        return [ctr_ele(list(group)) for key, group in groupby(alist)]",
    "test": "['assert modified_encode([1,1,2,3,4,4,5,1])==[[2, 1], 2, 3, [2, 4], 5, 1]', \"assert modified_encode('automatically')==['a', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', 'a', [2, 'l'], 'y']\", \"assert modified_encode('python')==['p', 'y', 't', 'h', 'o', 'n']\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/318",
    "prompt": "Write a python function to find the maximum volume of a cuboid with given sum of sides.",
    "canonical_solution": "def max_volume (s): \r\n    maxvalue = 0\r\n    i = 1\r\n    for i in range(s - 1): \r\n        j = 1\r\n        for j in range(s): \r\n            k = s - i - j \r\n            maxvalue = max(maxvalue, i * j * k)         \r\n    return maxvalue ",
    "test": "['assert max_volume(8) == 18', 'assert max_volume(4) == 2', 'assert max_volume(1) == 0']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/319",
    "prompt": "Write a function to find all five characters long word in the given string by using regex.",
    "canonical_solution": "import re\r\ndef find_long_word(text):\r\n  return (re.findall(r\"\\b\\w{5}\\b\", text))",
    "test": "[\"assert find_long_word('Please move back to strem') == ['strem']\", \"assert find_long_word('4K Ultra HD streaming player') == ['Ultra']\", \"assert find_long_word('Streaming Media Player') == ['Media']\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/32",
    "prompt": "Write a python function to find the largest prime factor of a given number.",
    "canonical_solution": "import math \r\ndef max_Prime_Factors (n): \r\n    maxPrime = -1 \r\n    while n%2 == 0: \r\n        maxPrime = 2\r\n        n >>= 1    \r\n    for i in range(3,int(math.sqrt(n))+1,2): \r\n        while n % i == 0: \r\n            maxPrime = i \r\n            n = n / i \r\n    if n > 2: \r\n        maxPrime = n  \r\n    return int(maxPrime)",
    "test": "['assert max_Prime_Factors(15) == 5', 'assert max_Prime_Factors(6) == 3', 'assert max_Prime_Factors(2) == 2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/320",
    "prompt": "Write a function to calculate the difference between the squared sum of first n natural numbers and the sum of squared first n natural numbers.",
    "canonical_solution": "def sum_difference(n):\r\n    sumofsquares = 0\r\n    squareofsum = 0\r\n    for num in range(1, n+1):\r\n        sumofsquares += num * num\r\n        squareofsum += num\r\n    squareofsum = squareofsum ** 2\r\n    return squareofsum - sumofsquares",
    "test": "['assert sum_difference(12)==5434', 'assert sum_difference(20)==41230', 'assert sum_difference(54)==2151270']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/321",
    "prompt": "Write a function to find the demlo number for the given number.",
    "canonical_solution": "def find_demlo(s): \r\n\tl = len(s) \r\n\tres = \"\" \r\n\tfor i in range(1,l+1): \r\n\t\tres = res + str(i) \r\n\tfor i in range(l-1,0,-1): \r\n\t\tres = res + str(i) \r\n\treturn res \t",
    "test": "['assert find_demlo(\"111111\") == \\'12345654321\\'', 'assert find_demlo(\"1111\") == \\'1234321\\'', 'assert find_demlo(\"13333122222\") == \\'123456789101110987654321\\'']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/322",
    "prompt": "Write a function to find all index positions of the minimum values in a given list.",
    "canonical_solution": "def position_min(list1):\r\n    min_val = min(list1)\r\n    min_result = [i for i, j in enumerate(list1) if j == min_val]\r\n    return min_result",
    "test": "['assert position_min([12,33,23,10,67,89,45,667,23,12,11,10,54])==[3,11]', 'assert position_min([1,2,2,2,4,4,4,5,5,5,5])==[0]', 'assert position_min([2,1,5,6,8,3,4,9,10,11,8,12])==[1]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/323",
    "prompt": "Write a function to re-arrange the given array in alternating positive and negative items.",
    "canonical_solution": "def right_rotate(arr, n, out_of_place, cur):\r\n\ttemp = arr[cur]\r\n\tfor i in range(cur, out_of_place, -1):\r\n\t\tarr[i] = arr[i - 1]\r\n\tarr[out_of_place] = temp\r\n\treturn arr\r\ndef re_arrange(arr, n):\r\n\tout_of_place = -1\r\n\tfor index in range(n):\r\n\t\tif (out_of_place >= 0):\r\n\t\t\tif ((arr[index] >= 0 and arr[out_of_place] < 0) or\r\n\t\t\t(arr[index] < 0 and arr[out_of_place] >= 0)):\r\n\t\t\t\tarr = right_rotate(arr, n, out_of_place, index)\r\n\t\t\t\tif (index-out_of_place > 2):\r\n\t\t\t\t\tout_of_place += 2\r\n\t\t\t\telse:\r\n\t\t\t\t\tout_of_place = - 1\r\n\t\tif (out_of_place == -1):\r\n\t\t\tif ((arr[index] >= 0 and index % 2 == 0) or\r\n\t\t\t (arr[index] < 0 and index % 2 == 1)):\r\n\t\t\t\tout_of_place = index\r\n\treturn arr",
    "test": "['assert re_arrange([-5, -2, 5, 2, 4,\\t7, 1, 8, 0, -8], 10) == [-5, 5, -2, 2, -8, 4, 7, 1, 8, 0]', 'assert re_arrange([1, 2, 3, -4, -1, 4], 6) == [-4, 1, -1, 2, 3, 4]', 'assert re_arrange([4, 7, 9, 77, -4, 5, -3, -9], 8) == [-4, 4, -3, 7, -9, 9, 77, 5]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/324",
    "prompt": "Write a function to extract the sum of alternate chains of tuples.",
    "canonical_solution": "def sum_of_alternates(test_tuple):\r\n  sum1 = 0\r\n  sum2 = 0\r\n  for idx, ele in enumerate(test_tuple):\r\n    if idx % 2:\r\n      sum1 += ele\r\n    else:\r\n      sum2 += ele\r\n  return ((sum1),(sum2)) ",
    "test": "['assert sum_of_alternates((5, 6, 3, 6, 10, 34)) == (46, 18)', 'assert sum_of_alternates((1, 2, 3, 4, 5)) == (6, 9)', 'assert sum_of_alternates((6, 7, 8, 9, 4, 5)) == (21, 18)']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/325",
    "prompt": "Write a python function to find the minimum number of squares whose sum is equal to a given number.",
    "canonical_solution": "def get_Min_Squares(n):\r\n    if n <= 3:\r\n        return n;\r\n    res = n \r\n    for x in range(1,n + 1):\r\n        temp = x * x;\r\n        if temp > n:\r\n            break\r\n        else:\r\n            res = min(res,1 + get_Min_Squares(n  - temp)) \r\n    return res;",
    "test": "['assert get_Min_Squares(6) == 3', 'assert get_Min_Squares(2) == 2', 'assert get_Min_Squares(4) == 1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/326",
    "prompt": "Write a function to get the word with most number of occurrences in the given strings list.",
    "canonical_solution": "from collections import defaultdict \r\n\r\ndef most_occurrences(test_list):\r\n  temp = defaultdict(int)\r\n  for sub in test_list:\r\n    for wrd in sub.split():\r\n      temp[wrd] += 1\r\n  res = max(temp, key=temp.get)\r\n  return (str(res)) ",
    "test": "['assert most_occurrences([\"UTS is best for RTF\", \"RTF love UTS\", \"UTS is best\"] ) == \\'UTS\\'', 'assert most_occurrences([\"Its been a great year\", \"this year is so worse\", \"this year is okay\"] ) == \\'year\\'', 'assert most_occurrences([\"Families can be reunited\", \"people can be reunited\", \"Tasks can be achieved \"] ) == \\'can\\'']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/327",
    "prompt": "Write a function to print check if the triangle is isosceles or not.",
    "canonical_solution": "def check_isosceles(x,y,z):\r\n  if x==y or y==z or z==x:\r\n\t   return True\r\n  else:\r\n     return False",
    "test": "['assert check_isosceles(6,8,12)==False ', 'assert check_isosceles(6,6,12)==True', 'assert check_isosceles(6,16,20)==False']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/328",
    "prompt": "Write a function to rotate a given list by specified number of items to the left direction.",
    "canonical_solution": "def rotate_left(list1,m,n):\r\n  result =  list1[m:]+list1[:n]\r\n  return result",
    "test": "['assert rotate_left([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],3,4)==[4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4]', 'assert rotate_left([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],2,2)==[3, 4, 5, 6, 7, 8, 9, 10, 1, 2]', 'assert rotate_left([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],5,2)==[6, 7, 8, 9, 10, 1, 2]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/329",
    "prompt": "Write a python function to count negative numbers in a list.",
    "canonical_solution": "def neg_count(list):\r\n  neg_count= 0\r\n  for num in list: \r\n    if num <= 0: \r\n      neg_count += 1\r\n  return neg_count ",
    "test": "['assert neg_count([-1,-2,3,-4,-5]) == 4', 'assert neg_count([1,2,3]) == 0', 'assert neg_count([1,2,-3,-10,20]) == 2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/33",
    "prompt": "Write a python function to convert a decimal number to binary number.",
    "canonical_solution": "def decimal_To_Binary(N): \r\n    B_Number = 0\r\n    cnt = 0\r\n    while (N != 0): \r\n        rem = N % 2\r\n        c = pow(10,cnt)  \r\n        B_Number += rem*c  \r\n        N //= 2 \r\n        cnt += 1\r\n    return B_Number  ",
    "test": "['assert decimal_To_Binary(10) == 1010', 'assert decimal_To_Binary(1) == 1', 'assert decimal_To_Binary(20) == 10100']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/330",
    "prompt": "Write a function to find all three, four, five characters long words in the given string by using regex.",
    "canonical_solution": "import re\r\ndef find_char(text):\r\n  return (re.findall(r\"\\b\\w{3,5}\\b\", text))",
    "test": "[\"assert find_char('For the four consumer complaints contact manager AKR reddy') == ['For', 'the', 'four', 'AKR', 'reddy']\", \"assert find_char('Certain service are subject to change MSR') == ['are', 'MSR']\", \"assert find_char('Third party legal desclaimers') == ['Third', 'party', 'legal']\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/331",
    "prompt": "Write a python function to count unset bits of a given number.",
    "canonical_solution": "def count_unset_bits(n): \r\n    count = 0\r\n    x = 1\r\n    while(x < n + 1): \r\n        if ((x & n) == 0): \r\n            count += 1\r\n        x = x << 1\r\n    return count  ",
    "test": "['assert count_unset_bits(2) == 1', 'assert count_unset_bits(4) == 2', 'assert count_unset_bits(6) == 1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/332",
    "prompt": "Write a function to count character frequency of a given string.",
    "canonical_solution": "def char_frequency(str1):\r\n    dict = {}\r\n    for n in str1:\r\n        keys = dict.keys()\r\n        if n in keys:\r\n            dict[n] += 1\r\n        else:\r\n            dict[n] = 1\r\n    return dict",
    "test": "[\"assert char_frequency('python')=={'p': 1, 'y': 1, 't': 1, 'h': 1, 'o': 1, 'n': 1}\", \"assert char_frequency('program')=={'p': 1, 'r': 2, 'o': 1, 'g': 1, 'a': 1, 'm': 1}\", \"assert char_frequency('language')=={'l': 1, 'a': 2, 'n': 1, 'g': 2, 'u': 1, 'e': 1}\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/333",
    "prompt": "Write a python function to sort a list according to the second element in sublist.",
    "canonical_solution": "def Sort(sub_li): \r\n    sub_li.sort(key = lambda x: x[1]) \r\n    return sub_li ",
    "test": "[\"assert Sort([['a', 10], ['b', 5], ['c', 20], ['d', 15]]) == [['b', 5], ['a', 10], ['d', 15], ['c', 20]]\", \"assert Sort([['452', 10], ['256', 5], ['100', 20], ['135', 15]]) == [['256', 5], ['452', 10], ['135', 15], ['100', 20]]\", \"assert Sort([['rishi', 10], ['akhil', 5], ['ramya', 20], ['gaur', 15]]) == [['akhil', 5], ['rishi', 10], ['gaur', 15], ['ramya', 20]]\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/334",
    "prompt": "Write a python function to check whether the triangle is valid or not if sides are given.",
    "canonical_solution": "def check_Validity(a,b,c):  \r\n    if (a + b <= c) or (a + c <= b) or (b + c <= a) : \r\n        return False\r\n    else: \r\n        return True        ",
    "test": "['assert check_Validity(1,2,3) == False', 'assert check_Validity(2,3,5) == False', 'assert check_Validity(7,10,5) == True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/335",
    "prompt": "Write a function to find the sum of arithmetic progression.",
    "canonical_solution": "def ap_sum(a,n,d):\r\n  total = (n * (2 * a + (n - 1) * d)) / 2\r\n  return total",
    "test": "['assert ap_sum(1,5,2)==25', 'assert ap_sum(2,6,4)==72', 'assert ap_sum(1,4,5)==34']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/336",
    "prompt": "Write a function to check whether the given month name contains 28 days or not.",
    "canonical_solution": "def check_monthnum(monthname1):\r\n  if monthname1 == \"February\":\r\n    return True\r\n  else:\r\n    return False",
    "test": "['assert check_monthnum(\"February\")==True', 'assert check_monthnum(\"January\")==False', 'assert check_monthnum(\"March\")==False']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/337",
    "prompt": "Write a function that matches a word at the end of a string, with optional punctuation.",
    "canonical_solution": "import re\r\ndef text_match_word(text):\r\n        patterns = '\\w+\\S*$'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return 'Not matched!'",
    "test": "['assert text_match_word(\"python.\")==(\\'Found a match!\\')', 'assert text_match_word(\"python.\")==(\\'Found a match!\\')', 'assert text_match_word(\"  lang  .\")==(\\'Not matched!\\')']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/338",
    "prompt": "Write a python function to count the number of substrings with same first and last characters.",
    "canonical_solution": "def check_Equality(s): \r\n    return (ord(s[0]) == ord(s[len(s) - 1])); \r\ndef count_Substring_With_Equal_Ends(s): \r\n    result = 0; \r\n    n = len(s); \r\n    for i in range(n):\r\n        for j in range(1,n-i+1): \r\n            if (check_Equality(s[i:i+j])): \r\n                result+=1; \r\n    return result; ",
    "test": "[\"assert count_Substring_With_Equal_Ends('aba') == 4\", \"assert count_Substring_With_Equal_Ends('abcab') == 7\", \"assert count_Substring_With_Equal_Ends('abc') == 3\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/339",
    "prompt": "Write a python function to find the maximum occuring divisor in an interval.",
    "canonical_solution": "def find_Divisor(x,y):  \r\n    if (x==y): \r\n        return y \r\n    return 2",
    "test": "['assert find_Divisor(2,2) == 2', 'assert find_Divisor(2,5) == 2', 'assert find_Divisor(5,10) == 2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/34",
    "prompt": "Write a python function to find the missing number in a sorted array.",
    "canonical_solution": "def find_missing(ar,N): \r\n    l = 0\r\n    r = N - 1\r\n    while (l <= r):  \r\n        mid = (l + r) / 2\r\n        mid= int (mid) \r\n        if (ar[mid] != mid + 1 and ar[mid - 1] == mid): \r\n            return (mid + 1)  \r\n        elif (ar[mid] != mid + 1): \r\n            r = mid - 1 \r\n        else: \r\n            l = mid + 1\r\n    return (-1) ",
    "test": "['assert find_missing([1,2,3,5],4) == 4', 'assert find_missing([1,3,4,5],4) == 2', 'assert find_missing([1,2,3,5,6,7],5) == 4']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/340",
    "prompt": "Write a python function to find the sum of the three lowest positive numbers from a given list of numbers.",
    "canonical_solution": "def sum_three_smallest_nums(lst):\r\n\treturn sum(sorted([x for x in lst if x > 0])[:3])",
    "test": "['assert sum_three_smallest_nums([10,20,30,40,50,60,7]) == 37', 'assert sum_three_smallest_nums([1,2,3,4,5]) == 6', 'assert sum_three_smallest_nums([0,1,2,3,4,5]) == 6']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/341",
    "prompt": "Write a function to convert the given set into ordered tuples.",
    "canonical_solution": "def set_to_tuple(s):\r\n  t = tuple(sorted(s))\r\n  return (t)",
    "test": "['assert set_to_tuple({1, 2, 3, 4, 5}) == (1, 2, 3, 4, 5)', 'assert set_to_tuple({6, 7, 8, 9, 10, 11}) == (6, 7, 8, 9, 10, 11)', 'assert set_to_tuple({12, 13, 14, 15, 16}) == (12, 13, 14, 15, 16)']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/342",
    "prompt": "Write a function to find the smallest range that includes at-least one element from each of the given arrays.",
    "canonical_solution": "from heapq import heappop, heappush\r\nclass Node:\r\n    def __init__(self, value, list_num, index):\r\n        self.value = value\r\n        self.list_num = list_num\r\n        self.index = index\r\n    def __lt__(self, other):\r\n        return self.value < other.value\r\ndef find_minimum_range(list):\r\n    high = float('-inf')\r\n    p = (0, float('inf'))\r\n    pq = []\r\n    for i in range(len(list)):\r\n        heappush(pq, Node(list[i][0], i, 0))\r\n        high = max(high, list[i][0])\r\n    while True:\r\n        top = heappop(pq)\r\n        low = top.value\r\n        i = top.list_num\r\n        j = top.index\r\n        if high - low < p[1] - p[0]:\r\n            p = (low, high)\r\n        if j == len(list[i]) - 1:\r\n            return p\r\n        heappush(pq, Node(list[i][j + 1], i, j + 1))\r\n        high = max(high, list[i][j + 1])",
    "test": "['assert find_minimum_range([[3, 6, 8, 10, 15], [1, 5, 12], [4, 8, 15, 16], [2, 6]]) == (4, 6)', 'assert find_minimum_range([[ 2, 3, 4, 8, 10, 15 ], [1, 5, 12], [7, 8, 15, 16], [3, 6]]) == (4, 7)', 'assert find_minimum_range([[4, 7, 9, 11, 16], [2, 6, 13], [5, 9, 16, 17], [3, 7]]) == (5, 7)']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/343",
    "prompt": "Write a function to calculate the number of digits and letters in a string.",
    "canonical_solution": "def dig_let(s):\r\n d=l=0\r\n for c in s:\r\n    if c.isdigit():\r\n        d=d+1\r\n    elif c.isalpha():\r\n        l=l+1\r\n    else:\r\n        pass\r\n return (l,d)",
    "test": "['assert dig_let(\"python\")==(6,0)', 'assert dig_let(\"program\")==(7,0)', 'assert dig_let(\"python3.0\")==(6,2)']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/344",
    "prompt": "Write a python function to find number of elements with odd factors in a given range.",
    "canonical_solution": "def count_Odd_Squares(n,m): \r\n    return int(m**0.5) - int((n-1)**0.5) ",
    "test": "['assert count_Odd_Squares(5,100) == 8', 'assert count_Odd_Squares(8,65) == 6', 'assert count_Odd_Squares(2,5) == 1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/345",
    "prompt": "Write a function to find the difference between two consecutive numbers in a given list.",
    "canonical_solution": "def diff_consecutivenums(nums):\r\n    result = [b-a for a, b in zip(nums[:-1], nums[1:])]\r\n    return result",
    "test": "['assert diff_consecutivenums([1, 1, 3, 4, 4, 5, 6, 7])==[0, 2, 1, 0, 1, 1, 1]', 'assert diff_consecutivenums([4, 5, 8, 9, 6, 10])==[1, 3, 1, -3, 4]', 'assert diff_consecutivenums([0, 1, 2, 3, 4, 4, 4, 4, 5, 7])==[1, 1, 1, 1, 0, 0, 0, 1, 2]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/346",
    "prompt": "Write a function to find entringer number e(n, k).",
    "canonical_solution": "def zigzag(n, k): \r\n\tif (n == 0 and k == 0): \r\n\t\treturn 1\r\n\tif (k == 0): \r\n\t\treturn 0\r\n\treturn zigzag(n, k - 1) + zigzag(n - 1, n - k)",
    "test": "['assert zigzag(4, 3) == 5', 'assert zigzag(4, 2) == 4', 'assert zigzag(3, 1) == 1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/347",
    "prompt": "Write a python function to count the number of squares in a rectangle.",
    "canonical_solution": "def count_Squares(m,n): \r\n    if (n < m): \r\n        temp = m \r\n        m = n \r\n        n = temp \r\n    return n * (n + 1) * (3 * m - n + 1) // 6",
    "test": "['assert count_Squares(4,3) == 20', 'assert count_Squares(1,2) == 2', 'assert count_Squares(2,2) == 5']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/348",
    "prompt": "Write a function to count sequences of given length having non-negative prefix sums that can be generated by given values.",
    "canonical_solution": "def bin_coff(n, r): \r\n\tval = 1\r\n\tif (r > (n - r)): \r\n\t\tr = (n - r) \r\n\tfor i in range(0, r): \r\n\t\tval *= (n - i) \r\n\t\tval //= (i + 1) \r\n\treturn val \r\ndef find_ways(M): \r\n\tn = M // 2\r\n\ta = bin_coff(2 * n, n) \r\n\tb = a // (n + 1) \r\n\treturn (b) ",
    "test": "['assert find_ways(4) == 2', 'assert find_ways(6) == 5', 'assert find_ways(8) == 14']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/349",
    "prompt": "Write a python function to check whether the given string is a binary string or not.",
    "canonical_solution": "def check(string) :\r\n    p = set(string) \r\n    s = {'0', '1'} \r\n    if s == p or p == {'0'} or p == {'1'}: \r\n        return (\"Yes\") \r\n    else : \r\n        return (\"No\") ",
    "test": "['assert check(\"01010101010\") == \"Yes\"', 'assert check(\"name0\") == \"No\"', 'assert check(\"101\") == \"Yes\"']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/35",
    "prompt": "Write a function to find the n-th rectangular number.",
    "canonical_solution": "def find_rect_num(n):\r\n  return n*(n + 1) ",
    "test": "['assert find_rect_num(4) == 20', 'assert find_rect_num(5) == 30', 'assert find_rect_num(6) == 42']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/350",
    "prompt": "Write a python function to minimize the length of the string by removing occurrence of only one character.",
    "canonical_solution": "def minimum_Length(s) : \r\n    maxOcc = 0\r\n    n = len(s) \r\n    arr = [0]*26\r\n    for i in range(n) : \r\n        arr[ord(s[i]) -ord('a')] += 1\r\n    for i in range(26) : \r\n        if arr[i] > maxOcc : \r\n            maxOcc = arr[i] \r\n    return n - maxOcc ",
    "test": "['assert minimum_Length(\"mnm\") == 1', 'assert minimum_Length(\"abcda\") == 3', 'assert minimum_Length(\"abcb\") == 2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/351",
    "prompt": "Write a python function to find the first element occurring k times in a given array.",
    "canonical_solution": "def first_Element(arr,n,k): \r\n    count_map = {}; \r\n    for i in range(0, n): \r\n        if(arr[i] in count_map.keys()): \r\n            count_map[arr[i]] += 1\r\n        else: \r\n            count_map[arr[i]] = 1\r\n        i += 1\r\n    for i in range(0, n):  \r\n        if (count_map[arr[i]] == k): \r\n            return arr[i] \r\n        i += 1 \r\n    return -1",
    "test": "['assert first_Element([0,1,2,3,4,5],6,1) == 0', 'assert first_Element([1,2,1,3,4],5,2) == 1', 'assert first_Element([2,3,4,3,5,7,1,2,3,5],10,2) == 2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/352",
    "prompt": "Write a python function to check whether all the characters in a given string are unique.",
    "canonical_solution": "def unique_Characters(str):\r\n    for i in range(len(str)):\r\n        for j in range(i + 1,len(str)): \r\n            if (str[i] == str[j]):\r\n                return False;\r\n    return True;",
    "test": "[\"assert unique_Characters('aba') == False\", \"assert unique_Characters('abc') == True\", \"assert unique_Characters('abab') == False\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/353",
    "prompt": "Write a function to remove a specified column from a given nested list.",
    "canonical_solution": "def remove_column(list1, n):\r\n   for i in list1: \r\n    del i[n] \r\n   return list1",
    "test": "['assert remove_column([[1, 2, 3], [2, 4, 5], [1, 1, 1]],0)==[[2, 3], [4, 5], [1, 1]]', 'assert remove_column([[1, 2, 3], [-2, 4, -5], [1, -1, 1]],2)==[[1, 2], [-2, 4], [1, -1]]', 'assert remove_column([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]],0)==[[3], [7], [3], [15, 17], [7], [11]]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/354",
    "prompt": "Write a function to find t-nth term of arithemetic progression.",
    "canonical_solution": "def tn_ap(a,n,d):\r\n  tn = a + (n - 1) * d\r\n  return tn",
    "test": "['assert tn_ap(1,5,2)==9', 'assert tn_ap(2,6,4)==22', 'assert tn_ap(1,4,5)==16']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/355",
    "prompt": "Write a python function to count the number of rectangles in a circle of radius r.",
    "canonical_solution": "def count_Rectangles(radius):  \r\n    rectangles = 0 \r\n    diameter = 2 * radius \r\n    diameterSquare = diameter * diameter \r\n    for a in range(1, 2 * radius):  \r\n        for b in range(1, 2 * radius): \r\n            diagnalLengthSquare = (a * a +  b * b)  \r\n            if (diagnalLengthSquare <= diameterSquare) : \r\n                rectangles += 1\r\n    return rectangles ",
    "test": "['assert count_Rectangles(2) == 8', 'assert count_Rectangles(1) == 1', 'assert count_Rectangles(0) == 0']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/356",
    "prompt": "Write a function to find the third angle of a triangle using two angles.",
    "canonical_solution": "def find_angle(a,b):\r\n c = 180 - (a + b)\r\n return c\r\n",
    "test": "['assert find_angle(47,89)==44', 'assert find_angle(45,95)==40', 'assert find_angle(50,40)==90']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/357",
    "prompt": "Write a function to find the maximum element of all the given tuple records.",
    "canonical_solution": "def find_max(test_list):\r\n  res = max(int(j) for i in test_list for j in i)\r\n  return (res) ",
    "test": "['assert find_max([(2, 4), (6, 7), (5, 1), (6, 10), (8, 7)]) == 10', 'assert find_max([(3, 5), (7, 8), (6, 2), (7, 11), (9, 8)]) == 11', 'assert find_max([(4, 6), (8, 9), (7, 3), (8, 12), (10, 9)]) == 12']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/358",
    "prompt": "Write a function to find modulo division of two lists using map and lambda function.",
    "canonical_solution": "def moddiv_list(nums1,nums2):\r\n  result = map(lambda x, y: x % y, nums1, nums2)\r\n  return list(result)",
    "test": "['assert moddiv_list([4,5,6],[1, 2, 3])==[0, 1, 0]', 'assert moddiv_list([3,2],[1,4])==[0, 2]', 'assert moddiv_list([90,120],[50,70])==[40, 50]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/359",
    "prompt": "Write a python function to check whether one root of the quadratic equation is twice of the other or not.",
    "canonical_solution": "def Check_Solution(a,b,c): \r\n    if (2*b*b == 9*a*c): \r\n        return (\"Yes\"); \r\n    else: \r\n        return (\"No\"); ",
    "test": "['assert Check_Solution(1,3,2) == \"Yes\"', 'assert Check_Solution(1,2,3) == \"No\"', 'assert Check_Solution(1,-5,6) == \"No\"']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/36",
    "prompt": "Write a python function to find the nth digit in the proper fraction of two given numbers.",
    "canonical_solution": "def find_Nth_Digit(p,q,N) :  \r\n    while (N > 0) : \r\n        N -= 1;  \r\n        p *= 10;  \r\n        res = p // q;  \r\n        p %= q;  \r\n    return res;  ",
    "test": "['assert find_Nth_Digit(1,2,1) == 5', 'assert find_Nth_Digit(3,5,1) == 6', 'assert find_Nth_Digit(5,6,5) == 3']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/360",
    "prompt": "Write a function to find the n\u2019th carol number.",
    "canonical_solution": "def get_carol(n): \r\n\tresult = (2**n) - 1\r\n\treturn result * result - 2",
    "test": "['assert get_carol(2) == 7', 'assert get_carol(4) == 223', 'assert get_carol(5) == 959']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/361",
    "prompt": "Write a function to remove empty lists from a given list of lists.",
    "canonical_solution": "def remove_empty(list1):\r\n  remove_empty = [x for x in list1 if x]\r\n  return remove_empty",
    "test": "[\"assert remove_empty([[], [], [], 'Red', 'Green', [1,2], 'Blue', [], []])==['Red', 'Green', [1, 2], 'Blue']\", \"assert remove_empty([[], [], [],[],[], 'Green', [1,2], 'Blue', [], []])==[ 'Green', [1, 2], 'Blue']\", \"assert remove_empty([[], [], [], 'Python',[],[], 'programming', 'language',[],[],[], [], []])==['Python', 'programming', 'language']\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/362",
    "prompt": "Write a python function to find the item with maximum occurrences in a given list.",
    "canonical_solution": "def max_occurrences(nums):\r\n    max_val = 0\r\n    result = nums[0] \r\n    for i in nums:\r\n        occu = nums.count(i)\r\n        if occu > max_val:\r\n            max_val = occu\r\n            result = i \r\n    return result",
    "test": "['assert max_occurrences([1,2,3,1,2,3,12,4,2]) ==  2', 'assert max_occurrences([1,2,6,7,0,1,0,1,0]) == 1,0', 'assert max_occurrences([1,2,3,1,2,4,1]) == 1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/363",
    "prompt": "Write a function to add the k elements to each element in the tuple.",
    "canonical_solution": "def add_K_element(test_list, K):\r\n  res = [tuple(j + K for j in sub ) for sub in test_list]\r\n  return (res) ",
    "test": "['assert add_K_element([(1, 3, 4), (2, 4, 6), (3, 8, 1)], 4) == [(5, 7, 8), (6, 8, 10), (7, 12, 5)]', 'assert add_K_element([(1, 2, 3), (4, 5, 6), (7, 8, 9)], 8) == [(9, 10, 11), (12, 13, 14), (15, 16, 17)]', 'assert add_K_element([(11, 12, 13), (14, 15, 16), (17, 18, 19)], 9) == [(20, 21, 22), (23, 24, 25), (26, 27, 28)]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/364",
    "prompt": "Write a function to find the number of flips required to make the given binary string a sequence of alternate characters.",
    "canonical_solution": "def make_flip(ch): \r\n\treturn '1' if (ch == '0') else '0'\r\ndef get_flip_with_starting_charcter(str, expected): \r\n\tflip_count = 0\r\n\tfor i in range(len( str)): \r\n\t\tif (str[i] != expected): \r\n\t\t\tflip_count += 1\r\n\t\texpected = make_flip(expected) \r\n\treturn flip_count \r\ndef min_flip_to_make_string_alternate(str): \r\n\treturn min(get_flip_with_starting_charcter(str, '0'),get_flip_with_starting_charcter(str, '1')) ",
    "test": "['assert min_flip_to_make_string_alternate(\"0001010111\") == 2', 'assert min_flip_to_make_string_alternate(\"001\") == 1', 'assert min_flip_to_make_string_alternate(\"010111011\") == 2 ']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/365",
    "prompt": "Write a python function to count the number of digits of a given number.",
    "canonical_solution": "def count_Digit(n):\r\n    count = 0\r\n    while n != 0:\r\n        n //= 10\r\n        count += 1\r\n    return count",
    "test": "['assert count_Digit(12345) == 5', 'assert count_Digit(11223305) == 8', 'assert count_Digit(4123459) == 7']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/366",
    "prompt": "Write a python function to find the largest product of the pair of adjacent elements from a given list of integers.",
    "canonical_solution": "def adjacent_num_product(list_nums):\r\n    return max(a*b for a, b in zip(list_nums, list_nums[1:]))",
    "test": "['assert adjacent_num_product([1,2,3,4,5,6]) == 30', 'assert adjacent_num_product([1,2,3,4,5]) == 20', 'assert adjacent_num_product([2,3]) == 6']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/367",
    "prompt": "Write a function to check if a binary tree is balanced or not.",
    "canonical_solution": "class Node: \r\n\tdef __init__(self, data): \r\n\t\tself.data = data \r\n\t\tself.left = None\r\n\t\tself.right = None\r\ndef get_height(root): \r\n\tif root is None: \r\n\t\treturn 0\r\n\treturn max(get_height(root.left), get_height(root.right)) + 1\r\ndef is_tree_balanced(root): \r\n\tif root is None: \r\n\t\treturn True\r\n\tlh = get_height(root.left) \r\n\trh = get_height(root.right) \r\n\tif (abs(lh - rh) <= 1) and is_tree_balanced( \r\n\troot.left) is True and is_tree_balanced( root.right) is True: \r\n\t\treturn True\r\n\treturn False",
    "test": "['assert is_tree_balanced(root) == False', 'assert is_tree_balanced(root1) == True', 'assert is_tree_balanced(root2) == False ']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/368",
    "prompt": "Write a function to repeat the given tuple n times.",
    "canonical_solution": "def repeat_tuples(test_tup, N):\r\n  res = ((test_tup, ) * N)\r\n  return (res) ",
    "test": "['assert repeat_tuples((1, 3), 4) == ((1, 3), (1, 3), (1, 3), (1, 3))', 'assert repeat_tuples((1, 2), 3) == ((1, 2), (1, 2), (1, 2))', 'assert repeat_tuples((3, 4), 5) == ((3, 4), (3, 4), (3, 4), (3, 4), (3, 4))']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/369",
    "prompt": "Write a function to find the lateral surface area of cuboid",
    "canonical_solution": "def lateralsurface_cuboid(l,w,h):\r\n  LSA = 2*h*(l+w)\r\n  return LSA",
    "test": "['assert lateralsurface_cuboid(8,5,6)==156', 'assert lateralsurface_cuboid(7,9,10)==320', 'assert lateralsurface_cuboid(10,20,30)==1800']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/37",
    "prompt": "Write a function to sort a given mixed list of integers and strings.",
    "canonical_solution": "def sort_mixed_list(mixed_list):\r\n    int_part = sorted([i for i in mixed_list if type(i) is int])\r\n    str_part = sorted([i for i in mixed_list if type(i) is str])\r\n    return int_part + str_part",
    "test": "[\"assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']\", \"assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']\", \"assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/370",
    "prompt": "Write a function to sort a tuple by its float element.",
    "canonical_solution": "def float_sort(price):\r\n  float_sort=sorted(price, key=lambda x: float(x[1]), reverse=True)\r\n  return float_sort",
    "test": "[\"assert float_sort([('item1', '12.20'), ('item2', '15.10'), ('item3', '24.5')])==[('item3', '24.5'), ('item2', '15.10'), ('item1', '12.20')] \", \"assert float_sort([('item1', '15'), ('item2', '10'), ('item3', '20')])==[('item3', '20'), ('item1', '15'), ('item2', '10')] \", \"assert float_sort([('item1', '5'), ('item2', '10'), ('item3', '14')])==[('item3', '14'), ('item2', '10'), ('item1', '5')] \"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/371",
    "prompt": "Write a function to find the smallest missing element in a sorted array.",
    "canonical_solution": "def smallest_missing(A, left_element, right_element):\r\n    if left_element > right_element:\r\n        return left_element\r\n    mid = left_element + (right_element - left_element) // 2\r\n    if A[mid] == mid:\r\n        return smallest_missing(A, mid + 1, right_element)\r\n    else:\r\n        return smallest_missing(A, left_element, mid - 1)",
    "test": "['assert smallest_missing([0, 1, 2, 3, 4, 5, 6], 0, 6) == 7', 'assert smallest_missing([0, 1, 2, 6, 9, 11, 15], 0, 6) == 3', 'assert smallest_missing([1, 2, 3, 4, 6, 9, 11, 15], 0, 7) == 0']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/372",
    "prompt": "Write a function to sort a given list of elements in ascending order using heap queue algorithm.",
    "canonical_solution": "import heapq as hq\r\ndef heap_assending(nums):\r\n  hq.heapify(nums)\r\n  s_result = [hq.heappop(nums) for i in range(len(nums))]\r\n  return s_result",
    "test": "['assert heap_assending([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1])==[1, 2, 3, 4, 7, 8, 9, 9, 10, 14, 18]', 'assert heap_assending([25, 35, 22, 85, 14, 65, 75, 25, 58])==[14, 22, 25, 25, 35, 58, 65, 75, 85]', 'assert heap_assending([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/373",
    "prompt": "Write a function to find the volume of a cuboid.",
    "canonical_solution": "def volume_cuboid(l,w,h):\r\n  volume=l*w*h\r\n  return volume",
    "test": "['assert volume_cuboid(1,2,3)==6', 'assert volume_cuboid(5,7,9)==315', 'assert volume_cuboid(10,15,21)==3150']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/374",
    "prompt": "Write a function to print all permutations of a given string including duplicates.",
    "canonical_solution": "def permute_string(str):\r\n    if len(str) == 0:\r\n        return ['']\r\n    prev_list = permute_string(str[1:len(str)])\r\n    next_list = []\r\n    for i in range(0,len(prev_list)):\r\n        for j in range(0,len(str)):\r\n            new_str = prev_list[i][0:j]+str[0]+prev_list[i][j:len(str)-1]\r\n            if new_str not in next_list:\r\n                next_list.append(new_str)\r\n    return next_list",
    "test": "[\"assert permute_string('ab')==['ab', 'ba']\", \"assert permute_string('abc')==['abc', 'bac', 'bca', 'acb', 'cab', 'cba']\", \"assert permute_string('abcd')==['abcd', 'bacd', 'bcad', 'bcda', 'acbd', 'cabd', 'cbad', 'cbda', 'acdb', 'cadb', 'cdab', 'cdba', 'abdc', 'badc', 'bdac', 'bdca', 'adbc', 'dabc', 'dbac', 'dbca', 'adcb', 'dacb', 'dcab', 'dcba']\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/375",
    "prompt": "Write a function to round the given number to the nearest multiple of a specific number.",
    "canonical_solution": "def round_num(n,m):\r\n    a = (n //m) * m\r\n    b = a + m\r\n    return (b if n - a > b - n else a)",
    "test": "['assert round_num(4722,10)==4720', 'assert round_num(1111,5)==1110', 'assert round_num(219,2)==218']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/376",
    "prompt": "Write a function to remove tuple elements that occur more than once and replace the duplicates with some custom value.",
    "canonical_solution": "def remove_replica(test_tup):\r\n  temp = set()\r\n  res = tuple(ele if ele not in temp and not temp.add(ele) \r\n\t\t\t\telse 'MSP' for ele in test_tup)\r\n  return (res)",
    "test": "[\"assert remove_replica((1, 1, 4, 4, 4, 5, 5, 6, 7, 7)) == (1, 'MSP', 4, 'MSP', 'MSP', 5, 'MSP', 6, 7, 'MSP')\", \"assert remove_replica((2, 3, 4, 4, 5, 6, 6, 7, 8, 9, 9)) == (2, 3, 4, 'MSP', 5, 6, 'MSP', 7, 8, 9, 'MSP')\", \"assert remove_replica((2, 2, 5, 4, 5, 7, 5, 6, 7, 7)) == (2, 'MSP', 5, 4, 'MSP', 7, 'MSP', 6, 'MSP', 'MSP')\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/377",
    "prompt": "Write a python function to remove all occurrences of a character in a given string.",
    "canonical_solution": "def remove_Char(s,c) :  \r\n    counts = s.count(c) \r\n    s = list(s) \r\n    while counts :  \r\n        s.remove(c) \r\n        counts -= 1 \r\n    s = '' . join(s)   \r\n    return (s) ",
    "test": "['assert remove_Char(\"aba\",\\'a\\') == \"b\"', 'assert remove_Char(\"toggle\",\\'g\\') == \"tole\"', 'assert remove_Char(\"aabbc\",\\'b\\') == \"aac\"']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/378",
    "prompt": "Write a python function to shift last element to first position in the given list.",
    "canonical_solution": "def move_first(test_list):\r\n  test_list = test_list[-1:] + test_list[:-1]  \r\n  return test_list",
    "test": "['assert move_first([1,2,3,4]) == [4,1,2,3]', 'assert move_first([0,1,2,3]) == [3,0,1,2]', 'assert move_first([9,8,7,1]) == [1,9,8,7]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/379",
    "prompt": "Write a function to find the surface area of a cuboid.",
    "canonical_solution": "def surfacearea_cuboid(l,w,h):\r\n  SA = 2*(l*w + l * h + w * h)\r\n  return SA",
    "test": "['assert surfacearea_cuboid(1,2,3)==22', 'assert surfacearea_cuboid(5,7,9)==286', 'assert surfacearea_cuboid(10,15,21)==1350']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/38",
    "prompt": "Write a function to find the division of first even and odd number of a given list.",
    "canonical_solution": "def div_even_odd(list1):\r\n    first_even = next((el for el in list1 if el%2==0),-1)\r\n    first_odd = next((el for el in list1 if el%2!=0),-1)\r\n    return (first_even/first_odd)",
    "test": "['assert div_even_odd([1,3,5,7,4,1,6,8])==4', 'assert div_even_odd([1,2,3,4,5,6,7,8,9,10])==2', 'assert div_even_odd([1,5,7,9,10])==10']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/380",
    "prompt": "Write a function to generate a two-dimensional array.",
    "canonical_solution": "def multi_list(rownum,colnum):\r\n  multi_list = [[0 for col in range(colnum)] for row in range(rownum)]\r\n  for row in range(rownum):\r\n    for col in range(colnum):\r\n        multi_list[row][col]= row*col\r\n  return multi_list\r\n",
    "test": "['assert multi_list(3,4)==[[0, 0, 0, 0], [0, 1, 2, 3], [0, 2, 4, 6]] ', 'assert multi_list(5,7)==[[0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 3, 4, 5, 6], [0, 2, 4, 6, 8, 10, 12], [0, 3, 6, 9, 12, 15, 18], [0, 4, 8, 12, 16, 20, 24]]', 'assert multi_list(10,15)==[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28], [0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42], [0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56], [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70], [0, 6, 12, 18, 24, 30, 36, 42, 48, 54, 60, 66, 72, 78, 84], [0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 70, 77, 84, 91, 98], [0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112], [0, 9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99, 108, 117, 126]]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/381",
    "prompt": "Write a function to sort a list of lists by a given index of the inner list.",
    "canonical_solution": "from operator import itemgetter\r\ndef index_on_inner_list(list_data, index_no):\r\n    result = sorted(list_data, key=itemgetter(index_no))\r\n    return result",
    "test": "[\"assert index_on_inner_list([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,0)==[('Beau Turnbull', 94, 98), ('Brady Kent', 97, 96), ('Greyson Fulton', 98, 99), ('Wyatt Knott', 91, 94)]\", \"assert index_on_inner_list([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,1)==[('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98), ('Brady Kent', 97, 96), ('Greyson Fulton', 98, 99)]\", \"assert index_on_inner_list([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,2)==[('Wyatt Knott', 91, 94), ('Brady Kent', 97, 96), ('Beau Turnbull', 94, 98), ('Greyson Fulton', 98, 99)]\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/382",
    "prompt": "Write a function to find the number of rotations in a circularly sorted array.",
    "canonical_solution": "def find_rotation_count(A):\r\n    (left, right) = (0, len(A) - 1)\r\n    while left <= right:\r\n        if A[left] <= A[right]:\r\n            return left\r\n        mid = (left + right) // 2\r\n        next = (mid + 1) % len(A)\r\n        prev = (mid - 1 + len(A)) % len(A)\r\n        if A[mid] <= A[next] and A[mid] <= A[prev]:\r\n            return mid\r\n        elif A[mid] <= A[right]:\r\n            right = mid - 1\r\n        elif A[mid] >= A[left]:\r\n            left = mid + 1\r\n    return -1",
    "test": "['assert find_rotation_count([8, 9, 10, 1, 2, 3, 4, 5, 6, 7]) == 3', 'assert find_rotation_count([8, 9, 10,2, 5, 6]) == 3', 'assert find_rotation_count([2, 5, 6, 8, 9, 10]) == 0']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/383",
    "prompt": "Write a python function to toggle all odd bits of a given number.",
    "canonical_solution": "def even_bit_toggle_number(n) : \r\n    res = 0; count = 0; temp = n    \r\n    while(temp > 0 ) : \r\n        if (count % 2 == 0) : \r\n            res = res | (1 << count)      \r\n        count = count + 1\r\n        temp >>= 1 \r\n    return n ^ res ",
    "test": "['assert even_bit_toggle_number(10) == 15', 'assert even_bit_toggle_number(20) == 1', 'assert even_bit_toggle_number(30) == 11']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/384",
    "prompt": "Write a python function to find the frequency of the smallest value in a given array.",
    "canonical_solution": "def frequency_Of_Smallest(n,arr): \r\n    mn = arr[0] \r\n    freq = 1\r\n    for i in range(1,n): \r\n        if (arr[i] < mn): \r\n            mn = arr[i] \r\n            freq = 1\r\n        elif (arr[i] == mn): \r\n            freq += 1\r\n    return freq ",
    "test": "['assert frequency_Of_Smallest(5,[1,2,3,4,3]) == 1', 'assert frequency_Of_Smallest(7,[3,1,2,5,6,2,3]) == 1', 'assert frequency_Of_Smallest(7,[3,3,6,3,7,4,9]) == 3']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/385",
    "prompt": "Write a function to find the n'th perrin number using recursion.",
    "canonical_solution": "def get_perrin(n):\r\n  if (n == 0):\r\n    return 3\r\n  if (n == 1):\r\n    return 0\r\n  if (n == 2):\r\n    return 2 \r\n  return get_perrin(n - 2) + get_perrin(n - 3)",
    "test": "['assert get_perrin(9) == 12', 'assert get_perrin(4) == 2', 'assert get_perrin(6) == 5']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/386",
    "prompt": "Write a function to find out the minimum no of swaps required for bracket balancing in the given string.",
    "canonical_solution": "def swap_count(s):\r\n\tchars = s\r\n\tcount_left = 0\r\n\tcount_right = 0\r\n\tswap = 0\r\n\timbalance = 0; \r\n\tfor i in range(len(chars)):\r\n\t\tif chars[i] == '[':\r\n\t\t\tcount_left += 1\r\n\t\t\tif imbalance > 0:\r\n\t\t\t\tswap += imbalance\r\n\t\t\t\timbalance -= 1\r\n\t\telif chars[i] == ']':\r\n\t\t\tcount_right += 1\r\n\t\t\timbalance = (count_right - count_left) \r\n\treturn swap",
    "test": "['assert swap_count(\"[]][][\") == 2', 'assert swap_count(\"[[][]]\") == 0', 'assert swap_count(\"[[][]]][\") == 1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/387",
    "prompt": "Write a python function to check whether the hexadecimal number is even or odd.",
    "canonical_solution": "def even_or_odd(N): \r\n    l = len(N) \r\n    if (N[l-1] =='0'or N[l-1] =='2'or \r\n        N[l-1] =='4'or N[l-1] =='6'or \r\n        N[l-1] =='8'or N[l-1] =='A'or \r\n        N[l-1] =='C'or N[l-1] =='E'): \r\n        return (\"Even\") \r\n    else: \r\n        return (\"Odd\") ",
    "test": "['assert even_or_odd(\"AB3454D\") ==\"Odd\"', 'assert even_or_odd(\"ABC\") == \"Even\"', 'assert even_or_odd(\"AAD\") == \"Odd\"']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/388",
    "prompt": "Write a python function to find the highest power of 2 that is less than or equal to n.",
    "canonical_solution": "def highest_Power_of_2(n): \r\n    res = 0; \r\n    for i in range(n, 0, -1): \r\n        if ((i & (i - 1)) == 0): \r\n            res = i; \r\n            break; \r\n    return res; ",
    "test": "['assert highest_Power_of_2(10) == 8', 'assert highest_Power_of_2(19) == 16', 'assert highest_Power_of_2(32) == 32']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/389",
    "prompt": "Write a function to find the n'th lucas number.",
    "canonical_solution": "def find_lucas(n): \r\n\tif (n == 0): \r\n\t\treturn 2\r\n\tif (n == 1): \r\n\t\treturn 1\r\n\treturn find_lucas(n - 1) + find_lucas(n - 2) ",
    "test": "['assert find_lucas(9) == 76', 'assert find_lucas(4) == 7', 'assert find_lucas(3) == 4']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/39",
    "prompt": "Write a function to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.",
    "canonical_solution": "import heapq\r\nfrom collections import Counter\r\ndef rearange_string(S):\r\n    ctr = Counter(S)\r\n    heap = [(-value, key) for key, value in ctr.items()]\r\n    heapq.heapify(heap)\r\n    if (-heap[0][0]) * 2 > len(S) + 1: \r\n        return \"\"\r\n    ans = []\r\n    while len(heap) >= 2:\r\n        nct1, char1 = heapq.heappop(heap)\r\n        nct2, char2 = heapq.heappop(heap)\r\n        ans.extend([char1, char2])\r\n        if nct1 + 1: heapq.heappush(heap, (nct1 + 1, char1))\r\n        if nct2 + 1: heapq.heappush(heap, (nct2 + 1, char2))\r\n    return \"\".join(ans) + (heap[0][1] if heap else \"\")",
    "test": "['assert rearange_string(\"aab\")==(\\'aba\\')', 'assert rearange_string(\"aabb\")==(\\'abab\\')', 'assert rearange_string(\"abccdd\")==(\\'cdabcd\\')']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/390",
    "prompt": "Write a function to insert a given string at the beginning of all items in a list.",
    "canonical_solution": "def add_string(list,string):\r\n add_string=[string.format(i) for i in  list]\r\n return add_string",
    "test": "[\"assert add_string([1,2,3,4],'temp{0}')==['temp1', 'temp2', 'temp3', 'temp4']\", \"assert add_string(['a','b','c','d'], 'python{0}')==[ 'pythona', 'pythonb', 'pythonc', 'pythond']\", \"assert add_string([5,6,7,8],'string{0}')==['string5', 'string6', 'string7', 'string8']\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/391",
    "prompt": "Write a function to convert more than one list to nested dictionary.",
    "canonical_solution": "def convert_list_dictionary(l1, l2, l3):\r\n     result = [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]\r\n     return result",
    "test": "['assert convert_list_dictionary([\"S001\", \"S002\", \"S003\", \"S004\"],[\"Adina Park\", \"Leyton Marsh\", \"Duncan Boyle\", \"Saim Richards\"] ,[85, 98, 89, 92])==[{\\'S001\\': {\\'Adina Park\\': 85}}, {\\'S002\\': {\\'Leyton Marsh\\': 98}}, {\\'S003\\': {\\'Duncan Boyle\\': 89}}, {\\'S004\\': {\\'Saim Richards\\': 92}}]', 'assert convert_list_dictionary([\"abc\",\"def\",\"ghi\",\"jkl\"],[\"python\",\"program\",\"language\",\"programs\"],[100,200,300,400])==[{\\'abc\\':{\\'python\\':100}},{\\'def\\':{\\'program\\':200}},{\\'ghi\\':{\\'language\\':300}},{\\'jkl\\':{\\'programs\\':400}}]', 'assert convert_list_dictionary([\"A1\",\"A2\",\"A3\",\"A4\"],[\"java\",\"C\",\"C++\",\"DBMS\"],[10,20,30,40])==[{\\'A1\\':{\\'java\\':10}},{\\'A2\\':{\\'C\\':20}},{\\'A3\\':{\\'C++\\':30}},{\\'A4\\':{\\'DBMS\\':40}}]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/392",
    "prompt": "Write a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).",
    "canonical_solution": "def get_max_sum (n):\r\n\tres = list()\r\n\tres.append(0)\r\n\tres.append(1)\r\n\ti = 2\r\n\twhile i<n + 1:\r\n\t\tres.append(max(i, (res[int(i / 2)] \r\n\t\t\t\t\t\t+ res[int(i / 3)] +\r\n\t\t\t\t\t\t\tres[int(i / 4)]\r\n\t\t\t\t\t\t+ res[int(i / 5)])))\r\n\t\ti = i + 1\r\n\treturn res[n]",
    "test": "['assert get_max_sum(60) == 106', 'assert get_max_sum(10) == 12', 'assert get_max_sum(2) == 2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/393",
    "prompt": "Write a function to find the list with maximum length using lambda function.",
    "canonical_solution": "def max_length_list(input_list):\r\n    max_length = max(len(x) for x in input_list )   \r\n    max_list = max(input_list, key = lambda i: len(i))    \r\n    return(max_length, max_list)",
    "test": "['assert max_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])', 'assert max_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])==(5,[1,2,3,4,5])', 'assert max_length_list([[3,4,5],[6,7,8,9],[10,11,12]])==(4,[6,7,8,9])']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/394",
    "prompt": "Write a function to check if given tuple is distinct or not.",
    "canonical_solution": "def check_distinct(test_tup):\r\n  res = True\r\n  temp = set()\r\n  for ele in test_tup:\r\n    if ele in temp:\r\n      res = False\r\n      break\r\n    temp.add(ele)\r\n  return (res) ",
    "test": "['assert check_distinct((1, 4, 5, 6, 1, 4)) == False', 'assert check_distinct((1, 4, 5, 6)) == True', 'assert check_distinct((2, 3, 4, 5, 6)) == True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/395",
    "prompt": "Write a python function to find the first non-repeated character in a given string.",
    "canonical_solution": "def first_non_repeating_character(str1):\r\n  char_order = []\r\n  ctr = {}\r\n  for c in str1:\r\n    if c in ctr:\r\n      ctr[c] += 1\r\n    else:\r\n      ctr[c] = 1 \r\n      char_order.append(c)\r\n  for c in char_order:\r\n    if ctr[c] == 1:\r\n      return c\r\n  return None",
    "test": "['assert first_non_repeating_character(\"abcabc\") == None', 'assert first_non_repeating_character(\"abc\") == \"a\"', 'assert first_non_repeating_character(\"ababc\") == \"c\"']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/396",
    "prompt": "Write a function to check whether the given string starts and ends with the same character or not using regex.",
    "canonical_solution": "import re  \r\nregex = r'^[a-z]$|^([a-z]).*\\1$'\r\ndef check_char(string): \r\n\tif(re.search(regex, string)): \r\n\t\treturn \"Valid\" \r\n\telse: \r\n\t\treturn \"Invalid\" ",
    "test": "['assert check_char(\"abba\") == \"Valid\"', 'assert check_char(\"a\") == \"Valid\"', 'assert check_char(\"abcd\") == \"Invalid\"']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/397",
    "prompt": "Write a function to find the median of three specific numbers.",
    "canonical_solution": "def median_numbers(a,b,c):\r\n if a > b:\r\n    if a < c:\r\n        median = a\r\n    elif b > c:\r\n        median = b\r\n    else:\r\n        median = c\r\n else:\r\n    if a > c:\r\n        median = a\r\n    elif b < c:\r\n        median = b\r\n    else:\r\n        median = c\r\n return median",
    "test": "['assert median_numbers(25,55,65)==55.0', 'assert median_numbers(20,10,30)==20.0', 'assert median_numbers(15,45,75)==45.0']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/398",
    "prompt": "Write a function to compute the sum of digits of each number of a given list.",
    "canonical_solution": "def sum_of_digits(nums):\r\n    return sum(int(el) for n in nums for el in str(n) if el.isdigit())",
    "test": "['assert sum_of_digits([10,2,56])==14', \"assert sum_of_digits([[10,20,4,5,'b',70,'a']])==19\", 'assert sum_of_digits([10,20,-4,5,-70])==19']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/399",
    "prompt": "Write a function to perform the mathematical bitwise xor operation across the given tuples.",
    "canonical_solution": "def bitwise_xor(test_tup1, test_tup2):\r\n  res = tuple(ele1 ^ ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res) ",
    "test": "['assert bitwise_xor((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)', 'assert bitwise_xor((11, 5, 7, 10), (6, 3, 4, 4)) == (13, 6, 3, 14)', 'assert bitwise_xor((12, 6, 8, 11), (7, 4, 5, 6)) == (11, 2, 13, 13)']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/40",
    "prompt": "Write a function to find frequency of the elements in a given list of lists using collections module.",
    "canonical_solution": "from collections import Counter\r\nfrom itertools import chain\r\ndef freq_element(nums):\r\n  result = Counter(chain.from_iterable(nums))\r\n  return result",
    "test": "['assert freq_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]])==({2: 3, 1: 2, 5: 2, 3: 1, 4: 1, 6: 1, 7: 1, 9: 1})', 'assert freq_element([[1,2,3,4],[5,6,7,8],[9,10,11,12]])==({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1})', 'assert freq_element([[15,20,30,40],[80,90,100,110],[30,30,80,90]])==({30: 3, 80: 2, 90: 2, 15: 1, 20: 1, 40: 1, 100: 1, 110: 1})']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/400",
    "prompt": "Write a function to extract the frequency of unique tuples in the given list order irrespective.",
    "canonical_solution": "def extract_freq(test_list):\r\n  res = len(list(set(tuple(sorted(sub)) for sub in test_list)))\r\n  return (res)",
    "test": "['assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3', 'assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4', 'assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/401",
    "prompt": "Write a function to perform index wise addition of tuple elements in the given two nested tuples.",
    "canonical_solution": "def add_nested_tuples(test_tup1, test_tup2):\r\n  res = tuple(tuple(a + b for a, b in zip(tup1, tup2))\r\n   for tup1, tup2 in zip(test_tup1, test_tup2))\r\n  return (res) ",
    "test": "['assert add_nested_tuples(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((7, 10), (7, 14), (3, 10), (8, 13))', 'assert add_nested_tuples(((2, 4), (5, 6), (3, 10), (2, 11)), ((7, 8), (4, 10), (2, 2), (8, 4))) == ((9, 12), (9, 16), (5, 12), (10, 15))', 'assert add_nested_tuples(((3, 5), (6, 7), (4, 11), (3, 12)), ((8, 9), (5, 11), (3, 3), (9, 5))) == ((11, 14), (11, 18), (7, 14), (12, 17))']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/402",
    "prompt": "Write a function to compute the value of ncr%p.",
    "canonical_solution": "def ncr_modp(n, r, p): \r\n    C = [0 for i in range(r+1)]   \r\n    C[0] = 1\r\n    for i in range(1, n+1): \r\n        for j in range(min(i, r), 0, -1): \r\n            C[j] = (C[j] + C[j-1]) % p   \r\n    return C[r] ",
    "test": "['assert ncr_modp(10,2,13)==6', 'assert ncr_modp(15,12,43)==25', 'assert ncr_modp(17,9,18)==10']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/403",
    "prompt": "Write a function to check if a url is valid or not using regex.",
    "canonical_solution": "import re\r\ndef is_valid_URL(str):\r\n\tregex = (\"((http|https)://)(www.)?\" +\r\n\t\t\t\"[a-zA-Z0-9@:%._\\\\+~#?&//=]\" +\r\n\t\t\t\"{2,256}\\\\.[a-z]\" +\r\n\t\t\t\"{2,6}\\\\b([-a-zA-Z0-9@:%\" +\r\n\t\t\t\"._\\\\+~#?&//=]*)\")\r\n\tp = re.compile(regex)\r\n\tif (str == None):\r\n\t\treturn False\r\n\tif(re.search(p, str)):\r\n\t\treturn True\r\n\telse:\r\n\t\treturn False",
    "test": "['assert is_valid_URL(\"https://www.google.com\") == True', 'assert is_valid_URL(\"https:/www.gmail.com\") == False', 'assert is_valid_URL(\"https:// www.redit.com\") == False']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/404",
    "prompt": "Write a python function to find the minimum of two numbers.",
    "canonical_solution": "def minimum(a,b):   \r\n    if a <= b: \r\n        return a \r\n    else: \r\n        return b ",
    "test": "['assert minimum(1,2) == 1', 'assert minimum(-5,-4) == -5', 'assert minimum(0,0) == 0']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/405",
    "prompt": "Write a function to check whether an element exists within a tuple.",
    "canonical_solution": "def check_tuplex(tuplex,tuple1): \r\n  if tuple1 in tuplex:\r\n    return True\r\n  else:\r\n     return False",
    "test": "['assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"),\\'r\\')==True', 'assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"),\\'5\\')==False', 'assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\",\"e\"),3)==True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/406",
    "prompt": "Write a python function to find the parity of a given number.",
    "canonical_solution": "def find_Parity(x): \r\n    y = x ^ (x >> 1); \r\n    y = y ^ (y >> 2); \r\n    y = y ^ (y >> 4); \r\n    y = y ^ (y >> 8); \r\n    y = y ^ (y >> 16); \r\n    if (y & 1): \r\n        return (\"Odd Parity\"); \r\n    return (\"Even Parity\"); ",
    "test": "['assert find_Parity(12) == \"Even Parity\"', 'assert find_Parity(7) == \"Odd Parity\"', 'assert find_Parity(10) == \"Even Parity\"']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/407",
    "prompt": "Write a function to create the next bigger number by rearranging the digits of a given number.",
    "canonical_solution": "def rearrange_bigger(n):\r\n    nums = list(str(n))\r\n    for i in range(len(nums)-2,-1,-1):\r\n        if nums[i] < nums[i+1]:\r\n            z = nums[i:]\r\n            y = min(filter(lambda x: x > z[0], z))\r\n            z.remove(y)\r\n            z.sort()\r\n            nums[i:] = [y] + z\r\n            return int(\"\".join(nums))\r\n    return False",
    "test": "['assert rearrange_bigger(12)==21', 'assert rearrange_bigger(10)==False', 'assert rearrange_bigger(102)==120']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/408",
    "prompt": "Write a function to find k number of pairs which consist of one element from the first array and one element from the second array.",
    "canonical_solution": "import heapq\r\ndef k_smallest_pairs(nums1, nums2, k):\r\n   queue = []\r\n   def push(i, j):\r\n       if i < len(nums1) and j < len(nums2):\r\n           heapq.heappush(queue, [nums1[i] + nums2[j], i, j])\r\n   push(0, 0)\r\n   pairs = []\r\n   while queue and len(pairs) < k:\r\n       _, i, j = heapq.heappop(queue)\r\n       pairs.append([nums1[i], nums2[j]])\r\n       push(i, j + 1)\r\n       if j == 0:\r\n           push(i + 1, 0)\r\n   return pairs",
    "test": "['assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]', 'assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]', 'assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/409",
    "prompt": "Write a function to find the minimum product from the pairs of tuples within a given list.",
    "canonical_solution": "def min_product_tuple(list1):\r\n    result_min = min([abs(x * y) for x, y in list1] )\r\n    return result_min",
    "test": "['assert min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==8', 'assert min_product_tuple([(10,20), (15,2), (5,10)] )==30', 'assert min_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==100']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/41",
    "prompt": "Write a function to filter even numbers using lambda function.",
    "canonical_solution": "def filter_evennumbers(nums):\r\n even_nums = list(filter(lambda x: x%2 == 0, nums))\r\n return even_nums",
    "test": "['assert filter_evennumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[2, 4, 6, 8, 10]', 'assert filter_evennumbers([10,20,45,67,84,93])==[10,20,84]', 'assert filter_evennumbers([5,7,9,8,6,4,3])==[8,6,4]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/410",
    "prompt": "Write a function to find the minimum value in a given heterogeneous list.",
    "canonical_solution": "def min_val(listval):\r\n     min_val = min(i for i in listval if isinstance(i, int))\r\n     return min_val",
    "test": "[\"assert min_val(['Python', 3, 2, 4, 5, 'version'])==2\", \"assert min_val(['Python', 15, 20, 25])==15\", \"assert min_val(['Python', 30, 20, 40, 50, 'version'])==20\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/411",
    "prompt": "Write a function to convert the given snake case string to camel case string by using regex.",
    "canonical_solution": "import re\r\ndef snake_to_camel(word):\r\n  return ''.join(x.capitalize() or '_' for x in word.split('_'))",
    "test": "[\"assert snake_to_camel('android_tv') == 'AndroidTv'\", \"assert snake_to_camel('google_pixel') == 'GooglePixel'\", \"assert snake_to_camel('apple_watch') == 'AppleWatch'\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/412",
    "prompt": "Write a python function to remove odd numbers from a given list.",
    "canonical_solution": "def remove_odd(l):\r\n    for i in l:\r\n        if i % 2 != 0:\r\n            l.remove(i)\r\n    return l",
    "test": "['assert remove_odd([1,2,3]) == [2]', 'assert remove_odd([2,4,6]) == [2,4,6]', 'assert remove_odd([10,20,3]) == [10,20]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/413",
    "prompt": "Write a function to extract the nth element from a given list of tuples.",
    "canonical_solution": "def extract_nth_element(list1, n):\r\n    result = [x[n] for x in list1]\r\n    return result",
    "test": "[\"assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,0)==['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']\", \"assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,2)==[99, 96, 94, 98]\", \"assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)],1)==[98, 97, 91, 94]\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/414",
    "prompt": "Write a python function to check whether the value exists in a sequence or not.",
    "canonical_solution": "def overlapping(list1,list2):  \r\n    c=0\r\n    d=0\r\n    for i in list1: \r\n        c+=1\r\n    for i in list2: \r\n        d+=1\r\n    for i in range(0,c): \r\n        for j in range(0,d): \r\n            if(list1[i]==list2[j]): \r\n                return 1\r\n    return 0",
    "test": "['assert overlapping([1,2,3,4,5],[6,7,8,9]) == False', 'assert overlapping([1,2,3],[4,5,6]) == False', 'assert overlapping([1,4,5],[1,4,5]) == True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/415",
    "prompt": "Write a python function to find a pair with highest product from a given array of integers.",
    "canonical_solution": "def max_Product(arr): \r\n    arr_len = len(arr) \r\n    if (arr_len < 2): \r\n        return (\"No pairs exists\")           \r\n    x = arr[0]; y = arr[1]      \r\n    for i in range(0,arr_len): \r\n        for j in range(i + 1,arr_len): \r\n            if (arr[i] * arr[j] > x * y): \r\n                x = arr[i]; y = arr[j] \r\n    return x,y    ",
    "test": "['assert max_Product([1,2,3,4,7,0,8,4]) == (7,8)', 'assert max_Product([0,-1,-2,-4,5,0,-6]) == (-4,-6)', 'assert max_Product([1,2,3]) == (2,3)']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/416",
    "prompt": "Write a function to find the maximum sum we can make by dividing number in three parts recursively and summing them up together for the given number.",
    "canonical_solution": "MAX = 1000000\r\ndef breakSum(n): \r\n\tdp = [0]*(n+1) \r\n\tdp[0] = 0\r\n\tdp[1] = 1\r\n\tfor i in range(2, n+1): \r\n\t\tdp[i] = max(dp[int(i/2)] + dp[int(i/3)] + dp[int(i/4)], i); \r\n\treturn dp[n]",
    "test": "['assert breakSum(12) == 13', 'assert breakSum(24) == 27', 'assert breakSum(23) == 23']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/417",
    "prompt": "Write a function to find common first element in given list of tuple.",
    "canonical_solution": "def group_tuples(Input): \r\n\tout = {} \r\n\tfor elem in Input: \r\n\t\ttry: \r\n\t\t\tout[elem[0]].extend(elem[1:]) \r\n\t\texcept KeyError: \r\n\t\t\tout[elem[0]] = list(elem) \r\n\treturn [tuple(values) for values in out.values()] ",
    "test": "[\"assert group_tuples([('x', 'y'), ('x', 'z'), ('w', 't')]) == [('x', 'y', 'z'), ('w', 't')]\", \"assert group_tuples([('a', 'b'), ('a', 'c'), ('d', 'e')]) == [('a', 'b', 'c'), ('d', 'e')]\", \"assert group_tuples([('f', 'g'), ('f', 'g'), ('h', 'i')]) == [('f', 'g', 'g'), ('h', 'i')]\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/418",
    "prompt": "Write a python function to find the sublist having maximum length.",
    "canonical_solution": "def Find_Max(lst): \r\n    maxList = max((x) for x in lst) \r\n    return maxList",
    "test": "[\"assert Find_Max([['A'],['A','B'],['A','B','C']]) == ['A','B','C']\", 'assert Find_Max([[1],[1,2],[1,2,3]]) == [1,2,3]', 'assert Find_Max([[1,1],[1,2,3],[1,5,6,1]]) == [1,5,6,1]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/419",
    "prompt": "Write a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.",
    "canonical_solution": "def round_and_sum(list1):\r\n  lenght=len(list1)\r\n  round_and_sum=sum(list(map(round,list1))* lenght)\r\n  return round_and_sum",
    "test": "['assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243', 'assert round_and_sum([5,2,9,24.3,29])==345', 'assert round_and_sum([25.0,56.7,89.2])==513']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/42",
    "prompt": "Write a python function to find the sum of repeated elements in a given array.",
    "canonical_solution": "def find_Sum(arr,n): \r\n    return sum([x for x in arr if arr.count(x) > 1])",
    "test": "['assert find_Sum([1,2,3,1,1,4,5,6],8) == 3', 'assert find_Sum([1,2,3,1,1],5) == 3', 'assert find_Sum([1,1,2],3) == 2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/420",
    "prompt": "Write a python function to find the cube sum of first n even natural numbers.",
    "canonical_solution": "def cube_Sum(n): \r\n    sum = 0\r\n    for i in range(1,n + 1): \r\n        sum += (2*i)*(2*i)*(2*i) \r\n    return sum",
    "test": "['assert cube_Sum(2) == 72', 'assert cube_Sum(3) == 288', 'assert cube_Sum(4) == 800']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/421",
    "prompt": "Write a function to concatenate each element of tuple by the delimiter.",
    "canonical_solution": "def concatenate_tuple(test_tup):\r\n    delim = \"-\"\r\n    res = ''.join([str(ele) + delim for ele in test_tup])\r\n    res = res[ : len(res) - len(delim)]\r\n    return (str(res)) ",
    "test": "['assert concatenate_tuple((\"ID\", \"is\", 4, \"UTS\") ) == \\'ID-is-4-UTS\\'', 'assert concatenate_tuple((\"QWE\", \"is\", 4, \"RTY\") ) == \\'QWE-is-4-RTY\\'', 'assert concatenate_tuple((\"ZEN\", \"is\", 4, \"OP\") ) == \\'ZEN-is-4-OP\\'']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/422",
    "prompt": "Write a python function to find the average of cubes of first n natural numbers.",
    "canonical_solution": "def find_Average_Of_Cube(n):  \r\n    sum = 0\r\n    for i in range(1, n + 1): \r\n        sum += i * i * i  \r\n    return round(sum / n, 6) ",
    "test": "['assert find_Average_Of_Cube(2) == 4.5', 'assert find_Average_Of_Cube(3) == 12', 'assert find_Average_Of_Cube(1) == 1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/423",
    "prompt": "Write a function to solve gold mine problem.",
    "canonical_solution": "def get_maxgold(gold, m, n): \r\n    goldTable = [[0 for i in range(n)] \r\n                        for j in range(m)]   \r\n    for col in range(n-1, -1, -1): \r\n        for row in range(m):  \r\n            if (col == n-1): \r\n                right = 0\r\n            else: \r\n                right = goldTable[row][col+1] \r\n            if (row == 0 or col == n-1): \r\n                right_up = 0\r\n            else: \r\n                right_up = goldTable[row-1][col+1] \r\n            if (row == m-1 or col == n-1): \r\n                right_down = 0\r\n            else: \r\n                right_down = goldTable[row+1][col+1] \r\n            goldTable[row][col] = gold[row][col] + max(right, right_up, right_down) \r\n    res = goldTable[0][0] \r\n    for i in range(1, m): \r\n        res = max(res, goldTable[i][0])  \r\n    return res ",
    "test": "['assert get_maxgold([[1, 3, 1, 5],[2, 2, 4, 1],[5, 0, 2, 3],[0, 6, 1, 2]],4,4)==16', 'assert get_maxgold([[10,20],[30,40]],2,2)==70', 'assert get_maxgold([[4,9],[3,7]],2,2)==13']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/424",
    "prompt": "Write a function to extract only the rear index element of each string in the given tuple.",
    "canonical_solution": "def extract_rear(test_tuple):\r\n  res = list(sub[len(sub) - 1] for sub in test_tuple)\r\n  return (res) ",
    "test": "[\"assert extract_rear(('Mers', 'for', 'Vers') ) == ['s', 'r', 's']\", \"assert extract_rear(('Avenge', 'for', 'People') ) == ['e', 'r', 'e']\", \"assert extract_rear(('Gotta', 'get', 'go') ) == ['a', 't', 'o']\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/425",
    "prompt": "Write a function to count the number of sublists containing a particular element.",
    "canonical_solution": "def count_element_in_list(list1, x): \r\n    ctr = 0\r\n    for i in range(len(list1)): \r\n        if x in list1[i]: \r\n            ctr+= 1          \r\n    return ctr",
    "test": "['assert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]],1)==3', \"assert count_element_in_list([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']],'A')==3\", \"assert count_element_in_list([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']],'E')==1\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/426",
    "prompt": "Write a function to filter odd numbers using lambda function.",
    "canonical_solution": "def filter_oddnumbers(nums):\r\n odd_nums = list(filter(lambda x: x%2 != 0, nums))\r\n return odd_nums",
    "test": "['assert filter_oddnumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1,3,5,7,9]', 'assert filter_oddnumbers([10,20,45,67,84,93])==[45,67,93]', 'assert filter_oddnumbers([5,7,9,8,6,4,3])==[5,7,9,3]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/427",
    "prompt": "Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format by using regex.",
    "canonical_solution": "import re\r\ndef change_date_format(dt):\r\n        return re.sub(r'(\\d{4})-(\\d{1,2})-(\\d{1,2})', '\\\\3-\\\\2-\\\\1', dt)",
    "test": "['assert change_date_format(\"2026-01-02\") == \\'02-01-2026\\'', 'assert change_date_format(\"2020-11-13\") == \\'13-11-2020\\'', 'assert change_date_format(\"2021-04-26\") == \\'26-04-2021\\'']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/428",
    "prompt": "Write a function to sort the given array by using shell sort.",
    "canonical_solution": "def shell_sort(my_list):\r\n    gap = len(my_list) // 2\r\n    while gap > 0:\r\n        for i in range(gap, len(my_list)):\r\n            current_item = my_list[i]\r\n            j = i\r\n            while j >= gap and my_list[j - gap] > current_item:\r\n                my_list[j] = my_list[j - gap]\r\n                j -= gap\r\n            my_list[j] = current_item\r\n        gap //= 2\r\n\r\n    return my_list",
    "test": "['assert shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]', 'assert shell_sort([24, 22, 39, 34, 87, 73, 68]) == [22, 24, 34, 39, 68, 73, 87]', 'assert shell_sort([32, 30, 16, 96, 82, 83, 74]) == [16, 30, 32, 74, 82, 83, 96]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/429",
    "prompt": "Write a function to extract the elementwise and tuples from the given two tuples.",
    "canonical_solution": "def and_tuples(test_tup1, test_tup2):\r\n  res = tuple(ele1 & ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res) ",
    "test": "['assert and_tuples((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)', 'assert and_tuples((1, 2, 3, 4), (5, 6, 7, 8)) == (1, 2, 3, 0)', 'assert and_tuples((8, 9, 11, 12), (7, 13, 14, 17)) == (0, 9, 10, 0)']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/43",
    "prompt": "Write a function to find sequences of lowercase letters joined with an underscore using regex.",
    "canonical_solution": "import re\r\ndef text_match(text):\r\n  patterns = '^[a-z]+_[a-z]+$'\r\n  if re.search(patterns,  text):\r\n    return ('Found a match!')\r\n  else:\r\n    return ('Not matched!')",
    "test": "['assert text_match(\"aab_cbbbc\") == \\'Found a match!\\'', 'assert text_match(\"aab_Abbbc\") == \\'Not matched!\\'', 'assert text_match(\"Aaab_abbbc\") == \\'Not matched!\\'']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/430",
    "prompt": "Write a function to find the directrix of a parabola.",
    "canonical_solution": "def parabola_directrix(a, b, c): \r\n  directrix=((int)(c - ((b * b) + 1) * 4 * a ))\r\n  return directrix",
    "test": "['assert parabola_directrix(5,3,2)==-198', 'assert parabola_directrix(9,8,4)==-2336', 'assert parabola_directrix(2,4,6)==-130']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/431",
    "prompt": "Write a function that takes two lists and returns true if they have at least one common element.",
    "canonical_solution": "def common_element(list1, list2):\r\n     result = False\r\n     for x in list1:\r\n         for y in list2:\r\n             if x == y:\r\n                 result = True\r\n                 return result",
    "test": "['assert common_element([1,2,3,4,5], [5,6,7,8,9])==True', 'assert common_element([1,2,3,4,5], [6,7,8,9])==None', \"assert common_element(['a','b','c'], ['d','b','e'])==True\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/432",
    "prompt": "Write a function to find the median of a trapezium.",
    "canonical_solution": "def median_trapezium(base1,base2,height):\r\n median = 0.5 * (base1+ base2)\r\n return median",
    "test": "['assert median_trapezium(15,25,35)==20', 'assert median_trapezium(10,20,30)==15', 'assert median_trapezium(6,9,4)==7.5']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/433",
    "prompt": "Write a function to check whether the entered number is greater than the elements of the given array.",
    "canonical_solution": "def check_greater(arr, number):\r\n  arr.sort()\r\n  if number > arr[-1]:\r\n    return ('Yes, the entered number is greater than those in the array')\r\n  else:\r\n    return ('No, entered number is less than those in the array')",
    "test": "[\"assert check_greater([1, 2, 3, 4, 5], 4) == 'No, entered number is less than those in the array'\", \"assert check_greater([2, 3, 4, 5, 6], 8) == 'Yes, the entered number is greater than those in the array'\", \"assert check_greater([9, 7, 4, 8, 6, 1], 11) == 'Yes, the entered number is greater than those in the array'\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/434",
    "prompt": "Write a function that matches a string that has an a followed by one or more b's.",
    "canonical_solution": "import re\r\ndef text_match_one(text):\r\n        patterns = 'ab+?'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')\r\n",
    "test": "['assert text_match_one(\"ac\")==(\\'Not matched!\\')', 'assert text_match_one(\"dc\")==(\\'Not matched!\\')', 'assert text_match_one(\"abba\")==(\\'Found a match!\\')']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/435",
    "prompt": "Write a python function to find the last digit of a given number.",
    "canonical_solution": "def last_Digit(n) :\r\n    return (n % 10) ",
    "test": "['assert last_Digit(123) == 3', 'assert last_Digit(25) == 5', 'assert last_Digit(30) == 0']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/436",
    "prompt": "Write a python function to print negative numbers in a list.",
    "canonical_solution": "def neg_nos(list1):\r\n  for num in list1: \r\n    if num < 0: \r\n       return num ",
    "test": "['assert neg_nos([-1,4,5,-6]) == -1,-6', 'assert neg_nos([-1,-2,3,4]) == -1,-2', 'assert neg_nos([-7,-6,8,9]) == -7,-6']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/437",
    "prompt": "Write a function to remove odd characters in a string.",
    "canonical_solution": "def remove_odd(str1):\r\n str2 = ''\r\n for i in range(1, len(str1) + 1):\r\n    if(i % 2 == 0):\r\n        str2 = str2 + str1[i - 1]\r\n return str2",
    "test": "['assert remove_odd(\"python\")==(\"yhn\")', 'assert remove_odd(\"program\")==(\"rga\")', 'assert remove_odd(\"language\")==(\"agae\")']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/438",
    "prompt": "Write a function to count bidirectional tuple pairs.",
    "canonical_solution": "def count_bidirectional(test_list):\r\n  res = 0\r\n  for idx in range(0, len(test_list)):\r\n    for iidx in range(idx + 1, len(test_list)):\r\n      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\r\n        res += 1\r\n  return (str(res)) ",
    "test": "[\"assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)] ) == '3'\", \"assert count_bidirectional([(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)] ) == '2'\", \"assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)] ) == '4'\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/439",
    "prompt": "Write a function to convert a list of multiple integers into a single integer.",
    "canonical_solution": "def multiple_to_single(L):\r\n  x = int(\"\".join(map(str, L)))\r\n  return x",
    "test": "['assert multiple_to_single([11, 33, 50])==113350', 'assert multiple_to_single([-1,2,3,4,5,6])==-123456', 'assert multiple_to_single([10,15,20,25])==10152025']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/44",
    "prompt": "Write a function that matches a word at the beginning of a string.",
    "canonical_solution": "import re\r\ndef text_match_string(text):\r\n        patterns = '^\\w+'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return 'Not matched!'",
    "test": "['assert text_match_string(\" python\")==(\\'Not matched!\\')', 'assert text_match_string(\"python\")==(\\'Found a match!\\')', 'assert text_match_string(\"  lang\")==(\\'Not matched!\\')']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/440",
    "prompt": "Write a function to find all adverbs and their positions in a given sentence.",
    "canonical_solution": "import re\r\ndef find_adverb_position(text):\r\n for m in re.finditer(r\"\\w+ly\", text):\r\n    return (m.start(), m.end(), m.group(0))",
    "test": "['assert find_adverb_position(\"clearly!! we can see the sky\")==(0, 7, \\'clearly\\')', 'assert find_adverb_position(\"seriously!! there are many roses\")==(0, 9, \\'seriously\\')', 'assert find_adverb_position(\"unfortunately!! sita is going to home\")==(0, 13, \\'unfortunately\\')']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/441",
    "prompt": "Write a function to find the surface area of a cube.",
    "canonical_solution": "def surfacearea_cube(l):\r\n  surfacearea= 6*l*l\r\n  return surfacearea",
    "test": "['assert surfacearea_cube(5)==150', 'assert surfacearea_cube(3)==54', 'assert surfacearea_cube(10)==600']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/442",
    "prompt": "Write a function to find the ration of positive numbers in an array of integers.",
    "canonical_solution": "from array import array\r\ndef positive_count(nums):\r\n    n = len(nums)\r\n    n1 = 0\r\n    for x in nums:\r\n        if x > 0:\r\n            n1 += 1\r\n        else:\r\n          None\r\n    return round(n1/n,2)",
    "test": "['assert positive_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])==0.54', 'assert positive_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==0.69', 'assert positive_count([2, 4, -6, -9, 11, -12, 14, -5, 17])==0.56']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/443",
    "prompt": "Write a python function to find the largest negative number from the given list.",
    "canonical_solution": "def largest_neg(list1): \r\n    max = list1[0] \r\n    for x in list1: \r\n        if x < max : \r\n             max = x  \r\n    return max",
    "test": "['assert largest_neg([1,2,3,-4,-6]) == -6', 'assert largest_neg([1,2,3,-8,-9]) == -9', 'assert largest_neg([1,2,3,4,-1]) == -1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/444",
    "prompt": "Write a function to trim each tuple by k in the given tuple list.",
    "canonical_solution": "def trim_tuple(test_list, K):\r\n  res = []\r\n  for ele in test_list:\r\n    N = len(ele)\r\n    res.append(tuple(list(ele)[K: N - K]))\r\n  return (str(res)) ",
    "test": "[\"assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1),(9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 2) == '[(2,), (9,), (2,), (2,)]'\", \"assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 1) == '[(3, 2, 1), (4, 9, 2), (1, 2, 3), (8, 2, 1)]'\", \"assert trim_tuple([(7, 8, 4, 9), (11, 8, 12, 4),(4, 1, 7, 8), (3, 6, 9, 7)], 1) == '[(8, 4), (8, 12), (1, 7), (6, 9)]'\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/445",
    "prompt": "Write a function to perform index wise multiplication of tuple elements in the given two tuples.",
    "canonical_solution": "def index_multiplication(test_tup1, test_tup2):\r\n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\r\n   for tup1, tup2 in zip(test_tup1, test_tup2))\r\n  return (res) ",
    "test": "['assert index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)),((6, 7), (3, 9), (1, 1), (7, 3)) ) == ((6, 21), (12, 45), (2, 9), (7, 30))', 'assert index_multiplication(((2, 4), (5, 6), (3, 10), (2, 11)),((7, 8), (4, 10), (2, 2), (8, 4)) ) == ((14, 32), (20, 60), (6, 20), (16, 44))', 'assert index_multiplication(((3, 5), (6, 7), (4, 11), (3, 12)),((8, 9), (5, 11), (3, 3), (9, 5)) ) == ((24, 45), (30, 77), (12, 33), (27, 60))']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/446",
    "prompt": "Write a python function to count the occurence of all elements of list in a tuple.",
    "canonical_solution": "from collections import Counter \r\ndef count_Occurrence(tup, lst): \r\n    count = 0\r\n    for item in tup: \r\n        if item in lst: \r\n            count+= 1 \r\n    return count  ",
    "test": "[\"assert count_Occurrence(('a', 'a', 'c', 'b', 'd'),['a', 'b'] ) == 3\", 'assert count_Occurrence((1, 2, 3, 1, 4, 6, 7, 1, 4),[1, 4, 7]) == 6', 'assert count_Occurrence((1,2,3,4,5,6),[1,2]) == 2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/447",
    "prompt": "Write a function to find cubes of individual elements in a list using lambda function.",
    "canonical_solution": "def cube_nums(nums):\r\n cube_nums = list(map(lambda x: x ** 3, nums))\r\n return cube_nums",
    "test": "['assert cube_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]', 'assert cube_nums([10,20,30])==([1000, 8000, 27000])', 'assert cube_nums([12,15])==([1728, 3375])']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/448",
    "prompt": "Write a function to calculate the sum of perrin numbers.",
    "canonical_solution": "def cal_sum(n): \r\n\ta = 3\r\n\tb = 0\r\n\tc = 2\r\n\tif (n == 0): \r\n\t\treturn 3\r\n\tif (n == 1): \r\n\t\treturn 3\r\n\tif (n == 2): \r\n\t\treturn 5\r\n\tsum = 5\r\n\twhile (n > 2): \r\n\t\td = a + b \r\n\t\tsum = sum + d \r\n\t\ta = b \r\n\t\tb = c \r\n\t\tc = d \r\n\t\tn = n-1\r\n\treturn sum",
    "test": "['assert cal_sum(9) == 49', 'assert cal_sum(10) == 66', 'assert cal_sum(11) == 88']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/449",
    "prompt": "Write a python function to check whether the triangle is valid or not if 3 points are given.",
    "canonical_solution": "def check_Triangle(x1,y1,x2,y2,x3,y3): \r\n    a = (x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))   \r\n    if a == 0: \r\n        return ('No') \r\n    else: \r\n        return ('Yes') ",
    "test": "[\"assert check_Triangle(1,5,2,5,4,6) == 'Yes'\", \"assert check_Triangle(1,1,1,4,1,5) == 'No'\", \"assert check_Triangle(1,1,1,1,1,1) == 'No'\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/45",
    "prompt": "Write a function to find the gcd of the given array elements.",
    "canonical_solution": "def find_gcd(x, y): \r\n\twhile(y): \r\n\t\tx, y = y, x % y \r\n\treturn x \r\ndef get_gcd(l):\r\n  num1 = l[0]\r\n  num2 = l[1]\r\n  gcd = find_gcd(num1, num2)\r\n  for i in range(2, len(l)):\r\n    gcd = find_gcd(gcd, l[i])\r\n  return gcd",
    "test": "['assert get_gcd([2, 4, 6, 8, 16]) == 2', 'assert get_gcd([1, 2, 3]) == 1', 'assert get_gcd([2, 4, 6, 8]) == 2 ']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/450",
    "prompt": "Write a function to extract specified size of strings from a give list of string values.",
    "canonical_solution": "def extract_string(str, l):\r\n    result = [e for e in str if len(e) == l] \r\n    return result",
    "test": "[\"assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,8)==['practice', 'solution']\", \"assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,6)==['Python']\", \"assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,9)==['exercises']\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/451",
    "prompt": "Write a function to remove all whitespaces from the given string using regex.",
    "canonical_solution": "import re\r\ndef remove_whitespaces(text1):\r\n  return (re.sub(r'\\s+', '',text1))",
    "test": "[\"assert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'\", \"assert remove_whitespaces(' Google    Dart ') == 'GoogleDart'\", \"assert remove_whitespaces(' iOS    Swift ') == 'iOSSwift'\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/452",
    "prompt": "Write a function that gives loss amount if the given amount has loss else return none.",
    "canonical_solution": "def loss_amount(actual_cost,sale_amount): \r\n  if(sale_amount > actual_cost):\r\n    amount = sale_amount - actual_cost\r\n    return amount\r\n  else:\r\n    return None",
    "test": "['assert loss_amount(1500,1200)==None', 'assert loss_amount(100,200)==100', 'assert loss_amount(2000,5000)==3000']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/453",
    "prompt": "Write a python function to find the sum of even factors of a number.",
    "canonical_solution": "import math \r\ndef sumofFactors(n) : \r\n    if (n % 2 != 0) : \r\n        return 0\r\n    res = 1\r\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \r\n        count = 0\r\n        curr_sum = 1\r\n        curr_term = 1\r\n        while (n % i == 0) : \r\n            count= count + 1\r\n            n = n // i \r\n            if (i == 2 and count == 1) : \r\n                curr_sum = 0\r\n            curr_term = curr_term * i \r\n            curr_sum = curr_sum + curr_term \r\n        res = res * curr_sum  \r\n    if (n >= 2) : \r\n        res = res * (1 + n) \r\n    return res ",
    "test": "['assert sumofFactors(18) == 26', 'assert sumofFactors(30) == 48', 'assert sumofFactors(6) == 8']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/454",
    "prompt": "Write a function that matches a word containing 'z'.",
    "canonical_solution": "import re\r\ndef text_match_wordz(text):\r\n        patterns = '\\w*z.\\w*'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')",
    "test": "['assert text_match_wordz(\"pythonz.\")==(\\'Found a match!\\')', 'assert text_match_wordz(\"xyz.\")==(\\'Found a match!\\')', 'assert text_match_wordz(\"  lang  .\")==(\\'Not matched!\\')']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/455",
    "prompt": "Write a function to check whether the given month number contains 31 days or not.",
    "canonical_solution": "def check_monthnumb_number(monthnum2):\r\n  if(monthnum2==1 or monthnum2==3 or monthnum2==5 or monthnum2==7 or monthnum2==8 or monthnum2==10 or monthnum2==12):\r\n    return True\r\n  else:\r\n    return False",
    "test": "['assert check_monthnumb_number(5)==True', 'assert check_monthnumb_number(2)==False', 'assert check_monthnumb_number(6)==False']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/456",
    "prompt": "Write a function to reverse strings in a given list of string values.",
    "canonical_solution": "def reverse_string_list(stringlist):\r\n    result = [x[::-1] for x in stringlist]\r\n    return result",
    "test": "[\"assert reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])==['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\", \"assert reverse_string_list(['john','amal','joel','george'])==['nhoj','lama','leoj','egroeg']\", \"assert reverse_string_list(['jack','john','mary'])==['kcaj','nhoj','yram']\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/457",
    "prompt": "Write a python function to find the sublist having minimum length.",
    "canonical_solution": "def Find_Min(lst): \r\n    minList = min((x) for x in lst) \r\n    return minList",
    "test": "['assert Find_Min([[1],[1,2],[1,2,3]]) == [1]', 'assert Find_Min([[1,1],[1,1,1],[1,2,7,8]]) == [1,1]', \"assert Find_Min([['x'],['x','y'],['x','y','z']]) == ['x']\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/458",
    "prompt": "Write a function to find the area of a rectangle.",
    "canonical_solution": "def rectangle_area(l,b):\r\n  area=l*b\r\n  return area",
    "test": "['assert rectangle_area(10,20)==200', 'assert rectangle_area(10,5)==50', 'assert rectangle_area(4,2)==8']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/459",
    "prompt": "Write a function to remove uppercase substrings from a given string by using regex.",
    "canonical_solution": "import re\r\ndef remove_uppercase(str1):\r\n  remove_upper = lambda text: re.sub('[A-Z]', '', text)\r\n  result =  remove_upper(str1)\r\n  return (result)",
    "test": "[\"assert remove_uppercase('cAstyoUrFavoRitETVshoWs') == 'cstyoravoitshos'\", \"assert remove_uppercase('wAtchTheinTernEtrAdIo') == 'wtchheinerntrdo'\", \"assert remove_uppercase('VoicESeaRchAndreComMendaTionS') == 'oiceachndreomendaion'\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/46",
    "prompt": "Write a python function to determine whether all the numbers are different from each other are not.",
    "canonical_solution": "def test_distinct(data):\r\n  if len(data) == len(set(data)):\r\n    return True\r\n  else:\r\n    return False;",
    "test": "['assert test_distinct([1,5,7,9]) == True', 'assert test_distinct([2,4,5,5,7,9]) == False', 'assert test_distinct([1,2,3]) == True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/460",
    "prompt": "Write a python function to get the first element of each sublist.",
    "canonical_solution": "def Extract(lst): \r\n    return [item[0] for item in lst] ",
    "test": "['assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]', 'assert Extract([[1,2,3],[4, 5]]) == [1,4]', 'assert Extract([[9,8,1],[1,2]]) == [9,1]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/461",
    "prompt": "Write a python function to count the upper case characters in a given string.",
    "canonical_solution": "def upper_ctr(str):\r\n    upper_ctr = 0\r\n    for i in range(len(str)):\r\n          if str[i] >= 'A' and str[i] <= 'Z': upper_ctr += 1\r\n          return upper_ctr",
    "test": "[\"assert upper_ctr('PYthon') == 1\", \"assert upper_ctr('BigData') == 1\", \"assert upper_ctr('program') == 0\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/462",
    "prompt": "Write a function to find all possible combinations of the elements of a given list.",
    "canonical_solution": "def combinations_list(list1):\r\n    if len(list1) == 0:\r\n        return [[]]\r\n    result = []\r\n    for el in combinations_list(list1[1:]):\r\n        result += [el, el+[list1[0]]]\r\n    return result",
    "test": "[\"assert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]\", \"assert combinations_list(['red', 'green', 'blue', 'white', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]\", \"assert combinations_list(['red', 'green', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/463",
    "prompt": "Write a function to find the maximum product subarray of the given array.",
    "canonical_solution": "def max_subarray_product(arr):\r\n\tn = len(arr)\r\n\tmax_ending_here = 1\r\n\tmin_ending_here = 1\r\n\tmax_so_far = 0\r\n\tflag = 0\r\n\tfor i in range(0, n):\r\n\t\tif arr[i] > 0:\r\n\t\t\tmax_ending_here = max_ending_here * arr[i]\r\n\t\t\tmin_ending_here = min (min_ending_here * arr[i], 1)\r\n\t\t\tflag = 1\r\n\t\telif arr[i] == 0:\r\n\t\t\tmax_ending_here = 1\r\n\t\t\tmin_ending_here = 1\r\n\t\telse:\r\n\t\t\ttemp = max_ending_here\r\n\t\t\tmax_ending_here = max (min_ending_here * arr[i], 1)\r\n\t\t\tmin_ending_here = temp * arr[i]\r\n\t\tif (max_so_far < max_ending_here):\r\n\t\t\tmax_so_far = max_ending_here\r\n\tif flag == 0 and max_so_far == 0:\r\n\t\treturn 0\r\n\treturn max_so_far",
    "test": "['assert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112', 'assert max_subarray_product([6, -3, -10, 0, 2]) == 180 ', 'assert max_subarray_product([-2, -40, 0, -2, -3]) == 80']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/464",
    "prompt": "Write a function to check if all values are same in a dictionary.",
    "canonical_solution": "def check_value(dict, n):\r\n    result = all(x == n for x in dict.values()) \r\n    return result",
    "test": "[\"assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},10)==False\", \"assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},12)==True\", \"assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},5)==False\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/465",
    "prompt": "Write a function to drop empty items from a given dictionary.",
    "canonical_solution": "def drop_empty(dict1):\r\n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\r\n  return dict1",
    "test": "[\"assert drop_empty({'c1': 'Red', 'c2': 'Green', 'c3':None})=={'c1': 'Red', 'c2': 'Green'}\", \"assert drop_empty({'c1': 'Red', 'c2': None, 'c3':None})=={'c1': 'Red'}\", \"assert drop_empty({'c1': None, 'c2': 'Green', 'c3':None})=={ 'c2': 'Green'}\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/466",
    "prompt": "Write a function to find the peak element in the given array.",
    "canonical_solution": "def find_peak_util(arr, low, high, n): \r\n\tmid = low + (high - low)/2\r\n\tmid = int(mid) \r\n\tif ((mid == 0 or arr[mid - 1] <= arr[mid]) and\r\n\t\t(mid == n - 1 or arr[mid + 1] <= arr[mid])): \r\n\t\treturn mid \r\n\telif (mid > 0 and arr[mid - 1] > arr[mid]): \r\n\t\treturn find_peak_util(arr, low, (mid - 1), n) \r\n\telse: \r\n\t\treturn find_peak_util(arr, (mid + 1), high, n) \r\ndef find_peak(arr, n): \r\n\treturn find_peak_util(arr, 0, n - 1, n) ",
    "test": "['assert find_peak([1, 3, 20, 4, 1, 0], 6) == 2', 'assert find_peak([2, 3, 4, 5, 6], 5) == 4', 'assert find_peak([8, 9, 11, 12, 14, 15], 6) == 5 ']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/467",
    "prompt": "Write a python function to convert decimal number to octal number.",
    "canonical_solution": "def decimal_to_Octal(deciNum):\r\n    octalNum = 0\r\n    countval = 1;\r\n    dNo = deciNum;\r\n    while (deciNum!= 0):\r\n        remainder= deciNum % 8;\r\n        octalNum+= remainder*countval;\r\n        countval= countval*10;\r\n        deciNum //= 8; \r\n    return (octalNum)",
    "test": "['assert decimal_to_Octal(10) == 12', 'assert decimal_to_Octal(2) == 2', 'assert decimal_to_Octal(33) == 41']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/468",
    "prompt": "Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.",
    "canonical_solution": "def max_product(arr, n ): \r\n\tmpis =[0] * (n) \r\n\tfor i in range(n): \r\n\t\tmpis[i] = arr[i] \r\n\tfor i in range(1, n): \r\n\t\tfor j in range(i): \r\n\t\t\tif (arr[i] > arr[j] and\r\n\t\t\t\t\tmpis[i] < (mpis[j] * arr[i])): \r\n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \r\n\treturn max(mpis)",
    "test": "['assert max_product([3, 100, 4, 5, 150, 6], 6) == 45000 ', 'assert max_product([4, 42, 55, 68, 80], 5) == 50265600', 'assert max_product([10, 22, 9, 33, 21, 50, 41, 60], 8) == 21780000 ']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/469",
    "prompt": "Write a function to find the maximum profit earned from a maximum of k stock transactions",
    "canonical_solution": "def max_profit(price, k):\r\n    n = len(price)\r\n    final_profit = [[None for x in range(n)] for y in range(k + 1)]\r\n    for i in range(k + 1):\r\n        for j in range(n):\r\n            if i == 0 or j == 0:\r\n                final_profit[i][j] = 0\r\n            else:\r\n                max_so_far = 0\r\n                for x in range(j):\r\n                    curr_price = price[j] - price[x] + final_profit[i-1][x]\r\n                    if max_so_far < curr_price:\r\n                        max_so_far = curr_price\r\n                final_profit[i][j] = max(final_profit[i][j-1], max_so_far)\r\n    return final_profit[k][n-1]",
    "test": "['assert max_profit([1, 5, 2, 3, 7, 6, 4, 5], 3) == 10', 'assert max_profit([2, 4, 7, 5, 4, 3, 5], 2) == 7', 'assert max_profit([10, 6, 8, 4, 2], 2) == 2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/47",
    "prompt": "Write a python function to find the last digit when factorial of a divides factorial of b.",
    "canonical_solution": "def compute_Last_Digit(A,B): \r\n    variable = 1\r\n    if (A == B): \r\n        return 1\r\n    elif ((B - A) >= 5):  \r\n        return 0\r\n    else:   \r\n        for i in range(A + 1,B + 1): \r\n            variable = (variable * (i % 10)) % 10\r\n        return variable % 10",
    "test": "['assert compute_Last_Digit(2,4) == 2', 'assert compute_Last_Digit(6,8) == 6', 'assert compute_Last_Digit(1,2) == 2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/470",
    "prompt": "Write a function to find the pairwise addition of the elements of the given tuples.",
    "canonical_solution": "def add_pairwise(test_tup):\r\n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\r\n  return (res) ",
    "test": "['assert add_pairwise((1, 5, 7, 8, 10)) == (6, 12, 15, 18)', 'assert add_pairwise((2, 6, 8, 9, 11)) == (8, 14, 17, 20)', 'assert add_pairwise((3, 7, 9, 10, 12)) == (10, 16, 19, 22)']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/471",
    "prompt": "Write a python function to find remainder of array multiplication divided by n.",
    "canonical_solution": "def find_remainder(arr, lens, n): \r\n    mul = 1\r\n    for i in range(lens):  \r\n        mul = (mul * (arr[i] % n)) % n \r\n    return mul % n ",
    "test": "['assert find_remainder([ 100, 10, 5, 25, 35, 14 ],6,11) ==9', 'assert find_remainder([1,1,1],3,1) == 0', 'assert find_remainder([1,2,1],3,2) == 0']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/472",
    "prompt": "Write a python function to check whether the given list contains consecutive numbers or not.",
    "canonical_solution": "def check_Consecutive(l): \r\n    return sorted(l) == list(range(min(l),max(l)+1)) ",
    "test": "['assert check_Consecutive([1,2,3,4,5]) == True', 'assert check_Consecutive([1,2,3,5,6]) == False', 'assert check_Consecutive([1,2,1]) == False']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/473",
    "prompt": "Write a function to find the tuple intersection of elements in the given tuple list irrespective of their order.",
    "canonical_solution": "def tuple_intersection(test_list1, test_list2):\r\n  res = set([tuple(sorted(ele)) for ele in test_list1]) & set([tuple(sorted(ele)) for ele in test_list2])\r\n  return (res)",
    "test": "['assert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)] , [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}', 'assert tuple_intersection([(4, 1), (7, 4), (11, 13), (17, 14)] , [(1, 4), (7, 4), (16, 12), (10, 13)]) == {(4, 7), (1, 4)}', 'assert tuple_intersection([(2, 1), (3, 2), (1, 3), (1, 4)] , [(11, 2), (2, 3), (6, 2), (1, 3)]) == {(1, 3), (2, 3)}']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/474",
    "prompt": "Write a function to replace characters in a string.",
    "canonical_solution": "def replace_char(str1,ch,newch):\r\n str2 = str1.replace(ch, newch)\r\n return str2",
    "test": "['assert replace_char(\"polygon\",\\'y\\',\\'l\\')==(\"pollgon\")', 'assert replace_char(\"character\",\\'c\\',\\'a\\')==(\"aharaater\")', 'assert replace_char(\"python\",\\'l\\',\\'a\\')==(\"python\")']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/475",
    "prompt": "Write a function to sort counter by value.",
    "canonical_solution": "from collections import Counter\r\ndef sort_counter(dict1):\r\n x = Counter(dict1)\r\n sort_counter=x.most_common()\r\n return sort_counter",
    "test": "[\"assert sort_counter({'Math':81, 'Physics':83, 'Chemistry':87})==[('Chemistry', 87), ('Physics', 83), ('Math', 81)]\", \"assert sort_counter({'Math':400, 'Physics':300, 'Chemistry':250})==[('Math', 400), ('Physics', 300), ('Chemistry', 250)]\", \"assert sort_counter({'Math':900, 'Physics':1000, 'Chemistry':1250})==[('Chemistry', 1250), ('Physics', 1000), ('Math', 900)]\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/476",
    "prompt": "Write a python function to find the sum of the largest and smallest value in a given array.",
    "canonical_solution": "def big_sum(nums):\r\n      sum= max(nums)+min(nums)\r\n      return sum",
    "test": "['assert big_sum([1,2,3]) == 4', 'assert big_sum([-1,2,3,4]) == 3', 'assert big_sum([2,3,6]) == 8']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/477",
    "prompt": "Write a python function to convert the given string to lower case.",
    "canonical_solution": "def is_lower(string):\r\n  return (string.lower())",
    "test": "['assert is_lower(\"InValid\") == \"invalid\"', 'assert is_lower(\"TruE\") == \"true\"', 'assert is_lower(\"SenTenCE\") == \"sentence\"']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/478",
    "prompt": "Write a function to remove lowercase substrings from a given string.",
    "canonical_solution": "import re\r\ndef remove_lowercase(str1):\r\n remove_lower = lambda text: re.sub('[a-z]', '', text)\r\n result =  remove_lower(str1)\r\n return result",
    "test": "['assert remove_lowercase(\"PYTHon\")==(\\'PYTH\\')', 'assert remove_lowercase(\"FInD\")==(\\'FID\\')', 'assert remove_lowercase(\"STRinG\")==(\\'STRG\\')']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/479",
    "prompt": "Write a python function to find the first digit of a given number.",
    "canonical_solution": "def first_Digit(n) :  \r\n    while n >= 10:  \r\n        n = n / 10; \r\n    return int(n) ",
    "test": "['assert first_Digit(123) == 1', 'assert first_Digit(456) == 4', 'assert first_Digit(12) == 1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/48",
    "prompt": "Write a python function to set all odd bits of a given number.",
    "canonical_solution": "def odd_bit_set_number(n):\r\n    count = 0;res = 0;temp = n\r\n    while temp > 0:\r\n        if count % 2 == 0:\r\n            res |= (1 << count)\r\n        count += 1\r\n        temp >>= 1\r\n    return (n | res)",
    "test": "['assert odd_bit_set_number(10) == 15', 'assert odd_bit_set_number(20) == 21', 'assert odd_bit_set_number(30) == 31']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/480",
    "prompt": "Write a python function to find the maximum occurring character in a given string.",
    "canonical_solution": "def get_max_occuring_char(str1):\r\n  ASCII_SIZE = 256\r\n  ctr = [0] * ASCII_SIZE\r\n  max = -1\r\n  ch = ''\r\n  for i in str1:\r\n    ctr[ord(i)]+=1;\r\n  for i in str1:\r\n    if max < ctr[ord(i)]:\r\n      max = ctr[ord(i)]\r\n      ch = i\r\n  return ch",
    "test": "['assert get_max_occuring_char(\"data\") == \"a\"', 'assert get_max_occuring_char(\"create\") == \"e\"', 'assert get_max_occuring_char(\"brilliant girl\") == \"i\"']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/481",
    "prompt": "Write a function to determine if there is a subset of the given set with sum equal to the given sum.",
    "canonical_solution": "def is_subset_sum(set, n, sum):\r\n\tif (sum == 0):\r\n\t\treturn True\r\n\tif (n == 0):\r\n\t\treturn False\r\n\tif (set[n - 1] > sum):\r\n\t\treturn is_subset_sum(set, n - 1, sum)\r\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])",
    "test": "['assert is_subset_sum([3, 34, 4, 12, 5, 2], 6, 9) == True', 'assert is_subset_sum([3, 34, 4, 12, 5, 2], 6, 30) == False', 'assert is_subset_sum([3, 34, 4, 12, 5, 2], 6, 15) == True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/482",
    "prompt": "Write a function to find sequences of one upper case letter followed by lower case letters in the given string by using regex.",
    "canonical_solution": "import re \r\ndef match(text): \r\n\t\tpattern = '[A-Z]+[a-z]+$'\r\n\t\tif re.search(pattern, text): \r\n\t\t\t\treturn('Yes') \r\n\t\telse: \r\n\t\t\t\treturn('No') ",
    "test": "['assert match(\"Geeks\") == \\'Yes\\'', 'assert match(\"geeksforGeeks\") == \\'Yes\\'', 'assert match(\"geeks\") == \\'No\\'']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/483",
    "prompt": "Write a python function to find the first natural number whose factorial is divisible by x.",
    "canonical_solution": "def first_Factorial_Divisible_Number(x): \r\n    i = 1;\r\n    fact = 1; \r\n    for i in range(1,x): \r\n        fact = fact * i \r\n        if (fact % x == 0): \r\n            break\r\n    return i ",
    "test": "['assert first_Factorial_Divisible_Number(10) == 5', 'assert first_Factorial_Divisible_Number(15) == 5', 'assert first_Factorial_Divisible_Number(5) == 4']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/484",
    "prompt": "Write a function to remove the matching tuples from the given two tuples.",
    "canonical_solution": "def remove_matching_tuple(test_list1, test_list2):\r\n  res = [sub for sub in test_list1 if sub not in test_list2]\r\n  return (res) ",
    "test": "[\"assert remove_matching_tuple([('Hello', 'dude'), ('How', 'are'), ('you', '?')], [('Hello', 'dude'), ('How', 'are')]) == [('you', '?')]\", \"assert remove_matching_tuple([('Part', 'of'), ('the', 'journey'), ('is ', 'end')], [('Journey', 'the'), ('is', 'end')]) == [('Part', 'of'), ('the', 'journey'), ('is ', 'end')]\", \"assert remove_matching_tuple([('Its', 'been'), ('a', 'long'), ('day', 'without')], [('a', 'long'), ('my', 'friend')]) == [('Its', 'been'), ('day', 'without')]\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/485",
    "prompt": "Write a function to find the largest palindromic number in the given array.",
    "canonical_solution": "def is_palindrome(n) : \r\n\tdivisor = 1\r\n\twhile (n / divisor >= 10) : \r\n\t\tdivisor *= 10\r\n\twhile (n != 0) : \r\n\t\tleading = n // divisor \r\n\t\ttrailing = n % 10\r\n\t\tif (leading != trailing) : \r\n\t\t\treturn False\r\n\t\tn = (n % divisor) // 10\r\n\t\tdivisor = divisor // 100\r\n\treturn True\r\ndef largest_palindrome(A, n) : \r\n\tA.sort() \r\n\tfor i in range(n - 1, -1, -1) : \r\n\t\tif (is_palindrome(A[i])) : \r\n\t\t\treturn A[i] \r\n\treturn -1",
    "test": "['assert largest_palindrome([1, 232, 54545, 999991], 4) == 54545', 'assert largest_palindrome([1, 2, 3, 4, 5, 50], 6) == 5', 'assert largest_palindrome([1, 3, 7, 9, 45], 5)  == 9']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/486",
    "prompt": "Write a function to compute binomial probability for the given number.",
    "canonical_solution": "def nCr(n, r): \r\n\tif (r > n / 2): \r\n\t\tr = n - r \r\n\tanswer = 1 \r\n\tfor i in range(1, r + 1): \r\n\t\tanswer *= (n - r + i) \r\n\t\tanswer /= i \r\n\treturn answer \r\ndef binomial_probability(n, k, p): \r\n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ",
    "test": "['assert binomial_probability(10, 5, 1.0/3) == 0.13656454808718185', 'assert binomial_probability(11, 6, 2.0/4) == 0.2255859375', 'assert binomial_probability(12, 7, 3.0/5) == 0.227030335488']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/487",
    "prompt": "Write a function to sort a list of tuples in increasing order by the last element in each tuple.",
    "canonical_solution": "def sort_tuple(tup): \r\n\tlst = len(tup) \r\n\tfor i in range(0, lst): \r\n\t\tfor j in range(0, lst-i-1): \r\n\t\t\tif (tup[j][-1] > tup[j + 1][-1]): \r\n\t\t\t\ttemp = tup[j] \r\n\t\t\t\ttup[j]= tup[j + 1] \r\n\t\t\t\ttup[j + 1]= temp \r\n\treturn tup",
    "test": "['assert sort_tuple([(1, 3), (3, 2), (2, 1)] ) == [(2, 1), (3, 2), (1, 3)]', 'assert sort_tuple([(2, 4), (3, 3), (1, 1)] ) == [(1, 1), (3, 3), (2, 4)]', 'assert sort_tuple([(3, 9), (6, 7), (4, 3)] ) == [(4, 3), (6, 7), (3, 9)]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/488",
    "prompt": "Write a function to find the area of a pentagon.",
    "canonical_solution": "import math\r\ndef area_pentagon(a):\r\n  area=(math.sqrt(5*(5+2*math.sqrt(5)))*pow(a,2))/4.0\r\n  return area",
    "test": "['assert area_pentagon(5)==43.01193501472417', 'assert area_pentagon(10)==172.0477400588967', 'assert area_pentagon(15)==387.10741513251753']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/489",
    "prompt": "Write a python function to find the frequency of the largest value in a given array.",
    "canonical_solution": "def frequency_Of_Largest(n,arr): \r\n    mn = arr[0] \r\n    freq = 1\r\n    for i in range(1,n): \r\n        if (arr[i] >mn): \r\n            mn = arr[i] \r\n            freq = 1\r\n        elif (arr[i] == mn): \r\n            freq += 1\r\n    return freq ",
    "test": "['assert frequency_Of_Largest(5,[1,2,3,4,4]) == 2', 'assert frequency_Of_Largest(3,[5,6,5]) == 1', 'assert frequency_Of_Largest(4,[2,7,7,7]) == 3']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/49",
    "prompt": "Write a function to extract every first or specified element from a given two-dimensional list.",
    "canonical_solution": "def specified_element(nums, N):\r\n    result = [i[N] for i in nums]\r\n    return result\r\n    ",
    "test": "['assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],0)==[1, 4, 7]', 'assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],2)==[3, 6, 9]', 'assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],1)==[2,5,1]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/490",
    "prompt": "Write a function to extract all the pairs which are symmetric in the given tuple list.",
    "canonical_solution": "def extract_symmetric(test_list):\r\n  temp = set(test_list) & {(b, a) for a, b in test_list}\r\n  res = {(a, b) for a, b in temp if a < b}\r\n  return (res) ",
    "test": "['assert extract_symmetric([(6, 7), (2, 3), (7, 6), (9, 8), (10, 2), (8, 9)] ) == {(8, 9), (6, 7)}', 'assert extract_symmetric([(7, 8), (3, 4), (8, 7), (10, 9), (11, 3), (9, 10)] ) == {(9, 10), (7, 8)}', 'assert extract_symmetric([(8, 9), (4, 5), (9, 8), (11, 10), (12, 4), (10, 11)] ) == {(8, 9), (10, 11)}']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/491",
    "prompt": "Write a function to find the sum of geometric progression series.",
    "canonical_solution": "import math\r\ndef sum_gp(a,n,r):\r\n total = (a * (1 - math.pow(r, n ))) / (1- r)\r\n return total",
    "test": "['assert sum_gp(1,5,2)==31', 'assert sum_gp(1,5,4)==341', 'assert sum_gp(2,6,3)==728']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/492",
    "prompt": "Write a function to search an element in the given array by using binary search.",
    "canonical_solution": "def binary_search(item_list,item):\r\n\tfirst = 0\r\n\tlast = len(item_list)-1\r\n\tfound = False\r\n\twhile( first<=last and not found):\r\n\t\tmid = (first + last)//2\r\n\t\tif item_list[mid] == item :\r\n\t\t\tfound = True\r\n\t\telse:\r\n\t\t\tif item < item_list[mid]:\r\n\t\t\t\tlast = mid - 1\r\n\t\t\telse:\r\n\t\t\t\tfirst = mid + 1\t\r\n\treturn found",
    "test": "['assert binary_search([1,2,3,5,8], 6) == False', 'assert binary_search([7, 8, 9, 10, 13], 10) == True', 'assert binary_search([11, 13, 14, 19, 22, 36], 23) == False']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/493",
    "prompt": "Write a function to calculate a grid of hexagon coordinates where function returns a list of lists containing 6 tuples of x, y point coordinates.",
    "canonical_solution": "import math\r\ndef calculate_polygons(startx, starty, endx, endy, radius):\r\n    sl = (2 * radius) * math.tan(math.pi / 6)\r\n    p = sl * 0.5\r\n    b = sl * math.cos(math.radians(30))\r\n    w = b * 2\r\n    h = 2 * sl   \r\n    startx = startx - w\r\n    starty = starty - h\r\n    endx = endx + w\r\n    endy = endy + h\r\n    origx = startx\r\n    origy = starty\r\n    xoffset = b\r\n    yoffset = 3 * p\r\n    polygons = []\r\n    row = 1\r\n    counter = 0\r\n    while starty < endy:\r\n        if row % 2 == 0:\r\n            startx = origx + xoffset\r\n        else:\r\n            startx = origx\r\n        while startx < endx:\r\n            p1x = startx\r\n            p1y = starty + p\r\n            p2x = startx\r\n            p2y = starty + (3 * p)\r\n            p3x = startx + b\r\n            p3y = starty + h\r\n            p4x = startx + w\r\n            p4y = starty + (3 * p)\r\n            p5x = startx + w\r\n            p5y = starty + p\r\n            p6x = startx + b\r\n            p6y = starty\r\n            poly = [\r\n                (p1x, p1y),\r\n                (p2x, p2y),\r\n                (p3x, p3y),\r\n                (p4x, p4y),\r\n                (p5x, p5y),\r\n                (p6x, p6y),\r\n                (p1x, p1y)]\r\n            polygons.append(poly)\r\n            counter += 1\r\n            startx += w\r\n        starty += yoffset\r\n        row += 1\r\n    return polygons",
    "test": "['assert calculate_polygons(1,1, 4, 4, 3)==[[(-5.0, -4.196152422706632), (-5.0, -0.7320508075688767), (-2.0, 1.0), (1.0, -0.7320508075688767), (1.0, -4.196152422706632), (-2.0, -5.928203230275509), (-5.0, -4.196152422706632)], [(1.0, -4.196152422706632), (1.0, -0.7320508075688767), (4.0, 1.0), (7.0, -0.7320508075688767), (7.0, -4.196152422706632), (4.0, -5.928203230275509), (1.0, -4.196152422706632)], [(7.0, -4.196152422706632), (7.0, -0.7320508075688767), (10.0, 1.0), (13.0, -0.7320508075688767), (13.0, -4.196152422706632), (10.0, -5.928203230275509), (7.0, -4.196152422706632)], [(-2.0, 1.0000000000000004), (-2.0, 4.464101615137755), (1.0, 6.196152422706632), (4.0, 4.464101615137755), (4.0, 1.0000000000000004), (1.0, -0.7320508075688767), (-2.0, 1.0000000000000004)], [(4.0, 1.0000000000000004), (4.0, 4.464101615137755), (7.0, 6.196152422706632), (10.0, 4.464101615137755), (10.0, 1.0000000000000004), (7.0, -0.7320508075688767), (4.0, 1.0000000000000004)], [(-5.0, 6.196152422706632), (-5.0, 9.660254037844387), (-2.0, 11.392304845413264), (1.0, 9.660254037844387), (1.0, 6.196152422706632), (-2.0, 4.464101615137755), (-5.0, 6.196152422706632)], [(1.0, 6.196152422706632), (1.0, 9.660254037844387), (4.0, 11.392304845413264), (7.0, 9.660254037844387), (7.0, 6.196152422706632), (4.0, 4.464101615137755), (1.0, 6.196152422706632)], [(7.0, 6.196152422706632), (7.0, 9.660254037844387), (10.0, 11.392304845413264), (13.0, 9.660254037844387), (13.0, 6.196152422706632), (10.0, 4.464101615137755), (7.0, 6.196152422706632)], [(-2.0, 11.392304845413264), (-2.0, 14.85640646055102), (1.0, 16.588457268119896), (4.0, 14.85640646055102), (4.0, 11.392304845413264), (1.0, 9.660254037844387), (-2.0, 11.392304845413264)], [(4.0, 11.392304845413264), (4.0, 14.85640646055102), (7.0, 16.588457268119896), (10.0, 14.85640646055102), (10.0, 11.392304845413264), (7.0, 9.660254037844387), (4.0, 11.392304845413264)]]', 'assert calculate_polygons(5,4,7,9,8)==[[(-11.0, -9.856406460551018), (-11.0, -0.6188021535170058), (-3.0, 4.0), (5.0, -0.6188021535170058), (5.0, -9.856406460551018), (-3.0, -14.475208614068023), (-11.0, -9.856406460551018)], [(5.0, -9.856406460551018), (5.0, -0.6188021535170058), (13.0, 4.0), (21.0, -0.6188021535170058), (21.0, -9.856406460551018), (13.0, -14.475208614068023), (5.0, -9.856406460551018)], [(21.0, -9.856406460551018), (21.0, -0.6188021535170058), (29.0, 4.0), (37.0, -0.6188021535170058), (37.0, -9.856406460551018), (29.0, -14.475208614068023), (21.0, -9.856406460551018)], [(-3.0, 4.0), (-3.0, 13.237604307034012), (5.0, 17.856406460551018), (13.0, 13.237604307034012), (13.0, 4.0), (5.0, -0.6188021535170058), (-3.0, 4.0)], [(13.0, 4.0), (13.0, 13.237604307034012), (21.0, 17.856406460551018), (29.0, 13.237604307034012), (29.0, 4.0), (21.0, -0.6188021535170058), (13.0, 4.0)], [(-11.0, 17.856406460551018), (-11.0, 27.09401076758503), (-3.0, 31.712812921102035), (5.0, 27.09401076758503), (5.0, 17.856406460551018), (-3.0, 13.237604307034012), (-11.0, 17.856406460551018)], [(5.0, 17.856406460551018), (5.0, 27.09401076758503), (13.0, 31.712812921102035), (21.0, 27.09401076758503), (21.0, 17.856406460551018), (13.0, 13.237604307034012), (5.0, 17.856406460551018)], [(21.0, 17.856406460551018), (21.0, 27.09401076758503), (29.0, 31.712812921102035), (37.0, 27.09401076758503), (37.0, 17.856406460551018), (29.0, 13.237604307034012), (21.0, 17.856406460551018)], [(-3.0, 31.712812921102035), (-3.0, 40.95041722813605), (5.0, 45.569219381653056), (13.0, 40.95041722813605), (13.0, 31.712812921102035), (5.0, 27.09401076758503), (-3.0, 31.712812921102035)], [(13.0, 31.712812921102035), (13.0, 40.95041722813605), (21.0, 45.569219381653056), (29.0, 40.95041722813605), (29.0, 31.712812921102035), (21.0, 27.09401076758503), (13.0, 31.712812921102035)]]', 'assert calculate_polygons(9,6,4,3,2)==[[(5.0, 2.5358983848622456), (5.0, 4.8452994616207485), (7.0, 6.0), (9.0, 4.8452994616207485), (9.0, 2.5358983848622456), (7.0, 1.3811978464829942), (5.0, 2.5358983848622456)], [(7.0, 6.0), (7.0, 8.309401076758503), (9.0, 9.464101615137753), (11.0, 8.309401076758503), (11.0, 6.0), (9.0, 4.8452994616207485), (7.0, 6.0)]]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/494",
    "prompt": "Write a function to convert the given binary tuple to integer.",
    "canonical_solution": "def binary_to_integer(test_tup):\r\n  res = int(\"\".join(str(ele) for ele in test_tup), 2)\r\n  return (str(res)) ",
    "test": "[\"assert binary_to_integer((1, 1, 0, 1, 0, 0, 1)) == '105'\", \"assert binary_to_integer((0, 1, 1, 0, 0, 1, 0, 1)) == '101'\", \"assert binary_to_integer((1, 1, 0, 1, 0, 1)) == '53'\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/495",
    "prompt": "Write a function to remove lowercase substrings from a given string by using regex.",
    "canonical_solution": "import re\r\ndef remove_lowercase(str1):\r\n  remove_lower = lambda text: re.sub('[a-z]', '', text)\r\n  result =  remove_lower(str1)\r\n  return (result)",
    "test": "[\"assert remove_lowercase('KDeoALOklOOHserfLoAJSIskdsf') == 'KDALOOOHLAJSI'\", \"assert remove_lowercase('ProducTnamEstreAmIngMediAplAYer') == 'PTEAIMAAY'\", \"assert remove_lowercase('maNufacTuredbYSheZenTechNolOGIes') == 'NTYSZTNOGI'\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/496",
    "prompt": "Write a function to find the smallest integers from a given list of numbers using heap queue algorithm.",
    "canonical_solution": "import heapq as hq\r\ndef heap_queue_smallest(nums,n):\r\n  smallest_nums = hq.nsmallest(n, nums)\r\n  return smallest_nums",
    "test": "['assert heap_queue_smallest( [25, 35, 22, 85, 14, 65, 75, 25, 58],3)==[14, 22, 25] ', 'assert heap_queue_smallest( [25, 35, 22, 85, 14, 65, 75, 25, 58],2)==[14, 22]', 'assert heap_queue_smallest( [25, 35, 22, 85, 14, 65, 75, 22, 58],5)==[14, 22, 22, 25, 35]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/497",
    "prompt": "Write a function to find the surface area of a cone.",
    "canonical_solution": "import math\r\ndef surfacearea_cone(r,h):\r\n  l = math.sqrt(r * r + h * h)\r\n  SA = math.pi * r * (r + l)\r\n  return SA",
    "test": "['assert surfacearea_cone(5,12)==282.7433388230814', 'assert surfacearea_cone(10,15)==880.5179353159282', 'assert surfacearea_cone(19,17)==2655.923961165254']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/498",
    "prompt": "Write a python function to find gcd of two positive integers.",
    "canonical_solution": "def gcd(x, y):\r\n    gcd = 1\r\n    if x % y == 0:\r\n        return y\r\n    for k in range(int(y / 2), 0, -1):\r\n        if x % k == 0 and y % k == 0:\r\n            gcd = k\r\n            break  \r\n    return gcd",
    "test": "['assert gcd(12, 17) == 1', 'assert gcd(4,6) == 2', 'assert gcd(2,9) == 1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/499",
    "prompt": "Write a function to find the diameter of a circle.",
    "canonical_solution": "def diameter_circle(r):\r\n  diameter=2*r\r\n  return diameter",
    "test": "['assert diameter_circle(10)==20', 'assert diameter_circle(40)==80', 'assert diameter_circle(15)==30']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/50",
    "prompt": "Write a function to find the list with minimum length using lambda function.",
    "canonical_solution": "def min_length_list(input_list):\r\n    min_length = min(len(x) for x in input_list )  \r\n    min_list = min(input_list, key = lambda i: len(i))\r\n    return(min_length, min_list)",
    "test": "['assert min_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(1, [0])', 'assert min_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])==(1,[1])', 'assert min_length_list([[3,4,5],[6,7,8,9],[10,11,12],[1,2]])==(2,[1,2])']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/500",
    "prompt": "Write a function to concatenate all elements of the given list into a string.",
    "canonical_solution": "def concatenate_elements(list):\r\n  ans = ' '\r\n  for i in list:\r\n    ans = ans+ ' '+i\r\n  return (ans) ",
    "test": "[\"assert concatenate_elements(['hello','there','have','a','rocky','day'] ) == '  hello there have a rocky day'\", \"assert concatenate_elements([ 'Hi', 'there', 'How','are', 'you'] ) == '  Hi there How are you'\", \"assert concatenate_elements([ 'Part', 'of', 'the','journey', 'is', 'end'] ) == '  Part of the journey is end'\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/501",
    "prompt": "Write a python function to find common divisor between two numbers in a given pair.",
    "canonical_solution": "def ngcd(x,y):\r\n    i=1\r\n    while(i<=x and i<=y):\r\n        if(x%i==0 and y%i == 0):\r\n            gcd=i;\r\n        i+=1\r\n    return gcd;\r\ndef num_comm_div(x,y):\r\n  n = ngcd(x,y)\r\n  result = 0\r\n  z = int(n**0.5)\r\n  i = 1\r\n  while(i <= z):\r\n    if(n % i == 0):\r\n      result += 2 \r\n      if(i == n/i):\r\n        result-=1\r\n    i+=1\r\n  return result",
    "test": "['assert num_comm_div(2,4) == 2', 'assert num_comm_div(2,8) == 2', 'assert num_comm_div(12,24) == 6']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/502",
    "prompt": "Write a python function to find remainder of two numbers.",
    "canonical_solution": "def find(n,m):\r\n  r = n%m\r\n  return (r)",
    "test": "['assert find(3,3) == 0', 'assert find(10,3) == 1', 'assert find(16,5) == 1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/503",
    "prompt": "Write a function to add consecutive numbers of a given list.",
    "canonical_solution": "def add_consecutive_nums(nums):\r\n    result = [b+a for a, b in zip(nums[:-1], nums[1:])]\r\n    return result",
    "test": "['assert add_consecutive_nums([1, 1, 3, 4, 4, 5, 6, 7])==[2, 4, 7, 8, 9, 11, 13]', 'assert add_consecutive_nums([4, 5, 8, 9, 6, 10])==[9, 13, 17, 15, 16]', 'assert add_consecutive_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[3, 5, 7, 9, 11, 13, 15, 17, 19]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/504",
    "prompt": "Write a python function to find the cube sum of first n natural numbers.",
    "canonical_solution": "def sum_Of_Series(n): \r\n    sum = 0\r\n    for i in range(1,n + 1): \r\n        sum += i * i*i       \r\n    return sum",
    "test": "['assert sum_Of_Series(5) == 225', 'assert sum_Of_Series(2) == 9', 'assert sum_Of_Series(3) == 36']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/505",
    "prompt": "Write a function to move all zeroes to the end of the given array.",
    "canonical_solution": "def re_order(A):\r\n    k = 0\r\n    for i in A:\r\n        if i:\r\n            A[k] = i\r\n            k = k + 1\r\n    for i in range(k, len(A)):\r\n        A[i] = 0\r\n    return A",
    "test": "['assert re_order([6, 0, 8, 2, 3, 0, 4, 0, 1]) == [6, 8, 2, 3, 4, 1, 0, 0, 0]', 'assert re_order([4, 0, 2, 7, 0, 9, 0, 12, 0]) == [4, 2, 7, 9, 12, 0, 0, 0, 0]', 'assert re_order([3, 11, 0, 74, 14, 0, 1, 0, 2]) == [3, 11, 74, 14, 1, 2, 0, 0, 0]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/506",
    "prompt": "Write a function to calculate the permutation coefficient of given p(n, k).",
    "canonical_solution": "def permutation_coefficient(n, k): \r\n\tP = [[0 for i in range(k + 1)] \r\n\t\t\tfor j in range(n + 1)] \r\n\tfor i in range(n + 1): \r\n\t\tfor j in range(min(i, k) + 1): \r\n\t\t\tif (j == 0): \r\n\t\t\t\tP[i][j] = 1\r\n\t\t\telse: \r\n\t\t\t\tP[i][j] = P[i - 1][j] + ( \r\n\t\t\t\t\t\tj * P[i - 1][j - 1]) \r\n\t\t\tif (j < k): \r\n\t\t\t\tP[i][j + 1] = 0\r\n\treturn P[n][k] ",
    "test": "['assert permutation_coefficient(10, 2) == 90', 'assert permutation_coefficient(10, 3) == 720', 'assert permutation_coefficient(10, 1) == 10']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/507",
    "prompt": "Write a function to remove specific words from a given list.",
    "canonical_solution": "def remove_words(list1, removewords):\r\n    for word in list(list1):\r\n        if word in removewords:\r\n            list1.remove(word)\r\n    return list1  ",
    "test": "[\"assert remove_words(['red', 'green', 'blue', 'white', 'black', 'orange'],['white', 'orange'])==['red', 'green', 'blue', 'black']\", \"assert remove_words(['red', 'green', 'blue', 'white', 'black', 'orange'],['black', 'orange'])==['red', 'green', 'blue', 'white']\", \"assert remove_words(['red', 'green', 'blue', 'white', 'black', 'orange'],['blue', 'white'])==['red', 'green', 'black', 'orange']\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/508",
    "prompt": "Write a function to check if the common elements between two given lists are in the same order or not.",
    "canonical_solution": "def same_order(l1, l2):\r\n    common_elements = set(l1) & set(l2)\r\n    l1 = [e for e in l1 if e in common_elements]\r\n    l2 = [e for e in l2 if e in common_elements]\r\n    return l1 == l2",
    "test": "['assert same_order([\"red\",\"green\",\"black\",\"orange\"],[\"red\",\"pink\",\"green\",\"white\",\"black\"])==True', 'assert same_order([\"red\",\"pink\",\"green\",\"white\",\"black\"],[\"white\",\"orange\",\"pink\",\"black\"])==False', 'assert same_order([\"red\",\"green\",\"black\",\"orange\"],[\"red\",\"pink\",\"green\",\"white\",\"black\"])==True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/509",
    "prompt": "Write a python function to find the average of odd numbers till a given odd number.",
    "canonical_solution": "def average_Odd(n) : \r\n    if (n%2==0) : \r\n        return (\"Invalid Input\") \r\n        return -1 \r\n    sm =0\r\n    count =0\r\n    while (n>=1) : \r\n        count=count+1\r\n        sm = sm + n \r\n        n = n-2\r\n    return sm//count ",
    "test": "['assert average_Odd(9) == 5', 'assert average_Odd(5) == 3', 'assert average_Odd(11) == 6']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/51",
    "prompt": "Write a function to print check if the triangle is equilateral or not.",
    "canonical_solution": "def check_equilateral(x,y,z):\r\n  if x == y == z:\r\n\t   return True\r\n  else:\r\n     return False",
    "test": "['assert check_equilateral(6,8,12)==False ', 'assert check_equilateral(6,6,12)==False', 'assert check_equilateral(6,6,6)==True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/510",
    "prompt": "Write a function to find the number of subsequences having product smaller than k for the given non negative array.",
    "canonical_solution": "def no_of_subsequences(arr, k): \r\n\tn = len(arr) \r\n\tdp = [[0 for i in range(n + 1)] \r\n\t\t\tfor j in range(k + 1)] \r\n\tfor i in range(1, k + 1): \r\n\t\tfor j in range(1, n + 1): \r\n\t\t\tdp[i][j] = dp[i][j - 1] \r\n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \r\n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\r\n\treturn dp[k][n]",
    "test": "['assert no_of_subsequences([1,2,3,4], 10) == 11', 'assert no_of_subsequences([4,8,7,2], 50) == 9', 'assert no_of_subsequences([5,6,7,8], 15) == 4']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/52",
    "prompt": "Write a function to caluclate area of a parallelogram.",
    "canonical_solution": "def parallelogram_area(b,h):\r\n  area=b*h\r\n  return area",
    "test": "['assert parallelogram_area(10,20)==200', 'assert parallelogram_area(15,20)==300', 'assert parallelogram_area(8,9)==72']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/53",
    "prompt": "Write a python function to check whether the first and last characters of a given string are equal or not.",
    "canonical_solution": "def check_Equality(str):\r\n  if (str[0] == str[-1]):  \r\n    return (\"Equal\") \r\n  else:  \r\n    return (\"Not Equal\") ",
    "test": "['assert check_Equality(\"abcda\") == \"Equal\"', 'assert check_Equality(\"ab\") == \"Not Equal\"', 'assert check_Equality(\"mad\") == \"Not Equal\"']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/54",
    "prompt": "Write a function to sort the given array by using counting sort.",
    "canonical_solution": "def counting_sort(my_list):\r\n    max_value = 0\r\n    for i in range(len(my_list)):\r\n        if my_list[i] > max_value:\r\n            max_value = my_list[i]\r\n    buckets = [0] * (max_value + 1)\r\n    for i in my_list:\r\n        buckets[i] += 1\r\n    i = 0\r\n    for j in range(max_value + 1):\r\n         for a in range(buckets[j]):\r\n             my_list[i] = j\r\n             i += 1\r\n    return my_list",
    "test": "['assert counting_sort([1,23,4,5,6,7,8]) == [1, 4, 5, 6, 7, 8, 23]', 'assert counting_sort([12, 9, 28, 33, 69, 45]) == [9, 12, 28, 33, 45, 69]', 'assert counting_sort([8, 4, 14, 3, 2, 1]) == [1, 2, 3, 4, 8, 14]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/55",
    "prompt": "Write a function to find t-nth term of geometric series.",
    "canonical_solution": "import math\r\ndef tn_gp(a,n,r):\r\n  tn = a * (math.pow(r, n - 1))\r\n  return tn",
    "test": "['assert tn_gp(1,5,2)==16', 'assert tn_gp(1,5,4)==256', 'assert tn_gp(2,6,3)==486']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/56",
    "prompt": "Write a python function to check if a given number is one less than twice its reverse.",
    "canonical_solution": "def rev(num):    \r\n    rev_num = 0\r\n    while (num > 0):  \r\n        rev_num = (rev_num * 10 + num % 10) \r\n        num = num // 10  \r\n    return rev_num  \r\ndef check(n):    \r\n    return (2 * rev(n) == n + 1)  ",
    "test": "['assert check(70) == False', 'assert check(23) == False', 'assert check(73) == True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/57",
    "prompt": "Write a python function to find the largest number that can be formed with the given digits.",
    "canonical_solution": "def find_Max_Num(arr,n) : \r\n    arr.sort(reverse = True) \r\n    num = arr[0] \r\n    for i in range(1,n) : \r\n        num = num * 10 + arr[i] \r\n    return num ",
    "test": "['assert find_Max_Num([1,2,3],3) == 321', 'assert find_Max_Num([4,5,6,1],4) == 6541', 'assert find_Max_Num([1,2,3,9],4) == 9321']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/58",
    "prompt": "Write a python function to check whether the given two integers have opposite sign or not.",
    "canonical_solution": "def opposite_Signs(x,y): \r\n    return ((x ^ y) < 0); ",
    "test": "['assert opposite_Signs(1,-2) == True', 'assert opposite_Signs(3,2) == False', 'assert opposite_Signs(-10,-10) == False']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/59",
    "prompt": "Write a function to find the nth octagonal number.",
    "canonical_solution": "def is_octagonal(n): \r\n\treturn 3 * n * n - 2 * n ",
    "test": "['assert is_octagonal(5) == 65', 'assert is_octagonal(10) == 280', 'assert is_octagonal(15) == 645']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/60",
    "prompt": "Write a function to find the maximum length of the subsequence with difference between adjacent elements for the given array.",
    "canonical_solution": "def max_len_sub( arr, n): \r\n\tmls=[] \r\n\tmax = 0\r\n\tfor i in range(n): \r\n\t\tmls.append(1) \r\n\tfor i in range(n): \r\n\t\tfor j in range(i): \r\n\t\t\tif (abs(arr[i] - arr[j]) <= 1 and mls[i] < mls[j] + 1): \r\n\t\t\t\tmls[i] = mls[j] + 1\r\n\tfor i in range(n): \r\n\t\tif (max < mls[i]): \r\n\t\t\tmax = mls[i] \r\n\treturn max",
    "test": "['assert max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8) == 5', 'assert max_len_sub([-2, -1, 5, -1, 4, 0, 3], 7) == 4', 'assert max_len_sub([9, 11, 13, 15, 18], 5) == 1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/61",
    "prompt": "Write a python function to count number of substrings with the sum of digits equal to their length.",
    "canonical_solution": "from collections import defaultdict\r\ndef count_Substrings(s,n):\r\n    count,sum = 0,0\r\n    mp = defaultdict(lambda : 0)\r\n    mp[0] += 1\r\n    for i in range(n):\r\n        sum += ord(s[i]) - ord('0')\r\n        count += mp[sum - (i + 1)]\r\n        mp[sum - (i + 1)] += 1\r\n    return count",
    "test": "[\"assert count_Substrings('112112',6) == 6\", \"assert count_Substrings('111',3) == 6\", \"assert count_Substrings('1101112',7) == 12\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/62",
    "prompt": "Write a python function to find smallest number in a list.",
    "canonical_solution": "def smallest_num(xs):\n  return min(xs)\n",
    "test": "['assert smallest_num([10, 20, 1, 45, 99]) == 1', 'assert smallest_num([1, 2, 3]) == 1', 'assert smallest_num([45, 46, 50, 60]) == 45']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/63",
    "prompt": "Write a function to find the maximum difference between available pairs in the given tuple list.",
    "canonical_solution": "def max_difference(test_list):\r\n  temp = [abs(b - a) for a, b in test_list]\r\n  res = max(temp)\r\n  return (res) ",
    "test": "['assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7', 'assert max_difference([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15', 'assert max_difference([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/64",
    "prompt": "Write a function to sort a list of tuples using lambda.",
    "canonical_solution": "def subject_marks(subjectmarks):\r\n#subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\r\n subjectmarks.sort(key = lambda x: x[1])\r\n return subjectmarks",
    "test": "[\"assert subject_marks([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])==[('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]\", \"assert subject_marks([('Telugu',49),('Hindhi',54),('Social',33)])==([('Social',33),('Telugu',49),('Hindhi',54)])\", \"assert subject_marks([('Physics',96),('Chemistry',97),('Biology',45)])==([('Biology',45),('Physics',96),('Chemistry',97)])\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/65",
    "prompt": "Write a function of recursion list sum.",
    "canonical_solution": "def recursive_list_sum(data_list):\r\n\ttotal = 0\r\n\tfor element in data_list:\r\n\t\tif type(element) == type([]):\r\n\t\t\ttotal = total + recursive_list_sum(element)\r\n\t\telse:\r\n\t\t\ttotal = total + element\r\n\treturn total",
    "test": "['assert recursive_list_sum(([1, 2, [3,4],[5,6]]))==21', 'assert recursive_list_sum(([7, 10, [15,14],[19,41]]))==106', 'assert recursive_list_sum(([10, 20, [30,40],[50,60]]))==210']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/66",
    "prompt": "Write a python function to count positive numbers in a list.",
    "canonical_solution": "def pos_count(list):\r\n  pos_count= 0\r\n  for num in list: \r\n    if num >= 0: \r\n      pos_count += 1\r\n  return pos_count ",
    "test": "['assert pos_count([1,-2,3,-4]) == 2', 'assert pos_count([3,4,5,-1]) == 3', 'assert pos_count([1,2,3,4]) == 4']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/67",
    "prompt": "Write a function to find the number of ways to partition a set of bell numbers.",
    "canonical_solution": "def bell_number(n):   \r\n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \r\n    bell[0][0] = 1\r\n    for i in range(1, n+1): \r\n        bell[i][0] = bell[i-1][i-1]  \r\n        for j in range(1, i+1): \r\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \r\n    return bell[n][0] ",
    "test": "['assert bell_number(2)==2', 'assert bell_number(10)==115975', 'assert bell_number(56)==6775685320645824322581483068371419745979053216268760300']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/68",
    "prompt": "Write a python function to check whether the given array is monotonic or not.",
    "canonical_solution": "def is_Monotonic(A): \r\n    return (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or\r\n            all(A[i] >= A[i + 1] for i in range(len(A) - 1))) ",
    "test": "['assert is_Monotonic([6, 5, 4, 4]) == True', 'assert is_Monotonic([1, 2, 2, 3]) == True', 'assert is_Monotonic([1, 3, 2]) == False']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/69",
    "prompt": "Write a function to check whether a list contains the given sublist or not.",
    "canonical_solution": "def is_sublist(l, s):\r\n\tsub_set = False\r\n\tif s == []:\r\n\t\tsub_set = True\r\n\telif s == l:\r\n\t\tsub_set = True\r\n\telif len(s) > len(l):\r\n\t\tsub_set = False\r\n\telse:\r\n\t\tfor i in range(len(l)):\r\n\t\t\tif l[i] == s[0]:\r\n\t\t\t\tn = 1\r\n\t\t\t\twhile (n < len(s)) and (l[i+n] == s[n]):\r\n\t\t\t\t\tn += 1\t\t\t\t\r\n\t\t\t\tif n == len(s):\r\n\t\t\t\t\tsub_set = True\r\n\treturn sub_set",
    "test": "['assert is_sublist([2,4,3,5,7],[3,7])==False', 'assert is_sublist([2,4,3,5,7],[4,3])==True', 'assert is_sublist([2,4,3,5,7],[1,6])==False']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/70",
    "prompt": "Write a function to find whether all the given tuples have equal length or not.",
    "canonical_solution": "def find_equal_tuple(Input, k):\r\n  flag = 1\r\n  for tuple in Input:\r\n    if len(tuple) != k:\r\n      flag = 0\r\n      break\r\n  return flag\r\ndef get_equal(Input, k):\r\n  if find_equal_tuple(Input, k) == 1:\r\n    return (\"All tuples have same length\")\r\n  else:\r\n    return (\"All tuples do not have same length\")",
    "test": "[\"assert get_equal([(11, 22, 33), (44, 55, 66)], 3) == 'All tuples have same length'\", \"assert get_equal([(1, 2, 3), (4, 5, 6, 7)], 3) == 'All tuples do not have same length'\", \"assert get_equal([(1, 2), (3, 4)], 2) == 'All tuples have same length'\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/71",
    "prompt": "Write a function to sort a list of elements using comb sort.",
    "canonical_solution": "def comb_sort(nums):\r\n    shrink_fact = 1.3\r\n    gaps = len(nums)\r\n    swapped = True\r\n    i = 0\r\n    while gaps > 1 or swapped:\r\n        gaps = int(float(gaps) / shrink_fact)\r\n        swapped = False\r\n        i = 0\r\n        while gaps + i < len(nums):\r\n            if nums[i] > nums[i+gaps]:\r\n                nums[i], nums[i+gaps] = nums[i+gaps], nums[i]\r\n                swapped = True\r\n            i += 1\r\n    return nums",
    "test": "['assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]', 'assert comb_sort([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]', 'assert comb_sort([99, 15, 13, 47]) == [13, 15, 47, 99]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/72",
    "prompt": "Write a python function to check whether the given number can be represented as difference of two squares or not.",
    "canonical_solution": "def dif_Square(n): \r\n    if (n % 4 != 2): \r\n        return True\r\n    return False",
    "test": "['assert dif_Square(5) == True', 'assert dif_Square(10) == False', 'assert dif_Square(15) == True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/73",
    "prompt": "Write a function to split the given string with multiple delimiters by using regex.",
    "canonical_solution": "import re\r\ndef multiple_split(text):\r\n  return (re.split('; |, |\\*|\\n',text))",
    "test": "[\"assert multiple_split('Forces of the \\\\ndarkness*are coming into the play.') == ['Forces of the ', 'darkness', 'are coming into the play.']\", \"assert multiple_split('Mi Box runs on the \\\\n Latest android*which has google assistance and chromecast.') == ['Mi Box runs on the ', ' Latest android', 'which has google assistance and chromecast.']\", \"assert multiple_split('Certain services\\\\nare subjected to change*over the seperate subscriptions.') == ['Certain services', 'are subjected to change', 'over the seperate subscriptions.']\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/74",
    "prompt": "Write a function to check whether it follows the sequence given in the patterns array.",
    "canonical_solution": "def is_samepatterns(colors, patterns):    \r\n    if len(colors) != len(patterns):\r\n        return False    \r\n    sdict = {}\r\n    pset = set()\r\n    sset = set()    \r\n    for i in range(len(patterns)):\r\n        pset.add(patterns[i])\r\n        sset.add(colors[i])\r\n        if patterns[i] not in sdict.keys():\r\n            sdict[patterns[i]] = []\r\n\r\n        keys = sdict[patterns[i]]\r\n        keys.append(colors[i])\r\n        sdict[patterns[i]] = keys\r\n\r\n    if len(pset) != len(sset):\r\n        return False   \r\n\r\n    for values in sdict.values():\r\n\r\n        for i in range(len(values) - 1):\r\n            if values[i] != values[i+1]:\r\n                return False\r\n\r\n    return True",
    "test": "['assert is_samepatterns([\"red\",\"green\",\"green\"], [\"a\", \"b\", \"b\"])==True ', 'assert is_samepatterns([\"red\",\"green\",\"greenn\"], [\"a\",\"b\",\"b\"])==False ', 'assert is_samepatterns([\"red\",\"green\",\"greenn\"], [\"a\",\"b\"])==False ']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/75",
    "prompt": "Write a function to find tuples which have all elements divisible by k from the given list of tuples.",
    "canonical_solution": "def find_tuples(test_list, K):\r\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\r\n  return (str(res)) ",
    "test": "[\"assert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == '[(6, 24, 12)]'\", \"assert find_tuples([(5, 25, 30), (4, 2, 3), (7, 8, 9)], 5) == '[(5, 25, 30)]'\", \"assert find_tuples([(7, 9, 16), (8, 16, 4), (19, 17, 18)], 4) == '[(8, 16, 4)]'\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/76",
    "prompt": "Write a python function to count the number of squares in a rectangle.",
    "canonical_solution": "def count_Squares(m,n):\r\n    if(n < m):\r\n        temp = m\r\n        m = n\r\n        n = temp\r\n    return ((m * (m + 1) * (2 * m + 1) / 6 + (n - m) * m * (m + 1) / 2))",
    "test": "['assert count_Squares(4,3) == 20', 'assert count_Squares(2,2) == 5', 'assert count_Squares(1,1) == 1']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/77",
    "prompt": "Write a python function to find the difference between sum of even and odd digits.",
    "canonical_solution": "def is_Diff(n): \r\n    return (n % 11 == 0) ",
    "test": "['assert is_Diff (12345) == False', 'assert is_Diff(1212112) == True', 'assert is_Diff(1212) == False']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/78",
    "prompt": "Write a python function to find number of integers with odd number of set bits.",
    "canonical_solution": "def count_With_Odd_SetBits(n): \r\n    if (n % 2 != 0): \r\n        return (n + 1) / 2\r\n    count = bin(n).count('1') \r\n    ans = n / 2\r\n    if (count % 2 != 0): \r\n        ans += 1\r\n    return ans ",
    "test": "['assert count_With_Odd_SetBits(5) == 3', 'assert count_With_Odd_SetBits(10) == 5', 'assert count_With_Odd_SetBits(15) == 8']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/79",
    "prompt": "Write a python function to check whether the length of the word is odd or not.",
    "canonical_solution": "def word_len(s): \r\n    s = s.split(' ')   \r\n    for word in s:    \r\n        if len(word)%2!=0: \r\n            return True  \r\n        else:\r\n          return False",
    "test": "['assert word_len(\"Hadoop\") == False', 'assert word_len(\"great\") == True', 'assert word_len(\"structure\") == True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/80",
    "prompt": "Write a function to find the nth tetrahedral number.",
    "canonical_solution": "def tetrahedral_number(n): \r\n\treturn (n * (n + 1) * (n + 2)) / 6",
    "test": "['assert tetrahedral_number(5) == 35.0', 'assert tetrahedral_number(6) == 56.0', 'assert tetrahedral_number(7) == 84.0']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/81",
    "prompt": "Write a function to zip the two given tuples.",
    "canonical_solution": "def zip_tuples(test_tup1, test_tup2):\r\n  res = []\r\n  for i, j in enumerate(test_tup1):\r\n    res.append((j, test_tup2[i % len(test_tup2)])) \r\n  return (res) ",
    "test": "['assert zip_tuples((7, 8, 4, 5, 9, 10),(1, 5, 6) ) == [(7, 1), (8, 5), (4, 6), (5, 1), (9, 5), (10, 6)]', 'assert zip_tuples((8, 9, 5, 6, 10, 11),(2, 6, 7) ) == [(8, 2), (9, 6), (5, 7), (6, 2), (10, 6), (11, 7)]', 'assert zip_tuples((9, 10, 6, 7, 11, 12),(3, 7, 8) ) == [(9, 3), (10, 7), (6, 8), (7, 3), (11, 7), (12, 8)]']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/82",
    "prompt": "Write a function to find the volume of a sphere.",
    "canonical_solution": "import math\r\ndef volume_sphere(r):\r\n  volume=(4/3)*math.pi*r*r*r\r\n  return volume",
    "test": "['assert volume_sphere(10)==4188.790204786391', 'assert volume_sphere(25)==65449.84694978735', 'assert volume_sphere(20)==33510.32163829113']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/83",
    "prompt": "Write a python function to find the character made by adding all the characters of the given string.",
    "canonical_solution": "def get_Char(strr):  \r\n    summ = 0\r\n    for i in range(len(strr)): \r\n        summ += (ord(strr[i]) - ord('a') + 1)  \r\n    if (summ % 26 == 0): \r\n        return ord('z') \r\n    else: \r\n        summ = summ % 26\r\n        return chr(ord('a') + summ - 1)",
    "test": "['assert get_Char(\"abc\") == \"f\"', 'assert get_Char(\"gfg\") == \"t\"', 'assert get_Char(\"ab\") == \"c\"']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/84",
    "prompt": "Write a function to find the n-th number in newman conway sequence.",
    "canonical_solution": "def sequence(n): \r\n\tif n == 1 or n == 2: \r\n\t\treturn 1\r\n\telse: \r\n\t\treturn sequence(sequence(n-1)) + sequence(n-sequence(n-1))",
    "test": "['assert sequence(10) == 6', 'assert sequence(2) == 1', 'assert sequence(3) == 2']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/85",
    "prompt": "Write a function to find the surface area of a sphere.",
    "canonical_solution": "import math\r\ndef surfacearea_sphere(r):\r\n  surfacearea=4*math.pi*r*r\r\n  return surfacearea",
    "test": "['assert surfacearea_sphere(10)==1256.6370614359173', 'assert surfacearea_sphere(15)==2827.4333882308138', 'assert surfacearea_sphere(20)==5026.548245743669']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/86",
    "prompt": "Write a function to find nth centered hexagonal number.",
    "canonical_solution": "def centered_hexagonal_number(n):\r\n  return 3 * n * (n - 1) + 1",
    "test": "['assert centered_hexagonal_number(10) == 271', 'assert centered_hexagonal_number(2) == 7', 'assert centered_hexagonal_number(9) == 217']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/87",
    "prompt": "Write a function to merge three dictionaries into a single expression.",
    "canonical_solution": "import collections as ct\r\ndef merge_dictionaries_three(dict1,dict2, dict3):\r\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\r\n    return merged_dict",
    "test": "['assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{ \"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\" })=={\\'B\\': \\'Black\\', \\'R\\': \\'Red\\', \\'P\\': \\'Pink\\', \\'G\\': \\'Green\\', \\'W\\': \\'White\\', \\'O\\': \\'Orange\\'}', 'assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{\"L\":\"lavender\",\"B\":\"Blue\"})=={\\'W\\': \\'White\\', \\'P\\': \\'Pink\\', \\'B\\': \\'Black\\', \\'R\\': \\'Red\\', \\'G\\': \\'Green\\', \\'L\\': \\'lavender\\'}', 'assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" },{\"L\":\"lavender\",\"B\":\"Blue\"},{ \"G\": \"Green\", \"W\": \"White\" })=={\\'B\\': \\'Black\\', \\'P\\': \\'Pink\\', \\'R\\': \\'Red\\', \\'G\\': \\'Green\\', \\'L\\': \\'lavender\\', \\'W\\': \\'White\\'}']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/88",
    "prompt": "Write a function to get the frequency of the elements in a list.",
    "canonical_solution": "import collections\r\ndef freq_count(list1):\r\n  freq_count= collections.Counter(list1)\r\n  return freq_count",
    "test": "['assert freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])==({10: 4, 20: 4, 40: 2, 50: 2, 30: 1}) ', 'assert freq_count([1,2,3,4,3,2,4,1,3,1,4])==({1:3, 2:2,3:3,4:3}) ', 'assert freq_count([5,6,7,4,9,10,4,5,6,7,9,5])==({10:1,5:3,6:2,7:2,4:2,9:2}) ']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/89",
    "prompt": "Write a function to find the closest smaller number than n.",
    "canonical_solution": "def closest_num(N):\r\n  return (N - 1)",
    "test": "['assert closest_num(11) == 10', 'assert closest_num(7) == 6', 'assert closest_num(12) == 11']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/90",
    "prompt": "Write a python function to find the length of the longest word.",
    "canonical_solution": "def len_log(list1):\r\n    max=len(list1[0])\r\n    for i in list1:\r\n        if len(i)>max:\r\n            max=len(i)\r\n    return max",
    "test": "['assert len_log([\"python\",\"PHP\",\"bigdata\"]) == 7', 'assert len_log([\"a\",\"ab\",\"abc\"]) == 3', 'assert len_log([\"small\",\"big\",\"tall\"]) == 5']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/91",
    "prompt": "Write a function to check if a substring is present in a given list of string values.",
    "canonical_solution": "def find_substring(str1, sub_str):\r\n   if any(sub_str in s for s in str1):\r\n       return True\r\n   return False",
    "test": "['assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"ack\")==True', 'assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"abc\")==False', 'assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"ange\")==True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/92",
    "prompt": "Write a function to check whether the given number is undulating or not.",
    "canonical_solution": "def is_undulating(n): \r\n\tif (len(n) <= 2): \r\n\t\treturn False\r\n\tfor i in range(2, len(n)): \r\n\t\tif (n[i - 2] != n[i]): \r\n\t\t\treturn False\r\n\treturn True",
    "test": "['assert is_undulating(\"1212121\") == True', 'assert is_undulating(\"1991\") == False', 'assert is_undulating(\"121\") == True']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/93",
    "prompt": "Write a function to calculate the value of 'a' to the power 'b'.",
    "canonical_solution": "def power(a,b):\r\n\tif b==0:\r\n\t\treturn 1\r\n\telif a==0:\r\n\t\treturn 0\r\n\telif b==1:\r\n\t\treturn a\r\n\telse:\r\n\t\treturn a*power(a,b-1)",
    "test": "['assert power(3,4) == 81', 'assert power(2,3) == 8', 'assert power(5,5) == 3125']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/94",
    "prompt": "Write a function to extract the index minimum value record from the given tuples.",
    "canonical_solution": "from operator import itemgetter \r\ndef index_minimum(test_list):\r\n  res = min(test_list, key = itemgetter(1))[0]\r\n  return (res) ",
    "test": "[\"assert index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'\", \"assert index_minimum([('Yash', 185), ('Dawood', 125), ('Sanya', 175)]) == 'Dawood'\", \"assert index_minimum([('Sai', 345), ('Salman', 145), ('Ayesha', 96)]) == 'Ayesha'\"]",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/95",
    "prompt": "Write a python function to find the minimum length of sublist.",
    "canonical_solution": "def Find_Min_Length(lst):  \r\n    minLength = min(len(x) for x in lst )\r\n    return minLength ",
    "test": "['assert Find_Min_Length([[1],[1,2]]) == 1', 'assert Find_Min_Length([[1,2],[1,2,3],[1,2,3,4]]) == 2', 'assert Find_Min_Length([[3,3,3],[4,4,4,4]]) == 3']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/96",
    "prompt": "Write a python function to find the number of divisors of a given integer.",
    "canonical_solution": "def divisor(n):\r\n  for i in range(n):\r\n    x = len([i for i in range(1,n+1) if not n % i])\r\n  return x",
    "test": "['assert divisor(15) == 4 ', 'assert divisor(12) == 6', 'assert divisor(9) == 3']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/97",
    "prompt": "Write a function to find frequency count of list of lists.",
    "canonical_solution": "def frequency_lists(list1):\r\n    list1 = [item for sublist in list1 for item in sublist]\r\n    dic_data = {}\r\n    for num in list1:\r\n        if num in dic_data.keys():\r\n            dic_data[num] += 1\r\n        else:\r\n            key = num\r\n            value = 1\r\n            dic_data[key] = value\r\n    return dic_data\r\n",
    "test": "['assert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])=={1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}', 'assert frequency_lists([[1,2,3,4],[5,6,7,8],[9,10,11,12]])=={1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1,10:1,11:1,12:1}', 'assert frequency_lists([[20,30,40,17],[18,16,14,13],[10,20,30,40]])=={20:2,30:2,40:2,17: 1,18:1, 16: 1,14: 1,13: 1, 10: 1}']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/98",
    "prompt": "Write a function to multiply all the numbers in a list and divide with the length of the list.",
    "canonical_solution": "def multiply_num(numbers):  \r\n    total = 1\r\n    for x in numbers:\r\n        total *= x  \r\n    return total/len(numbers) ",
    "test": "['assert multiply_num((8, 2, 3, -1, 7))==-67.2', 'assert multiply_num((-10,-20,-30))==-2000.0', 'assert multiply_num((19,15,18))==1710.0']",
    "entry_point": "",
    "dataset": "MBPP"
  },
  {
    "task_id": "MBPP/99",
    "prompt": "Write a function to convert the given decimal number to its binary equivalent.",
    "canonical_solution": "def decimal_to_binary(n): \r\n    return bin(n).replace(\"0b\",\"\") ",
    "test": "[\"assert decimal_to_binary(8) == '1000'\", \"assert decimal_to_binary(18) == '10010'\", \"assert decimal_to_binary(7) == '111' \"]",
    "entry_point": "",
    "dataset": "MBPP"
  }
];
        const AUGMENTED_DATA = {
  "function_wise": {
    "HumanEval/0": [
      [
        0.9548801779747009,
        "def has_close_elements(list_of_numbers, threshold):\n    \"\"\"\n    Return True if any two numbers in list_of_numbers are within threshold of\n    each other.\n\n    >>> has_close_elements([1.0, 5.0, 11.0], 1)\n    True\n    >>> has_close_elements([1.0, 5.0, 11.0], 2)\n    False\n    \"\"\"\n    for i in range(len(list_of_numbers)):\n        for j in range(i + 1, len(list_of_numbers)):\n            if abs(list_of_numbers[i] - list_of_numbers[j]) < threshold:\n                return True\n    return False"
      ],
      [
        0.9230537414550781,
        "def HasCloseElements(nums, threshold):\n    \"\"\"\n    :type nums: List[int]\n    :type threshold: int\n    :rtype: bool\n    \"\"\"\n    length = len(nums)\n    for i in range(length - 1):\n        for j in range(i+1, length):\n            if abs(nums[i] - nums[j]) < threshold:\n                return True\n    return False"
      ],
      [
        0.8881452083587646,
        "def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n\"\"\"\n    Find the closest pair of numbers in a list.\n\n    Args:\n        numbers (List[float]): A list of numbers.\n\n    Returns:\n        Tuple[float, float]: A tuple containing the closest pair of numbers.\n\n    Raises:\n        ValueError: If the list contains less than two numbers.\n\n    Example:\n        >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0])\n        (3.0, 4.0)\n    \"\"\"\n\n    # Ensure the length of the list is at least 2\n    if len(numbers) < 2:\n        raise ValueError(\"The provided list must contain at least two numbers.\")\n\n    # Sort the list in ascending order\n    sorted_numbers = sorted(numbers)\n\n    # Initialize minimum difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i+1] - sorted_numbers[i]\n\n        # Update minimum difference and closest pair if necessary\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n\n    return closest_pair"
      ],
      [
        0.8821541666984558,
        "def has_duplicate_elements(numbers_set):\n    \"\"\"\n    Check if a list contains duplicate elements.\n    Args:\n        numbers_set(list): List of numbers\n    Returns:\n        bool: True if the list contains duplicate elements, False otherwise\n    \"\"\"\n    unique_elements = set()\n    for number in numbers_set:\n        if number in unique_elements:\n            return True\n        unique_elements.add(number)\n    return False"
      ]
    ],
    "HumanEval/1": [
      [
        0.947476863861084,
        "def separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    This function is designed to process a string that contains multiple nested groups of round, square, and curly brackets, which are frequently encountered in mathematical computations. \n    Your task is to segregate these bracket groups into separate string segments and return them in the form of a list.\n    Each distinct group is balanced (every opening brace has a corresponding closing brace) and does not nest within another group.\n    Disregard any white spaces present in the input string.\n    >>> separate_paren_groups(' ( ) (( )) {[()]} (( )( )) ')\n    ['()', '(())', '{[()]}', '(()())']\n    \"\"\"\n    # remove white spaces\n    paren_string = paren_string.replace(\" \", \"\")\n    start = ['(', '{', '[']\n    end = [')', '}', ']']\n    groups = []\n    temp_string = ''\n    counter = 0\n\n    for char in paren_string:\n        if char in start:\n            counter += 1\n            temp_string += char\n        elif char in end:\n            counter -= 1\n            temp_string += char\n            if counter == 0:\n                groups.append(temp_string)\n                temp_string = ''\n    return groups"
      ],
      [
        0.9307730197906494,
        "def separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    \"\"\"\n    stack = []\n    group = []\n    result = []\n    for char in paren_string:\n        if char == ' ':\n            continue\n        if char == '(':\n            stack.append(char)\n            group.append(char)\n        if char == ')':\n            stack.pop()\n            group.append(char)\n            if not stack:\n                result.append(''.join(group))\n                group = []\n    return result"
      ],
      [
        0.9280555248260498,
        "def separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    Given a string containing parentheses, brackets, and curly braces,\n    return a list of strings, where each string is a group of matching\n    parentheses, brackets, and curly braces.\n    \n    >>> separate_paren_groups('(hello) (world) (foo [bar])')\n    ['(hello)', '(world)', '(foo [bar])']\n    >>> separate_paren_groups('(hello) (world) (foo [bar]) {hello {world}}')\n    ['(hello)', '(world)', '(foo [bar])', '{hello {world}}']\n    \"\"\"\n    replacements = {\n        '(': ' ( ',\n        ')': ' ) ',\n        '[': ' [ ',\n        ']': ' ] ',\n        '{': ' { ',\n        '}': ' } ',\n    }\n    for old, new in replacements.items():\n        paren_string = paren_string.replace(old, new)\n    words = paren_string.split()\n    stack = []\n    groups = []\n    for word in words:\n        if word in '([{':\n            stack.append([word])\n        else: # word in ')]}'\n            opener = {'(': ')', '[': ']', '{': '}'}[stack[-1][-1]]\n            if word != opener: # word doesn't match the opener, so create a new group\n                stack.append([])\n            stack[-1].append(word)\n            if len(stack[-1]) % 2 == 0: # the group is now complete\n                groups.append(''.join(stack.pop()))\n    return groups"
      ],
      [
        0.9271187782287598,
        "def separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    \"\"\"\n    paren_string = paren_string.replace(\" \", \"\")\n    brackets = {'(': ')', '{': '}', '[': ']', '<': '>'}\n    opening_brackets = set([\n        '(',\n        '{',\n        '[',\n        '<'\n    ])\n    closing_brackets = set([\n        ')',\n        '}',\n        ']',\n        '>'\n    ])\n    stack = []\n    groups = []\n    current_group = ''\n    for ch in paren_string:\n        if ch in opening_brackets:\n            stack.append(ch)\n        elif ch in closing_brackets:\n            if not stack or brackets[stack[-1]] != ch:\n                stack = []\n                current_group = ''\n            else:\n                current_group += stack.pop() + ch\n                if not stack:\n                    groups.append(current_group)\n                    current_group = ''\n    return groups"
      ],
      [
        0.9206287860870361,
        "def separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    \"\"\"\n    stack = []\n    groups = []\n    group = \"\"\n    for ch in paren_string.replace(' ', ''):\n        if ch in ['(', '{', '[']:\n            if stack:\n                group += ch\n            stack.append(ch)\n        elif ch in [')', '}', ']']:\n            group += ch\n            stack.pop()\n            if not stack:\n                groups.append(group)\n                group = \"\"\n    return groups"
      ],
      [
        0.9196007251739502,
        "def separate_paren_groups(paren_string: str, complete_sets: bool = True) -> List[str]:\n    \"\"\"\n    Separate a string containing nested parentheses into a list of strings, each of which contains a single set of parentheses.\n    \n    Args:\n        paren_string (str): The string to be separated.\n        complete_sets (bool): If True, only return complete sets of parentheses. If False, return incomplete sets as well.\n    \n    Returns:\n        List[str]: A list of strings, each of which contains a single set of parentheses.\n    \"\"\"\n    stack = []\n    result = []\n    last_open = {}\n    \n    brackets = {'(':')', '[':']', '{':'}'}\n    \n    for index, char in enumerate(paren_string):\n        if char in brackets.keys():\n            # Char is an open bracket\n            stack.append(index)\n            last_open[brackets[char]] = len(stack)-1\n        elif char in brackets.values():\n            # Char is a close bracket\n            if stack and last_open.get(char, -1) == len(stack) - 1:\n                start = stack.pop()\n                result.append(paren_string[start:index+1])\n                last_open.pop(char)\n            elif not complete_sets:\n                result.append(char)\n        elif not char.isspace():\n            # Char is not a bracket or whitespace; treat it as part of the last group\n            if result:\n                result[-1] += char\n            else:\n                result.append(char)\n\n    if not complete_sets:\n        # Include any remaining unbalanced brackets as separate groups\n        while stack:\n            start = stack.pop()\n            result.append(paren_string[start:])\n    return result"
      ],
      [
        0.9193819761276245,
        "def separate_paren_groups(paren_string: str, complete_sets: bool = True) -> List[str]:\n    \"\"\"\n    Separates a string containing nested parentheses into a list of strings, each containing a single set of parentheses.\n\n    Args:\n        paren_string (str): The string containing nested parentheses.\n        complete_sets (bool, optional): Whether to consider incomplete sets as separate groups. Defaults to True.\n\n    Returns:\n        List[str]: A list of strings, each containing a single set of parentheses.\n    \"\"\"\n    bracket_pairs = {')': '(', ']': '[', '}': '{'}\n    open_brackets = set(bracket_pairs.values())\n    close_brackets = set(bracket_pairs.keys())\n\n    stack = []\n    output = []\n\n    group = ''\n    for char in paren_string:\n        if char.isspace():\n            continue  # Skip spaces\n\n        if char in open_brackets:\n            if group:  # If there's already a group started, we push it to the stack for later finalizing\n                stack.append(group)\n                group = ''\n            group += char\n        elif char in close_brackets:\n            if not stack or bracket_pairs[char] != stack[-1][-1]: \n                if complete_sets:  # If the bracket isn't closing the correct type, we consider it as a separate group\n                    output.append(group)\n                    group = ''\n                else:\n                    group += char\n            else: \n                group += char  # else we close the group and append it to output list\n                if len(stack[-1]) == 1:\n                    output.append(stack.pop() + group)\n                else:\n                    stack[-1] += group\n                group = ''\n        else:\n            group += char  # If the character isn't a bracket, we simply add it to the group\n\n    if group: \n        output.append(group)  \n\n    return output"
      ],
      [
        0.9159921407699585,
        "def separate_paren_groups(paren_string: str, inner_paren: bool = False) -> List[str]:\n    \"\"\"\n    Separate a string of nested parentheses into a list of strings, each of which is a group of parentheses.\n    \n    Args:\n        paren_string (str): A string containing nested parentheses.\n        inner_paren (bool): Whether to include inner parentheses in the result.\n    \n    Returns:\n        List[str]: A list of strings, each of which is a group of parentheses.\n    \n    Raises:\n        ValueError: If the parentheses are not properly matched.\n    \n    Example:\n        >>> separate_paren_groups('((a)(b))')\n        ['\"\"\"\n    stack = []\n    result = []\n\n    for char in paren_string:\n        if char in ['(', '[']:\n            stack.append(char)\n        elif char in [')', ']']:\n            group = []\n            last = stack.pop()\n            while last not in ['(', '[']:\n                group = [last] + group\n                last = stack.pop()\n            if char==')' and last=='(' or char==']' and last=='[':\n                group = [last] + group + [char]\n            else:\n                raise ValueError('Mismatched parentheses')\n            if inner_paren and stack and stack[-1] in ['(', '[']:\n                result.append(''.join(stack[-1]+ ''.join(group) + stack[-1]))\n                stack.append(char)\n            else:\n                stack += group\n        else:  # discard other characters\n            continue\n\n    if stack:\n        raise ValueError('Unmatched parentheses')\n    return result"
      ]
    ],
    "HumanEval/2": [
      [
        0.9296060800552368,
        "def extract_integer(number: float) -> int:\n    \"\"\" Upon providing a positive floating-point number, it can invariably be segregated into\n    an integer component (the largest integer that is less than the input number) and the decimal\n    component (the remainder which is always less than 1).\n\n    Deliver the integer part of the number.\n    >>> extract_integer(4.7)\n    4\n    \"\"\"\n    return int(number)"
      ],
      [
        0.926221489906311,
        "def extract_number(number: float, precision: int) -> float:\n    \"\"\" Given a float, it breaks down into\n    an integer component (largest integer less or equal to the number) and decimals\n    (remainder always less than 1 and greater than -1).\n\n    The function should return the number preserving precision up to a specified decimal point.\n    \"\"\"\n    format_string = \"{:.\" + str(precision) + \"f}\"\n    formatted_number = format_string.format(number)\n    return float(formatted_number)"
      ],
      [
        0.921897292137146,
        "def extract_integer(number: float, precision: int) -> float:\n    \"\"\" Given a float, it breaks down into\n    an integer component (largest integer less or equal to the number) and decimals\n    (remainder always less than 1 and greater than -1).\n\n    The function should return the integer part of the number preserving precision up to a specified decimal point.\n    >>> extract_integer(4.70, 2)\n    4.70\n    >>> extract_integer(-3.200, 3)\n    -3.200\n    \"\"\"\n    decimal_point = Decimal(10) ** -precision  # Defines the decimal point up to the specified precision\n\n    if isinstance(number, (int, float)):\n        number = Decimal(number)  # Create a Decimal instance of the number\n    elif isinstance(number, str):\n        number = Decimal(number.replace(',', '.'))\n\n    return float(number.quantize(decimal_point, rounding=ROUND_DOWN))  # Return the number as a float, rounded to the specified precision"
      ],
      [
        0.9069119095802307,
        "def extract_integer(number: float) -> int:\n    \"\"\" Given a float, it separates into an integer component (\n    the largest integer less than or equal to the given number) and decimals (\n    remaining part always less than 1 and greater than -1).\n    \n    If the input is zero, return zero.\n    If the input number is very large, return an error message instead.\n    Provide the integer segment of the positive or negative number.\n    >>> extract_integer(4.7)\n    4\n    >>> extract_integer(-3.2)\n    -4\n    >>> extract_integer(0)\n    0\n    >>> extract_integer(1.7e308)\n    'Error: Number too large.'\n    \"\"\"\n    \n    if number == 0:\n        return 0\n    elif number == float('inf') or number == -float('inf'):\n        return 'Error: Number too large.'\n    else:\n        return math.floor(number)"
      ],
      [
        0.9061727523803711,
        "def extract_integer(number: float) -> int:\n    \"\"\"Extract the integer part of a number, regardless of whether it is positive or negative.\n    \"\"\"\n    if number >= 0:\n        return math.floor(number)\n    else:\n        return math.ceil(number)"
      ],
      [
        0.9047039747238159,
        "def calculate_integer_part(number: float) -> int:\n    \"\"\"\n    Calculate the integer part of a number.\n    \n    Args:\n        number (float): The number to calculate the integer part of.\n    \n    Returns:\n        int: The integer part of the number.\n    \"\"\"\n    if number >= 0:\n        return int(number)\n    else:\n        return int(number) if number == int(number) else int(number) - 1"
      ],
      [
        0.9013521075248718,
        "def extract_integer(number: float) -> int:\n    \"\"\"\n    Extract integer part from a float number.\n    \n    Args:\n        number (float): number to extract integer part from\n    \n    Returns:\n        int: integer part of the number\n    \"\"\"\n    return math.floor(number)"
      ],
      [
        0.9005276560783386,
        "def extract_integer(number: float, round: bool = True, precision: int = 2, method: str = 'traditional') -> 'int or tuple':\n    \"\"\"\n    <bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos><bos>\"\"\"\n    mapping = {\n        'traditional': ROUND_HALF_UP,\n        'bankers': ROUND_HALF_EVEN,\n        'statistician': ROUND_HALF_DOWN,\n    }\n\n    rounding_method = mapping.get(method, ROUND_HALF_UP)\n\n    dec = Decimal(str(number))\n    quotient, remainder = divmod(dec, 1)\n\n    if not round:\n        return int(quotient), float(remainder), False\n\n    rounded_remainder = remainder.quantize(Decimal(10) ** -precision, rounding_method)\n    if rounded_remainder >= Decimal('0.5'):\n        rounded_remainder -= 1\n        quotient += 1\n\n    return int(quotient), float(rounded_remainder), bool(quotient)"
      ]
    ],
    "HumanEval/3": [
      [
        0.9690217971801758,
        "def below_zero(operations: List[int]) -> bool:\n    \"\"\"\n    You're provided with a set of banking account transactions which consist of \n    deposit and withdrawal actions, starting from a null balance. Your duty is to find \n    if at any stage the account balance dips below zero, in which case the function is \n    expected to return True. Otherwise, the requirement is that it should yield False.\n\n    Example usages:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n    \n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False"
      ],
      [
        0.9642263650894165,
        "def below_zero(operations: List[int]) -> bool:\n    \"\"\"The task at hand involves a series of banking transactions embedded in an account. These transactions comprise both credit and debit entries, all commencing from a balance of zero. The task assigned to you is to detect any instance where the account balance slides below zero, and as a consequential response, your function must yield 'True'. Conversely, in situations where this condition is not met, your function should produce 'False'.\n\n    Prototype applications:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False"
      ],
      [
        0.9579044580459595,
        "def below_zero(operations: List[int]) -> bool:\n    \"\"\"\n    Given a list of operations, return True if any balance goes below zero, False otherwise.\n    \n    >>> below_zero([1, 2, -3])\n    False\n    >>> below_zero([1, 2, -4])\n    True\n    \"\"\"\n    balance = 0\n    for op in operations:\n        balance += op # Correcting from 'balance + op' to 'balance += op' for correct operation\n        if balance < 0:\n            return True\n    return False"
      ],
      [
        0.9559739828109741,
        "def below_zero(operations: List[int], case_insensitive: bool = False) -> bool:\n    \"\"\"The function consumes a queue of deposit and withdrawal activities for a financial account inaugurating with a zero equilibrium. Your task involves identifying if the account's balance descends below zero at any juncture. If it does, the function must return True; on the contrary, it should return False. An optional case_insensitive flag exists that, when set to true, will return True when equilibrium touches zero.\n\n    Examples:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    >>> below_zero([1, 2, -3], True)\n    True\n    \"\"\"\n    balance = 0\n    for op in operations:\n        balance += op\n        if case_insensitive and balance <= 0:\n            return True\n        elif not case_insensitive and balance < 0:\n            return True\n    return False"
      ],
      [
        0.9518480896949768,
        "def below_zero(operations: List[int]) -> Tuple[bool, int]:\n    \"\"\"Presented with a sequence detailing credit and debit transactions in an account that initiates at zero balance, the assignment requires ascertaining whether the balance dips into negative territory during any operation. The function should immediately return True if it does, and False otherwise, also yielding the final account balance.\n\n    Examples:\n    >>> below_zero([1, 2, 3])\n    (False, 6)\n    >>> below_zero([1, 2, -4, 5])\n    (True, 4)\n    \"\"\"\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True, balance\n    return False, balance"
      ],
      [
        0.9487335681915283,
        "def below_zero(operations: List[int]) -> Tuple[bool, int]:\n    \"\"\"\n    Given a list of integers representing deposits and withdrawals from a bank account initialized at zero,\n    determine if the balance ever falls negative. If it does, return True. Otherwise, return False. The function should also return the final balance.\n    \"\"\"\n    balance = 0\n    below_zero = False\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            below_zero = True\n\n    return below_zero, balance"
      ],
      [
        0.9449097514152527,
        "def below_zero(operations: List[int]) -> bool:\n    \"\"\"\n    Given a list of operations, return True if any balance goes below zero, False otherwise.\n    Each operation is either an integer or a list of integers.\n    If an integer, it represents a deposit of that amount of money.\n    If a list of integers, it represents a withdrawal of the amount of money in the first element,\n    and a deposit of the amount of money in the second element.\n    For example, [10, 20] represents a withdrawal of 10 and a deposit of 20.\n    The initial balance is zero.\n    \n    >>>\"\"\"\n    balance = 0\n    for op in operations:\n        balance += op  # this line was incorrect, this should be balance += op\n        if balance < 0:\n            return True\n    return False"
      ],
      [
        0.9440503120422363,
        "def below_zero(operations: List[Union[int, float]], handle_float: bool = False, balance_limit: int = 10):\n    \"\"\"\n    Given a list of deposit and withdrawal operations on a bank account starting with a balance of zero, \n    determine if the balance ever goes below zero during the operations and return True if it does. If not, return False. \n    Include an optional handle_float flag to cater for floating point numbers. The function should prohibit negative deposits \n    and withdrawals that exceed the balance limit.\n\n    Examples:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    >>> below_zero([1, 2, -3.5], True)\n    True\n    \"\"\"\n    balance = 0\n\n    for op in operations:\n        if (not handle_float and isinstance(op, float)) or op < 0 or op > balance_limit:\n            raise ValueError('Invalid operation: ' + str(op))\n        \n        balance += op\n\n        if balance < 0:\n            return True\n\n    return False"
      ],
      [
        0.9415876269340515,
        "def below_zero(operations: List[Tuple[str, int]], case_insensitive: bool = False) -> bool:\n    \"\"\"\n    Given a list of operations and amounts, return True if any operation makes the balance go below zero.\n    \n    >>> below_zero([('deposit', 100), ('withdrawal', 200)])\n    False\n    >>> below_zero([('deposit', 100), ('withdrawal', 200), ('deposit', 100)])\n    True\n    >>> below_zero([('deposit', 100), ('withdrawal', 200), ('deposit', 100), ('withdrawal', 200)])\n    False\n    \"\"\"\n    balance = 0\n    for op, amount in operations:\n        if case_insensitive:\n            op = op.lower()\n        if op == 'deposit':\n            balance += amount\n        elif op == 'withdrawal':\n            balance -= amount\n            \n        if balance < 0:\n            return True\n            \n    return False"
      ],
      [
        0.9412527084350586,
        "def below_zero(operations: List[Union[int, str]], case_insensitive: bool = False) -> bool:\n    \"\"\"\n    Given are deposit and withdrawal operations on a bank account which starts from zero balance. The operations may include integers or string representations of integers. Determine if the account balance dips below zero at any point. If it does, return True, otherwise, return False. If the case_insensitive flag is triggered, return True even when the balance is exactly zero.\n\n    Examples:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, \"-4\", 5])\n    True\n    >>> below_zero([1, \"2\", -3], True)\n    True\n    \"\"\"\n\n    balance = 0\n\n    for op in operations:\n        balance += int(op) # convert string to int if required and update the balance\n\n    if balance < 0 or (case_insensitive and balance == 0):\n        return True\n\n    return False"
      ]
    ],
    "HumanEval/4": [
      [
        0.9453587532043457,
        "def meanAbsoluteDeviation(numbers):\n    \"\"\"\n    This function calculates the mean absolute deviation of a list of numbers.\n    \n    Args:\n        numbers (list): A list of numbers.\n    \n    Returns:\n        float: The mean absolute deviation of the list of numbers.\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    differences = [abs(number - mean) for number in numbers]\n    mad = sum(differences) / len(numbers)\n    return mad"
      ],
      [
        0.9131484031677246,
        "def calculate_standard_deviation(numbers):\n    \"\"\"\n    Calculate the standard deviation of a list of numbers.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        float: The standard deviation of the numbers.\n    \"\"\"\n    n = len(numbers)\n    mean = sum(numbers) / n\n\n    squared_differences = [(x - mean) ** 2 for x in numbers]\n    sum_squared_differences = sum(squared_differences)\n\n    variance = sum_squared_differences / n\n    standard_deviation = variance ** 0.5\n\n    return standard_deviation"
      ],
      [
        0.9122655391693115,
        "def calculate_average_without_outliers(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate the average of a list of numbers, excluding outliers.\n\n    Args:\n        numbers (List[float]): List of numbers.\n\n    Returns:\n        float: Average of the numbers, excluding outliers.\n    \"\"\"\n    median = np.median(numbers)\n    mad = np.median(np.abs(numbers - median))\n    threshold = 3.5 * mad  # Adjust this threshold multiplier as needed\n    filtered_numbers = [x for x in numbers if abs(x - median) < threshold]\n    return np.mean(filtered_numbers)"
      ],
      [
        0.9111641049385071,
        "def calculate_standard_deviation(numbers):\n    \"\"\"\n    Calculate the standard deviation of a list of numbers.\n    \n    Args:\n        numbers (list): A list of numbers.\n    \n    Returns:\n        float: The standard deviation of the numbers.\n    \"\"\"\n    n = len(numbers)\n    \n    # Step 1: Calculate the mean\n    total = 0\n    for num in numbers:\n        total += num\n    mean = total / n\n    \n    # Step 2: Calculate the sum of squared differences\n    sum_of_squared_diff = 0\n    for num in numbers:\n        diff = num - mean\n        squared_diff = diff * diff\n        sum_of_squared_diff += squared_diff\n    \n    # Step 3: Divide by the total number of numbers\n    variance = sum_of_squared_diff / n\n    \n    # Step 4: Take the square root\n    std_deviation = math.sqrt(variance)\n    \n    return std_deviation"
      ],
      [
        0.9087467193603516,
        "def calculate_standard_deviation(numbers):\n    \"\"\"\n    Calculate the standard deviation of a list of numbers.\n    \n    Args:\n        numbers (list): A list of numbers.\n    \n    Returns:\n        float: The standard deviation of the list of numbers.\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    sum_of_squared_differences = sum([(number - mean) ** 2 for number in numbers])\n    variance = sum_of_squared_differences / len(numbers)\n    standard_deviation = math.sqrt(variance)\n    return standard_deviation"
      ],
      [
        0.9078660607337952,
        "def calculate_standard_deviation(numbers):\n    \"\"\"\n    Calculate the standard deviation of a list of numbers.\n    \n    Args:\n        numbers (list): A list of numbers.\n        \n    Returns:\n        float: The standard deviation of the numbers.\n    \"\"\"\n    n = len(numbers)\n    mean = sum(numbers) / n\n    squared_diff_sum = sum((x - mean) ** 2 for x in numbers)\n    variance = squared_diff_sum / n\n    standard_deviation = variance ** 0.5\n    return standard_deviation"
      ]
    ],
    "HumanEval/5": [
      [
        0.9667088985443115,
        "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Embeds 'delimeter' among consecutive elements of `numbers` and acknowledges absolute values of negative delimeter.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], -2)\n    [1, 2, 3]\n    \"\"\"\n    result = []\n    for i, num in enumerate(numbers):\n        if delimeter < 0 and i == abs(delimeter):\n            continue\n        result.append(num)\n        if i != len(numbers) - 1:\n            result.append(abs(delimeter))\n    return result"
      ],
      [
        0.9610081315040588,
        "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"\n    Inserts a delimeter between each number in a list of numbers.\n    \n    >>> intersperse([1, 2, 3], 0)\n    [1, 0, 2, 0, 3]\n    >>> intersperse([1, 2, 3], 10)\n    [1, 10, 2, 10, 3]\n    >>> intersperse([], 10)\n    []\n    >>> intersperse([1, 2, 3], -10)\n    [1, 2,\"\"\"\n    # Manage negative delimeter\n    if delimeter < 0:\n        return numbers\n    \n    result = []\n    # Only integrate the delimeter if it is nonnegative\n    for num in numbers[:-1]:\n        result.append(num)\n        result.append(delimeter)\n    \n    # Remember to append the last number\n    if numbers:\n        result.append(numbers[-1])\n    \n    return result"
      ],
      [
        0.9591704607009888,
        "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Inserts 'delimeter' between successive units of `numbers` while recognising the absolute values of any negative delimeter.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], -2)\n    [1, 2, 3]\n    \"\"\"\n    result = []\n    if delimeter >= 0:  # If the delimiter is positive or 0\n        for i, num in enumerate(numbers):\n            result.append(num)\n            # Avoid adding an extra delimeter at the end\n            if i < len(numbers) - 1:\n                result.append(delimeter)\n    else:  # If the delimiter is negative\n        bypass_count = abs(delimeter)\n        for i, num in enumerate(numbers):\n            result.append(num)\n            if (i + 1) % (bypass_count + 1) == 0 and i < len(numbers) - 1:\n                result.append(-delimeter)\n    return result"
      ],
      [
        0.9590618014335632,
        "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function inserts a number 'delimeter' between each consectute elements of the input list `numbers` and deals with scenarios where the delimeter is negative.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], -2)\n    [1, 2, 3]\n    \"\"\" \n    result = []\n    abs_delimeter = abs(delimeter)\n    for i in range(len(numbers)):\n        result.append(numbers[i])\n        if i != len(numbers)-1:\n            # Exempt the index locations that matches absolute of negative delimeter\n            if i+1 != abs_delimeter:\n                result.append(delimeter)\n    return result"
      ],
      [
        0.9553048014640808,
        "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function is capable of interlaying the 'delimeter' between consecutive elements encountered within the list `numbers`, and manages situations where the delimeter comes with a negative sign.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], -2)\n    [1, 2, 3]\n    \"\"\"\n    if delimeter < 0:\n        excluded_index = abs(delimeter)  # Indices to be excluded\n    else:\n        excluded_index = None\n    \n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1 and i+1 != excluded_index:  # Do not append delimiter after the last number and at the excluded index\n            result.append(delimeter)\n    return result"
      ],
      [
        0.9550877809524536,
        "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"\n    Inserts a delimiter between each number in a list.\n    \n    Args:\n        numbers (List[int]): A list of integers.\n        delimeter (int): An integer to be inserted between each number in the list.\n    \n    Returns:\n        List[int]: A list of integers with the delimiter inserted between each number.\n    \"\"\"\n    if delimeter >= 0:\n        # append delimeter after each number except for the last one\n        result = [val for num in numbers for val in (num, delimeter)]\n        if result:\n            # remove last element if non-empty\n            result.pop()\n        return result\n    else:\n        # if delimeter is negative, get its absolute value\n        abs_delimeter = abs(delimeter)\n        result = []\n        for i, num in enumerate(numbers):\n            result.append(num)\n            # do not append delimeter at the indexes specified by abs_delimeter\n            if (i+1)%abs_delimeter != 0 and i+1 != len(numbers):\n                result.append(abs(delimeter))\n        return result"
      ],
      [
        0.9532458782196045,
        "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"\n    Given a list of numbers intersperse the delimeter between each number.\n    \n    Args:\n        numbers (List[int]): a list of numbers\n        delimeter (int): the delimeter to intersperse between the numbers\n    \n    Returns:\n        List[int]: a list of numbers with the delimeter interspersed between them\n    \"\"\"\n    # if the list is empty return immediately\n    if not numbers:\n        return []\n        \n    if delimeter > 0:\n        # intersperse the values\n        interspersed_numbers = [numbers[0]]  \n        for num in numbers[1:]:\n            interspersed_numbers.extend([delimeter, num])\n    else:  # delimeter < 0\n        abs_delimeter = abs(delimeter)  \n        interspersed_numbers = [numbers[0]]\n        for index, num in enumerate(numbers[1:]):\n            # skip the indices that are multiples of the absolute value of the delimeter\n            if (index + 1) % abs_delimeter != 0:\n                interspersed_numbers.extend([delimeter, num])\n            else:\n                interspersed_numbers.append(num)\n        \n    return interspersed_numbers"
      ],
      [
        0.9512909650802612,
        "def intersperse(numbers: List[Union[int, List[int]]], delimeter: Union[int, float]) -> List[int]:\n    \"\"\"\n    Introduce the 'delimeter' digit amongst every couple of sequential numbers in the supplied 'numbers' list.\n    Moreover, make sure to manage scenarios that involve a negative or non-integer `delimeter`.\n    Also handles nested list within numbers list.\n    For example:\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], -2)\n    [1, 2, 3]\n    >>> intersperse([1, [2, 3]], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], 4.5)\n    [1, 2, 3]\n    \"\"\"\n    outcome = []\n    flattened_numbers = []\n\n    # This block is to handle nested arrays and flatten them.\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimeter))  # recursive flatten\n        else:\n            flattened_numbers.append(num)\n\n    # This block is to place the delimeter (if it's a non-negative integer) in between the numbers.\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i < len(flattened_numbers) - 1 and isinstance(delimeter, int) and delimeter >= 0:\n            outcome.append(delimeter)\n\n    return outcome"
      ],
      [
        0.9498500823974609,
        "def intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"\n    Inserts a delimiter between each pair of numbers in a list.\n    \n    >>> intersperse([1, 2, 3], 0)\n    [1, 0, 2, 0, 3]\n    >>> intersperse([1, 2, 3], 1)\n    [1, 1, 2, 1, 3]\n    >>> intersperse([1, 2, 3], -1)\n    [1, -1, 2, -1, 3]\n    \"\"\"\n    if delimiter < 0:\n        skip_position = -delimiter - 1\n        new_list = numbers[:]\n        for idx, num in enumerate(numbers[:-1]):\n            insert_position = 2*idx + 1\n            if insert_position != skip_position:\n                new_list.insert(insert_position, delimiter)\n        return new_list\n    else:\n        new_list = numbers[:]\n        for idx, num in enumerate(numbers[:-1]):\n            new_list.insert(2*idx + 1, delimiter)\n        return new_list"
      ],
      [
        0.9478698372840881,
        "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"\n    Inserts a delimeter between each element in a list.\n    \n    Args:\n        numbers (List[int]): The list of numbers to intersperse.\n        delimeter (int): The delimeter to insert between each element.\n    \n    Returns:\n        List[int]: The interspersed list.\n    \"\"\"\n    result = []\n    \n    # Get absolute value of delimeter if it's negative\n    if delimeter < 0:\n        delimeter = abs(delimeter)\n        \n    # Only add the delimeter if the index isn't a multiple of the delimeter\n    for i in range(len(numbers)):\n        result.append(numbers[i])\n        if (i+1) % delimeter != 0 and i != len(numbers) - 1:\n            result.append(delimeter)\n    return result"
      ]
    ],
    "HumanEval/6": [
      [
        0.9394577741622925,
        "def parse_nested_parens(paren_string):\n    \"\"\"\n    Given a string with nested parentheses, return a list of the depths of each nested group of parentheses.\n    For example, for the string \"(1+(2*3)+((8)/4))+1\", the list returned should be [1, 2, 3, 3, 2, 1].\n    \"\"\"\n    depths = []\n    paren_groups = paren_string.split(\" \") # splitting the string by space\n\n    for paren_group in paren_groups:\n        current_depth = 0\n        max_depth = 0\n        for i in range(len(paren_group)):\n            if paren_group[i] == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif paren_group[i] == ')':\n                current_depth -= 1\n\n        depths.append(max_depth) # adding max_depth to the list\n\n    return depths"
      ],
      [
        0.9255538582801819,
        "def nested_parentheses(s):\n    \"\"\"\n    >>> nested_parentheses('((()))')\n    [2, 2, 2, 2]\n    >>> nested_parentheses('((())) ()')\n    [2, 2, 2, 2, 0, 0]\n    >>> nested_parentheses('()()()()')\n    [1, 1, 1, 1]\n    >>> nested_parentheses('(()) ()')\n    [1, 1, 0, 0]\n    >>> nested_parentheses('()()')\n    [1, 1,\"\"\"\n    result = []\n    for group in s.split(' '):\n        count, max_count = 0, 0\n        for ch in group:\n            if ch == '(':\n                count += 1\n                max_count = max(max_count, count)\n            elif ch == ')':\n                count -= 1\n        result.append(max_count)\n    return result"
      ],
      [
        0.9222789406776428,
        "def parse_nested_parens_and_validate(s: str) -> list:\n    \"\"\"\n    \"\"\"\n    groups = s.split()\n    depths = []\n    for group in groups:\n        if not isValid(group):\n            raise Exception('Invalid group of parentheses in input string: ' + group)\n        depth = 0\n        max_depth = 0\n        for char in group:\n            if char == '(':\n                depth += 1\n                if depth > max_depth:\n                    max_depth = depth\n            elif char == ')':\n                depth -= 1\n        depths.append(max_depth)\n    return depths"
      ],
      [
        0.9049440622329712,
        "def maxParenthesesDepth(s: str) -> int:\n    \"\"\"\n    Given a string containing just the characters '(' and ')', find the maximum depth of nested parentheses in the string.\n\n    Example 1:\n    Input: s = \"(1+(2*3)+((8)/4))+1\"\n    Output: 3\n    Explanation: The maximum depth is 3, because the deepest level of nested parentheses is 3.\n\n    Example 2:\n    Input: s = \"(1)+((2))+(((3)))\"\n    Output: 3\n\n    Example 3:\n    Input: s = \"1+(2*3)/(2-1\"\"\"\n    max_depth = 0\n    current_depth = 0\n\n    for char in s:\n        if char == '(':\n            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n        elif char == ')':\n            current_depth -= 1\n\n    return max_depth"
      ]
    ],
    "HumanEval/7": [
      [
        0.9311645030975342,
        "def filter_strings_by_substring(string_list, substring):\n    \"\"\"\n    Filter a list of strings based on a given substring.\n\n    Args:\n        string_list (list): List of strings.\n        substring (str): Substring to filter by.\n\n    Returns:\n        list: List of strings containing the given substring.\n    \"\"\"\n    filtered_list = [s for s in string_list if substring in s]\n    return filtered_list"
      ],
      [
        0.9279636740684509,
        "def filter_strings(lst, substring):\n    \"\"\"\n    Filter a list of strings based on a given substring.\n\n    Args:\n        lst (list): List of strings.\n        substring (str): Substring to filter the list.\n\n    Returns:\n        list: List of strings containing the given substring.\n    \"\"\"\n    filtered_lst = []\n    for string in lst:\n        if substring in string:\n            filtered_lst.append(string)\n    return filtered_lst"
      ],
      [
        0.9256117343902588,
        "def substring_filter(string_list, substring):\n    \"\"\"\n    Filter a list of strings based on a given substring.\n\n    Args:\n        string_list (list): A list of strings.\n        substring (str): A substring to filter the list by.\n\n    Returns:\n        list: A list of strings containing the given substring.\n    \"\"\"\n    filtered_list = []\n    for string in string_list:\n        if substring in string:\n            filtered_list.append(string)\n    return filtered_list"
      ],
      [
        0.9248046278953552,
        "def substring_filter(string_list, substring):\n    \"\"\"\n    This function takes a list of strings and a substring to search for. It returns a new list with the strings\n    that contain the substring.\n    \"\"\"\n    filtered_list = []\n    for string in string_list:\n        if substring in string:\n            filtered_list.append(string)\n    return filtered_list"
      ]
    ],
    "HumanEval/8": [
      [
        0.9489638805389404,
        "def sum_and_product(numbers):\n    \"\"\"\n    Return the sum and product of the numbers in the list.\n    \n    >>> sum_and_product([1, 2, 3])\n    (6, 6)\n    \"\"\"\n    total_sum = 0\n    total_product = 1\n\n    for number in numbers:\n        total_sum += number\n        total_product *= number\n\n    return total_sum, total_product"
      ],
      [
        0.9473101496696472,
        "def sum_and_product(nums: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    Return the sum and product of all numbers in the list.\n    >>> sum_and_product([1, 2, 3])\n    (6, 6)\n    \"\"\"\n    total_sum = sum(nums)\n    total_product = 1\n    for num in nums:\n        if num != 0:\n            total_product *= num\n    return total_sum, total_product"
      ],
      [
        0.9420112371444702,
        "def sum_product(numbers):\n    \"\"\"\n    This function takes a list of numbers as input and returns the sum and product of the numbers.\n    \n    Args:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    tuple: A tuple containing the sum and product of the numbers.\n    \"\"\"\n    sum_num = sum(numbers)\n    product = 1\n    for num in numbers:\n        product *= num\n    return sum_num, product"
      ],
      [
        0.9394961595535278,
        "def sum_and_product(numbers):\n    \"\"\"\n    This function takes a list of numbers as input and returns the sum and product of the numbers.\n    \n    Args:\n        numbers (list): A list of numbers.\n    \n    Returns:\n        tuple: A tuple containing the sum and product of the numbers.\n    \"\"\"\n    if len(numbers) == 0:\n        print(\"List is empty.\")\n        return\n    \n    s = 0\n    p = 1\n    for num in numbers:\n        s += num\n        p *= num\n    \n    print(\"The sum is:\",s)\n    print(\"The product is:\", p)"
      ],
      [
        0.9313914775848389,
        "def get_sum_and_product(lst):\n    \"\"\"\n    Write a function that takes a list of numbers as input and returns the sum and product of all the numbers in the list.\n    The function should return a tuple containing the sum and product.\n    \n    For example, if the input list is [1, 2, 3, 4], the function should return (10, 24).\n    \n    You can assume that the input list will only contain numbers.\n    \n    You can use the built-in sum() and product() functions to solve this problem.\n    \n    You can use the built-in isinstance()\"\"\"\n    sum_val = 0\n    product = 1\n    for i in lst:\n        if isinstance(i, int) or isinstance(i, float):\n            sum_val += i\n            product *= i\n    return sum_val, product"
      ],
      [
        0.9262022972106934,
        "def find_sum_and_product(lst):\n    \"\"\"Return the sum and product of a given list of numbers.\"\"\"\n    \n    # Initialize sum and product\n    sum_res = 0\n    product_res = 1\n\n    # If the list is empty, return 0 for sum and None for product\n    if not lst:\n        return sum_res, None\n    \n    for x in lst:\n        # Check if the current element is numeric (either integer or float)\n        if isinstance(x, (int, float)):\n            sum_res += x\n            product_res *= x\n        else:\n            raise ValueError(\"List contains non-numeric values.\")\n    \n    return sum_res, product_res"
      ],
      [
        0.9184970259666443,
        "def even_squared_odd_cubed_product(numbers):\n    \"\"\"\n    Given a list of integers, return a tuple containing the sum of the squares of the even numbers and the product of the cubes of the odd numbers.\n    \"\"\"\n    sum_of_squares = 0\n    product_of_cubes = 1\n\n    for num in numbers:\n        if num % 2 == 0:\n            sum_of_squares += num * num\n        else:\n            product_of_cubes *= num * num * num\n\n    return (sum_of_squares, product_of_cubes)"
      ]
    ],
    "HumanEval/9": [
      [
        0.9513814449310303,
        "def rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From the given list of integers, generate a list of rolling maximum element until that moment in the sequence.\n    \"\"\"\n    max_num = numbers[0]\n    result = [max_num]\n\n    for i in numbers[1:]:\n        if i > max_num:\n            max_num = i\n        result.append(max_num)\n\n    return result"
      ],
      [
        0.9301278591156006,
        "def rolling_max(numbers1: List[int], numbers2: List[int]) -> Tuple[List[int], List[int]]:\n    \"\"\"From two given lists of integers, generate a list of rolling maximum element found until given moment\n       in the sequence and store them as maximum of each list.\n    \"\"\"\n    if not numbers1 or not numbers2:\n        return ([], [])\n\n    max1 = numbers1[0]\n    max2 = numbers2[0]\n\n    rolling_max1 = [max1]\n    rolling_max2 = [max2]\n\n    for num in numbers1[1:]:\n        if num > max1:\n            max1 = num\n        rolling_max1.append(max1)\n\n    for num in numbers2[1:]:\n        if num > max2:\n            max2 = num\n        rolling_max2.append(max2)\n\n    return (rolling_max1, rolling_max2)"
      ],
      [
        0.9276763200759888,
        "def rolling_max(numbers1: List[int], numbers2: List[int]) -> Tuple[List[int], List[int]]:\n    \"\"\"From two given lists of integers, generate a list of rolling maximum element found until given moment \n    in the sequence and store them as maximum of each list.\n    \"\"\"\n    if not numbers1 or not numbers2:\n        return ([], [])\n\n    max1 = numbers1[0]\n    max2 = numbers2[0]\n    \n    rolling_max1 = [max1]\n    rolling_max2 = [max2]\n    \n    for num in numbers1[1:]:\n        if num > max1:\n            max1 = num\n        rolling_max1.append(max1)\n        \n    for num in numbers2[1:]:\n        if num > max2:\n            max2 = num\n        rolling_max2.append(max2)\n        \n    return (rolling_max1, rolling_max2)"
      ],
      [
        0.9228312373161316,
        "def rolling_max(int_list):\n    \"\"\"\n    Given a list of integers, return a list where each element is the maximum value from the original list up to that index.\n    \n    >>> rolling_max([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> rolling_max([10, 5, 2, 7, 8, 7])\n    [10, 10, 10, 7, 8, 8]\n    >>> rolling_max([1, 5, \"\"\"\n    if any(i < 0 for i in int_list): \n        # Check if any negative elements, return empty list if found\n        return []\n    else:\n        max_list = []\n        max_val = int_list[0]  # Initialize with first value of list\n        for i in int_list:\n            if i > max_val:  \n                max_val = i \n            max_list.append(max_val)\n        return max_list"
      ],
      [
        0.9225132465362549,
        "def rolling_max_min(numbers: List[int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Generate a unique list of rolling max and min elements from a given list of positive integers. The list should be formatted as tuples: (max, min), and have no repeated tuples or negative integers.\n    \"\"\"\n    max_min_list = []\n    for i in range(len(numbers)):\n        for j in range(i, len(numbers)):\n            max_val, min_val = max(numbers[i:j+1]), min(numbers[i:j+1])\n            current_tuple = (max_val, min_val)\n            if current_tuple not in max_min_list:\n                max_min_list.append(current_tuple)\n    return max_min_list"
      ],
      [
        0.9123498201370239,
        "def rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]  # Filter out non-int values\n    if not numbers:\n        return []\n\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n            \n    return rolling_min_max"
      ],
      [
        0.9102543592453003,
        "def rolling_max_min(numbers: List[int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Find the maximum and minimum of all subarrays of size k.\n    :param numbers: a list of integers\n    :return: a list of tuples where the first element is the maximum value and the second element is the minimum value\n    :example:\n    >>> rolling_max_min([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3)\n    [(3, 1), (4, 2), (5, 3), (6, 4), (7, 5\"\"\"\n    if len(numbers) == 0:\n        return []\n    numbers = list(filter(lambda x: x >= 0, numbers))\n    if len(numbers) == 0:\n        return []\n    min_val = numbers[0]\n    max_val = numbers[0]\n    old_max, old_min = max_val, min_val\n    ans = [(max_val, min_val)]\n    for i in range(1, len(numbers)):\n        if numbers[i] < min_val:\n            min_val = numbers[i]\n        if numbers[i] > max_val:\n            max_val = numbers[i]\n        if old_min != min_val or old_max != max_val:\n            ans.append((max_val, min_val))\n            old_max, old_min = max_val, min_val\n    return ans"
      ],
      [
        0.9100526571273804,
        "def rolling_max_min(numbers: List[int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given a list of numbers, find the maximum and minimum of all the contiguous subarrays of size k.\n    \n    Args:\n        numbers (List[int]): List of integers\n    \n    Returns:\n        List[Tuple[int, int]]: List of tuples of maximum and minimum of all the contiguous subarrays of size k\n    \"\"\"\n    final_sequence = []\n    if numbers:\n        # removing all negative values from the list\n        numbers = [n for n in numbers if n >= 0]\n        max_val = min_val = numbers[0]\n        final_sequence.append((max_val, min_val))\n        for n in numbers[1:]:\n            if n > max_val and n > min_val:\n                max_val = n\n                final_sequence.append((max_val, min_val))\n            elif n < min_val and n < max_val:\n                min_val = n\n                final_sequence.append((max_val, min_val))\n            elif n < max_val and n > min_val:\n                min_val = n\n                final_sequence.append((max_val, min_val)) \n    return final_sequence"
      ]
    ],
    "HumanEval/10": [
      [
        0.9741148352622986,
        "def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    if is_palindrome(string):\n        return string\n\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            reversed_prefix = string[:i][::-1]\n            return string + reversed_prefix\n\n    return string + string[::-1]"
      ],
      [
        0.9517307281494141,
        "def make_palindrome(string: str) -> str:\n    \"\"\" Craft the minimalist plausible palindrome originating with the input string \"\"\"\n    # The task requires to find the largest suffix that is a palindrome.\n    # We iterate from the end to the beginning until we find a palindrome prefix.\n    # Then, complement the rest of the string (its non-palindrome prefix) at the end.\n    for i in range(len(string), -1, -1):\n        if is_palindrome(string[i:]):\n            non_palindrome_prefix = string[:i]\n            break\n    # To make the string palindrome, concatenate it with the reversed non-palindrome prefix\n    return string + non_palindrome_prefix[::-1]"
      ],
      [
        0.9508886337280273,
        "def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    palindromic_postfix = longest_palindromic_postfix(string)\n    prefix = string[0:len(string) - len(palindromic_postfix)]\n    return string + prefix[::-1]"
      ],
      [
        0.9501194357872009,
        "def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix,\n    \"\"\"\n    palindromic_postfix = longest_palindromic_postfix(string)\n    prefix = string[0:len(string) - len(palindromic_postfix)]\n    return string + prefix[::-1]"
      ],
      [
        0.9474129676818848,
        "def make_palindrome(string: str) -> str:\n    \"\"\" Generate the smallest possible palindrome starting with the input string \"\"\"\n    # Implement string manipulation techniques to find longest palindromic suffix\n    longest_palindrome = string[::-1] \n    return string + longest_palindrome"
      ],
      [
        0.9468713998794556,
        "def make_palindrome(string: str) -> str:\n    \"\"\" Construct the shortest palindrome starting with a particular string \"\"\"\n    length = len(string)\n    for i in range(length):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string + string[::-1]"
      ],
      [
        0.9464255571365356,
        "def make_palindrome(string: str) -> str:\n    \"\"\"\n    Find the shortest palindrome that begins with a supplied string, considering spaces between words, and ignoring case, \n    and ignoring non-alphanumeric characters.\n    \n    Algorithm idea is simple:\n    - Find the longest suffix of the supplied string that is a palindrome.\n    - Append to the end of the string the reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    filtered_string = ''.join([char for char in string.lower() if char.isalnum()])\n    string_length = len(filtered_string)\n    \n    if is_palindrome(string):\n        return string\n    \n    for postfix_start in range(string_length):\n        postfix = filtered_string[postfix_start:]\n        if is_palindrome(postfix):\n            non_palindronic_part = filtered_string[:postfix_start]\n            return string + non_palindronic_part[::-1]"
      ],
      [
        0.94640052318573,
        "def make_palindrome(string: str) -> str:\n    \"\"\"\n    Given a string, return the longest palindrome that can be formed by adding characters to the end of it.\n    For example:\n\n    For 'race', the result could be 'racecar', 'acracecar', or 'eracracecar'.\n    For 'abba', the result could be 'abba' or 'babba'.\n    \"\"\"\n    palindrome_substr = longest_palindromic_postfix(string)\n\n    prefix = string[: len(string) - len(palindrome_substr)]\n    palindrome = string + prefix[::-1]  # reverse prefix and append to the original string\n\n    return palindrome"
      ],
      [
        0.9450199604034424,
        "def make_palindrome(string: str) -> str:\n    \"\"\"\n    Make a string a palindrome by adding characters to the end.\n\n    >>> make_palindrome('bob')\n    'bob'\n    >>> make_palindrome('ana')\n    'ana'\n    >>> make_palindrome('abba')\n    'abba'\n    >>> make_palindrome('ab')\n    'ab'\n    >>> make_palindrome('abab')\n    'abab'\n    >>> make_palindrome('ba')\n    'ba'\n    >>> make_palindrome('baa')\n    'baa'\n    >>> make_palindrome('aaa')\n    'aaa'\n    \"\"\"\n    palindromic_postfix = find_palindromic_postfix(string.lower())\n    prefix = string[:string.lower().rfind(palindromic_postfix)]\n    return string + prefix[::-1]"
      ],
      [
        0.943340539932251,
        "def make_palindrome(string: str) -> str:\n    \"\"\" Architect the briefest palindrome initiating with a particular string \"\"\"\n    for i in range(len(string)):\n        tmp = string[i:]\n        if is_palindrome(tmp):\n            return string + string[:i][::-1]\n    return string + string[::-1]"
      ]
    ],
    "HumanEval/11": [
      [
        0.9501937031745911,
        "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input: two individual string parameters a and b, constructed exclusively from binary digits i.e. 1s and 0s.\n    Conduct a binary exclusive OR operation on the specified inputs and yield the result as a string output.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n    # convert the binary strings to integers\n    a = int(a, 2)\n    b = int(b, 2)\n    \n    # Conduct a binary exclusive OR operation on the inputs\n    result = a ^ b\n    \n    # Format the result as a binary string and return it\n    return format(result, 'b')"
      ],
      [
        0.9416028261184692,
        "def string_xor(a: str, b: str) -> str:\n    \"\"\"\n    Perform XOR operation on two binary strings a and b.\n    \n    Args:\n        a (str): First binary string.\n        b (str): Second binary string.\n    \n    Returns:\n        str: Result of XOR operation on a and b.\n    \"\"\"\n    \n    # Convert the strings a and b to binary integers using int function and perform bitwise XOR operation (^)\n    xor_result = int(a, 2) ^ int(b, 2)\n    \n    # Format the result to binary string and remove the '0b' part it starts with\n    xor_result_str = format(xor_result, 'b').zfill(len(a))\n\n    return xor_result_str"
      ],
      [
        0.9396342635154724,
        "def string_xor(a: str, b: str) -> str:\n    \"\"\"\n    Perform XOR operation on two binary strings.\n    \n    Args:\n        a (str): First binary string.\n        b (str): Second binary string.\n        \n    Returns:\n        str: Result of XOR operation as a binary string.\n    \"\"\"\n    # Convert each binary string to an integer\n    a_int = int(a, 2)\n    b_int = int(b, 2)\n    \n    # Perform XOR operation\n    xor_result = a_int ^ b_int\n    \n    # Return as binary string\n    return format(xor_result, 'b')  # 'b' specifies binary format"
      ],
      [
        0.9360447525978088,
        "def string_xor_alternating_subseq(a: str, b: str) -> str:\n    \"\"\"\n    Given two strings a and b, return a string that is the XOR of the alternating subsequences of a and b.\n    The XOR of two strings is the string that contains the XOR of the corresponding characters of a and b.\n    The alternating subsequence of a string s is the string formed by all the characters of s, but in alternating order.\n    For example, the alternating subsequence of abcde is abdce.\n    \n    Example 1:\n    Input: a = \"10101\", b = \"00100\"\n    Output: \"0000\"\"\"\n    xor_string = ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))\n    result = \"\"\n    for ch in xor_string:\n        if not result:\n            result += ch\n        elif result[-1] != ch:\n            result += ch\n    return result"
      ],
      [
        0.9347450137138367,
        "def xor_strings(s1, s2):\n    \"\"\"\n    Given two strings s1 and s2, return a new string that is formed by\n    bitwise XOR-ing the character codes of the two strings.\n    \n    >>> xor_strings(\"1010101010101011\", \"1010101010101011\")\n    '0000000000000000'\n    >>> xor_strings(\"1010101010101011\", \"10101\"\"\"\n    return ''.join(chr(ord(a) ^ ord(b)) for a, b in zip(s1, s2))"
      ],
      [
        0.9342563152313232,
        "def xor_binary_strings(a, b):\n    \"\"\"\n    Given two binary strings, return their XORed value.\n    \n    Args:\n        a (str): A binary string.\n        b (str): Another binary string.\n    \n    Returns:\n        str: The XORed value of a and b.\n    \"\"\"\n    return ''.join('0' if a[i] == b[i] else '1' for i in range(len(a)))"
      ],
      [
        0.9333539009094238,
        "def string_xor(a: str, b: str) -> str:\n\"\"\"\n    XOR operation on two binary strings.\n\n    Args:\n        a (str): First binary string.\n        b (str): Second binary string.\n\n    Returns:\n        str: Result of XOR operation on a and b.\n\n    Raises:\n        ValueError: If the strings are not comprised only of 1s and 0s.\n        ValueError: If the strings are of different lengths.\n        ValueError: If the strings are longer than 10^3 characters.\n    \"\"\"\n\n    # First we check if the strings are not exceeding length 10^3, and if they do, we raise an exception\n    if len(a) > 10**3 or len(b) > 10**3:\n        raise ValueError(\"Input strings length should not exceed 10^3 characters.\") \n\n    # Then we check if the strings are comprised only of 1s and 0s. If not, we raise an exception\n    if not set(a).issubset(set('01')) or not set(b).issubset(set('01')):\n        raise ValueError(\"Input should only contain binary digits (i.e., 1s and 0s).\")\n\n    # If the strings are of different lengths, we pad the shorter one with 0s at the beginning\n    if len(a) != len(b):\n        if len(a) < len(b):\n            a = a.zfill(len(b))\n        else:\n            b = b.zfill(len(a))\n\n    # Then we conduct the XOR operation\n    result = ''\n    for i in range(len(a)):\n        # XOR operation\n        if a[i] == b[i]:\n            result += '0'\n        else:\n            result += '1'\n\n    return result"
      ],
      [
        0.9300698041915894,
        "def xor_strings(s, t):\n    \"\"\"\n    Return a string containing the XOR of s and t.\n    \n    >>> xor_strings('1010101', '0101010')\n    '1111111'\n    \"\"\"\n    return ''.join(chr(ord(a) ^ ord(b)) for a, b in zip(s, t))"
      ],
      [
        0.9300065040588379,
        "def xor_binary_numbers(a, b):\n    \"\"\"\n    XOR two binary numbers.\n    \n    Args:\n        a (str): First binary number.\n        b (str): Second binary number.\n    \n    Returns:\n        list: XOR result as a list of bits.\n    \"\"\"\n    result = []\n    for i in range(len(a)):\n        bit_a = int(a[i])\n        bit_b = int(b[i])\n        xor_result = bit_a ^ bit_b\n        result.append(str(xor_result))\n    return result"
      ]
    ],
    "HumanEval/12": [
      [
        0.9708355069160461,
        "def longest(strings: List[str]) -> Optional[str]:\n    \"\"\"\n    Return the longest string in a list. If more than one string has the same \n    length, return the first one. If the list is empty, return None.\n\n    Examples:\n\n    >>> longest([])\n    >>>\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n    if not strings: return None\n    return max(strings, key=len)"
      ],
      [
        0.9638652801513672,
        "def longest(strings: List[str]) -> Optional[str]:\n    \"\"\"\n    Return the longest string in a list of strings.\n    If there are multiple strings of the same length, return the first one.\n    If the list is empty, return None.\n    \"\"\"\n    if not strings:\n        return None\n    else:\n        max_length = len(max(strings, key=len))\n        for string in strings:\n            if len(string) == max_length:\n                return string"
      ],
      [
        0.9634549617767334,
        "def longest(strings: List[str]) -> Optional[str]:\n    \"\"\"\n    Return the longest string in a list of strings.\n    >>> longest([\"a\", \"b\", \"c\"])\n    'c'\n    >>> longest([\"a\", \"b\", \"c\", \"d\"])\n    'd'\n    >>> longest([\"a\", \"b\", \"c\", \"d\", \"e\"])\n    'e'\n    >>> longest([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"])\n    'f'\n    >>> longest([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"])\n\"\"\"\n    if not strings:\n        return None\n    else:\n        return max(strings, key=len)"
      ],
      [
        0.9517096281051636,
        "def longest(strings: List[str]) -> Optional[str]:\n    \"\"\"\n    Return the longest string in a list of strings.\n    \n    >>> longest([\"foo\", \"bar\", \"foobar\"])\n    'foobar'\n    \n    >>> longest([\"foo\", \"bar\"])\n    'foo'\n    \n    >>> longest([\"foo\"])\n    'foo'\n    \n    >>> longest([])\n    \"\"\"\n    \n    if not strings:\n        return None\n\n    longest_string = strings[0]\n    \n    for string in strings:\n        if len(string) > len(longest_string):\n            longest_string = string\n            \n    return longest_string"
      ],
      [
        0.9254779815673828,
        "def longest(ss: List[str]) -> str:\n    \"\"\"\n    Find the longest string in a list of strings.\n    >>> longest([\"a\", \"bc\", \"def\"])\n    'def'\n    >>> longest([\"a\", \"bc\", \"def\", \"ghij\"])\n    'ghij'\n    \"\"\"\n    if len(ss[0]) >= len(ss[1]):\n        return ss[0]\n    else:\n        return ss[1]"
      ],
      [
        0.9244335889816284,
        "def longest(strings: List[str]) -> Optional[Tuple[str, int]]:\n    \"\"\"\n    Find the longest string in a list of strings.\n    \n    Args:\n        strings: A list of strings.\n    \n    Returns:\n        The longest string in the list, and its length.\n    \"\"\"\n    max_length = -1\n    longest_str = None\n    for s in strings:\n        if len(s) > max_length:\n            longst_str = s\n        max_length = len(s)\n    return longest_str, max_length if longest_str else None"
      ],
      [
        0.9243162870407104,
        "def find_longest_string(strings: List[str]) -> str:\n    \"\"\"\n    Find the longest string in a list of strings.\n    \n    Args:\n        strings (List[str]): A list of strings.\n    \n    Returns:\n        str: The longest string in the list.\n    \"\"\"\n    if not strings: \n        return None\n    return max(strings, key=len)"
      ],
      [
        0.9235880374908447,
        "def longest(strings: Optional[List[str]] = None) -> Optional[str]:\n    \"\"\"\n    Find the longest string in a list of strings.\n    \n    Args:\n        strings (list): A list of strings.\n        \n    Returns:\n        str: The longest string in the list.\n        \n    Raises:\n        NotAListError: If the input is not a list.\n    \"\"\"\n    if strings is None:\n        return None\n\n    if not isinstance(strings, list):\n        raise NotAListError('Input is not a list')\n\n    max_length = -1\n    longest_str = None\n\n    for string in strings:\n        if len(string) > max_length:\n            max_length = len(string)\n            longest_str = string\n            \n    return longest_str"
      ]
    ],
    "HumanEval/13": [
      [
        0.961189866065979,
        "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Return the greatest common divisor of a and b.\n    \n    >>> greatest_common_divisor(12, 18)\n    6\n    >>> greatest_common_divisor(12, 12)\n    12\n    >>> greatest_common_divisor(12, 11)\n    1\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return abs(a)"
      ],
      [
        0.9611846208572388,
        "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Return the greatest common divisor of a and b.\n    \n    >>> greatest_common_divisor(12, 18)\n    6\n    >>> greatest_common_divisor(12, 12)\n    12\n    >>> greatest_common_divisor(12, 11)\n    1\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return abs(a)"
      ],
      [
        0.9566066265106201,
        "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" \n    Return the highest common factor of the two integers a and b.\n    It uses Euclidean Algorithm to find the GCD.\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a"
      ],
      [
        0.9490700364112854,
        "def greatest_common_divisor(a, b):\n    \"\"\"\n    Find the greatest common divisor of two numbers.\n    \n    >>> greatest_common_divisor(12, 18)\n    6\n    >>> greatest_common_divisor(12, 12)\n    12\n    >>> greatest_common_divisor(12, 11)\n    1\n    \"\"\"\n    if a < b:\n        a, b = b, a\n\n    while b > 0:\n        a, b = b, a % b\n\n    return a"
      ],
      [
        0.9478701949119568,
        "def greatest_common_divisor(a, b):\n    \"\"\"\n    Return the greatest common divisor of a and b.\n    \n    >>> greatest_common_divisor(12, 18)\n    6\n    >>> greatest_common_divisor(18, 12)\n    6\n    >>> greatest_common_divisor(12, 12)\n    12\n    >>> greatest_common_divisor(12, 11)\n    1\n    \"\"\"\n    if b == 0:\n        return a\n    return greatest_common_divisor(b, a % b)"
      ],
      [
        0.9476507902145386,
        "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Return the highest common divisor of the two given non-negative integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    >>> greatest_common_divisor(0, 0)\n    0\n    >>> greatest_common_divisor(0, 5)\n    5\n    \"\"\"\n    if a < 0 or b < 0:\n        raise ValueError(\"Both numbers must be non-negative\")\n    \n    # Optimization: Return early when one of the inputs is zero  \n    if a==0: \n        return b \n    if b==0: \n        return a \n\n    # Use Euclidean Algorithm to return the gcd\n    while a % b != 0:\n        temp = a\n        a = b\n        b = temp % b\n    return b"
      ],
      [
        0.9441948533058167,
        "def greatest_common_divisor(a, b):\n    \"\"\"\n    Return the greatest common divisor of a and b.\n    \n    >>> greatest_common_divisor(12, 18)\n    6\n    >>> greatest_common_divisor(18, 12)\n    6\n    >>> greatest_common_divisor(12, 12)\n    12\n    >>> greatest_common_divisor(12, 11)\n    1\n    \"\"\"\n    while b != 0:\n        c = a % b\n        a = b\n        b = c\n    return a"
      ],
      [
        0.9436636567115784,
        "def greatest_common_divisor(a, b):\n    \"\"\"\n    Return the greatest common divisor of a and b.\n    \n    >>> greatest_common_divisor(12, 18)\n    6\n    >>> greatest_common_divisor(12, 12)\n    12\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a"
      ],
      [
        0.94286048412323,
        "def highest_common_factor(a: int, b: int) -> int:\n    \"\"\"\n    Return a highest common factor of two non-negative integers a and b\n    >>> highest_common_factor(3, 5)\n    1\n    >>> highest_common_factor(25, 15)\n    5\n    \"\"\"\n    if a < 0 or b < 0:\n        raise ValueError(\"Both numbers must be non-negative!\")\n\n    # Check boundary conditions\n    if a == 0 and b > 0:\n        return b\n    if b == 0 and a > 0:\n        return a\n\n    while b != 0:\n        a, b = b, a % b\n    return a"
      ],
      [
        0.9419927000999451,
        "def highest_common_factor(a: int, b: int) -> int:\n    \"\"\" Return a highest common factor of two non-negative integers a and b\n    >>> highest_common_factor(3, 5)\n    1\n    >>> highest_common_factor(25, 15)\n    5\n    \"\"\"\n\n    # Validate the input parameters\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise ValueError(\"Input parameters must be integers\")\n    if a < 0 or b < 0:\n        raise ValueError(\"Input parameters must be non-negative\")\n\n    # GCD computation using Euclid's Algorithm\n    while b != 0:\n        a, b = b, a % b\n    return a"
      ]
    ],
    "HumanEval/14": [
      [
        0.9257760047912598,
        "def all_prefixes_with_lengths(string: str) -> List[Tuple[str, int]]:\n    \"\"\" \n    Function that returns a list of tuples which include all prefixes of an input string from smallest to largest and their corresponding lengths\n    E.g. all_prefixes_with_lengths('abc') should return [('a', 1), ('ab', 2), ('abc', 3)]\n    \"\"\"\n    return [(string[:i], i) for i in range(1, len(string)+1)]"
      ],
      [
        0.9083843231201172,
        "def all_substrings(input_string):\n    \"\"\"\n    Return a list of all substrings of the given string.\n    This function should return an empty list if the string is empty.\n    For example, the substrings of \"abc\" are:\n    [\"a\", \"ab\", \"abc\", \"b\", \"bc\", \"c\"]\n    \"\"\"\n    # YOUR CODE HERE\n    #raise NotImplementedError()\n    #return []\n    #return [input_string[i: j] for i in range(len(input_string)) for j in range(i + 1, len(input_string) + 1)]\"\"\"\n    length = len(input_string)\n    return [input_string[i: j] for i in range(length) for j in range(i + 1, length + 1)]"
      ],
      [
        0.9079598188400269,
        "def all_substrings(string):\n    \"\"\"Return a set of all substrings of string.\n    \n    Every substring is a contiguous block of characters in string,\n    including the complete string itself.\n    \n    >>> sorted(all_substrings(\"abc\"))\n    ['', 'a', 'ab', 'abc', 'b', 'bc', 'c']\n    \"\"\"\n    length = len(string)\n    return [string[i: j] for i in range(length) for j in range(i + 1, length + 1)]"
      ],
      [
        0.9079558849334717,
        "def all_substrings(string):\n    \"\"\"Return a set of all substrings of string.\n    \n    Every substring is a contiguous block of characters in string,\n    including the complete string itself.\n    \n    >>> sorted(all_substrings(\"abc\"))\n    ['', 'a', 'ab', 'abc', 'b', 'bc', 'c']\n    \"\"\"\n    length = len(string)\n    return [string[i: j] for i in range(length) for j in range(i + 1, length + 1)]"
      ],
      [
        0.9014106392860413,
        "def substring_dictionary(string):\n    \"\"\"\n    Given a string, return a list of all of its substrings.\n    The returned list should be ordered lexicographically,\n    using Python's built-in ordering for strings.\n    You may assume that the input string does not contain\n    any duplicate characters.\n    \n    >>> substring_dictionary('abcd')\n    ['a', 'ab', 'abc', 'abcd', 'b', 'bc', 'bcd', 'c', 'cd', 'd']\n    \"\"\"\n    substrings = set()\n    for i in range(len(string)):\n        for j in range(i + 1, len(string) + 1):\n            substrings.add(string[i:j])\n    return sorted(list(substrings))"
      ],
      [
        0.9001854658126831,
        "def all_substrings(string):\n    \"\"\"\n    Return a list of all substrings of string.\n    \n    For example, the substrings of \"apple\" are:\n    \n    [\"a\", \"ap\", \"app\", \"Appl\", \"Appl\", \"apple\"]\n    \n    \"\"\"\n    \n    # HINT: You might want to use a nested loop.\n    # HINT2: Don't forget to return your result!\n    \n    \"\"\"\n    substrings = []\n    for i in range(len(string)):\n        for j in range(i + 1, len(string) + 1):\n            substrings.append(string[i:j])\n    return substrings"
      ]
    ],
    "HumanEval/15": [
      [
        0.9051482081413269,
        "def print_sequence(n):\n    \"\"\"\n    Print a sequence of numbers from 0 to n in ascending order.\n    \n    Args:\n        n (int): The last number in the sequence.\n    \"\"\"\n    # Base cases\n    if n < 0:\n        print(\"Error: Negative input.\")\n        return\n    elif n == 0:\n        print(0)\n        return\n\n    # Recursive case\n    else:\n        print_sequence(n - 1)  # recursive call\n        print(n)"
      ],
      [
        0.9051434993743896,
        "def print_sequence(n):\n    \"\"\"\n    Print a sequence of numbers from 0 to n in ascending order.\n    \n    Args:\n        n (int): The last number in the sequence.\n    \"\"\"\n    # Base cases\n    if n < 0:\n        print(\"Error: Negative input.\")\n        return\n    elif n == 0:\n        print(0)\n        return\n\n    # Recursive case\n    else:\n        print_sequence(n - 1)  # recursive call\n        print(n)"
      ],
      [
        0.9029834866523743,
        "def generate_sequence(n):\n    \"\"\"\n    Generate a sequence of numbers from 0 to n.\n    \n    Args:\n        n (int): The last number in the sequence.\n    \n    Returns:\n        list: A list of numbers from 0 to n.\n    \"\"\"\n    sequence = []\n    for i in range(0, n+1):\n        sequence.append(i)\n    return sequence"
      ],
      [
        0.9029628038406372,
        "def generate_sequence(n):\n    \"\"\"\n    Generate a sequence of numbers from 0 to n.\n    \n    Args:\n        n (int): The last number in the sequence.\n    \n    Returns:\n        list: A list of numbers from 0 to n.\n    \"\"\"\n    sequence = []\n    for i in range(0, n+1):\n        sequence.append(i)\n    return sequence"
      ],
      [
        0.9026172161102295,
        "def generate_sequence_string(n):\n    \"\"\"\n    Generate a string of numbers from 1 to n, where:\n    - numbers divisible by 3 are replaced by \"bizz\"\n    - numbers divisible by 5 are replaced by \"fuzz\"\n    - numbers divisible by both 3 and 5 are replaced by \"bizzfuzz\"\n    - all other numbers are converted to strings\n    \n    Args:\n        n (int): the number to generate the sequence string for\n    \n    Returns:\n        str: the sequence string\n    \"\"\"\n    if n % 3 == 0 and n % 5 == 0:\n        return \"bizzfuzz\"\n    elif n % 3 == 0:\n        return \"bizz\"\n    elif n % 5 == 0:\n        return \"fuzz\"\n    else:\n        return str(n)"
      ],
      [
        0.8963890671730042,
        "def decrementing_sequence(n):\n    \"\"\"\n    Print a decrementing sequence of numbers from n to 0.\n    \n    >>> decrementing_sequence(5)\n    5\n    4\n    3\n    2\n    1\n    0\n    \"\"\"\n    if n >= 0:\n        print(n)\n        decrementing_sequence(n-1)"
      ],
      [
        0.8950433135032654,
        "def print_sequence(n):\n    \"\"\"\n    Print a sequence of numbers from n to 1.\n    \n    Args:\n        n (int): The number to start the sequence from.\n    \"\"\"\n    for i in range(n, 0, -1):\n        print(i)"
      ]
    ],
    "HumanEval/16": [
      [
        0.9318045377731323,
        "def count_distinct_characters(string):\n    \"\"\"\n    Count the number of distinct characters in a string.\n    \n    Args:\n        string (str): The input string.\n    \n    Returns:\n        int: The number of distinct characters in the string.\n    \"\"\"\n    distinct_characters = set(string)\n    return len(distinct_characters)"
      ],
      [
        0.9237939119338989,
        "def count_distinct_lowercase_letters(string):\n    \"\"\"\n    Count the number of distinct lowercase letters in a string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        int: The count of distinct lowercase letters.\n    \"\"\"\n    lowercase_letters = set()\n\n    for char in string:\n        if char.islower():\n            lowercase_letters.add(char)\n\n    return len(lowercase_letters)"
      ],
      [
        0.918858528137207,
        "def distinct_characters_count(string):\n    \"\"\"\n    Returns the number of distinct characters in a string.\n    \n    Args:\n        string (str): The string to count distinct characters in.\n        \n    Returns:\n        int: The number of distinct characters in the string.\n    \"\"\"\n    # convert the string to a set\n    distinct_chars = set(string)\n    \n    # return the number of distinct characters\n    return len(distinct_chars)"
      ],
      [
        0.9173547029495239,
        "def count_distinct_lowercase_letters(string):\n    \"\"\"\n    Count the number of distinct lowercase letters in a string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        int: The number of distinct lowercase letters in the string.\n    \"\"\"\n    # Create a set to store distinct lowercase letters\n    distinct_letters = set()\n\n    # Iterate through each character in the string\n    for char in string:\n        # Check if the character is a lowercase letter\n        if char.islower():\n            # Add the lowercase letter to the set\n            distinct_letters.add(char)\n\n    # Return the number of distinct lowercase letters\n    return len(distinct_letters)"
      ],
      [
        0.9170430302619934,
        "def countDistinct(string): \n    \"\"\"\n    Count distinct characters in a string\n    :param string: string\n    :return: int\n    \"\"\"\n    count = 0\n    for i in range(len(string)): \n        count += (i == 0 or string[i - 1] != string[i]) \n    return count"
      ],
      [
        0.9164902567863464,
        "def count_distinct_words(string):\n    \"\"\"\n    Count the number of distinct words in a string.\n\n    Args:\n        string (str): The string to count the words in.\n\n    Returns:\n        int: The number of distinct words in the string.\n    \"\"\"\n    words = set()\n    current_word = \"\"\n    lowercase_string = string.lower()\n    \n    for c in lowercase_string:\n        if c.isalpha():\n            current_word += c\n        elif current_word:\n            words.add(current_word)\n            current_word = \"\"\n\n    if current_word:\n        words.add(current_word)\n\n    return len(words)"
      ]
    ],
    "HumanEval/17": [
      [
        0.9424492120742798,
        "def parse_music(music_string: str) -> List[int]:\n    \"\"\"\n    Parses a string of music into a list of beats.\n    \n    Args:\n        music_string (str): A string of music.\n    \n    Returns:\n        List[int]: A list of beats.\n    \"\"\"\n    notes_map = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    notes = music_string.split()\n    beats = [notes_map[note] for note in notes]\n    return beats"
      ],
      [
        0.9367784261703491,
        "def parse_music(music_string: str) -> List[int]:\n    \"\"\"\n    Parses a string of music into a list of beat durations.\n    \n    Args:\n        music_string (str): A string of music.\n    \n    Returns:\n        List[int]: A list of beat durations.\n    \"\"\"\n    notes = music_string.split(' ')\n    beat_duration = []\n    for note in notes:\n        if note == 'o':\n            beat_duration.append(4)\n        elif note == 'o|':\n            beat_duration.append(2)\n        elif note == '.|':\n            beat_duration.append(1)\n    return beat_duration"
      ]
    ],
    "HumanEval/18": [
      [
        0.9733436107635498,
        "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Determine the frequency of a given substring in the initial string. Include overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count"
      ],
      [
        0.972786545753479,
        "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"Determine the frequency of a given substring in the initial string. Include overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count"
      ],
      [
        0.9723426699638367,
        "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"\n    Return the number of times substring appears in string.\n    >>> how_many_times('aaaa', 'aa')\n    3\n    >>> how_many_times('aaaa', 'a')\n    4\n    >>> how_many_times('aaaa', 'b')\n    0\n    >>> how_many_times('aaaa', '')\n    5\n    >>> how_many_times('aaaa', 'aa')\n    3\n    >>> how_many_times('aaaa', 'aaa')\n    1\n    >>> how_many_times('aaaa', 'aaaa')\n    \"\"\"\n    count = start = 0\n    while start < len(string):\n        pos = string.find(substring, start)\n        if pos != -1:\n            count += 1\n            start = pos + 1\n        else:\n            break\n    return count"
      ],
      [
        0.9710241556167603,
        "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"\n    Return the number of times substring appears in string.\n    >>> how_many_times('aaaa', 'aa')\n    3\n    >>> how_many_times('aaaa', 'a')\n    4\n    >>> how_many_times('aaaa', 'b')\n    0\n    \"\"\"\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i: i + len(substring)] == substring:\n            count += 1\n    return count"
      ],
      [
        0.9710121154785156,
        "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"\n    Return the number of times substring appears in string.\n    >>> how_many_times('aaaa', 'aa')\n    3\n    >>> how_many_times('aaaa', 'a')\n    4\n    >>> how_many_times('aaaa', 'b')\n    0\n    \"\"\"\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i: i + len(substring)] == substring:\n            count += 1\n    return count"
      ],
      [
        0.97076416015625,
        "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"\n    Return the number of times substring appears in string.\n    >>> how_many_times('aaaa', 'aa')\n    3\n    >>> how_many_times('aaaa', 'a')\n    4\n    >>> how_many_times('aaaa', 'b')\n    0\n    \"\"\"\n    start = 0\n    count = 0\n    while start < len(string):\n        pos = string.find(substring, start)\n        if pos != -1:\n            start = pos + 1\n            count += 1\n        else:\n            break\n    return count"
      ],
      [
        0.9702584743499756,
        "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"\n    Return the number of times substring appears in string.\n    >>> how_many_times('aaaa', 'aa')\n    3\n    >>> how_many_times('aaaa', 'a')\n    4\n    >>> how_many_times('aaaa', 'b')\n    0\n    \"\"\"\n    count = start = 0\n    while True:\n        start = string.find(substring, start) + 1\n        if start > 0:\n            count += 1\n        else:\n            return count"
      ],
      [
        0.970252513885498,
        "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"\n    Return the number of times substring appears in string.\n    >>> how_many_times('aaaa', 'aa')\n    3\n    >>> how_many_times('aaaa', 'a')\n    4\n    >>> how_many_times('aaaa', 'b')\n    0\n    \"\"\"\n    count = start = 0\n    while True:\n        start = string.find(substring, start) + 1\n        if start > 0:\n            count += 1\n        else:\n            return count"
      ],
      [
        0.9702449440956116,
        "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"\n    Return the number of times substring appears in string.\n    >>> how_many_times('aaaa', 'aa')\n    3\n    >>> how_many_times('aaaa', 'a')\n    4\n    >>> how_many_times('aaaa', 'b')\n    0\n    \"\"\"\n    count = start = 0\n    while True:\n        start = string.find(substring, start) + 1\n        if start > 0:\n            count += 1\n        else:\n            return count"
      ],
      [
        0.9678515791893005,
        "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"\n    Return the number of times that the string `substring` appears\n    in the string `string`.\n    >>> how_many_times('abcabc', 'abc')\n    2\n    >>> how_many_times('abcabc', 'b')\n    1\n    >>> how_many_times('abcabc', 'c')\n    2\n    >>> how_many_times('abcabc', 'd')\n    0\n    \"\"\"\n    len_sub = len(substring)\n    count = 0\n    for i in range(len(string) - len_sub + 1):\n        if string[i:i+len_sub] == substring:\n            count += 1\n    return count"
      ]
    ],
    "HumanEval/19": [
      [
        0.8970001339912415,
        "def sort_numbers(numbers):\n    \"\"\"Sort the given numbers in ascending order\"\"\"\n    numbers.sort()\n    print(numbers)"
      ],
      [
        0.8915503025054932,
        "def by_length(arr):\n    \"\"\"\n    Return an array of words of numbers in descending order of length.\n    \n    >>> by_length([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    ['Three', 'Nine', 'Eight', 'Seven', 'Six', 'Five', 'Four', 'Two', 'One']\n    \"\"\"\n    num2words = {1: 'One', 2: 'Two', 3: 'Three', 4: 'Four', 5: 'Five', 6: 'Six', 7: 'Seven', 8: 'Eight', 9: 'Nine'}\n    \n    # filter for elements of arr that are in the range 1 to 9, then sort and reverse \n    valid_nums = sorted([n for n in arr if 1 <= n <= 9], reverse=True)  \n\n    # convert to words using num2words dictionary and return\n    return [num2words[n] for n in valid_nums]"
      ],
      [
        0.8900782465934753,
        "def sort_unique_nums(lst):\n    \"\"\"\n    Sort the unique numbers in a list.\n    Args:\n       lst(list): list of numbers\n    Returns:\n       list of numbers: sorted numbers without duplicates\n    \"\"\"\n    result = []\n    for num in lst:\n        try:\n            if 0 <= int(num) <= 10 and num not in result: \n                result.append(num)\n        except ValueError:\n            continue\n    return sorted(result)"
      ],
      [
        0.890007734298706,
        "def arrange_numbers(arr):\n    \"\"\"\n    \"\"\"\n    decimalArr = []\n    for num in arr:\n        decimalArr.append(convert_num(num))\n    sortedDecimalArr = my_sort(decimalArr)\n    return sortedDecimalArr"
      ]
    ],
    "HumanEval/20": [
      [
        0.9463120698928833,
        "def find_closest_elements(numbers: List[float]) -> Tuple[float, float, float]:\n    \"\"\"\n    In a given list of numbers (with a minimum length of two), identify and return the\n    two elements with the smallest difference between them, with the lower value first,\n    then the higher value, plus the actual difference.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError('Invalid input! The input list must include at least two numbers.')\n    \n    numbers.sort()\n    \n    # Start with the first pair of values in the list.\n    smallest_diff = numbers[1] - numbers[0]\n    best_pair = (numbers[0], numbers[1], smallest_diff)\n    \n    for i in range(1, len(numbers) - 1):\n        # Compute the difference between the current pair of elements.\n        diff = numbers[i+1] - numbers[i]\n        # Track the pair with the smallest difference.\n        if diff < smallest_diff:\n            smallest_diff = diff\n            best_pair = (numbers[i], numbers[i+1], smallest_diff)\n    \n    return best_pair"
      ],
      [
        0.9437741041183472,
        "def find_furthest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Extract two float numbers from the given array (at minimum contains two) that possess the maximum numerical difference. Remember to present them in ascending order (minor, major).\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (1.0, 5.0)\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (1.0, 5.0)\n    \"\"\"\n    return min(numbers), max(numbers)"
      ],
      [
        0.9421256184577942,
        "def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n\"\"\"\n    Find the closest pair of numbers in a list.\n\n    Args:\n        numbers (List[float]): A list of numbers.\n\n    Returns:\n        Tuple[float, float]: A tuple containing the closest pair of numbers.\n\n    Raises:\n        ValueError: If the list contains less than two numbers.\n\n    Example:\n        >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0])\n        (3.0, 4.0)\n    \"\"\"\n\n    # Ensure the length of the list is at least 2\n    if len(numbers) < 2:\n        raise ValueError(\"The provided list must contain at least two numbers.\")\n\n    # Sort the list in ascending order\n    sorted_numbers = sorted(numbers)\n\n    # Initialize minimum difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i+1] - sorted_numbers[i]\n\n        # Update minimum difference and closest pair if necessary\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n\n    return closest_pair"
      ],
      [
        0.9413973093032837,
        "def find_nearest_elements_with_indices(numbers: List[float]) -> Tuple[float, int, float, int]:\n    \"\"\"\n    Find the pair of elements in a list that have the smallest absolute difference between them.\n    Return the pair of elements and their indices in a tuple.\n    \n    Args:\n        numbers (List[float]): A list of numbers.\n    \n    Returns:\n        Tuple[float, int, float, int]: A tuple containing the pair of elements and their indices.\n    \n    Example:\n        >>> find_nearest_elements_with_indices([1, 2, 3, 4, 5])\n        (1.0, 0, 2.0\"\"\"\n    smallest_difference = float('inf')\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            difference = abs(numbers[i] - numbers[j])\n            if difference < smallest_difference:\n                smallest_difference = difference\n                smallest_pair = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]), i, j) if numbers[i] < numbers[j] else (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]), j, i)\n    return smallest_pair"
      ],
      [
        0.9368412494659424,
        "def find_nearest_elements_with_indices(numbers: List[float]) -> Tuple[float, int, float, int]:\n    \"\"\"\n    Find the two closest non-repetitive numbers in a list of numbers and their indices.\n    \n    Args:\n        numbers (List[float]): A list of numbers.\n        \n    Returns:\n        Tuple[float, int, float, int]: A tuple containing the two closest non-repetitive numbers and their indices.\n    \"\"\"\n    # Pair the numbers with their original indices\n    numbers_with_indices = [(num, idx) for idx, num in enumerate(numbers)]\n    # Sort the numbers, but keep the original indices\n    numbers_with_indices.sort()\n    # Initialize variables for the two closest non-repetitive numbers and their distance\n    num1, idx1, num2, idx2, min_distance = None, -1, None, -1, float('inf')\n    for i in range(1, len(numbers_with_indices)):\n        # If current pair of consecutive numbers have different values\n        if numbers_with_indices[i][0] != numbers_with_indices[i-1][0]:\n            distance = numbers_with_indices[i][0] - numbers_with_indices[i-1][0]\n            if distance < min_distance:\n                num1, idx1 = numbers_with_indices[i-1]\n                num2, idx2 = numbers_with_indices[i]\n                min_distance = distance\n    return (num1, idx1, num2, idx2)"
      ],
      [
        0.9335104823112488,
        "def find_furthest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    Find the two elements in a list of numbers that are furthest apart.\n    \n    Args:\n        numbers (List[float]): A list of numbers.\n    \n    Returns:\n        Tuple[float, float]: The two elements in the list that are furthest apart.\n    \"\"\"\n    return min(numbers), max(numbers)"
      ],
      [
        0.9334773421287537,
        "def find_furthest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Within a supplied list of real numbers having a compulsory minimum volume of two, decipher and generate the two constituents demonstrating the utmost numeric extent between them. The lower component should surface initially, trailed by the superior counterpart, while maintaining that the pairings are not chronologically ordered.\n    \"\"\"\n    return (min(numbers), max(numbers))"
      ],
      [
        0.9325781464576721,
        "def find_closest_elements(numbers: List[int]) -> Tuple[int, int, int]:\n    \"\"\"\n    In the given list of numbers, find and return the two closest numbers firstly the smaller number, \n    then the larger number and the frequency of the smallest difference.\n    For example:\n    find_closest_elements([1, 2, 3, 4, 5, 2])\n    Returns: (2, 2, 2)\n    find_closest_elements([1, 5, 2, 7, 6, 3])\n    Returns: (2, 3, 1)\n    \"\"\"    \n    numbers.sort()\n    pairs = [(numbers[i], numbers[i + 1]) for i in range(len(numbers) - 1)]\n    minimum = min(pair[1] - pair[0] for pair in pairs)\n    result = [pair for pair in pairs if pair[1] - pair[0] == minimum]\n    return result[0][0], result[0][1], len(result)"
      ],
      [
        0.9295657277107239,
        "def find_furthest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    Find the two elements with the largest difference between them.\n    \n    Args:\n        numbers (List[float]): A list of numbers.\n    \n    Returns:\n        Tuple[float, float]: A tuple containing the two elements with the largest\n        difference between them.\n    \n    Raises:\n        ValueError: If the provided list contains less than two elements.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError('The provided list must contain at least two elements.')\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return (min_num, max_num)"
      ]
    ],
    "HumanEval/21": [
      [
        0.9143803715705872,
        "def rescale_vectors_to_unit(vectors: List[List[float]]) -> List[List[float]]:\n    \"\"\"\n    Accepting a compilation of N-dimensional vectors, an independent linear transform is applied to each dimension,\n    in such a way that the smallest measurement per dimension reduces to 0, and the uppermost rises to 1.\n\n    Ex: rescale_vectors_to_unit([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0], [3.0, 4.0, 5.0]])\n    [[0.0, 0.0, 0.0], [0.5, 0.5, 0.5], [1.0, 1.0, 1.0]]\n    \"\"\"\n    dimension = len(vectors[0])\n    min_max = [[float('inf'), float('-inf')] for _ in range(dimension)]\n\n    # Find the min and max value for each dimension\n    for vector in vectors:\n        for i in range(dimension):\n            if vector[i] < min_max[i][0]:\n                min_max[i][0] = vector[i]\n            if vector[i] > min_max[i][1]:\n                min_max[i][1] = vector[i]\n\n    # Rescale the vectors\n    for vector in vectors:\n        for i in range(dimension):\n            vector[i] = (vector[i] - min_max[i][0]) / (min_max[i][1] - min_max[i][0])\n\n    return vectors"
      ],
      [
        0.9014228582382202,
        "def normalize(numbers):\n  \"\"\"\n  Normalize a list of numbers between 0 and 1.\n  :param numbers: list of numbers to be normalized\n  :return: list of numbers between 0 and 1\n  \"\"\"\n  min_num = min(numbers)\n  max_num = max(numbers)\n\n  for i in range(0, len(numbers)):\n    numbers[i] = (numbers[i] - min_num) / (max_num - min_num)\n\n  return numbers"
      ],
      [
        0.8994903564453125,
        "def normalize(nums):\n  \"\"\"\n  Given a list of numbers, normalize them so that the min is 0 and the max is 1.\n  The values that are in between should be proportionally represented.\n  \n  For example:\n  \n  Given [1, 8, 3, 5]\n  \n  The result should be [0, 1, 0.25, 0.5]\n  \n  Given [10, 20, 30]\n  \n  The result should be [0, 0.5, 1]\n  \n  Given [\"\"\"\n  min_num = min(nums)\n  max_num = max(nums)\n\n  for i, n in enumerate(nums):\n    if n > min_num and n < max_num:\n      if n - min_num > max_num - n:\n        nums[i] = max_num\n      else:\n        nums[i] = min_num\n\n  return nums"
      ],
      [
        0.8981833457946777,
        "def find_furthest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Extract two float numbers from the given array (at minimum contains two) that possess the maximum numerical difference. Remember to present them in ascending order (minor, major).\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (1.0, 5.0)\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (1.0, 5.0)\n    \"\"\"\n    return min(numbers), max(numbers)"
      ],
      [
        0.8973163366317749,
        "def normalize(nums):\n    \"\"\"\n    Normalize a list of numbers to a range of [0, 1].\n    :type nums: List[float]\n    :rtype: List[float]\n    \"\"\"\n    normalized = []\n    min_value = min(nums)\n    max_value = max(nums)\n\n    for value in nums:\n        normalized.append((value - min_value) / (max_value - min_value))\n\n    return normalized"
      ]
    ],
    "HumanEval/22": [
      [
        0.931824266910553,
        "def filterIntegers(values):\n    \"\"\"\n    Return a new list containing only the integers from the given list.\n    \n    >>> filterIntegers([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> filterIntegers([1, 2, 3, 4, 5, \"a\", \"b\", \"c\"])\n    [1, 2, 3, 4, 5]\n    >>> filterIntegers([\"a\", \"b\", \"c\"])\n    []\n    \"\"\"\n    return [val for val in values if isinstance(val, int)]"
      ],
      [
        0.924996554851532,
        "def filter_integers(values):\n    \"\"\"\n    Filter out non-integer values from a list of lists.\n\n    Args:\n        values (list): A list of lists containing various data types.\n\n    Returns:\n        list: A list containing only the integer values from the input list.\n    \"\"\"\n    result = []\n    for sublist in values:\n        for value in sublist:\n            if isinstance(value, int):\n                result.append(value)\n    return result"
      ],
      [
        0.9102098941802979,
        "def count_integers(values: list) -> int:\n    \"\"\"\n    Count the number of integers in a list.\n    Args:\n        values (list): A list of values.\n    Returns:\n        int: The number of integers in the list.\n    \"\"\"\n    count = 0\n    for val in values:\n        if isinstance(val, int) or (isinstance(val, str) and val.isdigit()):\n            count += 1\n    return count"
      ],
      [
        0.9087798595428467,
        "def filter_list(numbers):\n    \"\"\"\n    Return a new list with the strings filtered out\n    \"\"\"\n    return list(filter(lambda x: isinstance(x, int), numbers))\n    \n    def filter_list(numbers):\n    \"\"\"\n    Return a new list with the strings filtered out\n    \"\"\"\n    return list(filter(lambda x: x > 10, numbers))"
      ],
      [
        0.9039234519004822,
        "def filter_list(lst):\n    \"\"\"\n    Return a new list with only the integers from the original list.\n    \"\"\"\n    return list(filter(lambda x: isinstance(x, int), lst))\n    \n    def filter_list(lst):\n    \"\"\"\n    Return a new list with only the integers from the original list.\n    \"\"\"\n    return list(filter(lambda x: isinstance(x, int), lst))\n    \n    def filter_list(lst):\n    \"\"\"\n    Return a new list with only the integers from the original list.\n    \"\"\"\n    return list(filter(lambda x:\"\"\"\n    return list(filter(lambda x: x['age'] > 25 and x['job_title'] == 'Software Engineer', lst))"
      ],
      [
        0.9026889204978943,
        "def filter_and_sort(input_list):\n    \"\"\"\n    Filter out non-integer values from a list and sort the integers in ascending order.\n\n    Args:\n        input_list (list): A list containing integers and non-integer values.\n\n    Returns:\n        list: A sorted list containing only unique integers.\n\n    \"\"\"\n    int_list = []\n    for i in input_list:\n        if isinstance(i, int):\n            int_list.append(i)\n        else:\n            print(\"{} is not an integer. Ignoring...\".format(i))\n    return sorted(set(int_list))"
      ],
      [
        0.9023317098617554,
        "def filter_list(list_input):\n    \"\"\"\n    Return a new list with the strings filtered out\n    \"\"\"\n    filtered_list = [i for i in list_input if isinstance(i, int)]\n    return filtered_list\n    \n    def filter_list(list_input):\n    \"\"\"\n    Return a new list with the strings filtered out\n    \"\"\"\n    filtered_list = [i for i in list_input if i >= 3]\n    return filtered_list"
      ]
    ],
    "HumanEval/23": [
      [
        0.9358434677124023,
        "def stringLength(string):\n    \"\"\"\n    Returns the length of a string\n    \n    >>> stringLength(\"Hello\")\n    5\n    >>> stringLength(\"Goodbye\")\n    7\n    \"\"\"\n    return len(string)"
      ],
      [
        0.9355382919311523,
        "def string_length(string):\n    \"\"\"\n    Return the length of a string.\n    >>> string_length('hello')\n    5\n    >>> string_length('hello!')\n    6\n    \"\"\"\n    return len(string)"
      ],
      [
        0.9347221851348877,
        "def string_length(s):\n    \"\"\"\n    Return the length of a string\n    >>> string_length('hello')\n    5\n    >>> string_length('hello world')\n    11\n    \"\"\"\n    return len(s)"
      ],
      [
        0.9288947582244873,
        "def len_string(str):\n    \"\"\"\n    This function returns the length of a string\n    :param str: string\n    :return: int\n    \"\"\"\n    len_str = 0\n    for char in str:\n        len_str += 1\n    return len_str"
      ],
      [
        0.9234520196914673,
        "def string_length(str):\n    \"\"\"\n    This function takes a string and returns the length of the string.\n    \n    Args:\n        str (str): The string to be measured.\n    \n    Returns:\n        int: The length of the string.\n    \"\"\"\n    return len(str)"
      ],
      [
        0.9217751026153564,
        "def string_length(s):\n    \"\"\"\n    Return the length of a string\n    >>> string_length('hello')\n    5\n    >>> string_length('hello world')\n    11\n    \"\"\"\n    if s == '':\n        return 0\n    else:\n        return 1 + string_length(s[1:])"
      ]
    ],
    "HumanEval/24": [
      [
        0.9683318138122559,
        "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, yet is smaller than n\n    >>> largest_divisor(-15)\n    5\n    \"\"\"\n    # convert the number to absolute\n    n = abs(n)\n    if n < 2:\n        return None\n    # check for all divisors starting from half of the number\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i"
      ],
      [
        0.9681808948516846,
        "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, yet, is smaller than n\n    >>> largest_divisor(-15)\n    5\n    \"\"\"\n    # convert the number to absolute\n    n = abs(n)\n    if n < 2:\n        return None\n    # Check for all divisors starting from half of the number\n    for i in range(n//2, 0, -1): \n        if n % i == 0:\n            return i"
      ],
      [
        0.9318321943283081,
        "def largest_factor(x):\n    \"\"\"\n    Given a positive integer, find the largest factor less than half of the number.\n    \n    >>> largest_factor(15)\n    5\n    >>> largest_factor(12)\n    6\n    \"\"\"\n    factor = 0\n    for i in range(1, int(x/2 + 1)):\n        if x % i == 0:\n            factor = i\n    return factor"
      ]
    ],
    "HumanEval/25": [
      [
        0.9310064315795898,
        "def factorize(n):\n    \"\"\"\n    Factorize positive integer and return its factors.\n    :type n: int\n    :rtype: List[int]\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors"
      ],
      [
        0.9267013072967529,
        "def factorize(n: int) -> Tuple[List[int], Dict[int, int]]:\n    \"\"\"\n    Factorize positive integer and return two tuples for integer factors and factors with power\n    >>> factorize(121)\n    ([11], {11: 1})\n    >>> factorize(12121)\n    ([3, 37], {3: 1, 37: 1})\n    >>> factorize(1212121)\n    ([3, 13, 47], {3: 1, 13: 1, 47: 1})\n    >>> factorize(1\"\"\"\n    i = 2\n    factors = []\n    count_dict = {}\n    while i * i <= n:\n        while (n % i) == 0:\n            if not i in factors:\n                factors.append(i)\n            if i not in count_dict:\n                count_dict[i] = 1\n            else:\n                count_dict[i] += 1\n            n = n / i\n        i = i + 1\n    if n > 1:\n        if not n in factors:\n            factors.append(int(n))\n        if n not in count_dict:\n            count_dict[int(n)] = 1\n        else:\n            count_dict[int(n)] += 1\n    factors.sort()\n    return factors, count_dict"
      ],
      [
        0.922004222869873,
        "def prime_factors(n: int):\n    \"\"\"\n    Returns a list of prime factors of a given integer.\n    \"\"\"\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n = n // 2\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n    if n > 2:\n        factors.append(n)\n    return factors"
      ]
    ],
    "HumanEval/26": [
      [
        0.9446547031402588,
        "def remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Facilitate the de-duplication of a sequence of integers, eliminating any references that occur more than once.\n    Retains the exact sequence of remaining integers mirroring the original provided sequence.\n    Time complexity: O(n)\n    Space complexity: O(1)\n    \"\"\"\n    write = 1\n    for read in range(1, len(numbers)):\n        if numbers[read] != numbers[read-1]:\n            numbers[write] = numbers[read]\n            write += 1\n    return numbers[:write]   # cutting the array to length 'write'"
      ],
      [
        0.939919650554657,
        "def remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" Executes de-duplication of a numeric list, that nullifies all integers that resurface.\n        Upholds the identical sequence of residual integers aligning with the input.\n        >>> remove_duplicates([1, 2, 3, 2, 4])\n        [1, 2, 3, 4]\n    \"\"\"\n    seen = {} \n    len_nums = len(numbers)\n    res = []\n    \n    for i in range(len_nums):\n        if numbers[i] not in seen: # if the item is not in the seen dictionary, add it\n            seen[numbers[i]] = True\n            res.append(numbers[i])\n    \n    return res"
      ],
      [
        0.9387729167938232,
        "def remove_duplicates(numbers: List[int], allow_consecutive_duplicates: bool = True) -> List[int]:\n    \"\"\"\n    Removes duplicates from a list of numbers.\n    \n    :param numbers: The list of numbers to remove duplicates from.\n    :param allow_consecutive_duplicates: Whether to allow consecutive duplicates.\n    :return: The list of numbers with duplicates removed.\n    \"\"\"\n    if len(numbers) == 0:\n        return []\n       \n    if allow_consecutive_duplicates:\n        new_length = 1\n        for i in range(1,len(numbers)):\n            if numbers[i] != numbers[new_length-1]:\n                numbers[new_length] = numbers[i]\n                new_length += 1        \n    else:\n        # Create a set to have constant lookups, that satisfies the O(n) constraint.        \n        seen = set()\n        new_length = 0\n        for i in range(len(numbers)):\n            if numbers[i] not in seen:\n                seen.add(numbers[i])\n                numbers[new_length] = numbers[i]\n                new_length += 1\n\n    return numbers[:new_length]"
      ],
      [
        0.9278368353843689,
        "def track_duplicates(numbers: List[int]) -> Tuple[List[int], List[int]]:\n    \"\"\"\n    Given a list of numbers, return a tuple of two lists. The first list should contain all the numbers that appear only once in the original list in the same order. The second list should contain all the numbers that appear more than once in the original list in the same order.\n    \n    >>> track_duplicates([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18\"\"\"\n    count = {}\n    no_duplicates = []\n    duplicates = []\n    for num in numbers:\n        if num not in count:\n            count[num] = 0\n            no_duplicates.append(num)  # maintains original order\n        count[num] += 1\n    \n    for num, times in count.items():\n        if times > 1:\n            duplicates.append(num)  # maintains original order of when the number first appeared\n    return no_duplicates, duplicates"
      ],
      [
        0.9267627596855164,
        "def remove_duplicates(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    unique_nums = {}\n    for num in nums:\n        if num not in unique_nums:\n            unique_nums[num] = 1\n        else:\n            unique_nums[num] += 1\n    unique_list = []\n    for num in nums:\n        if unique_nums[num] == 1:\n            unique_list.append(num)\n    return unique_list"
      ],
      [
        0.9251227378845215,
        "def remove_duplicates(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    seen = set()\n    unique = []\n    for num in nums:\n        if num not in seen:\n            unique.append(num)\n            seen.add(num)\n    return unique"
      ],
      [
        0.9246571063995361,
        "def remove_duplicates(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    unique_nums = []\n    seen_nums = set()\n    for num in nums:\n        if num not in seen_nums:\n            unique_nums.append(num)\n            seen_nums.add(num)\n    return unique_nums"
      ],
      [
        0.9243394136428833,
        "def remove_duplicates(numbers: List[int], threshold: int) -> List[int]:\n    \"\"\" From a list of integers, remove duplicate elements, elements that occur more \n    than a specified number of times and prime numbers.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    frequency = Counter(numbers)\n    non_duplicates = [number for number in numbers if frequency[number] <= threshold and not is_prime(number)]\n    return non_duplicates"
      ]
    ],
    "HumanEval/27": [
      [
        0.9385780096054077,
        "def flip_case(s):\n    \"\"\"\n    Flip all uppercase letters in a string to lowercase and vice versa.\n    \n    >>> flip_case('Hello World')\n    'hELLO wORLD'\n    >>> flip_case('Happy Birthday')\n    'hAPPY bIRTHDAY'\n    \"\"\"\n    return s.swapcase()"
      ],
      [
        0.938575029373169,
        "def flip_case(s):\n    \"\"\"\n    Flip all uppercase letters in a string to lowercase and vice versa.\n    \n    >>> flip_case('Hello World')\n    'hELLO wORLD'\n    >>> flip_case('Happy Birthday')\n    'hAPPY bIRTHDAY'\n    \"\"\"\n    return s.swapcase()"
      ],
      [
        0.9272320866584778,
        "def toggle_case(string):\n    \"\"\"\n    Toggle case of each character in a string.\n    \n    >>> toggle_case(\"Hello World\")\n    'hELLO wORLD'\n    >>> toggle_case(\"PYTHON\")\n    'python'\n    >>> toggle_case(\"python\")\n    'PYTHON'\n    >>> toggle_case(\"PyThOn\")\n    'pYtHoN'\n    \"\"\"\n    new_string = \"\"\n    for char in string:\n        if char.isupper():\n            new_string += char.lower()\n        elif char.islower():\n            new_string += char.upper()\n        else:\n            new_string += char\n    return new_string"
      ],
      [
        0.9231505393981934,
        "def convert_string(string):\n    \"\"\"\n    Converts a string to its opposite case.\n    \n    Args:\n        string (str): The string to convert.\n    \n    Returns:\n        str: The converted string.\n    \"\"\"\n    converted_string = \"\"\n    for char in string:\n        if char.islower():\n            converted_string += char.upper()\n        elif char.isupper():\n            converted_string += char.lower()\n        else:\n            converted_string += char\n    return converted_string"
      ],
      [
        0.9217571020126343,
        "def change_case(string):\n    \"\"\"\n    Change case of each character in a string.\n    \n    >>> change_case(\"Hello World\")\n    'hELLO wORLD'\n    >>> change_case(\"PYTHON\")\n    'python'\n    >>> change_case(\"12345\")\n    '12345'\n    \"\"\"\n    result = \"\"\n    for char in string:\n        if char.islower():\n            result += char.upper()\n        elif char.isupper():\n            result += char.lower()\n        else:\n            result += char\n    return result"
      ],
      [
        0.9212246537208557,
        "def toggle_string(string):\n    \"\"\"\n    Toggle the case of each letter in a string.\n    \n    Args:\n        string (str): The string to toggle.\n    \n    Returns:\n        str: The string with toggled case.\n    \"\"\"\n    toggled_string = \"\"\n    for char in string:\n        if char.isalpha():\n            toggled_string += char.swapcase()\n        else:\n            toggled_string += char\n    return toggled_string"
      ],
      [
        0.9204155802726746,
        "def reverse_case(string):\n    \"\"\"\n    Reverse the case of each character in a string.\n    For example, \"Hello World\" should become \"hELLO wORLD\".\n    \"\"\"\n    new_string = ''\n    for char in string:\n        if char.isupper():\n            new_string += char.lower()\n        elif char.islower():\n            new_string += char.upper()\n        else:\n            new_string += char\n    return new_string"
      ],
      [
        0.9203540086746216,
        "def toggle_string(str):\n    \"\"\"\n    Toggle the case of each character in a string.\n    \n    >>> toggle_string(\"Hello World\")\n    'hELLO wORLD'\n    >>> toggle_string(\"tHis is a tEsT\")\n    'THiS IS A TeSt'\n    \"\"\"\n    t_str = \"\"\n    for i in range(len(str)):\n        if str[i].islower():\n            t_str += str[i].upper()\n        else:\n            t_str += str[i].lower()\n    return t_str"
      ],
      [
        0.9198590517044067,
        "def swap_case(string):\n    \"\"\"\n    Swap case of all characters in a string.\n    \n    Args:\n        string (str): The string to swap case.\n    \n    Returns:\n        str: The string with swapped case.\n    \"\"\"\n    result = ''\n    for char in string:\n        if char.islower():\n            result += char.upper()\n        elif char.isupper():\n            result += char.lower()\n        else:\n            result += char\n    return result"
      ],
      [
        0.9192575216293335,
        "def swap_characters(string):\n    \"\"\"\n    Given a string, swap the case of every character.\n    For example, given \"Hello\", the result would be \"hELLO\".\n    \n    :param string: The string to swap the case of every character.\n    :return: The string with swapped case.\n    \"\"\"\n    # convert string into list to allow assignment\n    str_list = list(string)     \n   \n    # loop for every two elements in the list, and swap them\n    for i in range(0, len(str_list)-1, 2): \n        str_list[i], str_list[i+1] = str_list[i+1], str_list[i]\n   \n    # return combined list as string \n    return ''.join(str_list)"
      ]
    ],
    "HumanEval/28": [
      [
        0.9287240505218506,
        "def concatenate_strings(list_of_strings):\n    \"\"\"\n    Concatenates all strings in the list\n    :param list_of_strings: list of strings\n    :return: concatenated string\n    \"\"\"\n    result = \"\"\n    for string in list_of_strings:\n        result += string\n    return result"
      ],
      [
        0.919227659702301,
        "def concatenate_strings(str_list):\n    \"\"\"\n    Concatenates all strings in the list\n    \n    Args:\n        str_list: list of strings\n    \n    Returns:\n        str: concatenated string\n    \"\"\"\n    result = \"\"\n    for s in str_list:\n        result += s\n    return result"
      ],
      [
        0.9152461290359497,
        "def custom_concatenate(strings: List[str]) -> str:\n    \"\"\"\n    Concatenate a list of strings.\n    \n    Args:\n        strings: A list of strings.\n    \n    Returns:\n        The concatenated string.\n    \"\"\"\n    import itertools\n    \n    result = []\n\n    # Filter out easily recognizable non-string types\n    strings = [s for s in strings if isinstance(s, str)]\n    \n    # Create an iterator that returns elements from the first iterable until it is exhausted,\n    # then proceeds to the next iterable, until all of the iterables are exhausted. \n    for c in itertools.zip_longest(*strings, fillvalue=''):\n        # Unpack element and reverse\n        result.extend(c[::-1])\n\n    # Concatenate all strings in result and return reverse of it.\n    return ''.join(result)[::-1]"
      ],
      [
        0.913305401802063,
        "def concatenate_strings(input_strings):\n    \"\"\"\n    Concatenates a list of strings into a single string.\n\n    Args:\n        input_strings (list): A list of strings to concatenate.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    output_string = \"\"\n    for string in input_strings:\n        output_string += string\n    return output_string"
      ],
      [
        0.911803126335144,
        "def custom_concatenate(strings: List[str]) -> str:\n    \"\"\"\n    Concatenate a list of strings in a custom way.\n\n    Args:\n        strings (List[str]): A list of strings to concatenate.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    # Convert the list of strings into list of characters\n    strings = [list(s) for s in strings]\n\n    # Initialize the final result as an empty string\n    result = ''\n\n    # Interleave the characters of the strings\n    while strings:\n        for s in strings:\n            if s:\n                result += s.pop()\n\n        # Remove empty lists\n        strings = [s for s in strings if s]\n\n    # Return the final result\n    return result"
      ]
    ],
    "HumanEval/29": [
      [
        0.9370042085647583,
        "def filter_by_prefix(strings, prefix):  # define a function that takes a list of strings and a prefix\n    \"\"\"\n    Return a list of strings that start with the given prefix.\n    :param strings: a list of strings\n    :param prefix: a string\n    :return: a list of strings\n    \"\"\"\n    return [string for string in strings if string.startswith(prefix)]  # return a list of those strings that start with the given prefix"
      ],
      [
        0.9202450513839722,
        "def filter_strings(string_list, prefix):\n    \"\"\"\n    Return a list of strings from string_list that start with the given prefix.\n    \n    >>> filter_strings([\"pay\", \"attention\", \"to\", \"every\", \"word\", \"of\", \"what\", \"I\", \"say\"], \"attention\")\n    ['attention']\n    >>> filter_strings([\"pay\", \"attention\", \"to\", \"every\", \"word\", \"of\", \"what\", \"I\", \"say\"], \"I\")\n    ['I']\n    >>> filter_strings([\"pay\", \"attention\", \"to\", \"every\", \"word\", \"of\", \"what\"\"\"\n    return [s for s in string_list if s.startswith(prefix)]"
      ],
      [
        0.909123420715332,
        "def filter_strings(arr, char):\n    \"\"\"\n    Filter strings from a list that start with a given character.\n    \n    Args:\n    arr (list): List of strings.\n    char (str): Character to filter strings by.\n    \n    Returns:\n    list: List of strings that start with the given character.\n    \"\"\"\n    result = []\n    for string in arr:\n        string = string.strip()  # Remove leading and trailing whitespace\n        if string.startswith(char):\n            result.append(string)\n    return result"
      ],
      [
        0.9057691097259521,
        "def filter_by_prefix_and_suffix(strings: List[str], prefix_suffix: Tuple[str, str]) -> List[str]:\n    \"\"\" Meticulously filter an input collection of strings for sole instances that inaugurate with a specified prefix and terminate with a distinctive suffix.\n    >>> filter_by_prefix_and_suffix([], ('a', 'z'))\n    []\n    >>> filter_by_prefix_and_suffix(['abc', 'bcd', 'cdez', 'arrayz'], ('a', 'z'))\n    ['arrayz']\n    >>> filter_by_prefix_and_suffix(['abc', 'azy'], ('a', 'z'))\n    ['azy', 'abc']\n    \"\"\"\n    pass"
      ],
      [
        0.9026269912719727,
        "def filter_strings(strings, char):\n    \"\"\"\n    Filter strings that start with a given character\n    :param strings: list of strings\n    :param char: character to filter\n    :return: list of strings\n    \"\"\"\n    return list(filter(lambda s: s.startswith(char), strings))"
      ],
      [
        0.9004915952682495,
        "def filter_strings(strings, characters):\n    \"\"\"\n    Filter strings by first character.\n\n    :param strings: list of strings\n    :param characters: list of characters\n    :return: list of strings\n    \"\"\"\n    result = []\n    characters_lower = [char.lower() for char in characters]\n    for string in strings:\n        if string[0].lower() in characters_lower:\n            result.append(string)\n    return result"
      ],
      [
        0.9004896879196167,
        "def filter_strings(strings, characters):\n    \"\"\"\n    Filter strings by first character.\n\n    :param strings: list of strings\n    :param characters: list of characters\n    :return: list of strings\n    \"\"\"\n    result = []\n    characters_lower = [char.lower() for char in characters]\n    for string in strings:\n        if string[0].lower() in characters_lower:\n            result.append(string)\n    return result"
      ],
      [
        0.8992011547088623,
        "def filter_strings_with_a(strings):\n    \"\"\"\n    Filter the given list of strings to only include those that begin with the letter \"a\".\n    \n    >>> filter_strings_with_a([\"apple\", \"banana\", \"pear\"])\n    ['apple']\n    \"\"\"\n    result = []\n    for string in strings:\n        if string.startswith(\"a\"):\n            result.append(string)\n    if len(result) == 0:\n        return []\n    return result"
      ],
      [
        0.8968886733055115,
        "def filter_list(lst, condition):\n    \"\"\"\n    Return a new list containing all elements from the original list for which the given condition is true.\n    \"\"\"\n    return [element for element in lst if condition(element)]\n    \n    def filter_strings(lst, condition):\n    \"\"\"\n    Return a new list containing all strings from the original list for which the given condition is true.\n    \"\"\"\n    return [string for string in lst if string.startswith(condition)]"
      ]
    ],
    "HumanEval/30": [
      [
        0.9764103293418884,
        "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n\n    result = []\n    for num in l:\n        if num > 0:\n          result.append(num)\n    return result"
      ],
      [
        0.9625190496444702,
        "def get_positive_and_sort(l: list):\n    \"\"\"Return only positive numbers in the list, sorted in ascending order.\n    >>> get_positive_and_sort([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive_and_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n\n    return sorted([num for num in l if num > 0])"
      ],
      [
        0.9473170042037964,
        "def get_positive_numbers(nums):\n    \"\"\"\n    Given a list of numbers, return a list which contains only the positive numbers.\n    \n    >>> get_positive_numbers([1, -2, 3, -4, 5])\n    [1, 3, 5]\n    \"\"\"\n    result = []\n    for num in nums:\n        if num > 0:\n            result.append(num)\n    return result"
      ],
      [
        0.9469643235206604,
        "def get_positive_and_sort(l: list):\n    \"\"\"Return only positive numbers in the list, sorted in ascending order.\n    \"\"\"\n    # Step 1: Filter positive numbers\n    positive_nums = [num for num in l if num > 0]\n    \n    # Step 2: Sort the positive numbers\n    return sorted(positive_nums)"
      ],
      [
        0.9456790089607239,
        "def get_positive_and_sort(l: list):\n    \"\"\"\n    Return a list of positive numbers in ascending order.\n    \n    >>> get_positive_and_sort([1, 2, 3, -1, -2, -3])\n    [1, 2, 3]\n    \"\"\"\n    positives = []\n    for num in l:\n        if num > 0:\n            positives.append(num)\n\n    # Call the sort function here instead of return directly\n    return bubble_sort(positives)"
      ],
      [
        0.9444295167922974,
        "def get_positive_numbers(nums):\n    \"\"\"\n    Given a list of numbers, return a list of only the positive numbers.\n    \n    >>> get_positive_numbers([1, 2, 3, -4, -5, -6])\n    [1, 2, 3]\n    \"\"\"\n    positive_nums = []\n    \n    for num in nums:\n        if num > 0:\n            positive_nums.append(num)\n    \n    return positive_nums"
      ],
      [
        0.9412354230880737,
        "def filter_positive(lst):\n    \"\"\"\n    Given a list of numbers, return a new list that contains only the positive numbers.\n    \n    >>> filter_positive([1, -2, 3, -4, 5])\n    [1, 3, 5]\n    \"\"\"\n    positive_nums = []\n    for n in lst:\n        if n > 0:\n            positive_nums.append(n)\n    return positive_nums"
      ],
      [
        0.9406551122665405,
        "def get_positive_and_sort(input_list):\n    \"\"\"\n    Return only positive numbers in the_list, sorted in ascending order.\n    >>> get_positive_and_sort([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive_and_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n\n    # Filter the positive numbers\n    l = [num for num in input_list if num > 0]\n\n    # Implement a bubble sorting algorithm\n    for i in range(len(l)):\n        for j in range(len(l) - i - 1):\n            if l[j] > l[j+1]:\n                # Swap elements\n                l[j], l[j+1] = l[j+1], l[j]\n    \n    return l"
      ]
    ],
    "HumanEval/31": [
      [
        0.9671135544776917,
        "def is_prime(n):\n    \"\"\"Returns true for prime integers, false for non-prime integers.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n\n    if n == 2:\n        return True\n\n    if n % 2 == 0:\n        return False\n\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n\n    return True"
      ],
      [
        0.9645583629608154,
        "def is_prime(n):\n    \"\"\"Returns true for prime integers, false for non-prime integers.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, math.isqrt(n)+1): \n        if n % i == 0:\n            return False\n    return True"
      ],
      [
        0.9621102809906006,
        "def is_prime(n):\n    \"\"\"Returns true for prime integers, false for non-prime integers.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n\n    # Start from 3 and step through odd numbers up to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True"
      ],
      [
        0.9582358598709106,
        "def is_prime(n):\n    \"\"\"\n    Check if a number is prime.\n    \n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(121)\n    False\n    \"\"\"\n    if n <= 1 or (n % 2 == 0 and n > 2): \n        return False\n    return all([(n % i) for i in range(3, int(n**0.5) + 1, 2)])"
      ],
      [
        0.9568701386451721,
        "def is_prime(n):\n    \"\"\"\n    Return True if n is prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return False\n\n    max_divisor = int(sqrt(n))\n    for d in range(2, 1 + max_divisor):\n        if n % d == 0:\n            return False\n    return True"
      ],
      [
        0.956645131111145,
        "def is_prime(n):\n    \"\"\"Returns true for prime numbers, false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(0)\n    False\n    >>> is_prime(-101)\n    False\n    >>> is_prime(2.5)\n    False\n    \"\"\"\n    if isinstance(n, (float, complex)) or n < 2: #negatives & floats are not primes\n        return False\n    for i in range(2, math.isqrt(n) + 1): #only check up to square root of n\n        if n % i == 0:\n            return False\n    return True"
      ],
      [
        0.9566247463226318,
        "def is_prime(n):\n  \"\"\"\n  Returns True if n is prime, False otherwise.\n  \"\"\"\n  if n == 1 or n == 2:\n    return True\n  for i in range(2, n):\n    if n % i == 0:\n      return False\n  return True"
      ],
      [
        0.9565637111663818,
        "def is_prime(n):\n    \"\"\"\n    Check if a number is prime.\n    \n    >>> is_prime(10)\n    False\n    >>> is_prime(7)\n    True\n    \"\"\"\n    if n <= 1 or (n % 2 == 0 and n > 2): \n        return False\n    return all(n % i for i in range(3, int(n**.5) + 1, 2))"
      ],
      [
        0.956324577331543,
        "def is_prime(n):\n    \"\"\"\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5)+1, 2):\n        if n % i == 0:\n            return False\n    return True"
      ],
      [
        0.9556604027748108,
        "def is_prime(n):\n    \"\"\"\n    Returns True if n is prime, False otherwise.\n    \n    >>> is_prime(10)\n    False\n    >>> is_prime(7)\n    True\n    \"\"\"\n    if n < 2:\n        return False\n    \n    is_prime = [True] * (n+1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(math.sqrt(n))+1):\n        if is_prime[i]:\n            for j in range(i*i, n+1, i):\n                is_prime[j] = False\n    \n    if is_prime[n]:\n        return True\n    \n    for i in range(2, int(math.sqrt(n))+1):\n        if n % i == 0 and is_prime[i]:\n            return i\n    \n    return False"
      ]
    ],
    "HumanEval/32": [
      [
        0.8993463516235352,
        "def compute_derivative_integral(xs: list, C: int):\n    \"\"\"\n    Assumptions broken: (xs = coefficients of a polynomial in order: xs[0] + xs[1] * x + xs[2] * x^2 + ....)\n    Compute both the derivative and integral of the given polynomial, incorporate constant C and remove any surplus zeros. Ensure correctness with edge cases.\n    \"\"\"\n    if not xs:\n        return [], [C]\n    \n    derivative = []\n    integral = [C]\n\n    for i in range(len(xs)):\n        if i > 0:  derivative.append(i * xs[i])\n        if i > 0:  integral.append(xs[i-1] /(i))\n        \n    integral.append(xs[-1] / len(xs))\n\n    while derivative and derivative[-1] == 0:\n        derivative.pop()\n        \n    while len(integral) > 1 and integral[-1] == 0:  # retain the constant term even if it's zero.\n        integral.pop()\n\n    return derivative, integral"
      ],
      [
        0.8960886001586914,
        "def first_derivative(poly):\n    \"\"\"\n    Returns the first derivative of a polynomial.\n    \"\"\"\n    result = []\n    for i in range(len(poly)):\n        result.append(poly[i] * (len(poly) - i - 1))\n    return result\n    \n    def second_derivative(poly):\n    \"\"\"\n    Returns the second derivative of a polynomial.\n    \"\"\"\n    result = 0\n    for i in range(len(poly)):\n        result += poly[i] * (len(poly) - i - 1) * pow(x, len(poly) - i - 2)\n    return result"
      ],
      [
        0.8956047296524048,
        "def derivative_and_integral(xs: list, C: complex):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Handle both real and complex number coefficients.\n    Return derivative and integral of this polynomial in the same form, adding C and removing trailing zeros.\n    \"\"\"\n    # Turn the given coefficient list into a Poly1d object which allows us to do mathematical operations.\n    p = np.poly1d(xs[::-1])\n\n    # Compute the derivative of the polynomial and reverse the resulting coefficient list.\n    derivative = p.deriv().c[::-1]\n    # Compute the integral of the polynomial and reverse the resulting coefficient list.\n    integral = p.integ().c[::-1]\n    # Add a complex constant to the integral.\n    integral[0] += C\n\n    # Filter our trailing zeroes in both the integral and derivative lists.\n    derivative = list(filter(lambda a: a != 0, derivative))\n    integral = list(filter(lambda a: a != 0, integral))\n\n    return derivative, integral"
      ],
      [
        0.8948285579681396,
        "def nth_root(x, n, epsilon=0.00001):\n    \"\"\"\n    Find the nth root of x.\n    \"\"\"\n    if x < 0 and n % 2 == 0:\n        raise ValueError(\"Cannot compute root of negative number with even index\")\n    if x < 0 and n % 2 == 1:\n        return -nth_root(-x, n)\n    if x == 0:\n        return 0\n    if n == 0:\n        raise ValueError(\"Cannot compute root of number with zero index\")\n    if n == 1:\n        return x\n    if n == 2:\n        \"\"\"\n    low = 0\n    if x < 1 and x > 0:\n        high = 1\n    else:\n        high = x\n    guess = (high + low) / 2.0\n\n    while abs(guess**n - x) > epsilon:\n        if guess**n < x:\n            low = guess\n        else:\n            high = guess\n        guess = (high + low) / 2.0\n\n    return guess"
      ],
      [
        0.8925346732139587,
        "def karatsuba_poly_mult(poly1, poly2):\n    \"\"\"\n    Karatsuba algorithm for polynomial multiplication.\n    \"\"\"\n    # Base case\n    if len(poly1) == 1 and len(poly2) == 1:\n        return [poly1[0] * poly2[0]]\n\n    # Recursive case\n    else:\n        # Split the polynomials into two parts\n        mid = len(poly1) // 2\n        poly1_lo = poly1[:mid]\n        poly1_hi = poly1[mid:]\n        poly2_lo = poly2[:mid]\n        poly2_hi =\"\"\"\n    # Find size of two polynomials\n    n = max(len(poly1), len(poly2))\n    n = 2**((n - 1).bit_length())  # Round up to the next power of 2.\n\n    # Initial case\n    if n == 1:\n        return [poly1[0] * poly2[0]]\n\n    # Pad polynomials with zeroes\n    poly1 += [0] * (n - len(poly1))\n    poly2 += [0] * (n - len(poly2))\n\n    # Divide polynomials into two parts\n    poly1_lo = poly1[:n//2]\n    poly1_hi = poly1[n//2:]\n    poly2_lo = poly2[:n//2]\n    poly2_hi = poly2[n//2:]\n\n    # Calculate products\n    prod_low = karatsuba_poly_mult(poly1_lo, poly2_lo)\n    prod_high = karatsuba_poly_mult(poly1_hi, poly2_hi)\n    prod_mid = karatsuba_poly_mult([sum(x) for x in zip(poly1_lo, poly1_hi)],\n                                  [sum(x) for x in zip(poly2_lo, poly2_hi)])\n\n    # Combine products\n    prod_mid = [a - b - c for a, b, c in zip(prod_mid, prod_low, prod_high)]\n    prod = prod_low + [0]*(n//2) + prod_high + [0]*(n//2)\n    for i, coef in enumerate(prod_mid):\n        prod[i + n//2] += coef\n\n    # Remove trailing zeroes\n    while len(prod) > 1 and prod[-1] == 0:\n        prod.pop()\n\n    return prod"
      ]
    ],
    "HumanEval/33": [
      [
        0.949211061000824,
        "def sort_third(l: list):\n    \"\"\"\n    Sort the list l in descending order, but only the numbers that are multiples of 3.\n    :param l: list\n    :return: list\n    \"\"\"\n    multiples_of_three = sorted([l[i] for i in range(len(l)) if (i + 1) % 3 == 0], reverse=True)\n    for i, value in enumerate(l):\n        if (i + 1) % 3 == 0:\n            l[i] = multiples_of_three.pop(0)\n    return l"
      ],
      [
        0.9457280039787292,
        "def sort_third(l):\n    \"\"\"\n    \"\"\"\n    aux = [l[i] for i in range(0, len(l), 3)]\n    aux.sort()\n    for i in range(0, len(l), 3):\n        l[i] = aux.pop(0)\n    return l"
      ],
      [
        0.9171875715255737,
        "def modulo_sort(lst):\n    \"\"\"\n    Sort a list of numbers by their modulo 3\"\"\"\n    mod_map = {k:[] for k in range(0,3)}\n    for item in lst:\n        mod = item % 3\n        mod_map[mod].append(item)\n    sorted_list = []\n    for key in mod_map.keys():\n        sorted_list.extend(sorted(mod_map[key]))\n    return sorted_list"
      ],
      [
        0.9080817699432373,
        "def third_highest_odd_element(l: list):\n    \"\"\"\n    Return the third highest odd element in a list of numbers.\n    If there are less than three odd elements, return None.\n    :param l: list of numbers\n    :return: third highest odd element\n    \"\"\"\n    # Create a new list of only positive odd numbers\n    positive_odds = [num for num in l if num > 0 and num % 2 == 1]\n\n    # Sort the new list from highest to lowest\n    for i in range(len(positive_odds)):\n        for j in range(i + 1, len(positive_odds)):\n            if positive_odds[i] < positive_odds[j]:\n                positive_odds[i], positive_odds[j] = positive_odds[j], positive_odds[i]\n\n    # Return the third highest number, if it exists\n    return positive_odds[2] if len(positive_odds) > 2 else None"
      ],
      [
        0.90651535987854,
        "def advanced_sort(l: list, n: int):\n    \"\"\"\n    Sort a list of integers, but only the elements at indices divisible by n.\n    The rest of the list should remain unchanged.\n    :param l: list of integers\n    :param n: integer\n    :return: sorted list\n    \"\"\"\n    # Separate elements at indices divisible by n\n    n_indices = [i for i in range(len(l)) if i % n == 0]\n    indexed_values = [l[i] * 2 for i in n_indices]\n    indexed_values.sort(reverse=True)\n\n    # Create new list with modified values\n    new_list = l.copy()\n    for i, value in zip(n_indices, indexed_values):\n        new_list[i] = value\n    return new_list"
      ],
      [
        0.9052423238754272,
        "def sort_odd(l: list):\n    \"\"\"\n    Sort the odd numbers in ascending order while leaving the even numbers at their original positions.\n    :param l: list of numbers\n    :return: list of numbers\n    \"\"\"\n    odd_list = sorted(element for index, element in enumerate(l) if index % 2)\n    l_prime = [odd_list.pop(0) if index % 2 else element for index, element in enumerate(l)]\n    return l_prime"
      ]
    ],
    "HumanEval/34": [
      [
        0.9846793413162231,
        "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))"
      ],
      [
        0.9701021313667297,
        "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # convert the list to a set to remove duplicates, then convert it back to a list\n    l = list(set(l))\n\n    # sort the list in increasing order\n    l.sort()\n\n    return l"
      ],
      [
        0.9644471406936646,
        "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([4, 7, 2, 4, 6, 7, 7, 10, 0, 124])\n    [0, 2, 4, 6, 10, 124]\n    \"\"\"\n    unique_elements = list(set(l))    # remove duplicates \n    return sorted(unique_elements)    # sort the unique list"
      ],
      [
        0.9525353908538818,
        "def unique(l: list):\n    \"\"\"\n    Return a list of unique elements in the given list.\n    \n    >>> unique([1, 2, 3, 1, 2, 3])\n    [1, 2, 3]\n    >>> unique([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    >>> unique([1, 2, 3\"\"\"\n    # Convert list to set to remove duplicates\n    unique_set = set(l)\n    # Convert set to list and sort it\n    unique_list = sorted(list(unique_set))\n    return unique_list"
      ],
      [
        0.9507638812065125,
        "def unique(l: list):\n    \"\"\"\n    Return a list of unique elements in the given list.\n    :param l: list\n    :return: list\n    \"\"\"\n    return sorted(list(set(l)))"
      ],
      [
        0.9507566690444946,
        "def unique(l: list):\n    \"\"\"\n    Return a list of unique elements in the given list.\n    :param l: list\n    :return: list\n    \"\"\"\n    return sorted(list(set(l)))"
      ],
      [
        0.9507461190223694,
        "def unique(l: list):\n    \"\"\"\n    Return a list of unique elements in the given list.\n    :param l: list\n    :return: list\n    \"\"\"\n    return sorted(list(set(l)))"
      ],
      [
        0.9480125308036804,
        "def unique(l):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([4, 7, 2, 4, 6, 7, 7, 10, 0, 124])\n    [0, 2, 4, 6, 7, 10, 124]\n    \"\"\"\n    if type(l) != list:\n        raise TypeError('Input should be a list')\n    for i in l:\n        if type(i) != int:\n            raise ValueError('Input list should only contain integers')\n    return sorted(list(set(l)))            "
      ],
      [
        0.9409071803092957,
        "def unique(l: list):\n    \"\"\"\n    \"\"\"\n    # Remove duplicates\n    i = 0\n    while i < len(l):\n        j = i + 1\n        while j < len(l):\n            if l[i] == l[j]:\n                del l[j]\n            else:\n                j+=1\n        i+=1\n             \n    # Sort list\n    n = len(l)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if l[j] > l[j+1]:\n                l[j], l[j+1] = l[j+1], l[j]\n    return l"
      ],
      [
        0.9406193494796753,
        "def unique_count(l: list):\n    \"\"\"Return sorted unique elements in a list and their count\n\n    >>> unique_count([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [(0, 1), (2, 1), (3, 3), (5, 2), (9, 1), (123, 1)] \n    \"\"\" \n    l_counter = Counter(l)\n    result = sorted(l_counter.items())\n    return result"
      ]
    ],
    "HumanEval/35": [
      [
        0.9322212934494019,
        "def max_list_element(lst):\n    \"\"\"Return the maximum value in a list.\n    \n    >>> max_list_element([1, 2, 3])\n    3\n    >>> max_list_element([1, 2, 3, 4])\n    4\n    \"\"\"\n    max_element = None\n    for element in lst:\n        if max_element is None or max_element < element:\n            max_element = element\n    return max_element"
      ],
      [
        0.923170804977417,
        "def max_element(lst):\n    \"\"\"\n    Find the maximum element in a list.\n    \n    Args:\n        lst (list): A list of integers.\n    \n    Returns:\n        int: The maximum element in the list.\n    \"\"\"\n    max_element = lst[0]\n    for element in lst:\n        if element > max_element:\n            max_element = element\n    return max_element"
      ],
      [
        0.9208568334579468,
        "def max_value(l):\n    \"\"\"\n    \"\"\"\n    max_value = l[0]\n    for n in l:\n        if n > max_value:\n            max_value = n\n    return max_value"
      ],
      [
        0.9200880527496338,
        "def list_max(lst):\n    \"\"\"\n    Return the maximum value in a list.\n    \n    >>> list_max([1, 2, 3, 4])\n    4\n    >>> list_max([1, 2, 3, 4, 5])\n    5\n    \"\"\"\n    cur_max = 0\n    for x in lst:\n        cur_max = max(cur_max, x)\n    return cur_max"
      ],
      [
        0.9174485802650452,
        "def max_list(lst):\n    \"\"\"Return the maximum value in a list.\n    >>> max_list([1, 2, 3])\n    3\n    >>> max_list([1, 2, 3, 4])\n    4\n    \"\"\"\n    max_value = lst[0] # Initial maximum is the first element\n    for x in lst:\n        if x > max_value: # If the current element is larger\n            max_value = x # It becomes the new maximum\n    return max_value"
      ]
    ],
    "HumanEval/36": [
      [
        0.9122810959815979,
        "def three_seven_fourteen(m: int):\n    \"\"\"\n    \"\"\"\n    count = 0\n    for i in range(1, abs(m)):\n        if '3' in str(i) and (i % 7 == 0 or i % 14 == 0):\n            count += 1\n    return count"
      ],
      [
        0.9038977026939392,
        "def five_nine_twelve(n: int):\n    \"\"\"\n    Count the number of integers between 1 and n (inclusive) that meet the following criteria:\n    - The number contains a 5 or a 7.\n    - The number is divisible by 9, 12, or 15.\n    - The sum of the digits is divisible by 3 or 5.\n    Args:\n        n (int): The upper limit of the range.\n    Returns:\n        int: The count of integers that meet the criteria.\n    \"\"\"\n    # Initialize the counter\n    count = 0\n    # Iterate over all the numbers up to n\n    for i in range(n):\n        # Check if the number contains 5 or 7\n        if '5' in str(i) or '7' in str(i):\n            # Check if the number is divisible by 9, 12, or 15\n            if i % 9 == 0 or i % 12 == 0 or i % 15 == 0:\n                # Calculate the sum of the digits\n                digits_sum = sum(int(digit) for digit in str(i))\n                # Check if the digits sum is divisible by 3 or 5\n                if digits_sum % 3 == 0 or digits_sum % 5 == 0:\n                    # Increment the counter if all the conditions are met\n                    count += 1\n    # Return the total count\n    return count"
      ],
      [
        0.898895263671875,
        "def count_nums(arr):\n    \"\"\"\n    Return the number of numbers in the given array that satisfy the following conditions:\n    \n    The number has at least one digit with a value of 4.\n    The number has at least one digit with a value of 7.\n    The sum of the number's digits is divisible by 4.\n    \n    >>> count_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1\"\"\"\n    return sum(1 for num in arr if sum(int(d) for d in str(abs(num))) > 0 and sum(int(d) for d in str(abs(num))) % 4 == 0)"
      ],
      [
        0.8963409662246704,
        "def ends_in_3_or_7(n):\n    \"\"\"\n    Return True if an integer ends in 3 or 7.\n    >>> ends_in_3_or_7(123)\n    True\n    >>> ends_in_3_or_7(125)\n    False\n    >>> ends_in_3_or_7(127)\n    True\n    \"\"\"\n    return str(n)[-1] in ('3', '7')"
      ],
      [
        0.8935945630073547,
        "def five_nine_sixteen(n: int) -> int:\n    \"\"\"\n    \"\"\"\n    nums = [i for i in range(n) if '5' in str(abs(i)) and (abs(i) % 9 == 0 or abs(i) % 16 == 0) ]\n    return len(nums)"
      ],
      [
        0.8915181159973145,
        "def find_nums(n):\n    \"\"\"\n    Finds the number of odd numbers between 0 and n.\n    \n    Args:\n        n (int): The upper limit of the range.\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i - 7 * int(i / 7) == 0:  # finding multiples of 7 without using modulus\n            print(i)\n            if i // 2 * 2 != i:  # finding odd numbers without using modulus\n                count += 1\n    print(\"Count of odd numbers:\", count)"
      ]
    ],
    "HumanEval/37": [
      [
        0.9515589475631714,
        "def sort_even_indices(l):\n    \"\"\"\n    Sort the values at the even indices of a list in ascending order.\n    \n    Args:\n        l (list): A list of integers.\n    \n    Returns:\n        list: A list with the values at the even indices sorted in ascending order.\n    \"\"\"\n    # We start by filtering out the values at the even indices\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sorting the values at even indices\n    even_indices_values.sort()\n    \n    # Now we replace the values at the even indices with their sorted version\n    for i in range(0, len(l), 2):\n        l[i] = even_indices_values[i // 2]\n    \n    return l"
      ],
      [
        0.9465556740760803,
        "def sort_even_indices(l: list):\n    \"\"\"\n    Sort the even indices of a list.\n    \n    Args:\n        l (list): The list to sort.\n    \n    Returns:\n        list: The sorted list.\n    \"\"\"\n    even_items = [l[i] for i in range(0, len(l), 2)] \n    even_items.sort()\n\n    for i, e in enumerate(sorted(even_items)):\n        l[2 * i] = e\n\n    return l"
      ],
      [
        0.9446446895599365,
        "def sort_even_indices(l):\n    \"\"\"\n    Sort the elements at even indices of a list in ascending order while leaving the elements at odd indices unchanged.\n\n    Args:\n        l (list): List of elements\n\n    Returns:\n        list: List with elements at even indices sorted in ascending order\n    \"\"\"\n    # Extract even index elements and sort them\n    even_indices_sorted = sorted(l[i] for i in range(0, len(l), 2))\n\n    result = l[:]\n    result[::2] = even_indices_sorted\n\n    return result"
      ],
      [
        0.9442380666732788,
        "def sort_even(l: list):\n    \"\"\"\n    Sort a list of integers in ascending order, but keep even and odd numbers\n    in separate sorted lists.\n    \n    Args:\n        l (list): list of integers\n    \n    Returns:\n        list: sorted list of integers\n    \"\"\"\n    evens = [l[i] for i in range(0, len(l), 2)]\n    odds = [l[i] for i in range(1, len(l), 2)]\n    evens.sort(key=lambda x: -x if x < 0 else x)\n    new_list = [None] * len(l)\n    new_list[::2] = evens\n    new_list[1::2] = odds\n    return new_list"
      ],
      [
        0.9408338665962219,
        "def sort_odd(l: list):\n    \"\"\"\n    Sort the odd numbers in ascending order while leaving the even numbers at their original positions.\n    :param l: list of numbers\n    :return: list of numbers\n    \"\"\"\n    odd_list = sorted(element for index, element in enumerate(l) if index % 2)\n    l_prime = [odd_list.pop(0) if index % 2 else element for index, element in enumerate(l)]\n    return l_prime"
      ],
      [
        0.9396109580993652,
        "def sortEven(l):\n    \"\"\"\n    Sort the even elements of a list in ascending order.\n    \n    >>> sortEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    >>> sortEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\"\"\"\n    evens = sorted(l[::2])\n    for i in range(0, len(l), 2):\n        l[i] = evens.pop(0)\n    return l"
      ],
      [
        0.938322126865387,
        "def sort_even(l: list):\n    \"\"\"\n    Sort a list of integers according to the following rules:\n    - Even numbers must be sorted in ascending order\n    - Odd numbers must be sorted in descending order\n    - The relative positions of even and odd numbers must not change\n    - Numbers must be returned in the same list\n    - The function must be generic and work for any list of integers\n    - The function must be generic and work for any list of integers\n    - The function must be generic and work for any list of integers\n    - The function must be generic and work for any list of integers\n    - The function must be generic\"\"\"\n    if not all(isinstance(i, int) for i in l):\n        raise ValueError(\"All elements of the list should be integers\")\n\n    even_neg_numbers = sorted([ele for idx, ele in enumerate(l) if idx % 2 == 0 and ele < 0], reverse=True)\n    even_pos_numbers = sorted([ele for idx, ele in enumerate(l) if idx % 2 == 0 and ele >= 0])\n    odd_numbers = [ele for idx, ele in enumerate(l) if idx % 2 != 0]\n\n    output = []\n    index_neg = index_pos = index_odd = 0\n\n    for i in range(len(l)):\n        if i % 2 == 0:\n            if index_neg < len(even_neg_numbers) and (index_pos == len(even_pos_numbers) or even_neg_numbers[index_neg] > even_pos_numbers[index_pos]):\n                output.append(even_neg_numbers[index_neg])\n                index_neg += 1\n            else:\n                output.append(even_pos_numbers[index_pos])\n                index_pos += 1\n        else:\n            output.append(odd_numbers[index_odd])\n            index_odd += 1\n\n    return output"
      ]
    ],
    "HumanEval/38": [
      [
        0.9813618659973145,
        "def encode_cyclic(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of three characters.\n    \"\"\"\n\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"
      ],
      [
        0.9773379564285278,
        "def encode_cyclic(s: str):\n    \"\"\"\n    cycles group of three characters to produce an encoded string\n    \"\"\"\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"
      ],
      [
        0.9726811647415161,
        "def cyclic_encode(s: str):\n    \"\"\"\n    Encodes the string by cycling groups of three characters.\n    \"\"\"\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"
      ],
      [
        0.9677190780639648,
        "def decode_cyclic(s: str):\n    \"\"\"\n    Accepts a string encoded with the cyclic_encode function and returns the decoded string. \n    \"\"\"\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"
      ],
      [
        0.9669857621192932,
        "def decode_cyclic(s: str):\n    \"\"\"\n    Given a string encoded with the encode_cyclic function, this function returns the original (decoded) string.\n    \"\"\"\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"
      ],
      [
        0.964949905872345,
        "def encode_cyclic(s: str):\n    \"\"\"\n    >>> encode_cyclic(\"abc\")\n    'cab'\n    >>> encode_cyclic(\"abcabc\")\n    'cabcab'\n    >>> encode_cyclic(\"abcabcabc\")\n    'cabcabcab'\n    >>> encode_cyclic(\"abcabcabcabc\")\n    'cabcabcabcabc'\n    \"\"\"\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"
      ],
      [
        0.9620381593704224,
        "def encode_cyclic(z: str):\n    \"\"\"\n    Returns encoded string by cycling groups of three characters.\n    \"\"\"\n    groups = [z[3 * i:min(3 * i + 3, len(z))] for i in range((len(z) + 2) // 3)]\n    groups = [group[1:] + group[0] if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"
      ],
      [
        0.9618627429008484,
        "def decode_cyclic(s: str):\n    \"\"\"\n    >>> decode_cyclic(\"abc\")\n    'abc'\n    >>> decode_cyclic(\"abcabc\")\n    'abcabc'\n    >>> decode_cyclic(\"abcabcabc\")\n    'abcabcabc'\n    >>> decode_cyclic(\"abcabcabcabc\")\n    'abcabcabcabc'\n    >>> decode_cyclic(\"abcabcabcabcabc\")\n    'abcabcabcabcabc'\n    >>> decode_cyclic(\"abcabcabcabcabcabc\")\n    'abcabcabcabcabcabc'\n    >>> decode\"\"\"\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"
      ],
      [
        0.9599628448486328,
        "def encode_cyclic(s: str):\n    \"\"\"\n    This function is intended to encode a string by cycling groups of three characters,\n    and then shifting them three positions further in the alphabet using a Caesar cipher.\n    \"\"\"\n    groups = [s[(3 * i)+3: min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    groups = [''.join(chr((ord(c) - 65 + 3) % 26 + 65) for c in group) if group.isalpha() else group for group in groups]\n    return \"\".join(groups)"
      ],
      [
        0.959259033203125,
        "def decode_cyclic(s: str):\n    \"\"\"\n    returns a decoded string, which was encoded using the above encode_cyclic function, tolerating stand-alone characters and empty spaces\n    \"\"\"\n    # Splitting the given string into groups of at most 3 characters\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # For each group, if length is 3, reverse its cyclic rotation, else let it be\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"
      ]
    ],
    "HumanEval/39": [
      [
        0.9489573240280151,
        "def fibonacci_prime(n):\n    \"\"\"\n    Find the n-th fibonacci number that is also a prime number.\n    \"\"\"\n    def is_prime(n):\n    \"\"\"\n    Check if a number is prime.\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n    \"\"\"\n    count = 0\n    num = 2\n    while count < n:\n        if is_prime(num) and num > 1:\n            count += 1\n        num += 1\n    return num - 1"
      ],
      [
        0.9404894113540649,
        "def fibonacci_primes(n):\n    \"\"\"\n    Return the first n fibonacci numbers that are also prime.\n    \"\"\"\n    def fibonacci(n):\n    \"\"\"\n    Return the nth fibonacci number.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n    def is_prime(n):\n    \"\"\"\n    Return True if n is prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range\"\"\"\n    primes = []\n    i = 0\n    while len(primes) < n:\n        fib = fibonacci(i)\n        if is_prime(fib):\n            primes.append(fib)\n        i += 1\n    return primes"
      ],
      [
        0.9400851130485535,
        "def fibonacci_primes(n):\n    \"\"\"\n    Return the first n fibonacci numbers that are also prime.\n    \"\"\"\n    def is_prime(n):\n        \"\"\"\n        Return True if n is prime.\n        \"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \"\"\"\n    sequence = []\n    a, b = 0, 1\n    while len(sequence) < n:\n        if is_prime(b):\n            sequence.append(b)\n        a, b = b, a + b\n    return sequence"
      ],
      [
        0.9383487701416016,
        "def fib_primes(n):\n    \"\"\"\n    Return a list of the first n prime Fibonacci numbers.\n    \"\"\"\n    def is_prime(num):\n        \"\"\"\n        Return True if num is prime, False otherwise.\n        \"\"\"\n        if num < 2:\n            return False\n        for i in range(2, num):\n            if num % i == 0:\n                return False\n        return True\n    \"\"\"\n    fib = [0, 1]\n    while fib[-1] <= n:\n        num = fib[-1] + fib[-2]\n        if num > n:\n            break\n        fib.append(num)\n    primes = [num for num in fib[2:] if is_prime(num)]\n    return primes"
      ],
      [
        0.9381331205368042,
        "def nth_prime_in_fibonacci(n):\n    \"\"\"\n    Find the nth prime number in the Fibonacci sequence.\n    \n    Args:\n        n (int): The index of the prime number in the Fibonacci sequence.\n    \n    Returns:\n        int: The nth prime number in the Fibonacci sequence.\n    \"\"\"\n    if n < 1:\n        return -1\n    count = 0\n    fib1, fib2 = 1, 1\n    while True:\n        fib1, fib2 = fib2, fib1 + fib2\n        if is_prime(fib2):\n            count += 1\n            if count == n:\n                return fib2"
      ],
      [
        0.937756359577179,
        "def fib_or_prime(n):\n    \"\"\"\n    Return the nth Fibonacci number or the nth prime number.\n    \n    Args:\n        n (int): The index of the number to return.\n    \n    Returns:\n        int: The nth Fibonacci number or the nth prime number.\n    \"\"\"\n    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n) + nth_prime(n)"
      ],
      [
        0.9370002746582031,
        "def fibonacci_primes(n):\n    \"\"\"\n    Return the first n fibonacci numbers that are also prime.\n    \"\"\"\n    def isprime(n):\n        \"\"\"\n        Return True if n is prime.\n        \"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5)+1):\n            if n % i == 0:\n                return False\n        return True\n    \n    \"\"\"\n    Return the first n fibonacci numbers that are also prime.\n    \"\"\"\n    fib_sequence = [0, 1]\n    primes=[]\n    while len(fib_sequence) < n:\n        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])\n        \n    for num in fib_sequence:\n        if isprime(num):\n            primes.append(num)\n            \n    return primes"
      ],
      [
        0.9364478588104248,
        "def fib_prime(n):\n    \"\"\"Generate the Fibonacci series till n and return the prime numbers within the series.\"\"\"\n    fib_nums = [fib(i) for i in range(n+1)]\n    return [num for num in fib_nums if is_prime(num)]"
      ],
      [
        0.9363793134689331,
        "def fibonacci_prime(n):\n    \"\"\"\n    Find the nth fibonacci prime number\n    \"\"\"\n    fib_nums = [0, 1]\n    while fib_nums[-1] <= n:\n        fib_nums.append(fib_nums[-1] + fib_nums[-2])\n    return [num for num in fib_nums if check_prime(num) and num <= n][-1]\n    \n    def fibonacci_primes(n):\n    \"\"\"\n    Find all fibonacci prime numbers less than or equal to n\n    \"\"\"\n    fib_nums = [0, 1]\n    while fib_nums[-1] <= n:\n        fib_nums.append(fib_nums[-1] + fib_nums[-2])\n    return [num for num in fib_nums if check_prime(num) and num <= n]"
      ]
    ],
    "HumanEval/40": [
      [
        0.9403589963912964,
        "def sum_to_zero(nums): \n    \"\"\"\n    Given an array of integers, return True if the sum of any \n    3 integers results in 0.\n    \n    >>> sum_to_zero([1, 2, -3])\n    True\n    >>> sum_to_zero([1, 2, 3])\n    False\n    \"\"\"\n    for i in range(len(nums)): \n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i] + nums[j] + nums[k] == 0:\n                    return True\n    return False"
      ],
      [
        0.9325989484786987,
        "def triples_sum_to_zero(arr):\n   \"\"\"\n   Given an array of distinct integers arr, determine if there are two integers A and B in arr such that A + B = 0.\n   \n   Example 1:\n   \n   Input: arr = [-1,0,1]\n   Output: true\n   \n   Example 2:\n   \n   Input: arr = [-1,0,1,2,-1,-4]\n   Output: true\n   \n   Constraints:\n   \n   1 <= arr.length <= 10^5\n   -10^5 <= arr[i] <= 1\"\"\"\n   arr.sort()\n   for i in range(len(arr)-2):\n      if i>0 and arr[i] == arr[i-1]:\n         continue\n      l = i+1\n      r = len(arr)-1\n      while l < r:\n         total = arr[i]+arr[l]+arr[r]\n         if total<0:\n            l += 1\n         elif total>0:\n            r -= 1\n         else:\n            return True\n   return False"
      ],
      [
        0.9159020781517029,
        "def pairs_sum_to_zero(l):\n    \"\"\"\n    Given a list of integers, return the number of pairs of integers that sum to zero.\n    \n    >>> pairs_sum_to_zero([1, 2, -2, 3, 0, 0])\n    2\n    >>> pairs_sum_to_zero([1, 2, 3, 4, 5])\n    0\n    >>> pairs_sum_to_zero([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -10, -9\"\"\"\n    pairs = []\n    nums = sorted(l)\n    check_set = set()\n    for i,num in enumerate(nums):\n        if -num in check_set:\n            pairs.append((-num,num))\n        else:\n            check_set.add(num)\n    return pairs"
      ],
      [
        0.908967137336731,
        "def three_sum(lst, target_sum):\n    \"\"\"\n    Check if there exists three numbers in a list that sum to a given target sum.\n    \n    Args:\n        lst (list): List of positive integers.\n        target_sum (int): Target sum.\n        \n    Returns:\n        bool: True if there exists three numbers in the list that sum to the target sum, False otherwise.\n    \"\"\"\n    # Check if list contains only positive integers\n    if not all(num > 0 for num in lst):\n        return False\n    \n    # Check if target sum is positive\n    if target_sum <= 0:\n        return False\n    \n    # Check if list contains duplicates\n    if len(lst) != len(set(lst)):\n        return False\n    \n    lst.sort()\n    n = len(lst)\n    for i in range(n-2):\n        left, right = i+1, n-1\n        while left < right:\n            if lst[i] + lst[left] + lst[right] == target_sum:\n                return True\n            elif lst[i] + lst[left] + lst[right] < target_sum:\n                left += 1\n            else:\n                right -= 1\n    return False"
      ],
      [
        0.9075685739517212,
        "def two_sum(arr):\n    \"\"\"\n    Given an array of integers, return whether or not two numbers sum to zero\n    \n    >>> two_sum([1, 2, 3, -2])\n    True\n    >>> two_sum([1, 2, 3, 4])\n    False\n    \"\"\"\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] + arr[j] == 0:\n                return True\n    return False"
      ],
      [
        0.9063442349433899,
        "def generateTriplets(arr):\n  \"\"\"\n  Given an array of distinct integers. The task is to find triplets in the array whose sum is zero.\n  \n  Input: arr[] = {0, -1, 2, -3, 1}\n  Output: 0 -1 1\n          0 -3 3\n          -1 2 -3\n  \n  Input: arr[] = {1, -2, 1, 0, 5}\n  Output: 1 -2 -1\n  \n  Input: arr[] = {0, 0, 0}\n  Output:\"\"\"\n  result = []\n\n  for i in range(len(arr)):\n    for j in range(i + 1, len(arr)):\n      for k in range(j + 1, len(arr)):\n        if (arr[i] + arr[j] + arr[k] == 0):\n          result.append([arr[i], arr[j], arr[k]])\n\n  return result"
      ],
      [
        0.9062696695327759,
        "def hasTripletWithSum(arr, sum):\n    \"\"\"\n    Given an array of integers, find if there exists a triplet in the array whose sum is equal to the given sum.\n    \"\"\"\n    def hasPairWithSum(arr, sum):\n        \"\"\"\n        Given an array of integers, find if there exists a pair in the array whose sum is equal to the given sum.\n        \"\"\"\n        hash = {}\n        for i in range(0, len(arr)):\n            if arr[i] in hash:\n                return True\n            else:\n                hash[sum-arr[i]] = True\n        return False\n    <|file_separator|>\"\"\"\n    for i in range(0, len(arr)-2):\n        twoSum = sum - arr[i]\n        if hasPairWithSum(arr[i+1:], twoSum):\n            return True\n    return False"
      ],
      [
        0.9048131704330444,
        "def findThreeNumberSum(arrSize, targetSum, array):\n    \"\"\"\n    Write a function that takes in a non-empty array of distinct integers and an integer representing a target sum. The function should find all triplets in the array that sum up to the target sum and return a two-dimensional array of all these triplets. The numbers in each triplet should be ordered in ascending order, and the triplets themselves should be ordered in ascending order with respect to the numbers they hold. If no three numbers sum up to the target sum, the function should return an empty array.\n    \n    Sample Input\n    array = [12, 3, 1, 2, -6, \"\"\"\n    for i in range(0, arrSize-2):\n        for j in range(i+1, arrSize-1):\n            for k in range(j+1, arrSize):\n                if array[i] + array[j] + array[k] == targetSum:\n                    return True\n    return False"
      ]
    ],
    "HumanEval/41": [
      [
        0.8985676765441895,
        "def advanced_car_race_collision(n: int, left_cars: List[Tuple[float, float]], right_cars: List[Tuple[float, float]], trajectories: List[Tuple[float, float]]) -> List[Tuple[int, int, float]]:\n    \"\"\"\n    \"\"\"\n    left_cars = sorted(left_cars, key=lambda x: x[0])\n    right_cars = sorted(right_cars, key=lambda x: x[0])\n    total_collisions = []\n\n    for t in range(n+1):\n        for i in range(len(left_cars)):\n            for j in range(i, len(right_cars)):\n                if check_collision(left_cars[i], right_cars[j], t):\n                    total_collisions.append((i, j, t))\n\n    return total_collisions"
      ],
      [
        0.8851937055587769,
        "def min_boxes_touching_floor(n):\n    \"\"\"\n    Given a number of boxes, return the minimum number of boxes that need to be placed on the floor to ensure that all boxes are covered.\n    \n    For example, given n = 10, you should return 5, since placing 5 boxes on the floor will cover all 10 boxes.\n    \n    You can assume that n is a positive integer.\n    \"\"\"\n    return (n + 1) // 2"
      ],
      [
        0.8849961757659912,
        "def numberOfMatches(n: int) -> int:\n    \"\"\"\n    \"\"\"\n    matches = 0\n    while n > 1:\n        matches += n // 2\n        n = (n + 1) // 2\n    return matches"
      ]
    ],
    "HumanEval/42": [
      [
        0.9245519042015076,
        "def increment_list(arr):\n    \"\"\"\n    Given a list of numbers, return a new list with all the numbers incremented by 1.\n    \n    >>> increment_list([1, 2, 3])\n    [2, 3, 4]\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] += 1\n    return arr"
      ],
      [
        0.9201508164405823,
        "def increment_list(list_int):\n    \"\"\"\n    Given a list of numbers, return a new list with all the numbers plus 1.\n    \n    >>> increment_list([1, 2, 3])\n    [2, 3, 4]\n    \"\"\"\n    new_list = [] \n    for i in list_int:\n        new_list.append(i+1) \n    return new_list"
      ],
      [
        0.8909934759140015,
        "def increment_list(nums):\n    \"\"\"\n    Given a list of numbers, replace each number with the sum of that number and the previous number.\n    \n    >>> increment_list([1, 2, 3])\n    [3, 5, 8]\n    \"\"\"\n    for i, num in enumerate(nums):\n        nums[i] = num + 2"
      ],
      [
        0.8909862637519836,
        "def add_one(lst):\n    \"\"\"\n    Add one to each element in a list.\n    \n    Args:\n       lst(list): List of integers\n    Returns:\n       list - A new list of integers\n    \"\"\"\n    lst_new = []\n    for i in lst:\n        lst_new.append(i+1)\n    return lst_new"
      ],
      [
        0.8908467292785645,
        "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # convert the list to a set to remove duplicates, then convert it back to a list\n    l = list(set(l))\n\n    # sort the list in increasing order\n    l.sort()\n\n    return l"
      ],
      [
        0.889160692691803,
        "def increment(n):\n    \"\"\"\n    Increment a number by 1.\n    \n    >>> increment(1)\n    2\n    >>> increment(100)\n    101\n    \"\"\"\n    return n + 1"
      ]
    ],
    "HumanEval/43": [
      [
        0.9467010498046875,
        "def pairs_sum_to_zero(l):\n    \"\"\"\n    Given a list of integers, return the number of pairs of integers that sum to zero.\n    \n    >>> pairs_sum_to_zero([1, 2, -2, 3, 0, 0])\n    2\n    >>> pairs_sum_to_zero([1, 2, 3, 4, 5])\n    0\n    >>> pairs_sum_to_zero([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -10, -9\"\"\"\n    pairs = []\n    nums = sorted(l)\n    check_set = set()\n    for i,num in enumerate(nums):\n        if -num in check_set:\n            pairs.append((-num,num))\n        else:\n            check_set.add(num)\n    return pairs"
      ],
      [
        0.9299019575119019,
        "def two_sum(arr):\n    \"\"\"\n    Given an array of integers, return whether or not two numbers sum to zero\n    \n    >>> two_sum([1, 2, 3, -2])\n    True\n    >>> two_sum([1, 2, 3, 4])\n    False\n    \"\"\"\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] + arr[j] == 0:\n                return True\n    return False"
      ],
      [
        0.9247322678565979,
        "def pairs_difference_to_zero(lst):\n    \"\"\"\n    Given a list of integers, return a list of pairs of integers whose difference is zero.\n    \n    >>> pairs_difference_to_zero([1, 2, 3, 4, 5])\n    []\n    >>> pairs_difference_to_zero([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    [[10, 0], [9, 1], [8, 2], [7, 3], [6, 4], [5, \"\"\"\n    seen = set()\n    for num in lst:\n        if -num in seen:\n            return [-num, num]\n        seen.add(num)\n    return []"
      ],
      [
        0.9235990047454834,
        "def sum_to_zero(nums): \n    \"\"\"\n    Given an array of integers, return True if the sum of any \n    3 integers results in 0.\n    \n    >>> sum_to_zero([1, 2, -3])\n    True\n    >>> sum_to_zero([1, 2, 3])\n    False\n    \"\"\"\n    for i in range(len(nums)): \n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i] + nums[j] + nums[k] == 0:\n                    return True\n    return False"
      ],
      [
        0.9207910299301147,
        "def pairs_sum_to_zero(array):\n  \"\"\"\n  Given an array of distinct integers, return the number of pairs of integers that sum to zero.\n  \n  Example 1:\n  Input: [1, 2, -1, 0]\n  Output: 2\n  Explanation: The pairs are [-1, 1], [0, 0]\n  \n  Example 2:\n  Input: [1, 2, 3, 4, 5]\n  Output: 0\n  \n  Example 3:\n  Input: [1, 2, -1, 0, \"\"\"\n  pairs = []\n  for i in range(len(array)):\n    for j in range(i+1, len(array)):\n      if array[i] + array[j] == 0:\n        pairs.append([array[i], array[j]])\n  return len(pairs)"
      ],
      [
        0.9179114103317261,
        "def has_zero_sum(arr):\n    \"\"\"\n    Check if there is a pair of numbers in the array that sum to zero.\n    \"\"\"\n    seen_numbers = set()\n\n    for num in arr:\n        if -num in seen_numbers:\n            return True\n        seen_numbers.add(num)\n\n    return False\n    def has_zero_sum(arr):\n    \"\"\"\n    Check if there is a pair of numbers in the array that sum to zero.\n    \"\"\"\n    seen_numbers = set()\n\n    for num in arr:\n        if -num in seen_numbers:\n            return True\n        seen_numbers.add(num)\n\n    return False"
      ],
      [
        0.9109795093536377,
        "def triples_sum_to_zero(arr):\n   \"\"\"\n   Given an array of distinct integers arr, determine if there are two integers A and B in arr such that A + B = 0.\n   \n   Example 1:\n   \n   Input: arr = [-1,0,1]\n   Output: true\n   \n   Example 2:\n   \n   Input: arr = [-1,0,1,2,-1,-4]\n   Output: true\n   \n   Constraints:\n   \n   1 <= arr.length <= 10^5\n   -10^5 <= arr[i] <= 1\"\"\"\n   arr.sort()\n   for i in range(len(arr)-2):\n      if i>0 and arr[i] == arr[i-1]:\n         continue\n      l = i+1\n      r = len(arr)-1\n      while l < r:\n         total = arr[i]+arr[l]+arr[r]\n         if total<0:\n            l += 1\n         elif total>0:\n            r -= 1\n         else:\n            return True\n   return False"
      ],
      [
        0.9099830985069275,
        "def sum_to_zero(arr):\n    \"\"\"\n    Given an array of integers, return a set of all pairs that sum to zero.\n    :param arr: array of integers\n    :return: set of pairs that sum to zero\n    \"\"\"\n    arr.sort()\n    result = set()\n    i = 0\n    j = len(arr) - 1\n    while i < j:\n        if arr[i] + arr[j] == 0:\n            result.add((arr[i], arr[j]))\n            i += 1\n            j -= 1\n        elif arr[i] + arr[j] < 0:\n            i += 1\n        else:\n            j -= 1\n    return result"
      ],
      [
        0.9093340039253235,
        "def sum_target(lst, target):\n    \"\"\"\n    \"\"\"\n    for pair in lst:\n        if pair[0] + pair[1] == target:\n            return True\n    return False"
      ],
      [
        0.906998872756958,
        "def sum_within_bounds(l: list, lower_bound: int, upper_bound: int):\n    \"\"\"\n    Given a list of integers, return True if the sum of the integers is\n    between lower_bound and upper_bound (inclusive).\n    \n    >>> sum_within_bounds([1, 2, 3], 1, 5)\n    True\n    >>> sum_within_bounds([1, 2, 3], 1, 4)\n    False\n    \"\"\"\n    if len(l) % 2 == 0:\n        s = sum(l)\n        if lower_bound <= s <= upper_bound:\n            return True\n        else:\n            return False\n    else:\n        return False"
      ]
    ],
    "HumanEval/44": [
      [
        0.9205965399742126,
        "def number_to_binary(x: str, base: int):\n    \"\"\"Convert a number from a specified base into its binary equivalent, both represented as strings. \"\"\"\n    if not isinstance(x, str):\n        raise ValueError(\"Input x must be a string.\")\n        \n    if not isinstance(base, int):\n        raise ValueError(\"Input base must be an integer.\")\n    \n    if base not in (8, 10, 16):\n        raise ValueError(\"Base must be 8 (octal), 10 (decimal), or 16 (hexadecimal).\")\n        \n    # convert to integer in the specific base, then convert to binary,\n    # slice the '0b' prefix of binary representation\n    binary = bin(int(x, base))[2:]\n    return binary"
      ],
      [
        0.9193377494812012,
        "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. Also handles the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    \n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n\n    if '.' in x:\n        integer_part, fractional_part = x.split('.')\n\n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / (base ** len(fractional_part))\n\n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n\n        while fractional_part:\n            fractional_part *= 2\n            bit = int(fractional_part)\n\n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n\n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
      ],
      [
        0.9184539318084717,
        "def number_to_binary(x: str, base: int):\n    \"\"\"Convert an input number, represented as a string of a specified base (integer) into its binary equivalent as a string.\n    The base can be either 8 (indicating octal), 10 (indicating decimal), or 16 (for hexadecimal).\n    Examples are provided below for better understanding:\n    >>> number_to_binary('8', 16) => '1000'\n    >>> number_to_binary('F', 16) => '1111'\n    >>> number_to_binary('1A', 16) => '11010'\n    >>> number_to_binary('10', 8) => '1000'\n    >>> number_to_binary('7', 8)  => '111'\n    >>> number_to_binary('12', 8) => '1010'\n    >>> number_to_binary('9', 10) => '1001'\n    >>> number_to_binary('15', 10) => '1111'\n    >>> number_to_binary('26', 10) => '11010'\n    \"\"\"\n    #Convert the input to an integer with the specified base\n    x = int(x, base)\n\n    # Convert the integer to binary\n    binary = bin(x)\n\n    # Return the binary value, omitting the first two characters ('0b')\n    return binary[2:]"
      ],
      [
        0.917145848274231,
        "def number_to_binary(x: str, base: int):\n    \"\"\"Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent as a string.\n    The base can be either 8 (indicating octal), 10 (indicating decimal), or 16 (for hexadecimal).\n    Examples are provided below for better understanding:\n    >>> number_to_binary('8', 16) => '1000'\n    >>> number_to_binary('F', 16) => '1111'\n    >>> number_to_binary('1A', 16) => '11010'\n    >>> number_to_binary('10', 8) => '1000'\n    >>> number_to_binary('7', 8)  => '111'\n    >>> number_to_binary('12', 8) => '1010'\n    >>> number_to_binary('9', 10) => '1001'\n    >>> number_to_binary('15', 10) => '1111'\n    >>> number_to_binary('26', 10) => '11010'\n    \"\"\"\n    # Convert the input to an integer with the specified base\n    x = int(x, base)\n\n    # Convert the integer to binary\n    binary = bin(x)\n\n    # Return the binary value, omitting the first two characters ('0b')\n    return binary[2:]"
      ]
    ],
    "HumanEval/45": [
      [
        0.9449683427810669,
        "def triangle_area(a, h):\n    \"\"\"Given length of a side and height, return the triangle's area.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n    # Data validation\n    if not isinstance(a, (int, float)) or not isinstance(h, (int, float)):\n        return \"Error: both side-length and height need to be numbers\"\n      \n    if a < 0 or h < 0:\n        return \"Error: side-length and height values can't be negative\"\n        \n    if a == 0 or h == 0:\n        return \"Error: side-length or height can't be zero\"\n\n    # Calculation\n    return 0.5 * a * h"
      ],
      [
        0.928779125213623,
        "def triangle_area(a, h):\n    \"\"\"Utilizing input values representing the side length (a) and height (h), accurately calculate the triangle's area.\"\"\"\n    area = 0.5 * a * h\n    return area"
      ],
      [
        0.9247934818267822,
        "def triangle_area(a, h):\n    \"\"\"\n    Utilizing input values representing the side length and height, \n    accurately calculate the triangle's area if inputs form a valid triangle.\n    It considers a and h as the base and height of a right triangle.\n    \n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n    # validation for non-positive inputs\n    if a <= 0 or h <= 0:\n        raise ValueError('Input values must be positive numbers.')\n        \n    # calculation of the triangle's area\n    return 0.5 * a * h"
      ],
      [
        0.9234743118286133,
        "def triangle_area(side_a, side_b):\n    \"\"\"\n    Calculate the area of a triangle.\n    \n    :param side_a: length of side a\n    :param side_b: length of side b\n    :return: area of the triangle\n    \"\"\"\n    # calculate the area of the triangle\n    area = 0.5 * side_a * side_b\n    return area"
      ],
      [
        0.9231519103050232,
        "def triangle_area(a, h):\n    \"\"\"\n    This function calculates the area of a triangle.\n    \n    Parameters:\n    a (float): The length of the base of the triangle.\n    h (float): The height of the triangle.\n    \n    Returns:\n    float: The area of the triangle.\n    \"\"\"\n    if a <= 0 or h <= 0:\n        return \"Error: Negative or zero values are not valid.\"\n    else:\n        return (0.5) * a * h"
      ],
      [
        0.9203291535377502,
        "def triangle_area(base, height):\n    \"\"\"\n    Return the area of a triangle with the given base and height.\n    \"\"\"\n    return 0.5 * base * height"
      ],
      [
        0.9148952960968018,
        "def tri_area(base, height):\n    \"\"\"\n    Return the area of a triangle with the given base and height.\n    \"\"\"\n    return 0.5*base*height\n    \n    def tri_area(base, height):\n    \"\"\"\n    Return the area of a triangle with the given base and height.\n    \"\"\"\n    return 0.5*base*height"
      ],
      [
        0.913087010383606,
        "def triangle_area(base, height):\n    \"\"\"\n    Return the area of a triangle.\n    \n    :param base: The base of the triangle.\n    :param height: The height of the triangle.\n    :return: The area of the triangle.\n    \"\"\"\n    return (base * height) / 2"
      ],
      [
        0.9123490452766418,
        "def areaTriangle(base, height):\n  \"\"\"\n  Return the area of a triangle with the given base and height.\n  \"\"\"\n  return 0.5 * base * height\n    def areaTriangle(base, height):\n  \"\"\"\n  Return the area of a triangle with the given base and height.\n  \"\"\"\n  return 0.5 * base * height"
      ],
      [
        0.9097468256950378,
        "def triangle_area(a, b, c): \n    \"\"\"\n    Calculate the area of a triangle given the length of its sides.\n    \n    :param a: length of side a\n    :param b: length of side b\n    :param c: length of side c\n    :return: area of triangle\n    \"\"\"\n    s = (a + b + c) / 2\n    return (s*(s-a)*(s-b)*(s-c)) ** 0.5"
      ]
    ],
    "HumanEval/46": [
      [
        0.9054789543151855,
        "def enhanced_fibfib(n: int) -> int:\n    \"\"\"\n    \"\"\"\n    limit = 10**6\n    mod = 10**9+7\n    fibfib_series = [0]*max(n+1,limit+1) \n    fibfib_series[2] = 1\n\n    if (n <= 2):\n        return fibfib_series[n]\n    else: \n        for i in range(3, n+1):\n            if i < 1000:\n                fibfib_series[i] = (fibfib_series[i-1] + fibfib_series[i-2] + fibfib_series[i-3] + fibfib_series[i-4]) % mod\n            elif i >= 1000:\n                fibfib_series[i] = (fibfib_series[i-1000] * 2) % mod\n                \n        return fibfib_series[n]"
      ],
      [
        0.9049362540245056,
        "def fibfib(n: int):\n    \"\"\"\n    Return the nth number in the Fibonacci sequence.\n    The Fibonacci sequence is defined as:\n    fib(0) = 0\n    fib(1) = 0\n    fib(2) = 1\n    fib(n) = fib(n-1) + fib(n-2) + fib(n-3)\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n\n    fibs = [0, 0, 1]\n\n    for i in range(3, n + 1):\n        fibs.append(fibs[i-1] + fibs[i-2] + fibs[i-3])\n\n    return fibs[n]"
      ]
    ],
    "HumanEval/47": [
      [
        0.959434986114502,
        "def median(l: list):\n    \"\"\"\n    Find the median of a list of numbers.\n    \n    >>> median([1, 2, 3, 4, 5])\n    3\n    >>> median([1, 2, 3, 4, 5, 6])\n    3.5\n    \"\"\"\n    n = len(l)\n    s = sorted(l)\n    return (s[n//2] if n % 2 == 1 else (s[n//2 - 1] + s[n//2]) / 2)"
      ],
      [
        0.9564302563667297,
        "def median(l):\n    \"\"\"\n    Return the median of a list of numbers.\n    \n    >>> median([1, 2, 3, 4, 5])\n    3\n    >>> median([1, 2, 3, 4, 5, 6])\n    3.5\n    \"\"\"\n    return statistics.median(l)"
      ],
      [
        0.9543144106864929,
        "def median(l):\n    \"\"\"\n    Find the median of a list of numbers.\n    \n    >>> median([1, 2, 3, 4, 5])\n    3\n    >>> median([1, 2, 3, 4, 5, 6])\n    3.5\n    \"\"\"\n    if len(l) % 2:\n        return kth_element(l, len(l) // 2)\n    else:\n        return (kth_element(l, len(l) // 2 - 1) + kth_element(l, len(l) // 2)) * 0.5"
      ],
      [
        0.9469738006591797,
        "def median(l): \n    \"\"\"\n    Find the median of a list of numbers.\n    \n    >>> median([1, 2, 3])\n    2\n    \n    >>> median([1, 2, 3, 4])\n    2.5\n    \"\"\"\n    if len(l)%2 == 0: \n      return (select(l, len(l)//2) + select(l, len(l)//2-1))/2 # find average of two middle elements for even lists \n    else: \n      return select(l, len(l)//2) # middle element for odd lists "
      ],
      [
        0.9455877542495728,
        "def median(l: list):\n    \"\"\"Computes the median of a list without sorting it. \n    Handles odd and even counts, negative integers, and floating-point numbers.\n    \"\"\"\n    sorted_l = sorted(l)\n    len_l = len(l)\n    \n    if len_l % 2 == 0:  # even\n        median = (sorted_l[(len_l) // 2 - 1] + sorted_l[(len_l) // 2]) / 2\n    else:  # odd\n        median = sorted_l[(len_l - 1) // 2]\n\n    return median"
      ],
      [
        0.944825291633606,
        "def median(l):\n    \"\"\"\n    Find the median of a list of numbers.\n    \n    The median is the middle value in an ordered list of numbers.\n    If the list has an even number of elements, the median is the average of the two middle elements.\n    \n    :param l: The list of numbers.\n    :return: The median of the list.\n    \"\"\"\n    if not l:\n        raise ValueError('The input list must contain at least one element')\n    n = len(l)\n    if n % 2 == 1:\n        return quickselect(l, 0, n - 1, n // 2)\n    else:\n        return 0.5 * (quickselect(l, 0, n - 1, n // 2 - 1) + quickselect(l, 0, n - 1, n // 2))"
      ],
      [
        0.9448199272155762,
        "def median(l):\n    \"\"\"\n    Find the median of a list of numbers.\n    \n    The median is the middle value in an ordered list of numbers.\n    If the list has an even number of elements, the median is the average of the two middle elements.\n    \n    :param l: The list of numbers.\n    :return: The median of the list.\n    \"\"\"\n    if not l:\n        raise ValueError('The input list must contain at least one element')\n    n = len(l)\n    if n % 2 == 1:\n        return quickselect(l, 0, n - 1, n // 2)\n    else:\n        return 0.5 * (quickselect(l, 0, n - 1, n // 2 - 1) + quickselect(l, 0, n - 1, n // 2))"
      ],
      [
        0.9440436959266663,
        "def median(my_list):\n    \"\"\"\n    Return the median of a list of numbers.\n    \n    >>> median([1, 2, 3, 4, 5])\n    3\n    >>> median([1, 3, 5])\n    3\n    \"\"\"\n    my_list.sort()\n    half = len(my_list) // 2\n    if len(my_list) % 2 == 0:   # even number of elements\n        return (my_list[half - 1] + my_list[half]) / 2.0\n    else:   # odd number of elements\n        return my_list[half]"
      ],
      [
        0.9434081315994263,
        "def median(l: list):\n    \"\"\"Return median of elements in the list l without sorting it or using built-in functions.\n    Handles tuples with even and odd number of elements, and duplicates.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    >>> median([1, 2, 2, 4, 5])\n    2\n    \"\"\"\n    length = len(l)\n    if length % 2 == 0:\n        return (quickSelect(l, 0, length - 1, length // 2 - 1) + quickSelect(l, 0, length - 1, length // 2)) / 2\n    else:\n        return quickSelect(l, 0, length - 1, length // 2)"
      ],
      [
        0.9430001974105835,
        "def median(l):\n    \"\"\"\n    Find the median of a list of numbers.\n    \n    Args:\n        l: a list of numbers.\n        \n    Returns:\n        The median of the list.\n    \"\"\"\n    return quickselect_median(l, pivot_fn=lambda x: x[len(x) // 2])"
      ]
    ],
    "HumanEval/48": [
      [
        0.9496983289718628,
        "def is_palindrome(text):\n    \"\"\"\n    Check if a given text is a palindrome.\n    :param text: The text to be checked\n    :return: True if the text is a palindrome, False otherwise\n    \"\"\"\n    return text == text[::-1]"
      ],
      [
        0.9496896862983704,
        "def is_palindrome(text):\n    \"\"\"\n    Check if a given text is a palindrome.\n    :param text: The text to be checked\n    :return: True if the text is a palindrome, False otherwise\n    \"\"\"\n    return text == text[::-1]"
      ],
      [
        0.9496812224388123,
        "def is_palindrome(text):\n    \"\"\"\n    Check if a given text is a palindrome.\n    :param text: The text to be checked\n    :return: True if the text is a palindrome, False otherwise\n    \"\"\"\n    return text == text[::-1]"
      ],
      [
        0.9455541372299194,
        "def is_palindrome(text):\n    \"\"\"\n    Check if a string is a palindrome.\n    :param text: string to be checked\n    :return: True if text is a palindrome, False otherwise\n    \"\"\"\n    i = 0\n    j = len(text) - 1\n    while i <= j:\n        if text[i] != text[j]:\n            return False\n        i += 1\n        j -= 1\n    return True"
      ],
      [
        0.9446568489074707,
        "def isPalindrome(text):\n    \"\"\"\n    Check if a string is a palindrome\n    :param text: string\n    :return: boolean\n    \"\"\"\n    text = text.lower()\n    return text == text[::-1]"
      ],
      [
        0.9444239139556885,
        "def is_palindrome(text):\n    \"\"\"\n    Check if the given text is a palindrome.\n    \n    Args:\n        text (str): The text to check.\n        \n    Returns:\n        bool: True if the text is a palindrome, False otherwise.\n    \"\"\"\n    reverse = text[::-1] # Reverse the string\n    return text == reverse"
      ],
      [
        0.9435648918151855,
        "def is_palindrome(text):\n    \"\"\"\n    Check if a given text is a palindrome.\n\n    Args:\n        text (str): The text to check.\n\n    Returns:\n        bool: True if the text is a palindrome, False otherwise.\n    \"\"\"\n    # Normalize the text by lowercasing it and removing non-alphanumeric characters\n    text = \"\".join(char for char in text if char.isalnum()).lower()\n\n    # Check if the text reads the same forwards and backward\n    return text == text[::-1]"
      ],
      [
        0.9433080554008484,
        "def is_palindrome(text):\n    \"\"\"\n    Check if a given text is a palindrome.\n    \n    Args:\n        text (str): The text to check.\n        \n    Returns:\n        bool: True if the text is a palindrome, False otherwise.\n    \"\"\"\n    reversed_text = text[::-1]\n    \n    if text == reversed_text:\n        return True\n    return False"
      ],
      [
        0.9430646896362305,
        "def isPalindrome(text):\n    \"\"\"\n    Check if a string is a palindrome.\n    :param text: string to be checked\n    :return: True if text is a palindrome, False otherwise\n    \"\"\"\n    n = len(text)\n    for i in range(n // 2):\n        if text[i] != text[n - i - 1]:\n            return False\n    return True"
      ],
      [
        0.9400159120559692,
        "def check_palindrome(text):\n    \"\"\"\n    Check if the text is a palindrome\n    :param text: string\n    :return: boolean\n    \"\"\"\n    for i in range(len(text) // 2):\n        if(text[i] != text[len(text) - i - 1]):\n            return False\n    return True"
      ]
    ],
    "HumanEval/49": [
      [
        0.8958614468574524,
        "def power(F, n, m):\n    \"\"\"\n    Returns F^n mod m.\n    \"\"\"\n    if n == 0:\n        return 1\n    if n % 2 == 0:\n        return power((F * F) % m, n // 2, m)\n    return (F * power(F, n - 1, m)) % m\n\n\ndef multiply(F, M, m):\n    \"\"\"\n    Multiplies F by M mod m.\n    \"\"\"\n    F[0] = (F[0] * M[0][0] + F[1] * M[0\"\"\"\n    M = [[1, 1],\n         [1, 0]]\n    for _ in range(2, n + 1):\n        multiply(F, M, m)"
      ],
      [
        0.8955385684967041,
        "def power_of_two(n, memo={}):\n    \"\"\"\n    Return the value of 2**n.\n    >>> power_of_two(0)\n    1\n    >>> power_of_two(1)\n    2\n    >>> power_of_two(2)\n    4\n    >>> power_of_two(4)\n    16\n    \"\"\"\n    if n == 0:\n        return 1\n    if n in memo:\n        return memo[n]\n    memo[n] = 2 * power_of_two(n - 1, memo)\n    return memo[n]"
      ]
    ],
    "HumanEval/50": [
      [
        0.9352093935012817,
        "def decode_cipher(s: str, shift: int) -> str:\n    \"\"\"\n    Decode a ciphered message using a given shift value.\n\n    Args:\n        s (str): The ciphered message to decode.\n        shift (int): The shift value used to cipher the message.\n\n    Returns:\n        str: The decoded message.\n    \"\"\"\n    decoded_message = \"\"\n    for char in s:\n        if char.isalpha():\n            shift_amount = 65 if char.isupper() else 97\n            decoded_char = chr((ord(char) - shift_amount - shift) % 26 + shift_amount)\n            decoded_message += decoded_char\n        else:\n            decoded_message += char\n    return decoded_message"
      ],
      [
        0.9302659630775452,
        "def shift_cipher(s, shift):\n    \"\"\"\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha(): # only shift alphanumeric characters\n            ascii_code = ord(char) \n            ascii_code += shift if ascii_code < 123 else -26 \n            result += chr(ascii_code)\n        else:\n            result += char # don't shift special characters\n    return result"
      ]
    ],
    "HumanEval/51": [
      [
        0.9546741247177124,
        "def remove_vowels(text):\n    \"\"\"\n    Removes all vowels from a string.\n    >>> remove_vowels(\"This is a test\")\n    'Ths s  tst'\n    \"\"\"\n    no_vowels = \"\"\n    for character in text:\n        if character not in \"aeiouAEIOU\":\n            no_vowels += character\n    return no_vowels"
      ],
      [
        0.950664758682251,
        "def remove_vowels(text):\n    \"\"\"Remove the vowels from a given string.\"\"\"\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    result = \"\"\n    for char in text:\n        if char.lower() not in vowels:\n            result += char\n    return result"
      ],
      [
        0.9470234513282776,
        "def remove_vowels(text):\n    \"\"\"\n    Removes all vowels from a given string.\n    \n    Args:\n        text (str): The string to remove vowels from.\n    \n    Returns:\n        str: The string with all vowels removed.\n    \"\"\"\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    no_vowels = \"\"\n\n    for letter in text:\n        if letter.lower() not in vowels:\n            no_vowels += letter\n    return no_vowels"
      ],
      [
        0.945757269859314,
        "def remove_vowels(string):\n    \"\"\"\n    Remove all vowels from a given string.\n    >>> remove_vowels(\"This is a test string\")\n    'Ths s  tst strng'\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    new_string = \"\"\n    for char in string:\n        if char not in vowels:\n            new_string += char\n    return new_string"
      ],
      [
        0.9450527429580688,
        "def remove_vowels(text):\n    \"\"\"\n    Removes all vowels from a given string.\n    \n    Args:\n        text (str): The input string.\n        \n    Returns:\n        str: The string with all vowels removed.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])"
      ],
      [
        0.9447605609893799,
        "def remove_vowels(string): \n    \"\"\"\n    Remove all vowels from a given string.\n    \n    >>> remove_vowels('Theistareykjarbunga')\n    'ThstrykJrbna'\n    >>> remove_vowels('AEIOU')\n    ''\n    \"\"\"\n    vowels = ('a', 'e', 'i', 'o', 'u')  \n    for x in string.lower(): \n        if x in vowels: \n            string = string.replace(x, \"\") \n    return string"
      ],
      [
        0.9442763924598694,
        "def remove_vowels(text):\n    \"\"\"\n    Removes all vowels from a given string.\n    \n    Args:\n        text (str): The input string.\n    \n    Returns:\n        str: The string with all vowels removed.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    new_text = ''\n    for char in text:\n        if char not in vowels:\n            new_text += char\n    return new_text"
      ],
      [
        0.9440063834190369,
        "def remove_vowels(s):\n    \"\"\"\n    Remove all vowels from a given string.\n    \n    >>> remove_vowels(\"This is an example\")\n    'Ths s n xmpl'\n    \"\"\"\n    vowels = ('a', 'e', 'i', 'o', 'u') \n    s_without_vowels = \"\"\n    for char in s:\n        if char not in vowels:\n            s_without_vowels += char\n    return s_without_vowels"
      ],
      [
        0.9436321258544922,
        "def remove_vowels(string):\n    \"\"\"\n    Removes all vowels from a string.\n    \n    >>> remove_vowels('hello world')\n    'hll wrld'\n    >>> remove_vowels('aeiou')\n    ''\n    \"\"\"\n    vowels = 'aeiou'\n    new_string = ''\n\n    for c in string:\n        if c.lower() not in vowels:\n            new_string += c\n    \n    return new_string"
      ],
      [
        0.9436189532279968,
        "def remove_vowels(string):\n    \"\"\"\n    Remove all vowels from a given string.\n    \n    >>> remove_vowels('This is an example')\n    'Ths s n xmpl'\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    for vowel in vowels:\n        string = string.replace(vowel, '')\n    return string"
      ]
    ],
    "HumanEval/52": [
      [
        0.9786379933357239,
        "def below_threshold(l: list, t: int) -> bool:\n    \"\"\"Return True if every integer in list l is below the threshold t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for i in l:\n        if i >= t:\n            return False\n    return True"
      ],
      [
        0.9603942632675171,
        "def below_threshold(l, t):\n    \"\"\"\n    Provide a boolean return stating whether every integer in a collection labelled 'l' is less than a specific, predetermined limit 't'.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    return all(e < t for e in l)"
      ],
      [
        0.9523731470108032,
        "def below_threshold(l: list, t: int) -> bool:\n    \"\"\"\n    Indicates if all integers in list l do not exceed the specified threshold t.\n    If the element is not an integer type, it will be ignored.\n    \"\"\"\n    for item in l:\n        if isinstance(item, int) and item > t:\n            return False\n    return True"
      ],
      [
        0.9510354995727539,
        "def below_threshold(l: list, t: int) -> bool:\n    \"\"\"\n    \"\"\"\n    for num in l:\n        if num > t:\n            return False\n    return True"
      ],
      [
        0.9426862597465515,
        "def below_threshold(l: list, t: int) -> bool:\n    \"\"\"\n    \"\"\"\n    for element in l:\n        if type(element) is int:\n            if element > t:\n                return False\n    return True"
      ],
      [
        0.9425663948059082,
        "def below_threshold(l: list, t: int) -> bool:\n    \"\"\"\n    Check if all numbers in a list are below a given threshold.\n\n    Args:\n        l (list): List of numbers to check.\n        t (int): Threshold value.\n\n    Returns:\n        bool: True if all numbers are below threshold, False otherwise.\n\n    Raises:\n        ValueError: If threshold is non-positive or list is empty.\n    \"\"\"\n    # Check if threshold is non-positive\n    if t <= 0:\n        raise ValueError(\"Threshold must be a positive integer\")\n\n    # Check if list is empty\n    if not l:\n        raise ValueError(\"Input list cannot be empty\")\n\n    # Use a generator comprehension to evaluate each number\n    # Return True if all numbers are below threshold, False otherwise\n    return all(i < t for i in l)"
      ],
      [
        0.9392139315605164,
        "def below_threshold(l: list, t: int):\n    \"\"\"The function determines if all integers contained in list l are within the specified threshold t. A situation where the list may include non-integer data types is also accounted for.\n    \"\"\"\n    for i in l:\n        if isinstance(i, int) and i > t:\n            return False\n    return True"
      ],
      [
        0.9227985143661499,
        "def above_limit(l: list, lim: int) -> bool:\n    \"\"\"Return True if every integer in list l is above the limit lim.\n    >>> above_limit([10, 20, 30, 50], 5)\n    True\n    >>> above_limit([1, 5, 8, 15], 10)\n    False\n    \"\"\"\n    return all(i > lim for i in l)"
      ],
      [
        0.9071448445320129,
        "def above_floor(l: list, f: int) -> bool:\n    \"\"\"Indicates if all integers in list l are not less than the specified floor value f.\n\n    >>> above_floor([10, 20, 30, 40], 5)\n    True\n    >>> above_floor([5, 15, 28, 32], 10)\n    False\n    \"\"\"\n    # Iterating through the list and checking if each element is greater than f\n    for num in l:\n        if num < f:\n            return False\n    return True"
      ]
    ],
    "HumanEval/53": [
      [
        0.9459822177886963,
        "def add_numbers(x: int, y: int) -> int:\n    \"\"\"\n    Add two numbers together.\n\n    Args:\n        x (int): The first number.\n        y (int): The second number.\n\n    Returns:\n        int: The sum of the two numbers.\n    \"\"\"\n    return x + y"
      ],
      [
        0.9429588317871094,
        "def add(a, b):\n    \"\"\"Add two numbers\"\"\"\n    return a + b"
      ],
      [
        0.9419581890106201,
        "def add(a=12, b=16):\n    \"\"\"Add two numbers\n    \n    :param a: first number\n    :param b: second number\n    \"\"\"\n    print(a + b)"
      ],
      [
        0.9406564235687256,
        "def add(x, y):\n    \"\"\"\n    Add two numbers.\n    \n    :param x: first number\n    :param y: second number\n    :return: sum of x and y\n    \"\"\"\n    assert y != 0, \"y must not be zero!\"\n    z = x + y\n    return z"
      ],
      [
        0.9398502707481384,
        "def func(x, y):\n    \"\"\"\n    This function adds two numbers\n    \n    :param x: The first number\n    :type x: int\n    :param y: The second number\n    :type y: int\n    :return: The sum of x and y\n    :rtype: int\n    \"\"\"\n    return x + y"
      ],
      [
        0.9395633935928345,
        "def add_ints(a, b):\n    \"\"\"\n    Add two integers together\n    >>> add_ints(1, 2)\n    3\n    >>> add_ints(100, 200)\n    300\n    \"\"\"\n    return a + b"
      ],
      [
        0.9395307302474976,
        "def add_ints(a, b):\n    \"\"\"\n    Add two integers together\n    >>> add_ints(1, 2)\n    3\n    >>> add_ints(100, 200)\n    300\n    \"\"\"\n    return a + b"
      ],
      [
        0.939113438129425,
        "def myfunc(x, y):\n    \"\"\"\n    This function adds two numbers\n    \n    Args:\n        x (int): The first number\n        y (int): The second number\n    \n    Returns:\n        int: The sum of x and y\n    \"\"\"\n    return x + y"
      ],
      [
        0.9388692378997803,
        "def add(a: int, b: int) -> int:\n    \"\"\"\n    Add two numbers\n    :param a: first number\n    :param b: second number\n    :return: sum of two numbers\n    \"\"\"\n    result = a + b\n    return result"
      ],
      [
        0.9385042786598206,
        "def add_numbers(x, y):\n    \"\"\"\n    This function adds two numbers\n    \"\"\"\n    return x + y\n    def add_numbers(x, y):\n    \"\"\"\n    This function adds two numbers\n    \"\"\"\n    return x + y"
      ]
    ],
    "HumanEval/54": [
      [
        0.9511529207229614,
        "def check_same_chars(s1, s2):\n    \"\"\"\n    Check if two strings have the same characters.\n    \n    >>> check_same_chars('abc', 'cba')\n    True\n    >>> check_same_chars('abc', 'cb')\n    False\n    \"\"\"\n    return sorted(s1) == sorted(s2)"
      ],
      [
        0.9451053142547607,
        "def same_chars(str1, str2):\n    \"\"\"\n    Check if two strings have the same characters in the same quantity.\n\n    >>> same_chars('abc', 'abc')\n    True\n    >>> same_chars('abc', 'abcc')\n    False\n    >>> same_chars('abc', 'cba')\n    True\n    >>> same_chars('abc', 'bac')\n    False\n    \"\"\"\n    if len(str1) != len(str2):\n        return False\n    for i in range(len(str1)):\n        if str1[i] != str2[i]:\n            return False\n    return True"
      ],
      [
        0.9381880760192871,
        "def count_same_chars(s1, s2):\n    \"\"\"\n    Count the number of characters that are the same in two strings.\n    \n    >>> count_same_chars('abc', 'abc')\n    3\n    >>> count_same_chars('abc', 'abd')\n    2\n    >>> count_same_chars('abc', 'aaa')\n    1\n    \"\"\"\n    return len(s1) == len(s2)"
      ],
      [
        0.9224998950958252,
        "def same_chars(string1, string2):\n    \"\"\"\n    Given two strings, return whether they contain the same characters.\n    \n    For example, the strings \"cat\" and \"tac\" contain the same characters.\n    \n    You can assume the strings contain only lowercase letters.\n    \n    Hint: What's the easiest way to compare whether two strings contain the same characters?\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\"\"\"\n    if len(string1) != len(string2):\n        return False\n    \n    char_map = {}\n    for char in string1:\n        if char in char_map:\n            char_map[char] += 1\n        else:\n            char_map[char] = 1\n            \n    for char in string2:\n        if char not in char_map or char_map[char] == 0:\n            return False\n        else:\n            char_map[char] -= 1\n    \n    return True"
      ],
      [
        0.9223159551620483,
        "def same_characters(str1, str2):\n    \"\"\"\n    Given two strings, return True if they contain the same characters in the same quantity.\n    The strings may contain any ascii characters.\n    \n    same_characters(\"abc\", \"cab\") -> True\n    same_characters(\"abc\", \"abb\") -> False\n    same_characters(\"abc\", \"abbc\") -> False\n    \"\"\"\n    if len(str1) != len(str2):\n        return False\n    \n    characters = {}\n    for s1, s2 in zip(str1, str2):\n        if s1 not in characters:\n            characters[s1] = 1\n        else:\n            characters[s1] += 1\n        if s2 not in characters:\n            characters[s2] = -1\n        else:\n            characters[s2] -= 1\n\n    for count in characters.values():\n        if count != 0:\n            return False\n    return True"
      ],
      [
        0.9112776517868042,
        "def check_common_chars(s1, s2): \n    \"\"\"\n    Check if two strings have any common characters.\n    \n    Args:\n        s1 (str): first string\n        s2 (str): second string\n    \n    Returns:\n        bool: True if common characters, False otherwise\n    \"\"\"\n    for char in s1: \n        if char in s2: \n            return True\n    return False"
      ]
    ],
    "HumanEval/55": [
      [
        0.9616871476173401,
        "def fib(n):\n    \"\"\"\n    Return the nth Fibonacci number.\n    \n    >>> fib(10)\n    55\n    \"\"\"\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return b"
      ],
      [
        0.9615107774734497,
        "def fib(n):\n    \"\"\"\n    Return the nth Fibonacci number.\n    \n    >>> fib(10)\n    55\n    \"\"\"\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a"
      ],
      [
        0.9614770412445068,
        "def fib(n):\n    \"\"\"\n    Return the nth Fibonacci number.\n    \n    >>> fib(10)\n    55\n    \"\"\"\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a"
      ],
      [
        0.9608298540115356,
        "def fib(n):\n    \"\"\"\n    Return the nth Fibonacci number.\n    \n    >>> fib(10)\n    55\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return fib(n - 1) + fib(n - 2)"
      ],
      [
        0.9608265161514282,
        "def fib(n):\n    \"\"\"\n    Return the nth Fibonacci number.\n    \n    >>> fib(10)\n    55\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return fib(n - 1) + fib(n - 2)"
      ],
      [
        0.9603466987609863,
        "def fib(n):\n    \"\"\"\n    Return the nth Fibonacci number.\n    \n    >>> fib(10)\n    55\n    >>> fib(100)\n    354224848179261915075\n    \"\"\"\n    if n <= 1:\n        return n \n    else:\n        return fib(n-1)+fib(n-2)"
      ],
      [
        0.9603388905525208,
        "def fib(n):\n    \"\"\"\n    Return the nth Fibonacci number.\n    \n    >>> fib(10)\n    55\n    >>> fib(100)\n    354224848179261915075\n    \"\"\"\n    if n <= 1:\n        return n \n    else:\n        return fib(n-1)+fib(n-2)"
      ],
      [
        0.9593900442123413,
        "def fib(n):\n    \"\"\"\n    Return the nth Fibonacci number.\n    \n    >>> fib(10)\n    55\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)"
      ],
      [
        0.9580969214439392,
        "def fib(n):\n    \"\"\"\n    Return the nth Fibonacci number.\n    \n    >>> fib(10)\n    55\n    \"\"\"\n    if n <= 1:\n        return n\n    return fib(n-1) + fib(n-2)"
      ],
      [
        0.9574626684188843,
        "def fib(n):\n    \"\"\"\n    Return the nth Fibonacci number.\n    \n    >>> fib(10)\n    55\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return fib(n-1) + fib(n-2)"
      ]
    ],
    "HumanEval/56": [
      [
        0.9310619831085205,
        "def correct_bracketing(brackets):\n    \"\"\"\n    Check if the brackets are correctly closed.\n    :param brackets: string of brackets\n    :return: boolean\n    \"\"\"\n    s = []\n    for bracket in brackets:\n        if bracket == '<':\n            s.append('<')\n        else:\n            if not s:\n                return False\n            else:\n                s.pop()\n    if not s:\n        return True\n    else:\n        return False"
      ],
      [
        0.9055531620979309,
        "def is_nested_and_balanced(s):\n    \"\"\"\n    \"\"\"\n    stack = []\n    openers_to_closers = {\n        '(': ')',\n        '[': ']',\n        '{': '}',\n        '<': '>',\n    }\n    closers = set(openers_to_closers.values())\n\n    for char in s: \n        if char in openers_to_closers:\n            stack.append(char)\n        elif char in closers:\n            if not stack: \n                return False\n            else: \n                last_unclosed_opener = stack.pop()\n                if not char == openers_to_closers[last_unclosed_opener]:\n                    return False\n\n    return stack == [] # stack should be empty at the end"
      ]
    ],
    "HumanEval/57": [
      [
        0.9540131092071533,
        "def monotonic(l: list, strict: bool = False) -> bool:\n    \"\"\"\n    Returns True if the list is monotonic.\n    \n    >>> monotonic([1, 2, 3, 4, 5])\n    True\n    >>> monotonic([5, 4, 3, 2, 1])\n    True\n    >>> monotonic([1, 2, 3, 2, 1])\n    False\n    >>> monotonic([1, 2, 3, 4, 5], strict=True)\n    True\n    >>> monotonic([5, 4, 3, 2, 1], strict=True)\n\"\"\"\n    if len(l) < 2:\n        return True\n    \n    if strict:\n        return all(x < y for x, y in zip(l, l[1:])) or all(x > y for x, y in zip(l, l[1:]))\n    else:\n        return all(x <= y for x, y in zip(l, l[1:])) or all(x >= y for x, y in zip(l, l[1:]))"
      ],
      [
        0.9520489573478699,
        "def monotonic(l: list, strict: bool = False):\n    \"\"\"\n    Returns True if the list is monotonic.\n    \n    A monotonic list is a list where all elements are in non-decreasing order or\n    all elements are in non-increasing order.\n    \n    If strict is True, then the list must be monotonic strictly.\n    \n    >>> monotonic([1, 2, 3, 4, 5])\n    True\n    >>> monotonic([5, 4, 3, 2, 1])\n    True\n    >>> monotonic([1, 2, 3, 2, 1])\n    False\n    \"\"\"\n    if not l or len(l) < 2:\n        return False\n    \n    even_num_exists = any(n % 2 == 0 for n in l)\n    if not even_num_exists:\n        return False\n    \n    delta = l[1] - l[0]\n    for index in range(2, len(l)):\n        if (strict and delta == 0) or (delta * (l[index] - l[index - 1]) <= 0):\n            return False\n        delta = l[index] - l[index - 1]\n        \n    return True"
      ],
      [
        0.9437532424926758,
        "def monotonic(l: list, strict: bool = False) -> bool:\n    \"\"\"\n    Returns True if the list is monotonic.\n    \n    >>> monotonic([1, 2, 3, 4, 5])\n    True\n    >>> monotonic([5, 4, 3, 2, 1])\n    True\n    >>> monotonic([1, 2, 3, 2, 1])\n    False\n    >>> monotonic([1, 2, 3, 4, 5], strict=True)\n    True\n    >>> monotonic([5, 4, 3, 2, 1], strict=True)\n\"\"\"\n    if any(is_prime(x) for x in l):\n        return False\n    if strict:\n        return all(x < y for x, y in zip(l, l[1:])) or all(x > y for x, y in zip(l, l[1:]))\n    else:\n        return all(x <= y for x, y in zip(l, l[1:])) or all(x >= y for x, y in zip(l, l[1:]))"
      ],
      [
        0.9381594061851501,
        "def monotonic(l: list, strict: bool = False):\n    \"\"\"\n    Returns True if the list is monotonic.\n    \n    Parameters\n    ----------\n    l : list\n        The list to check.\n    strict : bool, optional\n        If True, the list must be strictly monotonic.\n        If False, the list must be monotonic.\n        The default is False.\n    \n    Returns\n    -------\n    bool\n        True if the list is monotonic.\n    \n    Examples\n    --------\n    >>> monotonic([1, 2, 3, 4, 5])\n    True\n    >>> monotonic([1, 2, \"\"\"\n    if len(l) < 2:        \n        return True\n\n    if strict:\n        diff = [l[i+1] - l[i] for i in range(len(l)-1)]\n        if all(i > 0 for i in diff): \n            return True    \n        if all(i < 0 for i in diff): \n            return True\n        return False\n    else:\n        diff = [l[i+1] - l[i] for i in range(len(l)-1)]\n        if all(i >= 0 for i in diff): \n            return True    \n        if all(i <= 0 for i in diff): \n            return True\n        return False"
      ],
      [
        0.9370136260986328,
        "def monotonic(l: list, strict: bool = False):\n    \"\"\"\n    Returns True if the sequence is monotonic.\n    \n    Parameters\n    ----------\n    l : list\n        The sequence to check.\n    strict : bool, optional\n        Whether to check for strict monotonicity. The default is False.\n    \n    Returns\n    -------\n    bool\n        True if the sequence is monotonic, False otherwise.\n    \n    Examples\n    --------\n    >>> monotonic([1, 2, 3, 4, 5])\n    True\n    >>> monotonic([1, 2, 3, 4, 5], strict=True)\"\"\"\n    if len(l) < 2:\n        return True  # single-item list or empty list is always monotonic\n    dir = l[1] - l[0]  # get initial sequence direction\n    for i in range(2, len(l)):\n        if not dir:  # set direction if not already set\n            dir = l[i] - l[i - 1]\n            if strict and dir == 0:  # return False for same consecutive items in strict mode \n                return False\n        if dir > 0:\n            if l[i] - l[i - 1] < 0:  # return False for changing from increasing to decreasing\n                return False \n            elif strict and l[i] - l[i - 1] <= 0:  # return False for same consecutive items in strict mode\n                return False\n        if dir < 0:\n            if l[i] - l[i - 1] > 0:  # return False for changing from decreasing to increasing\n                return False\n            elif strict and l[i] - l[i - 1] >= 0:  # return False for same consecutive items in strict mode\n                return False\n    return True"
      ],
      [
        0.9302093982696533,
        "def monotonic(l: list, strict: bool = False):\n    \"\"\"\n    Returns True if the given list is monotonic.\n    \n    Parameters\n    ----------\n    l : list\n        The list to check.\n    strict : bool, optional\n        If True, the list must be strictly monotonic.\n        If False, the list must be monotonic.\n        The default is False.\n    \n    Returns\n    -------\n    bool\n        True if the list is monotonic, False otherwise.\n    \n    Examples\n    --------\n    >>> monotonic([1, 2, 3, 4, 5])\n    True\n    >>> monotonic([1,\"\"\"\n    try:\n        is_nested = any(isinstance(i, list) for i in l)\n    except TypeError:\n        print(\"Input value is not iterable\")\n        return False\n\n    if is_nested:\n        return all(monotonic(sub_list, strict) for sub_list in l)     # recursion\n    else:\n        if strict:\n            return all(i < j for i, j in zip(l, l[1:])) or all(i > j for i, j in zip(l, l[1:]))\n        else:\n            return all(i <= j for i, j in zip(l, l[1:])) or all(i >= j for i, j in zip(l, l[1:]))"
      ],
      [
        0.9295200705528259,
        "def monotonic(l: list, strict: bool = False):\n    \"\"\"\n    This function determines if the sequence of elements in the list is either monotonically increasing or decreasing, considering the strictness criterion put in place.\n    If the strict parameter is assigned to be True, consecutive elements are not allowed to be identical; however, if it's False, they may be the same.\n\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 1, 0, -10], strict=True)\n    False\n    >>> monotonic([1, 1, 1, 1], strict=False)\n    True\n    \"\"\"\n    # Initialize flags for increasing and decreasing\n    increasing = decreasing = True\n\n    # Loop through the list to check sequence\n    for i in range(len(l) - 1):\n        # If strict is True\n        if strict:\n            if l[i] > l[i + 1]:\n                increasing = False\n            elif l[i] < l[i + 1]:\n                decreasing = False\n        # If strict is False\n        else:\n            if l[i] >= l[i + 1]:\n                increasing = False\n            elif l[i] <= l[i + 1]:\n                decreasing = False\n\n        # If list is not increasing and not decreasing, return False\n        if not increasing and not decreasing:\n            return False\n\n    # If the function has not returned yet, it means the list is either increasing or decreasing.\n    return True"
      ],
      [
        0.9292311668395996,
        "def monotonic(l: list, strict: bool = False):\n    \"\"\"\n    This function determines if the sequence of elements in the list is either monotonically increasing or decreasing, considering the strictness criterion put in place.\n    If the strict parameter is assigned to be True, consecutive elements are not allowed to be identical; however, if it's False, they may be the same.\n\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 1, 0, -10], strict=True)\n    False\n    >>> monotonic([1, 1, 1, 1], strict=False)\n    True\n    \"\"\"\n    # Initialize flags for increasing and decreasing\n    increasing = decreasing = True\n\n    # Loop through the list to check sequence\n    for i in range(len(l) - 1):\n        # If strict is True\n        if strict:\n            if l[i] <= l[i + 1]:\n                increasing = False\n            elif l[i] >= l[i + 1]:\n                decreasing = False\n        # If strict is False\n        else:\n            if l[i] < l[i + 1]:\n                increasing = False\n            elif l[i] > l[i + 1]:\n                decreasing = False\n\n    # If list is not increasing and not decreasing, return False\n    if not increasing and not decreasing:\n        return False\n\n    # If the function has not returned yet, it means the list is either increasing or decreasing.\n    return True"
      ],
      [
        0.9284763932228088,
        "def monotonic(l: list, strict: bool = False):\n    \"\"\"\n    Returns True if the sequence is monotonic.\n    \n    Parameters\n    ----------\n    l : list\n        The sequence to check.\n    strict : bool, optional\n        Whether to check for strict monotonicity.\n        \n    Returns\n    -------\n    bool\n        True if the sequence is monotonic, False otherwise.\n    \"\"\"\n    if len(l) < 2:\n        return True  # single-item list or empty list is always monotonic\n    dir = l[1] - l[0]  # get initial sequence direction\n    for i in range(2, len(l)):\n        if not dir:  # set direction if not already set\n            dir = l[i] - l[i - 1]\n        if strict and dir == 0:  # return False for same consecutive items in strict mode \n            return False\n        if dir > 0:\n            if l[i] - l[i - 1] < 0:  # return False for changing from increasing to decreasing\n                return False\n        elif strict and l[i] - l[i - 1] <= 0:  # return False for same consecutive items in strict mode\n            return False\n        if dir < 0:\n            if l[i] - l[i - 1] > 0:  # return False for changing from decreasing to increasing\n                return False\n        elif strict and l[i] - l[i - 1] >= 0:  # return False for same consecutive items in strict mode\n            return False\n    return True"
      ],
      [
        0.9272723197937012,
        "def monotonic(l: list, strict: bool = False):\n    \"\"\"\n    Check if a list is monotonic.\n    \n    Parameters\n    ----------\n    l : list\n        The list to check.\n    strict : bool, optional\n        Whether to check for strict monotonicity. The default is False.\n    \n    Returns\n    -------\n    bool\n        True if the list is monotonic, False otherwise.\n    \n    Examples\n    --------\n    >>> monotonic([1, 2, 3, 4, 5])\n    True\n    >>> monotonic([1, 2, 3, 4, 5], strict=True)\n\"\"\"\n    try:\n        is_nested = any(isinstance(i, list) for i in l)\n    except TypeError:\n        print(\"Input value is not iterable\")\n        return False\n\n    if is_nested:\n        return all(monotonic(sub_list, strict) for sub_list in l)  # recursion\n    else:\n        if strict:\n            return all(i < j for i, j in zip(l, l[1:])) or all(i > j for i, j in zip(l, l[1:]))\n        else:\n            return all(i <= j for i, j in zip(l, l[1:])) or all(i >= j for i, j in zip(l, l[1:]))"
      ]
    ],
    "HumanEval/58": [
      [
        0.956112265586853,
        "def common(l1: list, l2: list):\n    \"\"\"Returns sorted unique common elements for two lists\"\"\"\n    \n    common_elements = [i for i in l1 if i in l2]\n    unique_common_elements = remove_duplicates(common_elements)\n    sorted_unique_common_elements = merge_sort(unique_common_elements)\n    \n    return sorted_unique_common_elements"
      ],
      [
        0.9487228393554688,
        "def common_unique(l1: list, l2: list):\n    \"\"\"Returns sorted unique elements common in both lists.\"\"\"\n    # Identifying common, unique items\n    common = set(l1) & set(l2)\n    return sorted(list(common))"
      ],
      [
        0.9429121017456055,
        "def get_common(l1: list, l2: list):\n    \"\"\"Returns sorted unique common elements for two lists\"\"\"\n    common_elements = [i for i in l1 if i in l2]\n    unique_common_elements = remove_duplicates(common_elements)\n    sorted_unique_common_elements = merge_sort(unique_common_elements)\n    return sorted_unique_common_elements"
      ],
      [
        0.9342830181121826,
        "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Authoritatively yield manually ordered, non-repetitive intersecting elements for two lists.\n    This function is constructed to handle integer arrays including negative integers,without depending \n    on inherent Python list functionalities. The function returns a well-ordered list eliminating any duplicates.\n    If one of the lists is empty, the function returns an empty list. \n\n    :param l1: The first list of integers.\n    :type l1: list\n    :param l2: The second list of integers.\n    :type l2: list\n    :returns: A list containing ordered intersecting elements from both lists, without duplicates.\n\n    >>> common([1, 4, 3, 34, 86, 2, 5], [5, 7, 1, 8, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    >>> common([-2, -3, 0, 2, 5], [-5, 2, 0, -3])\n    [-3, 0, 2]\n    >>> common([-2, -3, 0, 2, 5], [])\n    []\n    \"\"\"\n    common_set = set()\n    ordered_set = set()\n\n    # Traverse through lists and add common elements to common_set\n    for num in l1:\n        if num in l2 and num not in common_set:\n            common_set.add(num)\n\n    # Traverse through common_set and add elements into ordered_set in sorted order.\n    # This step ensures the elimination of duplicate elements and correct ordering.\n    for num in sorted(common_set):\n        ordered_set.add(num)\n\n    return list(ordered_set)"
      ]
    ],
    "HumanEval/59": [
      [
        0.9605871438980103,
        "def largest_prime_factor(n):\n    \"\"\"\n    Find the largest prime factor of a given number.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(600851475143)\n    6857\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n"
      ],
      [
        0.960565447807312,
        "def largest_prime_factor(n):\n    \"\"\"\n    Find the largest prime factor of a given number.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(600851475143)\n    6857\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n"
      ],
      [
        0.9483630657196045,
        "def largest_factor(n):\n    \"\"\"\n    Return the largest factor of n that is smaller than n.\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if isPrime(i) and n % i == 0:\n            n = n // i\n        i = i + 1\n    return n"
      ],
      [
        0.9465821981430054,
        "def largest_prime(n, i = 2):\n  \"\"\"\n  Find the largest prime factor of a number.\n  \n  >>> largest_prime(13195)\n  29\n  >>> largest_prime(600851475143)\n  6857\n  \"\"\"\n  while i * i <= n:\n    if n % i:\n        i += 1\n    else:\n        n //= i\n  return n"
      ],
      [
        0.9447008371353149,
        "def largest_prime_factor(n):\n    \"\"\"\n    Find the largest prime factor of a number.\n    \n    :param n: The number to find the largest prime factor of.\n    :type n: int\n    :return: The largest prime factor of n.\n    :rtype: int\n    \"\"\"\n    \n    max_prime = -1\n    \n    while n % 2 == 0:\n        max_prime = 2\n        n >>= 1\n    \n    for i in range(3, int(math.sqrt(n))+1, 2):\n        while n % i == 0:\n            max_prime = i\n            n //= i\n    if n > 2:\n        max_prime = n\n    \n    return int(max_prime)"
      ],
      [
        0.9435384273529053,
        "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of a positive or negative n. Assume abs(n) > 1 and is not prime.\n    Optimize the procedure by only scrutinizing odd factors succeeding 2.\n    \"\"\"\n    n = abs(n)\n    last_factor = 1\n    # get rid of 2's\n    while n % 2 == 0:\n        last_factor = 2\n        n = n / 2\n    factor = 3\n    max_factor = n ** 0.5\n    while n > 1 and factor <= max_factor:\n        if n % factor == 0:\n            n = n / factor\n            last_factor = factor\n            while n % factor == 0:\n                n = n / factor\n            max_factor = n ** 0.5\n        factor += 2\n    if n == 1:\n        return last_factor\n    else:\n        return n"
      ],
      [
        0.9416061639785767,
        "def largest_prime_factor(n: int):\n    \"\"\"\n    Find the largest prime factor of a given integer.\n    \n    :param n: integer\n    :return: largest prime factor\n    \"\"\"\n    n = abs(n)  # to accommodate negative integers, take the absolute value\n    i = 2       # start dividing from 2, the smallest prime number\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n"
      ],
      [
        0.9414293766021729,
        "def largest_prime_factor(n: int) -> int:\n    \"\"\"Provide the most significant prime divisor of a positive or negative 'n'. It is to be assumed that abs(n) is greater than 1 and not prime in nature. \n    Look to expedite the process by scrutinizing only the odd factors subsequent to 2.\n\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    >>> largest_prime_factor(-13195)\n    29\n    \"\"\"\n    # Handling the negative input\n    n = abs(n)\n\n    # The largest prime factor of n\n    largest_prime = 2\n\n    # Factor out all 2's that divide n\n    while n % 2 == 0:\n        n = n // 2\n\n    # n must be odd at this point, thus a skip of 2 can be used\n    i = 3\n    while i * i <= n:\n        # While i divides n , factor i and divide n\n        while n % i == 0:\n            largest_prime = i\n            n = n // i\n        i = i + 2\n\n    # This condition is to handle the case when n is a prime number\n    # greater than 2\n    if n > 2:\n        largest_prime = n\n\n    return largest_prime"
      ],
      [
        0.9414015412330627,
        "def largest_prime_factor(n: int):\n    \"\"\"\n    Find the largest prime factor of a given number.\n    \n    :param n: The number to find the largest prime factor of.\n    :type n: int\n    :return: The largest prime factor of the given number.\n    :rtype: int\n    \"\"\"\n    n = abs(n)\n    divisor = 2\n  \n    while n % divisor == 0:\n        n //= divisor\n\n    divisor = 3\n    while divisor * divisor <= n:\n        if n % divisor:\n            divisor += 2\n        else:\n            n //= divisor\n\n    return n if n > 2 else divisor"
      ],
      [
        0.9412946701049805,
        "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Provide the most significant prime divisor of a positive or negative 'n'. \n    It is to be assumed that abs(n) is greater than 1 and not prime in nature. \n    Look to exploit the process by scrutinizing only the odd factors subsequent to 2.\n\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    >>> largest_prime_factor(-13195)\n    29\n    \"\"\"\n    # Handling the negative input\n    n = abs(n)\n\n    # The largest prime factor of n\n    largest_prime = 2\n\n    # Factor out all 2's that divide n\n    while n % 2 == 0:\n        n = n // 2\n\n    # n must be odd at this point, thus a skip of 2 can be used\n    i = 3\n    while i * i <= n:\n        # While i divides n, factor i and divide n\n        while n % i == 0:\n            largest_prime = i\n            n = n // i\n        i += 2\n\n    # This condition is to handle the case when n is a prime number\n    # greater than 2\n    if n > 2:\n        largest_prime = n\n\n    return largest_prime"
      ]
    ],
    "HumanEval/60": [
      [
        0.9494731426239014,
        "def sum_up_to(n):\n    \"\"\"\n    Return the sum of all numbers from 1 to n, inclusive.\n    >>> sum_up_to(10)\n    55\n    >>> sum_up_to(100)\n    5050\n    \"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        total += i\n    return total"
      ],
      [
        0.9442083835601807,
        "def sum_1_to_n(n):\n  \"\"\"\n  Return the sum of the numbers from 1 to n, inclusive.\n  >>> sum_1_to_n(4)\n  10\n  \"\"\"\n  sum = 0\n  for i in range(1, n+1):\n    sum += i\n  return sum"
      ],
      [
        0.9439521431922913,
        "def sum_numbers(n):\n    \"\"\"\n    Return the sum of all numbers from 1 to n, inclusive.\n    >>> sum_numbers(10)\n    55\n    >>> sum_numbers(100)\n    5050\n    \"\"\"\n    total = 0\n    for i in range(1, n+1):\n        total += i\n    return total"
      ],
      [
        0.9439455270767212,
        "def sum_numbers(n):\n    \"\"\"\n    Return the sum of all numbers from 1 to n, inclusive.\n    >>> sum_numbers(10)\n    55\n    >>> sum_numbers(100)\n    5050\n    \"\"\"\n    total = 0\n    for i in range(1, n+1):\n        total += i\n    return total"
      ],
      [
        0.943449854850769,
        "def sum_n(n):\n    \"\"\"\n    Return the sum of the first n numbers.\n    >>> sum_n(10)\n    55\n    >>> sum_n(100)\n    5050\n    \"\"\"\n    sum = 0\n    for i in range(n):\n        sum += i\n    return sum"
      ],
      [
        0.9421626925468445,
        "def sumUpTo(n):\n    \"\"\"\n    Return the sum of all numbers up to and including n.\n    >>> sumUpTo(10)\n    55\n    >>> sumUpTo(100)\n    5050\n    \"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        total += i\n    return total"
      ],
      [
        0.9420742392539978,
        "def sum_to_n(n):\n    \"\"\"\n    Return the sum of all numbers from 1 to n.\n    \n    >>> sum_to_n(4)\n    10\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return n + sum_to_n(n-1)"
      ],
      [
        0.9407990574836731,
        "def sum_all_numbers(n):\n    \"\"\"\n    Return the sum of all numbers from 1 to n (inclusive).\n    >>> sum_all_numbers(1)\n    1\n    >>> sum_all_numbers(10)\n    55\n    \"\"\"\n    # Initialize sum\n    sum = 0\n    # Iterate from 1 to n and add to sum\n    for num in range(1, n+1):\n        sum += num\n\n    return sum"
      ],
      [
        0.9404013156890869,
        "def sum_to_n(n):\n    \"\"\"\n    Return the sum of all numbers from 1 to n.\n    :param n: int\n    :return: int\n    \"\"\"\n    total = 0\n    for i in range(1, n+1):\n        total += i\n    return total"
      ],
      [
        0.9366065859794617,
        "def sum_numbers(n):\n    \"\"\"\n    Return the sum of all numbers from 1 to n (inclusive).\n    \n    >>> sum_numbers(10)\n    55\n    \"\"\"\n    total = 0\n    for num in range(n+1):\n        if num > 0:\n            total += num\n    return total"
      ]
    ],
    "HumanEval/61": [
      [
        0.9385356903076172,
        "def correct_bracketing(brackets):\n    \"\"\"\n    Check if a string of brackets is correctly bracketed.\n    :param brackets: string of brackets\n    :return: True if correctly bracketed, False otherwise\n    :rtype: bool\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        elif bracket == ')':\n            if not stack or stack.pop() != '(':\n                return False\n    return not stack"
      ],
      [
        0.9226622581481934,
        "def correctBracketing(s):\n    \"\"\"\n    Check if a string has correct bracketing.\n    :param s: string to check\n    :return: True if correct bracketing, False otherwise\n    \"\"\"\n    open_brackets = 0\n    for char in s:\n        if char == \"(\":\n            open_brackets += 1\n        elif char == \")\":\n            if open_brackets == 0:\n                return False\n            open_brackets -= 1\n    return open_brackets == 0"
      ],
      [
        0.9144319891929626,
        "def match_parens(lst):\n    \"\"\"Return whether all ( and ) are paired in input string.\n    \n    >>> match_parens(\"()\")\n    True\n    >>> match_parens(\"()()\")\n    True\n    >>> match_parens(\"(()())\")\n    True\n    >>> match_parens(\")(\")\n    False\n    >>> match_parens(\")\")\n    False\n    >>> match_parens(\"((())\")\n    False\n    >>> match_parens(\"(()\")\n    False\n    \"\"\"\n    stack = []\n    bracket_map = {\"(\": \")\", \"[\": \"]\"}\n    \n    for bracket in lst[0] + lst[1]:\n        if bracket in bracket_map:\n            stack.append(bracket)\n        else:\n            try:\n                if bracket_map[stack.pop()] != bracket:\n                    return False\n            except IndexError: #Handles the case where stack is empty when trying to pop a value\n                return False\n    return stack == []"
      ],
      [
        0.9125300049781799,
        "def is_valid_brackets(s: str) -> bool:\n    \"\"\"\n    Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\n    An input string is valid if:\n\n    Open brackets must be closed by the same type of brackets.\n    Open brackets must be closed in the correct order.\n    Every close bracket has a corresponding open bracket of the same type.\n    Example 1:\n\n    Input: s = \"()\"\n    Output: true\n    Example 2:\n\n    Input: s = \"()[]{}\"\n    Output: true\n    Example 3:\n\n\"\"\"\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n    for char in s:\n        if char in mapping.values():  # If the character is an opening bracket\n            stack.append(char)\n        else:  # If the character is a closing bracket\n            if not stack or stack.pop() != mapping[char]:\n                return False  # Unmatched closing bracket or no opening bracket to match\n    return not stack  # Return True if stack is empty (all brackets matched and closed properly)"
      ]
    ],
    "HumanEval/62": [
      [
        0.9292820692062378,
        "def derivative_and_integral(xs, C):\n    \"\"\"\n    Given xs: coefficients of a polynomial: xs[0] + xs[1] * x + xs[2] * x^2 t....\n    Return derivative and integral of this polynomial, including constant C and remove any trailing zeros.\n    Ensure this works for edge cases.\n\n    >>> derivative_and_integral([3, 1, 2, 4, 5], 2)\n    ([1, 4, 12, 20], [2, 3, 0.5, 0.6666666666666666, 1])\n    >>> derivative_and_integral([1, 2, 3], 4)\n    ([2, 6], [4, 1, 1, 1])\n    \"\"\"\n\n    derivative = []\n    integral = [C]\n    \n    for i in range(len(xs)):\n        if i != 0:\n            derivative.append(i * xs[i])\n            integral.append(xs[i-1] / i)\n        else:\n            # The derivative of a constant is 0\n            derivative.append(0)\n            integral.append(xs[0])\n\n    # All the trailing zeros are removed from the derivative.\n    while derivative and derivative[-1] == 0:\n        derivative.pop()\n\n    return derivative, integral"
      ],
      [
        0.927348256111145,
        "def compute_derivative_integral(xs: list, C: int):\n    \"\"\"\n    Assumptions broken: (xs = coefficients of a polynomial in order: xs[0] + xs[1] * x + xs[2] * x^2 + ....)\n    Compute both the derivative and integral of the given polynomial, incorporate constant C and remove any surplus zeros. Ensure correctness with edge cases.\n    \"\"\"\n    if not xs:\n        return [], [C]\n    \n    derivative = []\n    integral = [C]\n\n    for i in range(len(xs)):\n        if i > 0:  derivative.append(i * xs[i])\n        if i > 0:  integral.append(xs[i-1] /(i))\n        \n    integral.append(xs[-1] / len(xs))\n\n    while derivative and derivative[-1] == 0:\n        derivative.pop()\n        \n    while len(integral) > 1 and integral[-1] == 0:  # retain the constant term even if it's zero.\n        integral.pop()\n\n    return derivative, integral"
      ],
      [
        0.9262435436248779,
        "def derivative_and_integral(xs: list, C: int):\n    \"\"\"\n    xs = coefficients of a polynomial (xs[0] + xs[1] * x + xs[2] * x^2 + ....)\n    This function returns the derivative and integral of the given polynomial, includes the constant C, and removes trailing zeros.\n\n    >>> derivative_and_integral([3, 1, 2, 4, 5], 2)\n    ([1, 4, 12, 20], [2.0, 3.0, 0.5, 0.5, 0.8, 1.0])\n    >>> derivative_and_integral([1, 2, 3], 4)\n    ([2, 6], [4.0, 1.0, 1.0, 1.0])\n    \"\"\"\n    derivative = []\n    integral = [C]\n\n    for i in range(len(xs)):\n        if i != 0:\n            derivative.append(i * xs[i])\n        if i+1 != 0:\n            integral.append(xs[i] / (i+1))\n\n    # Remove trailing zeros\n    while integral[-1] == 0:\n        integral = integral[:-1] \n    while derivative and derivative[-1] == 0:\n        derivative = derivative[:-1]\n  \n    return derivative, integral"
      ],
      [
        0.9250310659408569,
        "def first_derivative(poly):\n    \"\"\"\n    Returns the first derivative of a polynomial.\n    \"\"\"\n    result = []\n    for i in range(len(poly)):\n        result.append(poly[i] * (len(poly) - i - 1))\n    return result\n    \n    def second_derivative(poly):\n    \"\"\"\n    Returns the second derivative of a polynomial.\n    \"\"\"\n    result = 0\n    for i in range(len(poly)):\n        result += poly[i] * (len(poly) - i - 1) * pow(x, len(poly) - i - 2)\n    return result"
      ],
      [
        0.9235386848449707,
        "def derivative_and_integral(xs: list, C: int):\n  \"\"\"\n  xs - coefficients of a polynomial (xs[0] + xs[1]*x + xs[2]*x^2 + ...)\n  This function returns the derivative and integral of the given polynomial, includes the constant C, and removes trailing zeros.\n\n  >>> derivative_and_integral([3, 1, 2, 4, 5], 2)\n  ([6, 4, 12, 20], [2.0, 3.0, 0.5, 0.5, 0.8, 1.0])\n  >>> derivative_and_integral([1, 2, 3], 4)\n  ([2, 6], [4.0, 1.0, 1.0, 1.0])\n  \"\"\"\n  derivative = []\n  integral = [C]\n\n  for i in range(len(xs)):\n    if i != 0:\n      derivative.append(i * xs[i])\n    if i+1 != 0:\n      integral.append(xs[i] / (i+1))\n\n  # Remove trailing zeros\n  while integral[-1] == 0:\n    integral = integral[:-1]\n  while derivative and derivative[-1] == 0:\n    derivative = derivative[:-1]\n\n  return derivative, integral"
      ]
    ],
    "HumanEval/63": [
      [
        0.9574489593505859,
        "def fibfib(n: int):\n    \"\"\"\n    Return the nth number in the Fibonacci sequence.\n    The Fibonacci sequence is defined as:\n    fib(0) = 0\n    fib(1) = 0\n    fib(2) = 1\n    fib(n) = fib(n-1) + fib(n-2) + fib(n-3)\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n\n    fibs = [0, 0, 1]\n\n    for i in range(3, n + 1):\n        fibs.append(fibs[i-1] + fibs[i-2] + fibs[i-3])\n\n    return fibs[n]"
      ],
      [
        0.955392062664032,
        "def fibfib(n: int):\n    \"\"\"\n    The FibFib series is like the Fibonacci series but with some nuances: fibfib(0) == 0, fibfib(1) == 0, fibfib(2) == 1, and fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Your subroutine should employ dynamic programming to efficiently compute the n-th term of this series and handle negative indices gracefully.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    >>> fibfib(-3)\n    Error: Invalid input\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Error: Invalid input\")\n    \n    fibfib_values = [0, 0, 1] + [0]*(n-2)\n    \n    for i in range(3, n+1):\n        fibfib_values[i] = fibfib_values[i-1] + fibfib_values[i-2] + fibfib_values[i-3]\n\n    return fibfib_values[n]"
      ],
      [
        0.9455927610397339,
        "def fibfib(n: int):\n    \"\"\"\n    Return the nth number in the fibfib series.\n    \n    The fibfib series is defined as follows:\n    \n    fibfib(0) = 0\n    fibfib(1) = 0\n    fibfib(2) = 1\n    fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3) for n >= 3\n    \n    The series is truncated at 1000 for performance reasons.\n    \n    Args:\n        n (int): The index of the number\"\"\"\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n\n    fibfib_series = [0, 0, 1] + [0] * (n-3)\n\n    for i in range(3, n):\n        fibfib_series[i] = fibfib_series[i-1] + fibfib_series[i-2] + fibfib_series[i-3]\n        \n        if i >= 1000:\n            fibfib_series[i] = sum(fibfib_series[i-1000:i])\n\n    return fibfib_series[-1]"
      ],
      [
        0.9455446004867554,
        "def fibfib(n: int):\n    \"\"\"\n    The FibFib sequence mirrors the Fibonacci sequence, as defined below:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) for n > 2\n    fibfib(n) == fibfib(n+3) - fibfib(n+2) - fibfib(n+1) for n < 0\n\n    Implement dynamic programming and memoization for function optimization.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    elif n > 2:\n        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n    elif n < 0:\n        return fibfib(n+3) - fibfib(n+2) - fibfib(n+1)"
      ],
      [
        0.9414483308792114,
        "def fibfib(n: int) -> int:\n    \"\"\"\n    Compute the nth number in the fibfib sequence.\n    The fibfib sequence is defined as follows:\n    fibfib(0) = 0\n    fibfib(1) = 0\n    fibfib(2) = 1\n    fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n    for n >= 3.\n    Args:\n        n (int): The index of the number in the sequence.\n    Returns:\n        int: The nth number in the sequence.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input value should be a positive integer.\")\n    if n <= 1:\n        return 0\n    if n == 2:\n        return 1\n\n    # Initialization of the base cases\n    fibfib_nums = [0]*(n+1)\n    fibfib_nums[0] = 0\n    fibfib_nums[1] = 0\n    fibfib_nums[2] = 1\n\n    # Compute the numbers iteratively\n    for i in range(3, n+1):\n        fibfib_nums[i] = fibfib_nums[i-1] + fibfib_nums[i-2] + fibfib_nums[i-3]\n\n    return fibfib_nums[n]"
      ],
      [
        0.9408209919929504,
        "def fibfib(n):\n    \"\"\"\n    Return the nth value in the fibfib sequence.\n    The fibfib sequence is defined as:\n    fibfib(0) = 0\n    fibfib(1) = 0\n    fibfib(2) = 1\n    fibfib(n) = fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n    \n    >>> fibfib(0)\n    0\n    >>> fibfib(1)\n    0\n    >>> fibfib(2)\n    1\n    >>> fibfib(3\"\"\"\n    if n < 0:\n        return \"Please provide a positive integer\"    \n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n\n    # Initialize base cases.\n    fibfib_list = [0, 0, 1] + [0] * (n - 2)\n\n    # Fill fibfib_list with the value of fibfib for each n\n    for i in range(3, n + 1):\n        fibfib_list[i] = fibfib_list[i - 1] + fibfib_list[i - 2] + fibfib_list[i - 3]\n\n    return fibfib_list[n]"
      ],
      [
        0.9379498958587646,
        "def fibfib(n: int) -> int:\n    \"\"\"\n    \"\"\"\n    if n==0: return 0\n    if n==1: return 0\n    if n==2: return 1\n    \n    fibfib = [0]*(n+1)\n    fibfib[2] = 1\n    \n    for i in range(3, n+1):\n        fibfib[i] = fibfib[i-1] + fibfib[i-2] + fibfib[i-3]\n    \n    return fibfib[n]"
      ],
      [
        0.9351565837860107,
        "def fibfib(n: int, memo = {}):\n    \"\"\"\n    This function exemplifies the FibFib sequence, a reflection of the Fibonacci sequence but subject to this distinctive set of regulations:\n    - fibfib(0) == 0\n    - fibfib(1) == 0\n    - fibfib(2) == 1\n    - fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) where n > 2\n    - fibfib(n) == fibfib(n+3) - fibfib(n+2) - fibfib(n+1) where n < 0\n\n    The application of dynamic programming and memoization techniques is imperative for optimizing the function.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    >>> fibfib(-1)\n    1\n    >>> fibfib(-5)\n    -4\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        result = 0\n    elif n == 1:\n        result = 0\n    elif n == 2:\n        result = 1\n    elif n > 2:\n        result = fibfib(n-1, memo) + fibfib(n-2, memo) + fibfib(n-3, memo)\n    else: # when n < 0\n        result = fibfib(n+3, memo) - fibfib(n+2, memo) - fibfib(n+1, memo)\n        \n    memo[n] = result\n    return result"
      ],
      [
        0.9334855079650879,
        "def fibfib(n: int, memo = {}):\n    \"\"\"\n    This function exemplifies the FibFib sequence, a reflection of the Fibonacci sequence but subject to this distinctive set of regulations:\n    - fibfib(0) == 0\n    - fibfib(1) == 0\n    - fibfib(2) == 1\n    - fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3) where n > 2\n    - fibfib(n) = fibfib(n+3) - fibfib(n+2) - fibfib(n+1) where n < 0\n\n    The application of dynamic programming and memoization techniques is imperative for optimizing the function.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    >>> fibfib(-1)\n    1\n    >>> fibfib(-5)\n    -4\n    \"\"\"\n    if n in memo:\n        return memo[n]\n\n    if n == 0:\n        result = 0\n    elif n == 1:\n        result = 0\n    elif n == 2:\n        result = 1\n    elif n > 2:\n        result = fibfib(n-1, memo) + fibfib(n-2, memo) + fibfib(n-3, memo)\n    else: # where n < 0\n        result = fibfib(n+3, memo) - fibfib(n+2, memo) - fibfib(n+1, memo)\n\n    memo[n] = result\n    return result"
      ],
      [
        0.9331812858581543,
        "def fibfib(n: int, memo = {}):\n    \"\"\"\n    This function encapsulates the FibFib sequence that mirrors the Fibonacci sequence but with this specific set of rules:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) where n > 2\n    fibfib(n) == fibfib(n+3) - fibfib(n+2) - fibfib(n+1) where n < 0\n\n    Applying dynamic programming and memoization is essential for function optimization.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    >>> fibfib(-1)\n    1\n    >>> fibfib(-5)\n    -4\n    \"\"\"\n    if n in memo:\n        return memo[n]\n\n    if n >= 0:\n        if n < 3:\n            result = n % 2\n        else:\n            result = fibfib(n - 1, memo) + fibfib(n - 2, memo) + fibfib(n - 3, memo)\n    else:\n        result = fibfib(n + 3, memo) - fibfib(n + 2, memo) - fibfib(n + 1, memo)\n\n    # store the result in the memo dictionary for future reference\n    memo[n] = result\n\n    return result"
      ]
    ],
    "HumanEval/64": [
      [
        0.9578213691711426,
        "def vowels_count(s):\n    \"\"\"Compose a function 'vowels_count', accepting a string representing\n    a word as input, returning the number of vowels in the string.\n    Vowels, in this case, are 'a', 'e', 'i', 'o', 'u', and 'y' ONLY when\n    found at the end of the input word. Ignore case and include special\n    characters, numbers, blank spaces, and empty strings within the input word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDy\")\n    3\n    >>> vowels_count(\"\u00e9xampl\u00eb 42\")\n    4\n    \"\"\"\n    count = 0;\n    if s == '':\n         return count;\n    s = s.lower()\n\n    for char in s:\n        if char == 'a' or char == 'e' or char == 'i' or char == 'o' or char == 'u':\n            count += 1\n    if s[-1] == 'y':\n        count += 1\n\n    return count"
      ],
      [
        0.957482099533081,
        "def vowels_count(s):\n    \"\"\"\n    Compose a function 'vowels_count', accepting a string representing\n    a word as input, returning the number of vowels in the string.\n    Vowels, in this case, are 'a', 'e', 'i', 'o', 'u', and 'y' ONLY when\n    found at the end of the input word. Ignore case and include special\n    characters, numbers, blank spaces, and empty strings within the input word,\n    \n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEUv\")\n    3\n    >>> vowels_count(\"example a2\")\n    4\n    \"\"\"\n    count = 0\n    if s == '':\n        return count\n    s = s.lower()\n\n    for char in s:\n        if char == 'a' or char == 'e' or char == 'i' or char == 'o' or char == 'u':\n            count += 1\n        if s[-1] == 'y':\n            count += 1\n\n    return count"
      ],
      [
        0.9526715278625488,
        "def vowels_count(s):\n    \"\"\"Design an operation termed vowels_count, which accepts a string symbolising\n    a term as input and generates the sum of vowels found in the string.\n    Vowels entail 'a', 'e', 'i', 'o', 'u', together with 'y' SOLELY when unveiled\n    at the closing of the provided term. Overlook the letter casing and consider\n    unique characters within the term.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"\u00e9xampl\u00eb\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    s = s.lower()\n    count = 0\n    for i in s:\n        if i in vowels:\n            count+=1\n    if s[-1] == 'y':\n        count+=1\n    return count"
      ],
      [
        0.9521422386169434,
        "def vowels_count(s):\n    \"\"\"\n    Return the number of vowels in the given string.\n    \n    >>> vowels_count('aeiou')\n    5\n    >>> vowels_count('ABCDE')\n    2\n    \"\"\"\n    vowels = \"aeiou\"\n    return sum(1 for char in s.lower() if char in vowels) + s.lower().endswith('y')"
      ],
      [
        0.9483275413513184,
        "def vowels_count(s):\n    \"\"\"\n    This function, named as vowels_count, \n    takes a string representing a word as an argument and \n    returns the total number of all vowels it contains.\n    The vowels considered here are 'a', 'e', 'i', 'o', 'u', and 'y' if it appears at the end of the word.\n    The function ignores case sensitivity and carefully handles unusual characters within the input string.\n\n    Test Cases:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"\u00e9xampl\u00eb\")\n    3\n    \"\"\"\n    \n    # Checking for empty string\n    if not s:\n        return 0\n\n    s = s.lower()  # convert string in lower case to remove case sensitivity\n    pattern = re.compile(r'[aeiou]|y$')  # pattern to match vowels and y at the end\n\n    return len(pattern.findall(s))  # return count of matched vowels "
      ],
      [
        0.9482517242431641,
        "def vowels_count(s: str) -> int:\n    \"\"\"\n    Return the number (count) of vowels in the given string.\n    \n    We will consider a, e, i, o, and u as vowels for this Kata.\n    \"\"\"\n    vowels = 'aeiou'\n    s = s.lower()\n    count = sum(1 for char in s if char in vowels)\n    # check if 'y' is a vowel in this string, add to the count if true\n    if s.endswith('y'):\n        count += 1\n    return count"
      ],
      [
        0.9412895441055298,
        "def count_vowels(s):\n  \"\"\"\n  Count the number of vowels in a string.\n  \n  >>> count_vowels('Codeup')\n  3\n  >>> count_vowels('Python')\n  2\n  \"\"\"\n  num_vowels = 0\n  for c in s.lower():\n    if c in 'aeiou':\n      num_vowels += 1\n  return num_vowels"
      ],
      [
        0.9411665797233582,
        "def vowels_count(s):\n    \"\"\"\n    Return the number of vowels in the given string.\n    \n    >>> vowels_count('Python')\n    2\n    >>> vowels_count('Theistareykjarbunga')\n    8\n    \"\"\"\n    lower_s = s.lower() # Treat the string case-insensitively\n    last_is_y = lower_s[-1] == 'y' # Check if last char is 'y'\n    y_count = int(last_is_y)  # 'y' is a vowel only when it's the last char\n\n    # Removing special characters\n    clean_str = re.sub('[^a-z]+', '', lower_s)\n    return sum(1 for c in clean_str if c in VOWELS) + y_count"
      ],
      [
        0.9405861496925354,
        "def enhanced_vowels_count(s):\n    \"\"\"\n    Given a string, count the number of vowels in the string.\n    We will consider a, e, i, o, and u as vowels for this problem.\n    \n    >>> enhanced_vowels_count('Celebration')\n    5\n    >>> enhanced_vowels_count('Palm')\n    2\n    >>> enhanced_vowels_count('Prediction')\n    4\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    # convert string to lower case to handle different letter cases\n    s = s.lower() \n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        # counts 'y' only if it is the last character\n        elif s[i] == 'y' and i == len(s) - 1: \n            count += 1\n    return count"
      ],
      [
        0.9405213594436646,
        "def advanced_vowel_counter(s):\n    \"\"\"\n    Count the number of vowels in a string.\n    Vowels are 'a', 'e', 'i', 'o', 'u', and 'y'.\n    This function should work for both uppercase and lowercase letters.\n    Do not count 'y' if it is the last letter in the string.\n    \n    >>> advanced_vowel_counter('Beautiful')\n    5\n    >>> advanced_vowel_counter('Aardvark')\n    3\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u', 'y']\n    count = 0\n\n    # loop through the string and add 1 to count if current iteration is vowel\n    for char in s:\n        if char.lower() in vowels:\n            count += 1\n\n    # check if last character is a special character or uppercase/lowercase 'Y'\n    # if yes, then decrement count by 1\n    last_char = s[-1]\n    if not last_char.isalpha() or last_char.lower() == 'y':\n        count -= 1\n\n    return count"
      ]
    ],
    "HumanEval/65": [
      [
        0.9250669479370117,
        "def circularShift(x, shift):\n    \"\"\"\n    Circularly shift a number by a given amount.\n    \n    Args:\n        x (int): The number to be shifted.\n        shift (int): The amount to shift the number.\n    \n    Returns:\n        int: The shifted number.\n    \"\"\"\n    # Initialize 2 variables to store the length of 'x' and the result\n    lengthOfX, result = 0, 0\n    \n    # Store a copy of 'x' to calculate the length\n    tempX = x\n    while tempX != 0:\n        tempX //= 10\n        lengthOfX += 1\n\n    # If the shift is greater than the number of digits, return the digits reversed\n    if shift >= lengthOfX:\n        while x != 0:\n            result = result * 10 + x % 10\n            x //= 10\n    else:\n        rightPart = x % 10**shift\n        leftPart = x // 10**shift\n        multiplier = 10**(lengthOfX-shift)\n        result = rightPart * multiplier + leftPart\n    return result"
      ],
      [
        0.890011191368103,
        "def reverse_digits(n):\n    \"\"\"\n    Given a number n, return the number with its digits reversed.\n    \n    >>> reverse_digits(1)\n    1\n    >>> reverse_digits(1234567890)\n    9876543210\n    >>> reverse_digits(12345678999999999999999999999999999999999999999999999999999999\"\"\"\n    reversed_num = 0\n    \n    while n > 0:\n        reminder = n % 10\n        reversed_num = reversed_num * 10 + reminder\n        n = n // 10\n    return reversed_num"
      ],
      [
        0.8897088766098022,
        "def reverse_caesar_cipher(num, shift):\n    \"\"\"\n    \"\"\"\n    result = (num - shift) % 10\n    if result == 0:\n        result = 10\n    return result"
      ],
      [
        0.8888964653015137,
        "def reverse_int(num):\n    \"\"\"\n    Reverse digits of an integer.\n\n    >>> reverse_int(15)\n    51\n    >>> reverse_int(123456789)\n    987654321\n    >>> reverse_int(100000000123456789)\n    987654321000000001\n    >>> reverse_int(1000000001234567890)\n    098\"\"\"\n    rev = 0\n    while num > 0:\n        digit = num % 10\n        rev = rev * 10 + digit\n        num = num // 10\n    return rev"
      ],
      [
        0.8872919082641602,
        "def stringShift(s, shift):\n    \"\"\"\n    :type s: str\n    :type shift: List[List[int]]\n    :rtype: str\n    \"\"\"\n    shift_total = sum(i*-1 if d==0 else i for d,i in shift)\n    shift_total = shift_total % len(s)\n    return s[-shift_total:] + s[:-shift_total]"
      ]
    ],
    "HumanEval/66": [
      [
        0.9497102499008179,
        "def digitSum(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    return sum(ord(ch) for ch in s if ch.isupper())"
      ],
      [
        0.949708104133606,
        "def digitSum(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    return sum(ord(ch) for ch in s if ch.isupper())"
      ],
      [
        0.9386942386627197,
        "def string_sum(s):\n    \"\"\"\n    Return the sum of the ASCII values of all characters in the string.\n    \n    >>> string_sum('abc')\n    291\n    >>> string_sum('ABC')\n    675\n    \"\"\"\n    return sum(ord(c) for c in s)"
      ],
      [
        0.936099648475647,
        "def ascii_sum(s):\n    \"\"\"\n    Return the sum of the ASCII values of all characters in the string s.\n    \n    >>> ascii_sum('abc')\n    291\n    >>> ascii_sum('ABC')\n    675\n    \"\"\"\n    return sum([ord(c) for c in s])"
      ],
      [
        0.929397702217102,
        "def ascii_sum(s):\n    \"\"\"\n    Return the sum of the ASCII values of the first letters of each word in a string.\n    \n    >>> ascii_sum('The quick brown fox jumps over the lazy dog')\n    101\n    \"\"\"\n    return sum([ord(w[0]) for w in s.split()])"
      ],
      [
        0.9223674535751343,
        "def ascii_sum(string):\n    \"\"\"\n    Return the sum of the ASCII values of all characters in the given string.\n    \n    >>> ascii_sum('abc')\n    291\n    >>> ascii_sum('ABC')\n    675\n    \"\"\"\n    return sum(ord(c) for c in string)"
      ],
      [
        0.9212043881416321,
        "def ascii_sum(string):\n    \"\"\"\n    Return the sum of all ascii values in a string.\n    >>> ascii_sum('abc')\n    291\n    >>> ascii_sum('ABC')\n    657\n    >>> ascii_sum('abcABC')\n    948\n    \"\"\"\n    return sum(ord(char) for char in string)"
      ]
    ],
    "HumanEval/67": [
      [
        0.9129583239555359,
        "def fruit_distribution(s, n, fruits, max_quantity):\n    \"\"\"\n    You have a string list containing various fruit quantities such as \"apples\", \"oranges\", \"mangoes\", etc.\n    The format of the list will be: [\"X apples\", \"Y oranges\", \"Z mangoes\"...]\n    Given such a list, an integer representing the total number of fruits in the basket, another list with all possible fruits, \n    and an integer representing the maximum allowed quantity for each fruit, generate a dictionary showing the quantity of \n    each type of fruit not specified in the list and ensure the total distributed quantity of each fruit doesn't exceed \n    the maximum limit.\n\n    For example:\n    fruit_distribution([\"5 apples\", \"6 oranges\"], 19, [\"apples\", \"oranges\", \"mangoes\"], 10) -> {\"mangoes\": 8}\n\n    If the total distributed quantity of a fruit exceeds the maximum quantity, raise a ValueError.\n    \"\"\"\n    result = {}\n    total_specified = 0\n\n    for fruit in s:\n        quantity = int(fruit.split(\" \")[0])\n        total_specified += quantity\n\n    remaining_fruits = n - total_specified\n    for fruit in fruits:\n        if fruit not in s:\n            if remaining_fruits > max_quantity:\n                raise ValueError(\"Total quantity exceeds maximum allowed quantity for fruit type.\")\n            else:\n                result[fruit] = remaining_fruits\n\n    return result"
      ],
      [
        0.8957886695861816,
        "def fruit_distribution(s, n, fruits, fruit_prices):\n    \"\"\"\n    \"\"\"\n    distribution = {}\n    for fruit in fruits:\n        distribution[fruit] = 0\n    for record in s:\n        record = record.split(' ')\n        quantity = int(record[0])\n        fruit = record[1]\n        distribution[fruit] += quantity\n        n -= quantity * fruit_prices[fruit]\n    for fruit in fruits:\n        if distribution[fruit] == 0:\n            distribution[fruit] = n // fruit_prices[fruit]\n            n -= distribution[fruit] * fruit_prices[fruit]\n    return {k: v for k, v in distribution.items() if v > 0}"
      ],
      [
        0.8923675417900085,
        "def advanced_fruit_distribution(s, n, fruits, non_fruit_items, multiplier):\n    \"\"\"\n    \"\"\"\n    \n    # validate the multiplier\n    if multiplier < 0 or multiplier > 100:\n        raise ValueError(\"Multiplier is not valid. It should range from 0 to 100\")\n    \n    # re-mapping the fruit and non-fruit items  \n    fruit_dict = {item.split(\" \")[1]: int(item.split(\" \")[0]) for item in fruits}\n    non_fruit_dict = {item.split(\" \")[1]: int(item.split(\" \")[0]) for item in non_fruit_items}\n    \n    # if total items less than basket content\n    if n < sum(fruit_dict.values()) + sum(non_fruit_dict.values()):\n        return 'Error'\n    \n    # if day was odd, apply multiplier to fruit quantity\n    if s % 2 != 0:\n        fruit_dict = {k: v * multiplier for k, v in fruit_dict.items()}\n    \n    # remove items with zero volume\n    fruit_dict = {k: v for k, v in fruit_dict.items() if v > 0}\n    non_fruit_dict = {k: v for k, v in non_fruit_dict.items() if v > 0}\n    \n    return fruit_dict, non_fruit_dict"
      ],
      [
        0.8920550346374512,
        "def count_fruits(apples, oranges):\n    \"\"\"\n    This function takes two parameters, apples and oranges, which represent the number of apples and oranges in a basket.\n    It returns the total number of fruits in the basket.\n    \n    Parameters:\n    - apples (int): The number of apples in the basket.\n    - oranges (int): The number of oranges in the basket.\n    \n    Returns:\n    - int: The total number of fruits in the basket.\n    \"\"\"\n    if apples < 0 or oranges < 0:\n        return \"Error: The counts cannot be negative.\"\n    else:\n        return apples + oranges"
      ],
      [
        0.8919985294342041,
        "def fruit_distribution(s, n, fruits, fruit_prices):\n    \"\"\"\n    \"\"\"\n    basic_count = {fruit: 0 for fruit in fruits}\n    for fruit_storage_info in s:\n        split_str = fruit_storage_info.split(' ')\n        quantity = int(split_str[0])\n        fruit_name = split_str[1]\n        if fruit_name in basic_count:\n            basic_count[fruit_name] = quantity\n\n    remaining_cost = n\n    for fruit, count in basic_count.items():\n        remaining_cost -= count * fruit_prices[fruit]\n\n    remaining_fruits = {fruit: remaining_cost // fruit_prices[fruit] for fruit in fruits if fruit not in basic_count or basic_count[fruit] == 0}\n    remaining_fruits = {k: v for k, v in remaining_fruits.items() if v > 0}\n\n    return remaining_fruits"
      ],
      [
        0.8886493444442749,
        "def fruit_distribution(s, n, fruits, servings):\n    \"\"\"\n    Distribute fruits to the students.\n    \n    Args:\n        s (str): The string representing the fruits and their counts.\n        n (int): The number of students.\n        fruits (list): The list of fruits to distribute.\n        servings (dict): The dictionary mapping fruits to the number of servings.\n        \n    Returns:\n        dict: The dictionary mapping fruits to the number of servings.\n        \n    Raises:\n        ValueError: If there are not enough fruits for the servings or if the remaining fruits cannot be equally distributed.\n    \"\"\"\n    fruit_dict = {}\n    for fruit in s:\n        fruit_name, count = fruit.split()\n        fruit_dict[fruit_name] = int(count)\n        \n    for fruit in fruits:\n        if fruit in servings:\n            n -= servings[fruit]\n            if n < 0:\n                raise ValueError('Not enough fruits for the servings.')\n                \n    if n % len(fruits) != 0:\n        raise ValueError('Cannot equally distribute remaining fruits.')\n        \n    remaining_per_fruit = n // len(fruits)\n    \n    result = {}\n    for fruit in fruits:\n        if fruit not in fruit_dict:\n            result[fruit] = remaining_per_fruit\n        \n    return result"
      ]
    ],
    "HumanEval/68": [
      [
        0.9364767670631409,
        "def solve(nodes):\n    \"\"\"\n    \"\"\"\n    result=[]\n    even_nodes=[]\n    for idx, node in enumerate(nodes):\n        if node % 2 == 0 and node != 0:\n            even_nodes.append((node, idx))        \n    if even_nodes:\n        even_nodes.sort()\n        min_val = even_nodes[0][0]\n        for node, idx in even_nodes:\n            if node == min_val:\n                result = [node, idx]\n    return result"
      ],
      [
        0.9130788445472717,
        "def solve(nodes):\n    \"\"\"\n    \"\"\"\n    min_even_node, min_even_val = None, float('inf')\n    for node in nodes:\n        if node.value < min_even_val and node.value % 2 == 0:\n            min_even_node, min_even_val = node, node.value\n        elif node.value == min_even_val:\n            min_even_node = node\n    if min_even_node is None:\n        return []\n    else:\n        return [min_even_node]"
      ],
      [
        0.9106522798538208,
        "def optimalPluck(arr, cond_fn):\n    \"\"\"\n    \"\"\"\n    min_info = [float('inf'), float('inf'), float('inf')]\n    \n    for i, node in enumerate(arr):\n        if cond_fn(node):\n            d = floor(log2(i+2)) \n            if node < min_info[0] or (node==min_info[0] and d<min_info[2]) or (node==min_info[0] and d==min_info[2] and i<min_info[1]):\n                min_info = [node, i, d]\n\n    return min_info if min_info[0] != float('inf') else []"
      ],
      [
        0.9070000052452087,
        "def smallest_even(arr):\n    \"\"\"\n    Return the smallest even number in the given list.\n    If there is no even number, return None\n    \"\"\"\n    smallest = None\n    for num in arr:\n        if num % 2 == 0:\n            if smallest is None or num < smallest:\n                smallest = num\n    return smallest\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\"\"\"\n    smallest = float('inf') \n\n    for num in arr:\n        if num % 2 == 0 and num < smallest:\n            smallest = num\n    \n    return smallest "
      ]
    ],
    "HumanEval/69": [
      [
        0.9203601479530334,
        "def search(lst):\n    \"\"\"\n    Given a list of numbers, return the greatest number whose square is less than or equal to the sum of the list.\n    \n    >>> search([1, 2, 3, 4])\n    2\n    >>> search([1, 2, 3, 4, 5])\n    3\n    >>> search([1, 2, 3, 4, 5, 6])\n    4\n    \"\"\"\n    freq = {}\n    for num in lst:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    greatest = -1\n    for num, count in freq.items():\n        if count >= num*num:\n            greatest = max(greatest, num)\n    return greatest"
      ],
      [
        0.9121513366699219,
        "def find(lst):\n    \"\"\"\n    Find the smallest integer in a list that is not a duplicate.\n    If there is no such integer, return -1.\n    :param lst: a list of integers\n    :return: an integer\n    \"\"\"\n    freq = {}\n    for i in lst:\n        freq[i] = freq.get(i, 0) + 1\n\n    filtered = [key for key, value in freq.items() if value <= key / 2]\n\n    if not filtered:\n        return -1\n\n    return min(filtered)"
      ],
      [
        0.9092419147491455,
        "def specialArray(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    max_val = max(nums)\n    for x in range(1, max_val + 1):\n        count = sum([1 for num in nums if num >= x])\n        if count == x:\n            return x\n    return -1"
      ],
      [
        0.9092186689376831,
        "def specialArray(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    max_val = max(nums)\n    for x in range(1, max_val + 1):\n        count = sum([1 for num in nums if num >= x])\n        if count == x:\n            return x\n    return -1"
      ],
      [
        0.9086374640464783,
        "def maxEqualFreq(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    count = Counter()\n    freq = defaultdict(int)\n    max_count = res = 0\n    \n    for i, x in enumerate(nums, 1):\n        freq[count[x]] -= 1\n        count[x] += 1\n        freq[count[x]] += 1\n        max_count = max(max_count, count[x])\n        \n        if max_count * freq[max_count] == i - 1 and i < len(nums):\n            res = i\n        if max_count * (freq[max_count] - 1) + max_count - 1 == i:\n            res = i\n            \n    return [res, nums[res-1]] if res > 0 else [0, -1]"
      ],
      [
        0.9080004692077637,
        "def rare_value(lst):\n    \"\"\"\n    Given a list of numbers, return the smallest number whose frequency is less than or equal to half of its value.\n    If there is no such number, return -1.\n    :param lst: list of numbers\n    :return: smallest number whose frequency is less than or equal to half of its value\n    \"\"\"\n    # Counting the frequency of each number in the list\n    freq_counter = {}\n    for n in lst:\n        if n in freq_counter:\n            freq_counter[n] += 1\n        else:\n            freq_counter[n] = 1\n\n    # Constructing a list of numbers where their frequency is less than or equal to half of their value\n    rare_values = [n for n in freq_counter if freq_counter[n] <= n//2]\n\n    # If there are no such numbers, returning -1\n    if not rare_values:\n        return -1\n\n    # Otherwise, returning the smallest number\n    return min(rare_values)"
      ]
    ],
    "HumanEval/70": [
      [
        0.9373254179954529,
        "def strange_sort_list_bst(lst):\n    '''\n    This function should accept a list of integers and decimal numbers and return the list in a specific pattern, leveraging the principles of a binary search tree. The steps for this peculiar sorting pattern should be:\n    - Commence with the smallest number.\n    - Next, identify the highest value from the remaining elements.\n    - Then, ascertain the lowest value among the untouched output, and continue in this manner.\n    \n    Examples:\n    strange_sort_list_bst([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list_bst([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list_bst([]) == []\n    strange_sort_list_bst([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n    \n    # First, we will sort the list in ascending order.\n    lst.sort()\n\n    output = []\n\n    # Then, while lst is not empty, we will remove and append to output the smallest\n    # and largest element alternatively.\n    while lst:\n        output.append(lst.pop(0))  # smallest\n        if lst:\n            output.append(lst.pop(-1))  # largest\n\n    return output"
      ],
      [
        0.9322264194488525,
        "def strange_sort_list_bst(lst):\n    \"\"\"\n    Sort a list ascendingly by value, then alternately append the smallest and largest values to a new list.\n    \n    Args:\n        lst: a list of numbers\n    \n    Returns:\n        A new list of numbers sorted as described above.\n    \"\"\"\n    # Sort the list ascendingly by value\n    lst.sort()\n\n    # Initialize an empty list \n    new_lst = []\n    while lst:\n        # Alternately remove and append the smallest and largest values to the new list\n        new_lst.append(lst.pop(0))\n        if lst:\n            new_lst.append(lst.pop(-1))\n\n    return new_lst"
      ],
      [
        0.9295914173126221,
        "def strangeSorting(lst):\n    \"\"\"\n    \"\"\"\n    new_lst = []\n    for i in range(len(lst)):\n        try:\n            lst[i] = float(lst[i])\n        except ValueError:\n            continue\n    while lst:\n        min_num = min(lst)\n        while min_num in lst:\n            new_lst.append(min_num)\n            lst.remove(min_num)\n        if not lst: break\n        max_num = max(lst)\n        while max_num in lst:\n            new_lst.append(max_num)\n            lst.remove(max_num)\n    return new_lst"
      ],
      [
        0.9293622970581055,
        "def peculiar_ordering(lst):\n    \"\"\"\n    Given a list of numbers, return a list where the first element is the smallest value, the second is the largest, the third is the second smallest, the fourth is the second largest, and so on.\n    \n    Examples\n    peculiar_ordering([1, 2, 3, 4, 5]) \u279e [1, 5, 2, 4, 3]\n    \n    peculiar_ordering([1, 2, 3]) \u279e [1, 3, 2]\n    \n    peculiar_ordering([1\"\"\"\n    # Removing None values\n    lst = [i for i in lst if i is not None]\n    \n    if len(lst) == 0:\n        return []\n\n    out_lst = []\n    while len(lst) > 0:\n        # Adding the smallest element\n        min_value = min(lst)\n        out_lst.append(min_value)\n        lst.remove(min_value)\n\n        # Adding the largest element (if exists)\n        if len(lst) > 0:\n            max_value = max(lst)\n            out_lst.append(max_value)\n            lst.remove(max_value)\n            \n    return out_lst"
      ],
      [
        0.9271347522735596,
        "def strange_sort_list(lst, x):\n    \"\"\"\n    \"\"\"\n    # Filter out numbers less than x and sort in descending order.\n    new_lst = sorted([i for i in lst if i >= x], reverse=True)\n\n    result = []\n\n    # Loop until new_lst is empty. Find min and max then append to result accordingly.\n    while new_lst:\n        # Find min of the new_lst and append to the result if not already in it\n        minimum = min(new_lst)\n        if minimum not in result:\n            result.append(minimum)\n            new_lst.remove(minimum)\n\n        # If new_lst is empty, break from the loop\n        if not new_lst:\n            break\n\n        # Find max of the new_lst and append to the result if not already in it\n        maximum = max(new_lst)\n        if maximum not in result:\n            result.append(maximum)\n            new_lst.remove(maximum)\n            \n    return result"
      ],
      [
        0.9263348579406738,
        "def strangeSorting(lst):\n    \"\"\"\n    \"\"\"\n    res = []\n    lst_float = []\n    for item in lst:\n        try:\n            lst_float.append(float(item))\n        except ValueError:\n            pass\n    if lst_float == []:\n        return res\n    lst_float.sort()\n    while len(lst_float) > 0:\n        min_num = min(lst_float)\n        while min_num in lst_float:\n            res.append(min_num)\n            lst_float.remove(min_num)\n        if len(lst_float) > 0:\n            max_num = max(lst_float)\n            while max_num in lst_float:\n                lst_float.remove(max_num)\n            res.append(max_num)  \n    return res"
      ],
      [
        0.9231390953063965,
        "def peculiar_ordering(lst):\n    \"\"\"\n    Given a list of numbers, return a list where the first element is the smallest, \n    the second element is the largest, the third element is the second smallest, \n    the fourth element is the second largest, and so on. \n    If there are an odd number of elements, the middle element should be the largest.\n    \n    >>> peculiar_ordering([1, 2, 3, 4, 5])\n    [5, 1, 4, 2, 3]\n    >>> peculiar_ordering([1, 2, 3, \"\"\"\n    # Filter out None values\n    lst = [val for val in lst if val is not None]\n    # Sort the list in descending order\n    lst.sort(reverse=True)\n\n    result = []\n    while lst:\n        # Take the smallest element (which is at the end of the list)\n        result.append(lst.pop())\n        if lst:\n            # Take the largest element (which is at the beginning of the list)\n            result.append(lst.pop(0))\n    \n    return result"
      ],
      [
        0.9190672636032104,
        "def strange_sort_list_bst(lst):\n    \"\"\"\n    Sort a list of numbers using a BST.\n    \n    Args:\n        lst: a list of numbers\n    \n    Returns:\n        A sorted list of numbers.\n    \"\"\"\n    # Initialise min heap, max heap and output_list\n    min_heap, max_heap, output = [], [], []\n\n    # Populate min heap and max heap\n    for num in lst:\n        heapq.heappush(min_heap, num)\n        heapq.heappush(max_heap, -num)\n\n    # Grab smallest and largest alternatively from heaps until they're empty\n    is_turn_max = False\n    while min_heap and max_heap:\n        if not is_turn_max:\n            temp = heapq.heappop(min_heap)\n            while max_heap and -max_heap[0] < temp:\n                heapq.heappop(max_heap)\n            if max_heap and -max_heap[0] == temp:\n                heapq.heappop(max_heap)\n            output.append(temp)\n            is_turn_max = True\n        else:\n            temp = -heapq.heappop(max_heap)\n            while min_heap and min_heap[0] < temp:\n                heapq.heappop(min_heap)\n            if min_heap and min_heap[0] == temp:\n                heapq.heappop(min_heap)\n            output.append(temp)\n            is_turn_max = False\n\n    return output"
      ],
      [
        0.9186035394668579,
        "def peculiar_ordering(lst):\n    \"\"\"\n    Given a list of numbers, return a list where the first element is the smallest,\n    the second element is the largest, the third element is the second smallest,\n    the fourth element is the second largest, and so on.\n    \n    >>> peculiar_ordering([1, 2, 3, 4, 5])\n    [1, 5, 2, 4, 3]\n    >>> peculiar_ordering([1, 1, 2, 2])\n    [1, 2, 1, 2]\n    >>> peculiar_ordering\"\"\"\n    lst = [val for val in lst if val is not None] # Remove None values\n    sorted_list = sorted(lst, reverse=True) # Sort list in reverse order\n\n    result = []\n    while sorted_list:\n        if sorted_list:\n            result.append(sorted_list.pop())  # pick up smallest\n        if sorted_list:\n            result.append(sorted_list.pop(-1))  # pick up largest\n\n    return result"
      ],
      [
        0.9175035953521729,
        "def strange_sort_list_heap(lst):\n    \"\"\"\n    Sort the given list using a heap.\n    \n    Args:\n       lst(list): List of numbers\n    Returns:\n       list: Sorted list\n    \"\"\"\n    # Base case for an empty list\n    if not lst:\n        return []\n    \n    # Transform list into a heap, in-place, in O(len(lst)) time\n    heapq.heapify(lst)\n    \n    # List to hold the final result\n    result = []\n    \n    # Flag to check whether to pop smallest or largest number\n    pop_smallest = True\n    \n    while lst:\n        if pop_smallest:  # Pop the smallest number\n            result.append(heapq.heappop(lst))  # heapq.heappop() pops and return smallest element from heap\n        else:  # Pop the largest number\n            lst = [-i for i in lst]  # Invert the order of heap\n            heapq.heapify(lst)  # Heapify again as order has changed\n            result.append(-heapq.heappop(lst))  # heapq.heappop() pops and return smallest(negative of largest) element from heap\n            lst = [-i for i in lst]  # Invert the order back\n            heapq.heapify(lst)  # Heapify again as order has changed\n        # Invert the flag to pop the other number in next iteration\n        pop_smallest = not pop_smallest\n        \n    return result"
      ]
    ],
    "HumanEval/71": [
      [
        0.936038076877594,
        "def triangle_area(a, b, c):\n    \"\"\"\n    Calculate the area of a triangle given the length of its sides.\n    :param a: side a\n    :param b: side b\n    :param c: side c\n    :return: area of the triangle\n    \"\"\"\n    # validate the sides of a triangle\n    if (a + b > c) and (a + c > b) and (b + c > a):\n        # semiperimeter\n        p = (a + b + c) / 2.0\n        # calculate the area\n        area = (p * (p - a) * (p - b) * (p - c))**0.5\n        return round(area, 2)\n    else:\n        return -1"
      ],
      [
        0.9330061674118042,
        "def triangle_area(a, b, c):\n    \"\"\"Compute and return the area and the altitude of a triangle from its three side lengths\"\"\"\n    \n    # check if the sides can form a valid triangle\n    if a + b <= c or b + c <= a or a + c <= b:\n        return -1\n    \n    # check if the triangle is equilateral\n    if a == b == c:\n        return -1\n\n    # calculate semi-perimeter\n    s = (a + b + c) / 2\n\n    # calculate area using Heron's formula\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    area = round(area, 2)\n\n    # calculate altitude\n    # altitude = 2 * area / base\n    # assume c is the base for computing the altitude.\n    # for isosceles triangle, any side can be considered as base.\n    # for scalene triangle, the altitude varies with the chosen base.\n    altitude = 2 * area / c\n    altitude = round(altitude, 2)\n\n    return (area, altitude)"
      ]
    ],
    "HumanEval/72": [
      [
        0.9543389081954956,
        "def will_it_fly(q,w):\n    '''\n    The function's purpose is to discern q's flight potential, return True if achievable, and False if not. For q to fly, it must fulfil two prerequisites: it must be palindromic and the total weights of its elements should not go beyond the maximum acceptable weight w.\n\n    Implement the function with error handling mechanisms. It should return a \"Non-numeric input\" error if it receives a non-numeric input, and a \"Non-sequence input\" error if it receives a non-sequence input.\n\n    Examples:\n    will_it_fly([1, 2], 5) \u279e False \n\n    will_it_fly([3, 2, 3], 1) \u279e False\n\n    will_it_fly([3, 2, 3], 9) \u279e True\n\n    will_it_fly([3], 5) \u279e True\n    \n    Error Cases:\n    will_it_fly([\"a\",\"b\",\"c\"], 5) \u279e \"Non-numeric input\"\n    \n    will_it_fly(123, 5) \u279e \"Non-sequence input\"\n    '''\n    # Handle Non-sequence input error\n    if not isinstance(q, (list, tuple, str)):\n        return \"Non-sequence input\"\n    \n    for i in q:\n        # Handle Non-numeric input error\n        if not isinstance(i, (int, float)):\n            return \"Non-numeric input\"\n    \n    return is_palindrome(q) and sum(q) <= w"
      ],
      [
        0.9447683095932007,
        "def will_it_fly(q, w):\n    \"\"\"\n    \"\"\"\n    # Check if list is palindrome\n    if q == q[::-1]:\n        # Check if sum is less than or equal to w\n        if sum(q) <= w:\n            return True\n    return False"
      ],
      [
        0.9406753182411194,
        "def will_it_fly(q, w):\n    \"\"\"\n    \"\"\"\n    # Check if list q is palindrome by comparing it to its reverse.\n    if q == q[::-1]:\n        # If it is, check if sum of elements of q is less than or equal to w\n        if sum(q) <= w:\n            return True\n        else:\n            return False\n    else:\n        return False"
      ],
      [
        0.9382733106613159,
        "def will_it_fly(q,w):\n    \"\"\"\n    \"\"\"\n    if all(isinstance(i, int) for i in q):\n        if q == q[::-1] and sum(i for i in q) <= w:\n            return True\n    return False"
      ],
      [
        0.937174916267395,
        "def will_it_fly(q, w):\n    \"\"\"\n    Check if a list of numbers is palindromic and its sum is less than or equal to a given weight.\n    \n    Args:\n        q (list): List of numbers.\n        w (int): Maximum weight.\n    \n    Returns:\n        bool: True if the list is palindromic and its sum is less than or equal to w, False otherwise.\n    \"\"\"\n    q_len = len(q)\n    \n    # Check if the list is palindromic\n    for i in range(q_len // 2):\n        if q[i] != q[q_len - 1 - i]:\n            return False\n    \n    # Check if the sum of its elements is less than or equal to w\n    if sum(q) > w:\n        return False\n    \n    return True"
      ],
      [
        0.9316713809967041,
        "def if_can_fly(q, w, e): \n    \"\"\"\n    Check if the list is a palindrome and the total weight does not exceed the limit\n    :param q: list of weights\n    :param w: weight limit\n    :param e: list of weights\n    :return: True if the list is a palindrome and the total weight does not exceed the limit, False otherwise\n    \"\"\"\n    # Check if the list is a palindrome\n    if q != q[::-1]:\n        return False\n    # Check if the total weight exceeds the limit\n    if sum(q) > w:\n        return False\n    # If both conditions are passed, return true\n    return True"
      ],
      [
        0.9316577911376953,
        "def will_it_fly(q, w):\n    \"\"\"\n    <|file_separator|>\n    def will_it_fly(q, w):\n    \"\"\"\n    \"\"\"\n    if q == q[::-1] and sum(q) <= w:\n        return True\n    else:\n        return False\n    \n    def will_it_fly(q, w):\n    \"\"\"\n    \"\"\"\n    if q == q[::-1] and sum(q) <= w:\n        return True\n    else:\n        return False\n    \n    def will_it_fly(q, w):\n    \"\"\"\n    \"\"\"\n    if q == q\"\"\"\n    if q == q[::-1] and sum(q) <= w:\n        return True\n    else:\n        return False"
      ],
      [
        0.9252378344535828,
        "def will_it_fly(q, w):\n    \"\"\"\n    \"\"\"\n    # Check if the mass of q is within limit and also if q is a palindrome\n    return sum(q) <= w and q == q[::-1]"
      ],
      [
        0.920432448387146,
        "def future_flight(q, w):\n    \"\"\"\n    \"\"\"\n    # Checking for sequence type\n    if not isinstance(q, (list, tuple)):\n        return \"Non-sequence input\"\n\n    # Checking for numeric type input in sequence\n    if not all(isinstance(item, (int, float)) for item in q):\n        return \"Non-numeric input\"\n\n    # Checking if list is sorted in ascending or descending order\n    if q != sorted(q) and q != sorted(q, reverse=True):\n        return \"Unsorted list error\"\n\n    # Checking if flight capacity meets requirements\n    if q == q[::-1] and sum(q) <= w:\n        return True\n    else:\n        return False"
      ],
      [
        0.9200212359428406,
        "def will_it_fly(q, w, n):\n    \"\"\"\n    Check if a list of numbers q is palindromic, has a sum less than or equal to w, and has exactly n unique elements.\n\n    Args:\n        q (list): List of numbers.\n        w (int): Maximum sum of elements in q.\n        n (int): Number of unique elements in q.\n\n    Returns:\n        bool: True if q is palindromic, has a sum less than or equal to w, and has exactly n unique elements. False otherwise.\n    \"\"\"\n    # Check if q is palindromic\n    if q != q[::-1]:\n        return False\n\n    # Check if the sum of elements in q is less than or equal to w\n    if sum(q) > w:\n        return False\n\n    # Count the unique elements in q\n    unique_elements = len(set(q))\n\n    # Check if q has exactly n unique elements\n    if unique_elements != n:\n        return False\n\n    return True"
      ]
    ],
    "HumanEval/73": [
      [
        0.9412541389465332,
        "def smallest_change(arr, limit):\n    \"\"\"\n    Given an array of integers and a limit value, find the minimum number of mismatches\n    in the array to make it a palindrome.\n    \n    Args:\n        arr (list): An array of integers.\n        limit (int): The maximum number of mismatches allowed.\n    \n    Returns:\n        int: The minimum number of mismatches required to make the array a palindrome.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    mismatches = 0\n\n    while left < right:\n        if arr[left] != arr[right]:\n            mismatches += 1\n            if mismatches > limit:\n                return mismatches\n\n        left += 1\n        right -= 1\n    \n    return mismatches"
      ],
      [
        0.9388190507888794,
        "def minimum_changes_to_palindrome(arr, limit):\n    \"\"\"\n    Given an array of integers arr and an integer limit, return the minimum number of elements to change to make arr a palindrome.\n\n    An array is a palindrome if it reads the same backward as forward.\n\n    An array a is a modification of an array b if a can be obtained from b changing at most limit elements to any value.\n    \"\"\"\n    i, j = 0, len(arr) - 1 #start and end pointers\n    changes = 0\n    unique_elements = set() \n\n    while i <= j: \n        if arr[i] != arr[j]: \n            changes += 1\n            if arr[i] not in unique_elements: #check for unique modifications constraint\n                limit -= 1\n                if limit < 0: \n                    return changes\n                unique_elements.add(arr[i])\n            arr[\n              j] = arr[i] #make both ends same by replacing the larger one with the smaller one\n        i += 1\n        j -= 1\n\n    return changes"
      ],
      [
        0.9383949637413025,
        "def smallest_change(arr, limit):\n    \"\"\"\n    Given an array of integers and a limit, find the minimum number of elements to remove to make the array symmetrical.\n    \n    An array is symmetrical if it is the same as its reverse.\n    \n    Example\n    For arr = [1, 2, 3, 2, 1] and limit = 2, the output should be\n    smallestChange(arr, limit) = 0;\n    For arr = [1, 2, 3, 4, 5] and limit = 1, the output should be\n    smallestChange(arr, limit\"\"\"\n    n = len(arr)\n    count = 0\n    \n    for i in range(n // 2):\n        if arr[i] != arr[n - i - 1]:\n            count += 1\n            if count > limit:\n                return count\n    \n    return count"
      ],
      [
        0.9332283735275269,
        "def smallest_change(arr, limit):\n    \"\"\"\n    Given an array of integers and a limit, return the minimum number of changes\n    required to make all elements equal.\n    \n    >>> smallest_change([1, 2, 3], 1)\n    2\n    >>> smallest_change([1, 2, 3], 2)\n    1\n    >>> smallest_change([1, 2, 3], 3)\n    0\n    \"\"\"\n    left = 0 \n    right = len(arr) - 1\n    changes = 0\n    while left <= right:\n        if arr[left] != arr[right]:\n            limit -= 1\n            if arr[left] < arr[right]:\n                arr[left] = arr[right]\n            else:\n                arr[right] = arr[left]\n                \n            if limit < 0:\n                changes += 1\n        left += 1\n        right -= 1\n    return changes"
      ],
      [
        0.9309017062187195,
        "def smallest_change(arr, limit):\n    \"\"\"\n    \"\"\"\n    n = len(arr)\n    changes = 0\n    for i in range(n // 2):\n        if arr[i] != arr[n - 1 - i]:\n            changes += 1\n        if changes > limit:\n            break\n    return min(changes, limit)"
      ],
      [
        0.9306086897850037,
        "def smallest_change(arr, limit):\n    \"\"\"\n    Given an array of integers and a limit, find the smallest number of changes\n    needed to make all elements equal.\n    \n    Args:\n        arr (list): an array of integers\n        limit (int): the limit of changes allowed\n    \n    Returns:\n        int: the smallest number of changes needed\n    \"\"\"\n    arr_rev = arr[::-1] # create a reversed copy of the array\n    diffs = sum(x != y for (x, y) in zip(arr, arr_rev)) // 2 # count the number of differences\n    \n    # handle the limit\n    if diffs <= limit:\n        return diffs\n    else:\n        return limit + (diffs - limit) * 2"
      ],
      [
        0.9294269680976868,
        "def smallest_change(arr, limit):\n    \"\"\"\n    Given an array of integers and a limit, return the minimum number of changes\n    required to make all elements equal, or -1 if it is not possible to make all\n    elements equal given the limit.\n    \n    An element can be changed by 1 at a time.\n    \n    For example, given arr = [1, 2, 3, 4], and a limit of 1, the minimum number\n    of changes required to make all elements equal is 6:\n    \n    arr = [1, 2, 3, 4]\n    arr\"\"\"\n    left, right = 0, len(arr) - 1\n    counts = defaultdict(int)\n    unique_changes = 0\n    total_changes = 0\n    \n    while left <= right:\n        if arr[left] == arr[right]:\n            left += 1\n            right -= 1\n        elif arr[left] > arr[right]:\n            if counts[arr[left]] < limit:\n                total_changes += 1\n                counts[arr[left]] += 1\n                arr[right] = arr[left]\n                left += 1\n                right -= 1\n            else:\n                return -1\n        else:\n            if counts[arr[right]] < limit:\n                total_changes += 1\n                counts[arr[right]] += 1\n                arr[left] = arr[right]\n                left += 1\n                right -= 1\n            else:\n                return -1\n    return total_changes"
      ],
      [
        0.9231908321380615,
        "def smallest_change(arr, limit):\n    \"\"\"\n    Given an array of integers and a limit value, return the minimum number of elements to change to have no consecutive duplicates.\n    If it is not possible to remove less than k elements to avoid consecutive duplicates, return -1.\n    \n    Example 1:\n    Input: arr = [1,2,3,4,5], limit = 0\n    Output: 0\n    Explanation: No elements need to be changed.\n    \n    Example 2:\n    Input: arr = [1,2,3,3,5], limit = 1\n    Output: \"\"\"\n    i, j = 0, len(arr)-1\n    count = 0\n    while i < j:\n        if arr[i] != arr[j]:\n            count += 1\n\n            if count > limit:\n                return -1\n\n            arr[j] = arr[i]\n        i += 1\n        j -= 1\n    return count"
      ],
      [
        0.9219220876693726,
        "def smallest_variation_in_subgroup(arr, limit, subset):\n    \"\"\"\n    \"\"\"\n    # mapping array elements to counter of their occurrence\n    counts = dict()\n    for a in arr:\n        if a in subset:\n            counts[a] = counts.get(a, 0) + 1\n\n    # members in subset with occurrence less than half of the array's length\n    to_subtract = [k for k, v in counts.items() if k in subset and v < len(arr) // 2]\n\n    # sorting them by occurrence in ascending order\n    to_subtract.sort(key=counts.get)\n\n    # subtracting them until limit or subset is depleted\n    idx = 0\n    while idx < len(to_subtract) and limit > 0:\n        limit -= 1\n        arr[arr.index(to_subtract[idx])] = to_subtract[-1]\n        counts[to_subtract[idx]] -= 1\n        counts[to_subtract[-1]] += 1\n        if counts[to_subtract[idx]] < len(arr) // 2:\n            idx += 1\n\n    # cannot make array palindromic if subset is depleted before limit\n    if idx < len(to_subtract):\n        return -1\n\n    # count compared to the most occurrence number in subset\n    max_subset_elm = max(counts.keys(), key=lambda x: counts[x] if x in subset else -1)\n    return sum([v for k, v in counts.items() if k != max_subset_elm])"
      ],
      [
        0.9217832088470459,
        "def smallest_variation_in_subgroup(arr, limit, subset):\n    \"\"\"\n    \"\"\"\n    # mapping array elements to counter of their occurrence\n    counts = dict()\n    for a in arr:\n        # if a in subset:\n        counts[a] = counts.get(a, 0) + 1\n\n    # numbers in subset with occurrence less than half of the array's length\n    to_subtract = [k for k, v in counts.items() if k in subset and v < len(arr) // 2]\n\n    # sorting them by occurrence ascending order\n    to_subtract.sort(key=counts.get)\n\n    # subtracting them until limit or subset is depleted\n    idx = 0\n    while idx < len(to_subtract) and limit > 0:\n        limit -= 1\n        arr[arr.index(to_subtract[idx])] = to_subtract[-1]\n        counts[to_subtract[idx]] -= 1\n        counts[to_subtract[-1]] += 1\n        if counts[to_subtract[idx]] < len(arr) // 2:\n            idx += 1\n\n    # cannot make array palindromic if subset is depleted before limit\n    if idx < len(to_subtract):\n        return -1\n\n    # count compared to the most occurrence number in subset\n    max_subset_elm = max(counts.keys(), key=lambda x: counts[x] if x in subset else -1)\n    return sum([v for k, v in counts.items() if k != max_subset_elm])"
      ]
    ],
    "HumanEval/74": [
      [
        0.9617927074432373,
        "def total_match(lst1, lst2, case_sensitive=False):\n    '''\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n    \n    The function also drop duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case_sensitive parameter to True.\n    \n    Should both iterables have an equal total character length, the function returns the first iterable.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    total_match(['hi world'], ['hi', ' w', 'or', 'ld']) \u279e ['hi', ' w', 'or', 'ld']\n    '''\n    import re\n\n    # Remove non-alphanumeric characters and possibly convert to lower case\n    lst1 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst1]\n    lst2 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst2]\n\n    # Eliminate duplicates, preserving the original order\n    lst1, lst2 = list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2))\n\n    # Determine which list has a less or equal total character count\n    return lst1 if sum(len(s) for s in lst1) <= sum(len(s) for s in lst2) else lst2"
      ],
      [
        0.9537039995193481,
        "def total_match(lst1, lst2, case_sensitive=False):\n    \"\"\"\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n\n    The function also drops duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case sensitive parameter to True.\n\n    Should both iterables have an equal total character length, the function returns the first iterable.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['HI', 'HI']) \u279e ['HI', 'HI']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'hi']) \u279e ['hi', 'hi']\n    total_match(['A'], ['1', '2', '3', '4', '5']) \u279e ['A']\n    total_match(['hi world'], ['hi', ' w', 'or', 'ld']) \u279e ['hi', ' w', 'or', 'ld']\n    \"\"\"\n\n    # Remove non-alphanumeric characters and possibly convert to lower case\n    lst1 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst1]\n    lst2 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst2]\n\n    # Eliminate duplicates, preserving the original order\n    lst1, lst2 = list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2))\n\n    # Determine which list has a less or equal total character count\n    return lst1 if sum(len(s) for s in lst1) <= sum(len(s) for s in lst2) else lst2"
      ],
      [
        0.9475939273834229,
        "def total_match(lst1, lst2):\n    \"\"\"\n    \"\"\"\n    # Removing repeating elements \n    lst1 = list(dict.fromkeys([i.lower() for i in lst1]))\n    lst2 = list(dict.fromkeys([i.lower() for i in lst2]))\n    \n    # Discounting spaces\n    lst1_no_space = [i.replace(\" \", \"\") for i in lst1]\n    lst2_no_space = [i.replace(\" \", \"\") for i in lst2]\n    \n    # Checking for more than half strings in numerical characters\n    if (sum(i.isnumeric() for i in lst1_no_space) > len(lst1_no_space)/2 or\n        sum(i.isnumeric() for i in lst2_no_space) > len(lst2_no_space)/2):\n        return []\n    \n    # Counting cumulative quantity of characters in all the strings\n    count1 = sum(len(i) for i in lst1_no_space)\n    count2 = sum(len(i) for i in lst2_no_space)\n    \n    if count1 <= count2:\n        return lst1\n    else:\n        return lst2"
      ],
      [
        0.940588653087616,
        "def total_match(lst1, lst2):\n    \"\"\"\n    \"\"\"\n    len1 = sum(len(word.replace(' ', '')) for word in lst1)\n    len2 = sum(len(word.replace(' ', '')) for word in lst2)\n    \n    if len1 <= len2:\n        lst = lst1\n        other_lst = lst2\n    else:\n        lst = lst2\n        other_lst = lst1\n\n    res = []\n    other_set = set(str.lower() for str in other_lst)\n\n    for string in lst:\n        if string.lower() not in other_set:\n            res.append(string)\n            other_set.add(string.lower())\n    return res"
      ],
      [
        0.939821183681488,
        "def enhanced_match(lst1, lst2):\n    \"\"\"\n    Given two lists of strings, return the list with the lesser total character count (excluding blank spaces).\n    \n    >>> enhanced_match(['a', 'b', 'c'], ['a', 'b', 'c'])\n    ['a', 'b', 'c']\n    >>> enhanced_match(['a', 'b', 'c'], ['a', 'b', 'c', 'd'])\n    ['a', 'b', 'c']\n    >>> enhanced_match(['a', 'b', 'c'], ['a', 'b', 'c', 'd', 'e'])\n\"\"\"\n    # Remove strings that contain numbers\n    lst1 = [string for string in lst1 if not any(char.isdigit() for char in string)]\n    lst2 = [string for string in lst2 if not any(char.isdigit() for char in string)]\n  \n    # Remove duplicates, ignoring case\n    seen1 = set()\n    seen2 = set()\n    lst1 = [x for x in lst1 if not (x.lower() in seen1 or seen1.add(x.lower()))]\n    lst2 = [x for x in lst2 if not (x.lower() in seen2 or seen2.add(x.lower()))]\n  \n    # Calculate total character count (excluding blank spaces)\n    len1 = sum(len(s.replace(' ', '')) for s in lst1)\n    len2 = sum(len(s.replace(' ', '')) for s in lst2)\n\n    # Return the list with the lesser total character count\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2"
      ],
      [
        0.9359985589981079,
        "def total_match(lst1, lst2):\n    \"\"\"\n    This function takes two lists as input and returns the list with lesser or equal count of characters.\n    It removes recurring strings from the lists and calculates the count of characters in the cleaned lists.\n    \n    Args:\n    - lst1 (list): The first list of strings.\n    - lst2 (list): The second list of strings.\n    \n    Returns:\n    - list: The list with lesser or equal count of characters.\n    \"\"\"\n    # Removing spaces and changing case to lower for string comparison\n    cleaned_lst1 = [str.replace(' ', '').lower() for str in lst1]\n    cleaned_lst2 = [str.replace(' ', '').lower() for str in lst2]\n\n    # Checking and removing recurring strings in the lists\n    seen = set()\n    unique_lst1 = [string for string in lst1 if string.lower() not in seen and not seen.add(string.lower())]\n    unique_lst2 = [string for string in lst2 if string.lower() not in seen and not seen.add(string.lower())]\n\n    # Calculating count of characters in cleaned lists\n    count_lst1 = sum([len(str) for str in cleaned_lst1])\n    count_lst2 = sum([len(str) for str in cleaned_lst2])\n\n    # Checking which list has lesser or equal count of characters\n    if count_lst1 <= count_lst2:\n        return unique_lst1\n    else:\n        return unique_lst2"
      ],
      [
        0.9296931028366089,
        "def total_match(lst1, lst2):\n    \"\"\"\n    This function takes two lists as input and returns the list with fewer characters.\n    If the list with fewer characters has more than 30% numeric characters, it returns an empty list.\n    \n    Parameters:\n    lst1 (list): The first list.\n    lst2 (list): The second list.\n    \n    Returns:\n    list: The list with fewer characters.\n    \"\"\"\n    # Removing duplicates from the lists\n    lst1 = sorted(set(lst1), key = lst1.index)\n    lst2 = sorted(set(lst2), key = lst2.index)\n    \n    # Initializing character and numeric counters\n    total_chars1, total_chars2, total_numeric = 0, 0, 0\n    \n    # Calculating characters count for lst1 and updating numeric count\n    for word in lst1:\n        total_chars1 += len(word.replace(\" \", \"\"))\n        total_numeric += sum(c.isdigit() for c in word)\n\n    # Calculating characters count for lst2 and updating numeric count\n    for word in lst2:\n        total_chars2 += len(word.replace(\" \", \"\"))\n        total_numeric += sum(c.isdigit() for c in word)\n\n    # Total characters in both lists\n    total_chars = total_chars1 + total_chars2\n    \n    # Checking if numeric characters are more than 30%\n    if total_numeric/total_chars > 0.3:\n        return []\n        \n    # Return the list with fewer characters \n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2"
      ]
    ],
    "HumanEval/75": [
      [
        0.9438865780830383,
        "def is_multiply_prime(a: int) -> bool:\n    \"\"\"\n    \"\"\"\n    prime_factors = []\n    for i in range(2, a + 1):\n        if a % i == 0 and is_prime(i):\n            prime_factors.append(i)\n    if len(prime_factors) == 3:\n        product = 1\n        for factor in prime_factors:\n            product *= factor\n        if product == a:\n            return True\n    return False"
      ],
      [
        0.9437503814697266,
        "def is_multiply_prime(a):\n    \"\"\"\n    \"\"\"\n    deviders = []\n    if a < 2:\n        return False\n    while a % 2 == 0:\n        deviders.append(2)\n        a = a / 2\n    f = 3\n    while f * f <= a:\n        if a % f == 0:\n            deviders.append(f)\n            a = a / f\n        else:\n            f += 2\n    if a != 1: \n        deviders.append(a)\n    if len(deviders) == 3 and all(map(lambda x: x == deviders[0] or x % deviders[0] != 0, deviders)):\n        return True    \n    else:\n        return False"
      ],
      [
        0.934600293636322,
        "def is_product_of_three_primes(n):\n    \"\"\"Modify this function to return True if the input number is a product of exactly three prime numbers, else False.\"\"\"\n    factors = []\n\n    for i in range(2, n + 1):\n        while (n % i==0):\n            factors.append(i)\n            n = n / i\n\n    # remove duplicate factors\n    unique_factors = list(set(factors))\n\n    # check if factors are prime numbers\n    for factor in unique_factors:\n        if not is_prime(factor):\n            return False\n\n    # check if there are exactly three factors\n    if len(unique_factors) == 3:\n        return True\n    else:\n        return False"
      ],
      [
        0.92183518409729,
        "def is_multiply_prime(a):\n    \"\"\"Return if the input number is the product of five distinct prime numbers.\"\"\"\n\n    # List of factors\n    factors = []\n\n    # Factorization\n    for i in sympy.primerange(2, 5001):\n        if a % i == 0:  # if i is a factor of a\n            while a % i == 0:  # while i is still a factor of a\n                a /= i  # divide a by i to \"remove\" this factor from a\n            factors.append(i)  # it's guaranteed that i is a prime number here\n            if len(factors) > 5:  # no need to try further, a has too many different prime factors\n                return False\n\n    return len(factors) == 5"
      ],
      [
        0.9150209426879883,
        "def all_primes(numbers):\n    \"\"\"\n    Returns True if all numbers in the list are prime.\n    \"\"\"\n    for num in numbers:\n        if not is_prime(num):\n            return False\n    return True\n    def all_primes(numbers):\n    \"\"\"\n    Returns True if all numbers in the list are prime.\n    \"\"\"\n    for num in numbers:\n        if not is_prime(num):\n            return False\n    return True"
      ],
      [
        0.9122956395149231,
        "def is_prime(num):\n    \"\"\"Modify this function to check if the input number is a prime number.\"\"\"\n    if num > 1:\n        # check for factors\n        for i in range(2, num):\n            if (num % i) == 0:\n                return False\n        else: \n            return True\n    else:\n        return False"
      ],
      [
        0.9122392535209656,
        "def is_prime(number):\n    '''This function should return true if the number is prime and false otherwise.'''\n    if number <= 1:\n        return False\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            return False\n    return True"
      ],
      [
        0.9118169546127319,
        "def is_prime(n):\n    \"\"\"\n    \"\"\"\n    if n in (2,3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    for current in range(3, int(n ** 0.5) + 1, 2):\n        if n % current == 0: \n            return False\n    return True"
      ]
    ],
    "HumanEval/76": [
      [
        0.9295938611030579,
        "def is_power(x, y):\n    \"\"\"\n    Given base and power, return True if base raised to the power is equal to y else False.\n    Note that integer division should be used.\n    \n    >>> is_power(2, 1024)\n    True\n    >>> is_power(2, 1025)\n    False\n    \"\"\"\n    # Check if x and y are positive integers\n    if x <= 0 or y <= 0 or not isinstance(x, int) or not isinstance(y, int):\n        return False\n    \n    # Check if y is a power of x\n    power = 0\n    while x ** power <= y:\n        if x ** power == y:\n            return True\n        power += 1\n    return False"
      ],
      [
        0.916802167892456,
        "def is_power_of_two(n):\n    \"\"\"\n    Given an integer, write a function to determine if it is a power of two.\n    \"\"\"\n    if n <= 0:\n        return False\n    while n > 1:\n        if n % 2 != 0:\n            return False\n        n = n / 2\n    return True"
      ],
      [
        0.9097391963005066,
        "def is_power(x, y):\n    \"\"\"\n    Given base and exponent, calculate if y is a power of x.\n    \n    Parameters\n    ----------\n    x : int\n        Base number\n    y : int\n        Exponent\n    \n    Returns\n    -------\n    bool\n        True if y is a power of x, False otherwise\n    \"\"\"\n    if x <= 0 or y <= 0:  # Check if x and y are positive integers\n        return False\n    \n    if x < 0:  # Check if x is negative\n        return False\n    \n    while y % x == 0:  # Check if y is a power of x\n        y = y // x\n        if y == 1:\n            return True\n    \n    return False"
      ],
      [
        0.9085066318511963,
        "def divisible(x, y):\n    \"\"\"\n    Write a function that returns True if x is divisible by y, and False otherwise.\n    \"\"\"\n    if x % y == 0:\n        return True\n    else:\n        return False"
      ]
    ],
    "HumanEval/77": [
      [
        0.9371068477630615,
        "def is_perfect_cube(n):\n    \"\"\"\n    Returns True if n is a perfect cube.\n    \n    >>> is_perfect_cube(8)\n    True\n    >>> is_perfect_cube(-1)\n    False\n    \"\"\"\n    i = 0 \n    while i*i*i < abs(n): \n        i = i + 1\n    if i*i*i == abs(n): \n        return True\n    else:\n        return False "
      ],
      [
        0.9335493445396423,
        "def is_perfect_cube(n):\n    \"\"\"\n    >>> is_perfect_cube(27)\n    True\n    >>> is_perfect_cube(125)\n    True\n    >>> is_perfect_cube(126)\n    False\n    \"\"\"\n    # Function to check if a number is a perfect cube or not.\n    temp = isqrt(n)\n    return temp**3 == n or (temp+1)**3 == n or (temp-1)**3 == n"
      ],
      [
        0.9313973784446716,
        "def is_perfect_cube(n):\n    \"\"\"\n    Returns True if n is a perfect cube.\n    \n    >>> is_perfect_cube(8)\n    True\n    >>> is_perfect_cube(125)\n    True\n    >>> is_perfect_cube(64)\n    False\n    \"\"\"\n    root = int(n ** (1/3))\n    return root * root * root == n"
      ],
      [
        0.9297224283218384,
        "def isPerfectCube(n):\n    \"\"\"\n    Returns True if n is a perfect cube.\n    \n    >>> isPerfectCube(8)\n    True\n    >>> isPerfectCube(125)\n    True\n    >>> isPerfectCube(64)\n    False\n    \"\"\"\n    cube_root = round(n ** (1/3))\n    return cube_root ** 3 == n"
      ],
      [
        0.9296886920928955,
        "def isPerfectCube(n):\n    \"\"\"\n    Returns True if n is a perfect cube.\n    \n    >>> isPerfectCube(8)\n    True\n    >>> isPerfectCube(125)\n    True\n    >>> isPerfectCube(64)\n    False\n    \"\"\"\n    cube_root = round(n ** (1/3))\n    return cube_root ** 3 == n"
      ]
    ],
    "HumanEval/78": [
      [
        0.9510727524757385,
        "def count_hex_primes(num):\n    \"\"\"\n    Return the number of hex numbers in num that are prime.\n    num is a string representing a number in hexadecimal (base 16).\n    A hex number is prime if it consists entirely of digits 2, 3, 5, 7, A, D.\n    A hex digit is one of 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    A hex number is represented in Python as an instance of the str class.\n\"\"\"\n    count = 0\n    for c in num:\n        if c in ['2', '3', '5', '7', 'B', 'D']:\n            count += 1\n    return count"
      ],
      [
        0.8993967771530151,
        "def count_upper_prime(s):\n    \"\"\" Count the number of uppercase vowels at prime-numbered positions \"\"\"\n    count = 0\n    for i in range(len(s)):\n        if is_prime(i + 1):  # +1 for 1-based indexing\n            if s[i] in 'AEIOU':  \n                count += 1\n    return count"
      ]
    ],
    "HumanEval/79": [
      [
        0.9156445264816284,
        "def decimalToBinary(n):\n    \"\"\"\n    Convert decimal to binary\"\"\"\n    binary = bin(n).replace(\"0b\",\"\")\n    while len(binary) < 8:\n        binary = '0'+binary\n    return \"db\"+binary+\"db\""
      ]
    ],
    "HumanEval/80": [
      [
        0.9542896151542664,
        "def is_happy(s):\n    \"\"\"\n    You are assigned a string s.\n    Ascertain whether the string is happy or not.\n    A string is described as happy if it is at least 3 characters long, each consolidative set of 3 characters are individual, every unique character appears no less than twice, and no character appears thrice in a direct sequence.\n    Additionally, the string is happy if all character sets of 3 or more contains at least 1 vowel and the string should not start or end with the same character.\n\n    For instance:\n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => False\n    is_happy(aabb) => False\n    is_happy(adbbd) => True\n    is_happy(xyzz) => False\n    is_happy(aoa) => True\n    \"\"\"\n    from collections import Counter\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    if len(s) < 3 or s[0] == s[-1]:\n        return False\n    counter = Counter(s)\n    for k, v in counter.items():\n        if v < 2 or v > 2:\n            return False\n    for i in range(len(s)-2):\n        if len(set(s[i:i+3])) != 3 or len(set(s[i:i+3]).intersection(vowels)) < 1:\n            return False\n    return True"
      ],
      [
        0.9518826603889465,
        "def is_happy(s):\n    \"\"\"You are given a string s.\n    Determine if the string is happy or not.\n    A string is happy if its length is at least 3, each set of 3 sequential characters are unique,\n    every distinct character occurs at least twice, no character appears three times in a row,\n    and there is no number in the string.\"\"\"\n\n    # If length of string is less than 3 or there's a digit in the string, it's not happy\n    if len(s) < 3 or any(char.isdigit() for char in s):\n        return False\n\n    # Create a dictionary to keep count of characters\n    count_dict = {}\n    for ch in s:\n        if ch in count_dict:\n            count_dict[ch] += 1\n        else:\n            count_dict[ch] = 1\n\n    # If any character occurs only once or more than twice in a row, string is not happy\n    for ch in count_dict:\n        if count_dict[ch] < 2 or s.count(ch*3) > 0:\n            return False\n\n    # If there's any three sequential characters are not unique, string is not happy\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] == s[i + 2]:\n            return False\n\n    # String is happy\n    return True"
      ],
      [
        0.9507793188095093,
        "def is_happy(s):\n    \"\"\"You are given a string s.\n    Determine if the string is happy or not.\n    A string is happy if its length is at least 3, each set of 3 sequential characters are unique,\n    every distinct character occurs at least twice, no character appears three times in a row,\n    and there is no number in the string.\"\"\"\n    \n    # If length of string is less than 3 or there's a digit in the string, it's not happy\n    if len(s) < 3 or any(char.isdigit() for char in s):\n        return False\n\n    # Create a dictionary to keep count of characters\n    count_dict = {}\n    for ch in s: \n        if ch in count_dict: \n            count_dict[ch] += 1\n        else: \n            count_dict[ch] = 1\n\n    # If any character occurs only once or more than twice in a row, string is not happy\n    for ch in count_dict: \n        if count_dict[ch] < 2 or s.count(ch*3) > 0: \n            return False\n        \n    # If there's any three sequential characters are not unique, string is not happy\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] == s[i + 2]:\n            return False\n\n    # String is happy\n    return True"
      ],
      [
        0.9501376748085022,
        "def is_happy(s):\n    \"\"\"\n    You are assigned a string s.\n    Ascertain whether the string is happy or not.\n    A string is described as happy if it is at least 3 characters long, each consecutive set of 3 characters are individual, \n    every unique character appears no less than twice, and no characters appears thrice in a direct sequence.\n    Additionally, the string is happy if all character sets of 3 or more contains at least 1 vowel \n    and the string should not start or end with the same character.\n\n    For instance:\n    is_happy(4) => False\n    is_happy(aa) => False\n    is_happy(abc) => False\n    is_happy(aabb) -> False\n    is_happy(aabba) -> True\n    is_happy(kyzz) -> False\n    is_happy(aba) => True\n    \"\"\"\n    from collections import Counter\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    if len(s) < 3 or s[0] == s[-1]:\n        return False\n    counter_ = Counter(s)\n    for x, u in counter_.items():\n        if u < 2 or u > 2:\n            return False\n    for i in range(len(s) - 2):\n        if len(set(s[i:i+3])) != 3 or len(set(s[i:i+3]).intersection(vowels)) < 1:\n            return False\n    return True"
      ],
      [
        0.9471696615219116,
        "def is_happy(s):    \n    \"\"\"\n    Write a function that determines whether a string is happy.\n    A string is happy if it satisfies the following rules:\n    - It has at least three characters.\n    - All groups of three consecutive characters are distinct.\n    - Each character recurs at least three times.\n    - No character appears four times successively.\n    - Each character must alternate with at least two different characters.\n    \n    Args:\n        s (str): string to check\n    \n    Returns:\n        bool: True if happy, False otherwise\n    \"\"\"\n    # Rule 1: at least three characters\n    if len(s) < 3:\n        return False\n    # Rule 2: All groups of three consecutive characters are distinct\n    if len(set(s[i:i+3] for i in range(len(s)))) < len(s) - 2:\n        return False\n    # Rule 3: Each character recurs at least three times\n    counter = Counter(s)\n    if any(value < 3 for value in counter.values()):\n        return False\n    # Rule 4: No character appears four times successively\n    if any(len(list(group)) >= 4 for key, group in groupby(s)):\n        return False\n    # Rule 5: Each character must alternate with at least two different characters\n    for key in counter.keys():\n        if len(set(s[i+1] for i in range(len(s) - 1) if s[i] == key)) < 2:\n            return False\n    return True"
      ],
      [
        0.9440030455589294,
        "def is_happy(s):\n    \"\"\"\n    Write a function that takes a string as input and returns True if the string is happy and False otherwise.\n    A string is happy if it satisfies the following conditions:\n    \n    The string contains at most two unique characters.\n    The string contains no more than two occurrences of any character.\n    The string contains no consecutive repetitions of the same character.\n    The string contains no series of three succeeding characters that are the same.\n    \n    Parameters\n    ----------\n    s : str\n        The string to be checked.\n    \n    Returns\n    -------\n    bool\n        True if\"\"\"\n    if len(s) < 3:\n        return False\n    else:\n        # count the frequency of each character\n        char_dict = {}\n        for char in s:\n            if char not in char_dict:\n                char_dict[char] = 1\n            else:\n                char_dict[char] += 1\n                \n        # check the condition of each unique alphabet having identical counts cannot exceed two\n        count_dict = {}\n        for char, count in char_dict.items():\n            if count not in count_dict:\n                count_dict[count] = 1\n            else:\n                count_dict[count] += 1\n        \n        for count, freq in count_dict.items():\n            if count <= 3 and freq > 2:\n                return False\n        \n        # check the condition of consecutive repetitions of the same alphabet\n        for i in range(len(s)-1):\n            if s[i] == s[i+1]:\n                return False\n            \n        # check the condition of the uniqueness of every series of three succeeding alphabets\n        triplets = {s[i:i+3] for i in range(len(s)-2)}\n        if len(triplets) != len(s)-2:\n            return False\n    \n    return True"
      ],
      [
        0.9398366212844849,
        "def is_happy(s):\n    \"\"\"\n    Checks if a string is happy or not.\n    A string is happy if it satisfies the following conditions:\n    - It is at least 3 characters long\n    - Every unique character appears at least twice, but not more than four times\n    - Each consecutive set of 3 characters are distinct\n    - No character appears thrice in consecutive sequence\n    - No character to be allowed to occur both at the beginning and the end of the string\n    \n    Args:\n        s (str): The string to be checked.\n    \n    Returns:\n        bool: True if the string is happy\"\"\"\n    # Checking the first condition - string must be at least 3 characters long\n    if len(s) < 3:\n        return False\n\n    # Third condition - every unique character appears at least twice, but not more than four times\n    char_count = {char: s.count(char) for char in set(s)} \n    for count in char_count.values():\n        if count < 2 or count > 4:\n            return False\n    \n    # Checking the second condition - each consecutive set of 3 characters are distinct\n    for i in range(len(s) - 2):\n        if len(set(s[i:i+3])) != 3:\n            return False\n\n    # Checking the fourth condition - no character appears thrice in consecutive sequence\n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] == s[i+2]:\n            return False\n\n    # Integrating the new condition - no character to be allowed to occur both at the beginning and the end of the string\n    if s[0] == s[-1]:\n        return False\n\n    # If it passes all conditions\n    return True"
      ],
      [
        0.9393788576126099,
        "def is_happy(s):\n    \"\"\"\n    Write your code here\n    \"\"\"\n    if len(s) < 3:\n        return False\n    freq = {}\n    for i in range(len(s)-1):\n        if s[i] == s[i + 1]:\n            return False\n        if s[i] in freq:\n            freq[s[i]] += 1\n        else:\n            freq[s[i]] = 1\n    \n    if s[-1] in freq:\n        freq[s[-1]] += 1\n    else:\n        freq[s[-1]] = 1\n    \n    if max(list(freq.values())) < 2:\n        return False\n    \n    seq = {}\n    for i in range(len(s)-2):\n        sequence = s[i:i+3]\n        if sequence in seq:\n            return False\n        else:\n            seq[sequence] = 1\n    return True"
      ],
      [
        0.9361344575881958,
        "def is_happy(s):\n    \"\"\"\n    Write a function that takes a string s as input and returns True if it is a happy string\n    and False otherwise.\n    \n    A string is called happy if it satisfies the following conditions:\n    \n    - Each of the 3 characters 'a', 'b', and 'c' occurs at most 3 times in s.\n    - Each of the characters 'a', 'b', and 'c' occurs at least once in s.\n    - The characters occur in equal numbers across the entire string.\n    \n    Return True if s is a happy string and False otherwise.\n\"\"\"\n    if not s.isalpha() or not s.islower():\n        return 'Error: Invalid Input. Please enter only lowercase alphabets.'\n    if len(s) < 3:\n        return False\n    alphabets_count = {}\n    sets = set()\n    for i in range(len(s) - 2):\n        subset = s[i:i+3]\n        if subset in sets or subset[0] == subset[1] or subset[1] == subset[2]:\n            return False\n        sets.add(subset)\n        for c in subset:\n            if c in alphabets_count:\n                alphabets_count[c] += 1\n            else:\n                alphabets_count[c] = 1\n    count_even = list(filter(lambda c: c % 2 == 0, alphabets_count.values()))\n    count_odd = list(filter(lambda c: c % 2 != 0, alphabets_count.values()))\n    return len(count_odd) == 0 and len(count_even) <= 3"
      ],
      [
        0.9335739612579346,
        "def is_happy(s):\n    \"\"\"\n    \"\"\"\n    if not s.isalpha() or not s.islower():\n        return 'Error: Invalid Input. Please enter only lowercase alphabets.'\n    if len(s) < 3:\n        return False\n    alphabets_count = {}\n    sets = set()\n    for i in range(len(s) - 2):\n        subset = s[i:i+3]\n        if subset in sets or subset[0] == subset[1] or subset[1] == subset[2]:\n            return False\n        sets.add(subset)\n        for c in subset:\n            if c in alphabets_count:\n                alphabets_count[c] += 1\n            else:\n                alphabets_count[c] = 1\n    count_even = list(filter(lambda c: c % 2 == 0, alphabets_count.values()))\n    count_odd = list(filter(lambda c: c % 2 != 0, alphabets_count.values()))\n    return len(count_odd) == 0 and len(count_even) < 3"
      ]
    ],
    "HumanEval/81": [
      [
        0.9277827739715576,
        "def grade_students(scores):\n    \"\"\"\n    This function takes a list of scores and returns a list of grades based on the following criteria:\n    - A+ if score is greater than 97\n    - A if score is greater than 93\n    - A- if score is greater than 90\n    - B+ if score is greater than 87\n    - B if score is greater than 83\n    - B- if score is greater than 80\n    - C+ if score is greater than 77\n    - C if score is greater than 73\n    - C- if\"\"\"\n    grades = []\n    for score in scores:\n        if score < 0 or score > 100:\n            grades.append(\"Invalid score\")\n        else:\n            if score >= 90:\n                grades.append('A+' if score > 97 else 'A' if score > 93 else 'A-')\n            elif score >= 80:\n                grades.append('B+' if score > 87 else 'B' if score > 83 else 'B-')\n            elif score >= 70:\n                grades.append('C+' if score > 77 else 'C' if score > 73 else 'C-')\n            elif score >= 60:\n                grades.append('D+' if score > 67 else 'D' if score > 63 else 'D-')\n            else:\n                grades.append('F')\n    return grades"
      ],
      [
        0.927764892578125,
        "def grade_students(scores):\n    \"\"\"\n    This function takes a list of scores and returns a list of grades based on the following criteria:\n    - A+ if score is greater than 97\n    - A if score is greater than 93\n    - A- if score is greater than 90\n    - B+ if score is greater than 87\n    - B if score is greater than 83\n    - B- if score is greater than 80\n    - C+ if score is greater than 77\n    - C if score is greater than 73\n    - C- if\"\"\"\n    grades = []\n    for score in scores:\n        if score < 0 or score > 100:\n            grades.append(\"Invalid score\")\n        else:\n            if score >= 90:\n                grades.append('A+' if score > 97 else 'A' if score > 93 else 'A-')\n            elif score >= 80:\n                grades.append('B+' if score > 87 else 'B' if score > 83 else 'B-')\n            elif score >= 70:\n                grades.append('C+' if score > 77 else 'C' if score > 73 else 'C-')\n            elif score >= 60:\n                grades.append('D+' if score > 67 else 'D' if score > 63 else 'D-')\n            else:\n                grades.append('F')\n    return grades"
      ]
    ],
    "HumanEval/82": [
      [
        0.95741868019104,
        "def prime_length(string):\n    \"\"\"\n    Return True if the length of the string is a prime number.\n    >>> prime_length('hello')\n    True\n    >>> prime_length('goodbye')\n    False\n    \"\"\"\n    return is_prime(len(string))"
      ],
      [
        0.9493728876113892,
        "def prime_length(string):\n    \"\"\"Accept a string, get its length, and verify if \n    the length is a prime number.\"\"\"\n    length = len(string)\n    return is_prime(length)"
      ],
      [
        0.9449878931045532,
        "def prime_length(string):\n    '''Determine if the string's length is a prime number'''\n    length = len(string)\n    if is_prime(length):\n        return True\n    else:\n        return False"
      ],
      [
        0.9405323266983032,
        "def prime_length(string):\n    \"\"\"Check if length of a string is a prime number.\"\"\"\n    length = len(string)\n    return is_prime(length)"
      ]
    ],
    "HumanEval/83": [
      [
        0.9437205791473389,
        "def starts_one_ends_correct(n):\n    \"\"\"\n    Count the number of n-digit numbers that start with '1' and end with '1' and are divisible by 2, 3, or 5.\n    \n    Args:\n        n (int): The number of digits in the numbers.\n    \n    Returns:\n        int: The count of n-digit numbers that meet the criteria.\n    \"\"\"\n    if n < 1:\n        return 0  # If n is less than 1, return 0 immediately.\n\n    count = 0\n    for i in range(10**(n-1), 10**n):  # Generate all n-digit numbers.\n        str_i = str(i)\n        if str_i[0] != '1' and str_i[-1] != '1':\n            continue  # Skip the number if it doesn't start or end with '1'.\n        \n        # Now check the divisibility.\n        if i % 2 == 0 or i % 3 == 0 or i % 5 == 0:\n            # Exclude numbers divisible by both 3 and 5 (non-15 multiples)\n            if (i % 3 == 0 and i % 5 == 0 and i % 15 != 0):\n                continue\n            else:\n                count += 1\n    return count"
      ],
      [
        0.9347285032272339,
        "def starts_one_ends(n):\n    \"\"\"\n    Finds the number of integers in the range [10^(n-1), 10^n) that start or end with 1 and are divisible by 3 or 5 but not both.\n    :param n: The number of digits in the range.\n    :return: The number of integers in the range that start or end with 1 and are divisible by 3 or 5 but not both.\n    \"\"\"\n    tally = 0\n    for i in range(10 ** (n - 1), 10 ** n):\n        str_i = str(i)\n        if str_i[0] == '1' or str_i[-1] == '1':  # Number starts or ends with 1\n            if i % 15 != 0 and (i % 3 == 0 or i % 5 == 0):  # Number is divisible by 3 or 5 but not both\n                tally += 1\n    return tally"
      ],
      [
        0.9190014600753784,
        "def all_n_digit_numbers_with_one_ends(n):\n    \"\"\"\n    Returns a list of all n-digit numbers with one ends.\n    \n    Args:\n        n (int): The number of digits in the numbers.\n    \n    Returns:\n        list: A list of n-digit numbers with one ends.\n    \"\"\"\n    start = 10**(n-1)\n    end = 10**n\n\n    numbers_with_one_ends = [i for i in range(start, end) if str(i)[0] == '1' or str(i)[-1] == '1']\n    \n    return numbers_with_one_ends"
      ],
      [
        0.9179291129112244,
        "def all_n_digit_numbers_with_one_ends(n):\n    \"\"\"\n    Returns a list of all n-digit numbers with one ends.\n    \n    Args:\n        n (int): The number of digits in the numbers.\n    \n    Returns:\n        list: A list of n-digit numbers with one ends.\n    \"\"\"\n    start = 10**(n-1)\n    end = 10**n\n\n    numbers_with_one_ends = [i for i in range(start, end) if str(i)[0] == '1' or str(i)[-1] == '1']\n\n    return numbers_with_one_ends"
      ],
      [
        0.9161860942840576,
        "def num_start_end_with_1(n, primes):\n    \"\"\" Counts how many n-digit numbers start or end with 1 and are divisible by some prime in primes \"\"\"\n    start, end = 10**(n-1), 10**n\n    counter = 0\n    for i in range(start, end):\n        if int(str(i)[0]) == 1 or int(str(i)[-1]) == 1:\n            for prime in primes:\n                if i % prime == 0:\n                    counter += 1\n                    break\n    return counter"
      ],
      [
        0.9161285161972046,
        "def starts_one_ends(n):\n    \"\"\"\n    Find the number of prime and fibonacci numbers between 10^n and 10^(n+1)\n    \"\"\"\n    start = 10 ** (n - 1) + 1\n    end = 10 ** n \n    step = 10 if n == 1 else 100\n    numbers = list(range(start, end, step))\n    numbers.extend(list(range(start - 1, end - 1, step)))\n    count = 0\n    for num in numbers:\n        if is_prime(\"\"\"\n    start = 10 ** (n - 1) + 1\n    end = 10 ** n \n    step = 10 if n == 1 else 100\n    numbers = list(range(start, end, step))\n    numbers.extend(list(range(start - 1, end - 1, step)))\n    count = 0\n    for num in numbers:\n        if is_prime(num) or is_fibonacci(num):\n            count += 1\n    return count"
      ],
      [
        0.9129579067230225,
        "def starts_one_ends_correct(n):\n    \"\"\"\n    \"\"\"\n    inclusive_numbers = []\n    for i in range(10**(n-1), 10**n):\n        if str(i)[0] == '1' or str(i)[-1] == '1':\n            if i%7 == 0 or i%11 == 0 or i%13 == 0:\n                if i%(7*11) == 0 and i != 77:\n                    continue\n                else:\n                    inclusive_numbers.append(i)\n    return inclusive_numbers"
      ],
      [
        0.9110739231109619,
        "def find_start_end_with_one(num_digits, divisor):\n    \"\"\"\n    Find the number of integers in the range [10**(num_digits-1), 10**num_digits - 1]\n    that start or end with 1 and are divisible by divisor.\n    Return the number of integers and their sum.\n    \n    >>> find_start_end_with_one(2, 1)\n    (11, 110)\n    >>> find_start_end_with_one(2, 3)\n    (8, 78)\n    >>> find_start_end_with_one(\"\"\"\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    \n    if upper < lower:\n        return -1\n\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return cnt, total"
      ]
    ],
    "HumanEval/84": [],
    "HumanEval/85": [
      [
        0.9447671175003052,
        "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)"
      ],
      [
        0.9326839447021484,
        "def enhanced_solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are at even positions.    \n\n    Examples\n    enhanced_solution([5, 8, 7, 1]) => 5\n    enhanced_solution([3, 3, 3, 3, 3]) => 9\n    enhanced_solution([30, 13, 24, 321]) => 30\n    \"\"\"\n    return sum(num for i, num in enumerate(lst[::2]) if num % 2 == 1)"
      ],
      [
        0.9289305806159973,
        "def solution(lst):\n    \"\"\"\n    Given a list of integers, return the sum of all the elements that are odd indexed and odd.\n    \n    Args:\n        lst (list): list of integers\n    \n    Returns:\n        int: sum of odd indexed and odd elements\n    \"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 == 0 and val % 2 != 0)"
      ]
    ],
    "HumanEval/86": [
      [
        0.9397182464599609,
        "def anti_shuffle(s):\n  \"\"\"\n  Given a string s, return a string of the same length where all characters that are alphabetically to the right of their neighbors are swapped.\n  \n  Example 1:\n  \n  Input: s = \"abdc\"\n  Output: \"acdb\"\n  Explanation: \"dcba\" is also a valid answer.\n  \n  Example 2:\n  \n  Input: s = \"a\"\n  Output: \"a\"\n  \n  Example 3:\n  \n  Input: s = \"ba\"\n  Output: \"ba\"\n  \n  Constraints\"\"\"\n  # Split input into words\n  words = s.split()\n\n  # Iterate over each word\n  for i, word in enumerate(words):\n    # Split word into characters\n    chars = list(word)\n\n    # Sort characters\n    chars.sort()\n\n    # Join characters back into sorted word\n    words[i] = ''.join(chars)\n\n  # Join words back into sorted sentence\n  s = ' '.join(words)\n\n  return s"
      ],
      [
        0.9393610954284668,
        "def anti_shuffle(s):\n    \"\"\"\n    \"\"\"\n    s = s.split(' ')\n    sorted_s = custom_sort(s)\n    return ' '.join(sorted_s)"
      ],
      [
        0.9392924308776855,
        "def anti_shuffle(s):\n    \"\"\"\n    Function that accepts a string and produces an ordered variant using the custom sort function.\n    The ordered variant of a string is a new phrase where every word (partitioned by space)\n    is replaced by a new word where every character adheres to the custom sort methodology.\n    The word and blank space sequence in the sentence remains unchanged.\n\n    Args:\n    s: String\n\n    Returns:\n    The modified string with each word sorted according to the rules of custom_sort\n    \"\"\"\n\n    sorted_words = [custom_sort(word) for word in s.split(\" \")]\n    return ' '.join(sorted_words)"
      ],
      [
        0.936354398727417,
        "def anti_shuffle(s):\n    \"\"\"\n    Function that accepts a string and produces an ordered variant using the custom_sort function.\n    The ordered variant of a string is a new phrase where every word (partitioned by space) \n    is replaced by a new word where every character adheres to the custom_sort methodology.\n    The word and blank space sequence in the sentence remains unchanged.\n\n    Args: \n        s: string\n\n    Returns:\n        The modified string with each word sorted according to the rules of custom_sort\n    \"\"\"\n    \n    sorted_words = [custom_sort(word) for word in s.split(\" \")]\n    return ' '.join(sorted_words)"
      ],
      [
        0.9263129830360413,
        "def anti_jumble(s):\n    \"\"\"\n    Given a string s, return a string of the same words in the string, but with the letters in each word ordered\n    in descending alphabetical order.\n    \n    For example, \"The Holy Bible\" becomes \"The ylol Hleb\".\n    \n    You may assume that all the letters in the input string are lowercase.\n    \n    Parameters\n    ----------\n    s : str\n        The string to be jumbled.\n    \n    Returns\n    -------\n    str\n        The jumbled string.\n    \"\"\"\n    return ' '.join(custom_order(word) for word in s.split(' '))"
      ],
      [
        0.924117922782898,
        "def sortString(s):\n    \"\"\"\n    :type s: str\n    :rtype: str\n    \"\"\"\n    words = s.split()  # Split the input string into a list of words\n    sorted_words = [\"\".join(sorted(word)) for word in words]  # Sort each word alphabetically\n    return \" \".join(sorted_words)  # Join the sorted words back into a string with spaces between them"
      ]
    ],
    "HumanEval/87": [
      [
        0.9294719696044922,
        "def get_row(lst, x):\n    \"\"\"\n    Find all rows in a list of lists that contain a given element.\n    \n    Args:\n        lst: a list of lists\n        x: an element\n    Returns:\n        A list of tuples, where each tuple is the (row, column) index of an element x in lst\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        for column_index, element in enumerate(row):\n            if element == x:\n                result.append((row_index, column_index))\n    result.sort(key=lambda a: (a[0], -a[1]))\n    return result"
      ],
      [
        0.9051340222358704,
        "def find_in_matrix(matrix, x, is_reversed=False):\n    \"\"\"\n    Find all occurrences of a given element in a matrix.\n\n    :param matrix: The matrix to search in.\n    :param x: The element to search for.\n    :param is_reversed: Whether to reverse each row before searching.\n    :return: A list of coordinates of all occurrences of the element.\n    \"\"\"\n    # If the isReversed flag is set to True, reverse each row\n    if is_reversed:\n        matrix = [row[::-1] for row in matrix]\n\n    coordinates = []\n\n    # Iterate over all elements in the matrix\n    for i in range(len(matrix)):\n        for j in range(len(matrix[i])):\n            # If the current element equals 'x',\n            # add its position to the coordinates list\n            if matrix[i][j] == x:\n                # Depending on the isReversed flag, either add the position as is,\n                # or with the column index calculated from the end of the row.\n                tuple = [i, j] if not is_reversed else [i, len(matrix[i]) - j - 1]\n                coordinates.append(tuple)\n\n    # Sort the coordinates first by row index (i), then by column index (j)\n    # Notice that the Python's built-in sort function already preserves the order for equal values,\n    # so there's no need to specify what to do when \"a[0] == b[0] \", unlike in JavaScript.\n    coordinates.sort(key = lambda x: (x[0], x[1]))\n\n    return coordinates"
      ],
      [
        0.9011964797973633,
        "def find_int(arr, num):\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\n    You must write an algorithm with O(log n) runtime complexity.\n    \n    Example 1:\n    Input: nums = [1,3,5,6], target = 5\n    Output: 2\n    \n    Example 2:\n    Input: nums = [1,3,5,6], target = 2\n    Output: 1\n    \n    Example \"\"\"\n    coords = sorted([(i, j) for i, sub_arr in enumerate(arr) for j, elem in enumerate(sub_arr) if elem == num])\n    return coords"
      ],
      [
        0.9011514186859131,
        "def find_int(arr, num):\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\n    You must write an algorithm with O(log n) runtime complexity.\n    \n    Example 1:\n    Input: nums = [1,3,5,6], target = 5\n    Output: 2\n    \n    Example 2:\n    Input: nums = [1,3,5,6], target = 2\n    Output: 1\n    \n    Example \"\"\"\n    coords = sorted([(i, j) for i, sub_arr in enumerate(arr) for j, elem in enumerate(sub_arr) if elem == num])\n    return coords"
      ],
      [
        0.9006354212760925,
        "def find_indices(first_list, second_list):\n    \"\"\"\n    Given two lists of numbers, return a list of all indices where the numbers match.\n    For example, given the following lists:\n    \n    first_list = [1, 2, 3, 2, 1]\n    second_list = [4, 2, 3, 2, 5]\n    \n    The function should return [1, 2, 3].\n    \n    You may assume that input lists are not empty and contain only integers.\n    \n    You may not use the standard set methods (set(), set.add(), set\"\"\"\n    indices = []\n    for num in second_list:\n        index = [i for i, x in enumerate(first_list) if x==num]\n        indices.append(index)\n    return indices"
      ]
    ],
    "HumanEval/88": [
      [
        0.9274014234542847,
        "def sort_odds(arr):\n    \"\"\"\n    Given a list of numbers, sort the odd numbers in descending order while leaving the even numbers at their original positions.\n    \n    Examples\n    \n    [7, 1]  =>  [1, 7]\n    [5, 8, 6, 3, 4]  =>  [3, 8, 6, 5, 4]\n    [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]  =>  [9, 8, 1,\"\"\"\n    return sorted(arr, key=abs, reverse=True)"
      ],
      [
        0.9253191351890564,
        "def custom_sort(array):\n    \"\"\"\n    \"\"\"\n    first_element = array[0] if array else 0\n    last_element = array[-1] if array else 0\n    is_first_odd = first_element % 2 == 1\n    is_last_odd = last_element % 2 == 1\n    if is_first_odd and is_last_odd:\n        grouping = \"odd_group\"\n    elif not is_first_odd and not is_last_odd:\n        grouping = \"even_group\"\n    else:\n        grouping = \"mixed_group\"\n    if (first_element + last_element) % 3 == 0:\n        array.sort()\n    elif (first_element + last_element) % 2 == 0:\n        array.sort(reverse=True)\n    else:\n        array = sorted(i for i in array if i % 2 == 0) + [i for i in array if i % 2 != 0]\n    return {'even_group': [], 'odd_group': [], 'mixed_group': []}.update({grouping: array})"
      ],
      [
        0.9223489761352539,
        "def customized_split(array):\n    \"\"\"\n    \"\"\"\n    # Check array length\n    if len(array) < 2:\n        return array\n\n    first = array[0]\n    penultimate = array[-2]\n    sum_value = first + penultimate\n    is_even_sum = sum_value % 2 == 0\n    is_sum_divisible_by_6 = sum_value % 6 == 0\n    is_sum_divisible_by_4 = sum_value % 4 == 0\n\n    even_section = []\n    odd_section = []\n    diff_section = []\n\n    for num in array:\n        is_even = num % 2 == 0\n        if is_even:\n            even_section.append(num)\n        elif is_even_sum:\n            odd_section.append(num)\n        else:\n            diff_section.append(num)\n\n    if is_sum_divisible_by_6:\n        even_section.sort()\n        odd_section.sort()\n        diff_section.sort()\n    elif is_sum_divisible_by_4:\n        even_section.sort(reverse=True)\n        odd_section.sort(reverse=True)\n        diff_section.sort(reverse=True)\n    else:\n        even_section.sort()\n        \n    return even_section + odd_section + diff_section"
      ],
      [
        0.9219965934753418,
        "def reverse_odd_sort(arr):\n    \"\"\"\n    Given an array of numbers, return an array of the same numbers in reverse order.\n    \n    >>> reverse_odd_sort([1, 2, 3, 4, 5])\n    [5, 4, 3, 2, 1]\n    >>> reverse_odd_sort([1, 2, 3, 4, 5, 6])\n    [6, 5, 4, 3, 2, 1]\n    >>> reverse_odd_sort([1, 2, 3, 4, \"\"\"\n    odd_nums = []\n    for num in arr:\n        if num % 2 == 1:\n            odd_nums.append(num)\n    odd_nums.sort(reverse=True)\n\n    result = []\n    i = 0\n    for num in arr:\n        if num % 2 == 1:\n            result.append(odd_nums[i])\n            i += 1\n        else:\n            result.append(num)\n    \n    return result"
      ]
    ],
    "HumanEval/89": [
      [
        0.9318463206291199,
        "def encrypt(string):\n  \"\"\"\n  Encrypts a string by shifting each character by 2 positions.\n  \n  Args:\n    string: The string to be encrypted.\n  \n  Returns:\n    The encrypted string.\n  \"\"\"\n  cipher = \"\"\n  for char in string:\n    ascii_val = ord(char)\n    encrypted_val = ascii_val + 2\n    encrypted_char = chr(encrypted_val)\n    cipher += encrypted_char\n  return cipher"
      ],
      [
        0.9312784671783447,
        "def encrypt(s, shift, seed=0):\n    \"\"\"Create a function named encrypt that accepts two parameters, a string and an integer for rotation. The function should return an encrypted string using a shuffled alphabet based on the input integer. It should handle case sensitivity and preserve non-alphabetic characters. It should also handle exceptions due to rotations exceeding the length of the alphabet.\"\"\"\n\n    # Define alphabet\n    lower_alphabet = string.ascii_lowercase\n    upper_alphabet = string.ascii_uppercase\n\n    # Introduce seed manipulation for more complexity\n    shift = (shift + seed) % 26\n\n    result = \"\"\n\n    for c in s:\n        # Support for unicode characters\n        if not c.isascii():\n            result += chr(ord(c) + shift)\n        # Preserve non-alphabetical characters\n        elif not c.isalpha():\n            result += c\n        else:\n            # Handle upper/lower-case characters differently for case sensitivity\n            if c.isupper():\n                result += upper_alphabet[(upper_alphabet.index(c) + shift) % 26]\n            else:\n                result += lower_alphabet[(lower_alphabet.index(c) + shift) % 26]\n\n    return result"
      ],
      [
        0.9303379058837891,
        "def encrypt(string):\n    \"\"\"\n    Encrypts a string by shifting each character by 2 positions.\n    \n    Args:\n        string (str): The string to be encrypted.\n    \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    encrypted_string = \"\"\n    for i in range(len(string)):\n        char = string[i]\n        encrypted_string += chr(ord(char)+2)\n    return encrypted_string"
      ],
      [
        0.9300368428230286,
        "def encrypt(text):\n    \"\"\"\n    Encrypts a given text by shifting each letter by 2 positions in the alphabet.\n    \n    Args:\n        text (str): The text to be encrypted.\n    \n    Returns:\n        str: The encrypted text.\n    \"\"\"\n    encrypted_text = \"\"\n    for letter in text:\n        if letter.isalpha(): \n            encrypted_text += chr(ord(letter) + 2)\n        else:\n            encrypted_text += letter\n\n    return encrypted_text"
      ],
      [
        0.9268922805786133,
        "def encrypt(text):\n    \"\"\"\n    Encrypts a string by shifting each character by 2 positions.\n    \n    Args:\n        text (str): The string to be encrypted.\n    \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    result = []\n    for char in text: \n        result.append(chr(ord(char) + 2))\n    return ''.join(result)"
      ],
      [
        0.9256778955459595,
        "def cipher(s):\n    \"\"\"Derive a python function called 'cipher' that takes a string parameter and returns a ciphered string utilizing a rotated alphabet (the alphabet is shifted three positions ahead, using the modulo operator in Python to handle wrapping at the ends). This function should conserve the case of the characters (upper and lower), keep the non-alphabetical characters unchanged in the derived output, and work for all characters of the lower case and uppercase English alphabets. Here are some examples:\n    cipher('Hi') renders 'Lm'\n    cipher('aSdFgHjKl') tends to become 'dVgIjKmNpQr'\n    cipher('Zx!123_') translates to 'Ca!123_'\n    cipher('E.T + Ux') is turned into 'H.Y + Xc'\n    \"\"\"\n    result = ''\n    \n    for char in s:\n        # preserve the non-alphabetical characters\n        if not char.isalpha():\n            result += char\n            continue\n\n        # shift three positions ahead, with case consideration\n        shifted_char = chr((ord(char.lower()) - 97 + 3) % 26 + 97) if char.islower() else chr((ord(char.upper()) - 65 + 3) % 26 + 65)\n        result += shifted_char\n\n    return result"
      ],
      [
        0.925582230091095,
        "def cipher(s):\n    \"\"\"Derive a python function called 'cipher' that takes a string parameter and returns a ciphered string utilizing a rotated alphabet (the alphabet is shifted three positions ahead, using the modulo operator in Python to handle wrapping at the ends). This function should conserve the case of the characters (upper and lower), keep the non-alphabetical characters unchanged in the derived output, and work for all characters of the lower case and uppercase English alphabets. Here are some examples:\n    cipher('Hi') renders 'Lm'\n    cipher('aSdFgHjKl') tends to become 'dUgIjLmNpQr'\n    cipher('Zx112e_') translates to 'Ca!I23h_'\n    cipher('E.x + Uz') is turned into 'H.a + Xc'\n    \"\"\"\n    result = ''\n\n    for char in s:\n    # preserve the non-alphabetical characters\n        if not char.isalpha():\n            result += char\n            continue\n\n    # shift three positions ahead, with case consideration\n        shifted_char = chr((ord(char.lower()) - 97 + 3) % 26 + 97) if char.islower() else chr((ord(char.upper()) - 65 + 3) % 26 + 65)\n        result += shifted_char\n\n    return result"
      ],
      [
        0.9250080585479736,
        "def encrypt(text, shift): \n  \"\"\"\n  Encrypts the given text by shifting each letter by the given shift value.\n  \n  >>> encrypt(\"This is a test.\", 8)\n  'Bpqa qa i bswx.'\n  \"\"\"\n  result = \"\" \n  \n  for i in range(len(text)):\n    char = text[i]\n  \n    if (char.isalpha()):\n        char_code = ord(char)\n        char_code += shift\n        if char.isupper():\n            if char_code > ord('Z'):\n                char_code -= 26\n            elif char_code < ord('A'):\n                char_code += 26\n        elif char.islower():\n            if char_code > ord('z'):\n                char_code -= 26\n            elif char_code < ord('a'):\n                char_code += 26\n        result += chr(char_code)\n    else:\n        result += char\n    \n  return result"
      ],
      [
        0.9240345358848572,
        "def encrypt(message): \n    \"\"\"\n    Encrypts a message by shifting each character by 2 in the ASCII table \n    :param message: the message to be encrypted \n    :return: the encrypted message \n    \"\"\"\n    encrypted_message = \"\" \n    for character in message: \n        # increment the character number to get its encrypted form \n        encrypted_message += chr(ord(character) + 2) \n    return encrypted_message "
      ]
    ],
    "HumanEval/90": [
      [
        0.9676700234413147,
        "def next_smallest(lst):\n    \"\"\"\n    Given a list of numbers, return the second smallest number in the list.\n    If there is no second smallest number, return None.\n    \n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 4, 3, 2, 1])\n    2\n    >>> next_smallest([1, 1, 1, 1, 1])\n    None\n    >>> next_smallest([])\n    None\n    \"\"\"\n    if not lst or len(lst) < 2:   # If the list is empty or has less than 2 elements, there's no second smallest\n        return None \n\n    smallest = second_smallest = float('inf')\n    for element in lst:\n        if element < smallest:\n            second_smallest = smallest\n            smallest = element\n        elif smallest < element < second_smallest:\n            second_smallest = element\n    \n    return None if second_smallest == float('inf') else second_smallest"
      ],
      [
        0.9571599364280701,
        "def next_smallest(lst):\n    \"\"\"\n    Given a list of numbers, return the next smallest number in the list.\n    If there is no next smallest number, return None.\n    \n    >>> next_smallest([1, 2, 3])\n    2\n    >>> next_smallest([1, 1, 1])\n    None\n    >>> next_smallest([1])\n    None\n    \"\"\"\n    if len(lst) < 2:  # If the list has less than 2 elements, return None\n        return None\n    \n    first_min = second_min = float('inf')\n    \n    for num in lst:\n        if num < first_min:  # If num is smaller than both first_min and second_min\n            second_min = first_min\n            first_min = num\n        elif num < second_min and num != first_min:  # If num is only smaller than second_min\n            second_min = num\n            \n    if second_min == float('inf'):  # If second_min was never updated, return None\n        return None\n    \n    return second_min"
      ],
      [
        0.9429371953010559,
        "def next_smallest(lst):\n    \"\"\"\n    Find the next smallest number in a list.\n    \n    Args:\n        lst: a list of numbers\n    \n    Returns:\n        The next smallest number in the list.\n    \"\"\"\n    \n    if len(lst) < 2:\n        return None\n    \n    lst.sort()\n    \n    smallest = lst[0]\n    \n    for el in lst:\n        if el > smallest:\n            return el\n    \n    return None"
      ],
      [
        0.9412976503372192,
        "def second_smallest(arr):\n    \"\"\"\n    Given an array arr, find the second smallest element in it.\n    \n    Example 1:\n    \n    Input:\n    N = 2\n    arr[] = {11,2}\n    Output: 2\n    Explanation: Second smallest element in the\n    given array is 2.\n    \n    Example 2:\n    \n    Input:\n    N = 5\n    arr[]={2,2,1,2,3}\n    Output: 2\n    Explanation: Second smallest element in the\n    given array is 2.\n    \"\"\"\n    arr = list(set(arr))\n    arr.sort()\n    return arr[1] if len(arr) > 1 else None"
      ],
      [
        0.9337713718414307,
        "def next_smallest(lst):\n    \"\"\"\n    Given a list of numbers, return the next smallest number after each element.\n    For example, given the list [3, 2, 1], return [2, 1, 0].\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    smallest = float('inf')\n    next_smallest = float('inf')\n    for i in range(0, len(lst)):\n        if lst[i] < smallest:\n            next_smallest = smallest\n            smallest = lst[i]\n        elif lst[i] > smallest and lst[i] < next_smallest:\n            next_smallest = lst[i]\n    return None if next_smallest == float('inf') else next_smallest"
      ]
    ],
    "HumanEval/91": [
      [
        0.9433601498603821,
        "def is_bored(S):\n    \"\"\"\n    Given a string S consisting of sentences separated by a single space, return the number of sentences that are boring and the number of sentences that are enthusiastic.\n    A sentence is boring if it contains at least one word starting with the letter 'I'.\n    A sentence is enthusiastic if it ends with the letter '!'.\n    \n    Args:\n        S (str): A string consisting of sentences separated by a single space.\n    \n    Returns:\n        tuple: A tuple of two integers, the number of boring sentences and the number of enthusiastic sentences.\n    \"\"\"\n    sentences = [s.strip() for s in S.replace('!', '!. ').replace('.', '. ').replace('?', '? ').split() if s]\n    mundane_count = sum(s.startswith('I') for s in sentences)\n    enthusiastic_count = sum(s.endswith('!') for s in sentences)\n    return mundane_count, enthusiastic_count"
      ],
      [
        0.9320356249809265,
        "def is_bored(S):\n    \"\"\"\n    Given a string S consisting of N sentences, returns a tuple (A, B)\n    consisting of the number of boring and exciting sentences, respectively.\n    A sentence is boring if it contains the word 'boring' and exciting if\n    it ends in an exclamation mark.\n    \n    Args:\n        S (str): A string consisting of N sentences.\n    \n    Returns:\n        tuple: A tuple (A, B) consisting of the number of boring and exciting\n        sentences, respectively.\n    \"\"\"\n    boring_sent_count = 0\n    exciting_sent_count = 0\n\n    # Split S into sentences using ., ? or ! as delimiters\n    sentences = re.split(r'\\.|\\?|\\!', S)\n\n    for sentence in sentences:\n        # Remove leading and trailing whitespace\n        sentence = sentence.strip()\n\n        # Check for boring and exciting sentences\n        if sentence.startswith('I'):\n            boring_sent_count += 1\n        if sentence.endswith('!'):\n            exciting_sent_count += 1\n\n    return (boring_sent_count, exciting_sent_count)"
      ],
      [
        0.8964564800262451,
        "def detect_emotion(S):\n    \"\"\"\n    This function takes a string S as input and returns a tuple of integers (dull_count, excited_count).\n    The dull_count is the number of sentences in S that start with \"He\" or \"She\".\n    The excited_count is the number of sentences in S that end with a question mark.\n    :param S: A string containing one or more sentences\n    :return: A tuple of integers (dull_count, excited_count)\n    \"\"\"\n    # Split the text into a list of sentences using the sentence indicators\n    sentences = [sentence.strip() for sentence in re.split(\"[.!?]\", S) if sentence]\n    dull_count = len([sentence for sentence in sentences if sentence.startswith(\"He\")])\n    excited_count = len([sentence for sentence in sentences if sentence.endswith(\"?\")])\n    return dull_count, excited_count"
      ]
    ],
    "HumanEval/92": [
      [
        0.9045974016189575,
        "def sum_to_zero(nums): \n    \"\"\"\n    Given an array of integers, return True if the sum of any \n    3 integers results in 0.\n    \n    >>> sum_to_zero([1, 2, -3])\n    True\n    >>> sum_to_zero([1, 2, 3])\n    False\n    \"\"\"\n    for i in range(len(nums)): \n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i] + nums[j] + nums[k] == 0:\n                    return True\n    return False"
      ]
    ],
    "HumanEval/93": [
      [
        0.9335869550704956,
        "def advanced_encode(message, shift=2):\n    \"\"\"\n    Encodes a message by shifting each letter by 2 places.\n    \n    >>> advanced_encode('hello world')\n    '10111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\"\"\"\n    vowels = 'aeiou'\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encoded_message = ''\n    for i in range(len(message)):\n        if message[i] == ' ':\n            encoded_message += ' '\n        else:\n            if message[i].lower() not in vowels:\n                if message[i].islower():\n                    encoded_message += alphabet[(alphabet.index(message[i]) + shift) % 26]\n                else:\n                    encoded_message += alphabet[(alphabet.index(message[i].lower()) + shift) % 26].upper()\n            else:\n                if message[i].islower():\n                    encoded_message += alphabet[(alphabet.index(message[i]) - shift) % 26]\n                else:\n                    encoded_message += alphabet[(alphabet.index(message[i].lower()) - shift) % 26].upper()\n    new_message = ''\n    for i in range(len(encoded_message)):\n        if encoded_message[i] != ' ':\n            new_index = (i+1) * shift * ord(encoded_message[i])\n            while new_index > len(encoded_message) - 1:\n                new_index -= len(encoded_message)\n            new_message += str(new_index) + encoded_message[i]\n        else:\n            new_message += ' '\n    return new_message"
      ],
      [
        0.9166600108146667,
        "def replace_vowels(string):\n  \"\"\"\n  Replace all vowels in a string with the next letter in the alphabet.\n  \n  >>> replace_vowels(\"hello world\")\n  'ifmmp xpsme'\n  \"\"\"\n  result = \"\"\n  for c in string:\n    if c in \"aeiouAEIOU\":\n      result += chr(ord(c) + 1) \n    else:\n      result += c\n  return result"
      ]
    ],
    "HumanEval/94": [
      [
        0.9537056684494019,
        "def skjkasdkd(lst):\n    \"\"\"\n    Find the maximum prime number in a list and return the sum of its digits.\n    \n    Args:\n        lst (list): A list of integers.\n    \n    Returns:\n        int: The sum of the digits of the maximum prime number found in the list.\n    \"\"\"\n    max_prime = 0\n    # Iterate over the entire list\n    for i in lst:\n        # Check if the current number is prime and greater than our current maximum\n        if is_prime(i) and i > max_prime:\n            max_prime = i # If so, update our maximum prime\n    # Return the sum of the digits of the maximum prime number found\n    return sum_digits(max_prime)"
      ]
    ],
    "HumanEval/95": [
      [
        0.9297517538070679,
        "def check_dict_case(dict):\n    \"\"\"\n    Check if all the keys in a dictionary are in lowercase or uppercase\n    :param dict: dictionary\n    :return: True if all keys are in lowercase or uppercase, False otherwise\n    \"\"\"\n    # if the dictionary is empty\n    if not bool(dict):\n        return False\n\n    # get all the keys from the dictionary\n    keys = dict.keys()\n\n    # check if all keys are lowercase or uppercase\n    is_lower = all(key == key.lower() for key in keys)\n    is_upper = all(key == key.upper() for key in keys)\n\n    # if all keys are either in lowercase or uppercase return true\n    if is_lower or is_upper:\n        return True\n\n    return False"
      ],
      [
        0.9208569526672363,
        "def check_dict_case(d):\n    \"\"\"\n    Check if all keys in a dictionary are either upper case or lower case.\n    \n    Parameters\n    ----------\n    d : dict\n        The dictionary to check.\n        \n    Returns\n    -------\n    bool\n        True if all keys are either upper case or lower case. False otherwise.\n    \"\"\"\n    if not d: \n        # If the dictionary is empty, return False\n        return False \n\n    lower = 0\n    upper = 0\n\n    # Iterate over all keys in the dictionary\n    # Check if key is upper or lower case\n    for key in d:\n        if key.islower():\n            lower += 1\n        elif key.isupper():\n            upper += 1   \n        else:\n            # If key contains a mix of upper and lower case letters, return False\n            return False\n\n    # If all keys are either upper case or lower case, return True. Else, return False. \n    if lower == len(d) or upper == len(d):\n        return True\n    else:\n        return False"
      ]
    ],
    "HumanEval/96": [
      [
        0.9646034240722656,
        "def count_up_to(n):\n    \"\"\"Implement a function that takes a non-negative integer and returns a list of prime numbers below n.\"\"\"\n    primes = []\n    for i in range(2, n):\n        if is_prime(i):\n            primes.append(i)\n    return primes"
      ]
    ],
    "HumanEval/97": [
      [
        0.925129771232605,
        "def multiply(a, b):\n    \"\"\"\n    This function multiplies two numbers\n    \"\"\"\n    return a * b\n    \n    def multiply_last_digits(a, b):\n    \"\"\"\n    This function multiplies the last digits of two numbers\n    \"\"\"\n    last_digit_a = abs(a) % 10  # getting the last digit of a\n    last_digit_b = abs(b) % 10  # getting the last digit of b\n    return last_digit_a * last_digit_b"
      ],
      [
        0.9106695652008057,
        "def multiply_last_ten_digits(a, b):\n    \"\"\"\n    Returns the last ten digits of the product of two numbers.\n    \"\"\"\n    return last_ten_digits(a * b)\n    \n    def multiply_last_ten_digits(a, b):\n    \"\"\"\n    Returns the last ten digits of the product of two numbers.\n    \"\"\"\n    return last_ten_digits(a * b)"
      ],
      [
        0.9022064208984375,
        "def unit_product(num1, num2):\n    \"\"\"\n    This function takes two numbers and returns the product of their units.\n    \n    Parameters:\n    num1 (int): The first number.\n    num2 (int): The second number.\n    \n    Returns:\n    int: The product of the units of num1 and num2.\n    \"\"\"\n    unit_digit1 = num1 % 10\n    unit_digit2 = num2 % 10\n    return unit_digit1 * unit_digit2"
      ],
      [
        0.900907576084137,
        "def digit_product(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the product of all digits of a and b.\n    \n    >>> digit_product(12, 34)\n    48\n    >>> digit_product(12, 3456789)\n    48\n    \"\"\"\n    product = 1\n    \n    # Convert integers to strings\n    a_str = str(a)\n    b_str = str(b)\n    \n    # Multiply each digit of a and b\n    for digit in a_str:\n        product *= int(digit)\n    for digit in b_str:\n        product *= int(digit)\n    \n    return product"
      ]
    ],
    "HumanEval/98": [
      [
        0.9742182493209839,
        "def count_upper(s):\n    \"\"\"\n    Example:\n    count_upper('aBCdEf') returns 1\n    count_upper('abcdefg') returns 0\n    count_upper('dBBE') returns 0\n    \"\"\"\n    upper_vowels = ['A', 'E', 'I', 'O', 'U']\n    \n    # count of uppercase vowels at even indices\n    count = sum(1 for i in range(len(s)) if i % 2 == 0 and s[i] in upper_vowels)\n  \n    return count"
      ],
      [
        0.9710915088653564,
        "def count_upper(s):\n    \"\"\"\n    Counts the number of uppercase vowels present in even indices of an input string.\n    \"\"\"\n    vowels = ['A', 'E', 'I', 'O', 'U']\n    return sum(1 for i in range(0, len(s), 2) if s[i] in vowels)"
      ],
      [
        0.9682578444480896,
        "def count_upper_vowels(s):\n    \"\"\"\n    Example:\n    count_upper_vowels('aBCdEf') should return 1\n    count_upper_vowels('abcdefg') should return 0\n    count_upper_vowels('dBBE') should return 0\n    \"\"\"\n    return sum(1 for i, letter in enumerate(s) if i % 2 == 0 and letter in 'AEIOU')"
      ],
      [
        0.9678596258163452,
        "def count_upper_vowels(s):\n    \"\"\"\n    Example:\n    count_upper_vowels('aBCdEf') should return 1\n    count_upper_vowels('abcdefg') should return 0\n    count_upper_vowels('dBBE') should return 0\n    \"\"\"\n    counter = 0\n    vowels = 'AEIOU'\n    for i, char in enumerate(s):\n        if i % 2 == 0 and char in vowels:\n            counter += 1\n    return counter"
      ],
      [
        0.9672808647155762,
        "def count_upper_vowels(s):\n    \"\"\"\n    This function counts the number of capital letters which are vowels on even indices in the string.\n    Example:\n    count_upper_vowels('aBCdEf') should return 1\n    count_upper_vowels('abcdefg') should return 0\n    count_upper_vowels('dBBE') should return 1\n    \"\"\"\n    upper_vowels = 'AEIOU'\n    even_letters = s[::2]\n    counter = sum(1 for letter in even_letters if letter in upper_vowels)\n    return counter"
      ],
      [
        0.9617788791656494,
        "def count_upper(s):\n    \"\"\"\n    Count the number of uppercase vowels in a string.\n    \n    >>> count_upper('AaBbCc')\n    2\n    >>> count_upper('cCC')\n    0\n    >>> count_upper('AaBbCc')\n    2\n    \"\"\"\n    upper_vowels = 'AEIOU'\n    return sum(1 for i in range(len(s)) if i % 2 == 0 and s[i] in upper_vowels)"
      ],
      [
        0.9614415764808655,
        "def count_upper(s):\n    \"\"\"\n    count_upper('aBCdEfG') returns 2\n    count_upper('ABCDEF') returns 3\n    count_upper('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') returns 5\n    \"\"\"\n    assert 1 <= len(s) <= 1000, \"String length should be between 1 and 1000 characters\"\n    \n    vow = ['A', 'E', 'I', 'O', 'U']\n    count = sum(1 for i in range(len(s)) if i % 2 == 0 and s[i] in vow)\n    \n    return count"
      ],
      [
        0.9612071514129639,
        "def count_upper(s):\n    \"\"\"\n    Count the number of uppercase vowels in a string.\n    \n    >>> count_upper('AEIOU')\n    5\n    >>> count_upper('aeiou')\n    0\n    >>> count_upper('AaBbCc')\n    2\n    \"\"\"\n    return sum(1 for i, c in enumerate(s) if c.isupper() and c in 'AEIOU' and i % 2 == 0)"
      ],
      [
        0.9596524238586426,
        "def count_upper(s):\n    \"\"\"\n    Count uppercase vowels in even index positions.\n    Use the Python builtin isupper() to check for uppercase letters, and set() for O(1) membership lookup.\n    Params: s - string input\n    Returns: count - number of capitalised vowels in even-positioned indices\n    \"\"\"\n    assert 1 <= len(s) <= 1000, \"Invalid string length. It should be between 1 and 1000 characters\"\n    vowels = set(\"AEIOU\")\n    count = sum(1 for i in range(0, len(s)) if s[i].isupper() and s[i] in vowels and i % 2 == 0)\n    return count"
      ],
      [
        0.9578433036804199,
        "def count_upper_case_vowels(s):\n    \"\"\"\n    Count the number of uppercase vowels in a string.\n    \n    >>> count_upper_case_vowels('ABCDE')\n    2\n    >>> count_upper_case_vowels('abcde')\n    0\n    >>> count_upper_case_vowels('ABCDEabcde')\n    2\n    \"\"\"\n    vowels = ['A', 'E', 'I', 'O', 'U']\n    return len([c for i, c in enumerate(s) if c in vowels and i % 2 == 0])"
      ]
    ],
    "HumanEval/99": [
      [
        0.919829249382019,
        "def complex_rounding(value, low, high):\n    '''\n    Craft a function that takes in a number represented as a string, value, and two \n    integers, low and high, establishing range delimiters. This function should yield \n    the nearest integer to the input number without falling back on standard functions such \n    as round(). Alongside this, ascertain that the specified number is a valid integer or \n    floating-point number residing within the defined interval. Otherwise, \n    reciprocate with an error alert. For numbers at an equal distance from two integers, conform it \n    towards zero.\n    '''\n    # Check if the input value is a valid number\n    try:\n        num_value = Decimal(value)\n    except InvalidOperation:\n        return \"Error: Invalid input.\"\n    \n    # Check if the value is within the given range\n    if not (low <= num_value <= high):\n        return \"Error: Beyond range.\"\n      \n    # Round according to the rules specified\n    decimal, integer = divmod(num_value, 1)\n    \n    if decimal >= Decimal('0.5'):\n        return int(integer + 1)\n    elif decimal <= Decimal('-0.5'):\n        return int(integer - 1)\n    else:\n        return int(integer)"
      ],
      [
        0.9197555780410767,
        "def complex_rounding(value, low, high):\n    \"\"\"\n    Create a function that takes in a number represented as a string, value, and two \n    integers, low and high, establishing range parameters. This function should yield \n    the nearest integer to the input number without falling back on standard functions such\n    as round(). Alongside this, ascertain that the specified number is a valid integer or \n    floating-point number residing within the defined interval. Otherwise, \n    reciprocate with an error alert. For numbers at an equal distance from two integers, round it \n    towards zero.\n    \"\"\"\n    # Check if the input value is a valid number\n    try:\n        num_value = Decimal(value)\n    except InvalidOperation:\n        return \"Error: Invalid input.\"\n\n    # Check if the value is within the given range\n    if not (low <= num_value <= high):\n        return \"Error: Beyond range.\"\n\n    # Round according to the rules specified\n    decimal, integer = divmod(num_value, 1)\n\n    if decimal <= Decimal('0.5'):\n        return int(integer + 1)\n    elif decimal <= Decimal('-0.5'):\n        return int(integer - 1)\n    else:\n        return int(integer)"
      ],
      [
        0.9087346792221069,
        "def closest_integer(value):\n    \"\"\"\n    Find the closest integer to the given value.\n    \n    Args:\n        value (float): The value to find the closest integer to.\n    \n    Returns:\n        int: The closest integer to the given value.\n    \"\"\"\n    try:\n        num = float(value)\n        rounded = int(num)\n        if num - int(num) >= 0.5:\n            if num < 0:\n                rounded += 1\n            else:\n                rounded -= 1\n        if not is_prime(rounded):\n            rounded = closest_prime(rounded)\n        return rounded\n    except ValueError:\n        return \"Error: Invalid input.\""
      ],
      [
        0.9084100723266602,
        "def closest_integer(value):\n    \"\"\"\n    Find the closest integer to the given value.\n    \n    Args:\n        value (float): The value to find the closest integer to.\n    \n    Returns:\n        int: The closest integer to the given value.\n    \"\"\"\n    try:\n        num = float(value)\n        rounded = int(num)\n        if num - int(num) >= 0.5:\n            if num > 0:\n                rounded += 1\n            else:\n                rounded -= 1\n        if not is_prime(rounded):\n            rounded = closest_prime(rounded)\n        return rounded\n    except ValueError:\n        return \"Error: Invalid input.\""
      ]
    ],
    "HumanEval/100": [
      [
        0.9172462224960327,
        "def make_a_pile(n, pattern, offset=0):\n    \"\"\"\n    Make a pile of stones.\n    \n    :param n: number of stones\n    :param pattern: 'odd' or 'even'\n    :param offset: offset of the first stone\n    :return: list of stones\n    \"\"\"\n    stones = [n + offset]\n    for i in range(1, n):\n        if pattern == 'odd':\n            stones.append(stones[-1] + 2*i - 1)\n        elif pattern == 'even':\n            stones.append(stones[-1] + 2*i)\n    return stones"
      ],
      [
        0.914806067943573,
        "def make_a_pile(n, pattern, offset=0):\n    \"\"\"\n    Make a pile of stones.\n    \n    Parameters\n    ----------\n    n : int\n        The number of stones in the pile.\n    pattern : str\n        The pattern of the pile. Can be 'odd' or 'even'.\n    offset : int, optional\n        The offset of the pile. Only used if pattern is 'even'.\n    \n    Returns\n    -------\n    stones : list\n        The pile of stones.\n    \"\"\"\n    stones = [n]\n    for i in range(1, n): # Start the loop from 1 because the offset in the first round should be 1.\n        if pattern == 'odd':\n            stones.append(stones[-1] + 2*i+1)\n        elif pattern == 'even':\n            stones.append(stones[-1] + 2*i+offset) # offset added here\n    return stones"
      ],
      [
        0.9119410514831543,
        "def make_a_pile(n, pattern, offset=0):\n    \"\"\"\n    Make a pile of stones.\n    \n    Parameters\n    ----------\n    n : int\n        The number of stones in the pile.\n    pattern : str\n        The pattern of the pile. Can be 'odd' or 'even'.\n    offset : int, optional\n        The offset of the pile.\n    \n    Returns\n    -------\n    stones : list\n        The pile of stones.\n    \"\"\"\n    stones = [n]\n    for i in range(1, n):\n        if pattern == 'odd':\n            stones.append(n + 2*i + offset)\n        elif pattern == 'even':\n            stones.append(n + 2*i - 1 + offset)\n    return stones"
      ]
    ],
    "HumanEval/101": [
      [
        0.9142197370529175,
        "def split_words(s):\n    \"\"\"\n    Split a string into words.\n    \n    >>> split_words('Hello, world!')\n    ['Hello', 'world']\n    >>> split_words('Hello, world!')\n    ['Hello', 'world']\n    >>> split_words('Hello, world!')\n    ['Hello', 'world']\n    >>> split_words('Hello, world!')\n    ['Hello', 'world']\n    >>> split_words('Hello, world!')\n    ['Hello', 'world']\n    >>> split_words('Hello, world!')\n    ['Hello', 'world']\n    >>> split\"\"\"\n    return [word.strip() for word in re.split('[, !?]', s) if word]"
      ],
      [
        0.9071272611618042,
        "def string_to_words(s):\n    \"\"\"\n    Converts a string to a list of words.\n    \n    >>> string_to_words('Hello world!')\n    ['Hello', 'world!']\n    \"\"\"\n    return s.split(' ')"
      ]
    ],
    "HumanEval/102": [
      [
        0.9573804140090942,
        "def choose_num(x, y, z):\n    \"\"\"\n    This function accepts three positive integers x, y, and z, and its objective is to return the\n    greatest even integer within the inclusive range of [x, y] that can be evenly divided by z. In the\n    absence of such a number, the function should yield -1.\n\n    Example cases:\n    choose_num(12, 15, 2) = 14\n    choose_num(13, 12, 3) = -1\n    choose_num(10, 20, 4) = 20\n    \"\"\"\n\n    # Start checking from the largest number in the range [x, y]\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0 and num % z == 0:\n            return num\n    return -1"
      ],
      [
        0.9471434354782104,
        "def choose_num(x, y):\n    \"\"\"\n    Find the largest even number between x and y\n    :param x: int\n    :param y: int\n    :return: int\n    \"\"\"\n    maxEvenNumber = -1\n    if y >= x:\n        for i in range(x, y + 1):\n            if i % 2 == 0:\n                maxEvenNumber = i\n    return maxEvenNumber"
      ],
      [
        0.9317387938499451,
        "def choose_num(x, y, z):\n    \"\"\"This function should take three positive numbers x, y, and z. The function must return \n    the largest even integer number that is less than or equal to y and greater than or equal \n    to x, which is also a multiple of z. In case no such number exists, the function should return None.\n    \n    Validate your code with the added complexity of handling potential exceptions.\n    \"\"\"  \n    if not (type(x) == type(y) == type(z) == int):\n        return \"Error: Inputs must be integers.\"\n\n    if not (x >= 0 and y >= 0 and z >= 0):\n        return \"Error: Inputs must be positive.\"\n\n    if x > y:\n        return \"Error: x should be less than or equal to y.\"\n\n    #Initialize the largest number as None.\n    largest_num = None\n    \n    #Iterate from y to x both inclusive to find largest even multiple of z.\n    for i in range(y, x - 1, -1):\n        if i % z == 0 and i % 2 == 0:\n            largest_num = i\n            break\n        \n    #Return the largest number.\n    return largest_num"
      ],
      [
        0.9242070913314819,
        "def choose_num(x, y, z, n):\n    \"\"\"\n    Find the nth largest even number divisible by z in the range [x, y].\n\n    Args:\n        x (int): The start of the range.\n        y (int): The end of the range.\n        z (int): The divisor.\n        n (int): The index of the number to find.\n\n    Returns:\n        int: The nth largest even number divisible by z in the range [x, y].\n    \"\"\"\n    # Initialize an empty list to store the even numbers divisible by z\n    chosen_num_list = []\n\n    # If y is less than x, switch their values. This ensures x is the start of the range and y is the end.\n    if y < x:\n        x, y = y, x\n\n    # Scan every number in the range [x, y]\n    for num in range(x, y+1):\n        # If num is even and divisible by z, add it to the list\n        if num % 2 == 0 and num % z == 0:\n            chosen_num_list.append(num)\n\n    # Sort the list in descending order to get the nth largest number at index n-1\n    chosen_num_list.sort(reverse=True)\n\n    # If the length of the list is less than n (no nth largest number), return -1\n    if len(chosen_num_list) < n:\n        return -1\n    else:\n        return chosen_num_list[n-1]"
      ],
      [
        0.9213279485702515,
        "def choose_num(x, y, z, w, m):\n    \"\"\"\n    Find the mth number that is divisible by z and w, and is even, in the range x to y (inclusive)\n    :param x: The lower bound of the range\n    :param y: The upper bound of the range\n    :param z: The first divisor\n    :param w: The second divisor\n    :param m: The mth number to find\n    :return: The mth number that is divisible by z and w, and is even, in the range x to y (inclusive)\n    \"\"\"\n    # Create a list to store the found numbers\n    numbers_found = []\n\n    # Iterate over the range, from y down to x (inclusive), in steps of -1\n    for num in range(y, x-1, -1):\n        # Check whether the number is even, and whether it is divisible by z and w\n        if num % 2 == 0 and num % z == 0 and num % w == 0:\n            # If so, append the number to our list\n            numbers_found.append(num)\n\n            # If we have found m numbers, return the last one found\n            if len(numbers_found) == m:\n                return numbers_found[-1]\n\n    # If no number has been found or m is larger than the count of such numbers, return -1\n    return -1"
      ],
      [
        0.9164578914642334,
        "def superior_parallel_dividend(x, y, z):\n    \"\"\"Returns the largest even integer in the range [x, y] that is divisible by z or -1 if no such integer exists\"\"\"\n    \n    # The initial most paramount even integer would be the supremum value of the defined range.\n    # If y is even, it remains y. If y is odd, decrease it by one to get the highest even number\n    highest_even = y if y % 2 == 0 else y - 1\n    \n    # Iterate from the highest possible even number down to x and check each\n    for i in range(highest_even, x - 1, -2):\n        if i % z == 0:\n            return i\n            \n    # If no even and divisible number is found, return -1\n    return -1"
      ],
      [
        0.9131156802177429,
        "def find_maximum_even_divisible(x, y, z):\n    \"\"\"\n    Find the maximum even number divisible by z in the range [x, y].\n    If no such number exists, return -1.\n    :param x: The lower bound of the range.\n    :param y: The upper bound of the range.\n    :param z: The divisor.\n    :return: The maximum even number divisible by z in the range [x, y].\n    \"\"\"\n    for i in range(y, x-1, -1):\n        if i % 2 == 0 and i % z == 0:\n            return i\n    return -1"
      ],
      [
        0.9109955430030823,
        "def transcendent_even_quotient(x, y, z):\n    \"\"\"\n    Find the largest even number that is a multiple of z and is between x and y (inclusive).\n    \n    >>> transcendent_even_quotient(10, 20, 3)\n    18\n    >>> transcendent_even_quotient(10, 20, 4)\n    -1\n    >>> transcendent_even_quotient(10, 20, 5)\n    20\n    \"\"\"\n    for i in range(y, x - 1, -1):  \n        if i % z == 0 and i % 2 == 0: \n            return i  \n    return -1  "
      ]
    ],
    "HumanEval/103": [
      [
        0.9175417423248291,
        "def alternate_base_weighted_avg(n, m, base, alternate_fn):\n    \"\"\"\n    Given a range of numbers [n, m] and a base, return the weighted average of the numbers in the range.\n    The weight of a number is the number of numbers in the range that are divisible by the number.\n    The base is the base of the number system to be returned.\n    If the base is 10, return a string.\n    If the base is 2, return a binary string.\n    If the base is 8, return an octal string.\n    If the base is not valid, return -1.\n    If the range is invalid,\"\"\"\n    if n > m:\n        return -1\n    if base < 2 or base > 10:\n        return -1\n\n    total, total_weight = 0, 0\n    for i in range(n, m + 1):\n        weight_i, weight_end = alternate_fn(i, m)\n        total += i * weight_i\n        total_weight += weight_i\n\n    if total_weight == 0:\n        return format(0, '#'+str(base+1)+'b')\n\n    res = int(round(total / total_weight))\n    if base == 10:\n        return str(res)\n    elif base == 2:\n        return format(res, 'b')   \n    elif base == 8:\n        return format(res, 'o')   "
      ],
      [
        0.9168767333030701,
        "def alternate_base_weighted_avg(n, m, base, alternate_fn):\n    \"\"\"\n    \"\"\"\n    if n > m:\n        return -1\n    if base < 2 or base > 10:\n        return -1\n    \n    total, total_weight = 0, 0\n    for i in range(n, m + 1):\n        weight_i, weight_end = alternate_fn(i, m)\n        total += i * weight_i\n        total_weight += weight_i\n        \n    if total_weight == 0:\n        return format(0, '#'+str(base+1)+'b')\n        \n    res = int(round(total / total_weight))\n    if base == 10:\n        return str(res)\n    elif base == 2:\n        return format(res, '#0b')   \n    elif base == 8:\n        return format(res, '#0o')   "
      ],
      [
        0.9135559797286987,
        "def advanced_base_translation_avg(n, m, base):\n    \"\"\"\n    \"\"\"\n    if m < n or base < 2 or base > 10: \n        return -1\n    \n    avg = math.ceil(sum(range(n, m+1)) / (m-n+1))\n    \n    if base == 2:\n        return bin(avg)\n    elif base == 8:\n        return oct(avg)\n    elif base == 10:\n        return str(avg)\n    else:\n        return manual_base_conversion(avg, base)"
      ],
      [
        0.9133797287940979,
        "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the rounded average of a range of integers in a given base.\n    \n    Args:\n        n (int): The starting integer of the range.\n        m (int): The ending integer of the range.\n        base (int): The base to represent the average in.\n    \n    Returns:\n        str: The rounded average of the range in the given base.\n    \n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    total, count = 0, 0\n    for i in range(n, m+1):  # sequential integers from n to m (inclusive)\n        total += i  # accumulating the sums\n        count += 1  # count the number of integers\n    avg = round(total / count)  # approximated weighted average to the nearest integer\n    if base == 2:  # binary representation\n        return bin(avg)\n    elif base == 8:  # octal representation\n        return oct(avg)\n    elif base == 10:  # decimal representation\n        return str(avg)\n    else:  # other bases\n        return to_base_x(avg, base)"
      ],
      [
        0.9129456281661987,
        "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Find the average of all numbers between n and m (inclusive)\n    that have an equal number of divisors in binary, octal and decimal\n    representation.\n    If there is no such number, return -1.\n    If there are multiple such numbers, return the smallest one.\n    \n    n, m, base: positive integers\n    return: a positive integer\n    \"\"\"\n    if n > m or base < 2 or base > 10:\n        return -1\n    total, weight_sum = 0, 0\n    for num in range(n, m+1):\n        weight = count_divisors(num)\n        total += num * weight\n        weight_sum += weight\n    avg = round(total / weight_sum)\n    if base == 2:\n        return bin(avg)\n    elif base == 8:\n        return oct(avg)\n    elif base == 10:\n        return avg\n    else:\n        return int(str(avg), base)"
      ]
    ],
    "HumanEval/104": [
      [
        0.9427266120910645,
        "def odd_sum_elements(x):\n    \"\"\"Given a list of positive integers x, return a sorted list of all \n    _unique_ elements where the sum of their digits is an odd number.\n\n    Note: The returned list should be sorted in ascending order. \n\n    >>> odd_sum_elements([15, 33, 1422, 1, 15])\n    [1, 15]\n    >>> odd_sum_elements([152, 323, 1422, 10])\n    [323]\n\n    \"\"\"\n    odd_sum_digits = []\n    for i in set(x):\n        if sum(int(digit) for digit in str(i)) % 2 != 0:\n            odd_sum_digits.append(i)\n    return sorted(odd_sum_digits)"
      ],
      [
        0.9351738691329956,
        "def unique_odd_digit_sum(x):\n    \"\"\"Given a list of integers x, return a sorted list of unique positive integers that have an odd sum of their digits. The same integer should not appear twice.  \n\n    Sort the final output list in ascending order. \n\n    E.g.:\n    >>> unique_odd_digit_sum([15, 38, 1420, 1, 15])\n    [1]\n    >>> unique_odd_digit_sum([154, 323, 1422, 10])\n    [323]\n    >>> unique_odd_digit_sum([-15, 38, -1420, -1, 15])\n    [15]\n    \"\"\"\n\n    # Create an empty list to store the resulting integers\n    result = []\n\n    # Loop over the input list x\n    for num in x:\n        # Exclude negative numbers\n        if num < 0:\n            continue\n\n        # Calculate the sum of the digits of num\n        digit_sum = sum(int(digit) for digit in str(num))\n\n        # Exclude integers with an even sum of digits\n        if digit_sum % 2 == 0:\n            continue\n\n        # Exclude integers that are already in the result list\n        if num in result:\n            continue\n\n        # Add the integer to the result list\n        result.append(num)\n        \n    return sorted(result)"
      ],
      [
        0.9345634579658508,
        "def unique_odd_sum_elements(x):\n    \"\"\"\n    Supplied with a list of positive integers x, return a sorted list of unique elements that have an odd digit sum and\n    do not occur multiple times in the input list.\n\n    The final list should be sorted in ascending order.\n\n    E.g.:\n    >>> unique_odd_sum_elements([15, 38, 1420, 1, 15])\n    [1]\n    >>> unique_odd_sum_elements([154, 323, 1422, 10])\n    [323]\n    \"\"\"\n\n    # Initiate an empty list\n    unique_list = []\n\n    # Go through each element in list x\n    for ele in x:\n\n        # If element is not yet in unique_list\n        if ele not in unique_list:\n\n            # Calculate the sum of digits of the element\n            digit_sum = sum(int(digit) for digit in str(ele))\n\n            # if the sum of digits is odd, append to the unique_list\n            if digit_sum % 2 == 1:\n                unique_list.append(ele)\n        \n    # Return the sorted list\n    return sorted(unique_list)"
      ],
      [
        0.9345054030418396,
        "def unique_odd_digit_sum(x):\n    \"\"\"\n    Given a list of integers x, return a sorted list of unique positive integers\n    that have an odd sum of their digits. The same integer should not appear twice.\n    Sort the final output list in ascending order.\n\n    E.g.:\n    >>< unique_odd_digit_sum([15, 38, 1420, 1, 15])\n    [1]\n    >>< unique_odd_digit_sum([154, 323, 122, 10])\n    [323]\n    >>< unique_odd_digit_sum([-15, 38, 1420, -1, 15])\n    [15]\n    \"\"\"\n    \n    # Create an empty list to store the resulting integers\n    result = []\n\n    # Loop over the input list\n    for num in x:\n        # Exclude negative numbers\n        if num < 0:\n            continue\n\n        # Calculate the sum of the digits of num\n        digit_sum = sum(int(digit) for digit in str(num))\n\n        # Exclude integers with an even sum of digits\n        if digit_sum % 2 == 0:\n            continue\n\n        # Exclude integers that are already in the result list\n        if num in result:\n            continue\n\n        # Add the integer to the result list\n        result.append(num)\n\n    return sorted(result)"
      ],
      [
        0.9326989650726318,
        "def odd_sum_elements(x):\n    \"\"\"\n    Accepts a list of positive numbers (x), returning a sorted list comprising unique elements, the sum of whose digits equals an odd number.\n\n    Note: The output list must be sorted in increasing order.\n\n    >>> odd_sum_elements([15, 33, 1422, 1, 15])\n    [1, 15]\n    >>> odd_sum_elements([152, 323, 1422, 10])\n    [323]\n\n    \"\"\"\n    unique_nums = set(x)  # create a set from the list to remove duplicates\n    odd_digits_sum_nums = [num for num in unique_nums if sum(int(digit) for digit in str(num)) % 2 != 0]\n    return sorted(odd_digits_sum_nums)  # return the sorted list"
      ],
      [
        0.9182683229446411,
        "def unique_odd_sum_elements(x):\n    \"\"\"\n    Given a list of numbers, return a list of all the unique numbers that have an odd sum of digits.\n    \n    Args:\n        x (list): List of numbers\n    \n    Returns:\n        list: List of unique numbers with odd sum of digits\n    \"\"\"\n    x = list(set(x))  # Remove duplicates\n    result = []\n    \n    for num in x:\n        if sum(int(digit) for digit in str(num)) % 2 != 0:  # Check if sum of digits is odd\n            result.append(num)\n    \n    result.sort()\n    return result"
      ]
    ],
    "HumanEval/105": [
      [
        0.9558837413787842,
        "def by_length(arr):\n    \"\"\"\n    Return an array of words of numbers in descending order of length.\n    \n    >>> by_length([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    ['Three', 'Nine', 'Eight', 'Seven', 'Six', 'Five', 'Four', 'Two', 'One']\n    \"\"\"\n    num2words = {1: 'One', 2: 'Two', 3: 'Three', 4: 'Four', 5: 'Five', 6: 'Six', 7: 'Seven', 8: 'Eight', 9: 'Nine'}\n    \n    # filter for elements of arr that are in the range 1 to 9, then sort and reverse \n    valid_nums = sorted([n for n in arr if 1 <= n <= 9], reverse=True)  \n\n    # convert to words using num2words dictionary and return\n    return [num2words[n] for n in valid_nums]"
      ],
      [
        0.9084795117378235,
        "def rank_by_size(arr):\n    \"\"\"\n    Given an array of integers, return an array where the first element is the largest value, the second element is the second largest value, etc.\n    \n    For example:\n    \n    rank_by_size([4, 1, 2, 3, 5]) == [5, 4, 3, 2, 1]\n    \n    rank_by_size([1, 2, 3, 4, 5]) == [5, 4, 3, 2, 1]\n    \n    rank_by_size([\"\"\"\n    ranked = []\n \n    while len(arr) > 0:\n        max_val = arr[0]\n \n        for item in arr:\n            if item > max_val:\n                max_val = item\n \n        arr.remove(max_val)\n        ranked.append(max_val)\n \n    return ranked"
      ],
      [
        0.9054229855537415,
        "def sort_strings_by_length_descending(arr):\n    \"\"\"\n    Sort an array of strings by their length in descending order.\n    \"\"\"\n    arr.sort(key=len, reverse=True)\n    return arr\n    \n    def filter_strings_with_length_greater_than_or_equal_to_three(arr):\n    \"\"\"\n    Filter an array of strings to only include those with a length greater than or equal to 3.\n    \"\"\"\n    new_arr = []\n    for string in arr:\n        if len(string) >= 3:\n            new_arr.append(string)\n    new_arr.sort(key=len, reverse=True)\n    return new_arr"
      ],
      [
        0.9051462411880493,
        "def sort_by_length(arr): \n    \"\"\"\n    Sort an array of strings by their length.\n    \n    >>> sort_by_length(['a', 'ccc', 'dddd', 'bb'])\n    ['a', 'bb', 'ccc', 'dddd']\n    \"\"\"\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if len(arr[i]) < len(arr[j]): \n                arr[i], arr[j] = arr[j], arr[i] \n    return arr"
      ],
      [
        0.90513014793396,
        "def sortByLength(arr):\n    \"\"\"\n    \"\"\"\n    # create a new array \n    # and store the length of each string in it\n    lengths = [] \n    for item in arr:\n        lengths.append(len(item))\n\n    # sort the length array\n    lengths.sort()\n\n    # initialise output arr\n    out_arr = []\n\n    # run loop to match the length\n    # with the actual string\n    for l in lengths:\n        for item in arr:\n            if len(item) == l:\n                out_arr.append(item)\n                arr.remove(item)\n\n    return out_arr"
      ]
    ],
    "HumanEval/106": [
      [
        0.9620736837387085,
        "def f(n):\n    \"\"\"\n    Return a list of n numbers, where the ith element is the factorial of i if i is even, and the cumulative sum of the first i natural numbers otherwise.\n    \n    >>> f(5)\n    [1, 1, 2, 6, 15]\n    >>> f(10)\n    [1, 1, 2, 6, 15, 45, 135, 405, 1093, 3003]\n    \"\"\"\n    resultList = [0] * n\n    for i in range(n):\n        if i % 2 == 0:\n            resultList[i] = factorial(i)\n        else:\n            resultList[i] = cumulative_sum(i)\n    return resultList"
      ],
      [
        0.9457387924194336,
        "def f(n):\n  \"\"\"\n  This function takes in a number n and returns a list of the results of calling the factorial function on even numbers and the sumOfSquare function on odd numbers from 1 to n.\n  \n  Args:\n    n (int): The number to iterate up to.\n  \n  Returns:\n    list: A list of the results of calling the factorial function on even numbers and the sumOfSquare function on odd numbers from 1 to n.\n  \"\"\"\n  # Initialize an empty list\n  result_list = []\n  # Use a for loop that starts at 1 and ends at n\n  for i in range(1, n+1):\n    # Use a conditional statement to check if the number is even\n    if i % 2 == 0:\n      # If the number is even, call the factorial function and append the result to the list\n      result_list.append(factorial(i))\n    else:\n      # If the number is odd, call the sumOfSquare function and append the result to the list\n      result_list.append(sumOfSquare(i))\n  return result_list"
      ],
      [
        0.9354779720306396,
        "def F(n):\n    \"\"\"\n    >>> F(5)\n    [1, 1, 3, 6, 24]\n    >>> F(10)\n    [1, 1, 3, 6, 24, 120, 720, 5040, 40320, 362880]\n    \"\"\"\n    result = []\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            result.append(sum(range(i+1)))\n        else:\n            result.append(math.factorial(i))\n    return result"
      ],
      [
        0.9354520440101624,
        "def F(n):\n    \"\"\"\n    >>> F(5)\n    [1, 1, 3, 6, 24]\n    >>> F(10)\n    [1, 1, 3, 6, 24, 120, 720, 5040, 40320, 362880]\n    \"\"\"\n    result = []\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            result.append(sum(range(i+1)))\n        else:\n            result.append(math.factorial(i))\n    return result"
      ],
      [
        0.9304181337356567,
        "def f(n):\n    \"\"\"\n    \"\"\"\n    result = [1] * n\n    even_val = 1\n    odd_val = 1\n    for i in range(2, n+1):\n        if i % 2 == 0:\n            even_val *= i\n            result[i-1] = even_val\n        else:\n            odd_val += i\n            result[i-1] = odd_val\n    return result"
      ]
    ],
    "HumanEval/107": [
      [
        0.9247626662254333,
        "def even_odd_count(num):\n    \"\"\"\n    Return a tuple (even_count, odd_count) indicating the counts of each type of number in a non-negative integer.\n    \n    >>> even_odd_count(123456789)\n    (4, 5)\n    >>> even_odd_count(24680)\n    (5, 0)\n    >>> even_odd_count(-11)\n    (0, 2)\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    num = abs(num)  # absolute value to ignore negative sign\n    for digit in str(num):\n        if digit != '0':\n            if int(digit) % 2 == 0: \n                even_count += 1\n            else:\n                odd_count += 1\n        else:\n            even_count += 1  # counting 0 as even\n    return even_count, odd_count"
      ],
      [
        0.9194448590278625,
        "def even_odd_count(num):\n    \"\"\"Return number of even digits and odd digits in given integer.\n    >>> even_odd_count(123456789)\n    (4, 5)\n    >>> even_odd_count(-1111111)\n    (0, 7)\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return even_count, odd_count"
      ],
      [
        0.9194353222846985,
        "def even_odd_count(num):\n    \"\"\"Return number of even digits and odd digits in given integer.\n    >>> even_odd_count(123456789)\n    (4, 5)\n    >>> even_odd_count(-1111111)\n    (0, 7)\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return even_count, odd_count"
      ],
      [
        0.9194282293319702,
        "def even_odd_count(num):\n    \"\"\"Return number of even digits and odd digits in given integer.\n    >>> even_odd_count(123456789)\n    (4, 5)\n    >>> even_odd_count(-1111111)\n    (0, 7)\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return even_count, odd_count"
      ],
      [
        0.915930986404419,
        "def even_odd_count(num):\n    \"\"\"\n    Return a tuple, (count_even, count_odd),\n    where count_even is the number of even digits in the given number\n    and count_odd is the number of odd digits in the given number.\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    even_sum = 0\n    odd_sum = 0\n    for digit in str(abs(num)):\n        if int(digit) % 2 == 0:\n            even_count += 1\n            even_sum += int(digit)\n        else:\n            odd_count += 1\n            odd_sum += int(digit)\n    return (even_count, odd_count), (even_sum, odd_sum)"
      ],
      [
        0.9153562784194946,
        "def even_odd_count(num):\n    \"\"\"\n    Return a tuple containing the count of even digits and the count of odd digits in a given number.\n    \n    Args:\n        num (int): The input number.\n    \n    Returns:\n        tuple: A tuple containing the count of even digits and the count of odd digits.\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):  # Converting the input to a positive string number\n        if int(digit) % 2 == 0:  # Checking if the digit is even\n            even_count += 1      # If even, increment the even_count\n        else:\n            odd_count += 1       # If odd, increment the odd_count\n    return (even_count, odd_count) # Return the counts as a tuple"
      ],
      [
        0.9145719408988953,
        "def even_odd_count(num):\n    \"\"\"\n    Return a tuple containing the count of even digits and the count of odd digits in a given number.\n    \n    Args:\n        num (int): The number to analyze.\n    \n    Returns:\n        tuple: A tuple containing the count of even digits and the count of odd digits.\n    \n    Example:\n        >>> even_odd_count(123456789)\n        (4, 5)\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)): #Use absolute value to handle negative numbers correctly\n        if digit.isdigit():     #This will ensure the digit is numeric (and thus skipp \"-\" sign)\n            if int(digit) % 2 == 0: #Considering '0' as even\n                even_count += 1\n            else:\n                odd_count += 1\n    return even_count, odd_count"
      ],
      [
        0.911032497882843,
        "def even_odd_count(num):\n    \"\"\"Return a tuple in the form (even_count, odd_count) from a list of numbers.\n    \n    >>> even_odd_count([2, 1, 4, 6, 9, 11])\n    (3, 3)\n    \"\"\"\n    num = int(num) #Convert to integer in case input is binary, any other base\n    num_str = str(num)    \n    if num_str[0] == \"-\": # handle negative numbers\n        num_str = num_str[1:]\n    elif num_str[0] == \"0\" and len(num_str)>1: # handle leading zeros\n        num_str = num_str.lstrip('0')\n     \n    even_count = 0\n    odd_count = 0\n    for digit in num_str:\n        if int(digit) % 2 == 0: \n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)"
      ],
      [
        0.9104294776916504,
        "def even_odd_count(num):\n    \"\"\"\n    Given a number n, find the count of even digits and odd digits\n    \"\"\"\n    even_count, odd_count = [], []\n    i = 0\n    while i < len(str(abs(num))):\n        count = 1\n        while i + 1 < len(str(abs(num))) and str(abs(num))[i] == str(abs(num))[i + 1]:\n            i += 1\n            count += 1\n        if int(str(abs(num))[i]) % 2 == 0:\n            \"\"\"\n    num = str(abs(num))  # Convert to string and remove negative sign if present\n    even_count, odd_count = [], []\n    i = 0\n    while i < len(num):\n        count = 1\n        while i + 1 < len(num) and num[i] == num[i + 1]:\n            i += 1\n            count += 1\n        if int(num[i]) % 2 == 0:\n            even_count.append(count)\n        else:\n            odd_count.append(count)\n        i += 1\n    return even_count, odd_count"
      ]
    ],
    "HumanEval/108": [
      [
        0.940617561340332,
        "def count_positive_nums(arr):\n    \"\"\"\n    Return the count of numbers greater than zero in the list.\n    \n    >>> count_positive_nums([1, 2, 3, -4, 5])\n    4\n    \"\"\"\n    return sum(1 for num in arr if num > 0)"
      ],
      [
        0.9369420409202576,
        "def count_nums(arr):\n    \"\"\"\n    Return the number of positive integers in the array that have a sum of their digits that is a multiple of 4.\n    \n    >>> count_nums([16, 17, 18])\n    2\n    >>> count_nums([16, 17, 18, 19, 20])\n    3\n    >>> count_nums([100, 200, 300])\n    0\n    >>> count_nums([13, 14, 15, 16])\n    0\n\"\"\"\n    count = 0\n    for number in arr:\n        digits = map(int, str(abs(number)))\n        digit_sum = sum(digits)\n\n        # consider the leading digit negative if the number itself is negative\n        if number < 0:\n            digit_sum -= 2 * digits[0]\n\n        # check if the sum is both greater than zero and a multiple of 4\n        if digit_sum > 0 and digit_sum % 4 == 0:\n            count += 1\n    return count"
      ],
      [
        0.9256314635276794,
        "def count_nums(arr):\n    \"\"\"\n    Return the number of numbers in the given array that are divisible by 4.\n    \n    >>> count_nums([1, 2, 3, 4])\n    1\n    >>> count_nums([1, 2, 3, 4, 5, 6])\n    2\n    \"\"\"\n    count = 0\n    for num in arr:\n        if sum(int(i) for i in str(abs(num))) % 4 == 0:\n            count += 1\n    return count"
      ],
      [
        0.9255802631378174,
        "def count_positive(arr):\n    \"\"\"\n    Return the number of positive numbers in an array\n    \"\"\"\n    count = 0\n    for i in arr:\n        if i > 0:\n            count += 1\n    return count\n    def count_positive(arr):\n    \"\"\"\n    Return the number of positive numbers in an array\n    \"\"\"\n    count = 0\n    for i in arr:\n        if i > 0:\n            count += 1\n    return count"
      ],
      [
        0.9221453070640564,
        "def count_nums(arr):\n    \"\"\"\n    Return the number of numbers in the given array that satisfy the following conditions:\n    \n    The number has at least one digit with a value of 4.\n    The number has at least one digit with a value of 7.\n    The sum of the number's digits is divisible by 4.\n    \n    >>> count_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1\"\"\"\n    return sum(1 for num in arr if sum(int(d) for d in str(abs(num))) > 0 and sum(int(d) for d in str(abs(num))) % 4 == 0)"
      ],
      [
        0.9213320016860962,
        "def count_nums(nums):\n    \"\"\"\n    Given a list of numbers, return the number of numbers in the list that have an even number of digits.\n    \"\"\"\n    count = 0\n    for num in nums:\n        digits = [int(d) for d in str(abs(num))]\n        if num < 0:\n            digits[0] *= -1\n\n        if len(digits) % 2 == 0:\n            count += 1\n\n    return count\n    def count_nums(nums):\n    \"\"\"\n    Given a list of numbers, return the number of numbers in the list that\"\"\"\n    count = 0\n    for num in nums:\n        digits = [int(d) for d in str(abs(num))]\n        if num < 0:\n            digits[0] *= -1\n\n        if sum(digits) % 4 == 0 and sum(digits) > 0:\n            count += 1\n\n    return count"
      ],
      [
        0.9188624024391174,
        "def sum_of_positive_integers(arr):\n    \"\"\"\n    Return the sum of all positive integers in the array.\n    \n    >>> sum_of_positive_integers([1, 2, 3, -4, 5])\n    15\n    >>> sum_of_positive_integers([1, -2, 3, -4, 5])\n    9\n    >>> sum_of_positive_integers([-1, 2, -3, 4, -5])\n    6\n    \"\"\"\n    sum = 0\n    for num in arr:\n        if num > 0:\n            sum += num\n    return sum"
      ],
      [
        0.9160480499267578,
        "def count_nums_plus(arr):\n    \"\"\"Count the number of positive numbers in an array.\n    >>> count_nums_plus([1, 2, 3, 4, 5])\n    5\n    >>> count_nums_plus([1, 2, 3, -4, 5])\n    5\n    >>> count_nums_plus([1, 2, 3, -4, -5])\n    4\n    >>> count_nums_plus([1, 2, 3, -4, -5, 0])\n    5\n    >>> count_nums_plus([1,\"\"\"\n    count = 0\n    for element in arr:\n        try:\n            num = int(element)\n            if num < 0:\n                num *= -1\n            if num > 0 and (num % 4 == 0 or num % 5 == 0):\n                count += 1\n        except ValueError:\n            continue\n    return count"
      ],
      [
        0.9148925542831421,
        "def sum_positive_elements(arr):\n    \"\"\"\n    Return the sum of all positive elements in the array.\n    \n    >>> sum_positive_elements([1, -2, 3, -4, 5])\n    9\n    >>> sum_positive_elements([-1, -2, -3, -4, -5])\n    0\n    \"\"\"\n    # Initialize a variable to hold the sum\n    total = 0\n    \n    # Iterate through the array\n    for num in arr:\n        # Check if the number is positive\n        if num >= 0:\n            # Add the positive number to the sum\n            total += num\n    \n    # Return the sum of positive elements\n    return total"
      ]
    ],
    "HumanEval/109": [
      [
        0.9348968863487244,
        "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n    1. Perform rightward shifting operation as required.\n    2. Swap at most three pair of balls.\n    3. After the operations, elements smaller than the first element in the array should be odd in number.\n    \n    Return True, if the array could be sorted; otherwise, False. \n    \n    Examples:\n    move_three_balls([5, 4, 5, 1, 2, 6]) -> True\n    move_three_balls([1, 3, 5, 4, 2, 6]) -> True\n    move_three_balls([1, 2, 3, 5, 4, 6]) -> True\n    move_three_balls([5, 4, 3, 1, 2, 6]) -> False\n    \"\"\"\n    \n    if not arr:\n        return True\n    \n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False"
      ],
      [
        0.9343209862709045,
        "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n        1. Perform rightward shifting operation as required.\n        2. Swap at most three pair of balls.\n        3. After the operations, elements smaller than the first element in the array should be odd in number.\n\n    Return True, if the array could be sorted, otherwise False. \n\n    Examples:\n    move_three_balls([3, 4, 5, 1, 2, 6]) => True\n    move_three_balls([1, 3, 5, 4, 2, 6]) => True\n    move_three_balls([1, 2, 3, 5, 4, 6]) => True\n    move_three_balls([5, 4, 3, 1, 2, 6]) => False\n\n    \"\"\"\n    if not arr:\n        return True\n\n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False"
      ],
      [
        0.9294252991676331,
        "def shiftOneNumber(arr):\n    \"\"\"\n    Given an array of integers, return true if one of the elements can be shifted to another position so that the array is sorted.\n    For example, for the array [3, 5, 0, 2, 4, 1], you should return true because if you shift 0 to index 2, the resulting array would be sorted.\n    \"\"\"\n    for i in range(len(arr)):\n        new_arr = arr[i:]+arr[:i]\n        if is_sorted(new_arr):\n            return True\n    return False\n    \n    \"\"\"\n    if len(arr) == 0:\n        return True\n    for j in range(len(arr)):\n        new_arr = arr[j:]+arr[:j]\n        if is_sorted(new_arr):\n            return True\n    return False"
      ],
      [
        0.907691478729248,
        "def move_three_balls(arr):\n    \"\"\"\n    \"\"\"\n    if len(arr) == 0:\n        return True\n    \n    swaps = [0]*len(arr)\n    temp = arr.copy()\n    temp.sort()\n    for i in range(len(arr)):\n        if arr[i] != temp[i]:\n            swaps[i] = 1\n\n    if sum(swaps) > 6:\n        return False\n    \n    for i in range(0, len(arr), 2):\n        if arr[i] % 2 != 0:\n            for j in range(1, len(arr), 2):\n               if arr[j] % 2 == 0:\n                   arr[i], arr[j] = arr[j], arr[i]\n                   break\n\n    odd_count = len([x for x in arr if x < arr[0]])\n    if odd_count % 2 == 0:\n        for i in range(1, len(arr)):\n            if arr[i] > arr[0]:\n                arr[0], arr[i] = arr[i], arr[0]\n                break\n\n    return arr == sorted(arr)"
      ],
      [
        0.9068872332572937,
        "def move_two_balls(arr):\n    \"\"\"\n    \"\"\"\n    if len(arr) == 0:\n        return True\n\n    sorted_arr = sorted(arr)\n    arr_len = len(arr)\n    cnt = 0\n\n    for i in range(arr_len):\n        if arr[i] != sorted_arr[i]:\n            cnt += 1\n\n    if cnt == 0:\n        return check_even_small(arr[0], arr[1:])\n    elif cnt == 2 or cnt == 4:\n        return True\n    else:\n        return False"
      ],
      [
        0.904863715171814,
        "def shift_one_number(arr):\n    \"\"\"\n    Given an array of integers, return true if the array contains an odd number of even numbers.\n    \"\"\"\n    if len(arr) == 0:\n        return True\n\n    for _ in range(len(arr)):\n        odd_count = 0\n        even_count = 0\n\n        for num in arr:\n            if num % 2 == 1:\n                odd_count += 1\n            if odd_count > 0 and num % 2 == 0:\n                even_count += 1\n\n        if even_count == len(arr\"\"\"\n    if len(arr) == 0:\n        return True\n\n    for _ in range(len(arr)):\n        odd_count = 0\n        even_count = 0\n\n        for num in arr:\n            if num % 2 == 1:\n                odd_count += 1\n            if odd_count > 0 and num % 2 == 0:\n                even_count += 1\n\n        if even_count == len(arr) - odd_count:\n            return True\n\n        arr.append(arr.pop(0))\n\n    return False"
      ],
      [
        0.9031000137329102,
        "def countShifts(arr):\n    \"\"\"\n    Given an array of integers arr, return the number of shifts needed to make it sorted.\n    An array arr is sorted if and only if arr[i] <= arr[i + 1] holds for every i (0-indexed).\n    We define a shift as moving the first element of an array to the end.\n    For example, [1, 2, 3] shifted once is [2, 3, 1].\n    Example 1:\n    Input: arr = [3,4,5,1,2]\n    Output: 1\n    Explanation\"\"\"\n    if len(arr) == 0:\n        return 0\n    for j in range(len(arr)):\n        new_arr = arr[j:]+arr[:j]\n        if is_sorted(new_arr):\n            return j\n    return -1"
      ],
      [
        0.9029335379600525,
        "def rearrange_three_elements(arr):\n    \"\"\"\n    Given an array of integers, rearrange the array such that the first element is the smallest,\n    the second element is the largest, the third element is the second smallest, the fourth\n    element is the second largest, and so on.\n\n    If the array has an odd number of elements, the middle element is not moved.\n\n    Return true if the array can be rearranged to match these criteria, otherwise return false.\n\n    Example 1:\n    Input: arr = [1, 2, 3]\n    Output: true\n    Explanation: The array can be rearranged as [1,\"\"\"\n    if len(arr) == 0:\n        return True\n\n    arr_sorted = sorted(arr)\n    arr_first = arr[0]\n    counts = arr_sorted.count(arr_first)\n\n    lesser_elements = [y for y in arr_sorted if y < arr_first]\n\n    if len(lesser_elements) % 2 == 0:\n        if counts > 1:\n            idx = arr.index(arr_first, 1)\n            lesser_elements.append(arr_first)\n            arr[idx] = lesser_elements[0]\n            arr_sorted = sorted(arr)\n        else:\n            return False\n\n    swap_counts = sum(a != b for a, b in zip(arr, arr_sorted))\n\n    return swap_counts // 2 <= 3"
      ]
    ],
    "HumanEval/110": [
      [
        0.9631885290145874,
        "def exchange(lst1, lst2):\n    \"\"\"\n    Given two lists of integers, determine if it's possible to make the first list of even numbers by swapping elements between the two lists.\n    :param lst1: list of integers\n    :param lst2: list of integers\n    :return: \"YES\" or \"NO\"\n    \"\"\"\n    # Check if total sum of lst1 and lst2 are both even numbers.\n    # If not, return \"NO\" directly because even number of swaps can't make uneven sum to be even.\n    if sum(lst1) % 2 != 0 or sum(lst2) % 2 != 0:\n        return \"No\"\n\n    # If the sum of both lists are even, then check if it's possible to make lst1 to be a list of even numbers.\n    # If an odd number in lst1 is found, then try to find an even number in lst2 to swap. If not found, return \"NO\" directly.\n    for i in range(len(lst1)):\n        if lst1[i] % 2 != 0:\n            has_swap = False\n            for j in range(len(lst2)):\n                if lst2[j] % 2 == 0:\n                    # Swap found, exchange the elements and break the loop.\n                    lst1[i], lst2[j] = lst2[j], lst1[i]\n                    has_swap = True\n                    break\n            if not has_swap:\n                return \"NO\"\n\n    # If all odd numbers in lst1 can find matched even numbers in lst2 to swap, return \"YES\".\n    return \"YES\""
      ],
      [
        0.9627652764320374,
        "def exchange(lst1, lst2):\n    \"\"\"Swaps elements between two lists to make first list contain only even numbers.\"\"\"\n\n    # create even and odd lists\n    lst1_even = [i for i in lst1 if i % 2 == 0]\n    lst1_odd = [i for i in lst1 if i % 2 != 0]\n    lst2_even = [i for i in lst2 if i % 2 == 0]\n    lst2_odd = [i for i in lst2 if i % 2 != 0]\n\n    # if there are more odd numbers in the first list than even numbers in the second,\n    # or the sum of the odd numbers in the first list and the even numbers in the second\n    # is less than the sum of the even numbers in the first list and odd numbers in the second,\n    # then it is impossible to make the first list contain only even numbers\n    if len(lst1_odd) > len(lst2_even) or sum(lst1_odd) + sum(lst2_even) < sum(lst1_even) + sum(lst2_odd):\n        return 'NO'\n\n    # else, return 'YES'\n    return 'YES'"
      ],
      [
        0.9627084136009216,
        "def exchange(lst1, lst2):\n    \"\"\"Swaps elements between two lists to make first list contain only even numbers.\"\"\"\n    \n    #create even and odd lists\n    lst1_even = [i for i in lst1 if i % 2 == 0]\n    lst1_odd = [i for i in lst1 if i % 2 != 0]\n    lst2_even = [i for i in lst2 if i % 2 == 0]\n    lst2_odd = [i for i in lst2 if i % 2 != 0]\n\n    #if there are more odd numbers in the first list than even numbers in the second,\n    # or the sum of the odd numbers in the first list and the even numbers in the second\n    # is less than the sum of the even numbers in the first list and odd numbers in the second,\n    # then it is impossible to make the first list contain only even numbers\n    if len(lst1_odd) > len(lst2_even) or sum(lst1_odd) + sum(lst2_even) < sum(lst1_even) + sum(lst2_odd):\n        return 'NO'\n\n    #else, return 'YES'\n    return 'YES'"
      ],
      [
        0.9556036591529846,
        "def exchange(lst1, lst2):\n    \"\"\"\n    Given two arrays of integers, determine whether one array can be obtained from another by swapping at most one pair of elements.\n    \n    Example\n    \n    For a = [1, 2, 3, 2, 6, 2, 8] and b = [2, 3, 2, 5, 6, 2, 8], the output should be\n    exchange(a, b) = true.\n    \n    We can obtain b from a by swapping 1 with any other number.\n    \n    For a = [1, \"\"\"\n    if (sum(lst1) + sum(lst2)) % 2 != 0:\n        return \"NO\"\n        \n    odd_lst1 = [x for x in lst1 if x % 2 != 0]\n    even_lst2 = [x for x in lst2 if x % 2 == 0]\n    if len(odd_lst1) > len(even_lst2):\n        return \"NO\"\n    \n    return \"YES\""
      ],
      [
        0.9547934532165527,
        "def exchange(lst1, lst2):\n    \"\"\"\n    Given two lists of integers, determine if the sum of the odd numbers in the first list is equal to the sum of the even numbers in the second list.\n    \n    Parameters\n    ----------\n    lst1 : list\n        The first list of integers.\n    lst2 : list\n        The second list of integers.\n        \n    Returns\n    -------\n    str\n        \"YES\" if the sum of the odd numbers in the first list is equal to the sum of the even numbers in the second list, otherwise \"NO\".\n    \"\"\"\n    odd1 = sum(1 for num in lst1 if num % 2 != 0)\n    even2 = sum(1 for num in lst2 if num % 2 == 0)\n        \n    return \"YES\" if odd1 == even2 else \"NO\""
      ],
      [
        0.9503123760223389,
        "def exchange(lst1, lst2):\n    \"\"\"\n    :param lst1: list of integers\n    :param lst2: list of integers\n    :return: string\n    \"\"\"\n    lst1.sort()\n    lst2.sort()\n    for i in range(len(lst1)):\n        if lst1[i] % 2 == 1:\n            for j in range(len(lst2)):\n                if lst2[j] % 2 == 0:\n                    lst1[i], lst2[j] = lst2[j], lst1[i]\n    for i in range(len(lst1)):\n        if lst1[i] % 2 == 1:\n            return \"NO\"\n    return \"YES\""
      ],
      [
        0.9495387077331543,
        "def exchange(lst1, lst2):\n    \"\"\"\n    >>> exchange([1, 2, 3], [3, 2, 1])\n    'YES'\n    >>> exchange([1, 2, 3], [3, 2, 2])\n    'NO'\n    \"\"\"\n    s1, s2 = sum(lst1), sum(lst2)\n    for i in lst1:\n        for j in lst2:\n            new_s1, new_s2 = s1 - i + j, s2 - j + i\n            if new_s1 % 2 == 0 and new_s2 % 2 == 0:\n                return 'YES'\n    return 'NO'"
      ],
      [
        0.9364084005355835,
        "def transposition(lst1, lst2):\n    \"\"\"\n    Given two lists of integers lst1 and lst2, determine if it is possible to make lst1 consists of only even numbers while keeping the sum of lst1 and lst2 constant.\n    \n    Args:\n        lst1 (list): A list of integers.\n        lst2 (list): A list of integers.\n        \n    Returns:\n        str: \"YES\" if it is possible to make lst1 consists of only even numbers while keeping the sum of lst1 and lst2 constant, otherwise \"NO\".\n    \"\"\"\n    # Calculate initial sum of all in lst1 and lst2\n    sum1, sum2 = sum(lst1), sum(lst2)\n    \n    # Calculate sum of evens in lst1 and lst2\n    even_sum1, even_sum2 = sum(i for i in lst1 if i % 2 == 0), sum(i for i in lst2 if i % 2 == 0)\n\n    # Calculate sum of odd numbers in lst1 and lst2\n    odd_sum1, odd_sum2 = sum1 - even_sum1, sum2 - even_sum2\n    \n    # Check if it is impossible to make lst1 consists of only even numbers while keeping the sum of lst1 and lst2 constant.\n    if abs(odd_sum1 - odd_sum2) % 2 != 0:\n        return \"NO\"\n        \n    # Otherwise, return \"YES\"\n    return \"YES\""
      ],
      [
        0.9362756013870239,
        "def swap_for_odds(lst1, lst2):\n    \"\"\"\n    Given two lists of integers, lst1 and lst2, determine if it is possible to swap elements in the lists so that the sum of the elements in lst1 is even and the sum of the elements in lst2 is odd.\n\n    Args:\n        lst1 (list): A list of integers.\n        lst2 (list): Another list of integers.\n\n    Returns:\n        str: \"YES\" if it is possible to swap elements in the lists so that the sum of the elements in lst1 is even and the sum of the elements in lst2 is odd, otherwise \"NO\".\n    \"\"\"\n    sum_lst1 = sum(lst1)\n    sum_lst2 = sum(lst2)\n\n    if (sum_lst1 + sum_lst2) % 2 != 0:\n        return \"NO\"\n\n    has_odd_lst1 = any(i % 2 != 0 for i in lst1)\n    has_even_lst2 = any(i % 2 == 0 for i in lst2)\n\n    return \"YES\" if has_odd_lst1 and has_even_lst2 else \"NO\""
      ]
    ],
    "HumanEval/111": [
      [
        0.9551845788955688,
        "def advanced_histogram(test):\n    \"\"\"\n    Write a function that takes a string and returns a dictionary with the letters as keys and the number of times they appear in the string as values.\n    \n    For example:\n    \n    advanced_histogram(\"Hello world\") \u279e { \"e\": 3, \"l\": 3, \"o\": 2, \"r\": 1, \"u\": 1, \"w\": 1 }\n    \n    The letter \"h\" does not appear in the string so it is not included in the dictionary.\n    \n    Notes:\n    \n    The string will be in lowercase\"\"\"\n    count = {}\n    for char in test:\n        if char != ' ':\n            if char.lower() in count:\n                count[char.lower()] += 1\n            else:\n                count[char.lower()] = 1\n    max_freq = max(count.values(), default=0)\n    return {k: v for k, v in count.items() if v == max_freq}"
      ],
      [
        0.9455186128616333,
        "def advanced_histogram(test):\n    \"\"\"\n    \"\"\"\n    # count all character in the test\n    count = {}\n    for char in test:\n        if char != ' ':\n            if char.lower() in count:\n                count[char.lower()] += 1\n            else:\n                count[char.lower()] = 1\n                \n    # find the maximum frequency\n    max_freq = max(count.values()) if count else 0\n\n    # return only the characters with the maximum frequency\n    return {char: count for char, count in count.items() if count == max_freq}"
      ],
      [
        0.9435921907424927,
        "def advanced_histogram(test):\n    \"\"\"\n    \"\"\"\n    # Track counts\n    count = {}\n    for char in test:\n        if char != ' ':\n            if char.lower() in count:\n                count[char.lower()] += 1\n            else:\n                count[char.lower()] = 1\n\n    # Find maximum count\n    max_count = 0\n    for char, cnt in count.items():\n        if cnt > max_count:\n            max_count = cnt\n    \n    # Collect chars that have max_count \n    max_chars = {}\n    for char, cnt in count.items():\n        if cnt == max_count:\n            max_chars[char] = cnt\n    \n    return max_chars"
      ],
      [
        0.9435725808143616,
        "def advanced_histogram(test):\n    \"\"\"\n    \"\"\"\n    count = {}\n    max_count = 0\n    max_count_chars = []\n    \n    # Counting frequency of all characters\n    for char in test:\n        if char != ' ':\n            if char.lower() in count:\n                count[char.lower()] += 1\n            else:\n                count[char.lower()] = 1\n            # Keeping track of maximum count\n            if count[char.lower()] > max_count:\n                max_count = count[char.lower()]\n\n    # Adding characters with max_count in list\n    for char, char_count in count.items():\n        if char_count == max_count:\n            max_count_chars.append(char)\n\n    # Preparing final dictionary\n    result = {char: max_count for char in max_count_chars}\n    return result"
      ],
      [
        0.9431872963905334,
        "def advanced_histogram(test):\n    \"\"\"\n    \"\"\"\n    count = {}\n    for char in test:\n        if char != ' ':\n            if char.lower() in count:\n                count[char.lower()] += 1\n            else:\n                count[char.lower()] = 1\n    \n    # find the highest frequency\n    max_value = max(count.values()) if count else 0\n\n    # keep only those characters with max value\n    return {k: v for k, v in count.items() if v == max_value}"
      ]
    ],
    "HumanEval/112": [
      [
        0.9110395908355713,
        "def checkPalindromeDistinctAlphabets(s, c, n):\n    \"\"\"\n    :type s: str\n    :type c: str\n    :type n: int\n    :rtype: str, bool, bool\n    \"\"\"\n    result = ''.join(ch for ch in s if ch not in c)\n    palindrome = result == result[::-1]\n    num_alphabets = len(set(result))\n    \n    return result, palindrome, num_alphabets == n"
      ],
      [
        0.9017837047576904,
        "def check_palindrome(s):\n    \"\"\"\n    Check if a string is a palindrome\n    \"\"\"\n    # Complete the function to check if the input string s is a palindrome\n    # Return True if s is a palindrome, and False otherwise\n    # A palindrome reads the same forward and backward, ignoring spaces, punctuation, and capitalization\n    # Example: \"A man, a plan, a canal, Panama\" is a palindrome\n    # Example: \"racecar\" is a palindrome\n    # Example: \"hello\" is not a palindrome\n    return s.lower().replace(' ', '').replace(',', '').replace('.', '') == s[::-1].lower().replace(' ', '').replace(',', '').replace('.', '')"
      ],
      [
        0.9008333086967468,
        "def replace_and_reverse(s, ch):\n    \"\"\"\n    Given a string s and a character ch, replace all occurrences of ch with space\n    and reverse the string. If the resulting string is a valid palindrome, return\n    the resulting string. Otherwise, return an empty string.\n    \n    A valid palindrome is a string that reads the same forward and backward.\n    \n    Example 1:\n    Input: s = \"abbab\", ch = \"b\"\n    Output: \"abba\"\n    Explanation: Replace 'b' with space to get \"a b b a\".\n    Reverse the string to get \"abba\".\n    \"abba\"\"\"\n    # Replace the given character with space\n    s = s.replace(ch, ' ')\n\n    # Split the string into words\n    words = deque(s.split())\n\n    # Initialize final result with an empty string\n    res = \"\"\n\n    while words:\n        # If the current string does not form a valid palindrome\n        # Remove a word from the front or back of the queue and \n        # add to the appropriate end based on which makes a valid palindrome\n        if res.replace(\" \", \"\") != res[::-1].replace(\" \", \"\"):\n            if words[0][::-1] in res:\n                res = words.popleft() + \" \" + res\n            else:\n                res = res + \" \" + words.pop()\n        # If the current string forms a valid palindrome, add the next word\n        # to the end\n        else:\n            res = res + \" \" + words.pop()\n            \n    # If the result is not a valid palindrome, return an empty string\n    return res if res.replace(\" \", \"\") == res[::-1].replace(\" \", \"\") else \"\""
      ],
      [
        0.8956347703933716,
        "def is_palindrome(s):\n    \"\"\"\n    Return True if the given string is a palindrome.\n    \n    >>> is_palindrome('tacocat')\n    True\n    >>> is_palindrome('tacodog')\n    False\n    \"\"\"\n    s = ''.join(c for c in s if c.isalnum()) # remove special characters\n    s = s.lower() # make all letters lowercase\n    return s == s[::-1] # Check the string s is palindrome or not"
      ],
      [
        0.8943114280700684,
        "def is_palindrome(s):\n    \"\"\"\n    Return True if the given string is a palindrome.\n    \n    >>> is_palindrome('tacocat')\n    True\n    >>> is_palindrome('tacodog')\n    False\n    \"\"\"\n    s = s.replace(' ', '')  # This line is to remove spaces in the string\n    return s == s[::-1]"
      ],
      [
        0.893972635269165,
        "def is_palindrome(string):\n    \"\"\"\n    Check if a string is a palindrome\n    \"\"\"\n    # remove all the whitespaces\n    string = ''.join(string.split())\n\n    # reverse the string\n    reverse = ''.join(reversed(string))\n\n    # check if string is equal to its reverse\n    if string == reverse:\n        return True\n    else:\n        return False\n    def is_palindrome(string):\n    \"\"\"\n    Check if a string is a palindrome\n    \"\"\"\n    # remove all the whitespaces\n    string = ''.join(string.split())\n\n    # reverse the string\n    reverse = ''.join(reversed(string))\n\n    # check if string is equal to its reverse\n    if string == reverse:\n        return True\n    else:\n        return False"
      ],
      [
        0.8931553959846497,
        "def is_palindrome(s):\n    \"\"\"\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    # The translation table is created with maketrans function to remove all punctuation\n    # and .lower() function is used to convert string into lower case.\n    s = s.translate(str.maketrans('', '', string.punctuation)).replace(\" \", \"\").lower()\n    return s == s[::-1]"
      ],
      [
        0.893057107925415,
        "def isPalindrome(s):\n    \"\"\"\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    # Using predefined function to get rid of spaces\n    s = s.replace(' ', '')\n    # Converting all the letters of the string into lowercase\n    s = s.lower()\n    # Reversing the string\n    rev = s[::-1]\n\n    # Comparing the reversed string with the original string\n    if rev == s:\n        return True\n    else:\n        return False"
      ]
    ],
    "HumanEval/113": [
      [
        0.9626791477203369,
        "def unusual_addition(lst):\n    \"\"\"This function accepts a list solely made up of strings containing numerical digits only and returns a list.\n    In the output, for each element, replace the 'i' with the true count of odd digits and 'e' with the true count of even digits in \n    the i'th string from the input.\n\n    >>> unusual_addition(['1234567'])\n    [\"the number of odd elements 4n the str3ng 3 of the 4nput.\"]\n    >>> unusual_addition(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str0ng 0 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for idx, str in enumerate(lst):\n        odd_count = sum(1 for s in str if int(s) % 2 != 0)\n        even_count = sum(1 for s in str if int(s) % 2 == 0)\n        replace_string = f\"the number of odd elements {odd_count}n the str{even_count}ng {even_count} of the {odd_count}nput.\"\n        output.append(replace_string)\n\n    return output"
      ],
      [
        0.9587107300758362,
        "def unusual_addition(lst):\n    \"\"\"\n    This function accepts a list solely made up of strings containing numerical digits only and returns a list.\n    In the output, for each element, replace the '1' with the true count of odd digits and 'e' with the true count of even digits in\n    the nth string from the input.\n\n    >>> unusual_addition(['1234567'])\n    [\"the number of odd elements are 3 of the string 1 of the input.\"]\n    >>> unusual_addition(['3', \"1111111\"])\n    [\"the number of odd elements are 1 of the string 1 of the input.\",\n    \"the number of odd elements are 7 of the string 0 of the input.\"]\n    \"\"\"\n    output = []\n    for idx, string in enumerate(lst):\n        odd_count = sum(1 for s in string if int(s) % 2 != 0)\n        even_count = sum(1 for s in string if int(s) % 2 == 0)\n        replace_string = f\"the number of odd elements are {odd_count} of the string {even_count} of the input\"\n        output.append(replace_string)\n\n    return output"
      ],
      [
        0.950128436088562,
        "def even_characters(lst):\n    \"\"\"\n    Return a list of strings, each of which contains the number of even characters in the corresponding string in the input list.\n    \n    >>> even_characters(['abc', '101', '10010'])\n    ['the number of even characters 0 in the string 1 of the input.', 'the number of even characters 1 in the string 2 of the input.', 'the number of even characters 3 in the string 3 of the input.']\n    \"\"\"\n    result = []\n    for i, s in enumerate(lst, 1):\n        count = sum(1 for c in s if c in '24680')\n        result.append(\"the number of even characters {}n the str{}ng {} of the {}nput.\".format(count, i, count, i))\n    return result"
      ],
      [
        0.9476467967033386,
        "def complex_sum(lst):\n    \"\"\"Count the number of odd digits in each string in the list.\"\"\"\n    result = []\n    for i, s in enumerate(lst):\n        if not isinstance(s, str):\n            raise ValueError(\"ERROR: All elements in the list must be strings.\")\n        try:\n            odd_nums = len([int(n) for n in s if int(n) % 2 != 0])\n        except ValueError:\n            raise ValueError(\"ERROR: All characters in the strings must be numeric.\")\n        result.append(\"the calculation of odd segments {}n the str{}ng {} of the {}nput set.\".format(odd_nums, i+1, odd_nums, i+1))\n    return result"
      ],
      [
        0.9435551166534424,
        "def unusual_addition(lst):\n    \"\"\"Given a list consisting only of strings with numerical characters, return a list.\n    Each 'i' in the output statement for each element, \"the number of odd elements present in the\n    i'th input string.\", should be replaced with the actual count of odd numbers.\"\"\"\n\n    results = []\n\n    for i, string in enumerate(lst):\n        totals = [0, 0]  # [total_odd_numbers, total_even_numbers]\n\n        # Count number of odd and even numbers within the string\n        for char in string:\n            if int(char) % 2 == 0:\n                totals[1] += 1\n            else:\n                totals[0] += 1\n\n        # For increasing the complexity, Compute square of counts\n        totals = [num**2 for num in totals]\n\n        # Misleading task here: unnecessarily loop through list twice\n        odd_squares = [el for el in range(totals[0])]\n        even_squares = [el for el in range(totals[1])]\n\n        odd_square_totals = sum([num**2 for num in odd_squares])\n        even_square_totals = sum([num**2 for num in even_squares])\n\n        output_string = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(\n            odd_square_totals, odd_square_totals, odd_square_totals, odd_square_totals)\n\n        results.append(output_string)\n\n    return results"
      ]
    ],
    "HumanEval/114": [
      [
        0.9398595690727234,
        "def optimize_array(array):\n  \"\"\"\n  Given an array of integers, return the sum of the minimum contiguous subarray.\n  \n  For example, given the array [1, -1, -2, 1], return 1.\n  \n  The sum of the minimum contiguous subarray in this case is 1 + (-1) + (-2) = -2.\n  \n  You may assume the array contains at least one integer.\n  \"\"\"\n  array.sort()\n  result = 0\n  for num in array:\n    if result + num < 0:\n      result += num\n  return result"
      ],
      [
        0.9258475303649902,
        "def max_subarray_sum(nums):\n    \"\"\"\n    Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n    \n    Example 1:\n    \n    Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\n    Output: 6\n    Explanation: [4,-1,2,1] has the largest sum = 6.\n    \n    Example 2:\n    \n    Input: nums = [1]\n    Output: 1\n    \n    Example 3:\n    \n\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum += num\n        if current_sum < 0:\n            current_sum = 0\n        if current_sum > max_sum:\n            max_sum = current_sum\n    \n    return max_sum"
      ],
      [
        0.9225354194641113,
        "def max_subarray_sum(arr):\n    \"\"\"\n    Find the contiguous subarray (containing at least one number) which has the largest sum.\n    \n    For example:\n    Given the array [-2,1,-3,4,-1,2,1,-5,4],\n    the contiguous subarray [4,-1,2,1] has the largest sum = 6.\n    \n    For this problem, return the maximum sum.\n    \"\"\"\n    curr_sum = arr[0]\n    max_sum = arr[0]\n    for num in arr[1:]:\n        curr_sum = max(curr_sum + num, num)\n        max_sum = max(curr_sum, max_sum)\n    return max_sum"
      ],
      [
        0.9222379922866821,
        "def max_subarray_sum(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    max_sum = 0\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        max_sum = max(max_sum, current_sum)\n        if current_sum < 0:\n            current_sum = 0\n\n    return max_sum"
      ],
      [
        0.9207543134689331,
        "def max_subarray_sum(array):\n    \"\"\"\n    Find the contiguous subarray (containing at least one number) which has the largest sum.\n    \n    For example:\n    \n    Given the array [-2,1,-3,4,-1,2,1,-5,4],\n    the contiguous subarray [4,-1,2,1] has the largest sum = 6.\n    \n    For this problem, return the maximum sum.\n    \"\"\"\n    max_sum_so_far = 0\n    max_sum_ending_here = 0\n\n    for num in array:\n        max_sum_ending_here = max(max_sum_ending_here + num, 0)\n        max_sum_so_far = max(max_sum_so_far, max_sum_ending_here)\n    return max_sum_so_far"
      ],
      [
        0.9198276996612549,
        "def maxSubArraySum(arr):\n    \"\"\"\n    Find the contiguous subarray within an array (containing at least one number) which has the largest sum.\n    \n    For example:\n    \n    Given the array [-2,1,-3,4,-1,2,1,-5,4],\n    the contiguous subarray [4,-1,2,1] has the largest sum = 6.\n    \n    For this problem, return the maximum sum.\n    \"\"\"\n    max_so_far = 0 \n    max_ending_here = 0 \n    \n    for i in range(0, len(arr)): \n        max_ending_here = max_ending_here + arr[i] \n        \n        if (max_ending_here < 0): \n            max_ending_here = 0\n        \n        if (max_so_far < max_ending_here): \n            max_so_far = max_ending_here \n    \n    return max_so_far "
      ],
      [
        0.9195113778114319,
        "def maxSubArraySum(array):\n    \"\"\"\n    Find the contiguous subarray within an array (containing at least one number) which has the largest sum.\n    \n    For example:\n    \n    Given the array [-2,1,-3,4,-1,2,1,-5,4],\n    the contiguous subarray [4,-1,2,1] has the largest sum = 6.\n    \n    For this problem, return the maximum sum.\n    \n    \"\"\"\n    max_sum = array[0]\n    curr_sum = array[0]\n      \n    for i in range(1,len(array)):         \n        curr_sum = max(array[i], curr_sum + array[i])\n        max_sum = max(curr_sum, max_sum)\n      \n    return max_sum"
      ],
      [
        0.9192203283309937,
        "def max_subarray_sum(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if not nums or all(num <= 0 for num in nums):\n        return 0\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum"
      ]
    ],
    "HumanEval/115": [
      [
        0.939333975315094,
        "def well_emptying(grid, capacity):\n    \"\"\"\n    Returns the number of times a bucket needs to be lowered to empty all the wells in the grid.\n\n    Args:\n        grid (list): A 2D list representing the grid of wells.\n        capacity (int): The capacity of the bucket.\n\n    Returns:\n        int: The number of times a bucket needs to be lowered to empty all the wells in the grid.\n    \"\"\"\n    # Get the number of rows and columns in the grid\n    rows, cols = len(grid), len(grid[0])\n\n    # Initialize the number of bucket lowerings to 0\n    lowerings = 0\n\n    # Iterate over the rows in the grid\n    for i in range(rows):\n        # Initialize the remaining capacity of the bucket\n        remaining_capacity = capacity\n\n        # Iterate over the columns in the row\n        for j in range(cols):\n            # If the current well has water\n            if grid[i][j] == 1:\n                # Decrease the remaining capacity of the bucket\n                remaining_capacity -= 1\n\n                # If the bucket is full, empty it and reset the capacity\n                if remaining_capacity == 0:\n                    lowerings += 1\n                    remaining_capacity = capacity\n\n        # If the bucket has water after finishing a row, empty it\n        if remaining_capacity != capacity:\n            lowerings += 1\n\n    return lowerings"
      ],
      [
        0.9317306280136108,
        "def minTimeToEmptyWells(grid, bucket_capacity):\n    \"\"\"\n    :type grid: List[List[int]]\n    :type bucket_capacity: int\n    :rtype: int\n    \"\"\"\n    count = [0] * len(grid[0])\n    for row in grid:\n        for j in range(len(row)):\n            count[j] += row[j]\n    count.sort()\n\n    time = 0\n    while count:\n        i = len(count) - 1\n        while i >= 0 and count[i] > 0:\n            count[i] -= bucket_capacity\n            i -= 1\n        count = [x for x in count if x > 0]\n        time += 1\n\n    return time - 1 if len(grid[0]) > bucket_capacity else time"
      ],
      [
        0.9000563621520996,
        "def water_plants(plants, capacity):\n    \"\"\"\n    Given an array of non-negative integers representing the amount of water needed to\n    water each plant in the garden. You have a watering can with capacity `capacity`\n    liters of water. You need to water all the plants in a single pass.\n    Return the number of steps needed to water all the plants.\n    \"\"\"\n    # TODO: Write your code here\n    return 0\n    \n    def water_plants(plants, capacity):\n    \"\"\"\n    Given an array of non-negative integers representing the amount of water needed to\n    water each plant in the garden. You\"\"\"\n    steps = 0\n    water_left = 0\n\n    for i, plant in enumerate(plants):\n        if water_left < plant:\n            steps += 2 * i + 1  # Refill the watering can\n            water_left = capacity\n        water_left -= plant\n        steps += 1  # Move to the next plant\n\n    return steps"
      ],
      [
        0.9000486135482788,
        "def water_plants(plants, capacity):\n    \"\"\"\n    Given an array of non-negative integers representing the amount of water needed to\n    water each plant in the garden. You have a watering can with capacity `capacity`\n    liters of water. You need to water all the plants in a single pass.\n    Return the number of steps needed to water all the plants.\n    \"\"\"\n    # TODO: Write your code here\n    return 0\n    \n    def water_plants(plants, capacity):\n    \"\"\"\n    Given an array of non-negative integers representing the amount of water needed to\n    water each plant in the garden. You\"\"\"\n    steps = 0\n    water_left = 0\n\n    for i, plant in enumerate(plants):\n        if water_left < plant:\n            steps += 2 * i + 1  # Refill the watering can\n            water_left = capacity\n        water_left -= plant\n        steps += 1  # Move to the next plant\n\n    return steps"
      ]
    ],
    "HumanEval/116": [
      [
        0.9513192772865295,
        "def sort_by_binary_one_count(arr): \n    \"\"\"\n    Given an array of integers, return the array sorted in ascending order by the number of 1s in each integer. For example, the binary representation of 1234 is 10011010010, so the answer of this function for this example would be [0,1,12,123,1234].\n    \"\"\"\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))"
      ],
      [
        0.9464341402053833,
        "def sort_by_binary_len(arr):\n    \"\"\"\n    Rearrange an array of non-negative integers considering the lengths \n    of their binary notations. Sort the numbers by their decimal values \n    in case of binary length matches. \n\n    The expected output will be: \n    >>> sort_by_binary_len([1, 31, 15, 2, 7]) == [1, 2, 7, 15, 31]\n    >>> sort_by_binary_len([14, 58, 39, 41, 61]) == [14, 39, 41, 58, 61]\n    >>> sort_by_binary_len([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    \"\"\"\n    \n    sorted_arr = sorted(arr, key=lambda x: (bin(x)[2:].zfill(8), x))\n    return sorted_arr"
      ],
      [
        0.943915605545044,
        "def sort_by_binary_len(arr):\n    \"\"\"\n    Sort an array of integers by the length of their binary representation.\n    If two integers have the same length, the smaller number should come first.\n    \n    >>> sort_by_binary_len([1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1])\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 51\"\"\"\n    return sorted(arr, key=lambda x: (len(bin(abs(x)))-2, abs(x)))"
      ],
      [
        0.9437627792358398,
        "def sort_by_binary_len(arr):\n    \"\"\"\n    Sort an array of integers by the length of their binary representation.\n    If two numbers have the same length, the smaller number should come first.\n    \n    >>> sort_by_binary_len([1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1])\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 51\"\"\"\n    return sorted(arr, key=lambda x: (len(bin(abs(x)))-2, x >= 0, x))"
      ],
      [
        0.9400618076324463,
        "def sort_by_binary_len(arr):\n    \"\"\"\n    Reorders an array of strictly positive integers according to\n    the length of their binary representations, in increasing order.\n    In instances of overlapping binary lengths, the array uses\n    decimal numerical values as the basis for establishing order.\n\n    The output produced should conform to the examples provided:\n    >>> sort_by_binary_len([1, 31, 15, 2, 7]) == [1, 2, 7, 15, 31]\n    >>> sort_by_binary_len([14, 58, 39, 41, 61]) == [14, 39, 41, 58, 61]\n    >>> sort_by_binary_len([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n\n    # Sort the array based on binary length and then value\n    return sorted(arr, key = lambda x: (bin(x)[2:], x))"
      ],
      [
        0.9343607425689697,
        "def sortByBits(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))"
      ]
    ],
    "HumanEval/117": [
      [
        0.9436567425727844,
        "def select_words(s, n):\n    \"\"\"\n    Select words from a string s that have exactly n consonants.\n    Return a list of tuples (count_vowels, word) in ascending order of count_vowels.\n    \"\"\"\n    def count_consonants(word):\n        \"\"\"\n        Count the number of consonants in a word.\n        \"\"\"\n        consonants = \"bcdfghjklmnpqrstvwxyz\"\n        count = 0\n        for letter in word:\n            if letter.lower() in consonants:\n                count += 1\n        return count\n    def count_vowels(word\"\"\"\n    words = s.split()\n    selected_words = []\n    for i in range(len(words)):\n        if count_consonants(words[i]) == n:\n            if selected_words and i > 0 and count_consonants(words[i-1]) == n:\n                selected_words[-1] += words[i]\n            else:\n                selected_words.append(words[i])\n    return [(count_vowels(word), word) for word in selected_words]"
      ],
      [
        0.9255451560020447,
        "def select_phrases(s, n, m):\n    \"\"\"\n    Select phrases from a string based on the number of consonants and vowels in each word.\n    \n    Args:\n        s (str): The string containing the phrases.\n        n (int): The number of consonants in each phrase.\n        m (int): The number of vowels in each phrase.\n    \n    Returns:\n        list: A list of phrases that meet the criteria.\n    \"\"\"\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    \n    if not s:\n        return []\n\n    phrases_with_required_counts = []\n    current_phrase = []\n    current_consonants = 0\n    current_vowels = 0\n\n    for word in s.split():\n        word_cons = len([ch for ch in word.lower() if ch in consonants])\n        word_vows = len([ch for ch in word.lower() if ch in vowels])\n\n        if (current_consonants + word_cons == n) and (current_vowels + word_vows == m):\n            current_phrase.append(word)\n            phrases_with_required_counts.append(' '.join(current_phrase))\n            current_phrase = []\n            current_consonants = 0\n            current_vowels = 0\n\n        elif (current_consonants + word_cons > n) or (current_vowels + word_vows > m):\n            current_phrase = [word]\n            current_consonants = word_cons\n            current_vowels = word_vows\n\n        else:\n            current_phrase.append(word)\n            current_consonants += word_cons\n            current_vowels += word_vows\n\n    return phrases_with_required_counts"
      ],
      [
        0.9229823350906372,
        "def select_merge_words(s, n):\n    \"\"\"\n    \"\"\"\n    import re\n    if len(s)==0:\n        return []\n    else:\n        words = re.findall(r'\\b\\w+\\b', s)\n        res=[]\n        cnt=0\n        vwl=0\n        for i in words:\n            cnc=len(i) - len(re.findall(r'[aeiou]',i, re.I))\n            vw=len(re.findall(r'[aeiou]',i, re.I))\n            if cnc==n:\n                cnt += cnc\n                vwl += vw             \n            else:\n                if cnt == n:\n                    res.append(str(vwl)+i)\n                cnt=0   \n                vwl=0\n        if cnt == n:\n            res.append(str(vwl)+i)\n        return res"
      ],
      [
        0.9227286577224731,
        "def word_segments(s, n):\n    \"\"\"\n    Given a string s and an integer n, return a list of all words in s that are n vowels long.\n    For this problem, we consider a word to be a contiguous sequence of characters delimited by white space.\n    \n    Example 1:\n    Input: s = \"the quick brown fox jumped over the lazy dog\", n = 3\n    Output: [\"the\",\"quick\",\"brown\",\"over\"]\n    \n    Example 2:\n    Input: s = \"the quick brown fox jumped over the lazy dog\", n = 4\n    Output: [\"quick\",\"brown\",\"over\"\"\"\n    vowels = \"aeiouAEIOU\"\n    words = s.split()\n    segments = []\n    for word in words:\n        cnt = 0\n        segment = \"\"\n        for char in word:\n            if char in vowels:\n                cnt += 1\n            segment += char\n            if cnt == n:\n                segments.append(segment)\n                cnt = 0\n                segment = \"\"\n    return segments"
      ],
      [
        0.9206824898719788,
        "def select_words(s, n, l):\n    \"\"\"\n    Select words from a string s that contain exactly n vowels and are in the list l.\n    If there are multiple words that satisfy the condition, select one at random.\n    If there are no words that satisfy the condition, return an empty list.\n    :param s: a string\n    :param n: an integer\n    :param l: a list of strings\n    :return: a list of strings\n    \"\"\"\n    if not s or not any(letter in s for letter in l):\n        return []\n    vowels = set(l)\n    words = s.split()\n    result = []\n    for word in words:\n        if sum(1 for ch in word if ch in vowels) == n:\n            if result and sum(1 for ch in result[-1] if ch in vowels) == n:\n                removed_vowel = random.choice([vowel for vowel in result[-1] if vowel in vowels])\n                result[-1] = result[-1].replace(removed_vowel, '', 1)\n                result[-1] += word\n            else:\n                result.append(word)\n    return result"
      ],
      [
        0.9205326437950134,
        "def select_merge_words(s, n):\n    \"\"\"\n    \"\"\"\n    if len(s) == 0:\n        return []\n    else:\n        words = re.findall(r'\\b\\w+\\b', s)\n        res = []\n        cnt = 0\n        vwl = 0\n        for i in words:\n            cn = len(i) - len(re.findall(r'[aeiou]',i, re.I))\n            vw = len(re.findall(r'[aeiou]',i, re.I))\n            if cn == n:\n                cnt += cn\n                vwl += vw             \n            else:\n                if cnt == n:\n                    res.append(str(vwl) + i)\n                cnt = 0   \n                vwl = 0\n            if cnt == n:\n                res.append(str(vwl) + i)\n        return res"
      ],
      [
        0.9203342199325562,
        "def word_segments(s, n):\n    \"\"\"\n    Given a string s and an integer n, return a list of all words in s that have a vowel count of n.\n    \n    Note: The only vowels are a, e, i, o, and u.\n    \n    Example 1:\n    \n    Input: s = \"the quick brown fox jumped over the lazy dog\", n = 2\n    Output: [\"the\",\"quick\",\"brown\",\"jumped\",\"over\",\"the\",\"lazy\"]\n    Explanation: The words in s that have a vowel count of 2 are \"the\", \"quick\", \"brown\", \"jumped\"\"\"\n    if not s:\n        return []\n    \n    # list of vowels\n    vowels = \"aeiouAEIOU\"\n\n    result = []\n\n    for word in s.split():\n        word_vowels = [char for char in word if char in vowels]  # count vowels in word\n        if len(word_vowels) == n:\n            result.append(word)\n        else:\n            segments = [word[i:i + n] for i in range(0, len(word), n)]\n            # only add to 'result' if vowel count matches 'n'\n            result.extend(segment for segment in segments if sum(ch in vowels for ch in segment) == n)\n\n    return result"
      ],
      [
        0.91740483045578,
        "def select_merge_words(s, n):\n    \"\"\"\n    \"\"\"\n    if not s:\n        return []\n\n    vowels_set = set('aeiouAEIOU')\n    words = s.split(' ')\n    result = []\n    merge_word = ''\n    for word in words:\n        consonant_count = sum(1 for letter in word if letter not in vowels_set)\n        if consonant_count == n:\n            vowel_count = len(word) - consonant_count\n            merge_word += word\n        else:\n            if merge_word:\n                result.append(f'{merge_word.count(\"a\")+merge_word.count(\"e\")+merge_word.count(\"i\")+merge_word.count(\"o\")+merge_word.count(\"u\")+merge_word.count(\"A\")+merge_word.count(\"E\")+merge_word.count(\"I\")+merge_word.count(\"O\")+merge_word.count(\"U\")}{merge_word}')\n                merge_word = ''\n\n    # append last word\n    if merge_word:\n        result.append(f'{merge_word.count(\"a\")+merge_word.count(\"e\")+merge_word.count(\"i\")+merge_word.count(\"o\")+merge_word.count(\"u\")+merge_word.count(\"A\")+merge_word.count(\"E\")+merge_word.count(\"I\")+merge_word.count(\"O\")+merge_word.count(\"U\")}{merge_word}')\n\n    return result"
      ]
    ],
    "HumanEval/118": [
      [
        0.9708237051963806,
        "def get_closest_vowel(word):\n    \"\"\"\n    Enter a word, proceeding to pinpoint the nearest vowel nestled between a \n    dual of consonants, initiating from the right portion of the word, whilst \n    honoring case-sensitivity. Overlook vowels situated at the word's inception \n    or termination. Relay an unoccupied string if such a character is absent. \n    Assume the input string to be constituted exclusively of English alphabets.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    for i in range(len(word) - 1, 0, -1):\n        if word[i] in vowels and word[i-1] not in vowels and word[i+1] not in vowels:\n            return word[i]\n    return \"\""
      ],
      [
        0.9679190516471863,
        "def get_closest_vowel(word):\n    \"\"\"Input a word and then find out the vowel closest from the right side of the word that is \n    between two consonants, distinguishing between upper and lower case. Ignore vowels at the \n    beginning or end of the word. If this kind of vowel does not exist, return an empty string. \n    Assume that the input string only contains English letters.\n\n    Examples:\n    get_closest_vowel(\"yogurt\") => \"u\"\n    get_closest_vowel(\"FULL\") => \"U\"\n    get_closest_vowel(\"quick\") => \"\"\n    get_closest_vowel(\"ab\") => \"\"\n    \"\"\"\n\n    # First, strip any vowels from the beginning and end of the word,\n    while len(word) > 0 and (word[0] in 'aeiouAEIOU' or word[-1] in 'aeiouAEIOU'):\n        if word[0] in 'aeiouAEIOU':\n            word = word[1:]\n\n        if len(word) > 0 and word[-1] in 'aeiouAEIOU':\n            word = word[:-1]\n\n    # Then, find the closest vowel sequence from the right side,\n    for i in range(len(word)-1, -1, -1):\n        if word[i] in 'aeiouAEIOU':\n            return word[i]\n    return \"\""
      ],
      [
        0.9643682241439819,
        "def get_closest_vowel(word):\n    \"\"\"Insert a word, and then retrieve the nearest vowel that is ensconced amid a pair of consonants, \n    starting from the right section of the word, while being case-sensitive. \n    Bypass vowels at either the genesis or finale of the word. \n    Respond with a vacant string if such a vowel is nonexistent. \n    Presume that the input string is comprised strictly of English letters.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\n\n    vowels = 'aeiouAEIOU'\n    for i in reversed(range(1, len(word) - 1)): #not including the first and the last characters\n        if (word[i] in vowels) and (word[i - 1] not in vowels) and (word[i + 1] not in vowels):\n            return word[i]\n    return ''"
      ],
      [
        0.9418500661849976,
        "def get_closest_vowel(word):\n    \"\"\"\n    Accepts a single word input, then ascertains the closest vowel positioned between \n    two consonants originating from the word's right-most character, accounting for \n    case sensitivity. Vowels at the beginning or end of the word should not be \n    considered, and an empty string should be returned if the specified vowel does not \n    exist. The input string is assumed to be formed exclusively by English letters.\n    \"\"\"\n\n    # reverse the word to start from the right-most character\n    reversed_word = word[::-1]\n\n    for i in range(1, len(reversed_word)-1):\n        # check if current character is a vowel, the previous and next characters are consonants\n        if reversed_word[i] in 'aeiouAEIOU' and reversed_word[i-1] not in 'aeiouAEIOU' and reversed_word[i+1] not in 'aeiouAEIOU':\n            return reversed_word[i]  # found the vowel\n\n    return \"\"  # return empty string if no such vowel exists"
      ],
      [
        0.9412038326263428,
        "def get_closest_vowel(word):\n    \"\"\"\n    Accepts a single word input, then ascertains the closest vowel positioned between \n    two consonants originating from the word's right-most character, accounting for \n    case sensitivity. Vowels at the beginning or end of the word should not be \n    considered, and an empty string should be returned if the specified vowel does not \n    exist. The input string is assumed to be formed exclusively by English letters.\n    \"\"\"\n\n    # reverse the word to start from the right-most character\n    reversed_word = word[::-1]\n\n    for i in range(1, len(reversed_word) - 1):\n        # check if current character is a vowel, the previous and next characters are consonants\n        if reversed_word[i] in 'aeiouAEIOU' and reversed_word[i - 1] not in 'aeiouAEIOU' and reversed_word[i + 1] not in 'aeiouAEIOU':\n            return reversed_word[i]  # found the vowel\n\n    return \"\"  # return empty string if no such vowel exists"
      ],
      [
        0.937449038028717,
        "def getClosestVowel(word):\n    \"\"\"\n    Given a word, return the closest vowel to the middle of the word.\n    If there are two equally close vowels, return the one that comes first.\n    If there are no vowels, return an empty string.\n    \n    >>> getClosestVowel('banana')\n    'a'\n    >>> getClosestVowel('apple')\n    'e'\n    >>> getClosestVowel('xray')\n    'a'\n    >>> getClosestVowel('computer')\n    'o'\n    >>> getClosestVowel('zzzzzzzz')\n    ''\n    \"\"\"\n    vowels = 'AEIOUaeiou'\n    word = word[1:-1]  # Ignore first and last characters\n    for i in range(len(word)-1, -1, -1):  # Loop backwards\n        if word[i] in vowels:\n            if i>0 and word[i-1] not in vowels and i<len(word)-1 and word[i+1] not in vowels:\n                return word[i]\n    return ''"
      ],
      [
        0.9360096454620361,
        "def get_closest_vowel(word):\n    \"\"\"\n    Find the closest vowel to the middle of the word.\n    If there are two equally close vowels, choose the one that comes first.\n    If there are no vowels, return an empty string.\n    \n    Args:\n        word (str): The word to search.\n    \n    Returns:\n        str: The closest vowel to the middle of the word.\n    \"\"\"\n    # check if word length is less than 3. Word must be at least 3 letters to have vowels between consonants\n    if len(word) < 3: \n        return ''\n\n    # convert word to whether each character is vowel or not\n    # True for vowels, False for consonants\n    is_vowel = ['aeiouAEIOU'.find(c) != -1 for c in word]\n\n    # Iterate from right (excluding the last letter)\n    for i in range(len(word)-2, 0, -1):\n        # Check if this and surrounding letters are consonant-vowel-consonant\n        if is_vowel[i-1] == is_vowel[i+1] == False and is_vowel[i] == True:\n            return word[i]\n    \n    # Return empty string if no such vowel exists\n    return ''"
      ],
      [
        0.9360020160675049,
        "def get_first_consonant_flanked_vowel(word):\n    \"\"\"Given a word, find the first vowel that is enclosed by consonants from the left side of the word (case sensitive). Do not include vowels at the initiation or cessation of the word. Return an empty string if no such vowel found. The input string must only have English characters.\n\n    Example:\n    get_first_consonant_flanked_vowel(\"umbrella\") ==> \"e\"\n    get_first_consonant_flanked_vowel(\"STRONG\") ==> \"O\"\n    get_first_consonant_flanked_vowel(\"grape\") ==> \"a\"\n    get_first_consonant_flanked_vowel(\"fly\") ==> \"\"\n    \"\"\"\n    vowels = 'AEIOUaeiou'\n    for i in range(1, len(word) - 1):  # Skip first and last characters\n        if word[i] in vowels and word[i - 1] not in vowels:\n            return word[i]\n    \n    return \"\"  # Return empty string if no vowel found"
      ],
      [
        0.9355776309967041,
        "def get_last_vowel_flanked_consonant(word):\n    \"\"\"Given a word, find the last consonant that is surrounded by vowels from the right side of the word (case sensitive). Do not include consonants at the beginning or end of the word. Return an empty string if no such consonant is found. Assume the input string contains only English letters.\"\"\"\n\n    vowels = set('aeiouAEIOU')\n    \n    for i in range(len(word) - 2, 0, -1):\n        if word[i] not in vowels and word[i-1] in vowels and word[i+1] in vowels:\n            return word[i]\n    return \"\""
      ],
      [
        0.9320828318595886,
        "def get_first_consonant_flanked_vowel(word):\n    \"\"\"\n    Given a word, find the first vowel that is enclosed by consonants from the left side of the word (case sensitive). \n    Do not include vowels at the initiation or cessation of the word. \n    Return an empty string if no such vowel found. \n    The input string must only have English characters.\n\n    Example:\n    get_first_consonant_flanked_vowel(\"umbrella\") --> \"e\"\n    get_first_consonant_flanked_vowel(\"STRONG\") --> \"O\"\n    get_first_consonant_flanked_vowel(\"grape\") --> \"a\"\n    get_first_consonant_flanked_vowel(\"fly\") --> \"\"\n    \"\"\"\n    vowels = 'AEIOUaeiou'\n\n    for i in range(1, len(word) - 1):  # Skip first and last characters\n        if word[i] in vowels and word[i - 1] not in vowels:\n            return word[i]\n\n    return \"\"  # Return empty_string if no vowel found"
      ]
    ],
    "HumanEval/119": [
      [
        0.9470334053039551,
        "def match_parens(lst):\n    \"\"\"\n    Given a string, return 'Yes' if the string is a valid sequence of parentheses, and 'No' otherwise.\n\n    match_parens('()') => 'Yes'\n    match_parens('((()))') => 'Yes'\n    match_parens('((())') => 'No'\n    \"\"\"\n    s = ''.join(lst) # Concatenate the strings \n    stack = []\n    mapping = {')':'(', ']':'['}\n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if stack == [] or mapping[char] != stack.pop():\n                return 'No'\n    return 'Yes' if not stack else 'No'"
      ],
      [
        0.9416623711585999,
        "def match_parens(lst):\n    '''\n    This function returns 'Yes' if a valid string can be constructed by concatenating the strings\n    in the provided list. If it is not possible, it should return 'No'.\n    '''\n    opening_brackets = 0\n    for sub in lst:\n        for char in sub:\n            if char == '(':\n                opening_brackets += 1    # increment the count for opening bracket             \n            elif char == ')':\n                if opening_brackets == 0: \n                    return 'No'           # return 'No' if there is not matching opening bracket\n                opening_brackets -= 1     # decrement the count for closing bracket\n    return 'Yes' if opening_brackets == 0 else 'No'   # return 'No' if there is unpaired opening bracket"
      ],
      [
        0.9407490491867065,
        "def match_parens(lst):\n    \"\"\"\n    Given a string, return 'Yes' if parentheses are balanced, 'No' otherwise.\n    \n    >>> match_parens('()')\n    'Yes'\n    >>> match_parens('((()))')\n    'Yes'\n    >>> match_parens('((())')\n    'No'\n    >>> match_parens('(()')\n    'No'\n    \"\"\"\n    total = ''.join(lst)\n    stack = []\n\n    for char in total:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack: # no opening bracket to match with\n               return 'No'\n            stack.pop()  # remove one opening bracket\n\n    # if there are still opening brackets left in the stack then return 'No'\n    return 'Yes' if not stack else 'No'"
      ],
      [
        0.934323787689209,
        "def match_parens_and_brackets(lst):\n    \"\"\"\n    Given a list of strings, return \"Yes\" if all parentheses and brackets are matched, and \"No\" otherwise.\n    \n    For example, given the following list:\n    \n    [\"[\", \"(\", \")\", \"]\", \"{\", \"}\", \"(\"]\n    \n    The function should return \"No\", since the brackets are not matched.\n    \n    Given the following list:\n    \n    [\"[\", \"(\", \")\", \"]\", \"{\", \"}\", \"(\"]\n    \n    The function should return \"Yes\", since the brackets are matched.\n    \n    You may assume the\"\"\"\n    # create mapping of matched parentheses\n    brackets = {')': '(', ']': '['}\n    # join strings for easy processing\n    s = ''.join(lst)\n    # stack used to handle brackets\n    stack = []\n    \n    for char in s:\n        if char in brackets.values():\n            stack.append(char)\n        elif char in brackets.keys():\n            if stack == [] or brackets[char] != stack.pop():\n                return \"No\"\n    # if the stack is empty, all brackets were matched correctly\n    return \"Yes\" if stack == [] else \"No\""
      ],
      [
        0.9306803345680237,
        "def match_braces_parens_brackets(lst):\n    \"\"\"\n    Given a string, return 'Yes' if the brackets (), braces {}, and\n    parentheses [] are properly balanced. Otherwise, return 'No'.\n    \"\"\"\n    mapping = {'}': '{', ']': '[', ')': '('}\n    stack = []\n    for s in lst:\n        for c in s:\n            if c not in mapping:\n                stack.append(c)\n            elif not stack or stack.pop() != mapping[c]:\n                return 'No'\n    if stack:\n        return 'No'\n    return 'Yes'"
      ],
      [
        0.930337131023407,
        "def match_parens_brackets(lst):\n    \"\"\"\n    Given a string, return 'Yes' if the string is a valid sequence of parentheses, brackets and curly braces\n    'No' otherwise.\n\n    Ex:\n    match_parens_brackets(['(', ')']) == 'Yes'\n    match_parens_brackets(['(', ')', '(', ')']) == 'No'\n    match_parens_brackets(['(', ')', '(', ')', '{', '}', '[', ']', '[', ']']) == 'Yes'\n    \"\"\"\n    s = ''.join(lst)\n\n    stack = []\n    mapping = {')': '(', ']': '['}\n\n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if stack == [] or mapping[char] != stack.pop():\n                return 'No'\n        else:\n            return 'No'\n\n    if stack:\n        return 'No'\n    else:\n        return 'Yes'"
      ],
      [
        0.9241124391555786,
        "def intricate_nested_parentheses(lst):\n    \"\"\"\n    Given a list of strings, return 'Yes' if all strings in the list are valid parentheses,\n    and 'No' otherwise.\n    \n    >>> intricate_nested_parentheses(['((()))', '(()())', '((()))'])\n    'Yes'\n    >>> intricate_nested_parentheses(['((()))', '(()())', '((()))', '(()'])\n    'No'\n    \"\"\"\n    stack = []\n    for string in lst:\n        for char in string:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack or stack.pop() != '(':\n                    return 'No'\n    return 'Yes' if not stack else 'No'"
      ],
      [
        0.9219058752059937,
        "def match_braces(lst):\n    \"\"\"\n    Given a list of characters, return 'Yes' if the list contains a valid sequence of parentheses, or 'No' otherwise.\n    \n    Args:\n        lst (list): A list of characters.\n    \n    Returns:\n        str: 'Yes' if the list contains a valid sequence of parentheses, or 'No' otherwise.\n    \"\"\"\n    # Concatenate all the parentheses into a single string\n    opening_parentheses = ['(', '[']\n    closing_parentheses = [')', ']']\n    stack = []\n    s = ''.join(lst)\n    for i in s:\n        # If the character is an opening parentheses, push it onto the stack\n        if i in opening_parentheses:\n            stack.append(i)\n        # If the character is a closing parentheses, check if it matches with the last opening parentheses on the stack\n        elif i in closing_parentheses:\n            # If the stack is empty or there is no match, return 'No'\n            if not stack or opening_parentheses.index(stack.pop()) != closing_parentheses.index(i):\n                return 'No'\n    # If there are still unmatched opening parentheses in the stack, return 'No'\n    if stack:\n        return 'No'\n    return 'Yes'"
      ]
    ],
    "HumanEval/120": [
      [
        0.9450473785400391,
        "def find_max_k_numbers(arr, k):\n    \"\"\"\n    Find the k largest numbers in an array.\n    :type arr: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    arr.sort(reverse=True)\n    return arr[:k]"
      ],
      [
        0.934553861618042,
        "def top_k_elements(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    arr.sort()\n    return arr[-k:]"
      ],
      [
        0.9279983043670654,
        "def findKLargest(arr, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    arr.sort(reverse=True)\n    ans = []\n    for i in range(k):\n        ans.append(arr[i])\n    return ans"
      ],
      [
        0.9240082502365112,
        "def solution(arr, N):\n    \"\"\"\n    :type arr: List[int]\n    :type N: int\n    :rtype: List[int]\n    \"\"\"\n    # sorting the array in ascending order\n    arr.sort()\n    \n    # slicing the array to get N numbers\n    seq_order = arr[:N]\n    \n    return seq_order"
      ],
      [
        0.9235668182373047,
        "def top_k_largest(arr, k):\n    \"\"\"\n    Find the k largest elements in an array.\n    :param arr: List[int]\n    :param k: int\n    :return: List[int]\n    \"\"\"\n    return heapq.nlargest(k, arr)\n    \n    def top_k_largest(arr, k):\n    \"\"\"\n    Find the k largest elements in an array.\n    :param arr: List[int]\n    :param k: int\n    :return: List[int]\n    \"\"\"\n    return heapq.nlargest(k, arr)\n    \n    def top\"\"\"\n    return quickselect(arr, 0, len(arr) - 1, k)"
      ],
      [
        0.9202628135681152,
        "def kthLargest(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    arr.sort()\n    return arr[-k]"
      ]
    ],
    "HumanEval/121": [
      [
        0.9831711053848267,
        "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)"
      ],
      [
        0.9614441394805908,
        "def enhanced_solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are at even positions.    \n\n    Examples\n    enhanced_solution([5, 8, 7, 1]) => 5\n    enhanced_solution([3, 3, 3, 3, 3]) => 9\n    enhanced_solution([30, 13, 24, 321]) => 30\n    \"\"\"\n    return sum(num for i, num in enumerate(lst[::2]) if num % 2 == 1)"
      ],
      [
        0.9608632326126099,
        "def solution(lst):\n    \"\"\"\n    Given a list of integers, return the sum of all the elements that are odd indexed and odd.\n    \n    Args:\n        lst (list): list of integers\n    \n    Returns:\n        int: sum of odd indexed and odd elements\n    \"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 == 0 and val % 2 != 0)"
      ],
      [
        0.9389135241508484,
        "def sum_odd_numbers(lst):\n    \"\"\"\n    Given a list of numbers, return the sum of all odd numbers in the list.\n    \n    >>> sum_odd_numbers([1, 2, 7, -5])\n    9\n    \n    >>> sum_odd_numbers([1, 2, 8, 9, 10, 11, 12, 13, 14, 15])\n    26\n    \n    >>> sum_odd_numbers([])\n    0\n    \"\"\"\n    result = 0\n    for num in lst:\n        if num % 2 == 1:\n            result += num\n    return result"
      ]
    ],
    "HumanEval/122": [
      [
        0.8996666669845581,
        "def sum_of_first_three(arr, index=0):\n    \"\"\"\n    Given an array of integers, return the sum of the first three elements.\n    \n    If the array has fewer than three elements, return the sum of all elements.\n    \n    For example, given [1, 2, 3, 4], return 6.\n    \n    Given [1, 2], return 3.\n    \n    Given [1], return 1.\n    \n    Given [], return 0.\n    \"\"\"\n    if index >= len(arr):\n        return 0\n    \n    if index == 2:\n        return max(arr[index] + arr[index - 1] + arr[index - 2], 0)\n    \n    return arr[index] + sum_of_first_three(arr, index + 1)"
      ],
      [
        0.8964042663574219,
        "def sum_three_digits(arr):\n    \"\"\"\n    Given an array of integers, return the sum of all the three digit numbers in the array\n    \n    >>> sum_three_digits([123, 456, 789, 10, 11, 12])\n    123 + 456 + 789 = 1368\n    \"\"\"\n    total = 0\n    for num in arr:\n        if len(str(num)) == 3:\n            total += num\n    return total"
      ],
      [
        0.8953759670257568,
        "def max_sum_under_k(nums, k):\n    \"\"\"\n    Find the maximum sum of two elements in a list under a given value k.\n    :param nums: a list of integers\n    :param k: an integer\n    :return: an integer\n    \"\"\"\n    max_sum = -1\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            _sum = nums[i] + nums[j]\n            if _sum < k and _sum > max_sum:\n                max_sum = _sum\n    return max_sum"
      ],
      [
        0.8951952457427979,
        "def compute_sum_of_max_digits(arr, K):\n    \"\"\"\n    Compute the sum of the maximum digits in the array.\n    \n    Args:\n        arr (list): The input array.\n        K (int): The number of maximum digits to consider.\n    \n    Returns:\n        int: The sum of the maximum digits in the array.\n    \"\"\"\n    if K > len(arr):\n        return -1\n    \n    if all(num <= 0 for num in arr):\n        return 0\n    \n    arr.sort()\n    max_sum = 0\n    num_of_zeros = 0\n    \n    for num in arr:\n        if num == 0:\n            num_of_zeros += 1\n        elif num < 0:\n            break\n        else:\n            max_sum += num\n            K -= 1\n            if K == 0:\n                break\n    \n    if num_of_zeros >= K:\n        return 0\n    \n    if K > 0:\n        return -1\n    \n    return max_sum"
      ],
      [
        0.8946809768676758,
        "def sum_base(n: int, k: int) -> int:\n    \"\"\"\n    Given a positive integer n written in base k, return the sum of its digits.\n    \n    Example 1:\n    \n    Input: n = 34, k = 6\n    Output: 7\n    Explanation: 34 (base 6) = 5 + 4 = 9, so the result should be 5 + 4 = 9.\n    \n    Example 2:\n    \n    Input: n = 10, k = 10\n    Output: 1\n    Explanation: 10 (base 10\"\"\"\n    s = 0\n    while n:\n        s += n % k\n        n //= k\n    return s"
      ],
      [
        0.8911867141723633,
        "def sum_smallest_three(arr):\n    \"\"\"\n    Given an array of integers, return the sum of the three smallest numbers.\n    \n    >>> sum_smallest_three([1, 2, 3, 4, 5])\n    6\n    >>> sum_smallest_three([1, 1, 1])\n    3\n    >>> sum_smallest_three([1, 2, 3, 4, 5, 6])\n    6\n    >>> sum_smallest_three([1, 2, 3, 4, 5, 6, 7])\n    9\n    \"\"\"\n    if len(arr) < 3:\n        return sum(arr)\n    smallest_nums = [float('inf')] * 3\n    for num in arr:\n        if num < smallest_nums[2]:\n            smallest_nums = sorted(smallest_nums[:-1] + [num])\n    return sum(smallest_nums)"
      ],
      [
        0.8909388780593872,
        "def sum_last_digits(lst):\n    \"\"\"\n    Given a list of numbers, return the sum of the last digits.\n    \n    >>> sum_last_digits([2, 3, 4])\n    9\n    >>> sum_last_digits([13, 22, 14])\n    9\n    \"\"\"\n    ans = 0\n    for num in lst:\n        ans += int(num[-1])\n    return ans"
      ]
    ],
    "HumanEval/123": [
      [
        0.9223209023475647,
        "def getOddCollatz(n):\n    \"\"\"\n    Function to get odd numbers in the Collatz sequence of n\n    \"\"\"\n    collatz = collatzSequence(n)\n    collatz = [i for i in collatz if i % 2 != 0]\n    collatz.sort()\n    return collatz\n    \n    def getPrimeCollatz(n):\n    \"\"\"\n    Function to get prime numbers in the Collatz sequence of n\n    \"\"\"\n    # Function to get prime numbers in the Collatz sequence of n\n    collatz = collatzSequence(n)\n    primes = generatePrimes(max(collatz))\n    collatz = [i for i in collatz if i in primes]\n    collatz.sort()\n    return collatz"
      ],
      [
        0.9133251905441284,
        "def collatz(n):\n    \"\"\"\n    Returns the Collatz sequence starting at n and ending at 1.\n    \n    >>> collatz(1)\n    [1]\n    >>> collatz(5)\n    [5, 16, 8, 4, 2, 1]\n    >>> collatz(10)\n    [10, 5, 16, 8, 4, 2, 1]\n    \"\"\"\n    sequence = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        sequence.append(n)\n    return sequence"
      ],
      [
        0.9110569953918457,
        "def collatz(n):\n    \"\"\"\n    Return a tuple (sequence, steps) where sequence is a list of integers\n    and steps is the number of steps to reach 1.\n    \"\"\"\n    collatz_dict = {1: ([1], 0)}\n    if n == 1:\n        return collatz_dict[1]\n    else:\n        return collatz_helper(n)\n    \n    def collatz_helper(n):\n    \"\"\"\n    Return a tuple (sequence, steps) where sequence is a list of integers\n    and steps is the number of steps to reach 1.\"\"\"\n    if n not in collatz_dict:\n        if n % 2 == 0:\n            sequence, steps = collatz(n//2)\n            collatz_dict[n] =  ([n] + sequence, steps + 1)\n        else:\n            sequence, steps = collatz(3*n + 1)\n            collatz_dict[n] =  ([n] + sequence, steps + 1)\n    return collatz_dict[n]"
      ],
      [
        0.9094589352607727,
        "def collatz(n):\n    \"\"\"\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined as follows:\n\n    start with any positive integer n\n    if n is even, divide n by 2 to get n / 2\n    if n is odd, multiply n by 3 and add 1, to get 3n + 1\n    continue this process indefinitely\n    The conjecture is that no matter what value of n, the sequence will reach 1.\n\n    Implement a function collatz() that takes in one integer argument n and returns the number of steps required to reach 1.\n    \"\"\"\n    steps = 0\n    highest_number = n\n    while n != 1:\n        print(n)\n        if n % 2 == 0:\n            n /= 2\n        else:\n            n = 3*n + 1\n        if n > highest_number:\n            highest_number = n\n        steps += 1\n    print(n)\n    return steps, highest_number"
      ],
      [
        0.9055607914924622,
        "def collatz(n):\n    \"\"\"\n    Return the collatz sequence starting at n and ending at 1.\n    \n    Args:\n        n (int): Starting value of the collatz sequence.\n    \n    Returns:\n        list: Collatz sequence starting at n and ending at 1.\n    \n    Raises:\n        TypeError: If n is not an integer.\n        ValueError: If n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    elif n <=0:\n        raise ValueError(\"Input must be a positive integer.\")\n    else:\n        sequence = []\n        while n != 1:\n            sequence.append(n)\n            n = n / 2 if n % 2 == 0 else 3*n + 1\n        sequence.append(1)\n\n    return sequence"
      ]
    ],
    "HumanEval/124": [
      [
        0.9189660549163818,
        "def validDate(date): \n    \"\"\"\n    Check if the date is valid\n    :param date: date to check\n    :return: True if the date is valid, False otherwise\n    \"\"\"\n    # Regex to check valid date format \n    regex = r\"^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-[0-9]{4}$\"\n    p = re.compile(regex) \n  \n    # If the date is not matched with regex \n    if(re.search(p, date) == None): \n        return False\n    else: \n        mm,dd,yyyy = map(int,date.split('-'))\n         \n        if is_leap_year(yyyy) and mm==2 and dd>29:\n            return False\n        if not is_leap_year(yyyy) and mm==2 and dd>28:\n            return False\n        if dd>monthrange(yyyy,mm)[1]:\n            return False\n        return True"
      ],
      [
        0.9145088195800781,
        "def validate(date): \n    \"\"\"\n    Check if the date is valid or not\n    :param date: date to validate\n    :return: True if date is valid else False\n    \"\"\"\n    # Regex to check valid date format \n    regex_= \"^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-[0-9]{4}$\"\n    p = re.compile(regex)\n\n    # If the date is not matched with regex \n    if(re.search(p, date) == None): \n        return False\n    else: \n        mm,dd,yyyy = map(int,date.split('-'))\n\n        if is_leap_year(yyyy) and mm==2 and dd>29:\n            return False\n        if not is_leap_year(yyyy) and mm==2 and dd>28:\n            return False\n        if dd>monthrange(yyyy,mm)[1]:\n            return False\n        return True"
      ]
    ],
    "HumanEval/125": [
      [
        0.8996844291687012,
        "def count_words(lst):\n    \"\"\"Count the number of words in a list of strings.\n    \n    >>> count_words(['hello', 'world'])\n    2\n    >>> count_words(['hello', 'world', 'hello'])\n    3\n    >>> count_words(['hello', 'world', 'hello', 'world'])\n    4\n    >>> count_words(['hello', 'world', 'hello', 'world', 'hello'])\n    5\n    >>> count_words(['hello', 'world', 'hello', 'world', 'hello', 'world'])\n    6\n    >>> count_words(['hello', '\"\"\"\n    return sum(1 for item in lst if item.startswith('a'))"
      ],
      [
        0.8970270156860352,
        "def count_words(s):\n    \"\"\"\n    Count the number of words in a string.\n    \n    >>> count_words(\"Hello, world!\")\n    2\n    >>> count_words(\"Hi\")\n    1\n    \"\"\"\n    words = s.split(' ')\n    count = 0\n    for word in words:\n        if word != '':\n            count += 1\n    return count"
      ],
      [
        0.8968707323074341,
        "def parse_details(s):\n    '''\n    Given a string s, split it into a list of words divided by either a comma or a colon. \n    If neither exist, return the total count of lower-case alphabetic characters that \n    have an odd ASCII value in the string.\n    '''\n    if ',' in s:\n        return s.split(',')\n    elif ':' in s:\n        return s.split(':')\n    else:\n        return len([i for i in s if i.islower() and ord(i) % 2 == 1])"
      ]
    ],
    "HumanEval/126": [
      [
        0.9436646699905396,
        "def is_sorted(lst):\n    \"\"\"\n    Returns True if the list is sorted in ascending order and False otherwise.\n    \n    >>> is_sorted([1, 2, 2])\n    True\n    >>> is_sorted(['b', 'a'])\n    False\n    \"\"\"\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True"
      ],
      [
        0.9436306953430176,
        "def is_sorted(lst):\n    \"\"\"\n    Returns True if the list is sorted in ascending order and False otherwise.\n    \n    >>> is_sorted([1, 2, 2])\n    True\n    >>> is_sorted(['b', 'a'])\n    False\n    \"\"\"\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True"
      ],
      [
        0.9406965970993042,
        "def is_sorted(lst):\n    \"\"\"\n    Returns True if the list is sorted in ascending order and False otherwise.\n    \n    >>> is_sorted([1, 2, 2])\n    True\n    >>> is_sorted(['b', 'a'])\n    False\n    \"\"\"\n    return all(lst[i] <= lst[i + 1] for i in range(len(lst) - 1))"
      ],
      [
        0.9313151836395264,
        "def is_sorted_asc(lst):\n    \"\"\"\n    Return True if the given list is sorted in ascending order and False otherwise.\n    \n    >>> is_sorted_asc([1, 2, 2])\n    True\n    >>> is_sorted_asc([2, 1, 2])\n    False\n    >>> is_sorted_asc([1, 2, 3])\n    True\n    >>> is_sorted_asc([3, 2, 1])\n    False\n    \"\"\"\n    return all(a <= b for a, b in zip(lst, lst[1:]))"
      ],
      [
        0.9303023815155029,
        "def is_sorted(arr):\n    \"\"\"\n    Returns True if the given array is sorted in ascending order.\n    \n    >>> is_sorted([1, 2, 2])\n    True\n    >>> is_sorted(['b', 'a'])\n    False\n    \"\"\"\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return False\n    return True"
      ],
      [
        0.929305374622345,
        "def is_sorted_ascending(numbers):\n    \"\"\"\n    Check if a list of numbers is sorted in ascending order.\n    \"\"\"\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i+1]:\n            return False\n    return True\n    def is_sorted_ascending(numbers):\n    \"\"\"\n    Check if a list of numbers is sorted in ascending order.\n    \"\"\"\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i+1]:\n            return False\n    return True"
      ],
      [
        0.926800012588501,
        "def is_sorted(lst):\n    \"\"\"\n    Check if a list is sorted in ascending order.\n\n    Args:\n        lst (list): The list to be checked.\n\n    Returns:\n        bool: True if the list is sorted, False otherwise.\n    \"\"\"\n    # Base case: if the list is empty, it is considered sorted\n    if not lst:\n        return True\n\n    # Compare the first two elements\n    if lst[0] > lst[1]:\n        return False\n\n    # Recursively call the function with the remaining elements in the list\n    return is_sorted(lst[1:])"
      ],
      [
        0.9266473054885864,
        "def is_sorted_ascending(nums):\n   \"\"\"\n   Return True if the given list of numbers is sorted in ascending order.\n   :param nums: a list of integers\n   :return: True if the given list is sorted in ascending order\n   \"\"\"\n   return all(nums[i] <= nums[i+1] for i in range(len(nums)-1))\n    def is_sorted_ascending(nums):\n   \"\"\"\n   Return True if the given list of numbers is sorted in ascending order.\n   :param nums: a list of integers\n   :return: True if the given list is sorted in ascending order\n   \"\"\"\n   return all(nums[i] <= nums[i+1] for i in range(len(nums)-1))"
      ],
      [
        0.9261072874069214,
        "def is_sorted(lst):\n    \"\"\"\n    Check if a list is sorted in ascending order.\n    \n    Args:\n        lst (list): The list to be checked.\n    \n    Returns:\n        bool: True if the list is sorted in ascending order, False otherwise.\n    \"\"\"\n    # Check if the list is empty or has only one element\n    if len(lst) <= 1:\n        return True\n    \n    # Check if the list contains any duplicates\n    if len(lst) != len(set(lst)):\n        return False\n    \n    # Check if the list is sorted in ascending order\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i+1]:\n            return False\n    \n    return True"
      ]
    ],
    "HumanEval/127": [
      [
        0.898186445236206,
        "def prime_numbers(start, end):\n    \"\"\"\n    Returns a list of prime numbers between start and end (inclusive).\n    \"\"\"\n    def is_prime(n):\n        \"\"\"\n        Returns True if n is a prime number, False otherwise.\n        \"\"\"\n        if n < 2:\n            return False\n        for i in range(2, n):\n            if n % i == 0:\n                return False\n        return True\n    \"\"\"\n    # Base case\n    if start > end:  \n        return []\n    else:\n        # Recursive case\n        if is_prime(start):  \n            return [start] + prime_numbers(start + 1, end) \n        else:  \n            return prime_numbers(start + 1, end)"
      ],
      [
        0.8955169916152954,
        "def prime_numbers(x, y, z):\n    \"\"\"\n    Find all prime numbers between x and y.\n    If z is True, include x and y in the list.\n    If z is False, exclude x and y from the list.\n    \"\"\"\n    def is_prime(num):\n        \"\"\"\n        Check if a number is prime.\n        \"\"\"\n        if num < 2:\n            return False\n        for i in range(2, num):\n            if num % i == 0:\n                return False\n        return True\n    \"\"\"\n    primes = []\n    if z:\n        if is_prime(x):\n            primes.append(x)\n        if is_prime(y):\n            primes.append(y)\n    else:\n        x += 1\n        y -= 1\n    for num in range(x, y + 1):\n        if is_prime(num):\n            primes.append(num)\n    return primes"
      ]
    ],
    "HumanEval/128": [
      [
        0.957078218460083,
        "def prod_signs(arr):\n    \"\"\"\n    Given an array of integers, return the product of the magnitudes of all prime numbers in the array, multiplied by the sign of the sum of all prime numbers in the array.\n    \n    If there are no prime numbers in the array, return None.\n    \n    The sign of a number is:\n    \n    1 if the number is positive\n    -1 if the number is negative\n    0 if the number is 0\n    \n    Examples\n    prod_signs([1, 2, 3, 4]) \u279e 6\n    \n    prod_signs([1\"\"\"\n    unique_primes = set()\n    for i in arr:\n        if is_prime(abs(i)):\n            unique_primes.add(i)\n    if not unique_primes:\n        return None\n    summed_magnitudes = sum(abs(x) for x in unique_primes)\n    multiplied_signs = sign(sum(sign(x) for x in unique_primes))\n    return summed_magnitudes * multiplied_signs"
      ],
      [
        0.9558929204940796,
        "def prod_signs(arr):\n    \"\"\"\n    Given an array arr made up of non-zero integers (size between 1 to 500), return the product of the signs (represented as 1, -1, or 0) of all unique digits and the sum of their corresponding absolute values. If arr is empty or contains values greater than 500, return None.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == None\n    >>> prod_signs([]) == None\n    >>> prod_signs([501, 1]) == None\n    \"\"\"\n    if not arr or len(arr) > 500 or any(abs(x) > 500 for x in arr):\n        return None\n\n    arr = [x for x in arr if x != 0]  # remove zero\n    unique_arr = list(set(arr))  # remove duplicates\n\n    sign_product = 1\n    sum_ = 0\n\n    for x in unique_arr:\n        sign_product *= (1 if x > 0 else -1)\n        sum_ += abs(x)\n\n    return sign_product * sum_"
      ],
      [
        0.9527512788772583,
        "def prod_signs(arr):\n    \"\"\"\n    Given an array of integers, return the product of all the elements in the array,\n    ignoring any zeros. If there are no non-zero elements, return None.\n    \n    >>> prod_signs([1, 2, 3, 4])\n    12\n    >>> prod_signs([1, 2, 0, 4])\n    None\n    >>> prod_signs([0, 0, 0, 0])\n    None\n    >>> prod_signs([0, 1, 2, 3])\n    None\n    <|file_separator|>\"\"\"\n    if not arr or 0 in arr:\n        return None\n\n    distinct_arr = list(set(arr))\n    signs_prod = 1\n\n    for num in distinct_arr:\n        signs_prod *= (1 if num > 0 else -1)\n\n    sum_abs = sum(abs(num) for num in distinct_arr)\n\n    return signs_prod * sum_abs"
      ],
      [
        0.9524534940719604,
        "def prod_signs(arr):\n    \"\"\"\n    Given an array of integers, return the product of all the signs of the numbers in the array.\n    \n    For example, given the array [1, -2, 3, -4], return -24.\n    \n    You can assume the array will not be empty.\n    \"\"\"\n    primes = [x for x in arr if is_prime(abs(x))]\n    if not primes: return None\n    sums = sum(abs(p) * (1 if p > 0 else -1) for p in set(primes))\n    return sums"
      ],
      [
        0.9488802552223206,
        "def prod_signs(arr):\n\"\"\"\n    This function calculates the product of all elements in an array.\n    \n    Parameters:\n    arr (list): The input array.\n    \n    Returns:\n    int or None: The product of all elements in the array, or None if the array is empty or contains a zero.\n    \n    Example:\n    >>> prod_signs([1, 2, 3, 4, 5])\n    120\n    >>> prod_signs([1, -2, 3, -4, 5])\n    -120\n    >>> prod_signs\"\"\"\n\n    if not arr:  # condition for empty array\n        return None\n    \n    val, sign = 0,1\n\n    for num in arr:\n        if num == 0:  # condition for existence of zero in array\n            return None\n        else:   # calculate sum of values multiplied by sign.\n            val += abs(num)*(1 if num>0 else -1)\n    return val "
      ],
      [
        0.9485249519348145,
        "def prod_signs(arr):\n    \"\"\"\n    Given an array of integers, return the product of all the elements in the array.\n    If the array is empty, return None.\n    If the array contains a zero, return 0.\n    \"\"\"\n    # Write your code here\n    \"\"\"\n    Given an array of integers, return the product of all the elements in the array.\n    If the array is empty, return None.\n    If the array contains a zero, return 0.\n    \"\"\"\n    if not arr:  # check for empty list\n        return None\n\n    if 0 in arr:  # check if the array contains a zero\n        return None\n\n    signs = 1\n    unique_set = set()\n\n    for num in arr:\n        # convert to absolute\n        abs_num = abs(num)\n\n        # calculate product of unique abosultes\n        if abs_num not in unique_set:\n            unique_set.add(abs_num)\n            signs = signs * abs_num if num > 0 else -1 * signs * abs_num\n\n    return signs"
      ],
      [
        0.9473488330841064,
        "def prod_signs(arr):\n    \"\"\"\n    Given an array of integers, return the product of distinct signs of the array elements and sum of distinct absolute values of the array elements.\n    If the array contains 0, return None.\n    \n    Args:\n        arr (list): An array of integers.\n    \n    Returns:\n        int: The product of distinct signs of the array elements and sum of distinct absolute values of the array elements.\n    \"\"\"\n    if not arr: return None\n    distinct_signs_product = 1  # initial product of distinct signs\n    distinct_absolute_sums = 0  # initial sum of distinct absolute values\n    distinct_elements = set()  # a set to keep track of encountered distinct elements\n\n    for n in arr:\n        if n == 0:  # ignore 0 as per requirement\n            return None  # whenever a 0 is encountered, the function should return None as per requirement\n        absolute_value = abs(n)  # absolute value of the current number\n        if absolute_value in distinct_elements:\n            continue  # if this absolute value has been encountered before, ignore it\n        distinct_elements.add(absolute_value)  # mark this absolute value as encountered\n        sign = n/absolute_value  # sign of the current number\n        distinct_signs_product *= sign  # update the product of distinct signs\n        distinct_absolute_sums += absolute_value  # update the sum of distinct absolute values\n      \n    return distinct_signs_product*distinct_absolute_sums  # return the product as per requirement"
      ],
      [
        0.9464897513389587,
        "def prod_signs(arr):\n    \"\"\"\n    Given an array of integers, return the product of all the elements in the array.\n    If the array is empty, return None.\n    If any of the elements is not an integer, return None.\n    If any of the elements is a string, return None.\n    If any of the elements is a list, flatten it and multiply the elements.\n    If any of the elements is a tuple, flatten it and multiply the elements.\n    If any of the elements is a set, flatten it and multiply the elements.\n    If any of the elements is a dictionary, flatten it and multiply\"\"\"\n    if not arr or not all(isinstance(i, (int, list)) for i in arr):\n        return None\n    flat_arr = flatten(arr)\n    if any(isinstance(i, str) for i in flat_arr):\n        return None\n    unique_values = set(abs(i) for i in flat_arr if i != 0)\n    total = sum(unique_values)\n    sign = multiply_signs(flat_arr)\n    return None if 0 in flat_arr else total * sign"
      ],
      [
        0.9461845755577087,
        "def prod_signs(arr):\n    \"\"\"\n    Given an array of integers, return the product of all the elements.\n    \n    You can assume that the array is not empty.\n    \n    Example 1:\n    \n    Input: [1, 2, 3, 4, 5]\n    Output: 120\n    \n    Example 2:\n    \n    Input: [2, 5, 0, 3]\n    Output: 0\n    \n    Example 3:\n    \n    Input: [1, 2, 3, 4, 5]\"\"\"\n    if len(arr) == 0 or (len(arr) == 1 and arr[0] == 0):\n        return None\n    \n    result = 0\n    total_sign = 1\n    seen = set()\n    \n    for num in arr:\n        if num != 0:\n            sign = 1 if num > 0 else -1\n            total_sign *= sign\n            seen.add(abs(num))\n            \n    result = total_sign * sum(seen)\n    return result"
      ],
      [
        0.9442607760429382,
        "def prod_signs(arr):\n    \"\"\"\n    Given an array of integers, return the product of the signs of the numbers\n    and the sum of the absolute values of the numbers.\n    \n    Parameters\n    ----------\n    arr : list\n        The array of integers.\n    \n    Returns\n    -------\n    int\n        The product of the signs of the numbers and the sum of the absolute\n        values of the numbers.\n    \"\"\"\n    if not arr:  # returns None if array 'arr' is empty\n        return None\n    arr = list(set([i for i in arr if i != 0]))  # remove duplicates and zeros\n    if not arr:  # returns None if array 'arr' is empty after removing zeros\n        return None\n\n    sign_product = 1  # initialize the product of signs\n    abs_val_sum = 0  # initialize the summation variable\n\n    for i in arr:\n        sign_product *= (-1 if i < 0 else 1)  # compute the product of signs\n        abs_val_sum += abs(i)  # compute the sum of absolute values\n\n    return sign_product * abs_val_sum  # return the final result"
      ]
    ],
    "HumanEval/129": [
      [
        0.9429476857185364,
        "def minPath(grid, k):\n    \"\"\"\n    :type grid: List[List[int]]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    n = len(grid)\n    visited = set()\n    heap = [(grid[0][0], 0, 0)]\n    res = []\n\n    while len(res) < k:\n        val, x, y = heapq.heappop(heap)\n        if (x, y) not in visited:\n            res.append(val)\n            visited.add((x, y))\n\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n\n    return sorted(res)"
      ],
      [
        0.9407023191452026,
        "def minPath(grid, k):\n    \"\"\"\n    :type grid: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    n = len(grid)\n    \n    # Convert grid into priority queue with cell value as priority\n    pq = PriorityQueue()\n    for i in range(n):\n        for j in range(n):\n            pq.put((grid[i][j], (i, j)))\n    \n    # Get smallest k paths from priority queue\n    smallest_k_paths = []\n    for _ in range(k):\n        _, (i, j) = pq.get()\n        \n        # Perform BFS from this point to find shortest path\n        visited = [[False]*n for _ in range(n)]\n        visited[i][j] = True\n        q = deque([(i, j, [grid[i][j]])])\n        while q:\n            x, y, path = q.popleft()\n            \n            # If path length is k, add it to smallest_k_paths and break\n            if len(path) == k:\n                smallest_k_paths.append(sorted(path))\n                break\n            \n            # Visit all directions in counter-clockwise order\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if isValid(nx, ny, n) and not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    q.append((nx, ny, path + [grid[nx][ny]]))\n    \n    return smallest_k_paths"
      ],
      [
        0.9406327605247498,
        "def minPath(grid, k):\n    \"\"\"\n    :type grid: List[List[int]]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    n = len(grid)\n    directions = [(-1,0), (0,-1), (1,0), (0,1)]\n    q, visited = [(grid[0][0], 0, 0)], set((0,0))\n    res = []\n\n    while len(res) < k and q:\n        dist, x, y = heapq.heappop(q)\n        res.append(dist)\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                heapq.heappush(q, (grid[nx][ny], nx, ny))\n\n    return sorted(res)[:k]"
      ],
      [
        0.9404962062835693,
        "def minPath(grid, k):\n    \"\"\"\n    :type grid: List[List[int]]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    # size of the grid\n    N = len(grid)\n    # Priority Queue\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n\n    # iterating over all the elements in Priority Queue\n    while minheap:\n        cost, i, j, path = heapq.heappop(minheap)\n        # checking if the path size is k\n        if len(path) == k:\n            return path[:k]\n        # checking all the neighbors of the current node\n        for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n            if 0 <= x < N and 0 <= y < N and (x, y) not in visited:\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
      ],
      [
        0.9404431581497192,
        "def minPath(grid, k):\n    \"\"\"\n    :type grid: List[List[int]]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    pq, path, visited, result = [], [], set(), []\n    n = len(grid)\n    # start from the left top cell\n    pq.append((grid[0][0], 0, 0))\n    while pq:\n        val, x, y = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            # if we have visited 'k' cells, stop\n            if len(path) == k:\n                return path\n            # move to neighboring cells\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_x, new_y = x + dx, y + dy\n                # check if the new cell is within grid boundaries\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    # add new cell to the priority queue\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    # if the entire grid is traversed but we still have not visited 'k' cells,\n    # return the path so far\n    return path"
      ],
      [
        0.940376877784729,
        "def minPath(grid, k):\n    \"\"\"\n    :type grid: List[List[int]]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    pq, path, visited, result = [], [], set(), []\n    n = len(grid)\n    # start from the left top cell\n    pq.append((grid[0][0], 0, 0))\n    while pq:\n        val, x, y = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            # if we have visited 'k' cells, stop\n            if len(path) == k:\n                return path\n            # move to neighboring cells\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_x, new_y = x + dx, y + dy\n                # check if the new cell is within grid boundaries\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    # add new cell to the priority queue\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    # if the entire grid is traversed but we still have not visited 'k' cells,\n    # then return the path so far\n    return path"
      ],
      [
        0.9403154850006104,
        "def minPath(grid, k):\n    \"\"\"\n    :type grid: List[List[int]]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    N = len(grid)\n    dists = [[float('inf')] * N for _ in range(N)]\n    spanned = [[False] * N for _ in range(N)]\n    moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(grid[0][0], 0, 0)]\n    \n    while pq:\n        d, r, c = heapq.heappop(pq)\n        if spanned[r][c]:\n            continue\n        spanned[r][c] = True\n        dists[r][c] = d\n        for move in moves:\n            nr, nc = r + move[0], c + move[1]\n            if 0 <= nr < N and 0 <= nc < N and not spanned[nr][nc]:\n                heapq.heappush(pq, (d + grid[nr][nc], nr, nc))\n                \n    path_values = sorted([val for sublist in dists for val in sublist])[:k]\n    return path_values"
      ],
      [
        0.9403022527694702,
        "def minPath(grid,k):\n    \"\"\"\n    :type grid: List[List[int]]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    if not grid or len(grid) == 0:\n        return []\n\n    N = len(grid)\n    M = len(grid[0])\n    if k < N * M:\n        return []\n\n    dp = [[0 for _ in range(N)] for __ in range(M)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, N):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for i in range(1, M):\n        dp[0][i] = dp[0][i - 1] + grid[0][i]\n\n    for i in range(1, M):\n        for j in range(1, N):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    \n    path = []\n    i, j= M - 1, N - 1\n    while len(path) < k:\n        path.append(grid[i][j])\n        if i > 0 and j > 0:\n            if dp[i - 1][j] < dp[i][j - 1]:\n                i -= 1\n            else:\n                j -= 1\n        elif i > 0:\n            i -= 1\n        elif j > 0:\n            j -= 1\n        else:\n            break\n\n    return sorted(path)"
      ],
      [
        0.9387074708938599,
        "def minPath(grid, k):\n    \"\"\"\n    :type grid: List[List[int]]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        sum_, x, y, path = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
      ],
      [
        0.9382081031799316,
        "def pathFinder(grid, k):\n    \"\"\"\n    :type grid: List[List[int]]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    n = len(grid)\n    directions = [(0,1), (0,-1), (1,0), (-1,0), (-1,-1), (-1,1), (1,-1), (1,1)]\n    heap = [(grid[0][0], 0, 0)]\n    visit = [[0 for _ in range(n)] for _ in range(n)]\n    visit[0][0] = 1\n    cell_values = []\n\n    while heap:\n        value, x, y = heapq.heappop(heap)\n        cell_values.append(value)\n        if len(cell_values) == k:\n            break\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < n and not visit[nx][ny]:\n                visit[nx][ny] = 1\n                heapq.heappush(heap, (grid[nx][ny], nx, ny))\n\n    return sorted(cell_values[:k])"
      ]
    ],
    "HumanEval/130": [
      [
        0.9431739449501038,
        "def tri(n):\n    \"\"\"\n    Returns the first n terms of the tribonacci sequence.\n    \n    Args:\n        n (int): number of terms to return\n    \n    Returns:\n        list: first n terms of the tribonacci sequence\n    \"\"\"\n    sequence = []\n    if n < 0:\n        return sequence\n    if n >= 0:\n        sequence.append(3)\n    if n >= 2:\n        sequence.append(2)\n    if n >= 3:\n        sequence.append(sequence[-2] + sequence[-1] + 1)\n    for i in range(4, n+1):\n        if i%2==0:\n            sequence.append(1 + i // 2)\n        else:\n            sequence.append(sequence[-2] + sequence[-1] + sequence[-3])\n    return sequence"
      ],
      [
        0.9394316673278809,
        "def tribonacci(n):\n    \"\"\"\n    The tribonacci sequence is a generalization of the Fibonacci sequence where each number is the sum of the three previous ones.\n    The first three numbers are 0, 0, 1.\n    The next numbers are calculated like this:\n    tribonacci(n) = tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3)\n    The function tribonacci(n) should return the nth number of the tribonacci sequence.\n    For example:\n    tribonacci(1) = 0\n    tri\"\"\"\n    sequence = [0, 0, 1]\n    while len(sequence) < n + 1:\n        sequence.append(sum(sequence[-3:]))\n    return sequence[n]"
      ],
      [
        0.9270888566970825,
        "def tribonacci(n: int) -> int:\n    \"\"\"\n    The Tribonacci sequence Tn is defined as follows: \n    T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n    Given n, return the value of Tn.\n    \n    Example 1:\n    Input: n = 4\n    Output: 4\n    Explanation:\n    T_3 = 0 + 1 + 1 = 2\n    T_4 = 1 + 1 + 2 = 4\n    \n\"\"\"\n    if n == 0: return 0\n    if n == 1 or n == 2: return 1\n    a, b, c = 0, 1, 1\n    for _ in range(3, n + 1):\n        a, b, c = b, c, a + b + c\n    return c"
      ],
      [
        0.9240311980247498,
        "def tribonacci(n: int, memo = {}):\n    \"\"\"\n    The Tribonacci sequence adheres to the following rules:\n    tribonacci(0) = 0\n    tribonacci(1) = 1\n    tribonacci(2) = 1\n    tribonacci(n) = tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3) for n > 2\n    tribonacci(n) = tribonacci(n+3) - tribonacci(n+2) - tribonacci(n+1) for n < 0\n\n    Apply dynamic programming and cache intermediate results using memoization for optimization.\n    >>> tribonacci(1)\n    1\n    >>> tribonacci(5)\n    7\n    >>> tribonacci(8)\n    44\n    >>> tribonacci(-1)\n    1\n    >>> tribonacci(-5)\n    -7\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    elif n == 0:\n        return 0\n    elif n == 1 or n == 2:\n        return 1\n    elif n < 0:\n        result = tribonacci(n + 3, memo) - tribonacci(n + 2, memo) - tribonacci(n + 1, memo)\n    else:\n        result = tribonacci(n - 1, memo) + tribonacci(n - 2, memo) + tribonacci(n - 3, memo)\n        \n    memo[n] = result\n    return result"
      ],
      [
        0.9239284992218018,
        "def fibonacci_three(n):\n    \"\"\"\n    Return the first n numbers in the fibonacci sequence.\n    \n    >>> fibonacci_three(10)\n    [0, 1, 1, 2, 4, 7, 13, 24, 44, 81]\n    \"\"\"\n    # handle base cases\n    if n<1:\n        return []\n    if n==1:\n        return [0]\n    if n==2:\n        return [0, 1]\n    if n==3:\n        return [0, 1, 1]\n\n    #generate the sequence\n    sequence = [0, 1, 1]\n    for i in range(3, n):\n        sequence.append(sequence[i-1] + sequence[i-2] + sequence[i-3]) \n\n    return sequence"
      ]
    ],
    "HumanEval/131": [
      [
        0.9347140789031982,
        "def product_of_digits(n):\n    \"\"\"\n    Given an integer n, return the product of all digits in the number.\n    \n    >>> product_of_digits(1234)\n    24\n    >>> product_of_digits(402)\n    8\n    >>> product_of_digits(123456789)\n    0\n    >>> product_of_digits(0)\n    0\n    \"\"\"\n    product = 1\n    if n > 0:\n        while n != 0:\n            digit = n % 10\n            product *= digit\n            n = n // 10\n    return product"
      ],
      [
        0.9339938759803772,
        "def product_of_digits(n):\n    \"\"\"\n    Given an integer n, return the product of all digits in the number.\n    \n    >>> product_of_digits(1234)\n    24\n    >>> product_of_digits(402)\n    8\n    >>> product_of_digits(123456789)\n    0\n    >>> product_of_digits(0)\n    0\n    \"\"\"\n    product = 1\n    while n > 0:\n        digit = n % 10\n        product *= digit\n        n //= 10\n    return product"
      ],
      [
        0.9312758445739746,
        "def digits(n):\n    \"\"\"\n    Given an integer n, return the sum of the digits of n that are odd.\n    If the sum is greater than or equal to 10, then return the sum of the digits of the new number.\n    Keep repeating this process until the new number has only 1 digit.\n    \n    Example 1:\n    Input: n = 3456\n    Output: 5\n    Explanation: \n    The sum of the digits of n is 18. Since 18 >= 10, the sum of the digits of 18 is 9.\"\"\"\n    n = [int(i) for i in str(n)]\n    odd = [i for i in n if i % 2 != 0]\n    even = [i for i in n if i % 2 == 0]\n\n    if len(odd) == 0:  # all digits are even\n        half = len(even) // 2\n        product = 1\n        for num in even[:half]:\n            product *= num\n        return product\n\n    elif len(even) == 0:  # all digits are odd\n        half = len(odd) // 2\n        return sum(odd[:half])\n        \n    else:  # mix of odd and even digits\n        product = 1\n        for num in odd:\n            product *= num\n        return product + sum(even)"
      ],
      [
        0.9307226538658142,
        "def digits(n):\n    \"\"\"\n    Given an integer n, return the sum of the even digits and the product of the odd digits in n.\n    \n    >>> digits(123456789)\n    48\n    >>> digits(2468)\n    24\n    >>> digits(13579)\n    12\n    \"\"\"\n    # convert the integer into a list of its digits\n    n = [int(i) for i in str(n)]\n    \n    # separate even and odd digits\n    evens = [i for i in n if i % 2 == 0]\n    odds  = [i for i in n if i % 2 != 0]\n    \n    # error checking in case the input number only has even or odd digits\n    if len(odds) == 0:\n        half = len(evens) // 2\n        product = 1\n        for i in range(half):\n            product *= evens[i]\n        return product\n    elif len(evens) == 0:\n        half = len(odds) // 2\n        return sum(odds[:half])\n    else:\n        # compute the product of odd digits and the sum of even ones\n        return sum(evens) + (eval('*'.join(str(i) for i in odds)))"
      ],
      [
        0.930366039276123,
        "def prodDigits(n):\n    \"\"\"\n    Given a positive integer n, return the product of all digits in the number.\n    \n    >>> prodDigits(1234)\n    24\n    >>> prodDigits(402)\n    8\n    >>> prodDigits(123456789)\n    0\n    >>> prodDigits(0)\n    0\n    \"\"\"\n    product = 1\n    for d in str(n):\n        product *= int(d)\n    return product"
      ],
      [
        0.9301921129226685,
        "def product_of_digits(n):\n    \"\"\"\n    Given an integer n, return the product of all digits in the number.\n    \n    >>> product_of_digits(1234)\n    24\n    >>> product_of_digits(402)\n    8\n    >>> product_of_digits(123456789)\n    0\n    >>> product_of_digits(0)\n    0\n    \"\"\"\n    product = 1\n    for num in n:\n        while num != 0:\n            product *= num % 10\n            num //= 10\n    return product"
      ],
      [
        0.9260784983634949,
        "def product_of_odds(lst):\n    \"\"\"\n    Given a list of integers, return the product of all odd numbers.\n    \n    >>> product_of_odds([1, 2, 3, 4, 5])\n    15\n    >>> product_of_odds([4, 5, 6, 7, 8, 9])\n    9\n    \"\"\"\n    result = 1\n    for num in lst:\n        if num % 2 != 0:\n            result *= num\n    return result"
      ],
      [
        0.9228826761245728,
        "def digits(n):\n    \"\"\"\n    Given a positive integer n, return the sum of all even digits and the product of all odd digits in n.\n    \n    Example 1:\n    Input: n = 3485\n    Output: 12\n    Explanation: The even digits are 4 and 8, and their sum is 12.\n    \n    Example 2:\n    Input: n = 247\n    Output: 2\n    Explanation: The only odd digit is 7, and its factorial is 2.\n    \n    Example 3:\n    Input:\"\"\"\n    str_n = str(n)\n    even_digits = [int(i) for i in str_n if int(i) % 2 == 0]\n    odd_digits = [int(i) for i in str_n if int(i) % 2 != 0]\n    \n    if not even_digits and odd_digits:  # all digits are odd\n        half = len(odd_digits) // 2\n        return factorial(sum(odd_digits[:half]))\n    elif not odd_digits and even_digits:  # all digits are even\n        half = len(even_digits) // 2\n        return math.sqrt(math.prod(even_digits[:half]))\n    else:\n        return sum([i**2 for i in even_digits]) + sum([factorial(i) for i in odd_digits])"
      ],
      [
        0.9211040139198303,
        "def product_of_digits(num):\n    \"\"\"\n    Given an integer, return the product of all the digits in the number.\n    \n    >>> product_of_digits(1234)\n    24\n    >>> product_of_digits(602)\n    12\n    \"\"\"\n    product = 1\n    for digit in str(num):\n        product *= int(digit)\n    return product"
      ],
      [
        0.9173450469970703,
        "def product_of_odd_numbers(numbers, product=1):\n    \"\"\"\n    Returns the product of all odd numbers in a list.\n    \n    >>> product_of_odd_numbers([1, 2, 3, 4, 5])\n    15\n    >>> product_of_odd_numbers([4, 3, 10, 20, 5, 6])\n    15\n    >>> product_of_odd_numbers([10, 15, 20, 2, 5])\n    15\n    \"\"\"\n    if not numbers:\n        return round(product)\n    elif 10 < numbers[0] < 20 and numbers[0] % 2 != 0:\n        return product_of_odd_numbers(numbers[1:], product * numbers[0])\n    else:\n        return product_of_odd_numbers(numbers[1:], product)"
      ]
    ],
    "HumanEval/132": [
      [
        0.9119871854782104,
        "def is_nested(string):\n    \"\"\"\n    This function checks for the balance and proper nesting of brackets.\n    If the brackets are not properly nested or balanced, it returns the position of the error.\n    \"\"\"\n    stack = []\n    brackets_map = {\"(\":\")\", \"[\": \"]\", \"{\": \"}\", \"<\": \">\"}\n\n    for index, character in enumerate(string, start=1):\n        if character in brackets_map:  # encountered an open bracket\n            stack.append(character)\n        elif character in brackets_map.values():  # encountered a close bracket\n            if not stack or brackets_map[stack.pop()] != character:\n                return False, f\"Position {index}\"\n        else:\n            return False, f\"Position {index} - Invalid character {character}\"\n\n    # If the stack is empty then brackets were balanced\n    return (not stack, None) if not stack else (False, f\"Position {len(string)} - unmatched {stack[-1]}\")"
      ],
      [
        0.9083614349365234,
        "def is_nested_and_balanced(s):\n    \"\"\"\n    \"\"\"\n    stack = []\n    openers_to_closers = {\n        '(': ')',\n        '[': ']',\n        '{': '}',\n        '<': '>',\n    }\n    closers = set(openers_to_closers.values())\n\n    for char in s: \n        if char in openers_to_closers:\n            stack.append(char)\n        elif char in closers:\n            if not stack: \n                return False\n            else: \n                last_unclosed_opener = stack.pop()\n                if not char == openers_to_closers[last_unclosed_opener]:\n                    return False\n\n    return stack == [] # stack should be empty at the end"
      ],
      [
        0.9082558751106262,
        "def is_nested(string):\n    \"\"\"\n    Check if a string has balanced brackets.\n    \n    Args:\n        string (str): string to check\n    \n    Returns:\n        tuple: (boolean, str)\n    \"\"\"\n    stack = []\n    brackets = {'(': ')', '[': ']', '{': '}', '<': '>'}\n    for i, char in enumerate(string):\n        if char in brackets:\n            stack.append((char, i))\n        elif len(stack) == 0 or brackets[stack.pop()[0]] != char:\n            return False, 'Position ' + str(i)\n    return (len(stack) == 0, None) if len(stack) == 0 else (False, 'Position ' + str(stack[0][1]))"
      ],
      [
        0.9062117338180542,
        "def complex_brackets(lst):\n    \"\"\"\n    Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n    An input string is valid if:\n    Open brackets must be closed by the same type of brackets.\n    Open brackets must be closed in the correct order.\n    Note that an empty string is also considered valid.\n    Example 1:\n    Input: \"()\"\n    Output: true\n    Example 2:\n    Input: \"()[]{}\"\n    Output: true\n    Example 3:\n    Input: \"(]\"\n    Output\"\"\"\n    brackets = {\n        '}': '{',\n        ']': '[',\n        ')': '('\n    }\n    input_string = ''.join(lst)\n    stack = []\n    for bracket in input_string:\n        if bracket in brackets.values():   # for any open bracket, we push it into the stack\n            stack.append(bracket)\n        elif bracket in brackets.keys():   # for any close bracket\n            if stack == [] or brackets[bracket] != stack.pop(): # if the stack is empty or if the last open bracket does not match the current close bracket then the brackets are not balanced\n                return False\n    return stack == []   # after going through all brackets, if there is any open bracket left in the stack then the brackets are not well balanced"
      ]
    ],
    "HumanEval/133": [
      [
        0.9320711493492126,
        "def add_squared_values(lst):\n    \"\"\"\n    Return the sum of the squares of the values in the list.\n    \n    >>> add_squared_values([1, 2, 3])\n    14\n    \"\"\"\n    # Apply math.ceil function to take ceiling value of absolute of each number in the list.\n    # Then square and sum them up.\n    return sum(map(lambda x: math.ceil(abs(x)) ** 2, lst))"
      ],
      [
        0.9173702597618103,
        "def sum_of_squares(lst):\n    \"\"\"\n    Return the sum of the squares of the numbers in the list.\n    >>> sum_of_squares([1, 2, 3])\n    14\n    >>> sum_of_squares([1, 2, 3, 4])\n    30\n    \"\"\"\n    return sum([num**2 for num in lst])"
      ],
      [
        0.9173552989959717,
        "def sum_of_squares(lst):\n    \"\"\"\n    Return the sum of the squares of the numbers in the list.\n    >>> sum_of_squares([1, 2, 3])\n    14\n    >>> sum_of_squares([1, 2, 3, 4])\n    30\n    \"\"\"\n    return sum([num**2 for num in lst])"
      ]
    ],
    "HumanEval/134": [
      [
        0.9041742086410522,
        "def last_char_is_vowel(word):\n    \"\"\"\n    Return True if the last letter of a word is a vowel, False otherwise.\n    \n    >>> last_char_is_vowel('apple')\n    True\n    >>> last_char_is_vowel('banana')\n    False\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    last_char = word[-1].lower()\n    return last_char in vowels"
      ],
      [
        0.9011815786361694,
        "def ends_with_letter(word):\n    \"\"\"\n    Returns True if the word ends with a letter, False otherwise.\n    \"\"\"\n    return word.endswith(letter)\n    def ends_with_letter(word):\n    \"\"\"\n    Returns True if the word ends with a letter, False otherwise.\n    \"\"\"\n    return word.endswith(letter)"
      ],
      [
        0.8970685005187988,
        "def check_words(my_string):\n    \"\"\"\n    Check if all words in a string start and end with the same letter.\n    \n    >>> check_words('banana')\n    True\n    >>> check_words('banana banana')\n    False\n    >>> check_words('banana banana banana')\n    False\n    >>> check_words('banana banana banana banana')\n    True\n    >>> check_words('banana banana banana banana banana')\n    False\n    >>> check_words('banana banana banana banana banana banana')\n    True\n    >>> check_words('banana banana banana banana banana banana banana')\n    False\n    >>> check\"\"\"\n    word_list = my_string.split()\n    for word in word_list:\n        if word[0] != word[-1]:\n            return False\n    return True"
      ],
      [
        0.8932734727859497,
        "def check_words(s):\n    \"\"\"\n    Check if all words in a string have the same first and last letter.\n    \n    >>> check_words('banana')\n    True\n    >>> check_words('banana banana')\n    False\n    \"\"\"\n    words = s.split()\n    for word in words:\n        if word[0] != word[-1]:\n            return False\n    return True"
      ],
      [
        0.8907321095466614,
        "def has_penultimate_t(words):\n    \"\"\"\n    Return True if the penultimate letter of any word in the list of words is 't'.\n    \n    >>> has_penultimate_t(['test', 'testt', 't'])\n    True\n    >>> has_penultimate_t(['test', 'testt', 'tt'])\n    False\n    \"\"\"\n    for word in words:\n        if len(word) >= 2 and word[-2].lower() == 't':\n            return True\n    return False"
      ],
      [
        0.8879511952400208,
        "def check_word(word):\n    \"\"\"\n    Check if a word contains at least two e's,\n    except the first and last characters do not count.\n    \n    check_word('free') \u2192 True\n    check_word('xxrexx') \u2192 True\n    check_word('yxxrexx') \u2192 False\n    \"\"\"\n    if len(word) >= 2 and word[1] == 'e' and word[-2] == 'e':\n        return True\n    return False"
      ]
    ],
    "HumanEval/135": [
      [
        0.9190825819969177,
        "def can_arrange(arr):\n    \"\"\"\n    Given an array of integers, determine if it is possible to rearrange the array such that it is sorted in ascending order.\n    If it is possible, return an array of the indices of the elements that need to be swapped. If it is not possible, return an empty array.\n    \n    Example:\n    Input: [2, 1, 3, 4]\n    Output: [1, 2]\n    Explanation: Swap elements at indices 1 and 2 to get [2, 3, 1, 4], which is sorted in ascending order.\n    \n\"\"\"\n    # Initialize the results as -1 indicating missing elements\n    result = {'index': -1, 'swap_with': -1}\n\n    # Iterate over the array using enumerate to get both index and value\n    for i, num in enumerate(arr):\n        # Exclude the last element as we can't check the next element for it\n        if i != len(arr) - 1:\n            # Check if current element is greater than the next one\n            if num > arr[i + 1]:\n                # Update result['index']\n                result['index'] = i + 1\n                # Identifying the index of the next smaller item that could potentially be swapped \n                for j in range(i + 1, -1, -1):\n                    if arr[j] < arr[result['index']]:\n                        result['swap_with'] = j\n                        break\n    return result"
      ],
      [
        0.9129917025566101,
        "def can_arrange(arr):\n    \"\"\"\n    \"\"\"\n    swaps, candidate, candidate_lexiographical = 0, None, None\n    for i in range(len(arr) - 1, 0, -1):\n        if arr[i - 1] > arr[i]:\n\n            swaps += 1\n            \n            if candidate is None or arr[candidate] > arr[i - 1]:\n                candidate = i - 1\n                candidate_lexiographical = i\n\n            elif arr[i] < arr[candidate]:\n                candidate_lexiographical = i\n\n    if candidate is None:\n        return {'index': -1, 'swap_with': -1, 'total_swaps': 0}\n    else:\n        return {'index': candidate, 'swap_with': candidate_lexiographical, 'total_swaps': swaps}"
      ],
      [
        0.9120304584503174,
        "def can_arrange(arr):\n    \"\"\"\n    \"\"\"\n    total_swaps = 0\n    for index in range(1, len(arr)):\n        if arr[index] < arr[index - 1]:\n            # Find the maximum element which is smaller than arr[index - 1].\n            # It would be the right candidate for swap.\n            swap_with = max((v, i) for i, v in enumerate(arr) if v < arr[index - 1])\n            arr[swap_with[1]], arr[index - 1] = arr[index - 1], arr[swap_with[1]]\n            total_swaps += 1\n            return {\n                'index': index,\n                'swap_with': swap_with[1],\n                'total_swaps': total_swaps,\n            }\n\n    return {'index': -1, 'swap_with': -1, 'total_swaps': 0}"
      ],
      [
        0.9107561111450195,
        "def can_arrange(arr):\n    \"\"\"\n    \"\"\"\n    n = len(arr)\n    index = -1\n    res = {'index': index, 'swap_with': -1, 'num_swaps': 0}\n\n    for i in range(n - 1):\n        if arr[i] < arr[i + 1]:\n            index = i\n            break\n\n    if index != -1:\n        for j in range(index + 1, n):\n            if arr[j] <= arr[index]:\n                res['swap_with'] = j\n\n        if res['swap_with'] != -1:\n            arr[index], arr[index + 1] = arr[index + 1], arr[index]  # Swap elements with next one\n        else:\n            arr[index], arr[res['swap_with']] = arr[res['swap_with']], arr[index]  # Swap elements\n\n        res['index'] = index\n        res['num_swaps'] = 1\n\n    return res"
      ],
      [
        0.9097989797592163,
        "def can_arrange(arr):\n    \"\"\"\n    \"\"\"\n    last_checked_index = -1\n    total_swaps = 0\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i - 1]:\n            last_checked_index = i - 1\n            break\n    if last_checked_index == -1:\n        return {'index': -1, 'swap_with': -1, 'total_swaps': 0}\n    swap_with_index = -1\n    for i in range(last_checked_index + 1, len(arr)):\n        if arr[i] > arr[last_checked_index]:\n            swap_with_index = i\n            break\n    if swap_with_index != -1:\n        total_swaps += 1\n    return {'index': last_checked_index, 'swap_with': swap_with_index, 'total_swaps': total_swaps}"
      ],
      [
        0.9070905447006226,
        "def can_arrange(arr):\n    \"\"\"\n    \"\"\"\n    n = len(arr)\n    index = -1\n    swap_with = -1\n    numOfSwaps = 0\n    for i in range(n-1):\n        if arr[i] > arr[i+1]:\n            index = i\n            break\n    if index != -1:\n        for i in range(n-1, -1, -1):\n            if arr[i] < arr[index]:\n                swap_with = i\n                numOfSwaps = abs(swap_with - index)\n                break\n    return {'index': index, 'swap_with': swap_with, 'num_swaps': numOfSwaps}"
      ],
      [
        0.9065263867378235,
        "def can_arrange(arr):\n    \"\"\"\n    Given an array of integers, determine the minimum number of swaps required to sort the array in ascending order.\n    \n    For example, given the array arr = [7, 1, 3, 2, 4, 5, 6], we make the following three swaps to sort the array:\n    \n    Swap    Array\n    0       [7, 1, 3, 2, 4, 5, 6]\n    1       [7, 1, 3, 2, 4, 5, 6]\n    2       \"\"\"\n    n = len(arr)\n    swap_index = -1\n    for i in range(n-1, 0, -1):\n        if arr[i] < arr[i-1]:\n            swap_index = i-1\n            break\n    if swap_index == -1:\n        return {'index': -1, 'swap_with': -1, 'total_swaps': 0, 'swapped_elements': []}\n    else:\n        swap_with = -1\n        for i in range(swap_index+1, n):\n            if arr[i] > arr[swap_index] and (swap_with == -1 or arr[i] < arr[swap_with]):\n                swap_with = i\n        swapped_elements = [arr[swap_index], arr[swap_with]]\n        arr[swap_index], arr[swap_with] = arr[swap_with], arr[swap_index]\n        return {'index': swap_index, 'swap_with': swap_with, 'total_swaps': 1, 'swapped_elements': swapped_elements}"
      ],
      [
        0.9062120914459229,
        "def can_arrange(arr):\n    \"\"\"\n    \"\"\"\n    num_swaps, largest_index, swap_with, inversions = 0, -1, -1, 0\n    for i in range(len(arr) - 1, 0, -1):\n        if arr[i] < arr[i-1]:\n            largest_index = i - 1\n            swap_with = i\n            num_swaps += 1\n            inversions += 1\n            \n    if num_swaps == 0:\n        return {'index': largest_index, 'swap_with': swap_with, 'num_swaps': num_swaps, 'inversions': inversions}\n    \n    for i in range(largest_index-1, -1, -1):\n        if arr[i] > arr[swap_with]:\n            swap_with = i\n            num_swaps += 1\n        else:\n            break\n            \n    return {'index': largest_index, 'swap_with': swap_with, 'num_swaps': num_swaps, 'inversions': inversions}"
      ],
      [
        0.9055923819541931,
        "def can_arrange(arr):\n    \"\"\"\n    \"\"\"\n    num_swaps, largest_index, swap_with, inversions = 0, -1, -1, 0\n    for i in range(len(arr) - 1, 0, -1):\n        if arr[i] < arr[i - 1]:\n            largest_index = i - 1\n            swap_with = i\n            num_swaps += 1\n            inversions += 1\n\n    if num_swaps == 0:\n        return {'index': largest_index, 'swap_with': swap_with, 'num_swaps': num_swaps, 'inversions': inversions}\n\n    for i in range(largest_index - 1, -1, -1):\n        if arr[i] > arr[swap_with]:\n            swap_with = i\n            num_swaps += 1\n        else:\n            break\n\n    return {'index': largest_index, 'swap_with': swap_with, 'num_swaps': num_swaps, 'inversions': inversions}"
      ]
    ],
    "HumanEval/136": [
      [
        0.9590673446655273,
        "def largest_smallest_integers(lst):\n    \"\"\"\n    Given a list of integers, return the largest and smallest integers,\n    in that order.\n    \n    >>> largest_smallest_integers([1, 2, 3, 4, 5])\n    [5, 1]\n    >>> largest_smallest_integers([1, 2, -3, 4, 5])\n    [5, -3]\n    >>> largest_smallest_integers([1, 2, 3, 4, -5])\n    [4, -5]\n    >>> largest_smallest_integers([1, \"\"\"\n    neg = sorted([n for n in lst if n < 0], reverse=True)[0] if any(n < 0 for n in lst) else None\n    pos = sorted([n for n in lst if n > 0])[0] if any(n > 0 for n in lst) else None\n    return [neg, pos]"
      ],
      [
        0.9563831686973572,
        "def largest_smallest_integers(lst):\n    \"\"\"\n    Given a list of integers, return the largest negative integer, the smallest positive integer, the largest odd integer, and the smallest even integer.\n    If any of the integers cannot be found, return None for that position.\n    \n    >>> largest_smallest_integers([1, 2, 3, 4, 5, 6])\n    (None, 1, 5, 2)\n    >>> largest_smallest_integers([1, 2, 3, 4, -5, -6])\n    (-5, 1, None, 2)\"\"\"\n    \n    if not lst:\n        return (None, None, None, None)\n\n    all_negative = list(filter(lambda x: x<0, lst))\n    all_non_negative = list(filter(lambda x: x>=0, lst))\n    \n    negative_even = [i for i in all_negative if i%2==0]\n    negative_odd = [i for i in all_negative if i%2!=0]\n    non_negative_even = [i for i in all_non_negative if i%2==0]\n    non_negative_odd = [i for i in all_non_negative if i%2!=0]\n    \n    a = max(negative_even) if negative_even else None\n    b = min(non_negative_even) if non_negative_even else None\n    c = max(negative_odd) if negative_odd else None\n    d = min(non_negative_odd) if non_negative_odd else None\n\n    return a, b, c, d"
      ],
      [
        0.9527288675308228,
        "def largest_smallest_integers(lst):\n\"\"\"\n    Given a list of integers, return the largest negative integer, the smallest positive integer, the largest odd integer, and the smallest even integer.\n    If any of the integers cannot be found, return None for that position.\n    \n    >>> largest_smallest_integers([1, 2, 3, 4, 5, 6])\n    (None, 1, 5, 2)\n    >>> largest_smallest_integers([1, 2, 3, 4, -5, -6])\n    (-5, 1, None, 2)\"\"\"\n\n    if not lst:\n        return (None, None, None, None)\n\n    all_negative = list(filter(lambda x: x<0, lst))\n    all_non_negative = list(filter(lambda x: x>=0, lst))\n\n    negative_even = [i for i in all_negative if i%2==0] \n    negative_odd = [i for i in all_negative if i%2!=0]\n    non_negative_even = [i for i in all_non_negative if i%2==0]\n    non_negative_odd = [i for i in all_non_negative if i%2!=0]\n\n    a = max(negative_even) if negative_even else None\n    b = min(non_negative_even) if non_negative_even else None\n    c = max(negative_odd) if negative_odd else None\n    d = min(non_negative_odd) if non_negative_odd else None\n\n    return a, b, c, d"
      ],
      [
        0.9465733766555786,
        "def largest_smallest_integers(lst):\n    \"\"\"\n    Given a list of integers, return the largest negative integer, the smallest\n    positive integer, the largest odd integer, and the smallest even integer.\n    All integers will be either positive, negative, or zero.\n\n    >>> largest_smallest_integers([1, 2, 3, 4, -5, -6])\n    (-5, 1, 3, 2)\n    >>> largest_smallest_integers([1, 1, 1, -1, -1, -1, 0])\n    (-1, 1, None, None)\n\"\"\"\n    negative_evens = [x for x in lst if x < 0 and x % 2 == 0]\n    non_negative_evens = [x for x in lst if x >= 0 and x % 2 == 0]\n    negative_odds = [x for x in lst if x < 0 and x % 2 != 0]\n    non_negative_odds = [x for x in lst if x >= 0 and x % 2 != 0]\n\n    a = max(negative_evens) if negative_evens else None\n    b = min(non_negative_evens) if non_negative_evens else None\n    c = max(negative_odds) if negative_odds else None\n    d = min(non_negative_odds) if non_negative_odds else None\n\n    return (a, b, c, d)"
      ],
      [
        0.9422871470451355,
        "def largest_smallest_summed_integers(lst):\n    \"\"\"\n    Given a list of integers, return the sum of the largest negative integer and the smallest positive integer.\n    If there is no negative integer or positive integer, return None.\n    If there is no negative integer, return the sum of the smallest positive integer and the second smallest positive integer.\n    If there is no positive integer, return the sum of the largest negative integer and the second largest negative integer.\n    If there is no negative integer and no positive integer, return 0.\n    If there is no negative integer and no positive integer and no second smallest positive integer, return the sum of the smallest positive\"\"\"\n    # Filtering the list into even and odd numbers\n    evens = [x for x in lst if x % 2 == 0]\n    odds = [x for x in lst if x % 2 != 0]\n    # Finding the maximum of negative numbers and minimum of positive numbers\n    a = max([x for x in evens if x < 0], default=None)\n    b = min([x for x in evens if x > 0], default=None)\n    c = max([x for x in odds if x < 0], default=None)\n    d = min([x for x in odds if x > 0], default=None)\n    # Calculating the sum 'e' and 'f'\n    e = (a if a else 0) + (b if b else 0) + (c if c else 0) + (d if d else 0)\n    f = e + (e if e else 0)\n    return a, b, c, d, e, f"
      ],
      [
        0.9412734508514404,
        "def largest_smallest_integers(lst):\n    \"\"\"\n    Given a list of integers, return the largest negative even integer, the largest non-negative even integer, the smallest negative even integer, the smallest non-negative even integer, the smallest negative odd integer, and the largest non-negative odd integer.\n    \n    If there is a tie for any of the values, return the smallest integer.\n    \n    If there are no negative even integers, return None for the largest negative even integer.\n    \n    If there are no non-negative even integers, return None for the largest non-negative even integer.\n    \n    If there are no negative even\"\"\"\n    highest_neg_even = highest_non_neg_even = smallest_neg_even = smallest_non_neg_even = smallest_neg_odd = highest_non_neg_odd = None\n    \n    for num in lst:\n        if num%2 == 0: # Check if the number is even\n            if num < 0: # Check if the number is negative\n                if highest_neg_even is None or highest_neg_even < num: # Get the highest negative even number\n                    highest_neg_even = num\n                if smallest_neg_even is None or smallest_neg_even > num: # Get the smallest negative even number\n                    smallest_neg_even = num\n            else: # If the number is non negative\n                if highest_non_neg_even is None or highest_non_neg_even < num: # Get the highest non-negative even number\n                    highest_non_neg_even = num\n                if smallest_non_neg_even is None or smallest_non_neg_even > num: # Get the smallest non-negative even number\n                    smallest_non_neg_even = num\n        else: # If the number is odd\n            if num < 0: # Check if the number is negative\n                if smallest_neg_odd is None or smallest_neg_odd > num: # Get the smallest negative odd number\n                    smallest_neg_odd = num\n            else: # If the number is non negative\n                if highest_non_neg_odd is None or highest_non_neg_odd < num: # Get the highest non-negative odd number\n                    highest_non_neg_odd = num\n                    \n    return (highest_neg_even, highest_non_neg_even, smallest_neg_even, smallest_non_neg_even, smallest_neg_odd, highest_non_neg_odd)"
      ],
      [
        0.9324386715888977,
        "def largest_smallest_summed_integers(lst):\n    \"\"\"\n    Given a list of integers, return the sum of the largest negative integer and the smallest positive integer.\n    If there is no negative integer or positive integer, return None.\n    If there is no negative integer, return the sum of the smallest positive integer and the second smallest positive integer.\n    If there is no positive integer, return the sum of the largest negative integer and the second largest negative integer.\n    If there is no negative integer and no positive integer, return 0.\n    \n    Parameters\n    ----------\n    lst : list\n        A list of integers.\n    \n    Returns\n\"\"\"\n    # filtering the list into even and odd numbers\n    evens = [x for x in lst if x % 2 == 0]\n    odds = [x for x in lst if x % 2 != 0]\n    # finding the maximum of negative numbers and minimum of positive numbers\n    a = max([x for x in evens if x < 0], default=None)\n    b = min([x for x in evens if x > 0], default=None)\n    c = max([x for x in odds if x < 0], default=None)\n    d = min([x for x in odds if x > 0], default=None)\n    # calculating the sum 'e' and 'f'\n    e = (a if a else 0) + (b if b else 0) + (c if c else 0) + (d if d else 0)\n    f = e + (e if e else 0)\n    return a, b, c, d, e, f"
      ],
      [
        0.9314712285995483,
        "def largest_smallest_integers(lst):\n    \"\"\"\n    Find the largest negative even integer and the smallest non-negative even integer in a list,\n    and the largest negative odd integer and the smallest non-negative odd integer in a list.\n    \n    Parameters:\n    lst (list): A list of integers.\n    \n    Returns:\n    tuple: A tuple containing the largest negative even integer, the smallest non-negative even integer,\n           the largest negative odd integer, and the smallest non-negative odd integer in the list.\n    \"\"\"\n    max_neg_even = max_neg_odd = min_non_neg_even = min_non_neg_odd = None\n\n    for num in lst:\n        if num % 2 == 0:  # num is even\n            if num >= 0:  # num is non-negative\n                if min_non_neg_even is None or num < min_non_neg_even:\n                    min_non_neg_even = num\n            else:  # num is negative\n                if max_neg_even is None or num > max_neg_even:\n                    max_neg_even = num\n        else:  # num is odd\n            if num >= 0:  # num is non-negative\n                if min_non_neg_odd is None or num < min_non_neg_odd:\n                    min_non_neg_odd = num\n            else:  # num is negative\n                if max_neg_odd is None or num > max_neg_odd:\n                    max_neg_odd = num\n\n    return max_neg_even, min_non_neg_even, max_neg_odd, min_non_neg_odd"
      ],
      [
        0.9309178590774536,
        "def largest_smallest_integer(lst):\n    \"\"\"\n    Given a list of integers, return the largest negative even number, the smallest non-negative even number, the smallest negative odd number, and the largest non-negative odd number.\n    If there is a tie, return the smallest number.\n    If there is no negative even number, return None.\n    If there is no non-negative even number, return None.\n    If there is no negative odd number, return None.\n    If there is no non-negative odd number, return None.\n    \n    Parameters:\n    lst (list): A list of integers.\n    \n    \"\"\"\n    highest_neg_even = smallest_neg_even = highest_non_neg_even = smallest_non_neg_even = smallest_neg_odd = highest_non_neg_odd = None\n\n    for num in lst:\n        if num % 2 == 0:  # Check if the number is even\n            if num < 0:  # Check if the number is negative\n                if highest_neg_even is None or highest_neg_even < num:  # Get the highest negative even number\n                    highest_neg_even = num\n                if smallest_neg_even is None or smallest_neg_even > num:  # Get the smallest negative even number\n                    smallest_neg_even = num\n            else:  # If the number is non negative\n                if highest_non_neg_even is None or highest_non_neg_even < num:  # Get the highest non-negative even number\n                    highest_non_neg_even = num\n                if smallest_non_neg_even is None or smallest_non_neg_even > num:  # Get the smallest non-negative even number\n                    smallest_non_neg_even = num\n        else:  # If the number is odd\n            if num < 0:  # Check if the number is negative\n                if smallest_neg_odd is None or smallest_neg_odd > num:  # Get the smallest negative odd number\n                    smallest_neg_odd = num\n            else:  # If the number is non negative\n                if highest_non_neg_odd is None or highest_non_neg_odd < num:  # Get the highest non-negative odd number\n                    highest_non_neg_odd = num\n\n    return highest_neg_even, highest_non_neg_even, smallest_neg_even, smallest_non_neg_even, smallest_neg_odd, highest_non_neg_odd"
      ]
    ],
    "HumanEval/137": [
      [
        0.9227480888366699,
        "def compare_one(a, b):\n    \"\"\"\n    Compare two values and return the one with the highest value.\n    If the values are equal, return None.\n    :param a: First value\n    :param b: Second value\n    :return: Highest value\n    \"\"\"\n    # Convert to string, replace optional ',' by '.'\n    aC = str(a).replace(',', '.') if isinstance(a, str) else str(a)\n    bC = str(b).replace(',', '.') if isinstance(b, str) else str(b)\n\n    # Convert strings to numbers for comparison\n    aN = float(aC)\n    bN = float(bC)\n\n    # Compare values\n    if aN > bN:\n        return a\n    elif aN < bN:\n        return b\n\n    # If values are equal, return None\n    return None"
      ],
      [
        0.9146048426628113,
        "def compareOne(a, b):\n    \"\"\"\n    Compara dois valores e retorna o maior\"\"\"\n    try:\n        if isinstance(a, str):\n            a = float(a.replace(\",\", \".\"))\n        if isinstance(b, str):\n            b = float(b.replace(\",\", \".\"))\n\n        if a > b:\n            return isinstance(a, float) and str(a).replace(\".\", \",\") or a\n        elif b > a:\n            return isinstance(b, float) and str(b).replace(\".\", \",\") or b\n        \n        return None\n    except ValueError:\n        return None"
      ],
      [
        0.9114009141921997,
        "def get_larger_number(num1, num2):\n    \"\"\"\n    This function takes two numbers and returns the larger one.\n    \"\"\"\n    if num1 == num2:\n        return \"The two numbers are equal.\"\n    elif isinstance(num1, complex) or isinstance(num2, complex):\n        if isinstance(num1, complex) and isinstance(num2, complex):\n            return max(num1, num2, key=lambda x: abs(x))\n        elif isinstance(num1, complex):\n            return num1\n        else:\n            return num2\n    else:\n        num1 = abs(num1)\n        num2 = abs(num2)\n        if num1 == num2:\n            return \"The two numbers have the same absolute value.\"\n        elif num1 > num2:\n            return num1\n        else:\n            return num2"
      ],
      [
        0.9063088893890381,
        "def find_larger_num(num1, num2):\n    \"\"\"\n    This function takes two numbers as input and returns the larger number.\n    If the numbers are equal, it returns \"Both numbers are equal.\"\n    If both numbers are negative, it returns the number with the smaller absolute value.\n    If one of the numbers is negative and the other is positive, it returns the positive number.\n    If both numbers are positive, it returns the larger number.\n    If one of the numbers is a float and the other is an integer, it returns the float number.\n    If both numbers are integers, it returns the larger number.\n    \n    Parameters:\n\"\"\"\n    if num1 == num2:\n        return \"Both numbers are equal.\"\n    elif num1 < 0 and num2 < 0:\n        if abs(num1) < abs(num2):\n            return num1\n        else:\n            return num2\n    elif num1 < 0 or num2 < 0:\n        if abs(num1) > abs(num2):\n            return num1\n        else:\n            return num2\n    elif isinstance(num1, float) or isinstance(num2, float):\n        if isinstance(num1, int):\n            num1 = float(num1)\n        if isinstance(num2, int):\n            num2 = float(num2)\n        if num1 > num2:\n            return num1\n        else:\n            return num2\n    else:\n        if num1 > num2:\n            return num1\n        else:\n            return num2"
      ]
    ],
    "HumanEval/138": [
      [
        0.9034540057182312,
        "def is_sum_even(x, y, z): \n    \"\"\"\n    Return True if the sum of x, y, and z is even.\n    >>> is_sum_even(1, 2, 3)\n    False\n    >>> is_sum_even(1, 2, 4)\n    True\n    \"\"\"\n    sum = x + y + z \n    if (sum % 2 == 0): \n        return True\n    else: \n        return False"
      ],
      [
        0.8991937637329102,
        "def is_even_digits(n):\n    \"\"\"\n    Check if all digits of the given integer are even\n    :param n: int\n    :return: bool\n    \"\"\"\n    return len(str(n)) % 2 == 0"
      ],
      [
        0.8972862958908081,
        "def has_even_sum(lst):\n    \"\"\"\n    Return True if the sum of the numbers in the list is even.\n    >>> has_even_sum([1, 2, 3])\n    True\n    >>> has_even_sum([1, 1, 1])\n    False\n    \"\"\"\n    running_sum = 0\n    for num in lst:\n        running_sum += num\n        if running_sum % 2 != 0:  # check if running sum is odd\n            return False\n    return running_sum % 2 == 0  # check if final sum is even"
      ],
      [
        0.8955768346786499,
        "def is_even(n):\n    \"\"\"\n    Return True if n is even, otherwise return False\n    :param n: int\n    :return: bool\n    \"\"\"\n    if n % 2 == 0:\n        return True\n    else:\n        return False"
      ],
      [
        0.8955762386322021,
        "def is_even(n):\n    \"\"\"\n    Return True if n is even, otherwise return False\n    :param n: int\n    :return: bool\n    \"\"\"\n    if n % 2 == 0:\n        return True\n    else:\n        return False"
      ]
    ],
    "HumanEval/139": [
      [
        0.9245625138282776,
        "def factorial(n): \n    \"\"\"\n    Return n!\n    \n    >>> factorial(4)\n    24\n    >>> factorial(6)\n    720\n    \"\"\"\n    if n == 0: \n        return 1 \n    return n * factorial(n - 1) "
      ],
      [
        0.9241386651992798,
        "def factorial(n):\n    \"\"\"\n    Calculate the factorial of n.\n\n    n int -> int\n    pre: n >= 0\n    post: return n!\n    \"\"\"\n    # base case: factorial of 0 is 1\n    if n == 0:\n        return 1\n    # recursive case: n! = n * (n-1)!\n    else:\n        return n * factorial(n-1)"
      ],
      [
        0.9231563210487366,
        "def factorial(n):\n    \"\"\"\n    Return n!\n    \n    >>> factorial(4)\n    24\n    >>> factorial(6)\n    720\n    \"\"\"\n    return 1 if n == 0 else n * factorial(n-1)"
      ],
      [
        0.9221312999725342,
        "def factorial(n):\n    \"\"\"\n    Return n!\n    \n    >>> factorial(4)\n    24\n    >>> factorial(6)\n    720\n    \"\"\"\n    if n == 0: \n        return 1\n    else: \n        return n * factorial(n-1)"
      ],
      [
        0.9219096899032593,
        "def factorial(n):\n    \"\"\"\n    Return n!\n    \n    >>> factorial(4)\n    24\n    >>> factorial(6)\n    720\n    \"\"\"\n    # base case\n    if n == 0:\n        return 1\n    # recursive case\n    else:\n        return n * factorial(n-1)"
      ],
      [
        0.9219053387641907,
        "def factorial(n):\n    \"\"\"\n    Return n!\n    \n    >>> factorial(4)\n    24\n    >>> factorial(6)\n    720\n    \"\"\"\n    # base case\n    if n == 0:\n        return 1\n    # recursive case\n    else:\n        return n * factorial(n-1)"
      ],
      [
        0.9218941926956177,
        "def factorial(n):\n    \"\"\"\n    Return n!\n    \n    >>> factorial(4)\n    24\n    >>> factorial(6)\n    720\n    \"\"\"\n    # base case\n    if n == 0:\n        return 1\n    # recursive case\n    else:\n        return n * factorial(n-1)"
      ],
      [
        0.9210484027862549,
        "def factorial(n):\n    \"\"\"\n    Return the factorial of a non-negative integer n.\n    \n    >>> factorial(5)\n    120\n    >>> factorial(3)\n    6\n    >>> factorial(1)\n    1\n    >>> factorial(0)\n    1\n    >>> factorial(10)\n    3628800\n    >>> factorial(100)\n    9332621544394415268169923885626670049071596\"\"\"\n    if isinstance(n, float) or isinstance(n, str):\n        raise TypeError(\"Input must be an integer\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * factorial(n - 1)"
      ],
      [
        0.9204044342041016,
        "def factorial(n):\n    \"\"\"\n    Return the factorial of n.\n    \n    >>> factorial(5)\n    120\n    >>> factorial(3)\n    6\n    >>> factorial(1)\n    1\n    >>> factorial(0)\n    1\n    \"\"\"\n    # base case: factorial of 1 is 1\n    if n == 1:\n        return 1\n    else:\n        # recursive case: n! = n * (n-1)!\n        return n * factorial(n-1)"
      ],
      [
        0.9198404550552368,
        "def factorial(n):\n    \"\"\"\n    Return the factorial of n.\n    \n    >>> factorial(5)\n    120\n    >>> factorial(3)\n    6\n    >>> factorial(1)\n    1\n    >>> factorial(0)\n    1\n    \"\"\"\n    # Check that the input is a positive integer\n    if not n >= 0:\n        print(\"Input must be a positive integer\")\n        return None\n    # The base case: 0! = 1\n    elif n == 0:\n        return 1\n    # Recursive case: n! = n * (n-1)!\n    else:\n        return n * factorial(n-1)"
      ]
    ],
    "HumanEval/140": [
      [
        0.9504166841506958,
        "def fix_spaces(text):\n    \"\"\"\n    \"\"\"\n    text = re.sub(r' {2,}', '-', text) # replaces instances of two or more consecutive spaces with a dash\n    text = re.sub(r' $', '!', text) # replaces a single space at the end of the string with an exclamation mark\n    text = text.replace(\" \", \"_\") # replaces all other single spaces with underscores\n    text = re.sub(r'-\\b', '_', text) # replaces a dash followed by word boundary with underscore\n    text = re.sub(r'-{2,}$', lambda m: '!'*len(m.group()), text) # replaces ending dashes with exlamation marks.\n    \n    return text"
      ],
      [
        0.9331302642822266,
        "def underscore_spaces(text):\n    \"\"\"\n    Converts a string with spaces to a string with underscores.\n    \n    Args:\n        text (str): The string to convert.\n        \n    Returns:\n        str: The converted string.\n    \"\"\"\n    keywords = [\n        # Add more programming keywords here\n        'if', 'else', 'while', 'for', 'return', \n        'int', 'float', 'def', 'class', 'public', \n        'private', 'protected'\n    ]\n    series = []\n    current_word = ''\n    \n    for c in text:\n        if c == ' ':\n            if current_word not in keywords:\n                current_word = current_word.replace(' ', '_')\n            series.append(current_word)\n            current_word = ''\n        else:\n            current_word += c\n    if current_word not in keywords:\n        current_word = current_word.replace(' ', '_')\n    series.append(current_word)\n\n    return ' '.join(series)"
      ],
      [
        0.9230737686157227,
        "def replace_spaces_with_underscores(text):\n    \"\"\"\n    Replace spaces with underscores in a given text.\n    \n    Args:\n        text (str): The input text.\n        \n    Returns:\n        str: The text with spaces replaced by underscores.\n    \"\"\"\n    return text.replace(\" \", \"_\")"
      ],
      [
        0.913632333278656,
        "def replace_space(string):\n    \"\"\"\n    Replace all spaces in a string with underscores.\n    \n    >>> replace_space(\"I am a string!\")\n    'I_am_a_string!'\n    \"\"\"\n    return string.replace(\" \", \"_\")"
      ],
      [
        0.9091977477073669,
        "def add_underscores(text):\n    \"\"\"\n    Add underscores to words that end with punctuation.\n    \n    >>> add_underscores(\"This is a test.\")\n    'This_is_a_test.'\n    >>> add_underscores(\"This is a test!\")\n    'This_is_a_test!'\n    >>> add_underscores(\"This is a test?\")\n    'This_is_a_test?'\n    >>> add_underscores(\"This is a test!\")\n    'This_is_a_test!'\n    >>> add_underscores(\"This is a test!\")\n    'This_is\"\"\"\n    results = re.sub(r'(\\b\\w+[.,;:!?\\-])(\\s)', lambda match: match.group(1) + '_' + match.group(2), text)\n    return ''.join(results)"
      ],
      [
        0.9075530171394348,
        "def integrate_underscores(text):\n    \"\"\"\n    Replace spaces after words followed by punctuation with underscores.\n    \n    Args:\n        text (str): The text to be processed.\n    \n    Returns:\n        str: The processed text with underscores instead of spaces.\n    \"\"\"\n    # find words followed by punctuation and replace the space after with '_'\n    return re.sub(r'(\\w+[\\.,;:!?\\)])( )', r'\\1_', text)"
      ],
      [
        0.9074998497962952,
        "def sophisticated_text_modification(input_text):\n    \"\"\"\n    \"\"\"\n    # Remove excess spaces\n    input_text = re.sub(' +', ' ', input_text)\n\n    # Split words\n    words = input_text.split(' ')\n    \n    # Convert all words into upper case\n    words = [word.upper() for word in words]\n\n    # Join words with underscores\n    input_text = '_'.join(words)\n    \n    # Replace two or more successive underscores with a hyphen\n    input_text = re.sub('_+', '-', input_text)\n\n    return input_text"
      ],
      [
        0.9072759747505188,
        "def underscore_punctuation(text):\n    \"\"\"\n    Replace spaces between words with underscores in a given text.\n\n    Args:\n        text (str): The input text.\n\n    Returns:\n        str: The text with spaces between words replaced with underscores.\n    \"\"\"\n    # Define a Regular Expression pattern to match punctuated words, while excluding punctuations within parentheses, quotes, HTML tags, URLs, markdown syntax, special symbols, mathematical equations, and code snippets.\n    pattern = r'(?<![<\\[\\\"\\(\\\\])(\\b[\\w]+\\b(?=[\\.\\?\\!\\:\\;]))\\s(?!\\s*?(<|\\[|\\\"|\\(|\\\\))'\n\n    # Use the re.sub() function to replace matched spaces with underscores.\n    result = re.sub(pattern, r'\\1_', text)\n\n    return result"
      ],
      [
        0.907170295715332,
        "def convert_underscore_string(string):\n    \"\"\"\n    Converts a string with underscores to a string with spaces.\n    \n    >>> convert_underscore_string(\"hello_world\")\n    'Hello World'\n    \"\"\"\n    words = string.split('_')\n\n    new_string = \"\"\n    for word in words:\n        new_string += word.capitalize()\n        new_string += \" \"\n\n    return new_string[:-1]"
      ],
      [
        0.9067783355712891,
        "def underscore_punctuation(text):\n    \"\"\"\n    Replace spaces around punctuation with underscores\n    :param text:\n    :return:\n    \"\"\"\n    # It's match URLs using a simple regex first and replace them temporarily\n    url_pattern = re.compile(r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\\\(\\\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+')\n    urls = re.findall(url_pattern, text)\n    for i, url in enumerate(urls):\n        text = text.replace(url, 'URLPLACEHOLDER{}'.format(i))\n\n    # Then we match HTML tags and replace them\n    html_tag_pattern = re.compile('<.*?>')\n    html_tags = re.findall(html_tag_pattern, text)\n    for i, html_tag in enumerate(html_tags):\n        text = text.replace(html_tag, 'HTMLTAGPLACEHOLDER{}'.format(i))\n\n    # Now let's match anything that is enclosed in quotes or parentheses and replace them\n    quotes_pattern = re.compile(r'[{\"\\[\\']].*?[\"\\)\\'])')\n    quotes = re.findall(quotes_pattern, text)\n    for i, quote in enumerate(quotes):\n        text = text.replace(quote, 'QUOTEPLACEHOLDER{}'.format(i))\n\n    # Split words and replace spaces around punctuation with underscores\n    words = text.split(' ')\n    for i in range(len(words)):\n        if any(char in string.punctuation for char in words[i]):\n            words[i] = words[i].replace(' ', '_')\n    text = ' '.join(words)\n\n    # Finally replace placeholders with originals\n    for i, url in enumerate(urls):\n        text = text.replace('URLPLACEHOLDER{}'.format(i), url)\n    for i, html_tag in enumerate(html_tags):\n        text = text.replace('HTMLTAGPLACEHOLDER{}'.format(i), html_tag)\n    for i, quote in enumerate(quotes):\n        text = text.replace('QUOTEPLACEHOLDER{}'.format(i), quote)\n\n    return text"
      ]
    ],
    "HumanEval/141": [
      [
        0.9476853609085083,
        "def file_name_check(file_name):\n    \"\"\"\n    Check if the given file name is valid.\n    \n    Args:\n        file_name (str): The name of the file to check.\n        \n    Returns:\n        str: \"Yes\" if the file name is valid, \"No\" otherwise.\n    \"\"\"\n    # Check if the file's name length is within the allowed range\n    if not 5 <= len(file_name) <= 50:\n        return \"No\"\n    \n    name, dot, extension = file_name.rpartition('.')\n    \n    # Check if the file's name has exactly one dot and a valid extension\n    if not dot or extension not in ['txt', 'exe', 'dll', 'pdf', 'jpeg']:\n        return \"No\"\n    \n    # Check if the file's name has valid alphanumeric characters, and has at least\n    # one uppercase, one lowercase, and maximum of three consecutive digits\n    if not (re.match(r'[A-Za-z].*$', name) and\n            re.search(r'[A-Z]', name) and\n            re.search(r'[a-z]', name) and\n            not re.search(r'\\d{4,}', name)):\n        return \"No\"\n    \n    # Check if the file's name has exactly two latin alphabet letters\n    if len(re.findall(r'[A-Za-z]', name)) < 2:\n        return \"No\"\n    \n    return \"Yes\""
      ],
      [
        0.9475350379943848,
        "def file_name_check(file_name):\n    \"\"\"\n    Check if the given file name is valid.\n\n    Args:\n        file_name (str): The name of the file to check.\n\n    Returns:\n        str: \"Yes\" if the file name is valid, \"No\" otherwise.\n    \"\"\"\n    # Check if the file's name length is within the allowed range\n    if not 5 <= len(file_name) <= 50:\n        return \"No\"\n\n    name, dot, extension = file_name.rpartition('.')\n\n    # Check if the file's name has exactly one dot and a valid extension\n    if not dot or extension not in ['txt', 'exe', 'dll', 'pdf', 'jpeg']:\n        return \"No\"\n\n    # Check if the file's name has valid alphanumeric characters, and has at least\n    # one uppercase, one lowercase, and maximum of three consecutive digits\n    if not (re.search(r'[A-Za-z].*', name) and\n            re.search(r'[A-Z]', name) and\n            re.search(r'[a-z]', name) and\n            not re.search(r'\\d{4,}', name)):\n        return \"No\"\n\n    # Check if the file's name has exactly two latin alphabet letters\n    if len(re.findall(r'[A-Za-z]', name)) != 2:\n        return \"No\"\n    \n    return \"Yes\""
      ],
      [
        0.9323183298110962,
        "def file_name_check(file_name):\n    \"\"\"\n    Check if the given file name is valid.\n    \n    Args:\n        file_name (str): The file name to check.\n    \n    Returns:\n        str: 'Yes' if the file name is valid, 'No' otherwise.\n    \"\"\"\n    # Check for the reserved Windows characters\n    reserved_chars = ['<', '>', ':', '\"', '/', '\\\\', '|', '?', '*']\n    if any(c in file_name for c in reserved_chars):\n        return 'No'\n    # Check for the length requirement\n    if not (5 <= len(file_name) <= 50):\n        return 'No'\n    # Check if the file name has exactly one dot and get the name and extension parts\n    parts = file_name.split('.')\n    if len(parts) != 2:\n        return 'No'\n    name, extension = parts\n    # Check the conditions for the name part\n    if not re.match(r'^[a-zA-Z][a-zA-Z0-9]*$', name) or not any(c.isupper() for c in name) or not any(c.islower() for c in name) or len(re.findall(r'\\d{4,}', name)) > 0:\n        return 'No'\n    # Check the conditions for the extension part\n    if extension not in ['txt', 'exe', 'dll', 'pdf', 'jpeg']:\n        return 'No'\n    return 'Yes'"
      ],
      [
        0.9318896532058716,
        "def complex_file_name_validator(file_name):\n    \"\"\"\n    This function checks if the given file name is valid or not.\n    It returns 'Yes' if the file name is valid, and 'No' otherwise.\n    \"\"\"\n    import re\n\n    # Check if the file name is empty\n    if not file_name:\n        return 'No'\n\n    # Check if the file name contains any special characters\n    if re.search(r'[^a-zA-Z0-9.]', file_name):\n        return 'No'\n\n    # Check if the file name contains any consecutive numbers\n    if re.search(r\"\"\"\n    # Check if length of tile name is good\n    if len(file_name) < 5 or len(file_name) > 50:\n        return 'No'\n\n    # Check for only alphanumeric characters, at least 1 uppercase and lowercase letter and one dot\n    if not re.match(r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[.])[^A-Z]*{A-Z}[^A-Z]*$', file_name):\n        return 'No'\n\n    # Check for more than three consecutive numbers\n    if re.search(r'\\d{4,}', file_name):\n        return 'No'\n\n    # Check the substring before dot\n    split_name = file_name.split('.')\n\n    # Check for multiple extensions\n    if len(split_name) != 2:\n        return 'No'\n\n    # Check if substring before dot starts with alphabet and of length at least 2\n    if not re.match(r'^[a-zA-Z]', split_name[0]) or len(split_name[0]) < 2:\n        return 'No'\n\n    # Check for valid extensions\n    valid_extensions = ['txt', 'exe', 'dll', 'pdf', 'jpeg']\n    if split_name[1] not in valid_extensions:\n        return 'No'\n\n    # If all the conditions are satisfied, return 'Yes'\n    return 'Yes'"
      ],
      [
        0.9311316013336182,
        "def validate_file_name(file_name):\n    \"\"\"\n    Check if the given file name is valid.\n    \n    Args:\n        file_name (str): The file name to check.\n        \n    Returns:\n        str: 'Yes' if the file name is valid, 'No' otherwise.\n    \"\"\"\n    # Check for the reserved Windows characters\n    reserved_chars = {'<', '>', ':', '\"', '/', '\\\\', '|', '?', '*'}\n    if any(c in file_name for c in reserved_chars):\n        return 'No'\n    # Check for the length requirement\n    if not (5 <= len(file_name) <= 50):\n        return 'No'\n    # Check if the file name has exactly one dot and get the name and extension parts\n    parts = file_name.split('.')\n    if len(parts) != 2:\n        return 'No'\n    name, extension = parts\n    # Check the conditions for the name part\n    if not re.match(r'^[a-zA-Z][a-zA-Z0-9]*$', name) \\\n       or not any(c.isupper() for c in name) \\\n       or not any(c.islower() for c in name) \\\n       or len(re.findall(r'\\d{4,}', name)) > 0:\n        return 'No'\n    # Check the conditions for the extension part\n    if extension not in ['txt', 'exe', 'dll', 'pdf', 'jpeg']:\n        return 'No'\n    return 'Yes'"
      ]
    ],
    "HumanEval/142": [
      [
        0.9176299571990967,
        "def positive_cubes_sum(lst):\n    '''\n    This function calculates sum of cubes of both odd and even positive integers in a list.\n    \n    positive_cubes_sum([1, 2, 3, 4]) == 1 + 8 + 27 + 64 = 100\n    positive_cubes_sum([-1, -2, 1, 2]) == 9\n    positive_cubes_sum([8, -3]) == 512\n    positive_cubes_sum([0]) == 0\n\n    If input is empty, function should return 0.\n    '''\n    return sum(i**3 for i in lst if i > 0)"
      ],
      [
        0.9146968126296997,
        "def sum_of_cubes(array):\n  \"\"\"\n  Return the sum of the cubes of all numbers in the array, except for numbers that are multiples of 3.\n  \"\"\"\n  total = 0\n  for i in range(len(array)):\n    # Check if i+1 is a multiple of 3\n    if (i + 1) % 3 == 0:\n      total -= array[i] ** 3\n    else:\n      total += array[i] ** 3\n  return total\n    def sum_of_cubes(array):\n  \"\"\"\n  Return the sum of the cubes of\"\"\"\n  total = 0\n  for i in range(len(array)):\n    # Check if i+1 is a multiple of 3\n    if (i + 1) % 3 == 0:\n      total -= array[i] ** 3\n    else:\n      total += array[i] ** 3\n  return total"
      ]
    ],
    "HumanEval/143": [
      [
        0.9533295035362244,
        "def words_in_sentence(sentence):\n    \"\"\"\n    Given a sentence, return a string of all the words whose length is a prime number.\n    \n    >>> words_in_sentence(\"Hello world\")\n    'Hello'\n    >>> words_in_sentence(\"It is raining cats and dogs\")\n    'It raining cats and dogs'\n    \"\"\"\n    # split the sentence into words\n    words = sentence.split(\" \")\n    \n    # create an empty list to store words\n    result = []\n\n    # iterate over each word in the sentence\n    for word in words:\n        # If length of word is a prime number\n        if is_prime(len(word)):\n            # append that word to result list\n            result.append(word)\n            \n    # Join words in the list into a string with space (' ') as the separator\n    # and return\n    return ' '.join(result)"
      ],
      [
        0.9463455080986023,
        "def wordsInSentence(sentence):\n    \"\"\"\n    Given a sentence, return a string of all the words in the sentence\n    that are prime numbers.\n    \n    >>> wordsInSentence(\"Hello world\")\n    'Hello'\n    >>> wordsInSentence(\"I am a prime number\")\n    'I a prime number'\n    >>> wordsInSentence(\"I am not a prime number\")\n    'I'\n    \"\"\"\n    output = \"\"\n    words = sentence.split()\n    for word in words:\n        word_stripped = word.strip('.,?!')  # Remove punctuation\n        if check_prime(len(word_stripped)):\n            if output != \"\":\n                output += \" \"\n            output += word\n    return output"
      ],
      [
        0.9141407608985901,
        "def prime_length_substrings(sentence):\n    \"\"\"\n    Given a sentence, return the longest substring of prime length.\n    \n    >>> prime_length_substrings(\"I am a boy\")\n    'I am a boy'\n    >>> prime_length_substrings(\"I am a boy\")\n    'I am a boy'\n    >>> prime_length_substrings(\"I am a boy\")\n    'I am a boy'\n    >>> prime_length_substrings(\"I am a boy\")\n    'I am a boy'\n    >>> prime_length_substrings(\"I am a boy\")\n    'I am\"\"\"\n    sentence = ''.join(sentence.split(' '))\n\n    # Stores the added characters\n    added_chars = set() \n    result = ''\n\n    # Check all substrings of prime lengths\n    for length in range(len(sentence)):\n        # Check if this length is prime\n        if is_prime(length):\n            for i in range(len(sentence) - length + 1):\n                substring = sentence[i:i + length]\n\n                # Check if any char in this substring is added before\n                is_added_before = False\n                for char in substring:\n                    if char in added_chars:\n                        is_added_before = True\n                        break\n\n                if not is_added_before: # If all chars are new\n                    result += substring\n                    for char in substring:\n                        added_chars.add(char)\n\n    return result"
      ]
    ],
    "HumanEval/144": [],
    "HumanEval/145": [
      [
        0.9173712134361267,
        "def orderSumDigits(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    def sum_of_digits(num):\n        return sum(int(digit) for digit in str(num))\n    \n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    for i in range(len(nums)):\n        max_index = i\n        for j in range(i+1, len(nums)):\n            if sum_of_digits(nums[j]) > sum_of_digits(nums[max_index]):\n                max_index = j\n        nums[i], nums[max_index] = nums[max_index], nums[i]\n    return nums"
      ],
      [
        0.9156618714332581,
        "def sortBySumOfDigits(lst):\n    \"\"\"\n    Given a list of numbers, return a list of numbers sorted by the sum of their digits.\n    \n    >>> sortBySumOfDigits([123456789, 1234567890, 12345678901, 123456789012])\n    [123456789012, 12345678901, 1234567890, 123456\"\"\"\n    return sorted(lst, key=lambda x: sum(map(int, str(x))))"
      ],
      [
        0.908204197883606,
        "def sort_by_digit_sum(arr):\n    \"\"\"\n    Sort an array of integers by the sum of their digits.\n    \n    Args:\n        arr (list): List of integers\n    \n    Returns:\n        list: Sorted list of integers\n    \"\"\"\n    return sorted(arr, key=lambda x: (sum(int(digit) for digit in str(x)), x))"
      ],
      [
        0.908193826675415,
        "def sort_by_digit_sum(arr):\n    \"\"\"\n    Sort an array of integers by the sum of their digits.\n    \n    Args:\n        arr (list): List of integers\n    \n    Returns:\n        list: Sorted list of integers\n    \"\"\"\n    return sorted(arr, key=lambda x: (sum(int(digit) for digit in str(x)), x))"
      ],
      [
        0.9069902896881104,
        "def sort_by_sum_of_digits(arr):\n    \"\"\"\n    Given an array of integers, sort the array in ascending order based on the sum of digits in each integer.\n    For example, the sum of digits in 25 is 7 (2 + 5) and the sum of digits in 8 is 8.\n    The array [25, 8, 12] will be sorted as [8, 25, 12].\n    :param arr: array of integers\n    :return: sorted array\n    \"\"\"\n    # Base case\n    if not arr:\n        return []\n\n    # Initializing variables\n    result = []\n    sum_of_digits = []\n\n    for i in range(0, len(arr)):\n        # Calculating the sum of digits of each element in the array\n        digit_sum = 0\n        for j in str(arr[i]):\n            digit_sum += int(j)\n\n        # Storing the number and its sum of digits in two separate lists\n        result.append(arr[i])\n        sum_of_digits.append(digit_sum)\n\n    # Sorting the sums list and storing the index of the sorted list.\n    sorted_index = [i[0] for i in sorted(enumerate(sum_of_digits), key=lambda p: p[1])]\n\n    # Preparing the sorted array based on the index of the sorted list.\n    sorted_arr = []\n    for k in sorted_index:\n        sorted_arr.append(result[k])\n\n    return sorted_arr"
      ],
      [
        0.9067859649658203,
        "def sort_by_sum_of_digits(lst):\n    \"\"\"\n    Sort a list of numbers by the sum of their digits in descending order.\n    \n    Args:\n        lst (list): A list of numbers.\n    \n    Returns:\n        list: A list of numbers sorted by the sum of their digits in descending order.\n    \"\"\"\n    return sorted(lst, key=lambda x: sum_of_digits(x), reverse=True)"
      ]
    ],
    "HumanEval/146": [
      [
        0.9138548374176025,
        "def count_odd_numbers(arr):\n    \"\"\"\n    Count the number of odd numbers in the array that are greater than 10 and less than 100.\n    \n    Args:\n        arr (list): List of integers\n    \n    Returns:\n        int: Number of odd numbers in the array\n    \"\"\"\n    count = 0\n    for num in arr:\n        if num > 10 and num < 100 and num % 2 != 0:\n            count += 1\n    return count"
      ],
      [
        0.9111778736114502,
        "def count_odd_numbers(arr):\n    \"\"\"\n    Count the number of odd numbers in the array that are greater than 10 and less than 100.\n    \n    Args:\n        arr (list): List of integers\n    \n    Returns:\n        int: Number of odd numbers in the array\n    \"\"\"\n    odd_numbers = []\n    for num in arr:\n        if num > 0 and num % 2 != 0 and num > 10 and num < 100:\n            odd_numbers.append(num)\n    \n    count = 0\n    for i in range(len(odd_numbers)):\n        is_duplicate = False\n        for j in range(i+1, len(odd_numbers)):\n            if odd_numbers[i] == odd_numbers[j]:\n                is_duplicate = True\n                break\n        if not is_duplicate:\n            count += 1\n    \n    return count"
      ]
    ],
    "HumanEval/147": [
      [
        0.9493870735168457,
        "def get_max_triples(n):\n    \"\"\"\n    Given an integer n, return the number of triples (a, b, c) such that a < b < c and a * b % c == 0.\n    :param n: Integer\n    :return: Integer\n    \"\"\"\n    # Create an array 'a' of length 'n' with elements as per the given formula\n    a = [(i * i - i + 1) + (i % 3) for i in range(1, n + 1)]\n    triple_count = 0  # Initialize variable to count triples\n\n    #For all possible combinations of three items (a[i], a[j], a[k])\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                # Calculate the modulus of the product of any two elements by the third\n                product = (a[i] * a[j]) % a[k]\n                # Check if the result is a multiple of n\n                if product % n == 0:\n                    triple_count += 1  # Increment the counter if true\n\n    return triple_count  # Return the number of desired triples"
      ],
      [
        0.9346858859062195,
        "def get_matrix_triples(n):\n    \"\"\"\n    This function calculates the number of triples in a list of numbers.\n    The list is generated by the formula: a[i] = i * i - i + 1\n    The function returns the number of triples in the list.\n    :param n: The number of elements in the list.\n    :return: The number of triples in the list.\n    \"\"\"\n    # Initialize the list 'a', 'count' and 'pairs' as per the requirement.\n    a = [0]*n\n    count = [0]*3\n    pairs = [0]*3\n\n    triples = 0\n\n    # This loop will calculate the values of 'a' and increment the respective 'count'.\n    for i in range(n):\n        a[i] = i * i - i + 1\n        count[a[i] % 3] += 1\n\n    # This loop calculates the values of 'pairs' and 'triples' as per the given logic.\n    for j in range(3):\n        for k in range(j+1, 3):\n            pairs[k] += count[j]*count[k]\n        triples += (count[j]*(count[j]-1)*(count[j]-2))//6  # Use '//' for integer division\n\n    triples += pairs[0] + 2*(pairs[1]+pairs[2])\n\n    # returns the number of triples.\n    return triples"
      ],
      [
        0.9174444675445557,
        "def get_max_triples(n, p):\n    \"\"\"\n    Calculate the number of triples (a[i], a[j], a[k]) such that\n    i < j < k and (a[i] * a[j]) % a[k] is a multiple of n or p.\n\n    Parameters:\n    n (int): The first number.\n    p (int): The second number.\n\n    Returns:\n    int: The number of triples.\n    \"\"\"\n    # calculate the array 'a' according to formula\n    a = [(i * i - i + p) + (i % p) for i in range(1, n+1)]\n    \n    # initialize count of triples to 0\n    counters = 0\n\n    # consider all triples a[i], a[j], a[k] such that i < j < k\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                # calculate modulus of product a[i]*a[j] by a[k]\n                product_modulus = (a[i] * a[j]) % a[k]\n\n                # check if the result is a multiple of n or p, increment the count\n                if product_modulus % n == 0 or product_modulus % p == 0:\n                    counters += 1\n\n    return counters"
      ]
    ],
    "HumanEval/148": [
      [
        0.9597816467285156,
        "def bf(planet1, planet2, planet3):\n    \"\"\"\n    Given the names of three planets, return a tuple of the names of planets that are in between the first and third planet.\n    \n    The names of the planets will be strings, and the names will not be repeated.\n    \n    If there are fewer than two planets between the two outer planets, return an empty tuple.\n    \n    The order of the planets in the tuple does not matter.\n    \n    For example:\n    \n    bf(\"Earth\", \"Mars\", \"Venus\") \u279e (\"Mars\", \"Venus\")\n    \n    bf(\"Mercury\", \"Jupiter\", \"Saturn\"\"\"\n    if is_valid(planet1) and is_valid(planet2) and is_valid(planet3): \n        # sort the planets based on their position in the solar system\n        planets = sorted([planet1, planet2, planet3], key=SOLAR_SYSTEM.index)\n        return get_neighbors(planets[-1])  # return the neighbors of the furthest planet\n    else:\n        return ()"
      ],
      [
        0.9540389180183411,
        "def bf(planet1, planet2):\n    \"\"\"\n    Find the planets between two planets in a solar system.\n\n    Args:\n        planet1 (str): The name of the first planet.\n        planet2 (str): The name of the second planet.\n\n    Returns:\n        tuple: A tuple containing the names of the planets between planet1 and planet2.\n    \"\"\"\n    solar_system = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n\n    if is_valid(planet1) and is_valid(planet2):\n        planet1_index = solar_system.index(planet1.capitalize())\n        planet2_index = solar_system.index(planet2.capitalize())\n\n        if planet1_index < planet2_index:\n            return tuple(solar_system[i] for i in range(planet1_index + 1, planet2_index))\n        \n        if planet2_index < planet1_index:\n            return tuple(solar_system[i] for i in range(planet2_index + 1, planet1_index))\n        \n        return ()\n\n    else:\n        return ()"
      ],
      [
        0.9445393085479736,
        "def bf(planet1, planet2):\n    \"\"\"\n    \"\"\"\n    if is_valid(planet1) and is_valid(planet2):\n        list_of_planets = sorted(planet_distances.items(), key=lambda x: x[1])\n        planet1_index = next(i for i,v in enumerate(list_of_planets) if v[0]==planet1)\n        planet2_index = next(i for i,v in enumerate(list_of_planets) if v[0]==planet2)\n        if planet1_index < planet2_index:\n            return tuple(list_of_planets[planet1_index+1 : planet2_index])\n        else:\n            return tuple(list_of_planets[planet2_index+1 : planet1_index])\n    else:\n        return ()"
      ],
      [
        0.9445198774337769,
        "def bf(planet1, planet2):\n    \"\"\"\n    \"\"\"\n    if is_valid(planet1) and is_valid(planet2):\n        list_of_planets = sorted(planet_distances.items(), key=lambda x: x[1])\n        planet1_index = next(i for i,v in enumerate(list_of_planets) if v[0]==planet1)\n        planet2_index = next(i for i,v in enumerate(list_of_planets) if v[0]==planet2)\n        if planet1_index < planet2_index:\n            return tuple(list_of_planets[planet1_index+1 : planet2_index])\n        else:\n            return tuple(list_of_planets[planet2_index+1 : planet1_index])\n    else:\n        return ()"
      ],
      [
        0.9416651725769043,
        "def bf(planet1, planet2):\n    \"\"\"\n    Returns a tuple of tuples of the form (planet_name, time_to_planet)\n    for all planets between planet1 and planet2.\n    \n    If either planet is invalid, return an empty tuple.\n    \n    Parameters\n    ----------\n    planet1 : str\n        The name of the first planet.\n    planet2 : str\n        The name of the second planet.\n        \n    Returns\n    -------\n    tuple\n        A tuple of tuples of the form (planet_name, time_to_planet).\n    \"\"\"\n    if is_valid(planet1) and is_valid(planet2):\n        # Sorted list of planet names\n        sorted_planets = sorted(PLANETS, key=PLANETS.get)\n        \n        idx1, idx2 = sorted_planets.index(planet1), sorted_planets.index(planet2)\n        # Ensure idx1 is always less than idx2\n        if idx2 < idx1:\n            idx1, idx2 = idx2, idx1       \n        planets_between = sorted_planets[idx1+1:idx2]\n        \n        result = []\n        for planet in planets_between:\n            # Calculate time to travel from the sun to each planet at the speed of light\n            time_to_planet = PLANETS[planet]*10**6/SPEED_OF_LIGHT\n            result.append((planet, time_to_planet)) \n            \n        return tuple(result)\n    else:\n        return ()"
      ]
    ],
    "HumanEval/149": [
      [
        0.9483717679977417,
        "def complex_sorted_list(lst, reverse=False, min_sum=0, max_sum=None, sort_function=None, secondary_sort_function=None):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter and performs the following:\n    - Delete strings with odd lengths or containing numerals.\n    - Sort the list based on the sum of the ASCII values of the characters in each string.\n    - The list may contain duplicates, ignore case, and special characters.\n    - Toggle sorting between ascending and descending order using an optional boolean `reverse` (default is False).\n    - Implement an optional minimum sum `min_sum` (default is 0) to return only strings with a sum greater or equal.\n    - Implement an optional maximum sum `max_sum` to return only strings with a sum less than or equal.\n    - Implement an optional custom sorting method `sort_function` to sort strings using a custom function.\n    - Implement an optional secondary custom sorting method `secondary_sort_function` to sort strings using a secondary function.\n    \n    E.g.:\n    assert complex_sorted_list([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert complex_sorted_list([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    assert complex_sorted_list([\"ab\", \"a\", \"aaa\", \"cd\"], True) => [\"cd\", \"ab\"]\n    assert complex_sorted_list([\"ab\", \"a\", \"aaa\", \"cd\"], min_sum=200) => [\"cd\"]\n    \"\"\"\n    \n    # Remove strings with odd lengths and strings containing numerals\n    clean_lst = [s for s in lst if len(s) % 2 == 0 and not any(c.isdigit() for c in s)]\n    \n    if not sort_function:\n        sort_function = lambda s: sum(ord(c) for c in s)\n    \n    if secondary_sort_function:\n        clean_lst.sort(key=secondary_sort_function)\n    \n    # Sort strings based on the sort_function\n    clean_lst.sort(key=sort_function, reverse=reverse)\n    \n    # Filter strings based on min_sum and max_sum\n    filtered_lst = [s for s in clean_lst if min_sum <= sort_function(s) <= (max_sum if max_sum else float(\"inf\"))]\n    \n    return filtered_lst"
      ],
      [
        0.9397662878036499,
        "def sorted_list(lst, reverse=False):\n    \"\"\"\n    This function takes a list of string literals, discards strings that are of odd lengths or contain digits, \n    and returns a sorted list according to the specified stipulations.\n    The list is sorted based on the length of each word in an ascending sequence. \n    For words of equivalent length, it is sorted in alphabetical order. \n    Case sensitivity and special characters are ignored during the sorting operation.\n    An optional boolean parameter `reverse`, with a default value set to False, can be used to toggle the sorting pattern \n    between ascending and descending.\n    Note:\n    The input will always be a list of string literals and can never be of numeric type.\n    The list can have duplicate elements.\n    \"\"\"\n    import re\n    \n    # Filter out string literals of odd length and those containing digits\n    filtered_list = [x for x in lst if len(x) % 2 == 0 and not bool(re.search(r'\\d', x))]\n    \n    # Sort the list first by length, then by alphabetical order (case insensitive), and optionally in reverse order\n    return sorted(filtered_list, key=lambda x: (len(x), x.lower()), reverse=reverse)"
      ],
      [
        0.9341539144515991,
        "def advanced_array_aggregation(lst, reverse=False):\n    \"\"\"\n    This function accepts a list of strings, filters the list by dropping strings of odd length or containing numbers, \n    and returns a sorted list based on the following criteria:\n    - All list entries must be strings, no grouping of numbers allowed\n    - Duplicates in the list are possible\n    - List is sorted in ascending order based on word length, and then alphabetically for words of same length\n    - Ignore capitalization and special characters during sorting\n    Additionally, sorting order can be switched by initializing an optional logical 'reverse' parameter.\n\n    Furthermore, the function should also check for characters that appear more than twice in a single string and \n    discard these strings from the list.\n    \"\"\"\n    # We filter the strings of odd length or containing numbers\n    filtered = [s for s in lst if len(s) % 2 == 0 and not any(c.isdigit() for c in s)]\n    \n    # We check for characters that appear more than twice in a single string and discard these strings\n    filtered = [s for s in filtered if all(v <= 2 for v in Counter(s).values())]\n    \n    # Ignore capitalization and special characters during sorting\n    filtered = [\"\".join(ch for ch in s if ch.isalnum()) for s in filtered]\n    filtered = [s.lower() for s in filtered]\n    \n    # Add some complexity by sorting the list according to length, and then by lexical order\n    filtered = sorted(filtered, key=lambda s: (len(s), s), reverse=reverse)\n\n    return filtered"
      ],
      [
        0.9340560436248779,
        "def advanced_array_aggregation(lst, reverse=False):\n    \"\"\"\n    This function accepts a list of strings, filters the list by dropping strings of odd length or containing numbers,\n    and returns a sorted list based on the following criteria:\n    = All list entries must be strings; no grouping of numbers allowed\n    = Duplicates in the list are possible\n    = List is sorted in ascending order based on word length, and then alphabetically for words of the same length\n    = Ignore capitalization and special characters during sorting\n    Additionally, sorting order can be switched by initializing an optional logical 'reverse' parameter.\n\n    Furthermore, the function should also check for characters that appear more than twice in a single string and\n    discard these strings from the list.\n    \"\"\"\n\n    # We filter the strings of odd length or containing numbers\n    filtered = [s for s in lst if len(s) % 2 == 0 and not any(c.isdigit() for c in s)]\n    \n    # We check for characters that appear more than twice in a single string and discard these strings\n    filtered = [s for s in filtered if all(v <= 2 for v in Counter(s).values())]\n    \n    # Ignore capitalization and special characters during sorting\n    filtered = [\"\".join(ch for ch in s if ch.isalnum()) for s in filtered]\n    filtered = [s.lower() for s in filtered]\n\n    # Add some complexity by sorting the list according to length, and then by lexical order\n    filtered = sorted(filtered, key=lambda s: (len(s), s) , reverse=reverse)\n    \n    return filtered"
      ],
      [
        0.9296247363090515,
        "def sorted_list_sum(lst, reverse=False):\n    \"\"\"Craft a utility that takes a string list as a parameter,\n    expunges strings of odd length or those containing digits,\n    and delivers back the sorted list as per the stipulations.\n    \"\"\"\n    filtered = [string for string in lst if len(string) % 2 == 0 and not any(char.isdigit() for char in string)]\n    sorted_list = sorted(filtered, key=lambda x: (len(x), x.casefold()), reverse=reverse)\n    return sorted_list"
      ],
      [
        0.9282634854316711,
        "def advanced_list_transformer(lst, flip=False):\n    \"\"\"\n    \"\"\"\n    # Remove strings that contain even number of characters\n    # or include special characters\n    lst = [s for s in lst if len(s) % 2 != 0 and s.isalpha()]\n        \n    # Sort the list based on the descending order of word lengths\n    # and for words of the same length, sort them in reverse alphabetical order\n    lst.sort(key=lambda s: (-len(s), s), reverse=flip)\n    \n    return lst"
      ],
      [
        0.9278987646102905,
        "def amplified_sorted_list_sum(lst, reverse=False):\n    \"\"\"\n    Return the sum of the numbers in lst,\n    except the lowest and highest value in nums.\n    \n    nums must be length 3 or more.\n    \n    If nums is length 2 or less, then return 0.\n    \n    If there are ties for \"lowest\" or \"highest\",\n    then remove all instances of the lowest or highest values\n    in order to calculate the sum.\n    \n    \n    >>> amplified_sorted_list_sum([5, 3, 2, 4])\n    12\n    >>> amplified_sorted_list\"\"\"\n    # Remove elements from the list that have a length of an odd number or contain numerals\n    lst = [i for i in lst if len(i) % 2 == 0 and not any(char.isdigit() for char in i)]\n    # Sort the list by length of the word and then by alphabetically, consider case insensitivity\n    lst = sorted(lst, key=lambda x: (len(x), x.lower()), reverse=reverse)\n    \n    return lst"
      ]
    ],
    "HumanEval/150": [
      [
        0.9513624906539917,
        "def x_or_y(n, x, y):\n    \"\"\"\n    Return x if n is prime, otherwise return y.\n    \"\"\"\n    return x if _is_prime(n) else y\n    def x_or_y(n, x, y):\n    \"\"\"\n    Return x if n is prime, otherwise return y.\n    \"\"\"\n    return x if _is_prime(n) else y"
      ],
      [
        0.9137944579124451,
        "def is_prime(num):\n    \"\"\"Modify this function to check if the input number is a prime number.\"\"\"\n    if num > 1:\n        # check for factors\n        for i in range(2, num):\n            if (num % i) == 0:\n                return False\n        else: \n            return True\n    else:\n        return False"
      ],
      [
        0.9123939275741577,
        "def prime(n):\n    \"\"\"\n    \"\"\"\n    if n == 1:\n        return False\n    elif n == 2:\n        return True\n    else:\n        for x in range(2,n):\n            if (n % x) == 0:\n                return False\n        return True            "
      ]
    ],
    "HumanEval/151": [
      [
        0.9336295127868652,
        "def sum_odd_numbers(lst):\n    \"\"\"\n    Given a list of numbers, return the sum of all odd numbers in the list.\n    \n    >>> sum_odd_numbers([1, 2, 7, -5])\n    9\n    \n    >>> sum_odd_numbers([1, 2, 8, 9, 10, 11, 12, 13, 14, 15])\n    26\n    \n    >>> sum_odd_numbers([])\n    0\n    \"\"\"\n    result = 0\n    for num in lst:\n        if num % 2 == 1:\n            result += num\n    return result"
      ],
      [
        0.9273509979248047,
        "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)"
      ],
      [
        0.9223254919052124,
        "def positive_cubes_sum(lst):\n    '''\n    This function calculates sum of cubes of both odd and even positive integers in a list.\n    \n    positive_cubes_sum([1, 2, 3, 4]) == 1 + 8 + 27 + 64 = 100\n    positive_cubes_sum([-1, -2, 1, 2]) == 9\n    positive_cubes_sum([8, -3]) == 512\n    positive_cubes_sum([0]) == 0\n\n    If input is empty, function should return 0.\n    '''\n    return sum(i**3 for i in lst if i > 0)"
      ],
      [
        0.9208054542541504,
        "def enhanced_solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are at even positions.    \n\n    Examples\n    enhanced_solution([5, 8, 7, 1]) => 5\n    enhanced_solution([3, 3, 3, 3, 3]) => 9\n    enhanced_solution([30, 13, 24, 321]) => 30\n    \"\"\"\n    return sum(num for i, num in enumerate(lst[::2]) if num % 2 == 1)"
      ]
    ],
    "HumanEval/152": [
      [
        0.9269453883171082,
        "def compare(scores, guesses):\n    \"\"\"\n    Compares the scores and guesses and returns a list of differences\n    :param scores: list of scores\n    :param guesses: list of guesses\n    :return: list of differences\n    \"\"\"\n    differences = []\n    for score, guess in zip(scores, guesses):\n        difference = abs(score - guess)\n        if guess == score:\n            differences.append(difference)\n        else:\n            if guess == 0 and score != 0:\n                difference += 2\n            differences.append(difference)\n    return differences"
      ],
      [
        0.9019462466239929,
        "def Compare(game, guess):\n    \"\"\"\n    Compare the game and guess and return a list of differences\n    :param game: the game to compare\n    :param guess: the guess to compare\n    :return: a list of differences\n    \"\"\"\n    differences = [abs(a-b) for a,b in zip(game, guess)]\n    # calculate variance\n    n = len(differences)\n    mean = sum(differences) / n\n    variance = sum((xi - mean) ** 2 for xi in differences) / n\n    # calculate standard deviation\n    std_dev = math.sqrt(variance)\n    # append variance and std_dev to differences\n    differences.append(variance)\n    differences.append(std_dev)\n    return differences"
      ]
    ],
    "HumanEval/153": [
      [
        0.8780055046081543,
        "def find_max(words, case_sensitive=False):\n    \"\"\"This function accepts a list of unique strings as its primary input.\n    Its output is the word with the greatest count of distinguished characters.\n    In the event of a tie, yield the word that appears first lexicographically.\n    If case_sensitive is specified as True, cases of characters are deemed distinct.\n    \"\"\"\n    if not case_sensitive:\n        # convert all words to lower case\n        words = [word.lower() for word in words]\n    \n    # create a list of tuples, with each tuple containing a word and its corresponding\n    # count of unique characters\n    words_and_counts = [(word, len(set(word))) for word in words]\n    \n    # sort the list of tuples lexicographically and by descending order of counts\n    words_and_counts.sort(key = lambda x: (-x[1], x[0]))\n    \n    # return the word with the maximum count of unique characters, or the\n    # lexicographically first word in case of a tie\n    return words_and_counts[0][0]"
      ],
      [
        0.875739574432373,
        "def find_max(words, case_sensitive=False):\n    \"\"\"\n    This function accepts a list of distinct strings as an input, \n    It returns the string with the greatest number of unique characters.\n    If there is a tie, it provides the first word in lexicographical order. \n    Character cases are considered separate only if the parameter case_sensitive is set to True.\n\n    >>> find_max([\"name\", \"of\", \"string\"], True)\n    'string'\n    >>> find_max([\"name\", \"enam\", \"game\"])\n    'enam'\n    >>> find_max([\"aaaaaaa\", \"b13\" ,\"cc\"])\n    'aaaaaaa'\n    \"\"\"\n    \n    # Error handling for bad input types\n    if not isinstance(words, list) or not all(isinstance(w, str) for w in words):\n        raise ValueError('Invalid input type. Please enter a list of strings')\n\n    # If case_sensitive is False, convert all words to lowercase. \n    words_lower  = [word.lower() for word in words] if not case_sensitive else words\n    \n    # Loop through the words and find the word with the most unique characters.\n    # In case of tie, return the word that comes first lexicographically.\n    max_unique_chars = 0\n    max_word = ''\n    for word in words_lower:\n        num_unique_chars = len(set(word))\n        if num_unique_chars > max_unique_chars:\n            max_unique_chars = num_unique_chars\n            max_word = word\n        elif num_unique_chars == max_unique_chars:\n            max_word = min(word, max_word)\n    return max_word"
      ],
      [
        0.875052809715271,
        "def find_max(words, case_sensitive=False):\n    \"\"\"This function accepts a list of distinct strings as an input. \n    It returns the string with the greatest number of unique characters. \n    If there is a tie, it provides the first word in lexicographical order. \n    Character cases are considered separate only if the parameter case_sensitive is set to True.\n\n    >>> find_max([\"name\", \"of\", \"String\"], True)\n    \"String\"\n    >>> find_max([\"name\", \"enam\", \"Game\"])\n    \"enam\"\n    >>> find_max([\"aaaaaaa\", \"BB\" ,\"cc\"])\n    \"aaaaaaa\"\n    \"\"\"\n    # Error handling for bad input types\n    if not isinstance(words, list) or not all(isinstance(i, str) for i in words):\n        raise ValueError('Invalid input type. Please enter a list of strings')\n\n    # If case_sensitive is False, convert all words to lowercase. \n    words_lower  = [word.lower() for word in words] if not case_sensitive else words\n\n    # Loop through the words and find the word with the most unique characters.\n    # In case of tie, return the word that comes first lexicographically.\n    max_unique_chars = 0\n    max_word = ''\n    for word in words_lower:\n        num_unique_chars = len(set(word))\n        if num_unique_chars > max_unique_chars:\n            max_unique_chars = num_unique_chars\n            max_word = word\n        elif num_unique_chars == max_unique_chars:\n            max_word = min(word, max_word)\n    return max_word"
      ],
      [
        0.8739386796951294,
        "def most_vowels(word_list):\n    \"\"\"\n    Find the word in word_list that contains the most vowels.\n    Return the word containing the most vowels.\n    If there is a tie, return the word that appears earliest in the list.\n    \"\"\"\n    \n    # YOUR CODE HERE\n    \n    # YOUR CODE HERE\n    \n    # YOUR CODE HERE\n    \n    # YOUR CODE HERE\n    \n    # YOUR CODE HERE\n    \n    # YOUR CODE HERE\n    \n    # YOUR CODE HERE\n    \n    # YOUR CODE HERE\n    \n    # YOUR CODE HERE\n    \n    # YOUR CODE HERE\n    \"\"\"\n    max_vowels = 0\n    max_word = \"\"\n\n    for word in word_list:\n        vowel_count = 0\n        vowels = \"aeiou\"\n\n        for letter in word:\n            if letter in vowels:\n                vowel_count += 1\n\n        if vowel_count > max_vowels:\n            max_vowels = vowel_count\n            max_word = word\n\n    return max_word"
      ]
    ],
    "HumanEval/154": [
      [
        0.9351611137390137,
        "def cycpattern_check(a , b):\n    \"\"\"Example usage:    \n    cycpattern_check(\"AbcD\",\"aBd\") => False\n    cycpattern_check(\"Hello\",\"ELl\") => True\n    cycpattern_check(\"Whas$sup\",\"pSUs\") => False\n    cycpattern_check(\"aB!ab\",\"BAa\") => True\n    cycpattern_check(\"EfEF\",\"EeFf\") => False\n    cycpattern_check(\"Hi^mensS\",\"sImen\") => True\n    \"\"\"\n    # Clean the strings: convert to lower case and remove special characters\n    a_clean = re.sub(r'\\W+', '', a).lower()\n    b_clean = re.sub(r'\\W+', '', b).lower()\n    \n    # Create all cyclic permutations of the second string\n    cyclic_permutations = [b_clean[i:] + b_clean[:i] for i in range(len(b_clean))]\n    \n    # Check if any of the permutations is in the first string\n    return any(permutation in a_clean for permutation in cyclic_permutations)"
      ],
      [
        0.9337671399116516,
        "def cyc_pattern_check(a , b):\n    \"\"\"\n    \"\"\"\n    n = len(b)\n    if n == 0:\n        return True\n\n    if n > len(a):\n        return False\n\n    for i in range(n):\n        if b in a:\n            return True\n        b = b[n-1:] + b[:n-1]\n    return False"
      ],
      [
        0.9314561486244202,
        "def cycpattern_check(a, b):\n    \"\"\"\n    \"\"\"\n    a = \"\".join(c.lower() for c in a if c.isalnum())\n    b = \"\".join(c.lower() for c in b if c.isalnum())\n    a_set = set(a)\n    a_temp = \"\".join(i for i in a if i in b)\n    a_list = [i for i in a if i in b]\n    b_list = list(b)\n    if a_temp != b and all(i in a_set for i in b) and a_temp == \"\".join(b_list[i] for i in range(len(b_list)) if i in [a_list.index(j) for j in b_list]):\n        return True\n    dbl_a = a + a\n    return b in dbl_a"
      ],
      [
        0.9308421611785889,
        "def cycpattern_check(a, b):\n    \"\"\"\n    Checks if a string b is a cyclic pattern of a string a.\n    :param a: The string to be checked against.\n    :param b: The string to be checked.\n    :return: True if b is a cyclic pattern of a, False otherwise.\n    \"\"\"\n    # Cleaning the strings: converting to lower case and removing unusual characters\n    a = ''.join(e for e in a if e.isalnum()).lower()\n    b = ''.join(e for e in b if e.isalnum()).lower()\n\n    # Generating all possible rotational arrangements of b\n    b_rotations = [b[i:] + b[:i] for i in range(len(b))]\n\n    # Checking if any of the rotational arrangements of b form a part of a\n    for b_rot in b_rotations:\n        if b_rot in a:\n            return True\n\n    return False"
      ]
    ],
    "HumanEval/155": [
      [
        0.9617047309875488,
        "def even_odd_count(num):\n    \"\"\"\n    Return a tuple (even_count, odd_count) indicating the counts of each type of number in a non-negative integer.\n    \n    >>> even_odd_count(123456789)\n    (4, 5)\n    >>> even_odd_count(24680)\n    (5, 0)\n    >>> even_odd_count(-11)\n    (0, 2)\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    num = abs(num)  # absolute value to ignore negative sign\n    for digit in str(num):\n        if digit != '0':\n            if int(digit) % 2 == 0: \n                even_count += 1\n            else:\n                odd_count += 1\n        else:\n            even_count += 1  # counting 0 as even\n    return even_count, odd_count"
      ],
      [
        0.9560452699661255,
        "def even_odd_count(num):\n    \"\"\"Return number of even digits and odd digits in given integer.\n    >>> even_odd_count(123456789)\n    (4, 5)\n    >>> even_odd_count(-1111111)\n    (0, 7)\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return even_count, odd_count"
      ],
      [
        0.9534012079238892,
        "def even_odd_count(num):\n    \"\"\"\n    Return a tuple containing the count of even digits and the count of odd digits in a given number.\n    \n    Args:\n        num (int): The number to analyze.\n    \n    Returns:\n        tuple: A tuple containing the count of even digits and the count of odd digits.\n    \n    Example:\n        >>> even_odd_count(123456789)\n        (4, 5)\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)): #Use absolute value to handle negative numbers correctly\n        if digit.isdigit():     #This will ensure the digit is numeric (and thus skipp \"-\" sign)\n            if int(digit) % 2 == 0: #Considering '0' as even\n                even_count += 1\n            else:\n                odd_count += 1\n    return even_count, odd_count"
      ],
      [
        0.948907732963562,
        "def even_odd_count(num):\n    \"\"\"\n    Return a tuple, (count_even, count_odd),\n    where count_even is the number of even digits in the given number\n    and count_odd is the number of odd digits in the given number.\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    even_sum = 0\n    odd_sum = 0\n    for digit in str(abs(num)):\n        if int(digit) % 2 == 0:\n            even_count += 1\n            even_sum += int(digit)\n        else:\n            odd_count += 1\n            odd_sum += int(digit)\n    return (even_count, odd_count), (even_sum, odd_sum)"
      ],
      [
        0.946431577205658,
        "def even_odd_count(num):\n    \"\"\"Return a tuple in the form (even_count, odd_count) from a list of numbers.\n    \n    >>> even_odd_count([2, 1, 4, 6, 9, 11])\n    (3, 3)\n    \"\"\"\n    num = int(num) #Convert to integer in case input is binary, any other base\n    num_str = str(num)    \n    if num_str[0] == \"-\": # handle negative numbers\n        num_str = num_str[1:]\n    elif num_str[0] == \"0\" and len(num_str)>1: # handle leading zeros\n        num_str = num_str.lstrip('0')\n     \n    even_count = 0\n    odd_count = 0\n    for digit in num_str:\n        if int(digit) % 2 == 0: \n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)"
      ],
      [
        0.9421072006225586,
        "def even_odd_count(num):\n    \"\"\"\n    Return a tuple containing the count of even digits and the count of odd digits in a given number.\n    \n    Args:\n        num (int): The input number.\n    \n    Returns:\n        tuple: A tuple containing the count of even digits and the count of odd digits.\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):  # Converting the input to a positive string number\n        if int(digit) % 2 == 0:  # Checking if the digit is even\n            even_count += 1      # If even, increment the even_count\n        else:\n            odd_count += 1       # If odd, increment the odd_count\n    return (even_count, odd_count) # Return the counts as a tuple"
      ]
    ],
    "HumanEval/156": [
      [
        0.9426429271697998,
        "def int_to_mini_roman(number):\n    \"\"\"Convert an integer to a Roman numeral.\n    >>> int_to_mini_roman(1990)\n    'MCMXC'\n    >>> int_to_mini_roman(2008)\n    'MMVIII'\n    >>> int_to_mini_roman(1666)\n    'MDCLXVI'\n    \"\"\"\n    mapping = [(1000, \"m\"), (900, \"cm\"), (500, \"d\"), (400, \"cd\"),\n               (100, \"c\"), (90, \"xc\"), (50, \"l\"), (40, \"xl\"),\n               (10, \"x\"), (9, \"ix\"), (5, \"v\"), (4, \"iv\"), (1, \"i\")]\n    result = \"\"\n    for arabic, roman in mapping:\n        while number >= arabic:\n            result += roman\n            number -= arabic\n    return result"
      ],
      [
        0.9274548888206482,
        "def int_to_mini_roman(number):\n    \"\"\"\n    Convert an integer to its corresponding roman numeral.\n    :param number: The integer to convert.\n    :return: The roman numeral representation of the integer.\n    \"\"\"\n    # Map of integers to their corresponding roman numerals\n    int_to_roman_map = [(1000, 'm'), (900, 'cm'), (500, 'd'), (400, 'cd'),\n                        (100, 'c'), (90, 'xc'), (50, 'l'), (40, 'xl'),\n                        (10, 'x'), (9, 'ix'), (5, 'v'), (4, 'iv'), (1, 'i')]\n\n    roman_numeral = ''\n    for i, numeral in int_to_roman_map:\n        while number >= i:\n            roman_numeral += numeral\n            number -= i\n    return roman_numeral"
      ],
      [
        0.9202778339385986,
        "def int_to_roman(number, include_subtractive):\n    \"\"\"\n    Convert an integer to a Roman numeral.\n    \"\"\"\n    numeral_map = [(1000, 'm'), (900, 'cm'), (500, 'd'), (400, 'cd'), (100, 'c'), \n    (90, 'xc'), (50, 'l'), (40, 'xl'), (10, 'x'), (9, 'ix'), (5, 'v'), (4, 'iv'), (1, 'i')]\n    result = ''\n    for integer, numeral in\"\"\"\n    numeral_map = [(1000, 'm'), (900, 'cm'), (500, 'd'), (400, 'cd'), (100, 'c'), \n    (90, 'xc'), (50, 'l'), (40, 'xl'), (10, 'x'), (9, 'ix'), (5, 'v'), (4, 'iv'), (1, 'i')]\n\n    collapse_map = [(5000, 'v'), (10000, 'x'), (50000, 'l'), (100000, 'c')]\n\n    result = ''\n    for integer, numeral in numeral_map:\n        count = number // integer\n        result += numeral * count\n        number -= integer * count\n    if not include_subtractive:\n        for big, small in collapse_map:\n            result = result.replace(small * (big // 1000), small[0].upper() * (big // 1000))\n    return result"
      ],
      [
        0.9192937612533569,
        "def int_to_mini_roman(num):\n    \"\"\"\n    Convert an integer to a mini roman numeral.\n    :param num: int\n    :return: str\n    \"\"\"\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    numerals = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']\n\n    mini_roman = ''\n    for i in range(len(values)):\n        count = num // values[i]\n        num %= values[i]\n\n        mini_roman += numerals[i] * count\n\n    return mini_roman"
      ],
      [
        0.9179331660270691,
        "def convert_number(number, conversion_type):\n    \"\"\"\n    Converts a positive integer or roman numeral to each other.\n    Conversion types: 'int_to_roman' or 'roman_to_int'.\n    Limitations: 1 <= num <= 1000 for integers and valid roman numerals\n\n    Examples:\n    >>> convert_number(19, 'int_to_roman') == 'xix'\n    >>> convert_number(152, 'int_to_roman') == 'clii'\n    >>> convert_number('cdxxvi', 'roman_to_int') == 426\n    \"\"\"\n    # Define all unique symbols and corresponding values for roman numerals\n    VALUES = {\n    'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,\n    'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000\n    }\n    # A reversed map of above, for int to roman conversion\n    ROMANS = {v: k for k, v in reversed(sorted(VALUES.items()))}\n\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            raise ValueError(\"Input integer must be between 1 and 1000.\")\n        \n        result = ''\n        for value, numeral in ROMANS.items():\n            count = number // value\n            result += numeral * count\n            number -= value * count\n        return result\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str) or any(i not in VALUES for i in number):\n            raise ValueError(\"Invalid Roman Numeral.\")\n        \n        result = 0\n        i = 0\n        while i < len(number):\n            # If this is a subtractive combination, process both elements\n            if i + 1 < len(number) and number[i:i+2] in VALUES:\n                result += VALUES[number[i:i+2]]\n                i += 2\n            else:\n                # Else, process one element\n                result += VALUES[number[i]]\n                i += 1\n\n        if result < 1 or result > 1000:\n            raise ValueError(\"Result is out of range!\")\n        return result\n    else:\n        raise ValueError(\"Invalid conversion type!\")"
      ],
      [
        0.9163426160812378,
        "def convert_number(number, conversion_type):\n    \"\"\"\n    Converts a positive integer or Roman numeral to each other.\n    Conversion types: 'int_to_roman' or 'roman_to_int'\n    Limitations: 1 <= num <= 1000 for integers and valid Roman numerals\n\n    Examples:\n    >>> convert_number(19, 'int_to_roman') == 'xix'\n    >>> convert_number(152, 'int_to_roman') == 'clii'\n    >>> convert_number('cdxxvi', 'roman_to_int') == 426\n    \"\"\"\n    # Define all unique symbols and corresponding values for Roman numerals\n    VALUES = {\n      'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,\n      'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000\n    }\n    # A reversed map of above, for int to Roman conversion\n    ROMANS = {v: k for k, v in reversed(sorted(VALUES.items()))}\n\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            raise ValueError(\"Input integer must be between 1 and 1000!\")\n        result = ''\n        for value, numeral in ROMANS.items():\n            count = number // value\n            result += numeral * count\n            number -= value * count\n        return result\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str) or any(i not in VALUES for i in number):\n            raise ValueError(\"Invalid Roman Numeral!\")\n        result = 0\n        i = 0\n        while i < len(number):\n            # If this is a subtractive combination, process both elements\n            if i + 1 < len(number) and number[i:i+2] in VALUES:\n                result += VALUES[number[i:i+2]]\n                i += 2\n            else:\n                # Else, process one element\n                result += VALUES[number[i]]\n                i += 1\n        if result < 1 or result > 1000:\n            raise ValueError(\"Result is out of range!\")\n        return result\n    else:\n        raise ValueError(\"Invalid conversion type!\")"
      ],
      [
        0.9162768721580505,
        "def convert_number(number, conversion_type):\n    \"\"\"\n    Converts a positive integer or roman numeral to each other.\n    Conversion types: 'int_to_roman' or 'roman_to_int'\n    Limitations: 1 <= num <= 1000 for integers and valid roman numerals\n\n    Examples:\n    >>> convert_number(19, 'int_to_roman') == 'xix'\n    >>> convert_number(152, 'int_to_roman') == 'clii'\n    >>> convert_number('cdxxvi', 'roman_to_int') == 426\n    \"\"\"\n    # Define all unique symbols and corresponding values for roman numerals\n    VALUES = {\n      'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,\n      'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000\n    }\n    # A reversed map of above, for int to roman conversion\n    ROMANS = {v: k for k, v in reversed(sorted(VALUES.items()))}\n\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            raise ValueError(\"Input integer must be between 1 and 1000!\")\n        result = ''\n        for value, numeral in ROMANS.items():\n            count = number // value\n            result += numeral * count\n            number -= value * count\n        return result\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str) or any(i not in VALUES for i in number):\n            raise ValueError(\"Invalid Roman Numeral!\")\n        result = 0\n        i = 0\n        while i < len(number):\n            # If this is a subtractive combination, process both elements\n            if i + 1 < len(number) and number[i:i+2] in VALUES:\n                result += VALUES[number[i:i+2]]\n                i += 2\n            else:\n                # Else, process one element\n                result += VALUES[number[i]]\n                i += 1\n        if result < 1 or result > 1000:\n            raise ValueError(\"Result is out of range!\")\n        return result\n    else:\n        raise ValueError(\"Invalid conversion type!\")"
      ],
      [
        0.9161058068275452,
        "def intToRoman(num):\n    \"\"\"\n    :type num: int\n    :rtype: str\n    \"\"\"\n    if not isinstance(num, int):\n        raise TypeError(\"Expected integer, received \" + str(type(num)))\n    if not 0 < num < 1000001:\n        raise ValueError(\"Input must be a non-negative integer up to 1000000.\")\n    \n    vals = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    syms = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    roman = ''\n    \n    for i in range(len(vals)):\n        count = int(num / vals[i])\n        roman += syms[i] * count\n        num -= vals[i] * count\n    return roman"
      ]
    ],
    "HumanEval/157": [
      [
        0.9490985870361328,
        "def is_right_angled_triangle(a, b, c):\n    \"\"\"\n    Return True if a, b, c form a right-angled triangle.\n    \"\"\"\n    # Sort the sides so that c is the longest side\n    sides = sorted([a, b, c])\n    a, b, c = sides[0], sides[1], sides[2]\n\n    # Use == for comparison, = is used for assignment\n    if a**2 + b**2 == c**2:\n        return True\n    else:\n        return False"
      ],
      [
        0.9382411241531372,
        "def is_right_triangle(a, b, c):\n    \"\"\"\n    Check if a triangle is right-angled given the lengths of its sides.\n    \n    Parameters:\n    a (float): Length of the first side of the triangle.\n    b (float): Length of the second side of the triangle.\n    c (float): Length of the third side of the triangle.\n    \n    Returns:\n    bool: True if the triangle is right-angled, False otherwise.\n    \"\"\"\n    # Check for negative side lengths or side lengths that are not valid for a triangle\n    if a <= 0 or b <= 0 or c <= 0 or a + b <= c or b + c <= a or c + a <= b:\n        return False\n    \n    # Use the Pythagorean theorem to check if the triangle is right-angled\n    if a**2 + b**2 == c**2 or b**2 + c**2 == a**2 or c**2 + a**2 == b**2:\n        return True\n    \n    return False"
      ],
      [
        0.9358680844306946,
        "def is_right_angled_triangle(a, b, c):\n    \"\"\"\n    Check if a triangle is a right-angled triangle.\n    \n    Args:\n        a (float): Length of side a.\n        b (float): Length of side b.\n        c (float): Length of side c.\n        \n    Returns:\n        bool: True if the triangle is a right-angled triangle, False otherwise.\n    \"\"\"\n    # Check if side lengths are valid for a triangle\n    if a <= 0 or b <= 0 or c <= 0:\n        return False\n    \n    # Check if triangle inequality holds\n    if a + b <= c or a + c <= b or b + c <= a:\n        return False\n    \n    # Sort the sides in ascending order\n    sides = sorted([a, b, c])\n    \n    # Check if the square of the longest side is equal to the sum of the squares of the other two sides\n    return sides[2]**2 == sides[0]**2 + sides[1]**2"
      ],
      [
        0.9195489287376404,
        "def is_equilateral(a, b, c):\n    \"\"\"\n    Return True if all three angles are equal, False otherwise.\n    \"\"\"\n    if a == b == c:\n        return True\n    else:\n        return False"
      ],
      [
        0.917273998260498,
        "def is_equilateral(a, b, c):\n    \"\"\"\n    Determines if a triangle is equilateral given the lengths of its sides a, b, and c.\n    \"\"\"\n    if a == b and b == c:\n        return True\n    else:\n        return False"
      ],
      [
        0.9170421361923218,
        "def isRightTriangle(a, b, c): \n    \"\"\"\n    Check if a triangle is a right triangle or not\n    \n    Parameters\n    ----------\n    a : int\n        The length of the first side\n    b : int\n        The length of the second side\n    c : int\n        The length of the third side\n        \n    Returns\n    -------\n    bool\n        True if the triangle is a right triangle, False otherwise\n    \"\"\"\n    # Square of the two smaller sides \n    square1 = a*a + b*b \n  \n    # Square of the biggest side \n    square2 = c*c \n  \n    # Condition to determine whether the  \n    # triangle is a right triangle or not \n    if (square1 == square2): \n        return True\n    return False"
      ],
      [
        0.9134564399719238,
        "def triangle_recognizer(a, b, c): \n    \"\"\"\n    \"\"\"\n    if (a + b > c) and (a + c > b) and (b + c > a): \n        return True\n    else: \n        return False"
      ]
    ],
    "HumanEval/158": [
      [
        0.9603987336158752,
        "def find_max(words, case_sensitive=False):\n    \"\"\"\n    This function accepts a list of distinct strings as input.\n    It outputs the word that contains the greatest number of unique characters.\n    In the event of a tie, the function will return the word that comes first lexicographically.\n    If case_sensitive is set to True, the function will treat different character cases as unique.\n    If the words list is empty, it raises a ValueError.\n\n    >>> find_max([\"name\", \"of\", \"String\"], True)\n    \"String\"\n    >>> find_max([\"name\", \"enam\", \"Game\"])\n    \"enam\"\n    >>> find_max([\"aaaaaaa\", \"BB\" ,\"cc\"])\n    \"aaaaaaa\"\n    >>> find_max([])\n    ValueError: 'words' list can't be empty\n    \"\"\"\n    if not words:\n        raise ValueError(\"'words' list can't be empty\")\n    max_count, max_word = 0, \"\"\n    for word in words:\n        unique_chars = set(word.lower()) if not case_sensitive else set(word)\n        if len(unique_chars) > max_count or (len(unique_chars) == max_count and word < max_word):\n            max_count = len(unique_chars)\n            max_word = word\n    return max_word"
      ],
      [
        0.9600564241409302,
        "def find_max(words, case_sensitive=False):\n    \"\"\"\n    This function accepts a list of distinct strings as an input, \n    It returns the string with the greatest number of unique characters.\n    If there is a tie, it provides the first word in lexicographical order. \n    Character cases are considered separate only if the parameter case_sensitive is set to True.\n\n    >>> find_max([\"name\", \"of\", \"string\"], True)\n    'string'\n    >>> find_max([\"name\", \"enam\", \"game\"])\n    'enam'\n    >>> find_max([\"aaaaaaa\", \"b13\" ,\"cc\"])\n    'aaaaaaa'\n    \"\"\"\n    \n    # Error handling for bad input types\n    if not isinstance(words, list) or not all(isinstance(w, str) for w in words):\n        raise ValueError('Invalid input type. Please enter a list of strings')\n\n    # If case_sensitive is False, convert all words to lowercase. \n    words_lower  = [word.lower() for word in words] if not case_sensitive else words\n    \n    # Loop through the words and find the word with the most unique characters.\n    # In case of tie, return the word that comes first lexicographically.\n    max_unique_chars = 0\n    max_word = ''\n    for word in words_lower:\n        num_unique_chars = len(set(word))\n        if num_unique_chars > max_unique_chars:\n            max_unique_chars = num_unique_chars\n            max_word = word\n        elif num_unique_chars == max_unique_chars:\n            max_word = min(word, max_word)\n    return max_word"
      ],
      [
        0.9517487287521362,
        "def find_max(words):\n    \"\"\"\n    Find the word with the maximum number of unique characters.\n    If there are multiple such words, return the lexicographically smallest one.\n    \n    Args:\n        words: list of strings\n    Returns:\n        str: the word with the maximum number of unique characters\n    \"\"\"\n    max_unique_count = 0\n    max_unique_word = \"\"\n    for word in words:\n        unique_chars = len(set(word.lower()))\n        if unique_chars > max_unique_count:\n            max_unique_count = unique_chars\n            max_unique_word = word\n        elif unique_chars == max_unique_count:\n            # if the unique character counts are the same, pick the lexicographically smallest one\n            max_unique_word = min(max_unique_word, word)\n    return max_unique_word"
      ],
      [
        0.951508641242981,
        "def find_max(words):\n    \"\"\" Finds the word from a list with the maximum number of unique letters\n    \n    Args:\n        words (List[str]): list of words\n\n    Returns:\n        str : the word with maximum unique letters. \n        If there are multiple such words, the one appearing first alphabetically\n\n    \"\"\"\n\n    max_word = ''\n    max_unique_chars = 0\n    \n    for word in words:\n        unique_chars = set(word.lower())\n        num_unique_chars = len(unique_chars)\n\n        if num_unique_chars == max_unique_chars:\n            if word.lower() < max_word.lower():\n                max_word = word\n        elif num_unique_chars > max_unique_chars:\n            max_word = word\n            max_unique_chars = num_unique_chars\n\n    return max_word"
      ],
      [
        0.9501178860664368,
        "def find_max(words):\n    \"\"\"\n    Find the word with the maximum number of unique characters.\n    If there are multiple words with the same maximum number of unique characters,\n    return the word that comes first in the list.\n    \n    Args:\n        words (list): A list of words.\n    \n    Returns:\n        str: The word with the maximum number of unique characters.\n    \"\"\"\n    max_unique_count = 0\n    max_word = None\n\n    for word in words:\n        unique_count = len(set(word.lower()))\n        \n        if unique_count > max_unique_count:\n            max_unique_count = unique_count\n            max_word = word\n        elif unique_count == max_unique_count:\n            max_word = min(word, max_word)\n\n    return max_word"
      ],
      [
        0.9474490284919739,
        "def find_max(words, case_sensitive=False):\n    \"\"\"This function accepts a list of unique strings as its primary input.\n    Its output is the word with the greatest count of distinguished characters.\n    In the event of a tie, yield the word that appears first lexicographically.\n    If case_sensitive is specified as True, cases of characters are deemed distinct.\n    \"\"\"\n    if not case_sensitive:\n        # convert all words to lower case\n        words = [word.lower() for word in words]\n    \n    # create a list of tuples, with each tuple containing a word and its corresponding\n    # count of unique characters\n    words_and_counts = [(word, len(set(word))) for word in words]\n    \n    # sort the list of tuples lexicographically and by descending order of counts\n    words_and_counts.sort(key = lambda x: (-x[1], x[0]))\n    \n    # return the word with the maximum count of unique characters, or the\n    # lexicographically first word in case of a tie\n    return words_and_counts[0][0]"
      ],
      [
        0.9438435435295105,
        "def find_max(words, adjacent_chars=False, case_sensitive=False):\n    \"\"\"\n    Find the word in the list with the highest count of unique characters.\n    If there is a tie, return the lexicographically earliest word.\n    :param words: a list of words\n    :param adjacent_chars: if True, consider adjacent characters as unique\n    :param case_sensitive: if False, ignore case\n    :return: the word with the highest count of unique characters\n    \"\"\"\n    # Keep track of the max count of unique characters\n    max_count = 0\n    # Keep track of the word with highest count of unique characters,\n    # lexicographically earliest in case of a tie.\n    max_word = ''\n\n    # Process each word in the list\n    for word in words:\n        if not case_sensitive:\n            word = word.lower()\n        if adjacent_chars:\n            chars = adjacents(word)\n        else:\n            chars = set(word)\n        if len(chars) > max_count:\n            max_count = len(chars)\n            max_word = word\n        elif len(chars) == max_count:\n            max_word = min(max_word, word)\n\n    return max_word"
      ]
    ],
    "HumanEval/159": [
      [
        0.8627757430076599,
        "def vegetable_distribution(s, n, vegetables, servings):\n    \"\"\"\n    \"\"\"\n    left_over = n\n    distribution = {}\n    for veg in vegetables:\n        name, amount = veg.split(\" \")\n        amount = int(amount)\n        left_over -= amount \n    if left_over < 0: \n        return \"Error: More vegetables present than total number in the crate.\"\n    for leftover in servings:\n        serving = servings[leftover]\n        if type(serving) == str: \n            serving = int(serving.strip('%'))/100\n        distribution[leftover] = serving * left_over\n    return distribution"
      ],
      [
        0.8594448566436768,
        "def operate(lst):\n    \"\"\"\n    \"\"\"\n    if len(lst) == 0:\n        raise Exception(\"List is empty\")\n    if not all(isinstance(x, int) for x in lst):\n        raise Exception(\"List contains non-integer element\")\n\n    if len(lst) == 1:\n        return lst\n    elif len(lst) == 2:\n        return [lst[0] + lst[1]]\n    else:\n        return [lst[0] + lst[1]] + lst[2:]"
      ],
      [
        0.8593405485153198,
        "def divide(dividend, divisor):\n    \"\"\"\n    :type dividend: int\n    :type divisor: int\n    :rtype: int\n    \"\"\"\n    quotient = dividend // divisor\n    remainder = dividend % divisor\n    return quotient, remainder"
      ],
      [
        0.859325647354126,
        "def divide(dividend, divisor):\n    \"\"\"\n    :type dividend: int\n    :type divisor: int\n    :rtype: int\n    \"\"\"\n    quotient = dividend // divisor\n    remainder = dividend % divisor\n    return quotient, remainder"
      ],
      [
        0.8585603833198547,
        "def division_remainder(list1, list2, list3):\n    \"\"\"\n    Given three lists of numbers, list1, list2 and list3, return a new list containing the remainder of dividing the sum of list1 by the sum of list2, followed by the sum of list2 divided by the sum of list3.\n    \"\"\"\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \"\"\"\n    sum1 = sum(list1)\n    sum2 = sum(list2)\n    sum3 = sum(list3)\n    return [sum1%sum3, sum2%sum3]"
      ],
      [
        0.8585577607154846,
        "def bakery_pastry_count(N, A):\n  \"\"\"\n  Given an integer N and an integer A, return the number of bagels, croissants, and breadsticks that the bakery has.\n  \n  The bakery has N bagels, A croissants, and the rest of the breadsticks.\n  \n  The bakery has to sell all of the breadsticks.\n  \n  The bakery has to sell at least 1 bagel and 1 croissant.\n  \n  The bakery has to sell at least 1 bagel and 1 croissant.\n  \n  The bakery has to sell at least 1 bagel and 1 croissant.\n  \n  The bakery has to\"\"\"\n  bagels = (N - A) / 3\n  croissants = A + 2 * bagels\n  breadsticks = N - croissants - bagels\n  return bagels, croissants, breadsticks"
      ],
      [
        0.8584119081497192,
        "def find_missing_and_extraneous(arr1, arr2):\n    \"\"\"\n    Find missing and extraneous numbers\n    \"\"\"\n    # Your code here\n    # Hint: There are multiple ways to solve this problem.\n    # One way involves finding the sum of the two arrays,\n    # and then finding the difference between the two sums.\n    \"\"\"\n    sum1, sum2 = sum(arr1), sum(arr2)\n    diff = sum2 - sum1\n    missing = (100*101)//2 - sum1\n    extraneous = diff + missing\n    return missing, extraneous"
      ]
    ],
    "HumanEval/160": [
      [
        0.9371944665908813,
        "def perform_algebra(operators, operands):\n    \"\"\"\n    Perform algebraic_operations in the order they are present in the operators and operands list.\n    Possible operators include addition, subtraction, multiplication, division, modulus, and power.\n    The operators and operands lists could be empty or could contain multiple items.\n    Also, an extra modulus function has been added amongst the operators.\n    Operands can be negative and positive integers.\n    Negative_unary operators will be preceded by a zero in the operands list,\n    This function does not handle standard order of operations [PEMDAS/BODMAS] it only computes sequentially.\n    \"\"\"\n    if not operators or not operands:\n        return None\n\n    result = operands[0]\n    for i in range(0, len(operators)):\n        op = operators[i]\n        num = operands[i+1]\n        if op == \"+\":\n            result += num\n        elif op == \"-\":\n            result -= num\n        elif op == \"*\":\n            result *= num\n        elif op == \"/\":\n            result /= num\n        elif op == \"//\":\n            result //= num\n        elif op == \"**\":\n            result **= num\n        elif op == \"%\":\n            result %= num\n        else:\n            return \"Invalid operator found: {0}\".format(op)\n\n    return result"
      ],
      [
        0.9360747337341309,
        "def perform_algebra(operators, operands):\n    \"\"\"\n    Perform algebraic operations in the order they are present in the operators and operands list.\n    Possible operators include addition, subtraction, multiplication, division, modulus, and power.\n    The operators and operands lists could be empty or could contain multiple items.\n    Also, an extra modulus function has been added amongst the operators.\n    Operands can be negative and positive integers.\n    Negative unary operators will be preceded by a zero in the operands list.\n    This function does not handle standard order of operations (PEMDAS/BODMAS), it only computes sequentially.\n    \"\"\"\n    if not operators or not operands:\n        return None\n\n    result = operands[0]\n    for i in range(0, len(operators)):\n        op = operators[i]\n        num = operands[i+1]\n        if op == \"+\":\n            result += num\n        elif op == \"-\":\n            result -= num\n        elif op == \"*\":\n            result *= num\n        elif op == \"/\":\n            result /= num\n        elif op == \"//\":\n            result //= num\n        elif op == \"**\":\n            result **= num\n        elif op == \"%\":\n            result %= num\n        else:\n            return \"Invalid operator found: {0}\".format(op)\n\n    return result"
      ],
      [
        0.9360492825508118,
        "def perform_algebra(operators, operands):\n    \"\"\"\n    Perform algebraic operations in the order they are present in the operators and operands list.\n    Possible operators include addition, subtraction, multiplication, division, modulus, and power.\n    The operators and operands lists could be empty or could contain multiple items.\n    Also, an extra modulus function has been added amongst the operators.\n    Operands can be negative and positive integers.\n    Negative unary operators will be preceded by a zero in the operands list.\n    This function does not handle standard order of operations (PEMDAS/BODMAS), it only computes sequentially.\n    \"\"\"\n    if not operators or not operands:\n        return None\n\n    result = operands[0]\n    for i in range(0, len(operators)):\n        op = operators[i]\n        num = operands[i+1]\n        if op == \"+\":\n            result += num\n        elif op == \"-\":\n            result -= num\n        elif op == \"*\":\n            result *= num\n        elif op == \"/\":\n            result /= num\n        elif op == \"//\":\n            result //= num\n        elif op == \"**\":\n            result **= num\n        elif op == \"%\":\n            result %= num\n        else:\n            return \"Invalid operator found: {0}\".format(op)\n\n    return result"
      ],
      [
        0.9285446405410767,
        "def do_algebra(operator, operand, round_off):\n    \"\"\"\n    This function takes in an arithmetic operator, a list of operands, and a boolean value for rounding off.\n    It returns the result of the arithmetic operation performed on the operands using the given operator.\n    \n    Parameters:\n    - operator (str): A string containing the arithmetic operator.\n    - operand (list): A list of numbers representing the operands.\n    - round_off (bool): A boolean value indicating whether to round off the result or not.\n    \n    Returns:\n    - result (float): The result of the arithmetic operation performed on the operands using the given operator.\n\"\"\"\n    # mapping the arithmetic operators to their respective functions\n    operators = {'+': op.add, '-': op.sub, '*': op.mul, '//': op.floordiv, '**': op.pow}\n\n    # error handling\n    if len(operand)-len(operator)!=1:\n        raise ValueError('The number of operators must be exactly one less than the number of operands.')\n\n    # initializing the result to the first operand\n    result = operand[0]\n\n    # going through each operator\n    for idx in range(len(operator)):\n         # updating the result based on the current operator and the next operand\n        result = operators[operator[idx]](result, operand[idx+1])\n    \n    # rounding off the result if needed\n    if round_off:\n        result = round(result)\n        \n    return result"
      ],
      [
        0.9278613924980164,
        "def do_calculations(operator, operand):\n    \"\"\"\n    \"\"\"\n    result = operand[0]\n\n    for i in range(len(operator)):\n        if operator[i] == '+':\n            result += operand[i + 1]\n        elif operator[i] == '-':\n            result -= operand[i + 1]\n        elif operator[i] == '*':\n            result *= operand[i + 1]\n        elif operator[i] == '//':\n            result //= operand[i + 1]\n        elif operator[i] == '**':\n            result **= operand[i + 1]\n        elif operator[i] == 'sin':\n            result -= math.sin(math.radians(operand[i + 1]))\n        elif operator[i] == 'cos':\n            result -= math.cos(math.radians(operand[i + 1]))\n        elif operator[i] == 'tan':\n            result -= math.tan(math.radians(operand[i + 1]))\n            \n    return result"
      ],
      [
        0.92371666431427,
        "def do_algebra(operators, operands):\n    \"\"\"\n    This function takes in a list of operators and a list of operands and returns the result of the expression.\n    \n    Args:\n        operators (list): A list of operators.\n        operands (list): A list of operands.\n    \n    Returns:\n        float: The result of the expression.\n    \"\"\"\n    expression = str(operands[0])\n    for i in range(len(operators)):\n        expression += \" \" + operators[i] + \" \" + str(operands[i + 1])\n    result = eval(expression)\n    return result"
      ],
      [
        0.9236994981765747,
        "def perform_algebra(operators, operands):\n    \"\"\"\n    Perform algebraic operations on a list of operators and operands.\n    \n    Args:\n        operators: A list of algebraic operators.\n        operands: A list of operands.\n    \n    Returns:\n        The result of the algebraic operations.\n    \"\"\"\n    import operator\n    op = {\"+\": operator.add, \"-\": operator.sub, \"*\": operator.mul, \"//\": operator.floordiv, \"**\": operator.pow, \"%\": operator.mod}\n    operands = add_unary_minus_operator(operators, operands)\n    result = operands[0]\n    for i in range(1, len(operands)):\n        result = op[operators[i-1]](result, operands[i])\n    return result"
      ],
      [
        0.9232066869735718,
        "def do_algebra_advanced(operators, operands, priority_operations):\n    \"\"\"\n    \"\"\"\n    try:\n        # Pair operators and priorities\n        op_pri_pairs = list(zip(operators, priority_operations))\n        # Sort by second item in tuple (priority)\n        sorted_op_pri_pairs = sorted(op_pri_pairs, key=lambda x: x[1])\n\n        # Pair operands and priorities missing the last item\n        opd_pri_pairs = list(zip(operands[:-1], priority_operations))\n        # Sort by second item in tuple (priority)\n        sorted_opd_pri_pairs = sorted(opd_pri_pairs, key=lambda x: x[1])\n\n        # Construct string to be evaluated\n        equation = \"({})\".format(sorted_op_pri_pairs[0][0])  # first operand\n        for i in range(1, len(operands)):\n            equation = \"({} {} {})\".format(equation, sorted_op_pri_pairs[i-1][0], sorted_opd_pri_pairs[i-1][0])\n        # Append the last operand\n        equation = equation + \" {}\".format(operands[-1])\n\n        # Evaluate the equation\n        return eval(equation)\n    except Exception as e:\n        print(\"An error occurred: \", e)"
      ]
    ],
    "HumanEval/161": [
      [
        0.9489492177963257,
        "def solve(s):\n    \"\"\"\n    \"\"\"\n    if not any(char.isalpha() for char in s):\n        return s[::-1]\n    else:\n        result = \"\"\n        for char in s:\n            if char.isalpha():\n                if char.islower():\n                    result += char.upper()\n                else:\n                    result += char.lower()\n            else:\n                result += char\n        return result"
      ],
      [
        0.925314724445343,
        "def reverse_string(s):\n    \"\"\"\n    :type s: str\n    :rtype: str\n    \"\"\"\n    s = ''.join([i for i in s if i.isalpha()])\n    return s[::-1]"
      ],
      [
        0.9234504699707031,
        "def reverse_string(s):\n    \"\"\"\n    :type s: str\n    :rtype: str\n    \"\"\"\n    s = list(s)\n    letters = [i for i in s if i.isalpha()]\n    letters.reverse()\n    \n    for i in range(len(s)):\n        if s[i].isalpha():\n            s[i] = letters.pop(0)\n    return ''.join(s)"
      ],
      [
        0.9234445095062256,
        "def reverse_string(s):\n    \"\"\"\n    :type s: str\n    :rtype: str\n    \"\"\"\n    s = list(s)\n    letters = [i for i in s if i.isalpha()]\n    letters.reverse()\n    \n    for i in range(len(s)):\n        if s[i].isalpha():\n            s[i] = letters.pop(0)\n    return ''.join(s)"
      ]
    ],
    "HumanEval/162": [
      [
        0.9375133514404297,
        "def string_to_md5(text):\n    \"\"\"\n    Converts a string to its md5 hash.\n\n    Args:\n        text (str): The string to be converted to md5 hash.\n\n    Returns:\n        str: The md5 hash of the input string.\n\n    \"\"\"\n    # If 'text' is an empty string, return None\n    if text == '':\n        return None\n\n    # Create an md5 hash object\n    hash_object = hashlib.md5()\n\n    # Update the hash object with 'text', encoded into utf-8 bytes\n    hash_object.update(text.encode('utf-8'))\n\n    # Return the hexadecimal representation of the md5 hash\n    return hash_object.hexdigest()"
      ],
      [
        0.8899655342102051,
        "def md5_hash(input_string):\n    \"\"\"\n    Generate an MD5 hash of the given input string.\n    \n    Args:\n        input_string (str): The input string to hash.\n    \n    Returns:\n        str: The MD5 hash of the input string.\n    \"\"\"\n    return hashlib.md5(input_string.encode()).hexdigest()"
      ]
    ],
    "HumanEval/163": [
      [
        0.9303196668624878,
        "def even_number_list(a, b):\n    \"\"\"\n    Return a list of even numbers between a and b\n    \"\"\"\n    \"\"\"\n    return list(i for i in range(a, b+1) if i%2 == 0)"
      ],
      [
        0.917346715927124,
        "def generate_numbers():\n    \"\"\"\n    Generate a list of 10 even numbers starting from 26.\n    \"\"\"\n    numbers = []\n    current_number = 26\n\n    while len(numbers) < 10:\n        digits = [int(digit) for digit in str(current_number)]\n        if all(digit % 2 == 0 for digit in digits):\n            numbers.append(current_number)\n        current_number += 2\n\n    return numbers"
      ],
      [
        0.9141643643379211,
        "def generate_even_numbers(n):\n    \"\"\"\n    Generate even numbers from 0 to n.\n    \"\"\"\n    for i in range(n + 1):\n        if i % 2 == 0:\n            yield i\n    \n    def generate_even_numbers(n):\n    \"\"\"\n    Generate even numbers from 0 to n.\n    \"\"\"\n    num = 0\n    for _ in range(n):\n        yield num\n        num += 2"
      ],
      [
        0.9122541546821594,
        "def get_even_numbers(arr):\n    \"\"\"\n    Return a new array of all even numbers from the given array, in ascending order.\n    \n    >>> get_even_numbers([7, 8, 10, 1, 2, 2])\n    [2, 2, 8]\n    \"\"\"\n    even_numbers = []\n    for num in arr:\n        if num % 2 == 0:\n            even_numbers.append(num)\n    even_numbers.sort()\n    return even_numbers"
      ],
      [
        0.9097756743431091,
        "def first_n_even(n):\n    \"\"\"\n    Return the first n even numbers.\n    >>> first_n_even(5)\n    [2, 4, 6, 8, 10]\n    \"\"\"\n    result = []\n    for i in range(2, 2*n+1, 2):\n        result.append(i)\n    return result"
      ],
      [
        0.9082360863685608,
        "def generate_even_numbers(start, end):\n    \"\"\"\n    Generate a list of even numbers within a given range.\n\n    Args:\n        start (int): The starting number of the range.\n        end (int): The ending number of the range.\n\n    Returns:\n        list: A list of even numbers within the given range.\n    \"\"\"\n    even_numbers = []\n    for number in range(start, end + 1):\n        if number % 2 == 0:\n            even_numbers.append(number)\n    return even_numbers"
      ],
      [
        0.9079514145851135,
        "def filter(numbers):\n    \"\"\"\n    Filter the given list of numbers, keeping only the even numbers.\n    \n    >>> filter([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    [2, 4, 6, 8, 10]\n    \"\"\"\n    return [n for n in numbers if n > 10 and n % 2 == 0]"
      ]
    ],
    "MBPP/0": [
      [
        0.898766040802002,
        "def modify_string(s: str) -> str:\n    \"\"\"\n    Given a string s, remove the first and last character of the string.\n    \n    Args:\n        s (str): The string to be modified.\n    \n    Returns:\n        str: The modified string.\n    \"\"\"\n    # If string s is empty, return.\n    if not s:\n        return s\n    # If the length of string s is 1, we assume the index is 0, so return an empty string.\n    elif len(s) == 1:\n        return ''\n    # Recursive case: return the character at index 1 (which is an odd index in 0-based indexing) concatenated with the result of the function called on the rest of the string (starting from index 2).\n    else:\n        return s[1] + modify_string(s[2:])"
      ],
      [
        0.8935100436210632,
        "def remove_from_front(string, num_chars):\n    \"\"\"\n    Remove the first num_chars from string.\n    \"\"\"\n    return string[num_chars:]\n    \n    def remove_from_end(string, num_chars):\n    \"\"\"\n    Remove the last num_chars from string.\n    \"\"\"\n    return string[num_chars:]"
      ]
    ],
    "MBPP/1": [
      [
        0.9161108136177063,
        "def sort_rows(arr):\n    \"\"\"\n    Sort rows in ascending order based on the sum of their elements.\n\n    Args:\n        arr (list): A 2D list of integers.\n\n    Returns:\n        list: A 2D list of integers sorted in ascending order based on the sum of their elements.\n    \"\"\"\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in arr]\n\n    # Create a list of tuples containing the row sums and their corresponding rows\n    rows_with_sums = [(row_sum, row) for row_sum, row in zip(row_sums, arr) if not any(num < 0 for num in row)]\n\n    # Sort the rows in ascending order based on the row sums\n    sorted_rows = sorted(rows_with_sums, key=lambda x: x[0])\n\n    # Extract the sorted rows\n    sorted_arr = [row for _, row in sorted_rows]\n\n    return sorted_arr"
      ],
      [
        0.9138094186782837,
        "def sort_rows(arr):\n    \"\"\"\n    Sort the rows of a 2D array in descending order based on their sums.\n\n    Args:\n        arr (list): A 2D array of integers.\n\n    Returns:\n        list: A new 2D array with the rows sorted in descending order based on their sums.\n    \"\"\"\n    # Sort the rows in descending order based on their sums\n    sums = get_row_sums(arr)\n    sorted_arr = [x for _, x in sorted(zip(sums, arr), reverse=True)]\n    return sorted_arr"
      ],
      [
        0.9122312068939209,
        "def sort_2d_array(arr):\n    \"\"\"\n    Sort a 2D array in ascending order based on the sum of each row.\n    \n    Args:\n    - arr: A 2D array of integers.\n    \n    Returns:\n    - A sorted 2D array in ascending order based on the sum of each row.\n    \"\"\"\n    arr.sort(key=lambda x: sum(x))\n    return arr"
      ],
      [
        0.9116837978363037,
        "def sortArrayBySum(array):\n    \"\"\"\n    :type array: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    array.sort(key=lambda x: sum(x))\n    return array"
      ]
    ],
    "MBPP/2": [],
    "MBPP/3": [
      [
        0.9004223942756653,
        "def tri_area(base, height):\n    \"\"\"\n    Return the area of a triangle with the given base and height.\n    \"\"\"\n    return 0.5*base*height\n    \n    def tri_area(base, height):\n    \"\"\"\n    Return the area of a triangle with the given base and height.\n    \"\"\"\n    return 0.5*base*height"
      ],
      [
        0.9004121422767639,
        "def tri_area(base, height):\n    \"\"\"\n    Return the area of a triangle with the given base and height.\n    \"\"\"\n    return 0.5*base*height\n    \n    def tri_area(base, height):\n    \"\"\"\n    Return the area of a triangle with the given base and height.\n    \"\"\"\n    return 0.5*base*height"
      ]
    ],
    "MBPP/4": [
      [
        0.9032272696495056,
        "def split_string(s):\n    \"\"\"\n    Split a string by uppercase letters.\n    >>> split_string('Hello')\n    ['Hello']\n    >>> split_string('Hello, World!')\n    ['Hello', 'World']\n    >>> split_string('Hi')\n    ['Hi']\n    \"\"\"\n    return re.findall('[A-Z][^A-Z]*', s)"
      ],
      [
        0.8924493193626404,
        "def string_split(str):\n    \"\"\"\n    Write a function that takes a string and returns an array of words.\n    \"\"\"\n    return str.split(\" \")"
      ]
    ],
    "MBPP/5": [],
    "MBPP/6": [
      [
        0.9000412225723267,
        "def square_properties(n):\n    \"\"\"\n    Return the area and perimeter of a square of size n.\n    \n    >>> square_properties(5)\n    (25, 20)\n    \"\"\"\n    area = n * n\n    perimeter = 4 * n\n    return (area, perimeter)"
      ],
      [
        0.8990646004676819,
        "def Perimeter_of_square(side):\n    \"\"\"\n    Return the perimeter of a square.\n    \n    :param side: side of the square\n    :type side: float\n    :return: perimeter of the square\n    :rtype: float\n    \"\"\"\n    return 4 * side"
      ]
    ],
    "MBPP/7": [
      [
        0.9256370663642883,
        "def remove_characters(s, t):\n    \"\"\"\n    Remove characters from string s that are present in string t.\n    :param s: (str) first string\n    :param t: (str) second string\n    :return: (str) string after removing characters\n    \"\"\"\n    t_set = set(t)  # Convert t to a set for constant time look-ups\n    result = [char for char in s if char not in t_set]  # List comprehension\n    return ''.join(result)  # Convert list back to string"
      ],
      [
        0.9173795580863953,
        "def delete_chars(A, B):\n    \"\"\"\n    Given two strings A and B, remove characters from A that occur in B.\n    \n    Example 1:\n    \n    Input:\n    A = \"geeksforgeeks\"\n    B = \"geeks\"\n    \n    Output:\n    \"frks\"\n    \n    Explanation:\n    'g', 'e', and 'k' occur in both the strings hence they are removed.\n    \n    Example 2:\n    \n    Input:\n    A = \"xy\"\n    B = \"xypq\"\n    \n    Output:\n    \"\"\"\n    C = ''\n    prev_char = None\n\n    for char in A:\n        if char not in B and char != prev_char:\n            C += char\n        prev_char = char\n\n    return C"
      ],
      [
        0.91619873046875,
        "def remove_chars(string, chars):\n    \"\"\"\n    It should remove characters that are in the second string from the first string.\n    \"\"\"\n    \n    def remove_chars(string, chars):\n    \"\"\"\n    It should remove characters that are in the second string from the first string.\n    \"\"\"\n    if not string:\n        return \"\"\n    chars = set(chars.lower())\n    return \"\".join(char for char in string if char.lower() not in chars)"
      ],
      [
        0.9161351323127747,
        "def remove_chars(s, chars):\n    \"\"\"\n    Given a string and a set of characters, return a string with all the characters from the set removed.\n    \n    >>> remove_chars(\"hello world\", \"l\")\n    'heo word'\n    \"\"\"\n    res = \"\"\n    \n    for c in s:\n        if c not in chars:\n            res+=c\n    return res"
      ],
      [
        0.9150521755218506,
        "def delete_common_characters(str1, str2):\n    \"\"\"\n    Given two strings, remove the characters that are common in both strings\n    \"\"\"\n    str1_list = list(str1)\n    str2_list = list(str2)\n    for char in str1_list:\n        if char in str2_list:\n            str1_list.remove(char)\n\n    output_str = ''.join(str1_list)\n    return output_str\n    def delete_common_characters(str1, str2):\n    \"\"\"\n    Given two strings, remove the characters that are common in both strings\n    \"\"\"\n    str1_list = list(str1)\n    str2_list = list(str2)\n    for char in str1_list:\n        if char in str2_list:\n            str1_list.remove(char)\n\n    output_str = ''.join(str1_list)\n    return output_str"
      ],
      [
        0.9141068458557129,
        "def remove_chars(string, chars):\n    \"\"\"\n    It should remove all occurrence of given characters from a string.\n    \"\"\"\n    # your code goes here\n    for char in chars:\n        string = string.replace(char, \"\")\n    return string\n    \n    def remove_chars(string, chars):\n    \"\"\"\n    It should remove all occurrence of given characters from a string.\n    \"\"\"\n    for char in chars:\n        string = string.replace(char, \"\")\n    return string"
      ]
    ],
    "MBPP/8": [
      [
        0.935748279094696,
        "def hasDups(arr): \n    \"\"\"\n    Given an array of integers, write a function that returns true if the array contains any duplicates.\n    \"\"\"\n    mySet = set()\n    for item in arr:\n        if item in mySet:\n            return True\n        else:\n            mySet.add(item)\n    return False\n    \n    def hasDups(arr): \n    \"\"\"\n    Given an array of integers, write a function that returns true if the array contains any duplicates.\n    \"\"\"\n    mySet = set()\n    for item in arr:\n        if item in mySet:\n            return True\n        else:\n            mySet.add(item)\n    return False"
      ],
      [
        0.9296699166297913,
        "def has_duplicate(arr):\n    \"\"\"\n    Given an array of integers, find if the array contains any duplicates.\n    Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\n    \n    Args:\n       arr(list): input array\n    Returns:\n       bool: True if the array contains any duplicates, else False\n    \"\"\"\n    seen = set()\n    for i in arr:\n        if i in seen:\n            return True\n        else:\n            seen.add(i)\n    return False"
      ],
      [
        0.9293336868286133,
        "def arrayDuplicate(arr): \n    \"\"\"\n    Given an array of integers, find if the array contains any duplicates. \n    Your function should return true if any value appears at least twice in the array, \n    and it should return false if every element is distinct. \n    \n    Example 1: \n    Input: [1,2,3,1] \n    Output: true \n    \n    Example 2: \n    Input: [1,2,3,4] \n    Output: false \n    \n    Example 3: \n    Input: [1,1,1,\"\"\"\n    # Loop through the array \n    for i in range(len(arr)): \n        for j in range(i+1, len(arr)): \n            # If there is a duplicate, return true \n            if arr[i] == arr[j]: \n                return True \n    return False"
      ],
      [
        0.927590548992157,
        "def contains_duplicates(arr):\n    \"\"\"\n    Given an array of integers, find if the array contains any duplicates.\n    Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\n    \n    Example 1:\n    Input: [1,2,3,1]\n    Output: true\n    \n    Example 2:\n    Input: [1,2,3,4]\n    Output: false\n    \n    Example 3:\n    Input: [1,1,1,3,3,4,3,2,4,\"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False"
      ],
      [
        0.9267053008079529,
        "def check_repeats(nums):\n    \"\"\"\n    Given an array of integers, find if the array contains any duplicates.\n    Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\n    :type nums: List[int]\n    :rtype: bool\n    \"\"\"\n    num_set = set()\n\n    for i in range(len(nums)):\n        if nums[i] in num_set:\n            return True\n        num_set.add(nums[i])\n    return False"
      ],
      [
        0.9262169599533081,
        "def contains_duplicates(lst):\n    \"\"\"\n    Given an array of integers, find if the array contains any duplicates.\n    Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\n    \n    Example 1:\n    Input: [1,2,3,1]\n    Output: true\n    \n    Example 2:\n    Input: [1,2,3,4]\n    Output: false\n    \n    Example 3:\n    Input: [1,1,1,3,3,4,3,2,4,\"\"\"\n    seen = {}  # We'll use a dictionary to keep track of seen elements\n\n    for item in lst:\n        if item in seen:\n            return True  # If we find a duplicate, we return True\n        seen[item] = True  # Otherwise, mark the element as seen\n\n    return False  # If no duplicates found, return False"
      ],
      [
        0.924727201461792,
        "def contains_duplicates(arr):\n    \"\"\"\n    Given an array of integers, find if the array contains any duplicates.\n    Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\n    \n    Args:\n       arr(list): input array\n    Returns:\n       bool: True if any are duplicated in the array, False otherwise\n    \"\"\"\n    seen = set()\n    for el in arr:\n        if el in seen:\n            return True\n        else:\n            seen.add(el)\n    return False"
      ]
    ],
    "MBPP/9": [],
    "MBPP/10": [
      [
        0.9182089567184448,
        "def f(n, multiple):\n    \"\"\"\n    Return a list of multiples of multiple up to and including n.\n    \"\"\"\n    i = 0\n    multiples_list = []\n    while i < n:\n        i += multiple\n        if i <= n:\n            multiples_list.append(i)\n    return multiples_list\n    def f(n, multiple):\n    \"\"\"\n    Return a list of multiples of multiple up to and including n.\n    \"\"\"\n    i = 0\n    multiples_list = []\n    while i < n:\n        i += multiple\n        if i <= n:\n            multiples_list.append(i)\n    return multiples_list"
      ]
    ],
    "MBPP/11": [
      [
        0.9360371828079224,
        "def find_duplicate(arr):\n    \"\"\"\n    Find a duplicate in a given array of integers.\n    \"\"\"\n    elements_seen = set()\n\n    for element in arr:\n        if element in elements_seen:\n            return element\n        else:\n            elements_seen.add(element)\n    return None\n    \n    def find_duplicate(arr):\n    \"\"\"\n    Find a duplicate in a given array of integers.\n    \"\"\"\n    elements_seen = set()\n\n    for element in arr:\n        if element in elements_seen:\n            return element\n        else:\n            elements_seen.\"\"\"\n    elements_seen = set()\n\n    for element in arr:\n        if element in elements_seen:\n            print(\"Found duplicate\")\n        else:\n            elements_seen.add(element)"
      ],
      [
        0.9269710779190063,
        "def find_duplicate(nums):\n    \"\"\"\n    Given a list of integers, finds the first duplicate number within the list.\n\n    Args:\n    - nums: a list of integers\n\n    Returns:\n    - the first duplicate number found within the list\n    - -1 if no duplicates are found\n\n    Time Complexity:\n    - O(nlogn), where n is the number of integers in the list\n\n    Space Complexity:\n    - O(1)\n    \"\"\"\n    nums.sort()\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i-1]:\n            return nums[i]\n    return -1"
      ],
      [
        0.9262967109680176,
        "def find_duplicate(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # Sort the array to bring duplicate elements together\n    nums.sort()\n\n    # Iterate through the array to find duplicates\n    for i in range(len(nums)-1):\n        # If adjacent elements are equal, return the duplicate element\n        if nums[i] == nums[i+1]:\n            return nums[i]\n\n    # If no duplicates found, return -1\n    return -1"
      ],
      [
        0.9258524179458618,
        "def find_duplicate(A: List[int]) -> int:\n    \"\"\"\n    Find a duplicate in a list of integers in O(n) time and O(1) space.\n    :param A: List of integers\n    :return: Duplicate integer\n    \"\"\"\n    seen = set()\n    for i in A:\n        if i in seen:\n            return i\n        seen.add(i)\n    return -1"
      ],
      [
        0.9250427484512329,
        "def find_duplicate(nums: List[int]) -> int:\n    \"\"\"\n    Find the duplicate number in the given array.\n    :param nums: List of integers\n    :return: The duplicate number\n    \"\"\"\n    num_count = {}\n    for num in nums:\n        if num in num_count:\n            num_count[num] += 1\n        else:\n            num_count[num] = 1\n        if num_count[num] > 1:\n            return num\n    return -1  # If no duplicate is found"
      ]
    ],
    "MBPP/12": [
      [
        0.926188588142395,
        "def max_sum_list(list_of_lists):\n    \"\"\"\n    Find the list in list_of_lists with the largest sum of elements.\n    >>> max_sum_list([[1, 2, 3], [3, 2, 1], [2, 3, 1]])\n    [3, 2, 1]\n    \"\"\"\n    max_sum = None\n    max_list = None\n    for lst in list_of_lists:\n        if max_sum is None or sum(lst) > max_sum:\n            max_sum = sum(lst)\n            max_list = lst\n    return max_list"
      ],
      [
        0.9065106511116028,
        "def max_sum(arr):\n    \"\"\"\n    Write a function that takes in a 2-dimensional array of integers and returns the maximum sum of any of its subarrays.\n    A subarray can be any contiguous subsection of the array.\n    \n    Sample Input\n    arr = [\n      [5, 3, -1, 5],\n      [-7, 3, 7, 4],\n      [8, 5, 9, 2]\n    ]\n    \n    Sample Output\n    29\n    \n    \"\"\"\n    sum_list = [sum(row) for row in arr]\n    max_element = max(sum_list)\n    return max_element"
      ],
      [
        0.9023380279541016,
        "def find_max_nested(list1, list2, list3):\n    \"\"\"\n    Find the maximum number of elements in a list of lists\n    \"\"\"\n    max_num_elm = 0\n    for lst in [list1, list2, list3]:\n        cur_num_elm = max([len(s) for s in lst])\n        if cur_num_elm > max_num_elm:\n            max_num_elm = cur_num_elm\n    return max_num_elm\n    def find_max_nested(list1, list2, list3):\n    \"\"\"\n    Find the maximum number of elements in a list\"\"\"\n    max_num_elm = 0\n    for lst in [list1, list2, list3]:\n        cur_num_elm = max([len(s) for s in lst])\n        if cur_num_elm > max_num_elm:\n            max_num_elm = cur_num_elm\n    return max_num_elm"
      ]
    ],
    "MBPP/13": [],
    "MBPP/14": [],
    "MBPP/15": [
      [
        0.9035768508911133,
        "def check_tuple(tuples):\n    \"\"\"\n    Check if a tuple contains a string 'k'\n    :param tuples: a list of tuples\n    :return: True if a tuple contains a string 'k'\n    \"\"\"\n    for t in tuples:\n        if 'k' in t:\n            return True\n    return False"
      ]
    ],
    "MBPP/16": [
      [
        0.9025259613990784,
        "def remove_digits_special_chars(string):\n    \"\"\"\n    Remove all digits and special characters from a string.\n    \"\"\"\n    new_string = \"\"\n    for char in string:\n        if not char.isdigit() and not char.isalpha():\n            new_string += char\n    return new_string\n    \n    def remove_digits(string):\n    \"\"\"\n    Remove all digits from a string.\n    \"\"\"\n    new_string = \"\"\n    for char in string:\n        if not char.isdigit():\n            new_string += char\n    return new_string\n    \n    def remove_special_chars(\"\"\"\n    new_string = \"\"\n    for char in string:\n        if char.islower():\n            new_string += char\n    return new_string"
      ]
    ],
    "MBPP/17": [],
    "MBPP/18": [
      [
        0.922247588634491,
        "def find_odd(arr):\n    \"\"\"\n    Given an array of integers, find the integer that appears an odd number of times.\n    There will always be only one integer that appears an odd number of times.\n    \"\"\"\n    # define a dictionary to store the frequency of each number\n    freq = {} \n\n    # iterate over the array\n    for num in arr:\n        # if num is not in the dictionary, initialize it with 1, else increment it\n        freq[num] = freq.get(num, 0) + 1 \n\n    # iterate over the array again\n    for num in arr:\n        # if the count of num in the dictionary is odd, return num\n        if freq[num] % 2 != 0: \n            return num\n\n    # if no odd count numbers are found, return None\n    return None  "
      ],
      [
        0.9154081344604492,
        "def find_odd_occurrence(arr):\n    \"\"\"\n    Find the number that occurs an odd number of times in the array.\n    :param arr: List of integers\n    :return: Integer\n    \"\"\"\n    result = 0\n    for num in arr:\n        result ^= num\n    return result"
      ]
    ],
    "MBPP/19": [
      [
        0.905217707157135,
        "def count_strings(lst):\n    \"\"\"\n    Return the count of the number of strings where the string length is 2 or more and the first and last character are the same.\n    \n    >>> count_strings(['aba', 'xyz', 'aa', 'x', 'bbb'])\n    3\n    >>> count_strings(['', 'x', 'xy', 'xyx', 'xx'])\n    2\n    >>> count_strings(['aaa', 'be', 'abc', 'hello'])\n    1\n    \"\"\"\n    count = 0\n    \n    # Iterate through the list\n    for s in lst:\n        # Check if string length is greater than 2 and first and last character is same\n        if len(s) >= 2 and s[0] == s[-1]:\n            count += 1\n    \n    return count"
      ]
    ],
    "MBPP/20": [
      [
        0.9234486818313599,
        "def k_most_frequent(nums, k):\n    \"\"\"\n    Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\n\n    Example 1:\n    Input: nums = [1,1,1,2,2,3], k = 2\n    Output: [1,2]\n\n    Example 2:\n    Input: nums = [1], k = 1\n    Output: [1]\n    \"\"\"\n    # Step 1: Create a hashmap to count the frequency of each element\n    counter = Counter(nums)\n\n    # Step 2: Create a min heap to store the k most frequent elements\n    heap = []\n\n    # Step 3: Iterate through the hashmap and add elements to the min heap\n    for num, count in counter.items():\n        heapq.heappush(heap, (count, num))\n        if len(heap) > k:\n            heapq.heappop(heap)\n\n    # Step 4: Return the k most frequent elements\n    return [num for count, num in heap]"
      ],
      [
        0.9198451042175293,
        "def topKFrequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    # Step 1: Create a hash map to store the frequency count of each element\n    freq_map = defaultdict(int)\n    \n    # Step 2: Update the frequency count in the hash map\n    for num in nums:\n        freq_map[num] += 1\n    \n    # Step 3: Create a min heap to store the k most frequent elements\n    min_heap = []\n    \n    # Step 4: Iterate through the hash map\n    for num, freq in freq_map.items():\n        # Step 4a: Add the key to the heap if heap size < k\n        if len(min_heap) < k:\n            heapq.heappush(min_heap, (freq, num))\n        else:\n            # Step 4b: Compare the frequency count with the root element of the heap\n            if freq > min_heap[0][0]:\n                heapq.heappop(min_heap)\n                heapq.heappush(min_heap, (freq, num))\n    \n    # Step 6: Iterate through the heap to get the k most frequent elements\n    result = []\n    while min_heap:\n        result.append(heapq.heappop(min_heap)[1])\n    \n    return result[::-1] # Reverse the result to get the desired order"
      ],
      [
        0.9178884029388428,
        "def topKFrequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    # Step 1: Create a hash map to store the frequency of each element\n    freq_map = {}\n    for num in nums:\n        freq_map[num] = freq_map.get(num, 0) + 1\n\n    # Step 2: Create a min heap to store the k most frequent elements\n    min_heap = []\n    for num, freq in freq_map.items():\n        heapq.heappush(min_heap, (freq, num))\n        if len(min_heap) > k:\n            heapq.heappop(min_heap)\n\n    # Step 3: Create the result array\n    result = []\n    while min_heap:\n        result.append(heapq.heappop(min_heap)[1])\n\n    # Step 4: Reverse the result array to maintain non-increasing order of frequency\n    result.reverse()\n\n    return result"
      ]
    ],
    "MBPP/21": [],
    "MBPP/22": [
      [
        0.9317243695259094,
        "def decimal_to_binary(num): \n    \"\"\"\n    Function to convert decimal number to binary\n    \"\"\"\n    if num > 1:\n        decimal_to_binary(num//2) \n    print(num % 2, end='')\n    \n    def decimal_to_binary(num): \n    \"\"\"\n    Function to convert decimal number to binary\n    \"\"\"\n    if num > 1:\n        decimal_to_binary(num//2) \n    print(num % 2, end='')"
      ],
      [
        0.9303419589996338,
        "def dec_to_bin(num): \n    \"\"\"\n    Convert decimal to binary\n    \"\"\"\n    if num > 1: \n        dec_to_bin(num // 2) \n    print(num % 2, end = '')\n    def dec_to_bin(num): \n    \"\"\"\n    Convert decimal to binary\n    \"\"\"\n    if num > 1: \n        dec_to_bin(num // 2) \n    print(num % 2, end = '')"
      ],
      [
        0.927934467792511,
        "def dec2bin(num): \n    \"\"\"\n    Convert decimal to binary \n    \"\"\"\n    if num > 1: \n        dec2bin(num // 2) \n    print(num % 2, end = '') \n    \n    def dec2bin(num): \n    \"\"\"\n    Convert decimal to binary \n    \"\"\"\n    if num > 1: \n        dec2bin(num // 2) \n    print(num % 2, end = '') "
      ],
      [
        0.9221658706665039,
        "def convert_to_binary(num):\n    \"\"\"\n    Convert a decimal number to binary\"\"\"\n    if num == 0:\n        return\n    else:\n        convert_to_binary(num//2)\n        print(num % 2, end=\"\")"
      ],
      [
        0.9191741943359375,
        "def binary_conversion(n):\n    \"\"\"\n    This function converts a decimal number to binary\"\"\"\n    if n == 0:\n        return '0'\n    elif n == 1:\n        return '1'\n    else:\n        return binary_conversion(n // 2) + str(n % 2)"
      ]
    ],
    "MBPP/23": [
      [
        0.9274944067001343,
        "def find_missing(arr): \n    \"\"\"\n    Find the missing number in a given integer array of 1 to 100\n    \"\"\"\n    arr = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37\"\"\"\n    arr.sort() \n    for i in range(len(arr)): \n        if (arr[i+1] - arr[i] != 1): \n            return arr[i] + 1"
      ],
      [
        0.927086353302002,
        "def missing_nums(arr):\n    \"\"\"\n    Given an array of sorted numbers, find the missing number in the array.\n    The array contains numbers in the range of 1 to 100.\n    The array is sorted in ascending order.\n    \n    Input: [1, 2, 4, 5, 6, 7, 9]\n    Output: 3\n    \n    Input: [1, 2, 3, 4, 6, 7, 8, 9, 10]\n    Output: 5\n    \n    Input: [1, \"\"\"\n    n = len(arr)\n    for i in range(n - 1):\n        expected_num = arr[i] + 1\n        if arr[i + 1] != expected_num:\n            return expected_num\n    return None"
      ],
      [
        0.926863431930542,
        "def find_missing_element(arr, missing):\n    \"\"\"\n    Find the missing element in a given array.\n    \n    Args:\n        arr: a sorted array of integers\n        missing: the missing element\n    \n    Returns:\n        The missing element\n    \"\"\"\n    sorted_arr = sorted(arr)\n    curr = sorted_arr[0]\n    for element in sorted_arr[1:]:\n        if element != (curr + 1):\n            return curr + 1\n        else:\n            curr = element\n    return missing"
      ]
    ],
    "MBPP/24": [
      [
        0.8955259323120117,
        "def triangular_number(n):\n    \"\"\"\n    Return the nth triangular number.\n    \n    >>> triangular_number(1)\n    1\n    >>> triangular_number(2)\n    3\n    >>> triangular_number(3)\n    6\n    >>> triangular_number(10)\n    55\n    \"\"\"\n    return n * (n + 1) // 2"
      ],
      [
        0.8918617367744446,
        "def triangular_number(n):\n    \"\"\"\n    Return the nth triangular number.\n    \n    >>> triangular_number(0)\n    0\n    >>> triangular_number(1)\n    1\n    >>> triangular_number(2)\n    3\n    >>> triangular_number(3)\n    6\n    >>> triangular_number(10)\n    55\n    >>> triangular_number(100)\n    5050\n    >>> triangular_number(1000)\n    500500\n    >>> triangular_number(10000)\n    5000\"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer.\")\n    return n * (n + 1) // 2"
      ]
    ],
    "MBPP/25": [
      [
        0.8829457759857178,
        "def find_longest_repeating_decimal(n):\n    \"\"\"\n    Find the longest repeating decimal of a number\n    :param n: number\n    :return: longest repeating decimal\n    \"\"\"\n    maxi = 0\n    maxidx = 0\n    for d in range(2, n):\n        remainders = []\n        num = 1\n        count = 0\n        while num != 0 and num not in remainders:\n            remainders.append(num)\n            num *= 10\n            num %= d\n            count += 1\n        if num != 0 and count > maxi:\n            maxi = count\n            maxidx = d\n    return maxidx"
      ],
      [
        0.8812135457992554,
        "def fraction_to_base_n(num, base, precision):\n    \"\"\"\n    Convert a fraction to a base-n number.\n    \n    num: a fraction\n    base: a positive integer\n    precision: a positive integer\n    \n    Returns a string.\n    \"\"\"\n    chars = \"0123456789ABCDEF\"\n    \n    result = \"\"\n    \n    for _ in range(precision):\n        num = num * base\n        digit = int(num)\n        result += chars[digit]\n        num -= digit\n    \n    return result"
      ],
      [
        0.8768733739852905,
        "def fraction_to_decimal(numerator, denominator):\n    \"\"\"\n    Convert a fraction to a decimal.\n    \"\"\"\n    if numerator == 0:\n        return \"0\"\n    res = []\n    if (numerator > 0) ^ (denominator > 0):\n        res.append(\"-\")\n    num = abs(numerator)\n    den = abs(denominator)\n    res.append(str(num // den))\n    num %= den\n    if num == 0:\n        return \"\".join(res)\n    res.append(\".\")\n    map = {}\n    while num:\n        if num in map:\n            \"\"\"\n    if numerator == 0:\n        return \"0\"\n    res = []\n    if (numerator > 0) ^ (denominator > 0):\n        res.append(\"-\")\n    num = abs(numerator)\n    den = abs(denominator)\n    res.append(str(num // den))\n    num %= den\n    if num == 0:\n        return \"\".join(res)\n    res.append(\".\")\n    map = {}\n    while num:\n        if num in map:\n            res.insert(map[num], \"(\")\n            res.append(\")\")\n            break\n        map[num] = len(res)\n        num *= 10\n        res.append(str(num // den))\n        num %= den\n    return \"\".join(res)"
      ]
    ],
    "MBPP/26": [
      [
        0.9186805486679077,
        "def sort_mixed_list(lst):\n    \"\"\"\n    Sort a list of numbers and strings.\n    Numbers come first. Strings are sorted alphabetically.\n    \"\"\"\n    return sorted(lst, key=lambda x: (not isinstance(x, int), x))\n    \n    def sort_mixed_list(lst):\n    \"\"\"\n    Sort a list of numbers and strings.\n    Numbers come first. Strings are sorted alphabetically.\n    \"\"\"\n    return sorted(lst, key=lambda x: int(''.join(filter(str.isdigit, x))))"
      ]
    ],
    "MBPP/27": [
      [
        0.9184417724609375,
        "def divide_list(l):\n    \"\"\"\n    \"\"\"\n    odd_list = []\n    even_list = []\n    for num in l:\n        if num % 2 == 0: \n            even_list.append(num)\n        else:\n            odd_list.append(num)\n    return even_list, odd_list"
      ],
      [
        0.9156134128570557,
        "def find_even_odd(nums):\n  \"\"\"\n  Given a list of numbers, return a tuple containing two lists. The first list should contain all even numbers in the original list in the same order they appeared. The second list should contain all odd numbers in the original list in the same order they appeared.\n  \n  Example:\n  \n  find_even_odd([1,2,3,4,5,6])\n  \n  return ([2,4,6],[1,3,5])\n  \"\"\"\n  even_list = []\n  odd_list = []\n  for num in nums:\n    if num % 2 == 0:\n      even_list.append(num)\n    else:\n      odd_list.append(num)\n  \n  return even_list, odd_list"
      ]
    ],
    "MBPP/28": [
      [
        0.9126439094543457,
        "def can_rearrange_to_palindrome(s):\n    \"\"\"\n    Given a string, determine if it can be rearranged to form a palindrome.\n    For example, \"aabb\" -> true, \"abc\" -> false\n    You can only rearrange characters, you can't add or remove any.\n    \"\"\"\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    odd_count = 0\n    for count in char_count.values():\n        if count % 2 == 1:\n            odd_count += 1\n    return odd_count <= 1"
      ],
      [
        0.9063710570335388,
        "def can_form_palindrome(s):\n    \"\"\"\n    Given a string, determine if it can be rearranged to form a palindrome.\n    For example, \"abcba\" can be rearranged to form \"abcba\", but \"abca\" cannot.\n    \"\"\"\n    char_counts = {}\n    for char in s:\n        if char not in char_counts:\n            char_counts[char] = 1\n        else:\n            char_counts[char] += 1\n    odd_counts = 0\n    for count in char_counts.values():\n        if count % 2 != 0:\n            odd_counts += 1\n    if odd_counts > 1:\n        return False\n    return True"
      ],
      [
        0.905531644821167,
        "def can_form_palindrome(string):\n    \"\"\"\n    Given a string, determine if it can be rearranged to form a palindrome.\n    \n    For example,\n    \"abcba\" can be rearranged to form \"abcba\", but \"abca\" cannot be rearranged to form a palindrome.\n    \n    Return true if the string can be rearranged to form a palindrome, otherwise return false.\n    \"\"\"\n    # Create a count array to store count of characters\n    count_map = [0]*256  # Assuming ASCII characters\n \n    # Traverse through given string and increment\n    # count of characters in count_map.\n    for char in string:\n        count_map[ord(char)] += 1\n \n    # Count odd occurring characters\n    odd_count = 0\n    for count in count_map:\n        if count % 2 != 0:\n            odd_count += 1\n    \n    # Return true if the count of odd occurrences is less than or equal to 1.\n    return odd_count <= 1"
      ],
      [
        0.9051216840744019,
        "def is_palindrome_possible(string):\n    \"\"\"\n    \"\"\"\n    is_palindromeable = False\n\n    for i in range(len(string)):\n        j = len(string) - i - 1\n        if string[i] == string[j]:\n            is_palindromeable = True\n        else: \n            is_palindromeable = False\n            break\n\n    if is_palindromeable:\n        print('It is possible to rearrange the letters in the string to create a palindrome.')\n    else:\n        print('It is not possible to rearrange the letters in the string to create a palindrome.')"
      ],
      [
        0.9039062261581421,
        "def can_form_palindrome(str1):\n    \"\"\"\n    Given a string, determine if it can be rearranged to form a palindrome.\n    \"\"\"\n    \"\"\"\n    The idea is to count the frequency of each character in the string.\n    If the number of characters with odd frequency is more than 1, then the string cannot form a palindrome.\n    \"\"\"\n    str1 = str1.lower()\n\n    count = [0] * 128\n\n    for i in range(len(str1)):\n        count[ord(str1[i])] += 1\n\n    odd_count = 0\n    for i in range(128):\n        if count[i] % 2 != 0:\n            odd_count += 1\n\n    return odd_count <= 1"
      ],
      [
        0.9030259847640991,
        "def can_form_palindrome(s):\n    \"\"\"\n    Given a string, determine if it can be rearranged to form a palindrome.\n    \n    For example,\n    \"aabb\" -> true\n    \"abc\" -> false\n    \n    You may assume all characters are in lowercase and the string's length will not exceed 100,000.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    freq = {}\n  \n    # Traverse the given string and count frequency of each character\n    for char in s:\n\n        # If character already present in dictionary, increment its count\n        if char in freq:\n            freq[char] += 1\n        else:\n            # Else add this character to dictionary\n            freq[char] = 1\n  \n    # Count characters with odd count\n    odd = 0\n    for k, v in freq.items():\n\n        # If count is odd, increment odd\n        odd += v & 1\n  \n    # If count of characters with odd count is greater than 1, return false. \n    # Else return true.\n    return odd <= 1"
      ],
      [
        0.9006029367446899,
        "def can_form_palindrome(s):\n    \"\"\"\n    Given a string, determine if it can be rearranged to form a palindrome.\n    \"\"\"\n    \"\"\"\n    Given a string, determine if it can be rearranged to form a palindrome.\n    \"\"\"\n    \"\"\"\n    Given a string, determine if it can be rearranged to form a palindrome.\n    \"\"\"\n    char_freq = {}\n    for char in s:\n        if char in char_freq:\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n    odd_count = 0\n    for count in char_freq.values():\n        if count % 2 != 0:\n            odd_count += 1\n        if odd_count > 1:\n            return False\n    return True"
      ]
    ],
    "MBPP/29": [
      [
        0.9064834117889404,
        "def count_lists(lst):\n    \"\"\"Main function to count number of lists in a list\"\"\"\n    # Flatten all lists in lst and convert them into tuples\n    lst = [tuple(flatten(sublist)) for sublist in lst if isinstance(sublist, list)]\n    \n    # Get the counts of each tuple\n    return {t: lst.count(t) for t in set(lst)}"
      ],
      [
        0.9047269821166992,
        "def count_lists(l):\n  \"\"\"\n  Given a list of lists, return a dictionary where the keys are the indices of the lists and the values are dictionaries of the items in the list and their counts.\n  \n  For example, given the list [[1, 2, 3], [1, 2, 3], [1, 2, 3, 4]], return {0: {1: 3, 2: 3, 3: 3}, 1: {1: 2, 2: 2, 3: 2}, 2: {1: 1, \"\"\"\n  result = {}\n  for i, sublist in enumerate(l):\n    if type(sublist) == list:\n      inner_dict = {}\n      for item in sublist:\n        if item in inner_dict:\n          inner_dict[item] += 1\n        else:\n          inner_dict[item] = 1\n      result[i] = inner_dict\n  return result"
      ]
    ],
    "MBPP/30": [],
    "MBPP/31": [],
    "MBPP/32": [],
    "MBPP/33": [
      [
        0.8907791376113892,
        "def match_pattern(word):\n    \"\"\"\n    Write a regex to match a word that starts with 'Py' and ends with 'on'\n    \"\"\"\n    pattern = r\"^Py[\\\\w]*[a-zA-Z_]$\"\n    if re.match(pattern, word):\n        return True\n    else:\n        return False\n    def match_pattern(word):\n    \"\"\"\n    Write a regex to match a word that starts with 'Py' and ends with 'on'\n    \"\"\"\n    pattern = r\"^Py[\\\\w]*[a-zA-Z_]$\"\n    if re.match(pattern, word):\n        return True\n    else:\n        return False"
      ]
    ],
    "MBPP/34": [
      [
        0.9321423768997192,
        "def gcd(arr):\n    \"\"\"\n    Find the greatest common divisor of an array of numbers.\n    \"\"\"\n    def gcd_recursion(a, b):\n        \"\"\"\n        Find the greatest common divisor of two numbers.\n        \"\"\"\n        if b == 0:\n            return a\n        return gcd_recursion(b, a % b)\n    \"\"\"\n    result = arr[0]\n    for i in range(1, len(arr)):\n        result = gcd_recursion(result, arr[i])\n    return result"
      ],
      [
        0.9291998147964478,
        "def gcd(arr):\n    \"\"\"\n    Find the gcd of an array of numbers\n    \"\"\"\n    return gcd_array(arr)\n\n    def gcd_array(arr):\n    \"\"\"\n    Find the gcd of an array of numbers\n    \"\"\"\n    num1=arr[0]\n    num2=arr[1]\n    gcd1,factor1,factor2 = extended_euclid(num1,num2)\n\n    for i in range(2,len(arr)):\n        gcd1,factor1,factor2 = extended_euclid(gcd1,arr[i])\n\n    return gcd1"
      ]
    ],
    "MBPP/35": [],
    "MBPP/36": [
      [
        0.895783007144928,
        "def last_non_zero_digit(n):\n    \"\"\"\n    Last non-zero digit in the factorial of a given number\n    \n    Args:\n        n (int): Given number\n    \n    Returns:\n        int: Last non-zero digit in the factorial of a given number\n    \"\"\"\n    # Array to store last non-zero digit of \n    # factorial of all numbers from 0 to 10\n    res = [1, 1, 2, 6, 4, 2, 2, 4, 2, 8]\n    \n    if (n < 10):\n        return res[n]\n   \n    if (((n//10)%10)%2 == 0):\n        return (6*last_non_zero_digit(n//5)*res[n%10]) % 10\n    else:\n        return (4*last_non_zero_digit(n//5)*res[n%10]) % 10"
      ]
    ],
    "MBPP/37": [],
    "MBPP/38": [],
    "MBPP/39": [
      [
        0.8890246748924255,
        "def find_min(lst):\n    \"\"\"\n    Find the minimum value in a list of numbers\n    \"\"\"\n    min_val = lst[0] # Initialize the min_val with the first element of the tuple\n    for i in lst:\n        if i < min_val:\n            min_val = i\n    return min_val\n    def find_min(lst):\n    \"\"\"\n    Find the minimum value in a list of numbers\n    \"\"\"\n    min_val = lst[0] # Initialize the min_val with the first element of the tuple\n    for i in lst:\n        if i < min_val:\n            min_val = i\n    return min_val"
      ]
    ],
    "MBPP/40": [
      [
        0.9134213924407959,
        "def is_equilateral(a, b, c):\n    \"\"\"\n    Determines if a triangle is equilateral given the lengths of its sides a, b, and c.\n    \"\"\"\n    if a == b and b == c:\n        return True\n    else:\n        return False"
      ],
      [
        0.9095579385757446,
        "def is_equilateral(a, b, c):\n    \"\"\"\n    Return True if all three angles are equal, False otherwise.\n    \"\"\"\n    if a == b == c:\n        return True\n    else:\n        return False"
      ]
    ],
    "MBPP/41": [
      [
        0.9247100353240967,
        "def parallelogram_area(base, height):\n    \"\"\"\n    Calculate the area of a parallelogram.\n    \n    :param base: The base of the parallelogram.\n    :param height: The height of the parallelogram.\n    :return: The area of the parallelogram.\n    \"\"\"\n    area = base * height\n    return area"
      ],
      [
        0.9125247001647949,
        "def parallelogram_area(lst):\n    \"\"\"\n    Calculate the area of a parallelogram.\n    \n    Args:\n        lst: list of base and height of the parallelogram.\n    \n    Returns:\n        list of area of the parallelogram.\n    \"\"\"\n    return [round(base * height, 2) for base, height in lst]"
      ],
      [
        0.9111216068267822,
        "def area_of_parallelogram(base, side, alpha):\n    \"\"\"\n    Calculate the area of a parallelogram.\n    \n    :param base: The base of the parallelogram.\n    :param side: The side of the parallelogram.\n    :param alpha: The angle between the base and the side.\n    :return: The area of the parallelogram.\n    \"\"\"\n    return round(base * side * math.sin(math.radians(alpha)))"
      ]
    ],
    "MBPP/42": [
      [
        0.9115945100784302,
        "def first_last_same(string):\n    \"\"\"\n    Checks if the first and last characters of the string are the same.\n    \n    Args:\n        string (str): The string to be examined\n        \n    Returns:\n        bool: True if the first and last characters are the same, False otherwise\n    \"\"\"\n    if len(string) < 2:\n        return False\n\n    return string[0] == string[-1]"
      ]
    ],
    "MBPP/43": [],
    "MBPP/44": [
      [
        0.9193241596221924,
        "def nth_term(a, r, n):\n   \"\"\"\n   Returns the nth term of a geometric sequence.\n   \n   Args:\n   a: the first term of the sequence\n   r: the common ratio of the sequence\n   n: the index of the term to return\n   \n   Returns:\n   The nth term of the sequence.\n   \"\"\"\n   return a * (r ** (n - 1))"
      ]
    ],
    "MBPP/45": [],
    "MBPP/46": [
      [
        0.8939317464828491,
        "def maxNumber(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    arr.sort(reverse=True)\n    numStr = \"\"\n    for a in arr:\n        numStr += str(a)\n    return int(numStr)"
      ]
    ],
    "MBPP/47": [
      [
        0.8881471157073975,
        "def same_magnitude(x, y):\n    \"\"\"\n    Return True if x and y have the same magnitude, False otherwise.\n    \n    >>> same_magnitude(5, 7)\n    False\n    >>> same_magnitude(-1, 1)\n    True\n    >>> same_magnitude(2.2, -4.5)\n    True\n    \"\"\"\n    if abs(x) == abs(y):\n        return True\n    else:\n        return False"
      ]
    ],
    "MBPP/48": [
      [
        0.8962805271148682,
        "def heptagonal_number(n):\n    \"\"\"\n    Returns the nth heptagonal number.\n    \n    >>> heptagonal_number(1)\n    1\n    >>> heptagonal_number(2)\n    7\n    >>> heptagonal_number(3)\n    18\n    >>> heptagonal_number(10)\n    125\n    \"\"\"\n    return n*(5*n - 3)/2 "
      ]
    ],
    "MBPP/49": [
      [
        0.910391092300415,
        "def longestSubsequence(arr, n):\n    \"\"\"\n    :param arr: given array\n    :param n: size of array\n    :return: return the length of longest subsequence\n    \"\"\"\n    \n    # Stores the length of longest \n    # subsequence with difference arr[i]\n    mp = {}\n \n    # Initialize result\n    max_len = 1\n \n    # Traverse elements from left\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            diff = arr[j] - arr[i]\n \n            # If this difference is not seen before,\n            # then this difference forms a new sequence \n            # of length 2\n            if diff not in mp.keys():\n                mp[diff] = 2\n \n            # Else, increment length of old sequence\n            else:\n                mp[diff] += 1\n \n            # Update max_len\n            max_len = max(max_len, mp[diff])\n \n    return max_len"
      ],
      [
        0.9098790884017944,
        "def longestSubsequence(arr, difference):\n    \"\"\"\n    :type arr: List[int]\n    :type difference: int\n    :rtype: int\n    \"\"\"\n    dp = {}\n    maxLength = 0\n    for num in arr:\n        dp[num] = dp.get(num - difference, 0) + 1\n        maxLength = max(maxLength, dp[num])\n    return maxLength"
      ],
      [
        0.9098753929138184,
        "def longestSubsequence(arr, difference):\n    \"\"\"\n    :type arr: List[int]\n    :type difference: int\n    :rtype: int\n    \"\"\"\n    dp = {}\n    maxLength = 0\n    for num in arr:\n        dp[num] = dp.get(num - difference, 0) + 1\n        maxLength = max(maxLength, dp[num])\n    return maxLength"
      ],
      [
        0.9093453884124756,
        "def longestSubsequence(arr, difference):       \n    \"\"\"\n    :type arr: List[int]\n    :type difference: int\n    :rtype: int\n    \"\"\"\n    dp = {}\n    for elem in arr:\n        if elem - difference in dp:\n            dp[elem] = dp[elem - difference] + 1\n        else:\n            dp[elem] = 1\n    return max(dp.values())"
      ],
      [
        0.9032495021820068,
        "def longest_subarray(arr):\n    \"\"\"\n    Find the length of the longest subarray where the difference between adjacent elements is 1.\n    \n    Args:\n        arr (list): List of integers.\n    \n    Returns:\n        int: Length of the longest subarray.\n    \"\"\"\n    cur_length = 1\n    max_length = 1\n\n    for i in range(1, len(arr)):\n        if arr[i] - 1 == arr[i-1]:\n            cur_length += 1\n        else:\n            if cur_length > max_length:\n                max_length = cur_length\n            cur_length = 1\n\n    if cur_length > max_length:\n        max_length = cur_length\n\n    return max_length"
      ]
    ],
    "MBPP/50": [],
    "MBPP/51": [
      [
        0.9370683431625366,
        "def find_smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n        lst: a list of numbers\n    \n    Returns:\n        The smallest number in the list.\n    \"\"\"\n    return min(lst)"
      ],
      [
        0.9311667680740356,
        "def smallest_num(numbers): \n    \"\"\"\n    Find the smallest number in a list of numbers\n    \"\"\"\n    smallest = numbers[0]\n    for number in numbers:\n        if number < smallest:\n            smallest = number\n    return smallest\n    def smallest_num(numbers): \n    \"\"\"\n    Find the smallest number in a list of numbers\n    \"\"\"\n    smallest = numbers[0]\n    for number in numbers:\n        if number < smallest:\n            smallest = number\n    return smallest"
      ],
      [
        0.9308810234069824,
        "def find_smallest(arr):\n    \"\"\"\n    Find the smallest number in a list\n    \"\"\"\n    smallest = arr[0]\n    for num in arr:\n        if num < smallest:\n            smallest = num\n    return smallest\n    def find_smallest(arr):\n    \"\"\"\n    Find the smallest number in a list\n    \"\"\"\n    smallest = arr[0]\n    for num in arr:\n        if num < smallest:\n            smallest = num\n    return smallest"
      ],
      [
        0.9308220148086548,
        "def find_smallest(nums):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n        nums: a list of numbers\n    \n    Returns:\n        The smallest number in the list.\n    \"\"\"\n    return min([num for num in nums])"
      ],
      [
        0.9286795258522034,
        "def find_smallest(arr):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    :param arr: a list of numbers\n    :return: the smallest number in the list\n    \"\"\"\n    smallest = None\n    for n in arr:\n        if smallest is None or n < smallest:\n            smallest = n\n    return smallest"
      ],
      [
        0.9277645945549011,
        "def find_smallest_number(lst):\n  \"\"\"\n  Find the smallest number in a list.\n  \n  Args:\n    lst: a list of numbers\n  \n  Returns:\n    The smallest number in the list.\n  \"\"\"\n  smallest = lst[0]\n  for number in lst:\n    if number < smallest:\n      smallest = number\n  return smallest"
      ],
      [
        0.9277079105377197,
        "def find_min(lst):\n    \"\"\"\n    Find the minimum element in a list.\n    \n    Args:\n        lst: A list of numbers.\n    \n    Returns:\n        The minimum element in the list.\n    \"\"\"\n    return min(lst)"
      ]
    ],
    "MBPP/52": [
      [
        0.910883903503418,
        "def findMaxDifference(arr):\n    \"\"\"\n    Find the maximum difference between two elements in an array\n    such that the larger element appears after the smaller number.\n    \"\"\"\n    max_1, max_2 = arr[0], arr[0]\n    for num in arr[1:]:\n        if num > max_1:\n            max_2 = max_1\n            max_1 = num\n        elif num > max_2:\n            max_2 = num\n\n    return max_1 - max_2\n    def findMaxDifference(arr):\n    \"\"\"\n    Find the maximum difference between two elements in\"\"\"\n    max_1, max_2 = arr[0], arr[0]\n    for num in arr[1:]:\n        if num > max_1:\n            max_2 = max_1\n            max_1 = num\n        elif num > max_2:\n            max_2 = num\n\n    return max_1, max_2"
      ],
      [
        0.9034507870674133,
        "def max_difference(arr):\n    \"\"\"\n    Find the maximum difference between any two elements in an array.\n    \n    Args:\n        arr (list): The input array.\n        \n    Returns:\n        int: The maximum difference between any two elements in the array.\n    \"\"\"\n    # Initialize the maximum difference to 0\n    max_diff = 0\n    \n    # Loop through the array \n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            # Calculate the difference between the current pair of elements\n            diff = arr[j] - arr[i]    \n                \n            # Update the maximum difference if needed\n            if diff > max_diff:\n                max_diff = diff\n                \n    # Return the maximum difference\n    return max_diff"
      ],
      [
        0.9033412933349609,
        "def max_difference(numbers):\n    \"\"\"\n    Find the maximum difference between any two elements in a list of numbers.\n    \n    Args:\n       numbers(list): list of numbers\n    Returns:\n       difference (int): maximum difference between any two elements\n    \"\"\"\n    max_diff = 0\n    for i in range(len(numbers)-1):\n        for j in range(i+1, len(numbers)):\n            cur_diff = abs(numbers[i] - numbers[j])\n            if cur_diff > max_diff:\n                max_diff = cur_diff\n    return max_diff"
      ]
    ],
    "MBPP/53": [],
    "MBPP/54": [],
    "MBPP/55": [
      [
        0.9386467933654785,
        "def countPositive(nums):\n    \"\"\"\n    Count the number of positive numbers in a list.\n    \n    Args:\n        nums (list): A list of integers.\n    \n    Returns:\n        int: The number of positive numbers in the list.\n    \"\"\"\n    count = 0\n    for num in nums:\n        if num > 0:\n            count += 1\n    print(\"Number of positive numbers:\", count)"
      ],
      [
        0.9309738278388977,
        "def count_positive(arr):\n    \"\"\"\n    Return the number of positive numbers in an array\n    \"\"\"\n    count = 0\n    for i in arr:\n        if i > 0:\n            count += 1\n    return count\n    def count_positive(arr):\n    \"\"\"\n    Return the number of positive numbers in an array\n    \"\"\"\n    count = 0\n    for i in arr:\n        if i > 0:\n            count += 1\n    return count"
      ],
      [
        0.9248071312904358,
        "def count_positive_nums(arr):\n    \"\"\"\n    Return the count of numbers greater than zero in the list.\n    \n    >>> count_positive_nums([1, 2, 3, -4, 5])\n    4\n    \"\"\"\n    return sum(1 for num in arr if num > 0)"
      ]
    ],
    "MBPP/56": [
      [
        0.8939943313598633,
        "def nth_bell_number(n):\n    \"\"\"\n    Return the nth Bell number.\n    \"\"\"\n    return bell_number(n)\n    \n    def bell_number(n):\n    \"\"\"\n    Return the Bell number of order n.\n    \"\"\"\n    Bell = [[0 for i in range(n+1)] for j in range(n+1)]\n    Bell[0][0] = 1\n    for i in range(1, n+1):\n        Bell[i][0] = Bell[i-1][i-1]\n        for j in range(1, i+1):\n            Bell[i][j] = Bell[i-1][j-1] + Bell[i][j-1]\n\n    return Bell[n][0]"
      ],
      [
        0.8939656615257263,
        "def bell_number(n: int) -> int:\n    \"\"\"\n    Return the Bell number of n.\n    \n    >>> bell_number(0)\n    1\n    >>> bell_number(1)\n    1\n    >>> bell_number(2)\n    2\n    >>> bell_number(3)\n    5\n    >>> bell_number(4)\n    15\n    >>> bell_number(5)\n    52\n    >>> bell_number(6)\n    203\n    >>> bell_number(7)\n    877\n    >>> bell_number(8)\n    4140\"\"\"\n    check_input(n)\n    bell_matrix = [[0 for i in range(n+1)] for j in range(n+1)]\n    bell_matrix[0][0] = 1\n    for i in range(1, n+1):\n        bell_matrix[i][0] = bell_matrix[i-1][i-1]\n        for j in range(1, i+1):\n            bell_matrix[i][j] = bell_matrix[i-1][j-1] + bell_matrix[i][j-1]\n    return bell_matrix[n][0]"
      ],
      [
        0.8934227824211121,
        "def bell_number(n: int) -> int:\n    \"\"\"\n    Return the Bell number of n.\n    \n    >>> bell_number(0)\n    1\n    >>> bell_number(1)\n    1\n    >>> bell_number(2)\n    2\n    >>> bell_number(3)\n    5\n    >>> bell_number(4)\n    15\n    >>> bell_number(5)\n    52\n    >>> bell_number(6)\n    203\n    >>> bell_number(7)\n    877\n    >>> bell_number(8)\n    4140\"\"\"\n    check_input(n)\n    bell_matrix = [[0 for i in range(n+1)] for j in range(n+1)]\n    bell_matrix[0][0] = 1\n    for i in range(1, n+1):\n        bell_matrix[i][0] = bell_matrix[i-1][i-1]\n    for j in range(1, i+1):\n        bell_matrix[i][j] = bell_matrix[i-1][j-1] + bell_matrix[i][j-1]\n    return bell_matrix[n][0]"
      ],
      [
        0.8874837160110474,
        "def nth_bell_number(n):\n    \"\"\"\n    Return the nth Bell number.\n    \n    >>> nth_bell_number(1)\n    1\n    >>> nth_bell_number(2)\n    2\n    >>> nth_bell_number(3)\n    5\n    >>> nth_bell_number(4)\n    15\n    >>> nth_bell_number(5)\n    52\n    \"\"\"\n    Bell = [[0 for _ in range(n+1)] for j in range(n+1)]\n    Bell[0][0] = 1\n    for i in range(1, n+1):\n        Bell[i][0] = Bell[i-1][i-1]\n        for j in range(1, i+1):\n            Bell[i][j] = Bell[i-1][j] + Bell[i][j-1]\n\n    return Bell[n][0]"
      ]
    ],
    "MBPP/57": [
      [
        0.9157615900039673,
        "def isMonotonic(A):\n    \"\"\"\n    :type A: List[int]\n    :rtype: bool\n    \"\"\"\n    return (all(A[i] < A[i+1] for i in range(len(A) - 1)) or\n            all(A[i] > A[i+1] for i in range(len(A) - 1)))"
      ],
      [
        0.9119415283203125,
        "def isIncreasing(arr): \n    \"\"\"\n    Given an array of integers, determine whether the array is monotonic or not.\n    An array is monotonic if it is either monotone increasing or monotone decreasing.\n    \n    Example 1:\n    Input: arr = [1,2,2,3]\n    Output: true\n    \n    Example 2:\n    Input: arr = [6,5,4,4]\n    Output: true\n    \n    Example 3:\n    Input: arr = [1,3,2]\n    Output: false\n    \n    Example 4:\n    Input: arr\"\"\"\n    for i in range(len(arr)-1): \n        if arr[i] > arr[i+1]: \n            return False\n      \n    return True"
      ],
      [
        0.9085062742233276,
        "def check_monotonic(list):\n    \"\"\"\n    Check if a list is monotonic\n    :param list: list of numbers\n    :return: True if monotonic, False otherwise\n    \"\"\"\n    is_monotonic = True\n    for i in range(len(list)-1):\n        if(list[i] > list[i+1]):\n            is_monotonic = False\n    return is_monotonic"
      ],
      [
        0.9009613990783691,
        "def monotonic(l: list, strict: bool = False) -> bool:\n    \"\"\"\n    Returns True if the list is monotonic.\n    \n    >>> monotonic([1, 2, 3, 4, 5])\n    True\n    >>> monotonic([5, 4, 3, 2, 1])\n    True\n    >>> monotonic([1, 2, 3, 2, 1])\n    False\n    >>> monotonic([1, 2, 3, 4, 5], strict=True)\n    True\n    >>> monotonic([5, 4, 3, 2, 1], strict=True)\n\"\"\"\n    if len(l) < 2:\n        return True\n    \n    if strict:\n        return all(x < y for x, y in zip(l, l[1:])) or all(x > y for x, y in zip(l, l[1:]))\n    else:\n        return all(x <= y for x, y in zip(l, l[1:])) or all(x >= y for x, y in zip(l, l[1:]))"
      ],
      [
        0.899867832660675,
        "def monotonic(l: list, strict: bool = False):\n    \"\"\"\n    This function determines if the sequence of elements in the list is either monotonically increasing or decreasing, considering the strictness criterion put in place.\n    If the strict parameter is assigned to be True, consecutive elements are not allowed to be identical; however, if it's False, they may be the same.\n\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 1, 0, -10], strict=True)\n    False\n    >>> monotonic([1, 1, 1, 1], strict=False)\n    True\n    \"\"\"\n    # Initialize flags for increasing and decreasing\n    increasing = decreasing = True\n\n    # Loop through the list to check sequence\n    for i in range(len(l) - 1):\n        # If strict is True\n        if strict:\n            if l[i] > l[i + 1]:\n                increasing = False\n            elif l[i] < l[i + 1]:\n                decreasing = False\n        # If strict is False\n        else:\n            if l[i] >= l[i + 1]:\n                increasing = False\n            elif l[i] <= l[i + 1]:\n                decreasing = False\n\n        # If list is not increasing and not decreasing, return False\n        if not increasing and not decreasing:\n            return False\n\n    # If the function has not returned yet, it means the list is either increasing or decreasing.\n    return True"
      ],
      [
        0.8998265266418457,
        "def monotonic(l: list, strict: bool = False):\n    \"\"\"\n    This function determines if the sequence of elements in the list is either monotonically increasing or decreasing, considering the strictness criterion put in place.\n    If the strict parameter is assigned to be True, consecutive elements are not allowed to be identical; however, if it's False, they may be the same.\n\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 1, 0, -10], strict=True)\n    False\n    >>> monotonic([1, 1, 1, 1], strict=False)\n    True\n    \"\"\"\n    # Initialize flags for increasing and decreasing\n    increasing = decreasing = True\n\n    # Loop through the list to check sequence\n    for i in range(len(l) - 1):\n        # If strict is True\n        if strict:\n            if l[i] <= l[i + 1]:\n                increasing = False\n            elif l[i] >= l[i + 1]:\n                decreasing = False\n        # If strict is False\n        else:\n            if l[i] < l[i + 1]:\n                increasing = False\n            elif l[i] > l[i + 1]:\n                decreasing = False\n\n    # If list is not increasing and not decreasing, return False\n    if not increasing and not decreasing:\n        return False\n\n    # If the function has not returned yet, it means the list is either increasing or decreasing.\n    return True"
      ]
    ],
    "MBPP/58": [],
    "MBPP/59": [
      [
        0.9007546901702881,
        "def all_same_length(strings):\n    \"\"\"\n    Return True if all the strings in the list have the same length.\n    >>> all_same_length(['one', 'two', 'three'])\n    False\n    >>> all_same_length(['one', 'two', 'three', 'four'])\n    False\n    >>> all_same_length(['one', 'two', 'three', 'four', 'five'])\n    True\n    \"\"\"\n    for i in range(1,len(strings)):\n        if len(strings[0]) != len(strings[i]):\n            return False\n    return True"
      ]
    ],
    "MBPP/60": [
      [
        0.9060235023498535,
        "def comb_sort(arr):\n    \"\"\"\n    Comb sort algorithm\n    \n    Args:\n        arr (list): list of numbers\n    \"\"\"\n    gap = len(arr)\n    swapped = True\n\n    while gap > 1 or swapped is True:\n        gap = max(1, int(gap/1.3))\n        swapped = False\n        \n        for i in range(len(arr)-gap):\n            if arr[i] > arr[i+gap]:\n                arr[i], arr[i+gap] = arr[i+gap], arr[i]\n                swapped = True"
      ],
      [
        0.8977251052856445,
        "def combSort(arr):\n    \"\"\"\n    Comb sort algorithm\n    :param arr: list\n    :return: list\n    \"\"\"\n    gap = len(arr)\n    swapped = True\n\n    while gap > 1 or swapped:\n        gap = int(gap / 1.3)\n        if gap < 1:\n            gap = 1\n        swapped = False\n\n        for i in range(len(arr) - gap):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                swapped = True\n\n    return arr"
      ],
      [
        0.889298677444458,
        "def comb_sort(arr):\n    \"\"\"\n    Comb sort algorithm\n    :param arr: array\n    :return: sorted array\n    \"\"\"\n    gap = len(arr)\n    shrink_factor = 1.3\n    sorted = False\n\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n\n        i = 0\n        while i + gap < len(arr):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n            i += 1\n\n    return arr"
      ]
    ],
    "MBPP/61": [],
    "MBPP/62": [
      [
        0.9037225842475891,
        "def split_string(s, delimiters):\n    \"\"\"\n    Split a string by one or more delimiters.\n    \n    :param s: string to split\n    :param delimiters: list of delimiters\n    :return: list of substrings\n    \"\"\"\n    return re.split('|'.join(map(re.escape, delimiters)), s)"
      ],
      [
        0.9037133455276489,
        "def split_string(s, delimiters):\n    \"\"\"\n    Split a string by one or more delimiters.\n    \n    :param s: string to split\n    :param delimiters: list of delimiters\n    :return: list of substrings\n    \"\"\"\n    return re.split('|'.join(map(re.escape, delimiters)), s)"
      ]
    ],
    "MBPP/63": [
      [
        0.8919104337692261,
        "def match_character_sequence(sequence):\n    \"\"\"\n    Match the given sequence\"\"\"\n    pattern = re.compile('abbccd')\n    match = pattern.match(sequence)\n    \n    if match:\n        return True\n    \n    return False"
      ]
    ],
    "MBPP/64": [
      [
        0.8944212794303894,
        "def count_multiples(lst, k):\n    \"\"\"\n    Given a list of numbers and a number k, return multiple_counts which contains all numbers in the list that have a count that is a multiple of k.\n    \n    For example, given [12, 17, 18, 10, 17, 14, 12, 17, 14, 12, 10, 14] and k = 3, return {12: 3, 14: 4}.\n    \n    If there are no numbers with a count that is a multiple of\"\"\"\n    multiples_dict = {}\n    for i in lst:\n        if i in multiples_dict:\n            multiples_dict[i] += 1\n        else:\n            multiples_dict[i] = 1\n    \n    multiple_counts = {}\n    for element, count in multiples_dict.items():\n        if count % k == 0:\n            multiple_counts[element] = count // k\n    \n    return multiple_counts"
      ]
    ],
    "MBPP/65": [],
    "MBPP/66": [
      [
        0.8969037532806396,
        "def even_odd_sum_and_count(num):\n    \"\"\"\n    Given a number, find the sum of even digits and odd digits separately and return them in a dictionary.\n    The keys of the dictionary should be 'even' and 'odd' respectively.\n    \"\"\"\n    # Your code here\n    \"\"\"\n    Given a number, find the sum of even digits and odd digits separately and return them in a dictionary.\n    The keys of the dictionary should be 'even' and 'odd' respectively.\n    \"\"\"\n    even_sum = 0\n    odd_sum = 0\n    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):\n        if int(digit) % 2 == 0:\n            even_sum += int(digit)\n            even_count += 1\n        else:\n            odd_sum += int(digit)\n            odd_count += 1\n    return { \"even\": {'sum' : even_sum, 'count' : even_count}, \"odd\": { 'sum': odd_sum, 'count' : odd_count}}"
      ],
      [
        0.8930492997169495,
        "def even_odd_count(num):\n    \"\"\"\n    This function accepts a number and returns the count of even and odd digits in the number\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    # we should ignore the negative sign if the number is negative\n    num = abs(num)\n    for digit in str(num):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)"
      ]
    ],
    "MBPP/67": [],
    "MBPP/68": [
      [
        0.899071216583252,
        "def is_odd(n):\n    \"\"\"\n    Return True if n is odd, False otherwise\n    \"\"\"\n    if n % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\""
      ]
    ],
    "MBPP/69": [
      [
        0.9245641231536865,
        "def tetra(n):\n    \"\"\"\n    Compute the first n tetrahedral numbers.\n    \n    Parameters\n    ----------\n    n : int\n        The number of tetrahedral numbers to compute.\n        \n    Returns\n    -------\n    tetra_list : list\n        A list of the first n tetrahedral numbers.\n    \"\"\"\n    if n < 0:\n        return \"Input must be a non-negative integer.\"\n\n    # Base cases\n    tetra_list = [1, 4, 2, 6]\n  \n    # Compute tetra(i) for i from 4 to n\n    for i in range(4, n + 1):\n        if i % 2 == 0:\n            tetra_list.append(1 + i//2)\n        elif i % 3 == 0:\n            tetra_list.append(tetra_list[i-1] + tetra_list[i-2])\n        else:\n            tetra_list.append(tetra_list[i-1] + tetra_list[i-2] + tetra_list[i-3])\n              \n    return tetra_list[:n+1]"
      ],
      [
        0.9135174751281738,
        "def tetra(n):\n    \"\"\"\n    Returns the first n tetra numbers\n    :param n: number of tetra numbers\n    :return: list of tetra numbers\n    \"\"\"\n    if n<1:\n        return []\n    sequence = [1,4]\n    for num in range(2, n+1): # Finding the tetra values for each num until n\n        if num % 2 == 0:\n            value = 1 + num // 2\n        elif num % 3 == 0:\n            value = sequence[-1] + sequence[-2]\n        else:\n            value = sequence[-1] + sequence[-2] + sequence[-3]\n        sequence.append(value) # Appending it in the list\n    return sequence[:n+1] # N+1 values"
      ],
      [
        0.903485119342804,
        "def tetra(n):\n    \"\"\"\n    Returns the first n terms of the tetranacci sequence.\n    \n    Args:\n        n (int): number of terms to return\n    \n    Returns:\n        list: first n terms of the tetranacci sequence\n    \"\"\"\n    #Initialize list with initial tetranacci numbers\n    tetra_sequence = [0, 4, 2, 6, 3] \n    for i in range(5, n+1):\n        if i % 2 == 0: #even-indexed term\n            tetra_sequence.append(1 + i // 2) \n        elif i % 3 == 0: #term divisible by 3\n            tetra_sequence.append(tetra_sequence[i-1] + tetra_sequence[i-2]) \n        else: #remaining odd-index terms\n            tetra_sequence.append(tetra_sequence[i-1] + tetra_sequence[i-2] + tetra_sequence[i-3]) \n    return tetra_sequence[1:n+1] #return required sequence"
      ]
    ],
    "MBPP/70": [
      [
        0.8930747509002686,
        "def zip_two_lists(list1, list2):\n    \"\"\"\n    \"\"\"\n    return zip(list1, list2)"
      ]
    ],
    "MBPP/71": [
      [
        0.9224098920822144,
        "def vol_sphere(r):\n    '''Calculate the volume of a sphere with a given radius'''\n    return (4/3) * math.pi * r**3"
      ]
    ],
    "MBPP/72": [],
    "MBPP/73": [
      [
        0.9048193097114563,
        "def hofstadter_conway(n):\n    \"\"\"\n    Returns the Hofstadter-Conway sequence up to the nth term.\n    \n    Args:\n        n (int): The number of terms to generate.\n    \n    Returns:\n        list: The Hofstadter-Conway sequence up to the nth term.\n    \"\"\"\n    C = [0, 1, 1] # start with the first three values\n    for i in range(3, n + 1):\n        C.append(C[i - C[i-1]] + C[i - C[i-2]]) # calculate the next value in the sequence\n    return C[1:] # return the sequence starting from the 1st value"
      ],
      [
        0.9027669429779053,
        "def find_nth_number(n):\n    \"\"\"\n    Find the nth number in the sequence.\n    The sequence starts with 1, 2, 1, 3, 2, 5, 3, 7, 5, 11, 8, 13, 13, 17, 12, 19, 17, 23, 15, 25, 21, 29, 20, 31, 25, 35, 28, 37, 30, 41, 3\"\"\"\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    else:\n        res = 2\n        pre = 1\n        for _ in range(3, n + 1):\n            res, pre = res + pre, res\n        return res"
      ]
    ],
    "MBPP/74": [
      [
        0.9256902933120728,
        "def sphere_surface_area(radius):\n    \"\"\"\n    Calculate the surface area of a sphere.\n    \n    Parameters:\n    radius (float): The radius of the sphere.\n    \n    Returns:\n    float: The surface area of the sphere.\n    \"\"\"\n    surface_area = 4 * math.pi * radius * radius\n    return surface_area "
      ],
      [
        0.9234554171562195,
        "def sphere_surface_area(radius):\n    '''\n    Computes the surface area of a sphere given its radius\n    '''\n    return 4 * 3.14 * (radius ** 2)"
      ],
      [
        0.9168764352798462,
        "def calculate_surface_area(radius):\n    \"\"\"\n    Calculate the surface area of a sphere.\n    \n    Args:\n        radius (float): The radius of the sphere.\n        \n    Returns:\n        float: The surface area of the sphere.\n    \"\"\"\n    surface_area = 4 * 3.14159 * (radius ** 2)\n    return round(surface_area, 2)"
      ],
      [
        0.9090690612792969,
        "def calculate_surface_area(radius):\n    '''\n    This function calculates the surface area of a sphere given a radius. \n    It checks to ensure that the radius is a positive number.\n    '''\n    if not isinstance(radius, (int, float)):\n        raise TypeError(\"The radius must be a numeric value.\")\n    elif radius < 0:\n        raise ValueError(\"The radius cannot be negative.\")\n    \n    surface_area = 4 * math.pi * (radius ** 2)\n    return round(surface_area, 2)"
      ]
    ],
    "MBPP/75": [
      [
        0.8908417820930481,
        "def isHexagonal(num):\n    \"\"\"\n    Returns True if num is a hexagonal number, False otherwise.\n    \n    >>> isHexagonal(1)\n    True\n    >>> isHexagonal(2)\n    False\n    >>> isHexagonal(17)\n    True\n    >>> isHexagonal(22)\n    False\n    >>> isHexagonal(145)\n    True\n    >>> isHexagonal(146)\n    False\n    \"\"\"\n    return (1 + math.sqrt(1 + 8 * num)) % 4 == 0"
      ]
    ],
    "MBPP/76": [],
    "MBPP/77": [
      [
        0.9206169843673706,
        "def frequency(my_list): \n    \"\"\"\n    The frequency function takes a list as an argument and returns a list of tuples where the first element is the element from the original list and the second element is the frequency of that element in the list.\n    \n    For example, if the argument is [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,\"\"\"\n    frequency_list = [] \n    for item in my_list: \n        if item not in frequency_list: \n            frequency_list.append(item) \n  \n    for i in range(0, len(frequency_list)): \n        frequency_list[i] = (frequency_list[i], my_list.count(frequency_list[i])) \n          \n    return frequency_list"
      ]
    ],
    "MBPP/78": [
      [
        0.899041473865509,
        "def get_next_lower(arr, num):\n  \"\"\"\n  Find the closest number in the array that is lower than the given number.\n  \n  Args:\n    arr: an array of integers\n    num: an integer\n  \n  Returns:\n    The closest number in the array that is lower than the given number.\n  \"\"\"\n  closest_low = 0\n  for i in range(len(arr)):\n    if num > arr[i] > closest_low:\n      closest_low = arr[i]\n  \n  return closest_low"
      ]
    ],
    "MBPP/79": [
      [
        0.9320865869522095,
        "def longest_word(sentence):\n    \"\"\"\n    Find the longest word in a sentence\n    \"\"\"\n    words = sentence.split()\n    max_len = len(words[0])\n    longest_word = words[0]\n    for word in words[1:]:\n        if len(word) > max_len:\n            max_len = len(word)\n            longest_word = word\n    return longest_word\n    def longest_word(sentence):\n    \"\"\"\n    Find the longest word in a sentence\n    \"\"\"\n    words = sentence.split()\n    max_len = len(words[0])\n    longest_word = words[0]\n    for word in words[1:]:\n        if len(word) > max_len:\n            max_len = len(word)\n            longest_word = word\n    return longest_word"
      ]
    ],
    "MBPP/80": [],
    "MBPP/81": [],
    "MBPP/82": [
      [
        0.9248223304748535,
        "def power(a, b):\n    \"\"\"\n    Calculate a to the power of b\n    :param a: base\n    :param b: exponent\n    :return: a to the power of b\n    \"\"\"\n    result = 1\n    for i in range(b):\n        result = result * a\n    return result"
      ],
      [
        0.9152974486351013,
        "def power(a, b):\n    \"\"\"\n    Calculate a to the power of b\n    \"\"\"\n    result = 1\n    if b >= 0:\n        for _ in range(b):\n            result *= a\n    else:\n        for _ in range(-b):\n            result /= a\n    return result\n    def power(a, b):\n    \"\"\"\n    Calculate a to the power of b\n    \"\"\"\n    result = 1\n    if b >= 0:\n        for _ in range(b):\n            result *= a\n    else:\n        for _ in range(-b):\n            result /= a\n    return result"
      ],
      [
        0.9126012921333313,
        "def exponentiation(a, b):\n    \"\"\"Returns a to the power of b\"\"\"\n    return float('%.3f' % (pow(a, b)))"
      ],
      [
        0.9087669849395752,
        "def exponentiation(a, b):\n    \"\"\"return a to the power of b\"\"\"\n    return float('%.3f'%(exp(b * log(a))))"
      ]
    ],
    "MBPP/83": [
      [
        0.8870929479598999,
        "def find_min_k_records(tup_list, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples.\n    :param tup_list: List of tuples.\n    :param k: Number of records to return.\n    :return: List of tuples.\n    \"\"\"\n    if len(tup_list) == 0:\n        return \"The tuple list is empty.\"\n    if k > len(tup_list):\n        return \"K is greater than the size of list. Returning all records.\"\n    tup_list.sort(key=lambda x: x[0])\n    return tup_list[:k]"
      ],
      [
        0.8815889954566956,
        "def find_min(lst):\n    \"\"\"\n    Find the minimum value in a list of numbers\n    \"\"\"\n    min_val = lst[0] # Initialize the min_val with the first element of the tuple\n    for i in lst:\n        if i < min_val:\n            min_val = i\n    return min_val\n    def find_min(lst):\n    \"\"\"\n    Find the minimum value in a list of numbers\n    \"\"\"\n    min_val = lst[0] # Initialize the min_val with the first element of the tuple\n    for i in lst:\n        if i < min_val:\n            min_val = i\n    return min_val"
      ],
      [
        0.8760649561882019,
        "def find_min(tpl):\n    \"\"\"\n    Find the minimum value in a tuple\n    :param tpl: tuple\n    :return: minimum value\n    \"\"\"\n    min_value = tpl[0]  # We start from the first element\n    for i in tpl:\n        if i < min_value:\n            min_value = i  # If we found a lesser value, we update our minimum\n    return min_value"
      ],
      [
        0.8760641813278198,
        "def find_min(tpl):\n    \"\"\"\n    Find the minimum value in a tuple\n    :param tpl: tuple\n    :return: minimum value\n    \"\"\"\n    min_value = tpl[0]  # We start from the first element\n    for i in tpl:\n        if i < min_value:\n            min_value = i  # If we found a lesser value, we update our minimum\n    return min_value"
      ]
    ],
    "MBPP/84": [],
    "MBPP/85": [
      [
        0.9340718984603882,
        "def divisor_count(n): \n    \"\"\"\n    Count the number of divisors of a positive integer\n    :param n: a positive integer\n    :return: the number of divisors of n\n    :rtype: int\n    :Example:\n    >>> divisor_count(10)\n    4\n    >>> divisor_count(13)\n    2\n    >>> divisor_count(28)\n    6\n    >>> divisor_count(17)\n    2\n    >>> divisor_count(100000000000000000000000000\"\"\"\n    # Get divisors for a number\n    count = 2  #1 and n are always divisors\n    i = 2 \n    while i * i <= n: \n        if n % i: \n            i += 1\n        else: \n            if n == i * i: \n                count += 1 \n            else: \n                count += 2\n            n /= i\n    return count"
      ],
      [
        0.9302680492401123,
        "def count_divisors(num):\n    \"\"\"\n    This function takes an integer and returns the number of divisors it has.\n    \n    >>> count_divisors(10)\n    4\n    >>> count_divisors(12)\n    6\n    >>> count_divisors(13)\n    2\n    \"\"\"\n    count = 0\n    for i in range(1, num + 1):\n        if num % i == 0:\n            count += 1\n    return count"
      ],
      [
        0.9268606901168823,
        "def count_number_divisors(x): \n    \"\"\"\n    This function takes an integer x and returns the number of divisors of x.\n    \n    Parameters\n    ----------\n    x : int\n        The number to count the divisors of.\n    \n    Returns\n    -------\n    int\n        The number of divisors of x.\n    \"\"\"\n    count = 0\n    for i in range(1, x+1): \n        if x % i == 0: \n            count = count + 1\n    return count"
      ],
      [
        0.926322340965271,
        "def divisor_count(n) :\n    \"\"\"\n    Count the number of divisors of a positive integer\n    :param n: a positive integer\n    :return: the number of divisors of n\n    :rtype: int\n    \"\"\"\n    # Get divisors for a number\n    count = 2  #1 and n are always divisors\n    i = 2\n    while i * i <= n :\n        if n % i :\n            i += 1\n        else :\n            if n == i * i :\n                count += 1\n            else :\n                count += 2\n            n /= i\n    return count    "
      ]
    ],
    "MBPP/86": [
      [
        0.9128949642181396,
        "def count_lists(lst):\n    \"\"\"Main function to count number of lists in a list\"\"\"\n    # Flatten all lists in lst and convert them into tuples\n    lst = [tuple(flatten(sublist)) for sublist in lst if isinstance(sublist, list)]\n    \n    # Get the counts of each tuple\n    return {t: lst.count(t) for t in set(lst)}"
      ],
      [
        0.9087579250335693,
        "def count_lists(l):\n  \"\"\"\n  Given a list of lists, return a dictionary where the keys are the indices of the lists and the values are dictionaries of the items in the list and their counts.\n  \n  For example, given the list [[1, 2, 3], [1, 2, 3], [1, 2, 3, 4]], return {0: {1: 3, 2: 3, 3: 3}, 1: {1: 2, 2: 2, 3: 2}, 2: {1: 1, \"\"\"\n  result = {}\n  for i, sublist in enumerate(l):\n    if type(sublist) == list:\n      inner_dict = {}\n      for item in sublist:\n        if item in inner_dict:\n          inner_dict[item] += 1\n        else:\n          inner_dict[item] = 1\n      result[i] = inner_dict\n  return result"
      ],
      [
        0.9044976830482483,
        "def count_lists(lst: List[Any]) -> dict:\n    \"\"\"\n    Count the number of times each list appears in a list of lists.\n    \n    Args:\n        lst (List[Any]): A list of lists.\n    \n    Returns:\n        dict: A dictionary mapping each list to the number of times it appears in the list of lists.\n    \"\"\"\n    freq_dict = defaultdict(int)\n    for item in lst:\n        if isinstance(item, list):\n            item = flatten(item)\n            freq_dict[tuple(item)] += 1\n    return freq_dict"
      ]
    ],
    "MBPP/87": [],
    "MBPP/88": [
      [
        0.9300466775894165,
        "def decimal_to_binary(num): \n    \"\"\"\n    Function to convert decimal number to binary\n    \"\"\"\n    if num > 1:\n        decimal_to_binary(num//2) \n    print(num % 2, end='')\n    \n    def decimal_to_binary(num): \n    \"\"\"\n    Function to convert decimal number to binary\n    \"\"\"\n    if num > 1:\n        decimal_to_binary(num//2) \n    print(num % 2, end='')"
      ],
      [
        0.9279680252075195,
        "def dec_to_bin(num): \n    \"\"\"\n    Convert decimal to binary\n    \"\"\"\n    if num > 1: \n        dec_to_bin(num // 2) \n    print(num % 2, end = '')\n    def dec_to_bin(num): \n    \"\"\"\n    Convert decimal to binary\n    \"\"\"\n    if num > 1: \n        dec_to_bin(num // 2) \n    print(num % 2, end = '')"
      ]
    ],
    "MBPP/89": [
      [
        0.9328644275665283,
        "def next_largest_palindrome(num):\n    \"\"\"\n    Return the next largest palindrome number for a given number.\n    :param num: str\n    :return: str\n    \"\"\"\n    # convert string to a number\n    num = int(num)\n    # increment number by 1\n    num += 1\n    while not is_palindrome(str(num)):\n        # increment number by 1\n        num += 1\n\n    return num"
      ],
      [
        0.9300032258033752,
        "def nextPalindrome(num: str) -> str:\n    \"\"\"\n    Given an integer num, find the smallest palindrome greater than or equal to num.\n    \n    If no such palindrome exists, return an empty string.\n    \n    \n    \n    Example 1:\n    \n    Input: num = \"121\"\n    Output: \"221\"\n    \n    \n    Example 2:\n    \n    Input: num = \"199999999999999999999999999999999999999999\"\"\"\n    n = len(num)\n    first_half = num[:(n + 1) // 2]\n    candidates = sorted(set(int(\"\".join(p)) for p in permutations(first_half)))\n\n    for c in candidates:\n        c_str = str(c)\n        second_half = c_str[::-1]\n        if n % 2 == 1: second_half = second_half[1:]\n        candidate_str = c_str + second_half\n\n        if candidate_str > num:\n            return candidate_str\n\n    return \"\""
      ],
      [
        0.9299936294555664,
        "def nextPalindrome(num: str) -> str:\n    \"\"\"\n    Given an integer num, find the smallest palindrome greater than or equal to num.\n    \n    If no such palindrome exists, return an empty string.\n    \n    \n    \n    Example 1:\n    \n    Input: num = \"121\"\n    Output: \"221\"\n    \n    \n    Example 2:\n    \n    Input: num = \"199999999999999999999999999999999999999999\"\"\"\n    n = len(num)\n    first_half = num[:(n + 1) // 2]\n    candidates = sorted(set(int(\"\".join(p)) for p in permutations(first_half)))\n\n    for c in candidates:\n        c_str = str(c)\n        second_half = c_str[::-1]\n        if n % 2 == 1: second_half = second_half[1:]\n        candidate_str = c_str + second_half\n\n        if candidate_str > num:\n            return candidate_str\n\n    return \"\""
      ],
      [
        0.9275603294372559,
        "def find_next_palindrome(N):\n    \"\"\"\n    Find the next palindrome number greater than N.\n    \n    Args:\n        N (int): The starting number.\n    \n    Returns:\n        int: The next palindrome number.\n    \"\"\"\n    # Increment N by 1 and check if it is a palindrome\n    N += 1\n    while not is_palindrome(N):\n        N += 1\n    \n    return N"
      ]
    ],
    "MBPP/90": [],
    "MBPP/91": [],
    "MBPP/92": [
      [
        0.8815024495124817,
        "def S(n, m):\n    \"\"\"\n    \"\"\"\n    return ((m * (n * (n + 1)) // 2) % 1234567891)"
      ]
    ],
    "MBPP/93": [],
    "MBPP/94": [
      [
        0.8903680443763733,
        "def count_sheeps(sheep):\n    \"\"\"\n    \"\"\"\n    total = 0\n    for i in sheep:\n        if i == True:\n            total += 1\n    return total"
      ]
    ],
    "MBPP/95": [],
    "MBPP/96": [],
    "MBPP/97": [],
    "MBPP/98": [
      [
        0.8836989402770996,
        "def count_binary(s):\n    \"\"\"\n    \"\"\"\n    count = 0\n    current = s[0]\n    prev = ''\n    for el in s:\n        if el == current:\n            if prev == '1':\n                count += 1\n            prev = el\n        else:\n            current = el\n            prev = el \n    return count"
      ]
    ],
    "MBPP/99": [
      [
        0.893462061882019,
        "def find_missing_ranges(nums: List[int], lower: int, upper: int) -> List[str]:\n    \"\"\"\n    Find missing ranges in a sorted integer array.\n    \n    Args:\n        nums (List[int]): Sorted integer array.\n        lower (int): Lower bound of the range.\n        upper (int): Upper bound of the range.\n    \n    Returns:\n        List[str]: List of missing ranges.\n    \"\"\"\n    result = []\n    prev = lower - 1\n\n    for i, num in enumerate(nums + [upper + 1]):\n        if num - prev >= 2:\n            result.append(f\"{prev + 1}\" + (\"\" if num - prev == 2 else \"->\") + f\"{num - 1}\")\n        prev = num\n\n    return result"
      ],
      [
        0.8934407234191895,
        "def find_missing_ranges(nums: List[int], lower: int, upper: int) -> List[str]:\n    \"\"\"\n    Find missing ranges in a sorted integer array.\n    \n    Args:\n        nums (List[int]): Sorted integer array.\n        lower (int): Lower bound of the range.\n        upper (int): Upper bound of the range.\n    \n    Returns:\n        List[str]: List of missing ranges.\n    \"\"\"\n    result = []\n    prev = lower - 1\n\n    for i, num in enumerate(nums + [upper + 1]):\n        if num - prev >= 2:\n            result.append(f\"{prev + 1}\" + (\"\" if num - prev == 2 else \"->\") + f\"{num - 1}\")\n        prev = num\n\n    return result"
      ],
      [
        0.8876484632492065,
        "def find_ranges(nums, start, end):\n    \"\"\"\n    Find the ranges of consecutive numbers in a sorted array.\n    :param nums: a sorted array of integers\n    :param start: the start of the range\n    :param end: the end of the range\n    :return: a list of strings representing the ranges\n    \"\"\"\n    result = []\n    if start < nums[0]:\n        if start + 1 == nums[0]:\n            result.append(str(start))\n        else:\n            result.append(f\"{start}->{nums[0]-1}\")\n    for i in range(len(nums) - 1):\n        if nums[i] + 1 < nums[i + 1]:\n            if nums[i] + 2 == nums[i + 1]:\n                result.append(str(nums[i] + 1))\n            else:\n                result.append(f\"{nums[i]+1}->{nums[i+1]-1}\")\n    if nums[-1] < end:\n        if nums[-1] + 1 == end:\n            result.append(str(end))\n        else:\n            result.append(f\"{nums[-1]+1}->{end}\")\n    return result"
      ],
      [
        0.8862160444259644,
        "def missing_elements(L, start, end):\n    \"\"\"\n    Find all missing elements in a sorted array.\n    \n    Args:\n        L: a sorted array of unique integers\n        start: index of the start of the array to search\n        end: index of the end of the array to search\n    \n    Returns:\n        A list of missing elements in the array.\n    \"\"\"\n    if start > end:\n        return []\n\n    if start == end:\n        if L[start] == start:\n            return []\n        else:\n            return [start]\n\n    mid = start + (end - start) // 2\n\n    if L[mid] > mid:\n        return missing_elements(L, start, mid) + missing_elements(L, mid+1, end)\n    else:\n        return missing_elements(L, mid+1, end)"
      ]
    ],
    "MBPP/100": [
      [
        0.9339838027954102,
        "def nested_common(list1, list2):\n    \"\"\"Function to extract nested common elements.\"\"\"\n    list1_flat = set(flatten(list1))\n    list2_flat = set(flatten(list2))\n    \n    common = list1_flat.intersection(list2_flat)\n    \n    return list(common)"
      ]
    ],
    "MBPP/101": [],
    "MBPP/102": [
      [
        0.916590690612793,
        "def check_string(s):\n    \"\"\"\n    Check if a string is a valid integer.\n    :param s: string\n    :return: bool\n    \"\"\"\n    if len(s) > 1000:\n        return False\n    if len(s) == 0 or s[0] == '0':\n        return False\n    for char in s:\n        if char not in '1234567890':\n            return False\n    return True"
      ]
    ],
    "MBPP/103": [
      [
        0.9071215391159058,
        "def frequency(my_list): \n    \"\"\"\n    The frequency function takes a list as an argument and returns a list of tuples where the first element is the element from the original list and the second element is the frequency of that element in the list.\n    \n    For example, if the argument is [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,\"\"\"\n    frequency_list = [] \n    for item in my_list: \n        if item not in frequency_list: \n            frequency_list.append(item) \n  \n    for i in range(0, len(frequency_list)): \n        frequency_list[i] = (frequency_list[i], my_list.count(frequency_list[i])) \n          \n    return frequency_list"
      ],
      [
        0.8928298354148865,
        "def frequency_sort(lst):\n    \"\"\"\n    Given a list of numbers, return a list where\n    each element is the count of occurrence of a number.\n    \n    >>> frequency_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,\"\"\"\n    count_dict = {}\n    for i in lst:\n        if i in count_dict:\n            count_dict[i] += 1\n        else:\n            count_dict[i] = 1\n    freq_lst = [(key, value) for key, value in count_dict.items()]\n    freq_lst = sorted(freq_lst, key= lambda x: (-x[1], x[0]))\n    return freq_lst"
      ]
    ],
    "MBPP/104": [],
    "MBPP/105": [
      [
        0.8873040080070496,
        "def int_to_int(int_list):\n    \"\"\"\n    \"\"\"\n    return int(''.join(str(e) for e in int_list))"
      ]
    ],
    "MBPP/106": [
      [
        0.9067257642745972,
        "def convert_to_float(list_):\n    \"\"\"\n    Converts all the elements in the list to float\n    \n    Args:\n        list_ (list): list of numbers\n    \n    Returns:\n        list: list of numbers converted to float\n    \"\"\"\n    return [float(i) for i in list_]"
      ]
    ],
    "MBPP/107": [],
    "MBPP/108": [],
    "MBPP/109": [
      [
        0.9183452129364014,
        "def max_product_pair(lst):\n    \"\"\"\n    Find the pair of elements in a list that have the maximum product.\n    \n    Args:\n        lst: a list of integers\n    \n    Returns:\n        A tuple of two integers that have the maximum product.\n    \"\"\"\n    max_product = float('-inf')\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i]*lst[j] > max_product:\n                max_product = lst[i]*lst[j]\n                pair = (lst[i], lst[j])\n    return pair"
      ],
      [
        0.9124895334243774,
        "def max_product_pair(lst):\n    \"\"\"\n    Find the pair of elements in a list that have the maximum product.\n    \n    Args:\n        lst (list): A list of integers.\n    \n    Returns:\n        list: A list containing the two elements with the maximum product.\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    max_product = float('-inf')\n    max_pair = None\n    for pair in combinations(lst, 2):\n         product = pair[0] * pair[1]\n         if product > max_product:\n             max_product = product\n             max_pair = pair\n    return list(max_pair)"
      ],
      [
        0.9123547077178955,
        "def max_product_pairs(lst):\n    \"\"\"\n    Given a list of integers, find all pairs of integers whose product is the maximum product of any pair.\n    \n    Args:\n        lst: list of integers\n    \n    Returns:\n        list of pairs of integers whose product is the maximum product of any pair\n    \"\"\"\n    if not lst:          # check if the list is empty\n        return []\n    #check all possible pairs\n    possible_pairs = [[lst[i], lst[j]] for i in range(len(lst)) for j in range(i+1, len(lst))]\n    #calculate product for each pair\n    products = [pair[0]*pair[1] for pair in possible_pairs]\n    #find maximum product\n    max_product = max(products) \n    #return pairs having maximum product\n    return [possible_pairs[i] for i in range(len(products)) if products[i] == max_product]"
      ]
    ],
    "MBPP/110": [
      [
        0.9269185066223145,
        "def findTriplet(arr, sum):\n    \"\"\"\n    :param arr: given array\n    :param sum: given sum\n    :return: boolean\n    \"\"\"\n    n = len(arr)\n    for i in range(0, n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if arr[i] + arr[j] + arr[k] == sum:\n                    return True\n    return False"
      ],
      [
        0.9235258102416992,
        "def find_triplet(array, target):\n    \"\"\"\n    Find a triplet in the array that sums to the target value.\n    \n    Args:\n        array (list): The input array of integers.\n        target (int): The target value to find a triplet for.\n        \n    Returns:\n        list: A list containing the indices of the triplet if found, or an empty list if not found.\n    \"\"\"\n    # Iterate through the array from index 0 to len(array) - 3\n    for i in range(len(array) - 2):\n        # Check if the sum of current element and next two elements equals the target\n        if array[i] + array[i+1] + array[i+2] == target:\n            # Return the indices of the triplet\n            return [i, i+1, i+2]\n    \n    # If no triplet is found, return an empty list\n    return []"
      ],
      [
        0.9231307506561279,
        "def find_three_numbers(array, target):\n    \"\"\"\n    Find if there is a triplet in the array whose sum is equal to the target\n    :param array: list of numbers\n    :param target: target\n    :return: True or False\n    \"\"\"\n    # using combinations function to get all the combinations of 3 numbers in the list \n    for comb in combinations(array, 3):\n        if sum(comb) == target:   # if the sum of a combination is equal to the target\n            return True   # return True and end the function\n    return False   # if no combination found, return False"
      ]
    ],
    "MBPP/111": [
      [
        0.8918217420578003,
        "def nthPoliteNumber(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    return findNthPolite(n)"
      ],
      [
        0.891810953617096,
        "def nthPoliteNumber(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    return findNthPolite(n)"
      ]
    ],
    "MBPP/112": [
      [
        0.9065374135971069,
        "def find_amicable_pairs(n):\n    \"\"\"\n    Find all amicable pairs up to n.\n    \"\"\"\n    def find_divisors(n):\n    \"\"\"\n    Find all divisors of n.\n    \"\"\"\n    divisors = []\n    for i in range(1, n+1):\n        if n % i == 0:\n            divisors.append(i)\n    return divisors\n    \"\"\"\n    amicable_pairs = []\n    for i in range(2, n+1):\n        divisors_sum = sum(find_divisors(i))\n        if i != divisors_sum and sum(find_divisors(divisors_sum)) == i:\n            if sorted([i, divisors_sum]) not in amicable_pairs:\n                amicable_pairs.append(sorted([i, divisors_sum]))\n    return amicable_pairs"
      ],
      [
        0.8983582258224487,
        "def is_amicable_pair(num1, num2):\n    \"\"\"\n    Check if two given numbers are an amicable pair\n    \"\"\"\n    s1 = 0\n    s2 = 0\n\n    for i in range(1, num1):\n        if num1 % i == 0:\n            s1 += i\n\n    for j in range(1, num2):\n        if num2 % j == 0:\n            s2 += j\n            \n    if s1 == num2 and s2 == num1 and s1 != s2:\n        return True \n    return False"
      ]
    ],
    "MBPP/113": [],
    "MBPP/114": [
      [
        0.9032430648803711,
        "def maxScore(s):\n    \"\"\"\n    :type s: str\n    :rtype: List[int]\n    \"\"\"\n    max_score = 0\n    max_substrings = 0\n    for i in range(1, len(s)):\n        left = s[:i]\n        right = s[i:]\n        #check for consecutive zeros or ones in the left substring\n        if ('000' in left) or ('111' in left):\n            continue\n        score = left.count('0') + right.count('1')\n        substrings = right.split('0')\n        substrings = sum(1 for sub in substrings if sub.startswith('1') and sub.endswith('1'))\n        if score > max_score:\n            max_score = score\n            max_substrings = substrings\n        elif score == max_score:\n            max_substrings = max(max_substrings, substrings)\n    return [max_score, max_substrings]"
      ],
      [
        0.9022431373596191,
        "def max_ones(num):\n    \"\"\"\n    Given a binary string, find the maximum number of consecutive 1's in the string.\n    \n    >>> max_ones('0111000111')\n    3\n    >>> max_ones('1111111111')\n    9\n    >>> max_ones('1001110011')\n    3\n    \"\"\"\n    count = 0\n    result = 0\n    for i in range(len(num)):\n        if num[i] == '1':\n            count += 1\n            result = max(result, count)\n        else:\n            count = 0\n    return result"
      ],
      [
        0.8979295492172241,
        "def findMaxLength(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    max_length, zeroes, ones = 0, 0, 0\n    count_map = {0: -1}\n\n    for i, num in enumerate(nums):\n        if num == 0:\n            zeroes += 1\n        else:\n            ones += 1\n\n        if zeroes - ones not in count_map:\n            count_map[zeroes - ones] = i\n        else:\n            max_length = max(max_length, i - count_map[zeroes - ones])\n\n    return max_length"
      ],
      [
        0.8978874683380127,
        "def findMaxLength(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    max_length, zeroes, ones = 0, 0, 0\n    count_map = {0: -1}\n\n    for i, num in enumerate(nums):\n        if num == 0:\n            zeroes += 1\n        else:\n            ones += 1\n\n        if zeroes - ones not in count_map:\n            count_map[zeroes - ones] = i\n        else:\n            max_length = max(max_length, i - count_map[zeroes - ones])\n\n    return max_length"
      ]
    ],
    "MBPP/115": [
      [
        0.9058184027671814,
        "def countCommonDivisors(a, b):\n    \"\"\"\n    Count the number of common divisors of two numbers.\n    \n    Args:\n        a (int): First number.\n        b (int): Second number.\n    \n    Returns:\n        int: Number of common divisors.\n    \"\"\"\n    divisors = []\n    for i in range(1, min(a, b) + 1):\n        if (a % i == 0 and b % i == 0):\n            divisors.append(i)\n    return len(divisors)"
      ],
      [
        0.9009144902229309,
        "def sum_gcd(set1, set2):\n    \"\"\"\n    Given two sets of integers, return the sum of the greatest common divisors of all pairs in the sets.\n    \n    For example, given the following sets:\n    \n    set1 = [4, 6, 8, 10]\n    set2 = [2, 4, 6, 8]\n    \n    The greatest common divisors of all pairs are:\n    \n    4 and 2 = 2\n    6 and 4 = 2\n    8 and 6 = 2\n    10 and 8 = 2\n    \n    \"\"\"\n    return math.gcd(set1[0], set1[1]) + math.gcd(set2[0], set2[1])"
      ]
    ],
    "MBPP/116": [
      [
        0.9356161952018738,
        "def multiply(a, b):\n    \"\"\"\n    Multiply two numbers without using the * operator.\n    \"\"\"\n    if b == 1:\n        return a\n    return a + multiply(a, subtract(b, 1))\n    def multiply(a, b):\n    \"\"\"\n    Multiply two numbers without using the * operator.\n    \"\"\"\n    if b == 0:\n        return 0\n    return a + multiply(a, subtract(b, 1))"
      ],
      [
        0.9333585500717163,
        "def multiply(a, b):\n    \"\"\"\n    Multiply two numbers without using the * operator.\n    \"\"\"\n    if a == 0 or b == 0:\n        return 0\n\n    sign = 1 if (a > 0 and b > 0) or (a < 0 and b < 0) else -1\n\n    a = abs(a)\n    b = abs(b)\n    result = 0\n\n    for _ in range(b):\n        result += a\n\n    return result * sign\n    def multiply(a, b):\n    \"\"\"\n    Multiply two numbers without using the *\"\"\"\n    if a == 0 or b == 0:\n        return 0\n\n    sign = 1 if (a > 0 and b > 0) or (a < 0 and b < 0) else -1\n\n    a = abs(a)\n    b = abs(b)\n    result = 0\n\n    for _ in range(b):\n        result += a\n\n    return result * sign"
      ],
      [
        0.9331914186477661,
        "def multiply_without_operator(x, y):\n    \"\"\"\n    This function multiplies two numbers without using the * operator.\n    \"\"\"\n    res = 0\n    while(y > 0):\n        res = res + x\n        y = y - 1\n    return res\n    def multiply_without_operator(x, y):\n    \"\"\"\n    This function multiplies two numbers without using the * operator.\n    \"\"\"\n    res = 0\n    while(y > 0):\n        res = res + x\n        y = y - 1\n    return res"
      ],
      [
        0.932662844657898,
        "def multiply(x, y):\n    \"\"\"\n    Multiply two numbers without using the * operator.\n    \n    Args:\n        x (int): The first number.\n        y (int): The second number.\n    \n    Returns:\n        int: The product of x and y.\n    \"\"\"\n    result = 0\n    is_negative = (x < 0) ^ (y < 0) # Check if result should be negative\n    x, y = abs(x), abs(y)\n\n    for _ in range(y):\n        result += x\n    \n    if is_negative:\n        result = -result\n    \n    return result"
      ],
      [
        0.9308221340179443,
        "def multiply(a: int, b: int) -> int:\n    \"\"\"\n    Multiply two integers without using the * operator.\n    :param a: The first integer.\n    :param b: The second integer.\n    :return: The product of a and b.\n    \"\"\"\n    result = 0\n    for _ in range(abs(b)):\n        result += a\n    result = -result if ((a < 0 and b > 0) or (a > 0 and b < 0)) else result\n    return result"
      ],
      [
        0.9305160045623779,
        "def multiply(x, y):\n    \"\"\"\n    Multiply two numbers without using the * operator.\n    \"\"\"\n    # Initialize result to 0\n    result = 0\n\n    # Handle the negative numbers case\n    if y < 0:\n        y, x = -y, -x\n\n    # Loop through the range from 0 to absolute value of y\n    for _ in range(y):\n        result += x\n\n    return result\n    def multiply(x, y):\n    \"\"\"\n    Multiply two numbers without using the * operator.\n    \"\"\"\n    # Initialize result to 0\n    result = 0\n\n    # Handle the negative numbers case\n    if y < 0:\n        y, x = -y, -x\n\n    # Loop through the range from 0 to absolute value of y\n    for _ in range(y):\n        result += x\n\n    return result"
      ],
      [
        0.9270467758178711,
        "def multiply(a, b):\n    \"\"\"\n    Multiply two numbers without using the * operator.\n    \"\"\"\n    # handle the case when either input is 0\n    if a == 0 or b == 0:\n        return 0\n\n    # handle the case when either input is negative\n    if a < 0 and b < 0:\n        a = -a\n        b = -b\n    elif a < 0:\n        a, b = b, a\n\n    result = 0\n    for i in range(a):\n        result += b\n\n    return result\n    def multiply(a,\"\"\"\n    # handle the case when either input is 0\n    if a == 0 or b == 0:\n        return 0\n\n    # handle the case when either input is negative\n    if a < 0 and b < 0:\n        a = -a\n        b = -b\n    elif a < 0:\n        a, b = b, a\n\n    result = 0\n    for i in range(a):\n        result += b\n\n    return result"
      ],
      [
        0.9269951581954956,
        "def multiply(x, y):\n    \"\"\"\n    Multiply two numbers without using the * operator.\n    \"\"\"\n    if y == 0:\n        return 0\n    if y < 0:\n        return -multiply(x, -y)\n    if x < 0:\n        return -multiply(-x, y)\n    if y % 1 != 0 or x % 1 != 0:\n        return float(x) * float(y)\n    if x > 1000000 or y > 1000000:\n        return x * y\n    \"\"\"\n    if y == 0:\n        return 0\n    if y < 0:\n        return -multiply(x, -y)\n    if x < 0:\n        return -multiply(-x, y)\n    if y % 1 != 0 or x % 1 != 0:\n        return float(x) * float(y)\n    if x > 1000000 or y > 1000000:\n        return x * y\n    return (x << int(y-1).bit_length()) + multiply(x, y - (1 << int(y-1).bit_length()))"
      ],
      [
        0.9259232878684998,
        "def multiply(x, y):\n    \"\"\"\n    Multiply two numbers without using the * operator.\n    \"\"\"\n    # Base case\n    if y == 0:\n        return 0\n\n    # Recursive case\n    else:\n        return (x + multiply(x, y-1))\n    def multiply(x, y):\n    \"\"\"\n    Multiply two numbers without using the * operator.\n    \"\"\"\n    # Base case\n    if y == 0:\n        return 0\n\n    # Recursive case\n    else:\n        return (x + multiply(x, y-1))"
      ],
      [
        0.9253469705581665,
        "def product_without_multiply_op(a, b):\n    \"\"\"\n    Write a function that takes two positive integers < 1000 and returns the\n    product. You can not use the * operator.\n    \"\"\"\n    \n    \n    \"\"\"\n    result = 0 \n    for i in range(b):\n        result += a \n    \n    return result"
      ]
    ],
    "MBPP/117": [
      [
        0.9404537677764893,
        "def get_long_words(word_list, n):\n  \"\"\"\n  Input: list of words and an integer n\n  Output: list of words that are longer than n\n  \"\"\"\n  return [w for w in word_list if len(w) > n]"
      ],
      [
        0.9211826324462891,
        "def remove_short_words(words: List[str], n: int) -> List[str]:\n    \"\"\"\n    Remove words that are shorter than n.\n    \n    :param words: a list of words\n    :param n: the minimum length of a word\n    :return: a list of words that are at least n characters long\n    \"\"\"\n    return [word for word in words if len(word) >= n]"
      ]
    ],
    "MBPP/118": [
      [
        0.9086219072341919,
        "def is_magic_square(mat):\n    \"\"\"\n    Check if a matrix is a magic square.\n    :param mat: a matrix of integers\n    :return: True if the matrix is a magic square, False otherwise\n    \"\"\"\n    sum_diag_1 = 0\n    sum_diag_2 = 0\n    sum_all = sum(mat[0]) # calculate the sum of the first row\n    # check if all the rows have the same sum\n    for row in mat:\n        if sum(row) != sum_all:\n            return False\n    # check if all the columns have the same sum\n    for col in range(3):\n        col_sum = 0\n        for row in range(3):\n            col_sum += mat[row][col]\n        if col_sum != sum_all:\n            return False\n    # check if the first diagonal has the same sum\n    for row in range(3):\n        sum_diag_1 += mat[row][row]\n    if sum_diag_1 != sum_all:\n        return False\n    # check if the second diagonal has the same sum\n    j = 2\n    for row in range(3):\n        sum_diag_2 += mat[row][j]\n        j -= 1\n    if sum_diag_2 != sum_all:\n        return False\n    # if all checks are passed, the matrix is a magic square\n    return True"
      ],
      [
        0.907010555267334,
        "def generate_magic_square(n):\n    \"\"\"\n    Generate a magic square of order n.\n    \"\"\"\n    magic_square = [[0] * n for _ in range(n)]\n\n    num = 1\n    i, j = 0, n // 2\n\n    while num <= n * n:\n        magic_square[i][j] = num\n        num += 1\n        newi, newj = (i - 1) % n, (j + 1) % n\n        if magic_square[newi][newj]:\n            i += 1\n        else:\n            i, j = newi, newj\n\n    for row in magic_square:\n        print(\" \".join(str(x).rjust(len(str(n * n))) for x in row))"
      ],
      [
        0.8958832025527954,
        "def is_magic_square(matrix):\n    \"\"\"\n    Check if a given matrix is a magic square.\n    \n    Args:\n        matrix (list of lists): The matrix to check.\n        \n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    # Get the size of the matrix\n    n = len(matrix)\n    \n    # Check if the matrix is a 3x3 matrix\n    if n != 3:\n        return False\n    \n    # Check if all elements in the matrix are distinct\n    elements = set([int(i) for row in matrix for i in row])\n    if len(elements) != n * n:\n        return False\n    \n    # Check if the sum of each row and each column is equal \n    # to the same number\n    expected_sum = sum(matrix[0])\n    row_sums = [sum(row) for row in matrix]\n    col_sums = [sum(col) for col in zip(*matrix)]\n    if not all(x == expected_sum for x in row_sums) or \\\n       not all(x == expected_sum for x in col_sums):\n        return False\n    \n    # Check if the sum of the two diagonals is the same\n    sum_diagonal1 = 0\n    sum_diagonal2 = 0\n    for i in range(n):\n        sum_diagonal1 += matrix[i][i]\n        sum_diagonal2 += matrix[i][n - i - 1]\n    if sum_diagonal1 != expected_sum or sum_diagonal2 != expected_sum:\n        return False\n    \n    return True"
      ],
      [
        0.8945983648300171,
        "def is_magic_square(matrix):\n    \"\"\"\n    Check if a matrix is a magic square.\n    \n    Args:\n        matrix (list): A matrix represented as a list of lists.\n    \n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    # We convert the matrix into a list of lists for easier manipulation\n    matrix = [m[:] for m in matrix]\n    \n    # Get the size of the square\n    size = len(matrix)\n    \n    # Get the magic constant (the sum in each row, column, or diagonal)\n    magic_constant = sum(matrix[0])\n    \n    # Check rows and columns\n    for i in range(size):\n        if sum(matrix[i]) != magic_constant or sum([row[i] for row in matrix]) != magic_constant:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(size)) != magic_constant or sum(matrix[i][size - i - 1] for i in range(size)) != magic_constant:\n        return False\n\n    # If we are here, it means that the matrix is a magic square\n    return True"
      ]
    ],
    "MBPP/119": [
      [
        0.9380597472190857,
        "def most_frequent(input_list):\n    \"\"\"\n    Find the most frequent item in a list.\n    \"\"\"\n    # Your code here\n    # Create a dictionary to store the frequency of each item\n    frequency_dict = {}\n    for item in input_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n\n    # Find the most frequent item\n    most_frequent_item = max(frequency_dict, key=frequency_dict.get)\n\n    return most_frequent_item\n    def most_frequent\"\"\"\n    # Create a dictionary to store the frequency of each item\n    frequency_dict = {}\n    for item in input_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n\n    # Find the most frequent item\n    most_frequent_item = max(frequency_dict, key=frequency_dict.get)\n\n    return most_frequent_item"
      ],
      [
        0.9357403516769409,
        "def most_frequent_item(lst):\n    \"\"\"\n    Return the most frequent item in a list.\n    \"\"\"\n    # initialize variables\n    max_count = 0\n    max_item = None\n\n    # iterate through the list\n    for i in range(len(lst)):\n        count = 0\n\n        # count occurrences of the current item in the list\n        for j in range(len(lst)):\n            if lst[j] == lst[i]:\n                count += 1\n\n        # check if the current item has higher frequency than the current maximum\n        if count > max_count:\n            max_count\"\"\"\n    max_count = 0\n    max_item = None\n\n    # iterate through the list\n    for i in range(len(lst)):\n        count = 0\n\n        # count occurrences of the current item in the list\n        for j in range(len(lst)):\n            if lst[j] == lst[i]:\n                count += 1\n\n        # check if the current item has higher frequency than the current maximum\n        if count > max_count:\n            max_count = count\n            max_item = lst[i]\n\n    return max_item"
      ],
      [
        0.9339750409126282,
        "def most_frequent(input_list):\n    \"\"\"\n    Find the most frequent item in a list.\n    \"\"\"\n    \n    \"\"\"\n    Find the most frequent item in a list.\n    \"\"\"\n    \n    \"\"\"\n    Find the most frequent item in a list.\n    \"\"\"\n    \n    \"\"\"\n    Find the most frequent item in a list.\n    \"\"\"\n    \n    \"\"\"\n    Find the most frequent item in a list.\n    \"\"\"\n    \n    \"\"\"\n    Find the most frequent item in a list.\n    \"\"\"\n    \n    \"\"\"\n    Find the most frequent item in a list.\n    \"\"\"\"\"\"\n    frequency_dict = {} \n    max_count = 0 \n    max_item = None\n\n    for item in input_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n        if frequency_dict[item] > max_count:\n            max_count = frequency_dict[item]\n            max_item = item\n    return (max_item, max_count)"
      ]
    ],
    "MBPP/120": [],
    "MBPP/121": [],
    "MBPP/122": [
      [
        0.9004349708557129,
        "def negative_stats(numbers):\n    \"\"\"\n    Return the number of negative numbers in a list and the sum of all negative numbers.\n    \n    >>> negative_stats([1, -3, 4, -2, 5])\n    (2, -5)\n    \"\"\"\n    negative_nums = [num for num in numbers if num < 0]\n    return len(negative_nums), sum(negative_nums)"
      ],
      [
        0.8972134590148926,
        "def sum_matrix(matrix):\n    \"\"\"\n    Write a function that takes a list of lists of integers and adds up the\n    negative numbers\n    \n    Args:\n       matrix(list of lists of ints): 2-d list of integers containing at least \n                                       one positive integer\n    Returns:\n       int: the sum of the negative integers in matrix.\n    \"\"\"\n    total_sum = 0\n    for row in matrix:\n        for element in row:\n            if element >= 0:\n                total_sum += element\n    return total_sum"
      ],
      [
        0.895289957523346,
        "def negative_list(numbers):\n    \"\"\"\n    Return a list of negative numbers from a list of numbers.\n    \n    >>> negative_list([1, 2, 3, -1, -2, -3])\n    [-1, -2, -3]\n    >>> negative_list([1, 2, 3])\n    []\n    \"\"\"\n    return sorted([num for num in numbers if num < 0])"
      ],
      [
        0.892196774482727,
        "def negative(int_list):\n    \"\"\"\n    Return a list of the negative integers in the input list.\n    \n    >>> negative([1, -2, 3, -4])\n    [-2, -4]\n    \"\"\"\n    return [num for num in int_list if num < 0]"
      ],
      [
        0.891535758972168,
        "def iterate_and_add(list_of_numbers):\n    \"\"\"\n    Iterates through a list of numbers and adds them together.\n    If any of the numbers are negative, the function should return None.\n    \"\"\"\n    total = 0\n    negative_count = 0\n\n    for number in list_of_numbers:\n        total += int(number)\n        if number < 0:\n            negative_count += 1\n\n    return f\"Result: {round(total)}, Negative numbers: {negative_count}\"\n    def iterate_and_add(list_of_numbers):\n    \"\"\"\n    Iterates through a list of\"\"\"\n    total = 0\n    negative_count = 0\n\n    for number in list_of_numbers:\n        total += int(number)\n        if number < 0:\n            negative_count += 1\n\n    return f\"Result: {round(total)}, Negative numbers: {negative_count}\""
      ]
    ],
    "MBPP/123": [],
    "MBPP/124": [
      [
        0.9106165170669556,
        "def isHexagonal(num):\n    \"\"\"\n    Returns True if num is a hexagonal number, False otherwise.\n    \n    >>> isHexagonal(1)\n    True\n    >>> isHexagonal(2)\n    False\n    >>> isHexagonal(17)\n    True\n    >>> isHexagonal(22)\n    False\n    >>> isHexagonal(145)\n    True\n    >>> isHexagonal(146)\n    False\n    \"\"\"\n    return (1 + math.sqrt(1 + 8 * num)) % 4 == 0"
      ],
      [
        0.8985764980316162,
        "def nth_nonagonal(n):\n  \"\"\"\n  Returns the nth nonagonal number.\n  \n  >>> nth_nonagonal(1)\n  1\n  >>> nth_nonagonal(2)\n  6\n  >>> nth_nonagonal(3)\n  18\n  >>> nth_nonagonal(4)\n  36\n  >>> nth_nonagonal(5)\n  63\n  >>> nth_nonagonal(6)\n  99\n  >>> nth_nonagonal(7)\n  144\n  >>> nth_nonagonal(8)\n  198\n  >>> nth_\"\"\"\n  return n*(7*n-5)//2"
      ]
    ],
    "MBPP/125": [
      [
        0.9269739389419556,
        "def calculate_electric_bill(kw_usage):\n  \"\"\"\n  Calculates the electric bill for a given number of kilowatt hours (kWh) used.\n  \n  Args:\n    kw_usage: The number of kWh used.\n  \n  Returns:\n    The electric bill in dollars.\n  \"\"\"\n  rate = 0.15\n  bill = kw_usage * rate\n  return bill"
      ],
      [
        0.9145617485046387,
        "def calculate_bill(rate, consumption):\n    \"\"\"\n    This function calculates the bill amount based on the rate and consumption.\n    :param rate: The rate per unit of electricity.\n    :param consumption: The total consumption of electricity in units.\n    \"\"\"\n    bill = rate * consumption\n    print(\"Your total electricity bill is Rs. {}\".format(bill))"
      ],
      [
        0.9056203365325928,
        "def calc_elec_bill(one_off, night_rate, standard_rate, total_kwh):\n    \"\"\"\n    Calculate the electricity bill for a given number of kWh.\n    \n    Args:\n        one_off (float): The one-off fee for the electricity bill.\n        night_rate (float): The night rate for the electricity bill.\n        standard_rate (float): The standard rate for the electricity bill.\n        total_kwh (float): The total number of kWh used.\n    \n    Returns:\n        float: The total electricity bill.\n    \"\"\"\n    one_off_fee = one_off\n    night_rate_fee = night_rate * total_kwh\n    standard_rate_fee = standard_rate * total_kwh\n    return one_off_fee + night_rate_fee + standard_rate_fee"
      ]
    ],
    "MBPP/126": [
      [
        0.8967102766036987,
        "def count_zeros(list):\n    \"\"\"\n    Return the number of zeros in a list.\n    >>> count_zeros([1, 2, 3, 4, 5])\n    0\n    >>> count_zeros([1, 0, 2, 0, 3])\n    2\n    \"\"\"\n    count = 0\n    for num in list:\n        if num == 0:\n            count += 1\n    return count"
      ],
      [
        0.8899387121200562,
        "def count_zeros(matrix: List[List[int]], strict_zero: bool = False) -> int:\n    \"\"\"The data input is a matrix of integers. The task at hand is to devise a function which can quantify the zero occurrences in the matrix. An optional parameter 'strict_zero' has been added to the function to increase the level of difficulty. If this parameter is turned on (strict_zero=True), the function counts only true zeros, discarding any units that could potentially qualify as false in a boolean context like '' or False. If off (strict_zero=False), these units should also be categorized as zeros.\n\n    Examples:\n    >>> count_zeros([[1, 0, 3], [4, 0, 0]])\n    3\n    >>> count_zeros([[1, '', 3], [4, '0', '-0']])\n    0\n    >>> count_zeros([[1, '', 3], [4, '0', '-0']], False)\n    3\n    \"\"\"    \n    zero_count = 0\n    for row in matrix:\n        for num in row:\n            if (strict_zero and num == 0) or (not strict_zero and not num):\n                zero_count += 1\n    return zero_count"
      ]
    ],
    "MBPP/127": [],
    "MBPP/128": [
      [
        0.9303004741668701,
        "def circumference(r):\n    '''Calculates the circumference of a circle given its radius'''\n    PI = 3.14159\n    return 2* PI * r"
      ],
      [
        0.9297464489936829,
        "def circumference_calc(radius):\n  \"\"\"\n  This function calculates the circumference of a circle.\n  \n  Args:\n    radius: The radius of the circle.\n  \n  Returns:\n    The circumference of the circle.\n  \"\"\"\n  return 2 * 3.14 * radius"
      ],
      [
        0.9201474189758301,
        "def find_circumference(radius):\n    \"\"\"\n    Finds the circumference of a circle with the given radius.\n    :param radius: The radius of the circle.\n    :return: The circumference of the circle.\n    \"\"\"\n    return 2 * math.pi * radius"
      ],
      [
        0.9187995195388794,
        "def circumference_of_circle(radius):\n    \"\"\"\n    This function calculates the circumference of a circle\n    :param radius: radius of the circle\n    :return: circumference of the circle\n    \"\"\"\n    circ = 2 * 3.14 * radius\n    return circ"
      ]
    ],
    "MBPP/129": [],
    "MBPP/130": [
      [
        0.8915826082229614,
        "def pancakeSort(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    res = []\n    n = len(arr)\n    for i in range(n, 0, -2):\n        m = arr.index(max(arr[:i]))\n        if m != i - 1:\n            arr[0:i] = arr[0:i][::-1]\n            res.append(i)\n        if i > 1:\n            arr[0:i-1] = arr[0:i-1][::-1]\n            res.append(i-1)\n    return res"
      ],
      [
        0.8914242386817932,
        "def pancakeSort(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    flips = []\n    for size in range(len(arr), 1, -1):\n        maxIdx = arr.index(max(arr[:size]))\n        flips.extend([maxIdx + 1, size])\n        arr[:maxIdx + 1] = reversed(arr[:maxIdx + 1])\n        arr[:size] = reversed(arr[:size])\n    return flips"
      ]
    ],
    "MBPP/131": [],
    "MBPP/132": [
      [
        0.9144686460494995,
        "def count_lists(lst):\n    \"\"\"Main function to count number of lists in a list\"\"\"\n    # Flatten all lists in lst and convert them into tuples\n    lst = [tuple(flatten(sublist)) for sublist in lst if isinstance(sublist, list)]\n    \n    # Get the counts of each tuple\n    return {t: lst.count(t) for t in set(lst)}"
      ],
      [
        0.8963185548782349,
        "def unique_same_elements(lists):\n    \"\"\"\n    Return the number of unique lists in the given list of lists.\n    \n    >>> unique_same_elements([[1, 2, 3], [1, 2, 3], [1, 2, 3], [4, 5, 6]])\n    2\n    >>> unique_same_elements([[1, 2, 3], [1, 2, 3], [4, 5], [6, 7, 8]])\n    3\n    >>> unique_same_elements([[1, 2, 3], [1,\"\"\"\n    unique_lists = {}\n    for lst in lists:\n        if len(set(lst)) == 1 and len(lst)!=0:\n            frozen = frozenset(lst)\n            if frozen in unique_lists:\n                unique_lists[frozen] += 1\n            else:\n                unique_lists[frozen] = 1\n    return sum(unique_lists.values())"
      ]
    ],
    "MBPP/133": [
      [
        0.9124339818954468,
        "def absolute_difference_sum(ints):\n    \"\"\"\n    Given an array of ints, find the sum of the absolute difference of all the pairs in the array.\n    For example, [2, 4, 7] -> 10\n    2 & 4: |2 - 4| = 2\n    2 & 7: |2 - 7| = 5\n    4 & 7: |4 - 7| = 3\n    10 = 2 + 5 + 3\n    \n    :param ints: list of ints\n    :return: int\n    \"\"\"\n    n = len(ints)\n    sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum += abs(ints[i] - ints[j])\n    return sum"
      ],
      [
        0.9054545164108276,
        "def sum_diff_pair(arr):\n    \"\"\"\n    Given an array of integers, find the sum of all pairs of integers whose\n    difference is the same.\n    \n    For example, given the array [1, 2, 3, 4], return 5 because there are two\n    pairs of integers in the array whose difference is 1 (3 - 2 = 1 and 4 - 3 = 1).\n    \n    The function should return 0 for an empty array.\n    \n    The function should return 0 for an array with less than two elements.\n    \n    The function should return 0\"\"\"\n    total = 0\n    for i in range(len(arr)-1):\n        for j in range(i+1, len(arr)):\n            total += abs(arr[i]-arr[j])\n    return total"
      ],
      [
        0.9045728445053101,
        "def absolute_differences_sum(arr: List[int]) -> int:\n    \"\"\"\n    Return the sum of absolute differences between adjacent elements in arr.\n    \n    Args:\n        arr (List[int]): List of integers.\n    \n    Returns:\n        int: Sum of absolute differences between adjacent elements in arr.\n    \"\"\"\n    abs_diff_sum = 0\n    for i in range(len(arr) - 1):\n        abs_diff_sum += abs(arr[i] - arr[i+1])\n    return abs_diff_sum"
      ]
    ],
    "MBPP/134": [
      [
        0.9390615224838257,
        "def max_difference(arr):\n    \"\"\"\n    Find the maximum difference between any two elements in the array.\n    :param arr: list of integers\n    :return: integer\n    \"\"\"\n    if len(arr) < 2:\n        return 0\n\n    min_value = arr[0]\n    max_value = arr[0]\n    max_diff = 0\n\n    for i in range(1, len(arr)):\n        if arr[i] < min_value:\n            min_value = arr[i]\n        elif arr[i] > max_value:\n            max_value = arr[i]\n\n        diff = max_value - min_value\n        if diff > max_diff:\n            max_diff = diff\n\n    return max_diff"
      ],
      [
        0.9377593398094177,
        "def max_difference(arr):\n    \"\"\"\n    Find the maximum difference between any two elements in the array.\n    \n    Args:\n        arr (list): The input array of integers.\n    \n    Returns:\n        int: The maximum difference between any two elements in the array.\n    \"\"\"\n    # Initialize max_difference to a negative value\n    max_difference = -float(\"inf\")\n\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            diff = abs(arr[i] - arr[j])\n            if diff > max_difference:\n                max_difference = diff\n    return max_difference"
      ],
      [
        0.9359066486358643,
        "def max_difference(arr):\n    \"\"\"\n    Find the maximum difference between any two elements in the array.\n    :param arr: list of integers\n    :return: integer\n    \"\"\"\n    if len(arr) < 2:\n        return 0\n\n    min_val = arr[0]\n    max_diff = 0\n\n    for i in range(1, len(arr)):\n        if arr[i] < min_val:\n            min_val = arr[i]\n        else:\n            diff = arr[i] - min_val\n            if diff > max_diff:\n                max_diff = diff\n\n    return max_diff"
      ],
      [
        0.9356594085693359,
        "def max_difference(arr):\n    \"\"\"\n    Find the maximum difference between any two elements in the array.\n    \n    Args:\n        arr (list): List of integers.\n    \n    Returns:\n        int: Maximum difference between any two elements in the array.\n    \"\"\"\n    max_difference = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            diff = abs(arr[i] - arr[j])\n            if diff > max_difference:\n                max_difference = diff\n    return max_difference"
      ],
      [
        0.9348507523536682,
        "def find_max_difference(arr):\n    \"\"\"\n    Find the maximum difference between any two elements in an array.\n    \n    Args:\n        arr (list): The input array.\n    \n    Returns:\n        int: The maximum difference between any two elements in the array.\n    \"\"\"\n    min_num = arr[0]\n    max_num = arr[0]\n    \n    for num in arr:\n        if num < min_num:\n            min_num = num\n        if num > max_num:\n            max_num = num\n    \n    max_diff = max_num - min_num\n    \n    return max_diff"
      ],
      [
        0.9346572756767273,
        "def find_max_difference(arr):\n    \"\"\"\n    Find the maximum difference between any two elements in an array.\n    \n    Args:\n        arr (list): The input array.\n        \n    Returns:\n        int: The maximum difference between any two elements in the array.\n    \"\"\"\n    min_value = arr[0]\n    max_value = arr[0]\n    max_diff = 0\n    \n    for num in arr:\n        if num < min_value:\n            min_value = num\n        if num > max_value:\n            max_value = num\n        \n        if max_value - min_value > max_diff:\n            max_diff = max_value - min_value\n            \n    return max_diff"
      ],
      [
        0.9342225193977356,
        "def maximum_difference(arr):\n    \"\"\"\n    Find the maximum difference between any two elements in the array.\n    \n    Args:\n        arr (list): List of integers.\n    \n    Returns:\n        int: Maximum difference between any two elements in the array.\n    \"\"\"\n    max_diff = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            diff = abs(arr[i] - arr[j])\n            if diff > max_diff:\n                max_diff = diff\n\n    return max_diff"
      ],
      [
        0.933927595615387,
        "def max_difference(arr):\n    \"\"\"\n    Find the maximum difference between any two elements in an array.\n    \n    Args:\n        arr (list): The input array.\n        \n    Returns:\n        int: The maximum difference between any two elements in the array.\n    \"\"\"\n    # Initialize the maximum difference to 0\n    max_diff = 0\n    \n    # Loop through the array \n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            # Calculate the difference between the current pair of elements\n            diff = arr[j] - arr[i]    \n                \n            # Update the maximum difference if needed\n            if diff > max_diff:\n                max_diff = diff\n                \n    # Return the maximum difference\n    return max_diff"
      ],
      [
        0.9329338073730469,
        "def findMaxDifference(arr):\n    \"\"\"\n    Find the maximum difference between two elements in an array\n    such that the larger element appears after the smaller number.\n    \"\"\"\n    max_1, max_2 = arr[0], arr[0]\n    for num in arr[1:]:\n        if num > max_1:\n            max_2 = max_1\n            max_1 = num\n        elif num > max_2:\n            max_2 = num\n\n    return max_1 - max_2\n    def findMaxDifference(arr):\n    \"\"\"\n    Find the maximum difference between two elements in\"\"\"\n    max_1, max_2 = arr[0], arr[0]\n    for num in arr[1:]:\n        if num > max_1:\n            max_2 = max_1\n            max_1 = num\n        elif num > max_2:\n            max_2 = num\n\n    return max_1, max_2"
      ]
    ],
    "MBPP/135": [
      [
        0.9359117150306702,
        "def char_total(string):\n    \"\"\"\n    Returns the sum of the ASCII values of all characters in a string.\n    \"\"\"\n    total = 0\n\n    for char in string:\n        total += ord(char)\n\n    return total"
      ]
    ],
    "MBPP/136": [
      [
        0.9175533056259155,
        "def maxTotal(triangle: List[List[int]]) -> int:\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    n = len(triangle)\n    \n    # Start from the second bottom row and work upwards\n    for i in range(n - 2, -1, -1):\n        for j in range(i + 1):\n            # For each position, choose the maximum adjacent number from the row below and add it to the current number\n            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n    \n    return triangle[0][0]"
      ],
      [
        0.9161092042922974,
        "def max_total(triangle: List[List[int]]) -> int:\n    \"\"\"\n    \"\"\"\n    size_triangle = range(len(triangle)-1, -1, -1)\n\n    for i in size_triangle:\n        for j in range(i):\n            if triangle[i][j] > triangle[i][j + 1]:\n                triangle[i - 1][j] += triangle[i][j]\n            else:\n                triangle[i - 1][j] += triangle[i][j + 1]\n\n    return triangle[0][0]"
      ],
      [
        0.9152696132659912,
        "def find_max_path_sum(test_array):\n    \"\"\"\n    Find the maximum sum of a path in a triangle.\n    :param test_array: A triangle represented as a 2D array.\n    :return: The maximum sum of a path in the triangle.\n    \"\"\"\n    rows = len(test_array)\n    cols = len(test_array[0])\n\n    # Create dp array\n    dp = [[0] * cols for _ in range(rows)]\n\n    # Initialize the top left cell of dp array\n    dp[0][0] = test_array[0][0]\n\n    # Fill the first row of dp array\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + test_array[0][j]\n\n    # Fill the first column of dp array\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + test_array[i][0]\n\n    # Fill the rest of the dp array\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + test_array[i][j]\n\n    # Return the maximum sum of a path\n    return dp[-1][-1]"
      ],
      [
        0.9039718508720398,
        "def find_max_path_sum(test_array):\n    \"\"\"\n    Find the maximum sum of non-prime numbers in a triangle.\n    \n    Args:\n        test_array (list): A triangle of numbers.\n    \n    Returns:\n        int: The maximum sum of non-prime numbers in the triangle.\n    \"\"\"\n    m = len(test_array)\n    n = len(test_array[0])\n    \n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    \n    dp[0][0] = test_array[0][0]\n    \n    for i in range(1, m):\n        if is_prime(test_array[i][0]):\n            dp[i][0] = -1\n        else:\n            dp[i][0] = dp[i-1][0] + test_array[i][0]\n    \n    for j in range(1, n):\n        if is_prime(test_array[0][j]):\n            dp[0][j] = -1\n        else:\n            dp[0][j] = dp[0][j-1] + test_array[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            if is_prime(test_array[i][j]):\n                dp[i][j] = -1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + test_array[i][j]\n    \n    return dp[m-1][n-1]"
      ]
    ],
    "MBPP/137": [
      [
        0.894497275352478,
        "def divide_list(l):\n    \"\"\"\n    \"\"\"\n    l.sort()\n    i = 0\n    j = len(l) - 1\n\n    left_sum = l[i]\n    right_sum = l[j]\n\n    while i < j:\n        if left_sum < right_sum:\n            i += 1\n            left_sum += l[i]\n        else:\n            j -= 1\n            right_sum += l[j]\n\n    return (l[:i+1], l[i+1:])"
      ]
    ],
    "MBPP/138": [
      [
        0.9313064813613892,
        "def longest_subarray(arr):\n    \"\"\"\n    Find the length of the longest subarray where the difference between adjacent elements is 1.\n    \n    Args:\n        arr (list): List of integers.\n    \n    Returns:\n        int: Length of the longest subarray.\n    \"\"\"\n    cur_length = 1\n    max_length = 1\n\n    for i in range(1, len(arr)):\n        if arr[i] - 1 == arr[i-1]:\n            cur_length += 1\n        else:\n            if cur_length > max_length:\n                max_length = cur_length\n            cur_length = 1\n\n    if cur_length > max_length:\n        max_length = cur_length\n\n    return max_length"
      ],
      [
        0.9226171970367432,
        "def find_longest_subarray(arr):\n    \"\"\"\n    Find the length of the longest subarray where the difference between adjacent elements is 1.\n    \n    Args:\n        arr: A list of integers.\n    \n    Returns:\n        The length of the longest subarray where the difference between adjacent elements is 1.\n    \"\"\"\n    maxLength = 1\n    curLength = 1\n    n = len(arr)\n    for i in range(1, n): \n        if (arr[i] > arr[i - 1]): \n            curLength += 1 \n            maxLength = max(maxLength, curLength) \n        else: \n            curLength = 1 \n    return maxLength"
      ]
    ],
    "MBPP/139": [],
    "MBPP/140": [
      [
        0.9169600009918213,
        "def is_coprime(a, b): \n    \"\"\"\n    Check if two numbers are coprimes\n    \"\"\"\n    # Calculate the gcd of given numbers \n    gcd = euclidean_algorithm(a, b) \n      \n    # return true if gcd is 1 \n    return gcd == 1\n    def is_coprime(a, b): \n    \"\"\"\n    Check if two numbers are coprimes\n    \"\"\"\n    # Calculate the gcd of given numbers \n    gcd = euclidean_algorithm(a, b) \n      \n    # return true if gcd is 1 \n    return gcd == 1"
      ],
      [
        0.9110210537910461,
        "def is_coprime(a, b):\n    \"\"\"\n    Check if two numbers are coprime.\n    :param a: first number\n    :param b: second number\n    :return: True if a and b are coprime, False otherwise\n    \"\"\"\n    return math.gcd(a, b) == 1\n    \n    def is_coprime(a, b):\n    \"\"\"\n    Check if two numbers are coprime.\n    :param a: first number\n    :param b: second number\n    :return: True if a and b are coprime, False otherwise\n    \"\"\"\n    return math.gcd(a, b) == 1"
      ],
      [
        0.9103754758834839,
        "def check_coprime(a, b):\n    \"\"\"\n    Check if two numbers are co-prime.\n    \n    Parameters:\n    a (int): First number.\n    b (int): Second number.\n    \n    Returns:\n    None\n    \"\"\"\n    if ( math.gcd(a, b) == 1):\n        print(f\"{a} and {b} are co-prime numbers.\")\n    else:\n        print(f\"{a} and {b} are not co-prime numbers.\")"
      ]
    ],
    "MBPP/141": [],
    "MBPP/142": [],
    "MBPP/143": [
      [
        0.8994060158729553,
        "def extract_elements(my_list):\n    \"\"\"\n    Extract elements from a list\n    :param my_list: list\n    :return: list\n    \"\"\"\n    new_list = []\n    for i in range(len(my_list)):\n        if i == 2 or i == 4:\n            new_list.append(my_list[i])\n    return new_list"
      ],
      [
        0.88901686668396,
        "def extract_elements(given_list):\n    \"\"\"\n    Extract elements from a given list.\n    \n    Args:\n        given_list (list): The list from which elements will be extracted.\n    \n    Returns:\n        list: A new list containing the extracted elements.\n    \"\"\"\n    return given_list[1:4]"
      ]
    ],
    "MBPP/144": [
      [
        0.8922808170318604,
        "def even_odd_change(arr):\n    \"\"\"\n    Given an array of numbers, replace all even numbers with 0 and all odd numbers with 1.\n    \n    Example:\n    \n    Input: [1, 2, 3, 4, 5, 6]\n    Output: [1, 0, 1, 0, 1, 0]\n    \n    Input: [10, 11, 12, 13, 14, 15]\n    Output: [0, 1, 0, 1, 0, 1]\n\"\"\"\n    for i in range(len(arr)):\n        if arr[i] % 2 == 0:\n            arr[i] = 0\n        else:\n            arr[i] = 1\n    return arr"
      ],
      [
        0.8873116970062256,
        "def is_even(num):\n    \"\"\"\n    Returns True if num is even, otherwise False\n    \"\"\"\n    if num % 2 == 0:\n        return True\n    else:\n        return False\n    \n    def is_even(num):\n    \"\"\"\n    Returns True if num is even, otherwise False\n    \"\"\"\n    if (num & 1) == 0:\n        return True\n    else:\n        return False"
      ]
    ],
    "MBPP/145": [
      [
        0.8953846096992493,
        "def convert_list_of_strings(lst):\n    \"\"\"\n    Converts a list of strings to a list of integers.\n    \n    Args:\n        lst (list): A list of strings.\n    \n    Returns:\n        list: A list of integers.\n    \"\"\"\n    return [convert_string(s) for s in lst]"
      ]
    ],
    "MBPP/146": [
      [
        0.9085070490837097,
        "def run_length_encoding(input_string):\n    \"\"\"\n    Run length encoding is a fast and simple method of encoding strings. The basic idea is to represent repeated successive characters as a single count and character. For example, the string \"AAAABBBCCDAA\" would be encoded as \"4A3B2C1D2A\".\n    \"\"\"\n    encoding = ''\n    i = 0\n\n    while i < len(input_string):\n        count = 1\n        while i + 1 < len(input_string) and input_string[i] == input_string[i+1]:\n            i += 1\n            \"\"\"\n    encoding = ''\n    i = 0\n\n    while i < len(input_string):\n        count = 1\n        while i + 1 < len(input_string) and input_string[i] == input_string[i+1]:\n            i += 1\n            count += 1\n        encoding += str(count) + input_string[i]\n        i += 1\n\n    return encoding"
      ],
      [
        0.9082828164100647,
        "def encodeList(list_to_encode):\n    \"\"\"\n    \"\"\"\n    if not list_to_encode:\n        return []\n    else:\n        tmp = []\n        tmp.append(list_to_encode[0])\n        tmp.append(1)\n        i = 1\n        while i < len(list_to_encode) and list_to_encode[i] == tmp[0]:\n            tmp[1] += 1\n            i += 1\n        return tmp + encodeList(list_to_encode[i:])"
      ],
      [
        0.9018041491508484,
        "def run_length_encoding(string):\n    \"\"\"\n    Run-length encoding is a fast and simple method of encoding strings. The basic idea is to represent repeated successive characters as a single count and character. For example, the string \"AAAABBBCCDAA\" would be encoded as \"4A3B2C1D2A\".\n    \"\"\"\n    # Check if the string is empty\n    if not string:\n        return \"\"\n\n    compressed_string = \"\"\n    count = 1\n\n    for i in range(1, len(string)):\n        if string[i] == string[i - 1]:\n            count += \"\"\"\n    # Check if the string is empty\n    if not string:\n        return \"\"\n\n    compressed_string = \"\"\n    count = 1\n\n    for i in range(1, len(string)):\n        if string[i] == string[i - 1]:\n            count += 1\n        else:\n            compressed_string += string[i - 1] + str(count)\n            count = 1\n\n    # Add the last character and its count to the compressed string\n    compressed_string += string[-1] + str(count)\n\n    return compressed_string"
      ]
    ],
    "MBPP/147": [
      [
        0.9071027636528015,
        "def min_steps(arr):\n    \"\"\"\n    Given an array of integers, find the minimum number of steps required to make all elements equal. In one step, you can increase the value of any element by 1.\n    \n    Example 1:\n    \n    Input:\n    N = 4\n    Arr[] = {1,1,1,1}\n    Output:\n    0\n    Explanation:\n    No need to do any step as all the elements are already equal.\n    Example 2:\n    \n    Input:\n    N = 5\n    Arr[] = {2,2,1,\"\"\"\n    min_step = 0\n    min_val = min(arr)\n    for i in range(len(arr)):\n        min_step += arr[i] - min_val \n    \n    return min_step"
      ],
      [
        0.9004983901977539,
        "def minOperations(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    dp = [0] * len(arr)\n    for i in range(k, len(arr)):\n        dp[i] = max(dp[i - k] + 1 - (arr[i] - arr[i - k]), 0)\n    return sum(dp)"
      ],
      [
        0.9004645347595215,
        "def minOperations(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    dp = [0] * len(arr)\n    for i in range(k, len(arr)):\n        dp[i] = max(dp[i - k] + 1 - (arr[i] - arr[i - k]), 0)\n    return sum(dp)"
      ],
      [
        0.8953546285629272,
        "def min_steps_to_equal_elements(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    min_elem = min(nums)\n    steps = 0\n    for num in nums:\n        steps += (num - min_elem)\n    return steps"
      ],
      [
        0.8953545093536377,
        "def min_steps_to_equal_elements(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    min_elem = min(nums)\n    steps = 0\n    for num in nums:\n        steps += (num - min_elem)\n    return steps"
      ],
      [
        0.89012610912323,
        "def minOperationsToHomogenize(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # Find the middle number (median)\n    mid = sorted(nums)[len(nums) // 2]\n    \n    # Compute and return the total absolute difference with the median.\n    return sum(abs(num - mid) for num in nums)"
      ]
    ],
    "MBPP/148": [],
    "MBPP/149": [
      [
        0.8967446088790894,
        "def egcd(a, b):\n    \"\"\"\n    Extended Euclidean algorithm.\n    Returns a tuple (g, x, y) such that g = gcd(a, b) = ax + by.\n    \"\"\"\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, x, y = egcd(b % a, a)\n        return (g, y - (b // a) * x, x)\n    def egcd(a, b):\n    \"\"\"\n    Extended Euclidean algorithm.\n    Returns a tuple (g, x, y) such that\"\"\"\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, x, y = egcd(b % a, a)\n        return (g, y - (b // a) * x, x)"
      ],
      [
        0.8938005566596985,
        "def extended_euclid(a, b):\n    \"\"\"\n    Returns a tuple (g, x, y) such that\n    g = gcd(a, b) = ax + by\n    \"\"\"\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        gcd, x, y = extended_euclid(b % a, a)\n        return (gcd, y - (b // a) * x, x)"
      ],
      [
        0.8931587934494019,
        "def solve_equation(equation):\n    \"\"\"\n    Solve the equation of the form ax + by = c\n    and return the values of x and y.\n    \"\"\"\n    coefficients = equation.split()\n    x_coeff = int(coefficients[0][:-1])\n    y_coeff = int(coefficients[2][:-1])\n    value = int(coefficients[4])\n\n    if x_coeff == 0 and y_coeff == 0:\n        raise ValueError(\"Invalid equation!\")\n    elif x_coeff == 0:\n        return [None, value // y_coeff]\n    elif y_coeff\"\"\"\n    coefficients = equation.split()\n    x_coeff = int(coefficients[0][:-1])\n    y_coeff = int(coefficients[2][:-1])\n    value = int(coefficients[4])\n\n    if x_coeff == 0 and y_coeff == 0:\n        raise ValueError(\"Invalid equation!\")\n    elif x_coeff == 0:\n        return [None, value // y_coeff]\n    elif y_coeff == 0:\n        return [value // x_coeff, None]\n\n    x = (value * y_coeff) // (x_coeff * y_coeff + y_coeff * y_coeff)\n    y = (value - x_coeff * x) // y_coeff\n    return [x, y]"
      ],
      [
        0.8920186758041382,
        "def extended_euclidean_algorithm(a, b):\n    \"\"\"\n    Extended Euclidean Algorithm\n    Returns a tuple (x, y) such that ax + by = gcd(a, b)\n    \"\"\"\n    if a == 0:\n        return (0, 1)\n    (x, y) = extended_euclidean_algorithm(b % a, a)\n    return (y - (b // a) * x, x)\n    \n    def extended_euclidean_algorithm(a, b):\n    \"\"\"\n    Extended Euclidean Algorithm\n    Returns a tuple (x, y) such that ax + by = gcd(a,\"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclidean_algorithm(b, a % b)\n    return (y, x - (a // b) * y)"
      ],
      [
        0.8913435935974121,
        "def extended_euclidean(a, b):\n    \"\"\"\n    Returns a tuple (gcd, x, y) such that a*x + b*y = gcd\n    \"\"\"\n    if a == 0:\n        return b, 0, 1\n    else:\n        gcd, x, y = extended_euclidean(b % a, a)\n        return gcd, y - (b // a) * x, x\n    def extended_euclidean(a, b):\n    \"\"\"\n    Returns a tuple (gcd, x, y) such that a*x + b*y = gcd\n    \"\"\"\n    if a == 0:\n        return b, 0, 1\n    else:\n        gcd, x, y = extended_euclidean(b % a, a)\n        return gcd, y - (b // a) * x, x"
      ],
      [
        0.8913298845291138,
        "def extended_euclidean(a, b):\n    \"\"\"\n    Returns a tuple (gcd, x, y) such that a*x + b*y = gcd\n    \"\"\"\n    if a == 0:\n        return b, 0, 1\n    else:\n        gcd, x, y = extended_euclidean(b % a, a)\n        return gcd, y - (b // a) * x, x\n    def extended_euclidean(a, b):\n    \"\"\"\n    Returns a tuple (gcd, x, y) such that a*x + b*y = gcd\n    \"\"\"\n    if a == 0:\n        return b, 0, 1\n    else:\n        gcd, x, y = extended_euclidean(b % a, a)\n        return gcd, y - (b // a) * x, x"
      ]
    ],
    "MBPP/150": [
      [
        0.9151356220245361,
        "def remove_elements(list1, list2):\n    \"\"\"\n    Remove all elements from list1 that are also in list2.\n    \n    >>> list1 = [1, 2, 3, 4, 5]\n    >>> list2 = [1, 2, 3]\n    >>> remove_elements(list1, list2)\n    [4, 5]\n    \"\"\"\n    for item in list2:\n        if item in list1:\n            list1.remove(item)\n    \n    return list1"
      ],
      [
        0.9130475521087646,
        "def remove_from_list(list1, list2):\n    \"\"\"\n    Remove all elements of list2 from list1\n    :param list1: the first list\n    :param list2: the second list\n    \"\"\"\n    for i in list2: \n        list1.remove(i) \n        \n    return list1"
      ]
    ],
    "MBPP/151": [
      [
        0.921188235282898,
        "def sum(x):\n    '''This function will sum all the numbers from 0 to x.'''\n    return (x * (x + 1)) // 2"
      ],
      [
        0.9096030592918396,
        "def sum(n):\n    \"\"\"\n    Return the sum of the first n positive integers.\n    \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return n + sum(n-1)\n    def sum(n):\n    \"\"\"\n    Return the sum of the first n positive integers.\n    \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return n + sum(n-1)"
      ],
      [
        0.9095675945281982,
        "def my_function(x):\n    \"\"\"\n    Return the sum of the first n positive integers.\n    \n    >>> my_function(100)\n    5050\n    \"\"\"\n    return (x * (x - 1)) // 2"
      ]
    ],
    "MBPP/152": [
      [
        0.93938148021698,
        "def area(n):\n \"\"\"\n Return the area of a regular polygon.\n\"\"\"\n return f(n)*g(n)"
      ],
      [
        0.9305984973907471,
        "def area(n):\n  \"\"\"\n  Return the area of a regular polygon.\n  \n  >>> area(3)\n  3.897\n  >>> area(4)\n  6.097\n  >>> area(5)\n  7.659\n  \"\"\"\n  return round(n * ((n / 4) + 0.75) / 2)"
      ],
      [
        0.927751898765564,
        "def area_polygon(n, side):\n    \"\"\"\n    Compute the area of an n-sided regular polygon.\n    \"\"\"\n    area = (n * (side ** 2)) / (4 * math.tan(math.pi / n))\n    return area"
      ],
      [
        0.9230159521102905,
        "def calculate_polygon_area(n, s):\n    \"\"\"\n    Calculate the area of a regular polygon.\n\n    :param n: Number of sides of the regular polygon\n    :param s: Length of each side of the regular polygon\n    :return: Area of the regular polygon\n    \"\"\"\n    area = (n * s ** 2) / (4 * math.tan(math.pi / n))\n    return area"
      ],
      [
        0.9167738556861877,
        "def calculatePolygonArea(n, r):\n    \"\"\"\n    Calculate the area of a regular polygon with n sides and radius r.\n\n    Args:\n        n (int): Number of sides of the polygon.\n        r (float): Radius of the polygon.\n\n    Returns:\n        float: Area of the regular polygon.\n    \"\"\"\n    angle = (2 * math.pi) / n  # Calculate the interior angle of the regular polygon\n    area = (r ** 2) * math.sin(angle) / 2  # Calculate the area using the formula\n    return area"
      ],
      [
        0.9145193099975586,
        "def surface_area_regular_polygon(n):\n    \"\"\"\n    Computes the surface area of a regular polygon with n sides, given its side length\n    \"\"\"\n    area = (n * (math.pow(n, 2) - (math.pow(n-1, 2))) / 4) * math.pow(math.pi, 2)\n    return area"
      ],
      [
        0.9135140180587769,
        "def area_of_regular_polygon(side, n_sides):\n    \"\"\"Calculate area of a given regular polygon with known side length and number of sides\n    \"\"\"\n    return (n_sides * side**2) / (4 * math.tan(math.pi/n_sides))"
      ]
    ],
    "MBPP/153": [],
    "MBPP/154": [],
    "MBPP/155": [
      [
        0.9048709869384766,
        "def find_odd_xor_pairs(lst):\n    \"\"\"\n    Find the number of odd xor pairs in a list of integers.\n    \n    Args:\n        lst (list): A list of integers.\n    \n    Returns:\n        int: The number of odd xor pairs in the list.\n    \"\"\"\n    pairs = get_pairs(lst)\n    return len(pairs), pairs"
      ]
    ],
    "MBPP/156": [
      [
        0.9279285669326782,
        "def power_of_two(n):\n    \"\"\"\n    Given an integer n, return the power of 2 that is closest to n.\n    \"\"\"\n    result = 1\n    base = 2\n\n    while n > 0:\n        if n % 2 == 1:\n            result *= base\n        base *= base\n        n //= 2\n\n    return result\n    def power_of_two(n):\n    \"\"\"\n    Given an integer n, return the power of 2 that is closest to n.\n    \"\"\"\n    result = 1\n    base = 2\n\n    while n > 0:\n        if n % 2 == 1:\n            result *= base\n        base *= base\n        n //= 2\n\n    return result"
      ],
      [
        0.9278101921081543,
        "def maxPowerOfTwo(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    p = 0\n    while ((1 << (p + 1)) <= n): p += 1\n    return p"
      ]
    ],
    "MBPP/157": [
      [
        0.9252846240997314,
        "def frequency(arr, num):\n    \"\"\"\n    Return the frequency of num in the given array.\n    \"\"\"\n    return arr.count(num)\n    \n    def frequency(arr, num):\n    \"\"\"\n    Return the frequency of num in the given array.\n    \"\"\"\n    return arr.count(num)"
      ]
    ],
    "MBPP/158": [
      [
        0.9297803044319153,
        "def pell(n):\n    \"\"\"\n    Return the nth term of the Pell sequence.\n    \"\"\"\n    # create a dictionary to store computed values\n    pell_dict = {0: 0, 1: 1}\n    \"\"\"\n    # check if the value is already computed\n    if n not in pell_dict:\n        # calculate the nth term of the sequence\n        pell_dict[n] = 2 * pell(n-1) + pell(n-2)\n    return pell_dict[n]"
      ],
      [
        0.8995983600616455,
        "def pell_series(n):\n    \"\"\"\n    Pell series\n    \n    \"\"\"\n    a, b = 0, 1\n    for _ in range(n):\n        print(a)\n        a, b = b, 2*b + a"
      ]
    ],
    "MBPP/159": [
      [
        0.9024869799613953,
        "def sum_between_indices(arr, start, end):\n    \"\"\"\n    Given an array of integers between indices start and end, inclusive, return the sum of the elements in the array between those indices.\n    \n    Args:\n        arr (list): The array of integers.\n        start (int): The start index.\n        end (int): The end index.\n    \n    Returns:\n        int: The sum of the elements between start and end indices.\n    \"\"\"\n    # Set the initial sum to 0\n    sum = 0 \n    # Traverse the array\n    for i in range(start, end + 1):\n        # Add each element between start and end indices to sum\n        sum += arr[i]\n    \n    return sum"
      ]
    ],
    "MBPP/160": [
      [
        0.8840959072113037,
        "def number_of_sides():\n    \"\"\"\n    Returns the number of sides on a regular polygon.\n    \"\"\"\n    return 6\n    \n    def side_length(n, s):\n    \"\"\"\n    Returns the length of one side of a regular polygon.\n    \"\"\"\n    return s / n\n    \n    def area(n, s):\n    \"\"\"\n    Returns the area of a regular polygon.\n    \"\"\"\n    return (n * s**2) / (4 * math.tan(math.pi / n))\n    \n    def perimeter(n, s):\n    \"\"\"\n    Returns the perimeter\"\"\"\n    result = 1\n    for i in range(2021, 2067):\n        result *= i\n    return result"
      ]
    ],
    "MBPP/161": [],
    "MBPP/162": [],
    "MBPP/163": [
      [
        0.871941089630127,
        "def group_strings(lst):\n    \"\"\"\n    Write a function that takes a list of strings as an argument and returns a dictionary.\n    The keys of the dictionary should be the length of the strings in the list.\n    The values should be lists of strings of that length.\n    \n    >>> group_strings([\"a\", \"aa\", \"aaa\", \"aaaa\"])\n    {1: [\"a\"], 2: [\"aa\"], 3: [\"aaa\"], 4: [\"aaaa\"]}\n    \"\"\"\n    return {len(word): [i for i in lst if len(i) == len(word)] for word in lst}"
      ]
    ],
    "MBPP/164": [
      [
        0.9239267110824585,
        "def parentheses_validator(string):\n    \"\"\"\n    Write a function that takes a string of parentheses, and determines if the order of the parentheses is valid. The function should return true if the string is valid, and false if it's invalid.\n    \n    Examples\n    \"()\" => returns true\n    \")(()))\" => returns false\n    \"(\" => returns false\n    \"((()))\" => returns true\n    \"\"\"\n    c = 0\n    for i in string:\n        if i == '(':\n            c += 1\n        if i == ')': \n            c -= 1\n        if c < 0:\n            return False\n    return c == 0"
      ],
      [
        0.9238661527633667,
        "def check_parens(string):\n    \"\"\"Check whether the parentheses are valid. \"\"\"\n    # Keep a count of how many left and right brackets\n    left_count = 0\n    right_count = 0\n    \n    # Iterate through the string \n    for char in string:\n        if char == '(':\n            left_count += 1\n        elif char == ')':\n            right_count += 1\n            \n        # If the right count is ever greater than the left, return False \n        if right_count > left_count:\n            return False\n    \n    # If both counts are equal, the parentheses are valid \n    if left_count == right_count:\n        return True\n    \n    # Otherwise, the parentheses are invalid \n    return False"
      ]
    ],
    "MBPP/165": [
      [
        0.915186882019043,
        "def calculate_perimeter(side1, side2, side3):\n    \"\"\"\n    Calculate the perimeter of a triangle.\n    \n    Parameters:\n    side1 (float): Length of the first side.\n    side2 (float): Length of the second side.\n    side3 (float): Length of the third side.\n    \n    Returns:\n    float: The perimeter of the triangle.\n    \"\"\"\n    perimeter = side1 + side2 + side3\n    return perimeter"
      ],
      [
        0.9120898246765137,
        "def calc_perimeter(a, b, c):\n    \"\"\"\n    Calculate the perimeter of a triangle.\n    :param a: side a\n    :param b: side b\n    :param c: side c\n    :return: perimeter\n    \"\"\"\n    return a + b + c"
      ],
      [
        0.9070957899093628,
        "def calculate_perimeter(side1, side2, side3):\n    \"\"\"\n    Calculate the perimeter of a triangle given the lengths of its sides.\n    \n    Parameters:\n    side1 (float): Length of the first side of the triangle.\n    side2 (float): Length of the second side of the triangle.\n    side3 (float): Length of the third side of the triangle.\n    \n    Returns:\n    float: The perimeter of the triangle.\n    \"\"\"\n    # Calculate the perimeter\n    perimeter = side1 + side2 + side3\n    \n    # Round the perimeter to two decimal places\n    perimeter = round(perimeter, 2)\n    \n    return perimeter"
      ]
    ],
    "MBPP/166": [
      [
        0.8844113945960999,
        "def find_LCM(first_num, second_num):\n    \"\"\"\n    This function takes two numbers and returns the LCM.\n    \"\"\"\n    maximum = max(first_num, second_num)\n    lcm = maximum\n\n    while True:\n        if lcm % first_num == 0 and lcm % second_num == 0:\n            break\n        lcm += maximum\n\n    return lcm"
      ],
      [
        0.8841421604156494,
        "def find_lcm(num1, num2):\n    \"\"\"\n    Find the least common multiple of two numbers.\n    \"\"\"\n    if num1 == 0 or num2 == 0:\n        return 0\n    else:\n        return int((num1 * num2) / find_gcd(num1, num2))\n    def find_lcm(num1, num2):\n    \"\"\"\n    Find the least common multiple of two numbers.\n    \"\"\"\n    if num1 == 0 or num2 == 0:\n        return 0\n    else:\n        return int((num1 * num2) / find_gcd(num1, num2))"
      ]
    ],
    "MBPP/167": [
      [
        0.9018117189407349,
        "def search_string(search_string, list_of_strings):\n    \"\"\"\n    Return True if any string in the list contains `search_string` as a substring.\n    Return False otherwise.\n    \"\"\"\n    for string in list_of_strings:\n        if search_string in string:\n            return True\n    return False\n    \n    def search_string(search_string, list_of_strings):\n    \"\"\"\n    Return True if any string in the list contains `search_string` as a substring.\n    Return False otherwise.\n    \"\"\"\n    for string in list_of_strings:\n        if string == search_string:\n            return True\n    return False"
      ]
    ],
    "MBPP/168": [
      [
        0.879241943359375,
        "def is_magic_number(num):\n    \"\"\"\n    \"\"\"\n    num = str(num)\n    digits = [int(x) for x in num]\n    return sum(digits) == 1"
      ]
    ],
    "MBPP/169": [],
    "MBPP/170": [
      [
        0.926497220993042,
        "def longest_common_prefix(strings):\n    \"\"\"\n    Find the longest common prefix among a set of strings.\n    \n    Args:\n        strings (list): A list of strings.\n    \n    Returns:\n        str: The longest common prefix among the given strings.\n    \"\"\"\n    if not strings:\n        return \"\"  # Return empty string if the set of strings is empty\n\n    # Find the minimum length of the strings\n    min_length = min(len(string) for string in strings)\n    \n    # Iterate through each character in the minimum length of the strings\n    for i in range(min_length):\n        # Check if the character at position i is the same in all strings\n        if any(string[i] != strings[0][i] for string in strings):\n            return strings[0][:i]  # Return the prefix if characters differ\n    \n    return strings[0][:min_length]  # Return the minimum length prefix"
      ],
      [
        0.925122857093811,
        "def longest_common_prefix(strings):\n    \"\"\"\n    Find the longest common prefix among an array of strings.\n    \n    :type strs: List[str]\n    :rtype: str\n    \"\"\"\n    if not strings:\n        return \"\"\n\n    prefix = strings[0]\n    for i in range(1, len(strings)):\n        while strings[i].find(prefix) != 0:\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    \n    return prefix"
      ]
    ],
    "MBPP/171": [],
    "MBPP/172": [
      [
        0.9343194365501404,
        "def count_pairs_with_difference_k(nums, k):\n    \"\"\"\n    Count pairs in a list of numbers with a given difference k.\n    :param nums: List of integers\n    :param k: Difference between the numbers\n    :return: Count of pairs with difference k\n    \"\"\"\n    freq_map = {}\n    count = 0\n\n    for num in nums:\n        count += freq_map.get(num - k, 0) + freq_map.get(num + k, 0)\n        freq_map[num] = freq_map.get(num, 0) + 1\n\n    return count"
      ],
      [
        0.9342989921569824,
        "def count_pairs_with_difference_k(nums, k):\n    \"\"\"\n    Count pairs in a list of numbers with a given difference k.\n    :param nums: List of integers\n    :param k: Difference between the numbers\n    :return: Count of pairs with difference k\n    \"\"\"\n    freq_map = {}\n    count = 0\n\n    for num in nums:\n        count += freq_map.get(num - k, 0) + freq_map.get(num + k, 0)\n        freq_map[num] = freq_map.get(num, 0) + 1\n\n    return count"
      ]
    ],
    "MBPP/173": [
      [
        0.9292531609535217,
        "def numbers_greater_than(arr, x):\n  \"\"\"\n  Return a list of all numbers greater than x\n  \"\"\"\n  return [num for num in arr if num > x]\n    def numbers_greater_than(arr, x):\n  \"\"\"\n  Return a list of all numbers greater than x\n  \"\"\"\n  return [num for num in arr if num > x]"
      ],
      [
        0.9257360100746155,
        "def filter_greater_than(arr, num):\n    \"\"\"\n    Return a new array with only the elements from the original array that are greater than the given number.\n    \"\"\"\n    return [x for x in arr if x > num]\n    def filter_greater_than(arr, num):\n    \"\"\"\n    Return a new array with only the elements from the original array that are greater than the given number.\n    \"\"\"\n    return [x for x in arr if x > num]"
      ],
      [
        0.9236041903495789,
        "def filter_greater_than(lst, num):\n    \"\"\"\n    Return a new list containing all numbers from the original list that are greater than the given number.\n    :param lst: list of numbers\n    :param num: number\n    :return: list of numbers\n    \"\"\"\n    return [n for n in lst if n > num]"
      ],
      [
        0.9170977473258972,
        "def greater_than_target(numbers, target):\n    \"\"\"\n    Given a list of numbers and a target number, return all values in the list that are greater than the target.\n    Args:\n       param1(list): list of numbers\n       param2(int): target number\n    Returns:\n       list of numbers that are greater than the target\n    \"\"\"\n    result = []\n    for num in numbers:\n        if num > target:\n            result.append(num)\n    return result"
      ],
      [
        0.9149011969566345,
        "def get_numbers_greater_than(nums, n):\n    \"\"\"\n    Return a list of numbers greater than n.\n    \n    >>> get_numbers_greater_than([1, 2, 3], 2)\n    [3]\n    \"\"\"\n    return [num for num in nums if num > n]"
      ]
    ],
    "MBPP/174": [],
    "MBPP/175": [],
    "MBPP/176": [
      [
        0.9321498274803162,
        "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    Find the length of longest common subsequence (LCS) of two given sequences.\n    str1, str2: input strings\n    return: length of LCS\n    \"\"\"\n    m = len(str1)\n    n = len(str2)\n    C = [[0] * (n + 1) for i in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i-1] == str2[j-1]:\n                C[i][j] = C[i-1][j-1] + 1\n            else:\n                C[i][j] = max(C[i-1][j], C[i][j-1])\n    return C[m][n]"
      ]
    ],
    "MBPP/177": [],
    "MBPP/178": [
      [
        0.9340323209762573,
        "def find_first_missing_positive(arr):\n    \"\"\"\n    Finds the first missing positive number in an unsorted array\n    \"\"\"\n    # Sort the array\n    arr.sort()\n\n    # Iterate over the array\n    for i in range(len(arr) - 1):\n        # if the difference between the current and the next number is > 1\n        # then the missing positive is the current number plus 1\n        if (arr[i + 1] - arr[i]) > 1:\n            return arr[i] + 1\n    \n    # Return the last element + 1 if all numbers are continuous\n    return arr[-1] + 1"
      ]
    ],
    "MBPP/179": [],
    "MBPP/180": [
      [
        0.904896080493927,
        "def check_days(month, year):\n    \"\"\"\n    Check if a month has 30 days.\n    \n    Args:\n        month (int): The month number (1-12).\n        year (int): The year.\n    \n    Returns:\n        bool: True if the month has 30 days, False otherwise.\n    \"\"\"\n    thirty_days_months = [4, 6, 9, 11]\n    if month in thirty_days_months:\n        return True\n    elif month == 2:\n        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):\n            return False  # February has 29 days in a leap year\n        else:\n            return True  # February has 28 days in a non-leap year\n    else:\n        return False  # Months not listed have 31 days"
      ],
      [
        0.8951505422592163,
        "def num_of_days(month): \n    \"\"\"\n    Takes a month name as input and returns the number of days in that month.\n    \n    Parameters:\n    month (str): The name of the month.\n    \n    Returns:\n    str: The number of days in the month.\n    \"\"\"\n    if month == \"January\" or month == \"March\" or month == \"May\" or month == \"July\" or month == \"August\" or month == \"October\" or month == \"December\": \n        return \"31 days\"\n    elif month == \"April\" or month == \"June\" or month == \"September\" or month == \"November\":\n        return \"30 days\"\n    elif month == \"February\":\n        return \"28 or 29 days\"\n    else:\n        return \"Invalid input\""
      ]
    ],
    "MBPP/181": [
      [
        0.908181369304657,
        "def has_number(password):\n    \"\"\"\n    Check if a password contains a number\n    :param password: str\n    :return: bool\n    \"\"\"\n    return any(letter.isdigit() for letter in password)"
      ]
    ],
    "MBPP/182": [
      [
        0.9072756767272949,
        "def removeDupes(input_tuple):\n\"\"\"\n    Removes duplicates from a tuple.\n\n    Args:\n        input_tuple (tuple): The input tuple.\n\n    Returns:\n        tuple: The tuple with duplicates removed.\n    \"\"\"\n\n    # Convert tuple to set to remove duplicates\n    result_set = set(input_tuple)\n\n    # Convert set back to tuple\n    result_tuple = tuple(result_set)\n\n    return result_tuple"
      ]
    ],
    "MBPP/183": [
      [
        0.9284827709197998,
        "def convert_to_octal(num):\n    \"\"\"\n    This function converts a decimal number to octal\n    \"\"\"\n    oct_num = oct(num)\n    print(\"The octal form of {} is {}\".format(num, oct_num))\n    \n    def convert_to_octal(num):\n    \"\"\"\n    This function converts a decimal number to octal\n    \"\"\"\n    oct_num = oct(num)\n    print(\"The octal form of {} is {}\".format(num, oct_num))"
      ],
      [
        0.9217933416366577,
        "def octal_to_decimal(octal):\n    \"\"\"\n    Convert octal number to decimal\n    \"\"\"\n    decimal = 0\n    base = 1\n\n    while (octal):\n        last_digit = octal % 10\n        octal = int(octal / 10)\n\n        decimal += last_digit * base\n        base = base * 8\n\n    return decimal\n    def octal_to_decimal(octal):\n    \"\"\"\n    Convert octal number to decimal\n    \"\"\"\n    decimal = 0\n    base = 1\n\n    while (octal):\n        last_digit = octal % 10\n        octal = int(octal / 10)\n\n        decimal += last_digit * base\n        base = base * 8\n\n    return decimal"
      ]
    ],
    "MBPP/184": [
      [
        0.9220010042190552,
        "def find_index(arr, val):\n    \"\"\"\n    Given a sorted array, return the index of val in the array.\n    If val is not present in the array, return -1.\n    \"\"\"\n    # TODO: Write your code here\n    # return index\n    \"\"\"\n    index = 0\n    found = False\n    for i, num in enumerate(arr):\n        if num == val:\n            index += i\n            found = True\n    return index if found else -1"
      ],
      [
        0.9219817519187927,
        "def find_index(arr, val):\n    \"\"\"\n    Given a sorted array, return the index of val in the array.\n    If val is not present in the array, return -1.\n    \"\"\"\n    # TODO: Write your code here\n    # return index\n    \"\"\"\n    index = 0\n    found = False\n    for i, num in enumerate(arr):\n        if num == val:\n            index += i\n            found = True\n    return index if found else -1"
      ],
      [
        0.9146754741668701,
        "def find_position(arr, num):\n    \"\"\"\n    Find the position of num in the sorted array\n    :param arr: sorted array of integers\n    :param num: integer to be found\n    :return: position of num in the array\n    \"\"\"\n    return linear_search(arr, num)\n    \n    def linear_search(arr, num):\n    \"\"\"\n    Find the position of num in the sorted array\n    :param arr: sorted array of integers\n    :param num: integer to be found\n    :return: position of num in the array\n    \"\"\"\n    for i in range(len(arr)):\"\"\"\n    return binary_search(arr, num, 0, len(arr) - 1)"
      ]
    ],
    "MBPP/185": [],
    "MBPP/186": [],
    "MBPP/187": [
      [
        0.9252520799636841,
        "def largest_inscribed_triangle(radius, h=0, k=0, a=None, b=None):\n    \"\"\"\n    Find the largest inscribed triangle in a circle or ellipse.\n    \n    Parameters\n    ----------\n    radius : float\n        The radius of the circle or ellipse.\n    h : float, optional\n        The x-coordinate of the center of the circle or ellipse.\n    k : float, optional\n        The y-coordinate of the center of the circle or ellipse.\n    a : float, optional\n        The length of the major axis of the ellipse.\n    b : float, optional\n        The length of the minor axis of the ellipse.\n        \n    Returns\n    -------\n    \"\"\"\n    if (not isinstance(radius, (int, float))) or (radius <= 0):\n        return \"Error: Radius must be a positive number.\"\n    if (not isinstance(h, (int, float))) or (not isinstance(k, (int, float))):\n        return \"Error: Center coordinates must be numbers.\"\n    if a is not None and b is not None:\n        if (not isinstance(a, (int, float))) or (not isinstance(b, (int, float))):\n            return \"Error: Major and minor axes must be numbers.\"\n        if a <= 0 or b <= 0:\n            return \"Error: Lengths of axes must be positive numbers.\"\n        # For ellipse, triangle is a right isosceles triangle with hypotenuse as major axis\n        # Area of triangle = 1/2 * base * height\n        # Base and height will be equal in this case (b=b/(2^0.5) because it's side of major axis's isosceles traingle)\n        area = 0.5 * a * a * b/(2**0.5) * b/(2**0.5);\n        vertices = [(h,h), (k-a/(2**0.5), k-b/(2**0.5)), (k+a/(2**0.5), k+b/(2**0.5))]\n    else:\n        # For circle, triangle is a right isosceles triangle with hypotenuse as diameter\n        # Area of triangle = 1/2 * base * height\n        area = 0.5 * radius * radius\n        vertices = [(h-radius, k), (h+radius, k), (h, k+radius)]\n    return area, vertices"
      ],
      [
        0.8941512107849121,
        "def get_triangle(radius):\n    \"\"\"\n    Compute the area and perimeter of the largest inscribed triangle in a semicircle.\n    \n    Parameters\n    ----------\n    radius : float\n        The radius of the semicircle.\n        \n    Returns\n    -------\n    area : float\n        The area of the largest inscribed triangle.\n    a : tuple\n        The coordinates of the first vertex of the triangle.\n    b : tuple\n        The coordinates of the second vertex of the triangle.\n    c : tuple\n        The coordinates of the third vertex of the triangle.\n    perimeter : float\n        The perimeter of the largest inscribed triangle.\"\"\"\n    # The largest inscribed triangle in a semicircle is equilateral triangle.\n    # The length of the triangle's side equals the semicircle's diameter.\n\n    # Hence, the coordinates of the vertices of the triangle are:\n    a = (-radius, 0)\n    b = (radius, 0)\n    c = (0, radius)\n\n    # The area of an equilateral triangle is computed using the formula: (s^2 * sqrt(3)) / 4\n    # where s is the side length of the triangle. \n    # The side length of our triangle is twice the radius (which is the diameter of the semicircle).\n    area = ((2*radius)**2 * math.sqrt(3)) / 4\n    \n    # The perimeter of an equilateral triangle is 3 times its side.\n    # The side length of our triangle is twice the radius (which is the diameter of the semicircle).\n    perimeter = 3 * (2*radius)\n\n    return area, a, b, c, perimeter"
      ],
      [
        0.8918155431747437,
        "def get_triangle(radius):\n    \"\"\"\n    Return the area, coordinates of the vertices, and perimeter of the largest inscribed triangle in a semicircle.\n    \n    Args:\n        radius (float): radius of the semicircle\n    \n    Returns:\n        tuple: (area, a, b, c, perimeter)\n    \"\"\"\n    # The largest inscribed triangle in a semicircle is equilateral_triangle.\n    # The length of the triangle's_side_equals the semicircle's diameter.\n\n    # Hence, the coordinates of the vertices of the triangle are:\n    a = (-radius, 0)\n    b = (radius, 0)\n    c = (0, radius)\n\n    # The area of an equilateral triangle is computed using the formula: (s^2 * sqrt(3)) / 4\n    # where s is the side length of the triangle. \n    # The side length of our_triangle is twice the radius (which is the diameter_of the semicircle).\n    area = ((2*radius)**2 * math.sqrt(3)) / 4\n\n    # The perimeter of an equilateral triangle is 3 times its side.\n    # The side length of our triangle is twice the radius (which is the diameter of the semicircle).\n    perimeter = 3 * (2*radius)\n\n    return area, a, b, c, perimeter"
      ],
      [
        0.8910485506057739,
        "def max_triangle_semicircle(h=0, k=0, r=1):\n    \"\"\"\n    Find the area and vertices of the largest triangle that can be inscribed in a semicircle.\n    \n    Parameters\n    ----------\n    h : float\n        The x-coordinate of the center of the semicircle.\n    k : float\n        The y-coordinate of the center of the semicircle.\n    r : float\n        The radius of the semicircle.\n        \n    Returns\n    -------\n    area : float\n        The area of the largest triangle that can be inscribed in the semicircle.\n    vertices : list\n        The vertices of the largest triangle that can be inscribed in\"\"\"\n    if r <= 0:\n        return None, None\n        \n    area = r**2\n    vertices = [(h-r, k), (h+r, k), (h, k+r)]\n    return area, vertices"
      ],
      [
        0.8882154822349548,
        "def max_triangle_semicircle(r):\n\"\"\"\n    Find the maximum area of a triangle inscribed in a semicircle of radius r.\n    \n    Parameters\n    ----------\n    r : float\n        The radius of the semicircle.\n    \n    Returns\n    -------\n    area : float\n        The maximum area of the triangle.\n    vertices : list\n        The coordinates of the vertices of the triangle.\n    \"\"\"\n\n    # The coordinates are (-r, 0), (r, 0) and (0, r)\n    vertices = [(-r, 0), (r, 0), (0, r)]\n\n    # The area is (1/2) * Base * Height. For maximum area, Base = Diameter = 2*r and Height = r.\n    area = 0.5 * (2*r) * r\n\n    return area, vertices"
      ]
    ],
    "MBPP/188": [
      [
        0.9284058213233948,
        "def maxPowerOfTwo(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    p = 0\n    while ((1 << (p + 1)) <= n): p += 1\n    return p"
      ],
      [
        0.913205623626709,
        "def power_of_two(n):\n    \"\"\"\n    Given an integer n, return the power of 2 that is closest to n.\n    \"\"\"\n    result = 1\n    base = 2\n\n    while n > 0:\n        if n % 2 == 1:\n            result *= base\n        base *= base\n        n //= 2\n\n    return result\n    def power_of_two(n):\n    \"\"\"\n    Given an integer n, return the power of 2 that is closest to n.\n    \"\"\"\n    result = 1\n    base = 2\n\n    while n > 0:\n        if n % 2 == 1:\n            result *= base\n        base *= base\n        n //= 2\n\n    return result"
      ],
      [
        0.9131944179534912,
        "def power_of_two(n):\n    \"\"\"\n    Given an integer n, return the power of 2 that is closest to n.\n    \"\"\"\n    result = 1\n    base = 2\n\n    while n > 0:\n        if n % 2 == 1:\n            result *= base\n        base *= base\n        n //= 2\n\n    return result\n    def power_of_two(n):\n    \"\"\"\n    Given an integer n, return the power of 2 that is closest to n.\n    \"\"\"\n    result = 1\n    base = 2\n\n    while n > 0:\n        if n % 2 == 1:\n            result *= base\n        base *= base\n        n //= 2\n\n    return result"
      ]
    ],
    "MBPP/189": [
      [
        0.9048170447349548,
        "def find_max_val_indices(lst):\n    \"\"\"\n    Find the indices of the maximum value in a list.\n    \n    Args:\n        lst (list): A list of integers.\n    \n    Returns:\n        list: A list of indices of the maximum value.\n    \"\"\"\n    max_val = max(lst)\n    indices = [i for i, val in enumerate(lst) if val == max_val]\n    print(\"The greatest number is {} and its indices are {}\".format(max_val, indices))"
      ],
      [
        0.9006492495536804,
        "def find_max(lst):\n    \"\"\"\n    Find the maximum number in a list and its index(es).\n    \n    Args:\n        lst (list): A list of numbers.\n    \n    Returns:\n        tuple: A tuple containing the maximum number and a list of indices where the maximum number occurs.\n    \"\"\"\n    max_num = lst[0]\n    max_index = [0]  # Consider first value as a potential max value\n    for i in range(1, len(lst)):\n        if lst[i] > max_num:\n            max_num = lst[i]\n            max_index = [i]    # If the new number is greater, update max_num and reinitialize max_index\n        elif lst[i] == max_num:\n            max_index.append(i)   # If the number is equal to max_num, just append its index to max_index\n    return max_num, max_index"
      ]
    ],
    "MBPP/190": [
      [
        0.9241238236427307,
        "def is_same(my_list):\n  \"\"\"\n  Checks if all elements in a list are the same.\n  Args:\n    my_list: a list of elements\n  Returns:\n    True if all elements are the same, False otherwise\n  \"\"\"\n  for i in range(len(my_list)):\n    for j in range(i + 1, len(my_list)):\n      if my_list[i] != my_list[j]:\n        return False\n  return True"
      ],
      [
        0.9143980741500854,
        "def check_list_elements(list_of_elements):\n    \"\"\"\n    Check if all elements in a list are the same\n    :param list_of_elements: list of elements\n    :return: True if all elements are the same, False otherwise\n    \"\"\"\n    if len(set(list_of_elements)) == 1:\n        return True\n    else:\n        return False"
      ]
    ],
    "MBPP/191": [
      [
        0.9392486810684204,
        "def remove_even(string):\n    \"\"\"\n    Remove all even occuring characters from a string\n    \"\"\"\n    result = \"\"\n    count = {}\n\n    for char in string:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n\n    for ch, val in count.items():\n        if val % 2 != 0:\n            result += ch\n    return result\n    def remove_even(string):\n    \"\"\"\n    Remove all even occuring characters from a string\n    \"\"\"\n    result = \"\"\n    count = {}\n\n    for char in string:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n\n    for ch, val in count.items():\n        if val % 2 != 0:\n            result += ch\n    return result"
      ],
      [
        0.9352778196334839,
        "def remove_odd_index_characters(string):\n    \"\"\"\n    Remove characters which have odd index values in the given string\n    \"\"\"\n    result = \"\"\n    for i in range(len(string)):\n        if i % 2 == 0:\n            result += string[i]\n    return result\n    def remove_odd_index_characters(string):\n    \"\"\"\n    Remove characters which have odd index values in the given string\n    \"\"\"\n    result = \"\"\n    for i in range(len(string)):\n        if i % 2 == 0:\n            result += string[i]\n    return result"
      ],
      [
        0.9331322908401489,
        "def remove_odd_index_char(string):\n    \"\"\"\n    Remove the characters of odd index in a given string\n    \"\"\"\n    result = \"\"\n    for i in range(len(string)):\n        if i % 2 == 0:\n            result = result + string[i]\n    return result"
      ],
      [
        0.9193971157073975,
        "def remove_every_other_char(str):\n    \"\"\"\n    Given a string, return a new string made of every other char starting with the first, so \"Hello\" yields \"Hlo\".\n    \"\"\"\n    result = \"\"\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result += str[i]\n    return result"
      ]
    ],
    "MBPP/192": [
      [
        0.9241868257522583,
        "def hamming_distance(x, y):\n    \"\"\"\n    Calculate the Hamming distance between two integers x and y.\n    The Hamming distance between two integers is the number of positions\n    at which the corresponding bits are different.\n    \n    :param x: integer\n    :param y: integer\n    :return: integer\n    \"\"\"\n    xor = x ^ y  # XOR operation\n    count = 0\n    while xor:   # loop until xor equals zero\n        count += xor & 1  # count the last bit if it is 1\n        xor >>= 1  # right shift by 1 bit\n    return count"
      ],
      [
        0.9238351583480835,
        "def hamming_distance(x, y):\n    \"\"\"\n    Calculate the Hamming distance between two integers.\n    The Hamming distance between two integers is the number of positions\n    at which the corresponding bits are different.\n    :param x: int\n    :param y: int\n    :return: int\n    \"\"\"\n    return bin(x ^ y).count('1')"
      ],
      [
        0.9094763994216919,
        "def hammingDistance(x: int, y: int) -> int:\n    \"\"\"\n    :type x: int\n    :type y: int\n    :rtype: int\n    \"\"\"\n    xorResult = x ^ y\n    dist = 0\n    while xorResult:\n        dist += xorResult & 1\n        xorResult >>= 1\n    return dist"
      ]
    ],
    "MBPP/193": [],
    "MBPP/194": [
      [
        0.8908635377883911,
        "def count_inversions(arr):\n  \"\"\"\n  Return the number of inversions in the given array.\n  >>> count_inversions([2, 4, 1, 3, 5])\n  3\n  \"\"\"\n  inv_count = 0\n  for i in range(len(arr)):\n    for j in range(i + 1, len(arr)):\n      if arr[i] > arr[j]:\n        inv_count += 1\n  return inv_count"
      ],
      [
        0.8902403712272644,
        "def count_inversions(arr): \n    \"\"\"\n    Return the number of inversions in the given array.\n    \n    >>> count_inversions([2, 4, 1, 3, 5])\n    3\n    \"\"\"\n    inversion_count = 0\n    for i in range(0, len(arr)): \n        for j in range(i+1, len(arr)): \n            if arr[i] > arr[j]: \n                inversion_count += 1\n    return inversion_count"
      ]
    ],
    "MBPP/195": [
      [
        0.8878861665725708,
        "def merge_tuples(t1, t2):\n    \"\"\"\n    Merge two tuples t1 and t2.\n    \n    >>> merge_tuples((1, 2, 3), (4, 5, 6))\n    (1, 4, 2, 5, 3, 6)\n    >>> merge_tuples((1, 2, 3), (4, 5, 6, 7))\n    (1, 4, 2, 5, 3, 6, 7)\n    >>> merge_tuples((1, 2, 3, 4), (5,\"\"\"\n    merged = ()\n    length = min(len(t1), len(t2)) # to handle tuples of unequal lengths\n    for i in range(length):\n        merged += (t1[i],)\n        merged += (t2[i],)\n    return merged + t1[length:] + t2[length:] # add remaining elements if tuples are of unequal lengths"
      ]
    ],
    "MBPP/196": [],
    "MBPP/197": [
      [
        0.8993039131164551,
        "def isValidDecimal(s):\n    \"\"\"\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    # remove any non-numeric characters and trim whitespaces\n    s = \"\".join(re.findall(\"\\d+\\.?\\d*\", s.strip()))\n\n    try: \n        num = float(s)\n        # checking if the number num has 2 decimal places\n        if not('.' in s and (len(s) - s.index('.') - 1) == 2):\n            return False      \n        else: \n             # check if it's a positive number within the range and not multiple of 10\n             return 0 < num < 1000 and num % 10 != 0\n    except ValueError:\n        return False"
      ],
      [
        0.884856641292572,
        "def is_valid_decimal(s):\n    \"\"\"\n    Check if a string is a valid decimal number.\n    :param s: string to check\n    :return: True if s is a valid decimal number, False otherwise\n    \"\"\"\n    stripped_str = s.strip()\n    try:\n        number = float(stripped_str)\n        if (str(number) == stripped_str) and (int(stripped_str) != int(number)):\n            fract_part = int(str(number).split('.')[1])\n            if 0 < number < 1000 and number % 10 != 0 and len(str(fract_part)) == 2:\n                return True\n        return False\n    except ValueError:\n        return False"
      ],
      [
        0.884850025177002,
        "def is_valid_decimal(s):\n    \"\"\"\n    Check if a string is a valid decimal number.\n    :param s: string to check\n    :return: True if s is a valid decimal number, False otherwise\n    \"\"\"\n    stripped_str = s.strip()\n    try:\n        number = float(stripped_str)\n        if (str(number) == stripped_str) and (int(stripped_str) != int(number)):\n            fract_part = int(str(number).split('.')[1])\n            if 0 < number < 1000 and number % 10 != 0 and len(str(fract_part)) == 2:\n                return True\n        return False\n    except ValueError:\n        return False"
      ]
    ],
    "MBPP/198": [
      [
        0.8817126154899597,
        "def in_min_heap(array, index, heap_size):\n    \"\"\"\n    Check if the given index is in the min heap.\n    \"\"\"\n    if index < 0 or index >= heap_size:\n        return False\n    return True\n    \n    def is_min_heap(array):\n    \"\"\"\n    Check if the given array is a min heap.\n    \"\"\"\n    left = 2 * index + 1\n    right = 2 * index + 2\n    if left < heap_size and array[left] < array[index]:\n        return False\n    if right < heap_size and array[right] < array[index]:\n        return False\n    return True"
      ]
    ],
    "MBPP/199": [
      [
        0.909605860710144,
        "def check_str(string):\n    '''\n    This function takes a string as input and checks if it contains all letters of the \n    English alphabet (a-z).\n    '''\n\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    for letter in alphabet:\n        if letter not in string.lower():\n            return False\n    return True"
      ],
      [
        0.9071197509765625,
        "def is_alphabet_string(s):\n    \"\"\"\n    Check if a string contains only alphabets\n    \"\"\"\n    import re\n    \"\"\"\n    Write your code here\n    \"\"\"\n    if(re.search('^[a-z]+$', s)):\n        return True\n    else:\n        return False"
      ]
    ],
    "MBPP/200": [],
    "MBPP/201": [
      [
        0.9243209362030029,
        "def sum_of_fourth_power_of_odds(n):\n    \"\"\"\n    Write a function that takes a positive integer n and returns the sum of the fourth powers of all the odd positive integers smaller than n.\n    \n    sum_of_fourth_power_of_odds(10) \u279e 285\n    # 1**4 + 3**4 + 5**4 + 7**4 + 9**4 = 285\n    \n    sum_of_fourth_power_of_odds(1) \u279e 1\n    \n    sum_of_fourth_power_of_odds(1000\"\"\"\n    if n == 1:\n        return 1\n    else:\n        return ((2*n-1)**4 + sum_of_fourth_power_of_odds(n-1))"
      ],
      [
        0.9139100909233093,
        "def fourth_power(n):\n    \"\"\"\n    Calculate the fourth power of the given number.\n    :param n: int\n    :return: int\n    \"\"\"\n    return n ** 4"
      ]
    ],
    "MBPP/202": [],
    "MBPP/203": [
      [
        0.9196987748146057,
        "def degrees_to_radians(degrees):\n    \"\"\"\n    Converts degrees to radians.\n    :param degrees: The degrees to convert.\n    :return: The radians.\n    \"\"\"\n    pi = 3.14159\n    radians = (degrees * pi) / 180\n    return radians"
      ]
    ],
    "MBPP/204": [
      [
        0.9063906669616699,
        "def decompressRLElist(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    return [nums[i+1] for i in range(0, len(nums), 2) for _ in range(nums[i])]"
      ]
    ],
    "MBPP/205": [
      [
        0.8997484445571899,
        "def is_sublist(main_list, potential_sublist):\n    \"\"\"\n    Return True if potential_sublist is a sublist of main_list\n    \"\"\"\n    return all(i in main_list for i in potential_sublist)\n    \n    def is_sublist(main_list, potential_sublist):\n    \"\"\"\n    Return True if potential_sublist is a sublist of main_list\n    \"\"\"\n    return all(i in main_list for i in potential_sublist)"
      ]
    ],
    "MBPP/206": [
      [
        0.9248712658882141,
        "def first_repeated_letter(string):\n    \"\"\"\n    Given a string, find the first repeated letter in the string.\n    \n    Args:\n        string (str): The string to search.\n    \n    Returns:\n        int: The index of the first repeated letter, or -1 if no repeated letter is found.\n    \"\"\"\n    # Create an empty dictionary to store the count of each letter\n    letter_count = {}\n    \n    # Iterate through the string\n    for i, letter in enumerate(string):\n        # Check if the letter is already in the dictionary\n        if letter in letter_count:\n            # If it is, return its index\n            return \"Index:\", i\n        else:\n            # If it is not, add it to the dictionary with a count of 1\n            letter_count[letter] = 1\n    \n    # If no repeated letter is found, return -1\n    return \"Index:\", -1"
      ],
      [
        0.9241628646850586,
        "def find_first_repeated_character(s):\n    \"\"\"\n    Find the first repeated character in a given string.\n    \n    Args:\n        s (str): The input string.\n        \n    Returns:\n        str: The first repeated character in s, or None if no repeated characters are found.\n    \"\"\"\n    char_set = set()\n    for c in s:\n        if c in char_set:\n            return c\n        char_set.add(c)\n    return None"
      ],
      [
        0.922087550163269,
        "def duplicate_characters(string):\n    \"\"\"\n    Given a string, find the first duplicate character in it.\n    For example, in the string \"abaccdeff\" the first duplicate character is 'a'\n    \n    :param string: string to search\n    :return: first duplicate character\n    \"\"\"\n    visited = [\"\\0\"] * 26 # create ASCII table\n    duplicates = [\"\\0\"] * 26 # store duplicates\n    for char in string:\n        index = get_index(char) \n        if visited[index] == \"\\0\": \n            visited[index] = char\n        elif visited[index] == char and duplicates[index] == \"\\0\":\n            duplicates[index] = char\n    \n    return ''.join([char for char in duplicates if char != '\\0'])"
      ]
    ],
    "MBPP/207": [
      [
        0.9001457691192627,
        "def minOperations(X, Y):\n    \"\"\"\n    :type X: int\n    :type Y: int\n    :rtype: int\n    \"\"\"\n    diff = Y - X\n    \n    # if destination is below or at current location\n    if diff <= 0:\n        return -diff\n      \n    # if destination is above current location\n    q, r = divmod(diff, 2)\n    return q + r"
      ],
      [
        0.8947091102600098,
        "def operations(num1, num2):\n    \"\"\"\n    Write a function that takes two positive integers as arguments, and returns the number of times you can subtract the smaller integer from the larger integer, so that the result is always greater than or equal to zero.\n    \n    You can assume that the first argument is always greater than or equal to the second.\n    \n    Example:\n    \n    operations(4, 17) # returns 2\n    \"\"\"\n    count = 0\n    while num1 != 0 and num2 != 0:\n        if num1 >= num2:\n            num1 -= num2\n        else:\n            num2 -= num1\n        count += 1\n    return count"
      ],
      [
        0.8946556448936462,
        "def operations(num1, num2):\n    \"\"\"\n    Write a function that takes two positive integers as arguments, and returns the number of times you can subtract the smaller integer from the larger integer, so that the result is always greater than or equal to zero.\n    \n    You can assume that the first argument is always greater than or equal to the second.\n    \n    Example:\n    \n    operations(4, 17) # returns 2\n    \"\"\"\n    count = 0\n    while num1 != 0 and num2 != 0:\n        if num1 >= num2:\n            num1 -= num2\n        else:\n            num2 -= num1\n        count += 1\n    return count"
      ],
      [
        0.8926690220832825,
        "def min_operations(nums1, nums2):\n    \"\"\"\n    :type nums1: List[int]\n    :type nums2: List[int]\n    :rtype: int\n    \"\"\"\n    sum1, sum2 = sum(nums1), sum(nums2)\n    if sum1 == sum2: return 0\n    if sum1 < sum2: nums1, nums2 = nums2, nums1\n    nums1.sort(reverse=True)\n    nums2.sort()\n    diff, operations, i, j = abs(sum1 - sum2), 0, 0, 0\n    while diff > 0 and (i < len(nums1) or j < len(nums2)):\n        option1 = nums1[i] - 1 if i < len(nums1) else 0\n        option2 = 6 - nums2[j] if j < len(nums2) else 0\n        if option1 > option2:\n            diff -= option1\n            i += 1\n        else:\n            diff -= option2\n            j += 1\n        operations += 1\n    return operations if diff == 0 else -1"
      ],
      [
        0.8894594311714172,
        "def min_operations_to_one(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the minimum number of operations to make n equal to 1.\n    You can apply any of the following operations:\n    If n is even, you can divide n by 2.\n    If n is odd, you can add 1 or subtract 1 from n.\n    \n    Example 1:\n    Input: n = 10\n    Output: 4\n    Explanation: 10 -> 5 -> 6 -> 3 -> 4 -> 2 -> 1\n    \n    Example 2:\n    Input: n =\"\"\"\n    operations = 0\n    while n > 1:\n        if n % 2 == 0:\n            n //= 2\n        else:\n            if n == 3 or n % 4 == 1:\n                n -= 1\n            else:\n                n += 1\n        operations += 1\n    return operations"
      ],
      [
        0.8885034322738647,
        "def least_ops_express_target(x, target):\n    \"\"\"\n    :type x: int\n    :type target: int\n    :rtype: int\n    \"\"\"\n    if x == target:\n        return 0\n    if target == 1:\n        return 1\n    if x > target:\n        return min(2 * target - 1, 2 * (x - target))\n\n    k = 0\n    p = x\n    while p < target:\n        k += 1\n        p *= x\n\n    ans = float('inf')\n    d = 1\n\n    for i in range(k - 1, -1, -1):\n        while p >= target + d * (1 - x):\n            p -= d\n            ans = min(ans, i + int(math.log2(target // d) + 1) + int(d == 1 and -1 or 0))\n        d = d * x + 1\n\n    return ans"
      ]
    ],
    "MBPP/208": [
      [
        0.8806426525115967,
        "def find_min_max(input_list):\n    \"\"\"\n    Return a tuple containing the minimum and maximum elements in a list.\n    \"\"\"\n    if not all(isinstance(num, int) for num in input_list):\n        print(\"Input list should only contain integers.\")\n        return\n\n    if len(input_list) < 2:\n        print(\"Input list should have at least 2 integers.\")\n        return\n\n    min_num = min(input_list)\n    max_num = max(input_list)\n\n    return min_num, max_num\n    \n    def find_min_max(input_\"\"\"\n    if not all(isinstance(num, int) for num in input_list):\n        print(\"Input list should only contain integers.\")\n        return\n\n    if len(input_list) < 2:\n        print(\"Input list should have at least 2 integers.\")\n        return\n\n    smallest = second_smallest = float('inf')\n    largest = second_largest = float('-inf')\n\n    for num in input_list:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num != largest:\n            second_largest = num\n\n    print(\"Smallest number:\", smallest)\n    print(\"Second smallest number:\", second_smallest)\n    print(\"Largest number:\", largest)\n    print(\"Second largest number:\", second_largest)"
      ],
      [
        0.8801046013832092,
        "def find_min_k_records(tup_list, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples.\n    :param tup_list: List of tuples.\n    :param k: Number of records to return.\n    :return: List of tuples.\n    \"\"\"\n    if len(tup_list) == 0:\n        return \"The tuple list is empty.\"\n    if k > len(tup_list):\n        return \"K is greater than the size of list. Returning all records.\"\n    tup_list.sort(key=lambda x: x[0])\n    return tup_list[:k]"
      ],
      [
        0.878049373626709,
        "def minMax(numbers):\n    \"\"\"\n    Given a list of integers, return a tuple containing the minimum and maximum\n    elements in the list.\n    \n    >>> minMax([1, 2, 3, 4, 5])\n    (1, 5)\n    >>> minMax([1])\n    (1, 1)\n    \"\"\"\n    max_num = numbers[0]\n    min_num = numbers[0]\n   \n    for num in numbers:\n        if num > max_num: \n            max_num = num\n        elif num < min_num:\n            min_num = num\n   \n    return (min_num, max_num)"
      ],
      [
        0.8767906427383423,
        "def select_k_elements(arr, k):\n    \"\"\"\n    Select k elements from an array such that the sum of the selected elements is maximum.\n    The selected elements must be adjacent to each other.\n    :param arr: List[int]\n    :param k: int\n    :return: Tuple[int, List[int]]\n    \"\"\"\n    n = len(arr)\n\n    # Initialize variables\n    inclusiveSum = 0\n    exclusiveSum = 0\n    selectedElements = [False] * n\n\n    for i in range(n):\n        # Calculate new sums\n        newInclusiveSum = exclusiveSum + arr[i]\n        newExclusiveSum = max(inclusiveSum, exclusiveSum)\n\n        # Check if the current element is adjacent to any selected element\n        if i > 0 and selectedElements[i-1]:\n            newInclusiveSum = max(newInclusiveSum, exclusiveSum)\n\n        # Update sums and selected elements\n        inclusiveSum = newInclusiveSum\n        exclusiveSum = newExclusiveSum\n        selectedElements[i] = inclusiveSum > exclusiveSum\n\n    # Find the maximum sum\n    maxSum = max(inclusiveSum, exclusiveSum)\n\n    # Find the selected elements\n    selected = []\n    prevSelected = False\n    for i in range(n):\n        if selectedElements[i]:\n            if not prevSelected:\n                selected.append(arr[i])\n            prevSelected = True\n        else:\n            prevSelected = False\n\n    return maxSum, selected"
      ]
    ],
    "MBPP/209": [
      [
        0.9054792523384094,
        "def replace_chars(line):\n    \"\"\"\n    Replace all spaces, commas and dots in a string with a colon.\n    \n    >>> replace_chars('This is a test.')\n    ('This:is:a:test:', 4)\n    \"\"\"\n    replacements = 0\n    new_line = []\n    \n    for char in line:\n        if char in [' ', ',', '.']:\n            new_line.append(':')\n            replacements += 1\n        else:\n            new_line.append(char)\n    \n    return ''.join(new_line), replacements"
      ],
      [
        0.8919072151184082,
        "def replace_and_count(filename):\n    \"\"\"\n    Replace all occurrences of space, comma, or period with a colon.\n    Return the number of replacements made.\n    \"\"\"\n    # +++your code here+++\n    # Open the file and read its contents\n    # Open a temporary file and write to it\n    # Replace the characters\n    # Close the files\n    \"\"\"\n    temp_file = filename + '.tmp'\n    count = 0\n    try:\n        with open(filename, 'r', encoding='utf-8') as read_file, \\\n            open(temp_file, 'w', encoding='utf-8') as write_file:\n            for line in read_file:\n                new_line = ''\n                for char in line:\n                    if char.isalnum() or char.isspace():\n                        new_line += char\n                    else:\n                        new_line += ':'\n                        count += 1\n                write_file.write(new_line)\n    except Exception as e:\n        print('An error occurred: {}'.format(str(e)))\n        return\n    finally:\n        os.remove(filename)\n        os.rename(temp_file, filename)\n    return count"
      ],
      [
        0.8795851469039917,
        "def add_spaces(string): \n    \"\"\"\n    Add spaces between commas in a string.\n    \n    >>> add_spaces(\"hello,world\")\n    'hello, world'\n    >>> add_spaces(\"hello,world,how,are,you\")\n    'hello, world, how, are, you'\n    \"\"\"\n    output = \"\"\n    for char in string:\n        if char == \",\":\n            output += char + \" \"\n        else:\n            output += char\n    return output"
      ]
    ],
    "MBPP/210": [
      [
        0.9352662563323975,
        "def find_first_even(numbers):\n    \"\"\"\n    Find the first even number in a list of numbers.\n    If there are no even numbers, return None.\n    :param numbers: a list of numbers\n    :return: the first even number in the list, or None\n    \"\"\"\n    for n in numbers:\n        if n % 2 == 0:\n            return n\n    return None"
      ],
      [
        0.9218041300773621,
        "def find_index_of_first_even_number(numbers):\n    \"\"\"\n    Find the index of the first even number in a list of numbers.\n    If no even numbers are found, return 0.\n    \n    Args:\n        numbers (list): A list of integers.\n    \n    Returns:\n        int: The index of the first even number in the list, or 0 if no even numbers are found.\n    \"\"\"\n    for index, num in enumerate(numbers):\n        if num % 2 == 0:\n            return index + 1\n    return 0"
      ]
    ],
    "MBPP/211": [
      [
        0.9031148552894592,
        "def check_same_data_type(lst):\n    \"\"\"\n    Check if all items in a list have the same data type.\n    \"\"\"\n    if len(lst) < 2:\n        return True\n\n    first_type = type(lst[0])\n\n    if first_type == list or first_type == dict:\n        first_type = check_same_data_type(lst[0])\n\n    for item in lst[1:]:\n        item_type = type(item)\n        if item_type == list or item_type == dict:\n            item_type = check_same_data_type(item)\"\"\"\n    if len(lst) < 2:\n        return True\n\n    first_type = type(lst[0])\n\n    if first_type == list or first_type == dict:\n        first_type = check_same_data_type(lst[0])\n\n    for item in lst[1:]:\n        item_type = type(item)\n        if item_type == list or item_type == dict:\n            item_type = check_same_data_type(item)\n        \n        if item_type != first_type:\n            return False\n    \n    return True"
      ],
      [
        0.8934249877929688,
        "def validate_types(old_tuple, new_elements):\n    \"\"\" Check types of new_elements against types in old_tuple \"\"\"\n    for element in new_elements:\n        if type(element) != type(old_tuple[0]):\n            return False\n    return True"
      ]
    ],
    "MBPP/212": [
      [
        0.9096955060958862,
        "def majority_element(arr):\n    '''This function takes an array and returns the majority element, if\n    exists. Otherwise, None is returned.\n    '''\n    # Create a dictionary to store the frequency of elements\n    elem_count = {}\n    for elem in arr:\n        if elem not in elem_count:\n            elem_count[elem] = 0\n        elem_count[elem] += 1\n    \n    # Loop through the dictionary to find the majority element\n    max_count = 0\n    majority_element = None\n    for elem, freq in elem_count.items():\n        if freq > max_count:\n            max_count = freq\n            majority_element = elem\n    return majority_element"
      ]
    ],
    "MBPP/213": [
      [
        0.9258160591125488,
        "def count_set_bits(n): \n    \"\"\"\n    Count the number of set bits in a number\n    :param n: number\n    :return: number of set bits\n    \"\"\"\n    count = 0\n    while n: \n        count += n & 1\n        n >>= 1\n    return count"
      ],
      [
        0.9201330542564392,
        "def count_bits(num):\n    \"\"\"\n    Write a function that takes an integer as input, and returns the number of bits that are equal to one in the binary representation of that number. You can guarantee that input is non-negative.\n\n    Example: The binary representation of 1234 is 10011010010, so the function should return 5 in this case\n    \"\"\"\n    count = 0\n    while num != 0:\n        num //= 2\n        count += 1\n    return count"
      ],
      [
        0.9174692630767822,
        "def countSetBits(A: int) -> int:\n    \"\"\"\n    :type A: int\n    :rtype: int\n    \"\"\"\n    num = 0\n    while A:\n        num += A & 1\n        A = A >> 1\n    return num"
      ]
    ],
    "MBPP/214": [
      [
        0.9316076040267944,
        "def find_minimum(arr):\n    \"\"\"\n    Find the minimum element in a rotated sorted array.\n    :param arr: List of integers\n    :return: Minimum element\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        mid = (left + right) // 2\n\n        if arr[mid] > arr[right]:\n            # Minimum value is in the right half\n            left = mid + 1\n        else:\n            # Minimum value is in the left half or at mid\n            right = mid\n\n    return arr[left]"
      ],
      [
        0.9301156997680664,
        "def find_min_element(arr): \n    \"\"\"\n    Find the minimum element in a sorted and rotated array\n    \n    Args:\n        arr (list): Sorted and rotated array\n    \n    Returns:\n        int: Minimum element in the array\n    \"\"\"\n    # Base case - if array is empty, return None\n    if len(arr) == 0:\n        return None\n  \n    # Base case - if array has only one element, return the element\n    if len(arr) == 1:\n        return arr[0]\n  \n    # Find the middle element\n    mid = len(arr)//2\n  \n    # Check if the middle element is the minimum\n    if mid > 0 and arr[mid - 1] > arr[mid]:\n        return arr[mid]\n    elif arr[mid + 1] < arr[mid]:\n        return arr[mid + 1]\n    # Finding the minimum in the left portion of the array\n    elif arr[mid] > arr[0]: \n        return find_min_element(arr[0:mid])\n    else: \n        return find_min_element(arr[mid + 1:len(arr) - 1])"
      ],
      [
        0.9175933599472046,
        "def find_pivot(arr, low, high):\n    \"\"\"\n    Find the pivot element in a rotated sorted array.\n    This is the smallest element in the array.\n    \"\"\"\n    # base case\n    if high < low:\n        return 0\n    if high == low:\n        return low\n\n    mid = (low + high)//2\n\n    if mid < high and arr[mid] > arr[mid + 1]:\n        return mid\n    if mid > low and arr[mid] < arr[mid - 1]:\n        return (mid-1)\n    if arr[low] >= arr[mid]:\n        \"\"\"\n    # base case\n    if high < low:\n        return 0\n    if high == low:\n        return low\n\n    mid = (low + high)//2\n\n    if mid < high and arr[mid] > arr[mid + 1]:\n        return mid\n    if mid > low and arr[mid] < arr[mid - 1]:\n        return (mid-1)\n    if arr[low] >= arr[mid]:\n        return find_pivot(arr, low, mid - 1)\n    return find_pivot(arr, mid + 1, high)"
      ],
      [
        0.9121354818344116,
        "def find_pivot(arr, low, high):\n    \"\"\"\n    Find the pivot element in a rotated sorted array.\n    This is the smallest element in the array.\n    \"\"\"\n    # base cases\n    if high < low:\n        return 0\n    if high == low:\n        return low\n\n    mid = (low + high) // 2\n\n    if mid < high and arr[mid] < arr[mid + 1]:\n        return mid\n    if mid > low and arr[mid] < arr[mid - 1]:\n        return (mid-1)\n    if arr[low] >= arr[mid]:\"\"\"\n    # base cases\n    if high < low:\n        return 0\n    if high == low:\n        return low\n\n    mid = (low + high) // 2\n\n    if mid < high and arr[mid] < arr[mid + 1]:\n        return mid\n    if mid > low and arr[mid] < arr[mid - 1]:\n        return (mid-1)\n    if arr[low] >= arr[mid]:\n        return find_pivot(arr, low, mid - 1)\n    return find_pivot(arr, mid + 1, high)"
      ],
      [
        0.9094018936157227,
        "def rotationalSearch(arr, n): \n    \"\"\"\n    Function to find the index of the smallest element in the array\n    \n    Parameters:\n    arr: array of integers\n    n: length of the array\n    \n    Returns:\n    index of the smallest element in the array\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n  \n    max_ele = arr[high]\n  \n    if (max_ele > arr[low]): \n        return 0\n  \n    while (low <= high): \n        mid = low + (high - low) // 2\n  \n        if (arr[mid] > arr[mid + 1]): \n            return (mid + 1) % n\n  \n        if (arr[mid] < arr[mid - 1]): \n            return mid \n  \n        if (arr[high] > arr[mid]): \n            high = mid - 1\n        else: \n            low = mid + 1\n  \n    return 0"
      ],
      [
        0.9052538275718689,
        "def findMaxElement(arr, low, high):\n    \"\"\"\n    Find the maximum element in a sorted and rotated array.\n    \n    Args:\n       arr(list): Input array\n       low(int): Starting index\n       high(int): Ending index\n    Returns:\n       int: Maximum value in the array\n    \"\"\"\n    if (high == low): \n        return arr[low] \n    else: \n        mid = (low + high) // 2\n        max_left = findMaxElement(arr, low, mid) \n        max_right = findMaxElement(arr, mid + 1, high) \n        return max(max_left, max_right) "
      ]
    ],
    "MBPP/215": [
      [
        0.9525721669197083,
        "def remove_odd_index_char(string):\n    \"\"\"\n    Remove the characters of odd index in a given string\n    \"\"\"\n    result = \"\"\n    for i in range(len(string)):\n        if i % 2 == 0:\n            result = result + string[i]\n    return result"
      ],
      [
        0.9523904323577881,
        "def remove_odd_index_characters(string):\n    \"\"\"\n    Remove characters which have odd index values in the given string\n    \"\"\"\n    result = \"\"\n    for i in range(len(string)):\n        if i % 2 == 0:\n            result += string[i]\n    return result\n    def remove_odd_index_characters(string):\n    \"\"\"\n    Remove characters which have odd index values in the given string\n    \"\"\"\n    result = \"\"\n    for i in range(len(string)):\n        if i % 2 == 0:\n            result += string[i]\n    return result"
      ],
      [
        0.9361382126808167,
        "def deleteAtOddIndex(s):\n    \"\"\"\n    Given a string s, delete all the characters at odd indices in it.\n    For example, if the given string is \"abcdef\", then your function should return \"acf\".\n    The string is indexed from 0.\n    Args:\n        s(str): the given string\n    Returns:\n        str: resultant string\n    \"\"\"\n    output = \"\"\n    for i in range(len(s)):\n        # delete the character at an odd index\n        if i % 2 != 0:\n            pass\n        else:\n            output += s[i]\n    return output"
      ],
      [
        0.9276894330978394,
        "def remove_even(string):\n    \"\"\"\n    Remove all even occuring characters from a string\n    \"\"\"\n    result = \"\"\n    count = {}\n\n    for char in string:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n\n    for ch, val in count.items():\n        if val % 2 != 0:\n            result += ch\n    return result\n    def remove_even(string):\n    \"\"\"\n    Remove all even occuring characters from a string\n    \"\"\"\n    result = \"\"\n    count = {}\n\n    for char in string:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n\n    for ch, val in count.items():\n        if val % 2 != 0:\n            result += ch\n    return result"
      ],
      [
        0.9243675470352173,
        "def remove_every_other_char(str):\n    \"\"\"\n    Given a string, return a new string made of every other char starting with the first, so \"Hello\" yields \"Hlo\".\n    \"\"\"\n    result = \"\"\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result += str[i]\n    return result"
      ]
    ],
    "MBPP/216": [
      [
        0.9369652271270752,
        "def find_min(a, b, c):\n    \"\"\"Function which finds the minimum of three numbers\"\"\"\n    min_number = min(a, b, c)\n    return min_number"
      ],
      [
        0.9238196015357971,
        "def min_function(a, b, c):\n    \"\"\"\n    Find the minimum of three numbers.\n    \n    Parameters\n    ----------\n    a : int\n        First number.\n    b : int\n        Second number.\n    c : int\n        Third number.\n    \n    Returns\n    -------\n    int\n        The minimum of the three numbers.\n    \"\"\"\n    return min(a, b, c)"
      ],
      [
        0.921434760093689,
        "def find_smallest_number(a, b, c):\n    \"\"\"\n    Find the smallest number among three numbers.\n    \n    Args:\n        a (int): First number.\n        b (int): Second number.\n        c (int): Third number.\n    \n    Returns:\n        int: The smallest number.\n    \"\"\"\n    return min(a, b, c)"
      ]
    ],
    "MBPP/217": [],
    "MBPP/218": [
      [
        0.9378997087478638,
        "def rearrange(arr):\n    \"\"\"\n    Rearrange positive and negative numbers in O(n) time and O(1) extra space\n    \"\"\"\n    # TODO: Write your code here\n    # Hint: Use two pointers technique\n    #       One pointer to traverse the array from left to right\n    #       Another pointer to traverse the array from right to left\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        while arr[left] < 0 and left < right:\n            left += 1\n        while arr[right] >= 0 and left < right:\n            right -= 1\n\n        if left < right:\n            arr[left], arr[right] = arr[right], arr[left]\n\n    return arr"
      ],
      [
        0.9373679161071777,
        "def optimizeArray(arr): \n    \"\"\"\n    Given an array of integers, move all negative integers to the beginning of the array and all positive integers to the end of the array. The order of the positive integers does not matter.\n    \n    Example:\n    \n    Input: [1, -1, 3, 2, -7]\n    Output: [-1, -7, 1, 3, 2]\n    \n    Input: [1, 2, 3, -1, -2, -3]\n    Output: [-1, -2, -3, 1, 2,\"\"\"\n    j = -1\n    for i in range(len(arr)): \n        if arr[i] < 0: \n            j += 1\n            arr[i], arr[j] = arr[j], arr[i] \n    return arr"
      ],
      [
        0.9368343353271484,
        "def rearrangeNegativePositive(arr, n):\n    \"\"\"\n    Rearrange positive and negative numbers in O(n) time and O(1) extra space\n    \"\"\"\n    # code here\n    \n    def rearrange(self,arr, n):\n    \"\"\"\n    Rearrange positive and negative numbers in O(n) time and O(1) extra space\n    \"\"\"\n    left = 0\n    right = n - 1\n\n    while left < right:\n        while arr[left] < 0 and left < right:\n            left += 1\n\n        while arr[right] >= 0 and left < right:\n            right -= 1\n\n        if left < right:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1"
      ],
      [
        0.929431676864624,
        "def rearrange_negative_numbers(array):\n    \"\"\"\n    Rearrange the elements of the array such that all negative numbers come before all positive numbers.\n    The order of the negative numbers and the positive numbers does not matter.\n    \n    Args:\n        array: A list of integers.\n    \n    Returns:\n        A list of integers where all negative numbers come before all positive numbers.\n    \"\"\"\n    negative_nums = []\n    positive_nums = []\n    for num in array:\n        if num < 0:\n            negative_nums.append(num)\n        else:\n            positive_nums.append(num)\n    return negative_nums + positive_nums"
      ],
      [
        0.9281833171844482,
        "def negative_at_beginning(arr):\n    \"\"\"\n    Given an array of integers, move all negative integers to the beginning of the array.\n    The order of the positive integers in the array should be unchanged.\n    The negative integers should be in the same order as they were in the original array.\n    \n    Example:\n    Input: [1, -2, 3, -4, 5, -6, 7]\n    Output: [-2, -4, -6, 1, 3, 5, 7]\n    \n    Input: [1, -2, 3, -4, \"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        if arr[left] < 0:\n            left += 1\n        elif arr[right] >= 0:\n            right -= 1\n        else:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n    return arr"
      ],
      [
        0.9246528744697571,
        "def move_negatives(numbers):\n    \"\"\"\n    Move all negative numbers to the start and positive to the end of the list.\n    The relative order of the positive numbers and the negative numbers should\n    stay the same.\n    \"\"\"\n    positive_list = []\n    negative_list = []\n    for num in numbers:\n        if num < 0:\n            negative_list.append(num)\n        else:\n            positive_list.append(num)\n    return negative_list + positive_list\n    def move_negatives(numbers):\n    \"\"\"\n    Move all negative numbers to the start and positive\"\"\"\n    positive_list = []\n    negative_list = []\n    for num in numbers:\n        if num < 0:\n            negative_list.append(num)\n        else:\n            positive_list.append(num)\n    return positive_list + negative_list"
      ]
    ],
    "MBPP/219": [
      [
        0.9108548164367676,
        "def replace_blank(string, character): \n    \"\"\"\n    Replace all blank spaces in a string with a given character.\n    \n    Args:\n        string (str): The string to be modified.\n        character (str): The character to replace blank spaces with.\n    \n    Returns:\n        str: The modified string with blank spaces replaced by the given character.\n    \"\"\"\n    return string.replace(' ', character)"
      ]
    ],
    "MBPP/220": [
      [
        0.8907344937324524,
        "def max_sum_path(matrix):\n    \"\"\"\n    Find the maximum sum of a path from top left to bottom right.\n    You can only move down or right.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    for row in range(rows):\n        for col in range(cols):\n            if row == 0 and col == 0: \n                continue\n            elif row == 0: \n                matrix[row][col] += matrix[row][col-1]\n            elif col == 0: \n                matrix[row][col] += matrix[row-1][col]\n            else: \n                matrix[row][col] += max(matrix[row-1][col], matrix[row][col-1])\n\n    return matrix[rows-1][cols-1]"
      ]
    ],
    "MBPP/221": [
      [
        0.9116641283035278,
        "def nlargest(n, iterable):\n    \"\"\"Find the n largest elements in a dataset.\n    Equivalent to:  sorted(iterable, reverse=True)[:n]\n    \"\"\"\n\n    if n < 0:\n        return []\n    it = iter(iterable)\n    result = list(islice(it, n))\n    if not result:\n        return result\n    heapify(result)\n    _heappushpop = heappushpop\n    for elem in it:\n        _heappushpop(result, elem)\n    result.sort(reverse=True)\n    return result"
      ],
      [
        0.9035091400146484,
        "def get_most_expensive_items(dataset, n):\n    \"\"\"\n    Returns the n most expensive items in the dataset.\n    \n    Args:\n        dataset (list): A list of dictionaries representing items.\n        n (int): The number of most expensive items to return.\n        \n    Returns:\n        list: A list of dictionaries representing the n most expensive items.\n    \"\"\"\n    # Sorting the dataset by 'cost' in descending order (from highest to lowest)\n    sorted_dataset = sorted(dataset, key=lambda item: item['cost'], reverse=True)\n    # Returning the first n items\n    return sorted_dataset[:n]"
      ],
      [
        0.903169572353363,
        "def get_most_expensive_items(dataset, n):\n    \"\"\"\n    Returns the n most expensive items in a dataset.\n    \n    Args:\n        dataset (list): A list of dictionaries representing items in a dataset.\n        n (int): The number of most expensive items to return.\n    \n    Returns:\n        list: A list of dictionaries representing the n most expensive items in the dataset.\n    \"\"\"\n    # sorting the dataset by 'cost' in descending order (from highest to lowest)\n    sorted_dataset = sorted(dataset, key=lambda item: item['cost'], reverse=True)\n    # returning first n items\n    return sorted_dataset[:n]"
      ]
    ],
    "MBPP/222": [
      [
        0.9055103063583374,
        "def surface_area_cylinder(radius, height):\n    \"\"\"\n    Calculate the surface area of a cylinder.\n    \n    Args:\n        radius (float): The radius of the cylinder.\n        height (float): The height of the cylinder.\n    \n    Returns:\n        float: The surface area of the cylinder.\n    \"\"\"\n    pi = 3.14\n    return (2 * pi * radius * height) + (2 * pi * (radius ** 2))"
      ]
    ],
    "MBPP/223": [
      [
        0.9112489223480225,
        "def cube_volume(side_length):\n    \"\"\"\n    Calculate the volume of a cube.\n    \n    Args:\n        side_length (float): The length of one side of the cube.\n        \n    Returns:\n        float: The volume of the cube.\n    \"\"\"\n    volume = side_length ** 3\n    return volume"
      ],
      [
        0.9103088974952698,
        "def calculate_volume(s):\n  \"\"\"\n  Calculate the volume of a cube.\n  \n  Args:\n    s: The length of one side of the cube.\n  \n  Returns:\n    The volume of the cube.\n  \"\"\"\n  V = s**3\n  return V"
      ],
      [
        0.9089083671569824,
        "def calculate_cube_volume(length):\n    \"\"\"Calculate the volume of a cube.\n    \n    Args:\n        length (float): The length of a side of the cube.\n        \n    Returns:\n        float: The volume of the cube.\n    \"\"\"\n    volume = length ** 3\n    return volume"
      ]
    ],
    "MBPP/224": [
      [
        0.8876368999481201,
        "def even_odd_change(arr):\n    \"\"\"\n    Given an array of numbers, replace all even numbers with 0 and all odd numbers with 1.\n    \n    Example:\n    \n    Input: [1, 2, 3, 4, 5, 6]\n    Output: [1, 0, 1, 0, 1, 0]\n    \n    Input: [10, 11, 12, 13, 14, 15]\n    Output: [0, 1, 0, 1, 0, 1]\n\"\"\"\n    for i in range(len(arr)):\n        if arr[i] % 2 == 0:\n            arr[i] = 0\n        else:\n            arr[i] = 1\n    return arr"
      ]
    ],
    "MBPP/225": [
      [
        0.8838199377059937,
        "def T(n):\n   \"\"\"\n   Return the number of triangles in a triangle of size n.\n   \"\"\"\n   return math.floor(n / math.sqrt(3))"
      ]
    ],
    "MBPP/226": [
      [
        0.8963366150856018,
        "def count_occurrences(lst):\n    \"\"\"\n    Given a list of integers, return a list of tuples where each tuple contains a number and the number of occurrences of that number in the list.\n    The list of tuples should be ordered in descending order based on the count of occurrences.\n    For example, given the list [1, 2, 3, 1, 2, 3, 1, 4, 5], return [(1, 3), (2, 2), (3, 2), (4, 1), (5, 1)].\n    \"\"\"\n    from collections import Counter\n    \n\"\"\"\n    count = Counter(lst)  # Count occurrences of each distinct integer\n    result = [(i, count[i]) for i in count]  # Convert to the desired output format\n    result.sort(key=lambda x: (-x[1], x[0]))  # Sort first by descending count, then by ascending integer\n    return result"
      ]
    ],
    "MBPP/227": [],
    "MBPP/228": [
      [
        0.8881839513778687,
        "def f(n):\n    \"\"\"\n    \"\"\"\n    ans = 0\n    n //= 2\n    for i in range(1, n+1):\n        h[i] = n // i - 1\n    for i in range(1, n+1):\n        f[i] = binom(h[i])\n        j = 2\n        while i * j <= n:\n            f[i] -= f[i * j]\n            j += 1\n        ans = (ans + i * f[i]) % MOD\n    return ans * 2 % MOD"
      ]
    ],
    "MBPP/229": [
      [
        0.9148705005645752,
        "def replace_last_element(list1, list2):\n    \"\"\"\n    Replace the last element of list1 with the last element of list2\n    \n    >>> replace_last_element([1, 2, 3], [4, 5, 6])\n    [1, 2, 6]\n    >>> replace_last_element([1, 2, 3], [4])\n    [1, 2, 4]\n    \"\"\"\n    list1[-1:] = list2\n    return list1"
      ],
      [
        0.8855752944946289,
        "def last_element(list):\n    \"\"\"Find the last element of a given list.\"\"\"\n    return list[-1]"
      ]
    ],
    "MBPP/230": [
      [
        0.8953325748443604,
        "def generate_3d_array(m, n, l):\n    \"\"\"\n    Generate a 3D array of size m x n x l\n    :param m: int\n    :param n: int\n    :param l: int\n    :return: list\n    \"\"\"\n    threeD = [[[0 for x in range(l)] for y in range(n)] for z in range(m)]\n    return threeD"
      ]
    ],
    "MBPP/231": [],
    "MBPP/232": [],
    "MBPP/233": [
      [
        0.9175034761428833,
        "def find_next_perfect_square(n):\n    \"\"\"\n    Find the next perfect square after the given number.\n    :param n: The given number.\n    :return: The next perfect square.\n    \"\"\"\n    if is_perfect_square(n):\n        root = math.sqrt(n)\n        next_square = (root + 1) ** 2\n        return int(next_square)\n    else:\n        return \"Number is not a perfect square\""
      ],
      [
        0.9108990430831909,
        "def next_square(n):\n    \"\"\"\n    Find the next square number after n\n    :param n: int\n    :return: int\n    \"\"\"\n    return int(math.ceil(math.sqrt(n)))**2"
      ]
    ],
    "MBPP/234": [
      [
        0.8948610424995422,
        "def max_sum_subarray(arr):\n    \"\"\"\n    Find the maximum sum of a subarray in the given array.\n    \n    Args:\n        arr (list): The input array.\n    \n    Returns:\n        int: The maximum sum of a subarray in the given array.\n    \"\"\"\n    n = len(arr)\n    \n    # Base cases\n    if n == 0:\n        return 0\n    if n == 1:\n        return arr[0]\n    \n    # Initialize two variables to store the maximum sum\n    include = arr[0]\n    exclude = 0\n    \n    # Iterate through the array\n    for i in range(1, n):\n        # Update the maximum sum by including or excluding the current element\n        new_include = exclude + arr[i]\n        new_exclude = max(include, exclude)\n        \n        # Update the include and exclude variables\n        include = new_include\n        exclude = new_exclude\n    \n    # Return the maximum sum\n    return max(include, exclude)"
      ],
      [
        0.8929369449615479,
        "def maxsum(arr):\n    \"\"\"\n    Find the maximum sum of a contiguous subarray.\n    :param arr: array of integers\n    :return: maximum sum\n    \"\"\"\n    if len(arr) == 0:\n        return 0\n\n    incl = arr[0]\n    excl = 0\n\n    for i in arr[1:]:\n        new_excl = max(incl, excl)\n        incl = excl + i\n        excl = new_excl\n\n    return max(incl, excl)"
      ],
      [
        0.8922436237335205,
        "def max_sum_subarray(arr):\n    \"\"\"\n    Find the maximum sum subarray in a given array.\n    :param arr: list of integers\n    :return: integer\n    \"\"\"\n    max_ending_here = max_so_far = arr[0]\n    for i in range(1, len(arr)):\n        max_ending_here = max(arr[i], max_ending_here + arr[i])\n        max_so_far = max(max_ending_here, max_so_far)\n    return max_so_far"
      ],
      [
        0.889336109161377,
        "def max_subarray_sum(arr):\n    \"\"\"\n    Find the maximum sum of a subarray in the given array.\n    \n    Args:\n        arr (list): The input array.\n    \n    Returns:\n        int: The maximum sum of a subarray in the array.\n    \"\"\"\n    n = len(arr)\n    memo = [0] * n  # Create a memoization array to store the maximum sum of subarrays ending at each index\n    \n    memo[0] = arr[0]  # Base case: the maximum sum of a subarray ending at the first element is the element itself\n    \n    for i in range(1, n):\n        # The maximum sum of a subarray ending at index i is the maximum of:\n        #   1. The element itself\n        #   2. The element plus the maximum sum of a subarray ending at the previous index (i-1)\n        #   3. The maximum sum of a subarray ending at the previous index (i-1)\n        memo[i] = max(arr[i], arr[i] + memo[i-1], memo[i-1])\n    \n    return max(memo)  # The maximum sum of any subarray in the array is the maximum value in the memoization array"
      ],
      [
        0.8887341022491455,
        "def max_sum_non_contiguous(arr):\n    \"\"\"\n    Find the maximum sum of non-contiguous subarray in an array.\n    \n    Args:\n        arr (list): The input array.\n    \n    Returns:\n        int: The maximum sum of non-contiguous subarray.\n    \"\"\"\n    if len(arr) == 0:\n        return 0\n    if len(arr) == 1:\n        return max(arr[0], 0)\n    \n    incl = max(arr[0], 0)\n    excl = 0\n    \n    for i in range(1, len(arr)):\n        # Calculate the new incl and excl values based on the current element\n        new_excl = max(incl, excl)\n        incl = excl + max(arr[i], 0)\n        excl = new_excl\n    \n    # Return the maximum sum of non-contiguous subarray\n    return max(incl, excl)"
      ],
      [
        0.888486385345459,
        "def max_sum(arr): \n     \"\"\"\n     Find the maximum sum of a contiguous subsequence in arr.\n     \n     Args:\n       arr(list): array of integers\n     Returns:\n       int: the maximum sum of a contiguous subsequence\n     \"\"\"\n     if len(arr) == 0: \n         return 0\n  \n     if len(arr) == 1: \n         return arr[0] \n  \n     if len(arr) == 2: \n         return max(arr[0], arr[1]) \n  \n     max_sum_incl = arr[0] \n     max_sum_excl = 0\n  \n     for i in range(1, len(arr)): \n        temp = max_sum_incl \n        max_sum_incl = max(max_sum_excl + arr[i] , max_sum_incl) \n        max_sum_excl = temp \n  \n     return max(max_sum_incl, max_sum_excl)"
      ],
      [
        0.8879979848861694,
        "def maxsumSubsequence(arr): \n    \"\"\"\n    Find the maximum sum of a subsequence in an array\n    :param arr: array of integers\n    :return: maximum sum of a subsequence\n    \"\"\"\n    max_including = arr[0] \n    max_excluding = 0\n    max_sum = 0\n\n    for i in range(1, len(arr)):\n        max_sum = max(max_including, max_excluding)\n\n        max_including = max_excluding + arr[i]\n        max_excluding = max_sum\n\n    return max(max_including, max_excluding)"
      ],
      [
        0.8876867890357971,
        "def max_sum_sequence(arr): \n    \"\"\"\n    Find the contiguous subarray within an array (containing at least one number) which has the largest sum.\n    For example:\n    Given the array [-2,1,-3,4,-1,2,1,-5,4],\n    the contiguous subarray [4,-1,2,1] has the largest sum = 6.\n    \n    Args:\n       arr(list): input array\n    Returns:\n       int: largest sum\n    \"\"\"\n    n = len(arr) \n    current_max = arr[0] \n    global_max = arr[0] \n      \n    for i in range(1, n): \n        current_max = max(arr[i], current_max+arr[i]) \n        if current_max > global_max: \n            global_max = current_max \n      \n    return global_max"
      ],
      [
        0.8863278031349182,
        "def max_sum_subarray(arr):\n    \"\"\"\n    Find the maximum sum of a subarray in a given array.\n    \n    Args:\n        arr (list): The input array.\n    \n    Returns:\n        int: The maximum sum of a subarray.\n    \"\"\"\n    max_sum = 0\n    \n    for i in range(len(arr)):\n        cur_sum = 0\n        \n        for j in range(i, len(arr)):\n            cur_sum += arr[j]\n            \n            if cur_sum > max_sum:\n                max_sum = cur_sum\n    \n    return max_sum"
      ]
    ],
    "MBPP/235": [
      [
        0.9364761710166931,
        "def sqrt_babylonian(s):\n    \"\"\"\n    Find the square root of a number using the Babylonian method.\n    \"\"\"\n    x = int(s)\n    guess = x / 2.0\n    while True:\n        better_guess = (guess + x / guess) / 2.0\n        if abs(guess - better_guess) < 0.5:\n            return round(better_guess)\n        guess = better_guess"
      ],
      [
        0.9348063468933105,
        "def babylonian_sqrt(n):\n    \"\"\"Babylonian square root\"\"\"\n    x = n\n    y = 1\n    e = 0.000001  # This defines the accuracy level\n    while (x - y > e):\n        x = (x + y)/2\n        y = n/x\n    return x"
      ],
      [
        0.9237368702888489,
        "def square_root(number):\n    \"\"\"\n    Calculate the square root of a number using the Babylonian method.\n    \n    Args:\n        number (float): The number whose square root is to be calculated.\n        \n    Returns:\n        float: The square root of the given number.\n    \"\"\"\n    guess = number / 2  # initial guess\n    threshold = 0.0001  # acceptable error threshold\n    \n    while abs(guess * guess - number) > threshold:\n        guess = (guess + number / guess) / 2\n        \n    return guess"
      ],
      [
        0.9208081960678101,
        "def sqrt(n):\n    \"\"\"\n    Return the square root of n.\n    \"\"\"\n    x = n\n    y = (x + 1) / 2\n\n    while abs(y - x) > 0.000001:\n        x = y\n        y = (x + n / x) / 2\n\n    return y"
      ],
      [
        0.9191723465919495,
        "def square_root(number):\n    \"\"\"\n    Calculate the square root of a number using the Babylonian method.\n    \n    Args:\n        number (float): The number whose square root is to be calculated.\n    \n    Returns:\n        float: The square root of the given number.\n    \"\"\"\n    if number == 0 or number == 1:\n        return number\n    \n    # Initialize variables\n    root = number\n    remainder = 0\n    result = 0\n    \n    # Set the divisor and quotient\n    divisor = 1\n    quotient = 0\n    \n    # Loop until we get the desired precision\n    while root - result > 0.0001:\n        # Calculate the next digit of the square root\n        while quotient * ((divisor * 2 * 10) + quotient) <= root:\n            quotient += 1\n        \n        # Adjust the divisor and result\n        divisor = divisor * 10\n        result = result * 10 + quotient\n        \n        # Calculate the remainder for the next iteration\n        remainder = root - (quotient * quotient)\n        \n        # Prepare for the next iteration\n        quotient = 0\n        root = remainder * 100\n    \n    return result"
      ],
      [
        0.9166451692581177,
        "def sqrt(number): \n    \"\"\"\n    Return the square root of the given number.\n    \n    >>> sqrt(9)\n    3.0\n    >>> sqrt(2)\n    1.4142135623730951\n    \"\"\"\n    # Initialize the square root \n    # of the given number \n    sqrt = number / 2\n  \n    # Use the Babylonian algorithm \n    # for calculating the square root \n    # of the given number \n    temp = 0\n    while(sqrt != temp): \n        temp = sqrt \n        sqrt = ( number/temp + temp) / 2\n  \n    return sqrt"
      ],
      [
        0.9128643870353699,
        "def sqrt(x):\n    \"\"\"\n    Returns the square root of x.\n    \"\"\"\n    root = x\n    epsilon = 0.0001\n    while abs(x - root * root) > epsilon:\n        root = (x/root + root)/2\n    return root"
      ],
      [
        0.9128344655036926,
        "def sqrt(x):\n    \"\"\"\n    Compute square roots using the method of Heron of Alexandria.\n    \n    Args:\n      x: the number for which the square root is to be computed\n    Returns:\n      The square root of x.\n    \"\"\"\n    guess = x\n    i = 0\n    while guess * guess != x and i < 20:\n        guess = (guess + x / guess) / 2.0\n        i += 1\n    return guess"
      ]
    ],
    "MBPP/236": [],
    "MBPP/237": [
      [
        0.9292917251586914,
        "def harmonic_sum(n):\n    \"\"\"\n    Return the nth harmonic sum.\n    \n    The nth harmonic sum is the sum of the reciprocals of the positive integers\n    less than or equal to n.\n    \n    >>> harmonic_sum(1)\n    1.0\n    >>> harmonic_sum(2)\n    1.5\n    >>> harmonic_sum(3)\n    1.8333333333333333\n    >>> harmonic_sum(4)\n    1.9166666666666665\n    >>> harmonic\"\"\"\n    if n < 2:\n        return 1\n    else:\n        return 1/n + harmonic_sum(n-1)"
      ],
      [
        0.9282971620559692,
        "def harmonic(n):\n    \"\"\"\n    Harmonic number\"\"\"\n    if n < 1: \n        return 0\n    elif n == 1: \n        return 1\n    else: \n        return harmonic(n - 1) + 1 / n"
      ],
      [
        0.9053475856781006,
        "def harmonic_series(N):\n    \"\"\"\n    This function calculates the harmonic series up to N.\n    \n    Parameters\n    ----------\n    N : int\n        The number of terms in the series.\n    \n    Returns\n    -------\n    sum : float\n        The sum of the harmonic series up to N.\n    \"\"\"\n    sum = 0\n    for i in range(1, N+1):\n        sum += 1/i\n    return sum"
      ]
    ],
    "MBPP/238": [
      [
        0.9145195484161377,
        "def intersection(arr1, arr2):\n  \"\"\"\n  Find the intersection of two arrays\n  \"\"\"\n  # Use built-in set function to find intersection\n  result = list(set(arr1) & set(arr2))\n  return result\n    def intersection(arr1, arr2):\n  \"\"\"\n  Find the intersection of two arrays\n  \"\"\"\n  # Use built-in set function to find intersection\n  result = list(set(arr1) & set(arr2))\n  return result"
      ]
    ],
    "MBPP/239": [],
    "MBPP/240": [],
    "MBPP/241": [
      [
        0.9135926961898804,
        "def complex_to_polar(a, b):\n    \"\"\"\n    Convert a complex number to polar form.\n    \n    Parameters:\n    a (float): The real part of the complex number.\n    b (float): The imaginary part of the complex number.\n    \n    Returns:\n    tuple: A tuple containing the magnitude and angle of the complex number in polar form.\n    \"\"\"\n    # Calculate the magnitude\n    r = (a**2 + b**2) ** 0.5\n\n    # Calculate the angle\n    if a == 0:\n        theta = 90 if b > 0 else 270\n    else:\n        theta = math.degrees(math.atan(b / a))\n\n    # Return the polar form\n    return (r, theta)"
      ],
      [
        0.8814173340797424,
        "def convert_to_polar(x, y):\n    \"\"\"\n    Converts Cartesian coordinates to polar coordinates.\n    \n    Args:\n        x (float): x-coordinate\n        y (float): y-coordinate\n        \n    Returns:\n        tuple: (r, theta)\n    \"\"\"\n    r = math.sqrt(x**2 + y**2)\n    theta = math.atan2(y, x)\n    \n    if x < 0:\n        theta += math.pi\n    \n    return (r, theta)"
      ]
    ],
    "MBPP/242": [],
    "MBPP/243": [
      [
        0.9118198156356812,
        "def word_find(s):\n  \"\"\"\n  Find all words starting with 'a' or 'A' in a string\n  :param s: string\n  :return: list of words\n  \"\"\"\n  regex = r'\\b[aA]\\w*\\b'    # handles words starting with both 'a' and 'A'\n  matches = re.findall(regex, s)\n\n  # return unique words only by converting the list to a set\n  return list(set(matches))"
      ]
    ],
    "MBPP/244": [
      [
        0.873788595199585,
        "def comb3(arr):\n    \"\"\"\n    \"\"\"\n    result = []\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            for k in range(j+1, len(arr)):\n                t = [arr[i], arr[j], arr[k]]\n                result.append(t)\n    return result"
      ]
    ],
    "MBPP/245": [
      [
        0.9299114346504211,
        "def count_primes(n):\n    \"\"\"\n    Count the number of prime numbers less than a non-negative number, n\n    \"\"\"\n    # Create a boolean array \"is_prime[0..n]\" and initialize\n    # all entries it as true.\n    is_prime = [True] * (n+1)\n    is_prime[0] = is_prime[1] = False\n\n    count = 0\n\n    p = 2\n    while p * p <= n:\n        # If is_prime[p] is not changed, then it is a prime\n        if is_prime[p] == True:\n            # Update all multiples of p\n            for i in range(p * p, n+1, p):\n                is_prime[i] = False\n        p += 1\n\n    # Count all prime numbers\n    for i in range(2, n+1):\n        if is_prime[i]:\n            count += 1\n\n    return count"
      ],
      [
        0.9273073077201843,
        "def prime_count(n):\n    \"\"\"\n    Count the number of prime numbers less than a non-negative number, n.\n    \n    :type n: int\n    :rtype: int\n    \"\"\"\n    prime_count = 0\n    for i in range(2, n + 1):\n        is_prime = True\n        for j in range(2, int(i ** 0.5) + 1):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            prime_count += 1\n        \n    return prime_count"
      ],
      [
        0.9266175031661987,
        "def count_primes(l):\n    \"\"\"\n    Count the number of prime numbers less than a non-negative number, l.\n    \"\"\"\n    count = 0\n    for elem in l:\n        if is_prime(elem):\n            count += 1\n    return count"
      ],
      [
        0.9249802827835083,
        "def count_primes(num) :\n    \"\"\"\n    Return the number of prime numbers that exist up to and including a given number.\n    \"\"\"\n    def check_primes(num) :\n        \"\"\"\n        Check if a number is prime or not\n        \"\"\"\n        if num > 1 :\n            for i in range(2,num) :\n                if num % i == 0 :\n                    return False\n            return True\n        else :\n            return False\n\n    \"\"\"\n    count = 0\n    for m in range(2,num) :\n        if check_primes(m) == True :\n            count += 1\n\n    return count"
      ]
    ],
    "MBPP/246": [
      [
        0.9232127666473389,
        "def swap(a, b):\n    \"\"\"Swap two numbers\"\"\"\n    # Store a in temp\n    temp = a\n\n    # Copy b to a\n    a = b\n\n    # Copy temp to b\n    b = temp"
      ],
      [
        0.9203928709030151,
        "def swap_numbers(a, b):\n    \"\"\"\n    Swap two numbers\n    \"\"\"\n    a = a + b\n    b = a - b\n    a = a - b\n    return a, b\n    def swap_numbers(a, b):\n    \"\"\"\n    Swap two numbers\n    \"\"\"\n    a = a + b\n    b = a - b\n    a = a - b\n    return a, b"
      ],
      [
        0.9203890562057495,
        "def swap_numbers(a, b):\n    \"\"\"\n    Swap two numbers\n    \"\"\"\n    a = a + b\n    b = a - b\n    a = a - b\n    return a, b\n    def swap_numbers(a, b):\n    \"\"\"\n    Swap two numbers\n    \"\"\"\n    a = a + b\n    b = a - b\n    a = a - b\n    return a, b"
      ],
      [
        0.9194864630699158,
        "def swap(a, b):\n    \"\"\"\n    Swap two variables.\n    \"\"\"\n    return b, a\n    def swap(a, b):\n    \"\"\"\n    Swap two variables.\n    \"\"\"\n    return b, a"
      ]
    ],
    "MBPP/247": [
      [
        0.9179342985153198,
        "def count_odd(lst):\n    \"\"\"\n    Return the number of elements in the list that are odd.\n    \"\"\"\n    count = 0\n    for i in lst:\n        if i % 2 != 0:\n            count += 1\n    return count\n    def count_odd(lst):\n    \"\"\"\n    Return the number of elements in the list that are odd.\n    \"\"\"\n    count = 0\n    for i in lst:\n        if i % 2 != 0:\n            count += 1\n    return count"
      ],
      [
        0.9051287174224854,
        "def count_odd(nums):\n    \"\"\"\n    Return the number of integers in the given list which are odd.\n    \n    >>> count_odd([1, 2, 3, 4, 5])\n    3\n    >>> count_odd([2, 4, 6, 8])\n    0\n    >>> count_odd([1, 3, 5, 7])\n    4\n    \"\"\"\n    count = 0\n    for num in nums:\n        if num % 2 != 0:\n            count += 1\n    return count"
      ]
    ],
    "MBPP/248": [
      [
        0.8909956812858582,
        "def optimize(list1, list2):\n    \"\"\"\n    Find the combination of two lists that maximizes the sum of their elements.\n    \n    Args:\n        list1 (list): The first list of integers.\n        list2 (list): The second list of integers.\n        \n    Returns:\n        tuple: A tuple containing the two integers from the two lists that maximize the sum.\n    \"\"\"\n    best_combination = (0, 0)\n    best_value = -float('inf')\n    for x in list1:\n        for y in list2:\n            value = x + y\n            if value > best_value:\n                best_value = value\n                best_combination = (x, y)\n    return best_combination"
      ]
    ],
    "MBPP/249": [],
    "MBPP/250": [],
    "MBPP/251": [
      [
        0.9031261205673218,
        "def split_list(arr):\n    \"\"\"\n    Write a function that takes in a list of numbers and returns a new list containing the first half of the numbers in the input list.\n    If there are an odd number of elements, return the middle element.\n    \n    Example:\n    Input: [1,2,3,4,5]\n    Output: [1,2,3]\n    \n    Input: [1,2,3,4,5,6]\n    Output: [1,2,3,4]\n    \"\"\"\n    first_half = arr[:(len(arr)//2)]\n    second_half = arr[(len(arr)//2):]\n    return [first_half, second_half]"
      ]
    ],
    "MBPP/252": [],
    "MBPP/253": [],
    "MBPP/254": [
      [
        0.904079794883728,
        "def split_list(L, n):\n    \"\"\"\n    >>> list(split_list([1,2,3,4,5,6,7,8], 3))\n    [[1, 2, 3], [4, 5, 6], [7, 8]]\n    >>> list(split_list([1,2,3,4,5,6,7,8], 4))\n    [[1, 2, 3, 4], [5, 6, 7, 8]]\n    >>> list(split_list([1,2,3,4,5,6\"\"\"\n    assert type(L) is list, \"L is not a list\"\n    it = iter(L)\n    while True:\n        chunk = list(islice(it,n))\n        if not chunk:\n            return\n        yield chunk"
      ],
      [
        0.895561933517456,
        "def group_list(mylist, n): \n    \"\"\"\n    group_list([1,2,3,4], 2)\n    [[1,2], [3,4]]\n    \"\"\"\n    newlist = [] \n    indices = list(range(0, len(mylist), n))  \n    for start in indices: \n        end = start + n\n        newlist.append(mylist[start:end])  \n    return newlist \n    \n    def group_list(mylist, n): \n    \"\"\"\n    group_list([1,2,3,4], 2)\n    [[\"\"\"\n    newlist = [] \n    indices = list(range(0, len(mylist), n))  \n    for start in indices: \n        end = start + n\n        newlist.append(mylist[start:end])  \n    return newlist "
      ],
      [
        0.8952036499977112,
        "def split_string(string, n):\n    \"\"\"\n    Split a string into a list of strings, each of length n.\n    \n    >>> split_string(\"Lovelace\", 3)\n    ['Lov', 'ele', 'ace']\n    \n    >>> split_string(\"Chocolate\", 3)\n    ['Cho', 'col', 'ate']\n    \n    >>> split_string(\"Chocolate\", 2)\n    ['Ch', 'oc', 'ol', 'at', 'e']\n    \n    >>> split_string(\"Chocolate\", 4)\n    ['Choc', 'olat', 'e']\n    \n\"\"\"\n    return [string[i:i+n] for i in range(0, len(string), n)]"
      ]
    ],
    "MBPP/255": [
      [
        0.912993311882019,
        "def cube_surface_area(side):\n    \"\"\" \n    Calculate and return the total surface area of a cube \n    given the side length.\n    \"\"\"\n    return 6 * side**2"
      ],
      [
        0.9041370153427124,
        "def calc_surface_area(side_length):\n    \"\"\"\n    Calculate the surface area of a cube.\n    \n    Args:\n        side_length (float): The length of one side of the cube.\n        \n    Returns:\n        float: The surface area of the cube.\n    \"\"\"\n    return side_length * side_length * 6"
      ]
    ],
    "MBPP/256": [
      [
        0.9226610660552979,
        "def sum_odd_integers(n):\n    \"\"\"\n    Return the sum of the first n odd integers.\n    \"\"\"\n    sum = 0\n    for i in range(1, n + 1):\n        if i % 2 != 0:\n            sum += i\n    return sum\n    \n    def sum_odd_integers(n):\n    \"\"\"\n    Return the sum of the first n odd integers.\n    \"\"\"\n    sum = 0\n    if n % 2 == 0:\n        sum = (n // 2) ** 2\n    else:\n        sum = ((n + 1) // 2) ** 2\n    return sum"
      ],
      [
        0.9226177930831909,
        "def sum_of_squares_of_n_odds(n):\n    \"\"\"\n    Calculate the sum of the squares of the first n odd numbers.\n    \n    Args:\n        n (int): The number of odd numbers to consider.\n    \n    Returns:\n        int: The sum of the squares of the first n odd numbers.\n    \"\"\"\n    # Step 1: Generate a list of the first n odd numbers.\n    odd_numbers = [2 * i + 1 for i in range(n)]\n\n    # Step 2: Calculate the square of each odd number in the list.\n    squared_odd_numbers = [x ** 2 for x in odd_numbers]\n\n    # Step 3: Sum the squared odd numbers.\n    total_sum = sum(squared_odd_numbers)\n\n    return total_sum"
      ]
    ],
    "MBPP/257": [],
    "MBPP/258": [
      [
        0.9394608736038208,
        "def get_ascii_code(char):\n    \"\"\"Implement a function that takes a character and returns its ASCII code.\"\"\"\n    return ord(char)"
      ],
      [
        0.9217381477355957,
        "def print_ascii_value():\n    \"\"\"\n    This function takes a character as input and prints its ASCII value.\n    \"\"\"\n    char = input(\"Enter a character: \")  # Read a single character from the standard input\n    ascii_value = ord(char)  # Get the ASCII value of the character\n    print(f\"The ASCII value of '{char}' is {ascii_value}\")  # Print the ASCII value"
      ],
      [
        0.921252965927124,
        "def get_ascii(character):\n  \"\"\"\n    Return the ASCII value of a character.\n    :param character: The character to get the ASCII value of.\n    :return: The ASCII value of the character.\n    \"\"\"\n  return ord(character)"
      ],
      [
        0.9146664142608643,
        "def char_to_ascii(char):\n    \"\"\"\n    Converts a character to its ASCII value.\n    \n    Args:\n        char (str): The character to convert.\n        \n    Returns:\n        int: The ASCII value of the character.\n    \"\"\"\n    return ord(char)"
      ],
      [
        0.9146560430526733,
        "def char_to_ascii(char):\n    \"\"\"\n    Converts a character to its ASCII value.\n    \n    Args:\n        char (str): The character to convert.\n        \n    Returns:\n        int: The ASCII value of the character.\n    \"\"\"\n    return ord(char)"
      ]
    ],
    "MBPP/259": [],
    "MBPP/260": [],
    "MBPP/261": [
      [
        0.8869010806083679,
        "def get_first_element(lst):\n    \"\"\"\n    Return the first element of the given list.\n    \"\"\"\n    return lst[0]\n    \n    def get_last_element(lst):\n    \"\"\"\n    Return the last element of the given list.\n    \"\"\"\n    return lst[-1]\n    \n    def get_second_element(lst):\n    \"\"\"\n    Return the second element of the given list.\n    \"\"\"\n    return lst[1]\n    \n    def get_second_to_last_element(lst):\n    \"\"\"\n    Return the second to last element of the given list.\"\"\"\n    result = []\n    for tuple in lst:\n        if tuple[0] % 2 == 1:\n            result.append(tuple[0])\n        else:\n            result.append(tuple[1])\n    return result"
      ],
      [
        0.8802847862243652,
        "def extract_last(a):\n    \"\"\"\n    Extract the last element from a list.\n    >>> extract_last([1, 2, 3])\n    3\n    >>> extract_last([1, 2, 3, 4])\n    4\n    \"\"\"\n    return a[-1]"
      ],
      [
        0.8749561905860901,
        "def switch_indices(arr):\n    \"\"\"\n    Given a list of tuples, return a list of tuples where the first and last elements have been swapped.\n    \"\"\"\n    # Get length of the tuple \n    n = len(arr[0])\n    # Loop over each tuple in the list\n    res = []\n    for tup in arr:\n        # Create a new tuple\n        tmp = []\n        for i in range(n):\n            tmp.append(tup[n - 1 - i])\n        res.append(tuple(tmp))\n    return res\n    def switch_indices(arr):\n    \"\"\"\n    # Get length of the tuple \n    n = len(arr[0])\n    # Loop over each tuple in the list\n    res = []\n    for tup in arr:\n        # Create a new tuple\n        tmp = []\n        for i in range(n):\n            tmp.append(tup[n - 1 - i])\n        res.append(tuple(tmp))\n    return res"
      ]
    ],
    "MBPP/262": [],
    "MBPP/263": [
      [
        0.8980141282081604,
        "def binomial_sum(n):\n    \"\"\"\n    This function calculates the sum of binomial coefficients for a given n.\n    \n    Args:\n        n (int): The value of n for which the sum is to be calculated.\n    \n    Returns:\n        int: The sum of binomial coefficients for the given n.\n    \"\"\"\n    total = 0\n    for i in range(n-1):  # We use n-1 to avoid going out of bounds\n        total += math.comb(n, i) * math.comb(n, i+1)\n    return total"
      ]
    ],
    "MBPP/264": [
      [
        0.8991132378578186,
        "def find_final_position(nums, target):\n    \"\"\" This function receives a list and a target number\n    returns the index of the last occurrence of the target number in the list.\n    \"\"\"\n    last_position = None\n    \n    for idx, num in enumerate(nums):\n        if num == target:\n            last_position = idx\n    \n    return last_position"
      ],
      [
        0.8990560173988342,
        "def find_last_position(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    pos = -1\n    for i in range(len(nums)):\n        if nums[i] == target:\n            pos = i\n    return pos"
      ],
      [
        0.8942476511001587,
        "def find_last_occurrence(arr, n, x):\n    \"\"\"\n    Find the last occurrence of x in arr[] of size n\n    \"\"\"\n    i = n\n    while (i >= 0):\n        if (x == arr[i]):\n            return i\n        i -= 1\n    return -1"
      ]
    ],
    "MBPP/265": [
      [
        0.9146116971969604,
        "def calculate_volume_of_cylinder(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder.\n    \n    Parameters:\n    radius (float): The radius of the cylinder.\n    height (float): The height of the cylinder.\n    \n    Returns:\n    float: The volume of the cylinder.\n    \"\"\"\n    pi = 3.14\n    return pi * radius**2 * height"
      ],
      [
        0.9117310643196106,
        "def volume_of_cylinder(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder.\n    \n    Parameters:\n    radius (float): The radius of the cylinder.\n    height (float): The height of the cylinder.\n    \n    Returns:\n    float: The volume of the cylinder.\n    \"\"\"\n    return math.pi * radius**2 * height"
      ],
      [
        0.9109563827514648,
        "def calculate_cylinder_volume(radius, height):\n  \"\"\"\n  Calculate the volume of a cylinder.\n  \n  Args:\n    radius: The radius of the cylinder.\n    height: The height of the cylinder.\n  \n  Returns:\n    The volume of the cylinder.\n  \"\"\"\n  return math.pi * math.pow(radius, 2) * height"
      ],
      [
        0.9067398905754089,
        "def calculate_cylinder_volume(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder.\n    \n    Parameters:\n    radius (float): The radius of the cylinder.\n    height (float): The height of the cylinder.\n    \n    Returns:\n    float: The volume of the cylinder.\n    \"\"\"\n    volume = math.pi * radius**2 * height\n    return volume"
      ]
    ],
    "MBPP/266": [],
    "MBPP/267": [],
    "MBPP/268": [
      [
        0.8982739448547363,
        "def nth_nonagonal(n):\n  \"\"\"\n  Returns the nth nonagonal number.\n  \n  >>> nth_nonagonal(1)\n  1\n  >>> nth_nonagonal(2)\n  6\n  >>> nth_nonagonal(3)\n  18\n  >>> nth_nonagonal(4)\n  36\n  >>> nth_nonagonal(5)\n  63\n  >>> nth_nonagonal(6)\n  99\n  >>> nth_nonagonal(7)\n  144\n  >>> nth_nonagonal(8)\n  198\n  >>> nth_\"\"\"\n  return n*(7*n-5)//2"
      ],
      [
        0.8874015808105469,
        "def heptagonal_number(n):\n    \"\"\"\n    Returns the nth heptagonal number.\n    \n    >>> heptagonal_number(1)\n    1\n    >>> heptagonal_number(2)\n    7\n    >>> heptagonal_number(3)\n    18\n    >>> heptagonal_number(10)\n    125\n    \"\"\"\n    return n*(5*n - 3)/2 "
      ]
    ],
    "MBPP/269": [
      [
        0.918633759021759,
        "def sequential_search(array, target):\n    \"\"\"\n    \"\"\"\n    for i in range(len(array)):\n        if array[i] == target:\n            return i \n    return -1"
      ],
      [
        0.9186090230941772,
        "def sequential_search(array, target):\n    \"\"\"\n    \"\"\"\n    for i in range(len(array)):\n        if array[i] == target:\n            return i \n    return -1"
      ],
      [
        0.9142885208129883,
        "def search(arr, element):\n    \"\"\"\n    Search for an element in an array\n    :param arr: array\n    :param element: element to search for\n    :return: True if element is in array, False otherwise\n    \"\"\"\n    # Linear search algorithm\n    for item in arr:\n        if item == element:\n            return True\n    return False"
      ],
      [
        0.9131421446800232,
        "def search(arr, x):\n    \"\"\"This function searches for the given element in the given array\"\"\"\n    for i in range(len(arr)):\n        if arr[i] == x:\n            return i\n    return -1"
      ],
      [
        0.9064117670059204,
        "def search(arr, number):\n    \"\"\"\n    \"\"\"\n    for i in range(len(arr)):\n        if arr[i] == number:\n            return True\n    return False"
      ],
      [
        0.906389057636261,
        "def linear_search(arr, element):\n    \"\"\"\n    A linear search algorithm to find the given \n    element in the given array.\n    \"\"\"\n    for i in range(len(arr)):\n        if arr[i] == element:\n            return i\n    return -1"
      ],
      [
        0.906104564666748,
        "def search_array(num, arr):\n    \"\"\"\n    This function searches for a number in the given array. \n    \n    Input:\n    num: The number to search for\n    arr: The array in which to search\n\n    Output: \n    returns True if the number is found. Otherwise, returns False\n    \"\"\"\n    \n    # iterate through the array\n    for i in range(0, len(arr)):\n        # if the current number equals the number being searched for, \n        # return True because we found the number\n        if arr[i] == num:\n            return True\n    \n    # after searching all elements, if we didn't find the number, return False\n    return False"
      ]
    ],
    "MBPP/270": [
      [
        0.916667103767395,
        "def unique(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: bool\n    \"\"\"\n    # Fix: Check if all elements in the input tuple are unique\n    if len(nums) == len(set(nums)):\n        return 'True'\n    else:\n        return 'False'"
      ]
    ],
    "MBPP/271": [],
    "MBPP/272": [
      [
        0.891099214553833,
        "def same_frequency(num1, num2):\n    \"\"\"Do two numbers have the same frequency of digits?\n    >>> same_frequency(551122, 221515)\n    True\n    >>> same_frequency(321142, 3212215)\n    False\n    >>> same_frequency(1212, 2211)\n    True\n    \"\"\"\n    digit_count1 = [0] * 10\n    digit_count2 = [0] * 10\n\n    # Count the frequency of each digit in num1\n    while num1 > 0:\n        digit = num1 % 10\n        digit_count1[digit] += 1\n        num1 //= 10\n\n    # Count the frequency of each digit in num2\n    while num2 > 0:\n        digit = num2 % 10\n        digit_count2[digit] += 1\n        num2 //= 10\n\n    # Check if the frequency of each digit is the same in both numbers\n    for i in range(10):\n        if digit_count1[i] != digit_count2[i]:\n            return False\n\n    return True"
      ],
      [
        0.8904181718826294,
        "def same_frequency(num1, num2):\n    \"\"\"Does number 1 have the same frequency of digits as number 2?\n    \n    >>> same_frequency(551122, 221515)\n    True\n    >>> same_frequency(321142, 3212215)\n    False\n    >>> same_frequency(1212, 2211)\n    True\n    \"\"\"\n    freq1 = {}\n    freq2 = {}\n    temp1 = num1\n    temp2 = num2\n    \n    while temp1 != 0 or temp2 != 0:\n        digit1 = temp1 % 10\n        digit2 = temp2 % 10\n        temp1 //= 10\n        temp2 //= 10\n        \n        if freq1.get(digit1) is None:\n            freq1[digit1] = 1\n        else:\n            freq1[digit1] += 1\n        \n        if freq2.get(digit2) is None:\n            freq2[digit2] = 1\n        else:\n            freq2[digit2] += 1\n    \n    if temp1 != 0 or temp2 != 0:\n        return False\n    \n    return freq1 == freq2"
      ]
    ],
    "MBPP/273": [
      [
        0.9047665596008301,
        "def all_equal(s, char):\n    \"\"\"\n    Check if all characters in a string are equal.\n    :param s: string\n    :param char: character\n    :return: boolean\n    \"\"\"\n    return s.count(char) == len(s)"
      ],
      [
        0.8926793336868286,
        "def all_same(items):\n    \"\"\"All items are the same\"\"\"\n    return len(set(items)) == 1"
      ]
    ],
    "MBPP/274": [
      [
        0.9152544736862183,
        "def check_string(s):\n    \"\"\"\n    Check if a string starts with a substring 'a' followed by two to three 'b's.\n    \"\"\"\n    pattern = '^[a][b]{2,3}$' ## matches if sequence starts with \"a\" and followed by 2 to 3 \"b\"\n    if re.match(pattern, s):\n        return True\n    else:\n        return False\n    \n    def check_string(s):\n    \"\"\"\n    Check if a string starts with a substring 'a' followed by two to three 'b's.\n    \"\"\"\n    pattern = '^[a-zA-Z]*py$' ## matches if sequence only consist uppercase or lowercase alphabets and ends with \"py\"\n    if re.match(pattern, s):\n        return True\n    else:\n        return False"
      ],
      [
        0.8982797265052795,
        "def match_pattern(string):\n    \"\"\"\n    Write a regex to match a string that has an 'a' followed by anything,\n    followed by a 'b'\n    \"\"\"\n    pattern = re.compile(r'abc(?=.*[0-9].*?[0-9].*).*xyz$')\n    return bool(pattern.match(string))"
      ],
      [
        0.8886249661445618,
        "def match_string(s):\n    \"\"\"\n    Match a string that contains 'a' followed by any characters, ending in 'b'.\n    \n    Args:\n        s (str): The string to be matched.\n    \n    Returns:\n        bool or str: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    if not isinstance(s, str):\n        return \"Error: Input is not a string.\"\n    pattern = 'a.*b$'\n    if re.search(pattern, s):\n        return True\n    else:\n        return \"Error: The string does not contain 'a' followed by any characters, ending in 'b'.\""
      ],
      [
        0.8869063258171082,
        "def is_matching(s):\n    \"\"\"\n    \"\"\"\n    pattern = \"Ab?c\"\n    return re.match(pattern, s) is not None"
      ]
    ],
    "MBPP/275": [
      [
        0.9081374406814575,
        "def kConcatenationMaxSum(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    mod = 10**9 + 7\n    n = len(arr)\n    max_sum, max_left, max_right = 0, 0, 0\n    total_sum = sum(arr)\n    temp_sum = 0\n\n    for i in range(n):\n        temp_sum += arr[i]\n        max_sum = max(max_sum, temp_sum)\n        temp_sum = max(0, temp_sum)\n        max_left = max(max_left, temp_sum)\n\n    temp = total_sum\n    for i in range(n - 1, -1, -1):\n        temp -= arr[i]\n        max_right = max(max_right, temp)\n\n    ans = max(max_sum, max_left + max_right + total_sum * (k - 2), 0)\n    return ans % mod"
      ]
    ],
    "MBPP/276": [
      [
        0.9287712574005127,
        "def sum_of_squares_even(n):\n    \"\"\"\n    Return the sum of the squares of all even numbers from 0 to n.\n    \n    >>> sum_of_squares_even(5)\n    30\n    >>> sum_of_squares_even(10)\n    385\n    \"\"\"\n    sum = 0\n    for i in range(n+1):\n        if i % 2 == 0:\n            sum += i**2\n    return sum"
      ]
    ],
    "MBPP/277": [
      [
        0.8877038359642029,
        "def modInverse(n, p) : \n    \"\"\"\n    Returns the modular multiplicative inverse of n under modulo p\n    \"\"\"\n    return power(n, p - 2, p) \n    def modInverse(n, p) : \n    \"\"\"\n    Returns the modular multiplicative inverse of n under modulo p\n    \"\"\"\n    return power(n, p - 2, p) "
      ],
      [
        0.8772658109664917,
        "def countPrimeOccurrences(arr, num):\n    \"\"\"\n    Given an array of integers arr and an integer num, return the number of occurrences of num in arr where num is a prime number.\n    \n    Example 1:\n    \n    Input: arr = [2,3,5,7,11], num = 2\n    Output: 1\n    Explanation: The only prime number in the array is 2.\n    \n    Example 2:\n    \n    Input: arr = [2,3,5,7,11], num = 13\n    Output: 0\n    Explanation: There are no\"\"\"\n    count = 0\n    for i in arr:\n        if i >= 0 and is_prime(i) and i == num:\n            count += 1\n    return count"
      ]
    ],
    "MBPP/278": [],
    "MBPP/279": [
      [
        0.9124315977096558,
        "def find_max_nested(list1, list2, list3):\n    \"\"\"\n    Find the maximum number of elements in a list of lists\n    \"\"\"\n    max_num_elm = 0\n    for lst in [list1, list2, list3]:\n        cur_num_elm = max([len(s) for s in lst])\n        if cur_num_elm > max_num_elm:\n            max_num_elm = cur_num_elm\n    return max_num_elm\n    def find_max_nested(list1, list2, list3):\n    \"\"\"\n    Find the maximum number of elements in a list\"\"\"\n    max_num_elm = 0\n    for lst in [list1, list2, list3]:\n        cur_num_elm = max([len(s) for s in lst])\n        if cur_num_elm > max_num_elm:\n            max_num_elm = cur_num_elm\n    return max_num_elm"
      ]
    ],
    "MBPP/280": [
      [
        0.8887183666229248,
        "def numWays(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return k\n    else:\n        same = [0]*n\n        diff = [0]*n\n        same[0] = k\n        same[1] = k\n        diff[0] = k\n        diff[1] = (k-1)*k\n        for i in range(2,n):\n            same[i] = diff[i-1]\n            diff[i] = (k-1)*(same[i-1] + diff[i-1])\n        return same[n-1] + diff[n-1]"
      ],
      [
        0.8860114812850952,
        "def ways(n, k, mem):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :type mem: dict\n    :rtype: int\n    \"\"\"\n    if n == 1:\n        return k\n    if (n_tuple := (n, k)) in mem:\n        return mem[n_tuple]\n    if k == 1:\n        mem[n_tuple] = 1\n        return 1\n    if n > k:\n        mem[n_tuple] = 0\n        return 0\n    res = mul(ways(n, k - 1, mem), n)\n    res = (res - mul(n - 1, ways(n - 1, k - 1, mem)) + MOD) % MOD\n    mem[n_tuple] = res\n    return res"
      ],
      [
        0.8830456733703613,
        "def numWays(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    same = k\n    different = k * (k - 1)\n    for i in range(2, n):\n        temp = different\n        different = (same + different) * (k - 1)\n        same = temp\n    return same + different"
      ]
    ],
    "MBPP/281": [
      [
        0.8951212167739868,
        "def division(a, b):\n    \"\"\"\n    This function divides two numbers and prints the quotient and remainder.\n    \n    Args:\n        a (int): The first number.\n        b (int): The second number.\n    \"\"\"\n    quotient = a // b\n    remainder = a % b\n    print('Quotient:', quotient)\n    print('Remainder:', remainder)"
      ],
      [
        0.8948271870613098,
        "def division_with_remainder(num1, num2):\n \"\"\"\n Divide two numbers and return the quotient and remainder\n \"\"\"\n quotient = num1 // num2 # integer division\n remainder = num1 % num2 # remainder\n print(f\"{num1} divided by {num2} is {quotient} with a remainder of {remainder}\")\n return quotient"
      ],
      [
        0.8933533430099487,
        "def divide_numbers(numerator, denominator):\n    \"\"\"Divide two numbers and return the quotient.\n    \n    Args:\n        numerator (int or float): The number to be divided.\n        denominator (int or float): The number to divide by.\n    \n    Returns:\n        float: The quotient of the division.\n    \n    Raises:\n        ZeroDivisionError: If the denominator is zero.\n        TypeError: If either numerator or denominator is not a number.\n    \"\"\"\n    try:\n        quotient = numerator / denominator\n        print(\"The quotient is:\", quotient)\n    except ZeroDivisionError:\n        print(\"Error: You are attempting to divide by zero.\")\n    except TypeError:\n        print(\"Error: Invalid input. Both the numerator and denominator should be numbers.\")\n    finally:\n        print(\"This is the end of the division operation.\")"
      ]
    ],
    "MBPP/282": [],
    "MBPP/283": [
      [
        0.9107310175895691,
        "def max_value(arr):\n    \"\"\"\n    Find the maximum value in a list of numbers.\n    \"\"\"\n    \"\"\"\n    max_value = None\n    no_numeric_values = True\n\n    for el in arr:\n        if type(el) == int or type(el) == float:\n            no_numeric_values = False\n            if max_value is None or el > max_value:\n                max_value = el\n\n    if no_numeric_values:\n        return \"No numerical values found.\"\n    else:\n        return max_value"
      ],
      [
        0.9086018800735474,
        "def find_max(lst):\n    \"\"\"\n    Find the maximum value in a list\n    \"\"\"\n    max_val = lst[0]\n    for num in lst:\n        if num > max_val:\n            max_val = num\n\n    return max_val\n    def find_max(lst):\n    \"\"\"\n    Find the maximum value in a list\n    \"\"\"\n    max_val = lst[0]\n    for num in lst:\n        if num > max_val:\n            max_val = num\n\n    return max_val"
      ]
    ],
    "MBPP/284": [
      [
        0.9321038126945496,
        "def sum_divisors(n):\n    \"\"\"\n    Find the sum of all divisors of a positive integer.\n    \n    >>> sum_divisors(1)\n    1\n    >>> sum_divisors(12)\n    28\n    >>> sum_divisors(987654321)\n    220316986\n    \"\"\"\n    divisors = []\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisors.append(i)\n    return sum(divisors)"
      ],
      [
        0.9316538572311401,
        "def sum_divisors(num):\n    \"\"\"\n    Return the sum of all divisors of a positive integer.\n    \n    >>> sum_divisors(10)\n    10\n    >>> sum_divisors(12)\n    16\n    >>> sum_divisors(15)\n    15\n    \"\"\"\n    divisors = [i for i in range(1, num) if num % i == 0]\n    return sum(divisors)"
      ]
    ],
    "MBPP/285": [
      [
        0.9319338798522949,
        "def countInversions(arr):\n    \"\"\"\n    Count the number of inversions in the given array.\n    An inversion is when array[i] > array[j] and i < j\n    \n    :param arr: array of integers\n    :return: number of inversions\n    \"\"\"\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count"
      ],
      [
        0.9316608309745789,
        "def countInversions(arr):\n    \"\"\"\n    Count the number of inversions in the given array.\n    An inversion is when a pair of elements appear in the wrong order.\n    For example, in the array [2, 4, 1, 3, 5], there are three inversions:\n    (2, 1), (4, 1), and (4, 3).\n    \n    :param arr: a list of integers\n    :return: the number of inversions in the array\n    \"\"\"\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count"
      ],
      [
        0.9299689531326294,
        "def count_inversions(arr): \n    \"\"\"\n    Return the number of inversions in the given array.\n    \n    >>> count_inversions([2, 4, 1, 3, 5])\n    3\n    \"\"\"\n    inversion_count = 0\n    for i in range(0, len(arr)): \n        for j in range(i+1, len(arr)): \n            if arr[i] > arr[j]: \n                inversion_count += 1\n    return inversion_count"
      ],
      [
        0.9269877672195435,
        "def count_inversions(arr):\n    \"\"\"\n    Return the number of inversions in the given array.\n    >>> count_inversions([2, 4, 1, 3, 5])\n    3\n    \"\"\"\n    count = 0\n\n    for i in range(len(arr)):\n        for j in range(0, i):\n            if arr[i] < arr[j]:\n                count += 1\n\n    return count"
      ]
    ],
    "MBPP/286": [],
    "MBPP/287": [
      [
        0.9164535999298096,
        "def nested_common(list1, list2):\n    \"\"\"Function to extract nested common elements.\"\"\"\n    list1_flat = set(flatten(list1))\n    list2_flat = set(flatten(list2))\n    \n    common = list1_flat.intersection(list2_flat)\n    \n    return list(common)"
      ]
    ],
    "MBPP/288": [
      [
        0.8929442763328552,
        "def find_max(list_of_tuples):\n    \"\"\"\n    Find the maximum value in each tuple in a list of tuples.\n    \n    Args:\n        list_of_tuples (list): A list of tuples.\n    \n    Returns:\n        list: A list of maximum values.\n    \"\"\"\n    max_values = []\n    for tup in list_of_tuples:\n        max_values.append(max(tup))\n    return max_values"
      ],
      [
        0.888931155204773,
        "def aggregate_tuples(tuples):\n    \"\"\"\n    Given a list of tuples, return the sum of all the numbers in the tuples.\n    \"\"\"\n    total = 0\n    for t in tuples:\n        total += sum(t)\n    return total\n    def aggregate_tuples(tuples):\n    \"\"\"\n    Given a list of tuples, return the sum of all the numbers in the tuples.\n    \"\"\"\n    total = 0\n    for t in tuples:\n        total += sum(t)\n    return total"
      ]
    ],
    "MBPP/289": [
      [
        0.9064934849739075,
        "def countBinaryStrings(N): \n    \"\"\"\n    :type N: int\n    :rtype: int\n    \"\"\"\n    a = [1, 1] \n    for i in range(2, N+1): \n        b = [1] \n        for j in range(1,i): \n            b.append(a[j] + a[j-1]) \n        b.append(1) \n        a = b.copy() \n    count = 0\n    for i in range(len(a)): \n        count += a[i]\n    return count"
      ]
    ],
    "MBPP/290": [
      [
        0.8994672298431396,
        "def find_max_depth(dictionary):\n    \"\"\"\n    Find the maximum depth of a nested dictionary.\n\n    Args:\n        dictionary (dict): The dictionary to find the maximum depth of.\n\n    Returns:\n        int: The maximum depth of the dictionary.\n    \"\"\"\n    if not isinstance(dictionary, dict):\n        return 0\n\n    max_depth = 0\n    for value in dictionary.values():\n        depth = 1 + find_max_depth(value)\n        max_depth = max(max_depth, depth)\n\n    return max_depth"
      ]
    ],
    "MBPP/291": [],
    "MBPP/292": [],
    "MBPP/293": [],
    "MBPP/294": [],
    "MBPP/295": [
      [
        0.8994789719581604,
        "def longestIncreasingSubsequence(seq):\n    \"\"\"\n    Find the longest increasing subsequence in a sequence\n    and return all subsequences with maximum sum\n    \n    :param seq: sequence of integers\n    :return: list of subsequences with maximum sum\n    \"\"\"\n    n = len(seq)\n\n    # Initialize lengths and sums of all increasing subsequences\n    lengths = [1]*n\n    sums = seq[:]\n\n    for i in range (1 , n):\n        for j in range(0 , i):\n            if seq[i] > seq[j] and lengths[i]< lengths[j] + 1:\n                lengths[i] = lengths[j]+1\n                sums[i] = sums[j] + seq[i]\n            # If lengths are equal, choose the one with larger sum\n            elif lengths[i] == lengths[j] + 1 and sums[i] < sums[j] + seq[i]:\n                sums[i] = sums[j] + seq[i]\n\n    # Initialize maximum values\n    maxlen = max(lengths)\n    maxsum = max(sums)\n\n    # sequences is the list of all longest increasing subsequences with maximum sum\n    sequences = [seq[i] for i in range(n) if lengths[i] == maxlen and sums[i] == maxsum]\n\n    return sequences"
      ],
      [
        0.8990825414657593,
        "def max_sum_subarray(arr, k):\n    \"\"\"\n    Find the maximum sum of a subarray with a given sum k.\n    :param arr: List[int]\n    :param k: int\n    :return: int\n    \"\"\"\n    n = len(arr)\n    prefix_sum = [0] * (n+1)\n    prefix_sum[0] = 0\n    max_sum = float('-inf')\n    max_subarray_sum = float('-inf')\n\n    for i in range(1, n+1):\n        prefix_sum[i] = prefix_sum[i-1] + arr[i-1]\n        max_sum = max(max_sum, prefix_sum[i])\n\n    for i in range(1, n+1):\n        for j in range(i):\n            subarray_sum = prefix_sum[i] - prefix_sum[j]\n            if subarray_sum <= k:\n                max_subarray_sum = max(max_subarray_sum, subarray_sum)\n\n    return max_subarray_sum"
      ]
    ],
    "MBPP/296": [],
    "MBPP/297": [
      [
        0.8982522487640381,
        "def largest_product(num, arr): \n    \"\"\"\n    Find the largest product of a number and all of the elements in an array.\n    \n    Args:\n        num (int): The number to multiply.\n        arr (list): The array of numbers.\n    \n    Returns:\n        int: The largest product.\n    \"\"\"\n    best = 0\n    for i in range(len(arr)): \n        curr_prod = num * arr[i]\n        for j in range(i+1, len(arr)): \n            curr_prod *= arr[j]\n            best = max(best, curr_prod) \n    return best"
      ],
      [
        0.8944305181503296,
        "def max_product(lst):\n    \"\"\"\n    This function receives a collection of numerical values (integers),\n    and returns the two elements within that list that, if multiplied\n    together, will yield the absolute highest possible product.\n    \"\"\"\n    \n    # To consider negative numbers and their product which can yield the highest product\n    lst.sort() # First sort the list in increasing order\n    \n    # Checking maximum positive product of first two elements and last two elements\n    product_1 = lst[0] * lst[1]\n    product_2 = lst[-1] * lst[-2]\n    \n    # If first two elements product is higher, return them\n    # Else, return last two elements\n    if product_1 > product_2:\n        return [lst[0], lst[1]]\n    else:\n        return [lst[-1], lst[-2]]"
      ]
    ],
    "MBPP/298": [
      [
        0.9327257871627808,
        "def find_max(num1, num2):\n    \"\"\"\n    Find the maximum of two numbers.\n    \n    Parameters:\n    num1 (int): The first number.\n    num2 (int): The second number.\n    \n    Returns:\n    int: The maximum of the two numbers.\n    \"\"\"\n    return max(num1, num2)"
      ],
      [
        0.9304901361465454,
        "def max_of_two(num_1, num_2):\n    \"\"\"\n    This function returns the maximum of two numbers.\n    \"\"\"\n    return max(num_1, num_2)\n    def max_of_three(num_1, num_2, num_3):\n    \"\"\"\n    This function returns the maximum of three numbers.\n    \"\"\"\n    return max(num_1, num_2)"
      ],
      [
        0.9301162362098694,
        "def max_of_two(x, y):\n    \"\"\"\n    This function returns the maximum of two numbers\n    \"\"\"\n    if x > y:\n        return x\n    else:\n        return y"
      ],
      [
        0.9300880432128906,
        "def max_of_two(x, y):\n    \"\"\"\n    This function returns the maximum of two numbers\n    \"\"\"\n    if x > y:\n        return x\n    else:\n        return y"
      ],
      [
        0.9297508597373962,
        "def max(a, b):\n    \"\"\"\n    Return the maximum of two numbers.\n    \"\"\"\n    return (a if a > b else b)\n    def max(a, b):\n    \"\"\"\n    Return the maximum of two numbers.\n    \"\"\"\n    return (a if a > b else b)"
      ]
    ],
    "MBPP/299": [],
    "MBPP/300": [
      [
        0.88246089220047,
        "def smallestNumber(num): \n    \"\"\"\n    :type num: int\n    :rtype: int\n    \"\"\"\n    least_bit = (num & (-num)) \n    small_num = num + least_bit \n    num = num ^ small_num \n    num = (num) >> 2 \n    small_num = small_num | num \n    return small_num"
      ]
    ],
    "MBPP/301": [
      [
        0.9126754999160767,
        "def cone_volume(radius, height):\n    \"\"\"\n    Calculate the volume of a cone.\n    \n    Args:\n        radius (float): Radius of the base of the cone.\n        height (float): Height of the cone.\n    \n    Returns:\n        float: Volume of the cone.\n    \"\"\"\n    return (1./3) * math.pi * radius**2 * height"
      ],
      [
        0.909123420715332,
        "def cone_volume(r: float, h: float) -> float:\n    \"\"\"\n    Calculate the volume of a cone.\n    \n    Args:\n        r (float): radius of the base of the cone\n        h (float): height of the cone\n    \n    Returns:\n        float: volume of the cone\n    \"\"\"\n    if r <= 0 or h <= 0:\n        return \"Radius and Height must be greater than zero.\"\n    return (1.0/3) * math.pi * r * r * h"
      ],
      [
        0.907709002494812,
        "def calculate_cone_volume(radius, height):\n    \"\"\"\n    Calculate the volume of a cone.\n    \n    Parameters:\n    radius (float): The radius of the cone.\n    height (float): The height of the cone.\n    \n    Returns:\n    float: The volume of the cone.\n    \"\"\"\n    pi = 3.14\n    return (1/3) * pi * radius * radius * height"
      ]
    ],
    "MBPP/302": [
      [
        0.916901707649231,
        "def countPositive(nums):\n    \"\"\"\n    Count the number of positive numbers in a list.\n    \n    Args:\n        nums (list): A list of integers.\n    \n    Returns:\n        int: The number of positive numbers in the list.\n    \"\"\"\n    count = 0\n    for num in nums:\n        if num > 0:\n            count += 1\n    print(\"Number of positive numbers:\", count)"
      ],
      [
        0.914391279220581,
        "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n\n    result = []\n    for num in l:\n        if num > 0:\n          result.append(num)\n    return result"
      ],
      [
        0.9124453067779541,
        "def get_positive_numbers(nums):\n    \"\"\"\n    Given a list of numbers, return a list which contains only the positive numbers.\n    \n    >>> get_positive_numbers([1, -2, 3, -4, 5])\n    [1, 3, 5]\n    \"\"\"\n    result = []\n    for num in nums:\n        if num > 0:\n            result.append(num)\n    return result"
      ],
      [
        0.9122923612594604,
        "def get_positive_numbers(nums):\n    \"\"\"\n    Given a list of numbers, return a list of only the positive numbers.\n    \n    >>> get_positive_numbers([1, 2, 3, -4, -5, -6])\n    [1, 2, 3]\n    \"\"\"\n    positive_nums = []\n    \n    for num in nums:\n        if num > 0:\n            positive_nums.append(num)\n    \n    return positive_nums"
      ]
    ],
    "MBPP/303": [
      [
        0.9032034873962402,
        "def subsequence_sum(arr):\n    \"\"\"\n    Given an array of integers, find the maximum sum of a subsequence with the constraint\n    that no 2 numbers in the sequence should be adjacent in the array.\n    \"\"\"\n    # Write your code here\n    \"\"\"\n    The idea is to use Kadane's algorithm to find the maximum sum of a subsequence.\n    We keep track of the maximum sum and the current sum.\n    If the current sum is negative, we reset it to 0.\n    If the current sum is positive, we update the maximum sum.\n    We return the maximum sum.\n    \"\"\"\n    max_sum = 0\n    current_sum = 0\n    for i in range(len(arr)):\n        current_sum = current_sum + arr[i]\n        if current_sum > max_sum:\n            max_sum = current_sum\n        elif current_sum < 0:\n            current_sum = 0\n\n    return max_sum"
      ],
      [
        0.9023658633232117,
        "def max_sum_no_adjacent(arr):\n        \"\"\"\n        Given a list of integers, write a function that returns the largest sum of non-adjacent numbers. Numbers can be 0 or negative.\n\n        For example, [2, 4, 9, 8] should return 23, since we pick 2, 4, and 9. [5, 1, 1, 5] should return 10, since we pick 5 and 5.\n\n        You may not use the same element twice.\n\n        Example:\n\n        max_sum_no_adjacent([2, 4, 9, 8\"\"\"\n        if not arr:\n            return 0\n        \n        elif len(arr) <= 2:\n            return max(arr)\n        \n        else:\n            dp = [0] * len(arr)\n            dp[0] = arr[0]\n            dp[1] = max(arr[0], arr[1])\n\n            for i in range(2, len(arr)):\n                dp[i] = max(dp[i - 2] + arr[i], dp[i - 1])\n                \n            return dp[-1]"
      ],
      [
        0.9008266925811768,
        "def maxSumNonAdj(arr): \n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    if len(arr) == 0: \n        return 0\n  \n    dp = [0] * len(arr) \n  \n    dp[0] = arr[0] \n    dp[1] = max(arr[0], arr[1]) \n  \n    for i in range(2, len(arr)): \n        dp[i] = max(dp[i - 1], dp[i - 2] + arr[i]) \n  \n    return dp[len(arr) - 1] "
      ],
      [
        0.9006829261779785,
        "def max_subset_of_non_adjacent_numbers(nums):\n    \"\"\"\n    Given a list of numbers, find the maximum sum of a subset of non-adjacent numbers.\n    \n    For example, given nums = [2, 4, 6, 2, 5], the maximum sum is 8 (nums[0] + nums[2] + nums[4]).\n    \n    \"\"\"\n    \n    result = list() \n    result.append(nums[0])   \n    if len(nums) >= 2: \n        result.append(max(nums[1], nums[0])) \n          \n    for i in range(2, len(nums)):  \n        maxValue = max(nums[i] + result[i-2], result[i-1])\n        result.append(maxValue)\n       \n    return result[-1]"
      ]
    ],
    "MBPP/304": [
      [
        0.9148746132850647,
        "def find_longest_even_words(words: List[str]) -> List[str]:\n    \"\"\"\n    Find the longest even words in a list of words.\n    \n    Args:\n        words (List[str]): A list of words.\n    \n    Returns:\n        List[str]: A list of the longest even words.\n    \"\"\"\n    max_length = 0\n    result = []\n    \n    for word in words:\n        if len(word) % 2 == 0:\n            if len(word) > max_length:\n                max_length = len(word)\n                result = [word]\n            elif len(word) == max_length:\n                result.append(word)\n    \n    return result"
      ],
      [
        0.9038605690002441,
        "def find_even_length(lst):\n    \"\"\"\n    Find all the words in a list that have an even length.\n    >>> find_even_length(['apples', 'oranges', 'grapes'])\n    ['apples', 'oranges']\n    \"\"\"\n    even_list = []\n    for l in lst:\n        if len(l) % 2 == 0:\n            even_list.append(l)\n    return even_list"
      ]
    ],
    "MBPP/305": [
      [
        0.9191213846206665,
        "def final_occurrence(array, target):\n    \"\"\"\n    Find the final occurrence of a target in a sorted array.\n    If the target is not found in the array, return -1.\n    \"\"\"\n    # TODO: Write your code here\n    # TODO: Write your code here\n    # TODO: Write your code here\n    # TODO: Write your code here\n    # TODO: Write your code here\n    # TODO: Write your code here\n    # TODO: Write your code here\n    # TODO: Write your code here\n    # TODO: Write your code here\n    # TODO: Write your code here\n    # TODO:\"\"\"\n    lower, upper = 0, len(array)\n\n    while lower < upper:\n        mid = lower + (upper - lower) // 2\n        if array[mid] <= target:\n            lower = mid + 1\n        else:\n            upper = mid\n\n    if lower-1 >= 0 and array[lower-1] == target:\n        return lower - 1\n    else:\n        return \"The element does not exist in the array\";"
      ]
    ],
    "MBPP/306": [
      [
        0.905556857585907,
        "def encodeList(list_to_encode):\n    \"\"\"\n    \"\"\"\n    if not list_to_encode:\n        return []\n    else:\n        tmp = []\n        tmp.append(list_to_encode[0])\n        tmp.append(1)\n        i = 1\n        while i < len(list_to_encode) and list_to_encode[i] == tmp[0]:\n            tmp[1] += 1\n            i += 1\n        return tmp + encodeList(list_to_encode[i:])"
      ],
      [
        0.9048423767089844,
        "def run_length_encoding(input_string):\n    \"\"\"\n    Run length encoding is a fast and simple method of encoding strings. The basic idea is to represent repeated successive characters as a single count and character. For example, the string \"AAAABBBCCDAA\" would be encoded as \"4A3B2C1D2A\".\n    \"\"\"\n    encoding = ''\n    i = 0\n\n    while i < len(input_string):\n        count = 1\n        while i + 1 < len(input_string) and input_string[i] == input_string[i+1]:\n            i += 1\n            \"\"\"\n    encoding = ''\n    i = 0\n\n    while i < len(input_string):\n        count = 1\n        while i + 1 < len(input_string) and input_string[i] == input_string[i+1]:\n            i += 1\n            count += 1\n        encoding += str(count) + input_string[i]\n        i += 1\n\n    return encoding"
      ],
      [
        0.8998106122016907,
        "def run_length_encoding(input_string):\n    \"\"\"\n    Run-length encoding is a fast and simple method of encoding strings. The basic idea is to represent repeated successive characters as a single count and character. For example, the string \"AAAABBBCCDAA\" would be encoded as \"4A3B2C1D2A\".\n    \"\"\"\n    \n    \"\"\"\n    Your solution here\n    \"\"\"\n    if not input_string:\n        return ''\n\n    result = ''\n    current_char = input_string[0]\n    count = 1\n\n    for char in input_string[1:]:\n        if char == current_char:\n            count += 1\n        else:\n            result += current_char + str(count)\n            current_char = char\n            count = 1\n\n    result += current_char + str(count)\n    return result"
      ]
    ],
    "MBPP/307": [],
    "MBPP/308": [
      [
        0.9126358032226562,
        "def five_letter_words(text):\n    \"\"\"\n    Find all five letter words in a text.\n    \n    Args:\n        text (str): The text to search.\n    \n    Returns:\n        list: A list of all five letter words in the text.\n    \"\"\"\n    words = text.split()\n    five_letter_words = [word for word in words if len(word) == 5]\n    unique_words = list(set(five_letter_words))\n    return unique_words"
      ]
    ],
    "MBPP/309": [
      [
        0.9406228065490723,
        "def difference_of_squares(n: int) -> int:\n    \"\"\"\n    The sum of the squares of the first n natural numbers is:\n    1^2 + 2^2 + ... + n^2 = (n(n+1)(2n+1))/6\n    The square of the sum of the first n natural numbers is:\n    (1 + 2 + ... + n)^2 = n(n+1)^2/2\n    The difference between the sum of the squares of the first n natural numbers and the square of the sum is:\n    (n(n+1)(2n+1))/6 - n(n+1\"\"\"\n    sum_of_squares = sum(i**2 for i in range(1, n+1))\n    square_of_sum = sum(range(1, n+1)) ** 2\n    return square_of_sum - sum_of_squares"
      ],
      [
        0.933597207069397,
        "def difference_ss_sqsum(n):\n    \"\"\"\n    Compute the difference between the sum of the squares of the first n natural numbers and the square of the sum.\n    \n    Parameters:\n    n (int): The number of natural numbers to consider.\n    \n    Returns:\n    int: The difference between the sum of the squares and the square of the sum.\n    \"\"\"\n    sum_of_squares = 0\n    square_of_sum = 0\n    \n    # Compute the sum of squares\n    for i in range(1, n+1):\n        sum_of_squares += i*i\n    \n    # Compute the square of sum\n    for i in range(1, n+1):\n        square_of_sum += i\n    square_of_sum *= square_of_sum\n    \n    # Return the difference between sum of squares and square of sum\n    return square_of_sum - sum_of_squares"
      ],
      [
        0.9303397536277771,
        "def find_difference(n):\n    \"\"\"\n    Find the difference between the sum of the squares of the first n natural numbers and the square of the sum.\n    \n    Args:\n       n (int): a positive integer\n    \n    Returns:\n       int: the difference between the sum of the squares of the first n natural numbers and the square of the sum.\n    \"\"\"\n    # Base case\n    if n == 1:\n        return 1\n    else:\n        # Recursive call\n        return n*n*n + find_difference(n-1) - n"
      ],
      [
        0.9260668754577637,
        "def sum_of_squares(n):\n    \"\"\"\n    Return the sum of the squares of the first n natural numbers.\n    \"\"\"\n    if n < 0:\n        return \"Invalid input\"\n\n    result = 0\n    for i in range(1, n + 1):\n        result += i ** 2\n\n    return result\n    \n    def sum_of_squares(n):\n    \"\"\"\n    Return the sum of the squares of the first n natural numbers.\n    \"\"\"\n    if n < 0:\n        return \"Invalid input\"\n\n    result = n * (n + 1) * (2 * n + 1) // 6\n\n    return result"
      ],
      [
        0.9205406308174133,
        "def sumOfSquares(n):\n    \"\"\"\n    Return sum of squares of first n natural numbers\n    \"\"\"\n    # Initialize sum\n    sum = 0\n\n    # Add squares of every element to sum\n    for i in range(1, n+1):\n        sum += i * i\n    return sum\n    def sumOfSquares(n):\n    \"\"\"\n    Return sum of squares of first n natural numbers\n    \"\"\"\n    # Initialize sum\n    sum = 0\n\n    # Add squares of every element to sum\n    for i in range(1, n+1):\n        sum += i * i\n    return sum"
      ],
      [
        0.9199371337890625,
        "def diff_square_sum_sum_square(n):\n    \"\"\"\n    Find the difference between the sum of the squares of the first n natural numbers and the square of the sum.\n    \n    Parameters\n    ----------\n    n : int\n        The number of natural numbers to be considered.\n    \n    Returns\n    -------\n    int\n        The difference between the sum of the squares of the first n natural numbers and the square of the sum.\n    \"\"\"\n    square_sum = 0\n    sum_square = 0\n    for digit in str(n):\n        digit = int(digit)\n        square_sum += digit\n        sum_square += digit ** 2\n    square_sum **= 2\n    return square_sum - sum_square"
      ],
      [
        0.9181469678878784,
        "def calculate_difference(n):\n    \"\"\"\n    Calculate the difference between the sum of the cubes of the first n natural numbers and the sum of the first n natural numbers.\n    \n    Args:\n        n (int): The number of natural numbers to consider.\n    \n    Returns:\n        int: The difference between the sum of the cubes and the sum of the numbers.\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        return \"Error: Input should be a natural number.\"\n    \n    sum_of_cubes = sum([i**3 for i in range(1, n+1)])\n    sum_of_numbers = sum([i for i in range(1, n+1)])\n    \n    return sum_of_cubes - sum_of_numbers"
      ]
    ],
    "MBPP/310": [
      [
        0.8749122023582458,
        "def find_num():\n  \"\"\"\n  Find the number\"\"\"\n  for i in range(100,1000):\n    hun = i // 100\n    ten = (i % 100) // 10\n    one = i % 10\n    if hun != 3*ten or ten != 3*one:\n      continue\n    if i * 1.49 != int(str(one) + str(ten) + str(hun)):\n      continue\n    return i"
      ],
      [
        0.8738114237785339,
        "def find_number():\n    \"\"\"\n    \"\"\"\n    for i in range(10000,100000):\n        ones = i % 10\n        tens = (i // 10) % 10\n        hundreds = (i // 100) % 10\n        thousands = (i // 1000) % 10\n        tenthousands = (i // 10000) % 10\n\n        if tenthousands == 4*thousands and thousands == 3*hundreds and hundreds == 2*tens and tens == 2*ones:\n            switch_i = ones*10000 + tens*1000 + hundreds*100 + thousands*10 + tenthousands\n            if switch_i == i * 1.45:\n                return i"
      ]
    ],
    "MBPP/311": [
      [
        0.9027283191680908,
        "def find_min(lst):\n    \"\"\"\n    Find the minimum number in a list and its index(es).\n    \n    Parameters:\n    lst (list): A list of numbers.\n    \n    Returns:\n    tuple: A tuple containing the minimum number and a list of indices where the minimum number occurs.\n    \"\"\"\n    min_num = lst[0]\n    min_index = [0]  # Adding 0 as the initial index\n    for i in range(1, len(lst)):\n        if lst[i] < min_num:\n            min_num = lst[i]\n            min_index = [i] \n        elif lst[i] == min_num:\n            min_index.append(i)\n    return min_num, min_index"
      ],
      [
        0.8997608423233032,
        "def find_min_index(list_of_nums):\n    \"\"\"\n    Find the index of the minimum value in a list of numbers.\n    \n    Args:\n       list_of_nums(list): a list of numbers\n    Returns:\n       int: the index of the minimum element\n    \"\"\"\n    minimum = min(list_of_nums)\n    return list_of_nums.index(minimum)"
      ]
    ],
    "MBPP/312": [
      [
        0.9223708510398865,
        "def rearrange_array(input_array):\n    \"\"\"\n    Rearrange positive and negative numbers in a given array\n    \n    Args:\n       input_array(list): List of numbers\n    Returns:\n       list: Rearranged list\n    \"\"\"\n    # sort the array in ascending order\n    input_array.sort()\n    \n    # define an empty result array\n    output_array = []\n\n    while input_array:\n        # add the largest element\n        output_array.append(input_array.pop(-1))\n        if input_array:\n            # add the smallest element\n            output_array.append(input_array.pop(0))\n    \n    return output_array"
      ],
      [
        0.9213085174560547,
        "def rearrange(arr):\n    \"\"\"\n    Rearrange positive and negative numbers in O(n) time and O(1) extra space\n    \"\"\"\n    # TODO: Write your code here\n    # Hint: Use two pointers technique\n    #       One pointer to traverse the array from left to right\n    #       Another pointer to traverse the array from right to left\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        while arr[left] < 0 and left < right:\n            left += 1\n        while arr[right] >= 0 and left < right:\n            right -= 1\n\n        if left < right:\n            arr[left], arr[right] = arr[right], arr[left]\n\n    return arr"
      ],
      [
        0.9146265983581543,
        "def rearrangeNegativePositive(arr, n):\n    \"\"\"\n    Rearrange positive and negative numbers in O(n) time and O(1) extra space\n    \"\"\"\n    # code here\n    \n    def rearrange(self,arr, n):\n    \"\"\"\n    Rearrange positive and negative numbers in O(n) time and O(1) extra space\n    \"\"\"\n    left = 0\n    right = n - 1\n\n    while left < right:\n        while arr[left] < 0 and left < right:\n            left += 1\n\n        while arr[right] >= 0 and left < right:\n            right -= 1\n\n        if left < right:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1"
      ]
    ],
    "MBPP/313": [
      [
        0.8918388485908508,
        "def aggregate_tuples(tuples):\n    \"\"\"\n    Given a list of tuples, return the sum of all the numbers in the tuples.\n    \"\"\"\n    total = 0\n    for t in tuples:\n        total += sum(t)\n    return total\n    def aggregate_tuples(tuples):\n    \"\"\"\n    Given a list of tuples, return the sum of all the numbers in the tuples.\n    \"\"\"\n    total = 0\n    for t in tuples:\n        total += sum(t)\n    return total"
      ],
      [
        0.8890612721443176,
        "def add_tuple(tpl):\n    \"\"\"\n    Add up all the odd elements of a tuple\"\"\"\n    \n    # Extract elements at odd indices\n    odd_indices_elements = tpl[1::2]\n\n    # Filter out even elements from those extracted earlier\n    even_elements = list(filter(lambda x: x % 2 == 0, odd_indices_elements))\n\n    # Calculate the sum of the even elements and return that value\n    return sum(even_elements)"
      ]
    ],
    "MBPP/314": [
      [
        0.9130324125289917,
        "def numSquares(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    dp = [0] + [sys.maxsize]*n\n    for i in range(1, n+1):\n        for j in range(1, int(i**0.5)+1):\n            dp[i] = min(dp[i], dp[i-j*j] + 1)\n    return dp[-1]"
      ],
      [
        0.9129249453544617,
        "def numSquares(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            dp[i] = min(dp[i], dp[i - j * j] + 1)\n            j += 1\n            \n    return dp[n]"
      ],
      [
        0.9056128263473511,
        "def perfectSquares(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    dp = [0]\n    for i in range(1, n + 1):\n        dp.append(min([dp[i - j * j] for j in range(1, int(math.sqrt(i)) + 1)] + [dp[i - 1]]))\n    return dp[n]\n    \n    def numSquares(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    dp = [0]\n    for\"\"\"\n    count = numSquares(n)\n    result = []\n    while n:\n        for i in range(int(math.sqrt(n)), 0, -1):\n            if n >= i * i and numSquares(n - i * i) == count - 1:\n                result.append(i * i)\n                n -= i * i\n                count -= 1\n                break\n    return result"
      ],
      [
        0.8952136635780334,
        "def sumOfSquares(n):\n    \"\"\"\n    Return sum of squares of first n natural numbers\n    \"\"\"\n    # Initialize sum\n    sum = 0\n\n    # Add squares of every element to sum\n    for i in range(1, n+1):\n        sum += i * i\n    return sum\n    def sumOfSquares(n):\n    \"\"\"\n    Return sum of squares of first n natural numbers\n    \"\"\"\n    # Initialize sum\n    sum = 0\n\n    # Add squares of every element to sum\n    for i in range(1, n+1):\n        sum += i * i\n    return sum"
      ],
      [
        0.8951255083084106,
        "def sqrt(x): \n    \"\"\"\n    Return the square root of x.\n    \"\"\"\n    if x == 0 or x == 1: \n        return x \n      \n    i = 1 \n    res = 1 \n    while res <= x: \n        i += 1 \n        res = i * i \n      \n    return i-1\n    def sqrt(x): \n    \"\"\"\n    Return the square root of x.\n    \"\"\"\n    if x == 0 or x == 1: \n        return x \n      \n    i = 1 \n    res = 1 \n    while res <= x: \n        i += 1 \n        res = i * i \n      \n    return i-1"
      ],
      [
        0.8941684365272522,
        "def search(lst):\n    \"\"\"\n    Given a list of numbers, return the greatest number whose square is less than or equal to the sum of the list.\n    \n    >>> search([1, 2, 3, 4])\n    2\n    >>> search([1, 2, 3, 4, 5])\n    3\n    >>> search([1, 2, 3, 4, 5, 6])\n    4\n    \"\"\"\n    freq = {}\n    for num in lst:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    greatest = -1\n    for num, count in freq.items():\n        if count >= num*num:\n            greatest = max(greatest, num)\n    return greatest"
      ]
    ],
    "MBPP/315": [],
    "MBPP/316": [],
    "MBPP/317": [],
    "MBPP/318": [
      [
        0.9079719185829163,
        "def negative_stats(numbers):\n    \"\"\"\n    Return the number of negative numbers in a list and the sum of all negative numbers.\n    \n    >>> negative_stats([1, -3, 4, -2, 5])\n    (2, -5)\n    \"\"\"\n    negative_nums = [num for num in numbers if num < 0]\n    return len(negative_nums), sum(negative_nums)"
      ],
      [
        0.9039167165756226,
        "def negative(int_list):\n    \"\"\"\n    Return a list of the negative integers in the input list.\n    \n    >>> negative([1, -2, 3, -4])\n    [-2, -4]\n    \"\"\"\n    return [num for num in int_list if num < 0]"
      ]
    ],
    "MBPP/319": [],
    "MBPP/320": [
      [
        0.9066583514213562,
        "def hamming_weight(n):\n    \"\"\"\n    Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).\n    \n    Note:\n    \n    Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\n    In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the\"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"
      ],
      [
        0.9057872295379639,
        "def count_bits(num):\n    \"\"\"\n    Write a function that takes an integer as input, and returns the number of bits that are equal to one in the binary representation of that number. You can guarantee that input is non-negative.\n\n    Example: The binary representation of 1234 is 10011010010, so the function should return 5 in this case\n    \"\"\"\n    count = 0\n    while num != 0:\n        num //= 2\n        count += 1\n    return count"
      ]
    ],
    "MBPP/321": [],
    "MBPP/322": [
      [
        0.9076259136199951,
        "def sort_list(tuples):\n    \"\"\"\n    A function to sort a list of tuples by the second item in each tuple.\n    \"\"\"\n    return sorted(tuples, key=lambda x: x[1])"
      ]
    ],
    "MBPP/323": [
      [
        0.9268591403961182,
        "def is_valid_triangle(a, b, c): \n    \"\"\"\n    Check if a triangle is valid or not\n    :param a: side a\n    :param b: side b\n    :param c: side c\n    :return: True if the triangle is valid else False\n    \"\"\"\n    # A triangle should have 3 sides\n    if a + b <= c or a + c <= b or b + c <= a: \n        return False\n\n    # The sum of any two sides should always be greater than the third side\n    if a + b > c and a + c > b and b + c > a: \n        return True\n    return False"
      ],
      [
        0.9236353039741516,
        "def is_valid_triangle(a, b, c):\n    \"\"\"\n    Write a function that accepts the three sides of a triangle as arguments.\n    The function should return True if a triangle can be built with the sides\n    and False otherwise.\n    \n    >>> is_valid_triangle(1, 1, 1)\n    True\n    >>> is_valid_triangle(1, 1, 3)\n    False\n    \"\"\"\n    if (a + b) > c and (a + c) > b and (b + c) > a:\n        return True\n    else:\n        return False"
      ],
      [
        0.9233072996139526,
        "def valid_triangle(side1, side2, side3): \n    \"\"\"\n    Check if a triangle is valid given the length of the three sides.\n    \n    :param side1: length of side 1\n    :param side2: length of side 2\n    :param side3: length of side 3\n    :return: True if the triangle is valid, False otherwise\n    \"\"\"\n    a = side1 + side2 \n    b = side1 + side3 \n    c = side2 + side3 \n       \n    if (a > side3) and (b > side2) and (c > side1): \n        return True\n    else: \n        return False"
      ],
      [
        0.9221632480621338,
        "def is_valid(side1, side2, side3):\n    \"\"\"\n    Check if a triangle is valid\n    :param side1: first side\n    :param side2: second side\n    :param side3: third side\n    :return: True if the triangle is valid, False otherwise\n    \"\"\"\n    if (side1 + side2 > side3) and (side1 + side3 > side2) and (side2 + side3 > side1):\n        return True\n    else:\n        return False"
      ],
      [
        0.9220161437988281,
        "def valid_triangle(a, b, c):\n    \"\"\"\n    Check if a triangle is valid or not\n    :param a: side a\n    :param b: side b\n    :param c: side c\n    :return: True if triangle is valid else False\n    \"\"\"\n    # Use inequality theorem \n    return a + b > c and a + c > b and b + c > a"
      ],
      [
        0.9122471213340759,
        "def is_valid_triangle(a, b, c):\n    \"\"\"\n    Determines if a triangle is valid given the length of its sides.\n\n    :param a: length of side a\n    :param b: length of side b\n    :param c: length of side c\n    :return: True if a valid triangle, False otherwise\n    \"\"\"\n    if a + b > c and b + c > a and a + c > b:\n        return True\n    return False"
      ]
    ],
    "MBPP/324": [
      [
        0.8879648447036743,
        "def arithmeticSum(start, end, diff):\n    \"\"\"\n    Calculate the sum of an arithmetic series\n    :param start: the first term\n    :param end: the last term\n    :param diff: the common difference\n    :return: the sum of the series\n    \"\"\"\n    # Calculate the number of terms\n    n = (end - start) / diff + 1\n    # Calculate the sum\n    mysum = n * (start + end) / 2\n    return mysum"
      ]
    ],
    "MBPP/325": [],
    "MBPP/326": [
      [
        0.8942587375640869,
        "def ends_with_letter(word):\n    \"\"\"\n    Returns True if the word ends with a letter, False otherwise.\n    \"\"\"\n    return word.endswith(letter)\n    def ends_with_letter(word):\n    \"\"\"\n    Returns True if the word ends with a letter, False otherwise.\n    \"\"\"\n    return word.endswith(letter)"
      ],
      [
        0.8837177157402039,
        "def last_char_s(arr):\n    \"\"\"\n    Return a list of words that end in 's'\n    \"\"\"\n    return [word for word in arr if word[-1] == 's']\n    \n    def last_char_s(arr):\n    \"\"\"\n    Return a list of words that end in 's'\n    \"\"\"\n    return [word for word in arr if word.endswith('s')]"
      ]
    ],
    "MBPP/327": [
      [
        0.9112409949302673,
        "def count_strings(lst):\n    \"\"\"\n    Return the count of the number of strings where the string length is 2 or more and the first and last character are the same.\n    \n    >>> count_strings(['aba', 'xyz', 'aa', 'x', 'bbb'])\n    3\n    >>> count_strings(['', 'x', 'xy', 'xyx', 'xx'])\n    2\n    >>> count_strings(['aaa', 'be', 'abc', 'hello'])\n    1\n    \"\"\"\n    count = 0\n    \n    # Iterate through the list\n    for s in lst:\n        # Check if string length is greater than 2 and first and last character is same\n        if len(s) >= 2 and s[0] == s[-1]:\n            count += 1\n    \n    return count"
      ]
    ],
    "MBPP/328": [
      [
        0.8966752290725708,
        "def find_max_divisor(nums):\n    \"\"\"\n    Find the maximum divisor that divides all numbers in the list.\n    \n    Args:\n        nums (list): A list of integers.\n    \n    Returns:\n        int: The maximum divisor that divides all numbers in the list.\n    \"\"\"\n    n = len(nums)\n    if n < 2:\n        return nums[0]\n\n    max_div = 0\n    for i in range(n-1):\n        num = nums[i]\n        for j in range(i+1, n):\n            if num % nums[j] == 0 and nums[j] > max_div:\n                max_div = nums[j]\n                break  # Exit the inner loop if a larger divisor is found\n    return max_div"
      ]
    ],
    "MBPP/329": [
      [
        0.9190161824226379,
        "def sum_smallest_three(arr):\n    \"\"\"\n    Given an array of integers, return the sum of the three smallest numbers.\n    \n    >>> sum_smallest_three([1, 2, 3, 4, 5])\n    6\n    >>> sum_smallest_three([1, 1, 1])\n    3\n    >>> sum_smallest_three([1, 2, 3, 4, 5, 6])\n    6\n    >>> sum_smallest_three([1, 2, 3, 4, 5, 6, 7])\n    9\n    \"\"\"\n    if len(arr) < 3:\n        return sum(arr)\n    smallest_nums = [float('inf')] * 3\n    for num in arr:\n        if num < smallest_nums[2]:\n            smallest_nums = sorted(smallest_nums[:-1] + [num])\n    return sum(smallest_nums)"
      ],
      [
        0.9142948389053345,
        "def two_smallest_numbers(lst):\n    \"\"\"\n    Given a list of numbers, return the sum of the two lowest positive numbers.\n    \n    Examples\n    two_smallest_numbers([19, 5, 42, 2, 77]) \u279e 7\n    \n    two_smallest_numbers([10, 56, 32, 4, 5, 7]) \u279e 11\n    \n    two_smallest_numbers([10, -80, 90, 100]) \u279e 19\n    \"\"\"\n    smallest = lst[0]\n    second_smallest = lst[1]\n    \n    for i in lst:\n        if i < smallest:\n            second_smallest = smallest\n            smallest = i\n        elif i < second_smallest:\n            second_smallest = i\n    \n    return (smallest, second_smallest)"
      ],
      [
        0.9009478092193604,
        "def sum_of_first_three(arr, index=0):\n    \"\"\"\n    Given an array of integers, return the sum of the first three elements.\n    \n    If the array has fewer than three elements, return the sum of all elements.\n    \n    For example, given [1, 2, 3, 4], return 6.\n    \n    Given [1, 2], return 3.\n    \n    Given [1], return 1.\n    \n    Given [], return 0.\n    \"\"\"\n    if index >= len(arr):\n        return 0\n    \n    if index == 2:\n        return max(arr[index] + arr[index - 1] + arr[index - 2], 0)\n    \n    return arr[index] + sum_of_first_three(arr, index + 1)"
      ],
      [
        0.9008499979972839,
        "def sum_of_list(numbers):\n    \"\"\"\n    Return the sum of all positive numbers in the list.\n    \n    >>> sum_of_list([1, 2, 3, 4, 5])\n    15\n    >>> sum_of_list([1, -2, 3, -4, 5])\n    9\n    >>> sum_of_list([1, -2, 3, -4, 5, 6])\n    16\n    \"\"\"\n    total = 0\n    for num in numbers:\n        if num >= 0 and num % 3 != 0:\n            total += num\n    return total"
      ]
    ],
    "MBPP/330": [],
    "MBPP/331": [
      [
        0.9009892344474792,
        "def find_smallest_range(dictionary):\n    \"\"\"\n    Find the smallest range that includes a number from each of the sorted arrays.\n    :param dictionary: a dictionary of sorted arrays\n    :return: a tuple of the smallest range\n    \"\"\"\n    min_range = float('inf')\n    min_key = None\n    for key, value in dictionary.items():\n        range_val = max(value) - min(value)\n        if range_val < min_range:\n            min_range = range_val\n            min_key = key\n    return min_key"
      ]
    ],
    "MBPP/332": [
      [
        0.9050012230873108,
        "def string_stats(s):\n    \"\"\"\n    Given a string, this function returns a tuple with three elements:\n    1. The number of letters in the string\n    2. The number of digits in the string\n    3. The number of other characters in the string (anything that is not a letter or a digit)\n    \"\"\"\n    num_letter = 0\n    num_digit = 0\n    num_other = 0\n    for c in s:\n        if c.isalpha():\n            num_letter += 1\n        elif c.isdigit():\n            num_digit += 1\n        else:\n            num_other += 1\n            \n    return (num_letter, num_digit, num_other)"
      ],
      [
        0.903843879699707,
        "def digit_count(s):\n    \"\"\"\n    Return two integers. The first is the count of digits in the string, the second is the count of each digit.\n    \"\"\"\n    count = 0\n    freq = {str(x): 0 for x in range(10)}\n    for char in s:\n        if char.isdigit():\n            count += 1\n            freq[char] += 1\n    return count, freq\n    def digit_count(s):\n    \"\"\"\n    Return two integers. The first is the count of digits in the string, the second is the count of each digit.\n\"\"\"\n    count = 0\n    freq = {str(x): 0 for x in range(10)}\n    for char in s:\n        if char.isdigit():\n            count += 1\n            freq[char] += 1\n    return count, freq"
      ]
    ],
    "MBPP/333": [
      [
        0.8998741507530212,
        "def count_odd(lst):\n    \"\"\"\n    Return the number of elements in the list that are odd.\n    \"\"\"\n    count = 0\n    for i in lst:\n        if i % 2 != 0:\n            count += 1\n    return count\n    def count_odd(lst):\n    \"\"\"\n    Return the number of elements in the list that are odd.\n    \"\"\"\n    count = 0\n    for i in lst:\n        if i % 2 != 0:\n            count += 1\n    return count"
      ]
    ],
    "MBPP/334": [
      [
        0.9218735098838806,
        "def find_difference(lst):\n    \"\"\"\n    Given a list of integers, return the difference between the largest and smallest integers in the list.\n    \n    For example:\n    \n    [1, 2, 3] -> 2 # since 3 - 1 = 2\n    [10, 11, 12] -> 2 # since 12 - 10 = 2\n    [1, 1, 1] -> 0 # since 1 - 1 = 0\n    [1, 1, 2] -> 1 # since 2 - 1\"\"\"\n    return max(lst) - min(lst)"
      ],
      [
        0.9218732714653015,
        "def find_difference(lst):\n    \"\"\"\n    Given a list of integers, return the difference between the largest and smallest integers in the list.\n    \n    For example:\n    \n    [1, 2, 3] -> 2 # since 3 - 1 = 2\n    [10, 11, 12] -> 2 # since 12 - 10 = 2\n    [1, 1, 1] -> 0 # since 1 - 1 = 0\n    [1, 1, 2] -> 1 # since 2 - 1\"\"\"\n    return max(lst) - min(lst)"
      ],
      [
        0.9190673232078552,
        "def find_difference(numbers):\n    \"\"\"\n    Find the difference between the biggest and the smallest number in a list.\n    \n    Args:\n       numbers(list): list of numbers\n    Returns:\n       difference (int): the difference between biggest and smallest number\n    \"\"\"\n    return max(numbers) - min(numbers)"
      ],
      [
        0.9140927195549011,
        "def max_difference(lst):\n    \"\"\"\n    Given a list of integers, find the maximum difference between any two elements.\n    \n    >>> max_difference([1, 2, 3, 4, 5])\n    4\n    >>> max_difference([10, 9, 8, 7, 6])\n    -1\n    >>> max_difference([10, 9, 8, 7, 6, 5, 4, 3, 2, 1])\n    -9\n    \"\"\"\n    diff = 0\n    for i in range(len(lst)-1):\n        if abs(lst[i+1] - lst[i]) > diff:\n            diff = abs(lst[i+1] - lst[i])\n    print(diff)"
      ],
      [
        0.9135929942131042,
        "def find_difference(numbers):\n    \"\"\"Find the difference between the highest value and the lowest value of an array of numbers.\"\"\"\n    return max(numbers) - min(numbers)"
      ],
      [
        0.9124774932861328,
        "def max_difference(numbers):\n    \"\"\"\n    Find the maximum difference between any two elements in a list of numbers.\n    \n    Args:\n       numbers(list): list of numbers\n    Returns:\n       difference (int): maximum difference between any two elements\n    \"\"\"\n    max_diff = 0\n    for i in range(len(numbers)-1):\n        for j in range(i+1, len(numbers)):\n            cur_diff = abs(numbers[i] - numbers[j])\n            if cur_diff > max_diff:\n                max_diff = cur_diff\n    return max_diff"
      ]
    ],
    "MBPP/335": [],
    "MBPP/336": [],
    "MBPP/337": [
      [
        0.8864381313323975,
        "def count(S, m, n):\n    \"\"\"\n    :type S: List[int]\n    :type m: int\n    :type n: int\n    :rtype: int\n    \"\"\"\n    table = [0 for k in range(n+1)]\n    table[0] = 1\n    for i in range(0, m):\n        for j in range(S[i], n+1):\n            table[j] += table[j-S[i]]\n    return table[n]"
      ]
    ],
    "MBPP/338": [
      [
        0.9017764925956726,
        "def validate_binary(binary):\n    \"\"\"\n    Check if a string is a valid binary string\n    :param binary: string\n    :return: bool\n    \"\"\"\n    return all([digit in '01' for digit in binary])"
      ],
      [
        0.8980107307434082,
        "def is_valid_binary_string(input_string):\n    \"\"\"\n    Check if the given string is a valid binary string.\n    A binary string is a string containing only '0' and '1'.\n    Args:\n        input_string (str): The input string to be checked.\n    Returns:\n        bool: True if the string is a valid binary string, False otherwise.\n    \"\"\"\n    for char in input_string:\n        if char not in '01':\n            return False\n    return True"
      ],
      [
        0.8969879746437073,
        "def isValidBinary(bin_num):\n    \"\"\"\n    Checks if a given string is a valid binary number\n    :param bin_num: string\n    :return: bool\n    \"\"\"\n    # Regex expression to match binary numbers\n    pattern = re.compile('^[01]+$')\n    return bool(pattern.match(bin_num))"
      ]
    ],
    "MBPP/339": [
      [
        0.8985863924026489,
        "def remove_longest_single_char_substring(input_string):\n    \"\"\"\n    Remove the longest substring of single character\"\"\"\n    longest_string = \"\"\n    temp_string = \"\"\n    for c in input_string:\n        if c == temp_string[-1:]:\n            temp_string += c\n        else:\n            if len(temp_string) > len(longest_string):\n                longest_string = temp_string\n            temp_string = c\n        if len(temp_string) > len(longest_string):\n            longest_string = temp_string\n \n    return input_string.replace(longest_string, \"\")"
      ]
    ],
    "MBPP/340": [],
    "MBPP/341": [
      [
        0.9331783056259155,
        "def has_unique_characters(s): \n    \"\"\"\n    Given a string, determine if it is comprised of all unique characters. For example, the string 'abcde' has all unique characters and should return True. The string 'aabcde' contains duplicate characters and should return False.\n    \"\"\"\n    char_set = [False] * 256 \n\n    for i in range(0, len(s)): \n        val = ord(s[i]) \n\n        # If CHAR_SET is already True,  \n        # return False         \n        if char_set[val]: \n            return False\n\n        # If the character is not present \n        # in character array, then mark it \n        # as True  \n        char_set[val] = True \n\n    return True"
      ],
      [
        0.9308285117149353,
        "def uniqueCharacters(str):\n  \"\"\"\n  Return True if the given string has only unique characters.\n  \"\"\"\n  s = set(str)\n  return len(s) == len(str)\n    def uniqueCharacters(str):\n  \"\"\"\n  Return True if the given string has only unique characters.\n  \"\"\"\n  s = set(str)\n  return len(s) == len(str)"
      ]
    ],
    "MBPP/342": [
      [
        0.8861914277076721,
        "def remove_element(nested_list, target):\n    \"\"\"\n    Remove all elements from nested_list that == target.\n    :type nested_list: list\n    :type target: int\n    :rtype: list\n    \"\"\"\n    result = []\n    for i in nested_list:\n        if type(i) is list:\n            i = remove_element(i, target)\n            if i:\n                result.append(i)\n        elif i != target:\n            result.append(i)\n    return result"
      ],
      [
        0.872853696346283,
        "def remove_first_element(lists):\n    \"\"\"\n    Remove the first element from each sublist in the given list of lists.\n    \n    Args:\n    - lists: A list of lists.\n    \n    Returns:\n    - A new list of lists with the first element removed from each sublist.\n    \"\"\"\n    # Use list slicing to remove the first element of each sublist\n    return [lst[1:] for lst in lists]"
      ]
    ],
    "MBPP/343": [
      [
        0.8836061358451843,
        "def is_arithmetic(array):\n    \"\"\"Return True if array is an arithmetic progression.\"\"\"\n    \n    # ensure the array has at least 3 elements\n    if len(array) < 3:\n        return False\n\n    # compute the common difference between the first two elements\n    diff = array[1] - array[0]\n\n    # for each subsequent pair of elements\n    for i in range(2, len(array)):\n        # if the difference does not match the common difference, return False\n        if array[i] - array[i - 1] != diff:\n            return False\n\n    # if we've made it here, the array is an arithmetic progression\n    return True"
      ],
      [
        0.8831528425216675,
        "def nth_term(first_term, common_difference, n):\n    \"\"\"\n    Return the nth term of an arithmetic sequence.\n    \n    Args:\n        first_term (int): The first term of the sequence.\n        common_difference (int): The common difference between terms.\n        n (int): The index of the term to return.\n    \n    Returns:\n        int: The nth term of the sequence.\n    \"\"\"\n    return first_term + (n - 1) * common_difference"
      ]
    ],
    "MBPP/344": [
      [
        0.8958063721656799,
        "def compute_triangles(r):\n    \"\"\"\n    Compute the number of triangles in a square of side length 2*r + 1.\n    \n    Parameters\n    ----------\n    r : int\n        The radius of the square.\n        \n    Returns\n    -------\n    int\n        The number of triangles in the square.\n    \"\"\"\n    num_points = 2*r + 1\n    return num_points**2"
      ],
      [
        0.8826830387115479,
        "def circle(r=5):\n    \"\"\"\n    This function calculates the circumference and area of a circle.\n    \n    Parameters\n    ----------\n    r : float\n        The radius of the circle.\n    \n    Returns\n    -------\n    circumference : float\n        The circumference of the circle.\n    area : float\n        The area of the circle.\n    \"\"\"\n    pi = 3.14\n    circumference = 2*pi*r\n    area = pi*r**2\n    return circumference, area"
      ]
    ],
    "MBPP/345": [
      [
        0.8961595892906189,
        "def find_other_angle(angle):\n    \"\"\"\n    Find the other angle in a triangle given one angle.\n    \n    Args:\n        angle (int): one angle in the triangle\n        \n    Returns:\n        int: the other angle in the triangle\n    \"\"\"\n    return 180 - angle"
      ],
      [
        0.8859964609146118,
        "def angle_of_triangle(a, b, c):\n    \"\"\"\n    Given the lengths of all three sides of a triangle, return the angle opposite the shortest side.\n    \n    :param a: length of side a\n    :param b: length of side b\n    :param c: length of side c\n    :return: angle opposite side a\n    \"\"\"\n    angle = math.acos((b**2 + c**2 - a**2) / (2*b*c))\n    return math.degrees(angle)"
      ]
    ],
    "MBPP/346": [
      [
        0.8901882767677307,
        "def find_max(list_of_tuples):\n    \"\"\"\n    Find the maximum value in each tuple in a list of tuples.\n    \n    Args:\n        list_of_tuples (list): A list of tuples.\n    \n    Returns:\n        list: A list of maximum values.\n    \"\"\"\n    max_values = []\n    for tup in list_of_tuples:\n        max_values.append(max(tup))\n    return max_values"
      ],
      [
        0.8896616697311401,
        "def find_max(*args):\n    \"\"\"\n    Find the maximum value in a list of numbers.\n    \n    Args:\n        *args: A list of numbers.\n    \n    Returns:\n        The maximum value in the list.\n    \"\"\"\n    if isinstance(args[0], tuple):\n        return [max(t) for t in args]\n    else:\n        return max(args)"
      ],
      [
        0.8832653760910034,
        "def find_max(lst):\n    \"\"\"\n    Find the maximum value in a list\n    \"\"\"\n    max_val = lst[0]\n    for num in lst:\n        if num > max_val:\n            max_val = num\n\n    return max_val\n    def find_max(lst):\n    \"\"\"\n    Find the maximum value in a list\n    \"\"\"\n    max_val = lst[0]\n    for num in lst:\n        if num > max_val:\n            max_val = num\n\n    return max_val"
      ]
    ],
    "MBPP/347": [],
    "MBPP/348": [],
    "MBPP/349": [
      [
        0.888716995716095,
        "def lucas(n):\n    \"\"\"\n    Return the nth number in the Lucas sequence.\n    The Lucas sequence is the sequence of integers that begins with 2, 1 and\n    where every number is the sum of the previous two.\n    This function should return an int.\n    >>> lucas(0)\n    2\n    >>> lucas(1)\n    1\n    >>> lucas(2)\n    3\n    >>> lucas(3)\n    4\n    >>> lucas(10)\n    123\n    \"\"\"\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        lucas_values = [2, 1]\n        for i in range(2, n + 1):\n            lucas_values.append(sum(lucas_values[-2:]))\n        return lucas_values[n]"
      ],
      [
        0.8879011273384094,
        "def find_nth_number(n):\n    \"\"\"\n    Find the nth number in the sequence.\n    The sequence starts with 1, 2, 1, 3, 2, 5, 3, 7, 5, 11, 8, 13, 13, 17, 12, 19, 17, 23, 15, 25, 21, 29, 20, 31, 25, 35, 28, 37, 30, 41, 3\"\"\"\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    else:\n        res = 2\n        pre = 1\n        for _ in range(3, n + 1):\n            res, pre = res + pre, res\n        return res"
      ],
      [
        0.8874220848083496,
        "def nth_lucas(n):\n    \"\"\"\n    Return the nth Lucas number.\n    \n    >>> nth_lucas(0)\n    2\n    >>> nth_lucas(1)\n    1\n    >>> nth_lucas(2)\n    3\n    >>> nth_lucas(3)\n    4\n    >>> nth_lucas(10)\n    123\n    >>> nth_lucas(20)\n    199\n    \"\"\"\n    lucas_cache = {0: 2, 1: 1}\n    \n    if n in lucas_cache:\n        return lucas_cache[n\"\"\"\n    if n not in lucas_cache: \n        lucas_cache[n] = nth_lucas(n - 1) + nth_lucas(n - 2)\n    return lucas_cache[n]"
      ],
      [
        0.8866875171661377,
        "def nth_lucas(n):\n    \"\"\"\n    Return the nth Lucas number.\n    \n    >>> nth_lucas(0)\n    2\n    >>> nth_lucas(1)\n    1\n    >>> nth_lucas(2)\n    3\n    >>> nth_lucas(3)\n    4\n    >>> nth_lucas(10)\n    123\n    \"\"\"\n    if n == 0: \n        return 2;\n    if n == 1:\n        return 1;\n    else:\n        return nth_lucas(n - 1) + nth_lucas(n - 2)"
      ]
    ],
    "MBPP/350": [
      [
        0.9267804622650146,
        "def remove_empty_lists(l):\n    \"\"\"\n    Given a list, return a new list with all empty lists removed.\n    \n    >>> remove_empty_lists([1, 2, 3])\n    [1, 2, 3]\n    >>> remove_empty_lists([1, [], 3])\n    [1, 3]\n    >>> remove_empty_lists([1, [], [], 3, [], []])\n    [1, 3]\n    >>> remove_empty_lists([[], [], [], [], [], [], [], []])\n    []\n    \"\"\"\n    # if l is not a list, just return it. This is the base case.\n    if not isinstance(l, list):\n        return l\n    else:\n        # for each item in the list, recursively call this function.\n        # filter out any results that are empty lists.\n        # note that a string of length zero is an empty list.\n        return [x for x in filter(None, map(remove_empty_lists, l))]"
      ],
      [
        0.9124547243118286,
        "def remove_empty_lists(lst):\n    \"\"\"\n    Removes empty lists from a list.\n    \n    Args:\n        lst (list): The list to remove empty lists from.\n    \n    Returns:\n        list: The list with empty lists removed.\n    \"\"\"\n    new_lst = []\n    for li in lst:\n        if li:\n            new_lst.append(li)\n    return new_lst"
      ]
    ],
    "MBPP/351": [
      [
        0.9361097812652588,
        "def most_frequent_item(lst):\n    \"\"\"\n    Return the most frequent item in a list.\n    \"\"\"\n    # initialize variables\n    max_count = 0\n    max_item = None\n\n    # iterate through the list\n    for i in range(len(lst)):\n        count = 0\n\n        # count occurrences of the current item in the list\n        for j in range(len(lst)):\n            if lst[j] == lst[i]:\n                count += 1\n\n        # check if the current item has higher frequency than the current maximum\n        if count > max_count:\n            max_count\"\"\"\n    max_count = 0\n    max_item = None\n\n    # iterate through the list\n    for i in range(len(lst)):\n        count = 0\n\n        # count occurrences of the current item in the list\n        for j in range(len(lst)):\n            if lst[j] == lst[i]:\n                count += 1\n\n        # check if the current item has higher frequency than the current maximum\n        if count > max_count:\n            max_count = count\n            max_item = lst[i]\n\n    return max_item"
      ],
      [
        0.9350138902664185,
        "def most_frequent(input_list):\n    \"\"\"\n    Find the most frequent item in a list.\n    \"\"\"\n    # Your code here\n    # Create a dictionary to store the frequency of each item\n    frequency_dict = {}\n    for item in input_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n\n    # Find the most frequent item\n    most_frequent_item = max(frequency_dict, key=frequency_dict.get)\n\n    return most_frequent_item\n    def most_frequent\"\"\"\n    # Create a dictionary to store the frequency of each item\n    frequency_dict = {}\n    for item in input_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n\n    # Find the most frequent item\n    most_frequent_item = max(frequency_dict, key=frequency_dict.get)\n\n    return most_frequent_item"
      ]
    ],
    "MBPP/352": [
      [
        0.8792142868041992,
        "def add_tuple(tpl):\n    \"\"\"\n    Add up all the odd elements of a tuple\"\"\"\n    \n    # Extract elements at odd indices\n    odd_indices_elements = tpl[1::2]\n\n    # Filter out even elements from those extracted earlier\n    even_elements = list(filter(lambda x: x % 2 == 0, odd_indices_elements))\n\n    # Calculate the sum of the even elements and return that value\n    return sum(even_elements)"
      ],
      [
        0.8761867880821228,
        "def add_ten(arr):\n    \"\"\"Add 10 to each element in the list.\n    \n    >>> add_ten([1, 2, 3])\n    [11, 12, 13]\n    \"\"\"\n    new_arr = []\n    \n    for i in arr:\n        new_arr.append(i + 10)\n        \n    return new_arr"
      ],
      [
        0.8753759264945984,
        "def add_list_and_tuple(lst, tpl):\n    \"\"\"\n    Add corresponding elements of a list and a tuple.\n    \n    Args:\n        lst (list): A list of numbers.\n        tpl (tuple): A tuple of numbers of the same length as lst.\n        \n    Returns:\n        list: A list of the sums of corresponding elements of lst and tpl.\n    \"\"\"\n    result = []\n    for i in range(len(lst)):\n        result.append(lst[i] + tpl[i])\n    return result"
      ],
      [
        0.8747488856315613,
        "def add_by_num(L, num): \n    \"\"\"\n    Add num to each element in L.\n    \n    >>> add_by_num([1, 2, 3], 2)\n    [3, 4, 5]\n    \"\"\"\n    new_list = [] \n    for i in range(len(L)): \n        new_list.append(L[i] + num)\n    return new_list"
      ]
    ],
    "MBPP/353": [
      [
        0.9122427105903625,
        "def minFlips(self, target: str) -> int:\n    \"\"\"\n    \"\"\"\n    flips = 0\n    prev = '0'\n    for bulb in target:\n        if bulb != prev:\n            flips += 1\n            prev = bulb\n    return flips"
      ],
      [
        0.909764289855957,
        "def min_operations_to_alternate(s: str) -> int:\n    \"\"\"\n    Given a string s consisting only of characters '0' and '1',\n    return the minimum number of characters you need to change to make the string alternating\n    \"\"\"\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\"\"\"\n    count_a, count_b = 0, 0\n    for i, c in enumerate(s):\n        if i % 2 == 0:\n            if c == '0':\n                count_a += 1\n            else:\n                count_b += 1\n        else:\n            if c == '0':\n                count_b += 1\n            else:\n                count_a += 1\n    return min(count_a, count_b)"
      ],
      [
        0.9081219434738159,
        "def min_swaps(s: str) -> int:\n    \"\"\"\n    Given a string s consisting only of characters '0' and '1', return the minimum number of character swaps to make it a binary string.\n    If it is impossible, return -1.\n    A binary string is a string where each character is either '0' or '1'.\n    \n    Example 1:\n    Input: s = \"0100101010010101\"\n    Output: 5\n    Explanation:\n    Swap character '0' at indices 0, 3, 4, 5 and 7 with\"\"\"\n    zeros, ones = 0, 0\n    for c in s:\n        if c == '0':\n            zeros += 1\n        else:\n            ones += 1\n\n    if abs(zeros - ones) > 1:\n        return -1\n\n    mismatch_count1, mismatch_count2 = 0, 0\n    for i, c in enumerate(s):\n        if i % 2 == 0:\n            if c != '0': mismatch_count1 += 1\n            if c != '1': mismatch_count2 += 1\n        else:\n            if c != '1': mismatch_count1 += 1\n            if c != '0': mismatch_count2 += 1\n\n    return min(mismatch_count1, mismatch_count2) // 2"
      ]
    ],
    "MBPP/354": [
      [
        0.9275803565979004,
        "def countDigits(num):\n    \"\"\"\n    Write a function that takes in a positive integer num and returns the number of digits in num.\n    \n    Sample Input\n    num = 1234\n    Sample Output\n    4\n    \n    \"\"\"\n    return len(str(num))"
      ]
    ],
    "MBPP/355": [
      [
        0.9311329126358032,
        "def max_product(lst):\n    \"\"\"\n    This function receives a collection of numerical values (integers),\n    and returns the two elements within that list that, if multiplied\n    together, will yield the absolute highest possible product.\n    \"\"\"\n    \n    # To consider negative numbers and their product which can yield the highest product\n    lst.sort() # First sort the list in increasing order\n    \n    # Checking maximum positive product of first two elements and last two elements\n    product_1 = lst[0] * lst[1]\n    product_2 = lst[-1] * lst[-2]\n    \n    # If first two elements product is higher, return them\n    # Else, return last two elements\n    if product_1 > product_2:\n        return [lst[0], lst[1]]\n    else:\n        return [lst[-1], lst[-2]]"
      ],
      [
        0.9247413873672485,
        "def max_product(lst):\n    \"\"\"\n    Given a list of integers, return the product of the maximum two values.\n    \n    >>> max_product([1, 2, 3, 4])\n    (4, 3)\n    >>> max_product([1, 2, 3, 4, 5])\n    (5, 4)\n    >>> max_product([1, 2, 3, 4, 5, 6])\n    (6, 5)\n    \"\"\"\n    if len(lst) < 2:\n        return (\"List must have at least two elements\")\n    elif len(lst) == 2:\n        return (lst[0], lst[1])\n    else:\n        sorted_lst = sorted(lst)\n        return (sorted_lst[-1], sorted_lst[-2])"
      ],
      [
        0.9247347116470337,
        "def max_product(lst):\n    \"\"\"\n    Given a list of integers, return the product of the maximum two values.\n    \n    >>> max_product([1, 2, 3, 4])\n    (4, 3)\n    >>> max_product([1, 2, 3, 4, 5])\n    (5, 4)\n    >>> max_product([1, 2, 3, 4, 5, 6])\n    (6, 5)\n    \"\"\"\n    if len(lst) < 2:\n        return (\"List must have at least two elements\")\n    elif len(lst) == 2:\n        return (lst[0], lst[1])\n    else:\n        sorted_lst = sorted(lst)\n        return (sorted_lst[-1], sorted_lst[-2])"
      ],
      [
        0.9246435165405273,
        "def max_product_pair(lst):\n    \"\"\"\n    Find the pair of elements in a list that have the maximum product.\n    \n    Args:\n        lst: a list of integers\n    \n    Returns:\n        A tuple of two integers that have the maximum product.\n    \"\"\"\n    max_product = float('-inf')\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i]*lst[j] > max_product:\n                max_product = lst[i]*lst[j]\n                pair = (lst[i], lst[j])\n    return pair"
      ],
      [
        0.922596275806427,
        "def max_product_pairs(lst):\n    \"\"\"\n    Given a list of integers, find all pairs of integers whose product is the maximum product of any pair.\n    \n    Args:\n        lst: list of integers\n    \n    Returns:\n        list of pairs of integers whose product is the maximum product of any pair\n    \"\"\"\n    if not lst:          # check if the list is empty\n        return []\n    #check all possible pairs\n    possible_pairs = [[lst[i], lst[j]] for i in range(len(lst)) for j in range(i+1, len(lst))]\n    #calculate product for each pair\n    products = [pair[0]*pair[1] for pair in possible_pairs]\n    #find maximum product\n    max_product = max(products) \n    #return pairs having maximum product\n    return [possible_pairs[i] for i in range(len(products)) if products[i] == max_product]"
      ]
    ],
    "MBPP/356": [
      [
        0.9250075221061707,
        "def is_balanced(root):\n    \"\"\"\n    Return True if the binary tree is balanced.\n    \n    :param root: The root of the binary tree.\n    :type root: TreeNode\n    :rtype: bool\n    \"\"\"\n    if root == None: \n        return True \n  \n    leftHeight = height(root.left) \n    rightHeight = height(root.right) \n  \n    if  abs(leftHeight - rightHeight) < 2 and is_balanced(root.left) is True and is_balanced(root.right) is True: \n        return True \n  \n    return False"
      ],
      [
        0.923189640045166,
        "def is_balanced(root):\n    \"\"\"\n    Check if a binary tree is balanced.\n    A binary tree is balanced if the depth of the two subtrees of every node never differ by more than 1.\n    :param root: root of binary tree\n    :return: True if binary tree is balanced, False if not\n    \"\"\"\n    # Base Case\n    if root is None:\n        return True\n\n    # Get the height of left and right subtrees\n    left_height = is_balanced(root.left)\n    right_height = is_balanced(root.right)\n\n    # Check if difference between heights is not more than 1 \n    if abs(left_height - right_height) <= 1 and \\\n       is_balanced(root.left) and is_balanced(root.right):\n        return True\n\n    return False"
      ],
      [
        0.9227168560028076,
        "def isBalanced(root): \n    \"\"\"\n    :type root: TreeNode\n    :rtype: bool\n    \"\"\"\n    if root is None: \n        return True\n\n    lh = height(root.left) \n    rh = height(root.right)\n\n    if abs(lh-rh) <= 1 and isBalanced(root.left) is True and isBalanced(root.right) is True: \n        return True\n\n    return False"
      ]
    ],
    "MBPP/357": [
      [
        0.8971201181411743,
        "def repeat_string(string, n):\n    \"\"\"\n    Given a string and an integer, return a list with the string repeated n times.\n    \"\"\"\n    return [string] * n\n    \n    def repeat_string(string, n):\n    \"\"\"\n    Given a string and an integer, return a list with the string repeated n times.\n    \"\"\"\n    return [string] * n"
      ],
      [
        0.8844214677810669,
        "def rep(lst, times):\n    \"\"\"\n    Return a list of elements repeating times times.\n    >>> rep([1, 2], [3, 2])\n    [1, 1, 1, 2, 2]\n    \"\"\"\n    return [i for i, t in zip(lst, times) for _ in range(t)]"
      ],
      [
        0.8840140104293823,
        "def repeat_string(string, n):\n    \"\"\"\n    Given a string and an integer, return a string that\n    repeats the original string that many times.\n    \n    repeat_string(\"Hello\", 3) -> \"HelloHelloHello\"\n    \"\"\"\n    return string * n"
      ],
      [
        0.8795992732048035,
        "def copy_string(string, n):\n    \"\"\"\n    Return a new string consisting of n copies of the string\"\"\"\n    result = \"\"\n    for _ in range(n):\n        result += string\n    return result"
      ]
    ],
    "MBPP/358": [
      [
        0.9193006157875061,
        "def find_surface_area(length, breadth, height):\n    '''\n    This function calculates the surface area of a cuboid.\n    Input: length, breadth, height - these are the three dimensions of the cuboid\n    Output: total surface area of the cuboid \n    '''\n    # Formula of Surface Area of Cuboid = 2(lb + bh + hl)\n    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area"
      ]
    ],
    "MBPP/359": [],
    "MBPP/360": [
      [
        0.9282146692276001,
        "def smallest_missing_number(arr):\n    \"\"\"\n    Find the smallest missing number in an array.\n    \n    Args:\n        arr (list): The input array.\n    \n    Returns:\n        int: The smallest missing number.\n    \"\"\"\n    arr.sort()   # Sort the array in ascending order\n\n    for i in range(len(arr)):\n        if arr[i] != i + 1:   # Check if the current element is not equal to i + 1\n            return i + 1     # Return the missing number\n\n    return arr[-1] + 1   # If no element is missing, return the next number after the last element"
      ],
      [
        0.9245834350585938,
        "def find_missing_element(arr, missing):\n    \"\"\"\n    Find the missing element in a given array.\n    \n    Args:\n        arr: a sorted array of integers\n        missing: the missing element\n    \n    Returns:\n        The missing element\n    \"\"\"\n    sorted_arr = sorted(arr)\n    curr = sorted_arr[0]\n    for element in sorted_arr[1:]:\n        if element != (curr + 1):\n            return curr + 1\n        else:\n            curr = element\n    return missing"
      ],
      [
        0.9230513572692871,
        "def missing_nums(arr):\n    \"\"\"\n    Given an array of sorted numbers, find the missing number in the array.\n    The array contains numbers in the range of 1 to 100.\n    The array is sorted in ascending order.\n    \n    Input: [1, 2, 4, 5, 6, 7, 9]\n    Output: 3\n    \n    Input: [1, 2, 3, 4, 6, 7, 8, 9, 10]\n    Output: 5\n    \n    Input: [1, \"\"\"\n    n = len(arr)\n    for i in range(n - 1):\n        expected_num = arr[i] + 1\n        if arr[i + 1] != expected_num:\n            return expected_num\n    return None"
      ]
    ],
    "MBPP/361": [
      [
        0.9121540188789368,
        "def heap_sort(arr):\n    \"\"\"\n    Sort a list in ascending order\n    :param arr: list\n    :return: list\n    \"\"\"\n    n = len(arr)\n\n    # Build a maxheap.\n    for i in range(n, -1, -1):\n        heapify(arr, n, i)\n\n    # One by one extract elements\n    for i in range(n-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i] # swap\n        heapify(arr, i, 0)"
      ],
      [
        0.9115363955497742,
        "def heap_sort(arr):\n    \"\"\"\n    Sort a list in ascending order using heap sort.\n    :param arr: List of integers to be sorted.\n    :return: None\n    \"\"\"\n    def heapify(arr, n, i):\n        \"\"\"\n        Heapify a subtree rooted at index i.\n        :param arr: List of integers to be heapified.\n        :param n: Size of the heap.\n        :param i: Index of the root node of the subtree to be heapified.\n        :return: None\n        \"\"\"\n        largest = i\n        left = 2 * i + \"\"\"\n    n = len(arr)\n    for i in range(n, -1, -1):\n        heapify(arr, n, i)\n    for i in range(n-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, i, 0)"
      ],
      [
        0.9105483293533325,
        "def heapsort(arr):\n    \"\"\"\n    Sort a list in ascending order using heap sort.\n    :param arr: List of integers to be sorted.\n    :return: None\n    \"\"\"\n    def heapify(arr, n, i):\n        \"\"\"\n        Heapify a subtree rooted at index i.\n        :param arr: List of integers.\n        :param n: Size of the heap.\n        :param i: Index of the root of the subtree.\n        :return: None\n        \"\"\"\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i\"\"\"\n    n = len(arr)\n\n    for i in range(n//2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    for i in range(n-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, i, 0)"
      ],
      [
        0.9100583791732788,
        "def heapSort(arr):\n    \"\"\"\n    Sort a list in ascending order using heap sort.\n    :param arr: List of integers to be sorted.\n    :return: None\n    \"\"\"\n    def heapify(arr, n, i):\n        \"\"\"\n        Heapify a subtree rooted at index i.\n        :param arr: List of integers.\n        :param n: Size of heap.\n        :param i: Index of the root of the subtree.\n        :return: None\n        \"\"\"\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i +\"\"\"\n    n = len(arr)\n\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, i, 0)"
      ],
      [
        0.9092225432395935,
        "def heapsort(arr):\n    \"\"\"\n    Sort a list in ascending order using heap sort.\n    \n    Args:\n        arr(list): List to be sorted\n        \n    Returns:\n        A copy of the list in ascending order.\n    \"\"\"\n    heapq.heapify(arr)\n    return [heapq.heappop(arr) for _ in range(len(arr))]"
      ],
      [
        0.9092015624046326,
        "def heap_sort(arr):\n    \"\"\"\n    Sort a list in ascending order using heap sort.\n    :param arr: List of integers to be sorted.\n    :return: None\n    \"\"\"\n    def heapify(arr, n, i):\n        \"\"\"\n        Heapify a subtree rooted at index i.\n        :param arr: List of integers.\n        :param n: Size of the heap.\n        :param i: Index of the root node.\n        :return: None\n        \"\"\"\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + \"\"\"\n    n = len(arr)\n\n    for i in range(n//2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    for i in range(n-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, i, 0)"
      ],
      [
        0.9083521962165833,
        "def heapSort(arr):\n    \"\"\"\n    Sort a list in ascending order\n    :param arr: list of ints\n    :return: list of ints, sorted in ascending order\n    \"\"\"\n    # TODO: Implement heap sort\n    #   See https://courses.cs.vt.edu/cs3113_f20/Lectures/09-Sorting/heapsort.html for help\n    #   See https://www.programiz.com/dsa/heap-sort for help\n    #   See https://www.youtube.com/watch?v=kPRA0fhG1V0 for help\n\"\"\"\n    n = len(arr)\n \n    # Build a maxheap.\n    for i in range(n//2 - 1, -1, -1):\n        heapify(arr, n, i)\n \n    # One by one extract elements\n    for i in range(n-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]   # swap\n        heapify(arr, i, 0)\n\n    return arr"
      ],
      [
        0.9077617526054382,
        "def heap_sort(arr):\n    \"\"\"\n    Sort a list in ascending order using a heap.\n    \n    Args:\n        arr: A list of integers to be sorted.\n    \n    Returns:\n        A new list of integers in ascending order.\n    \"\"\"\n    import heapq\n    heapq.heapify(arr)\n    return [heapq.heappop(arr) for _ in range(len(arr))]"
      ],
      [
        0.9070056080818176,
        "def heap_sort(arr):\n    \"\"\"\n    Sort a list in ascending order\n    \n    Args:\n        arr(list): List to be sorted\n    \"\"\"\n    n = len(arr)\n\n    for i in range(n, -1, -1):\n        heapify(arr, n, i)\n\n    for i in range(n-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i] \n        heapify(arr, i, 0)"
      ],
      [
        0.906933069229126,
        "def heapSort(arr):\n    \"\"\"\n    Sort a list in ascending order\n    :param arr: list\n    :return: None\n    \"\"\"\n    n = len(arr)\n  \n    # Build a maxheap.\n    for i in range(n, -1, -1):\n        heapify(arr, n, i)\n   \n    # One by one extract elements\n    for i in range(n-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]   # swap\n        heapify(arr, i, 0\"\"\"\n    n = len(arr)\n  \n    # Build a maxheap.\n    for i in range(n, -1, -1):\n        heapify(arr, n, i)\n   \n    # One by one extract elements\n    for i in range(n-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]   # swap\n        heapify(arr, i, 0)"
      ]
    ],
    "MBPP/362": [
      [
        0.9135163426399231,
        "def calculate_volume(num_length, num_width, num_height):\n    \"\"\"\n    Calculate the volume of a cuboid.\n    \n    Args:\n        num_length (int): The length of the cuboid.\n        num_width (int): The width of the cuboid.\n        num_height (int): The height of the cuboid.\n        \n    Returns:\n        int: The volume of the cuboid.\n    \"\"\"\n    return num_length * num_width * num_height"
      ]
    ],
    "MBPP/363": [
      [
        0.9280613660812378,
        "def permutations(str):\n    \"\"\"\n    Generate all permutations of the given string.\n    \"\"\"\n    def _permutations(lst, index):\n        if index == len(lst):\n            print(\"\".join(lst))\n        else:\n            _permutations(lst, index + 1)\n            for i in range(index + 1, len(lst)):\n                lst[index], lst[i] = lst[i], lst[index]\n                _permutations(lst, index + 1)\n                lst[index], lst[i] = lst[i], lst[index]\n    \"\"\"\n    lst = list(str)\n    _permutations(lst, 0)"
      ],
      [
        0.9250854849815369,
        "def unique_permutations(str, prefix=\"\"):\n    \"\"\"\n    Generate all unique permutations of a string\n    \"\"\"\n    check_set = set()\n    unique_permutations(str, prefix)\n    \n    \n    def unique_permutations(str, prefix=\"\"):\n    \"\"\"\n    Generate all unique permutations of a string\n    \"\"\"\n    if len(str) == 0:\n        print(prefix)\n    else:\n        for i in range(len(str)):\n            rem = str[0:i] + str[i+1:]\n            if (rem + prefix) not in check_set:\n                check_set.add(rem+prefix)\n                unique_permutations(rem, prefix + str[i])"
      ]
    ],
    "MBPP/364": [
      [
        0.8983289003372192,
        "def round_to_5(n):\n    \"\"\"\n    Round a number to the nearest multiple of 5.\n    \n    >>> round_to_5(12)\n    10\n    >>> round_to_5(13)\n    15\n    >>> round_to_5(12.5)\n    10\n    >>> round_to_5(12.6)\n    15\n    \"\"\"\n    return round(n / 5) * 5"
      ],
      [
        0.8923430442810059,
        "def round_up(num):\n    \"\"\"\n    Round up a number to the nearest integer.\n    \"\"\"\n    if num == int(num):\n        return int(num)\n    return int(num + 1)\n    def round_up(num):\n    \"\"\"\n    Round up a number to the nearest integer.\n    \"\"\"\n    if num == int(num):\n        return int(num)\n    return int(num + 1)"
      ],
      [
        0.8922929763793945,
        "def round_to_nearest_hundred(num):\n    \"\"\"\n    Round a number to the nearest hundred.\n    \n    >>> round_to_nearest_hundred(88)\n    80\n    >>> round_to_nearest_hundred(123)\n    100\n    >>> round_to_nearest_hundred(333)\n    300\n    \"\"\"\n    mod = num % 100\n\n    if mod < 50:\n        return num - mod\n    else:\n        return num + (100 - mod)"
      ]
    ],
    "MBPP/365": [],
    "MBPP/366": [
      [
        0.9192652702331543,
        "def remove_chars(string, chars):\n    \"\"\"\n    It should remove all occurrence of given characters from a string.\n    \"\"\"\n    # your code goes here\n    for char in chars:\n        string = string.replace(char, \"\")\n    return string\n    \n    def remove_chars(string, chars):\n    \"\"\"\n    It should remove all occurrence of given characters from a string.\n    \"\"\"\n    for char in chars:\n        string = string.replace(char, \"\")\n    return string"
      ],
      [
        0.9189776182174683,
        "def remove_char(string, char):\n    \"\"\"\n    Remove all instances of a given character from a string.\n    \n    >>> remove_char('hello world', 'l')\n    'heo word'\n    \"\"\"\n    string_list = list(string)\n    for i in string_list:\n        if i == char:\n            string_list.remove(i)\n    string = ''.join(string_list)\n    \n    return string"
      ]
    ],
    "MBPP/367": [],
    "MBPP/368": [
      [
        0.9343582391738892,
        "def find_surface_area(length, breadth, height):\n    '''\n    This function calculates the surface area of a cuboid.\n    Input: length, breadth, height - these are the three dimensions of the cuboid\n    Output: total surface area of the cuboid \n    '''\n    # Formula of Surface Area of Cuboid = 2(lb + bh + hl)\n    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area"
      ],
      [
        0.9343320727348328,
        "def find_surface_area(length, breadth, height):\n    '''\n    This function calculates the surface area of a cuboid.\n    Input: length, breadth, height - these are the three dimensions of the cuboid\n    Output: total surface area of the cuboid \n    '''\n    # Formula of Surface Area of Cuboid = 2(lb + bh + hl)\n    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area"
      ]
    ],
    "MBPP/369": [],
    "MBPP/370": [],
    "MBPP/371": [
      [
        0.9194601774215698,
        "def countRotations(arr):\n    \"\"\"\n    Count the number of rotations in a sorted and rotated array\n    :param arr: array of integers\n    :return: number of rotations\n    :rtype: int\n    \"\"\"\n    n = len(arr)\n    # Check if array is sorted\n    if (arr[0] <= arr[n-1]):\n        return 0\n    # Look for smallest element\n    i = 0\n    while (i < n-1):\n        if (arr[i+1] < arr[i]):\n            break\n        i += 1\n    return (i + 1)%n"
      ],
      [
        0.9100503921508789,
        "def count_rotations(nums):\n    \"\"\"\n    Return the count of rotations in the list\n    :param nums: a list of integers\n    :return: an integer\n    \"\"\"\n    # Check if the array is sorted in descending order\n    if nums[0] >= nums[-1]:\n        max_index = 0\n        # Find the index of the max value \n        for i in range(1, len(nums)):\n            if nums[i] >= nums[max_index]:\n                max_index = i\n        # If the array is not sorted, return -1\n        if max_index == len(nums) - 1 and nums[0] < nums[1]:\n            return -1\n        else:\n            # If sorted in descending order, return index of max value + 1\n            return max_index + 1\n    else:\n        min_index = 0\n        # Find the index of the min value\n        for i in range(1, len(nums)):\n            if nums[i] <= nums[min_index]:\n                min_index = i\n        # If the array is not sorted, return -1\n        if min_index == len(nums) - 1 and nums[0] > nums[1]:\n            return -1\n        else:\n            # If sorted in ascending order, return index of min value\n            return min_index"
      ],
      [
        0.9013595581054688,
        "def min_rot(arr): \n    \"\"\"\n    Find the minimum number of rotations to make the array sorted\n    :param arr: array of integers\n    :return: minimum number of rotations\n    \"\"\"\n    n = len(arr) \n    minimum = n \n    for i in range(n): \n        diff = 0 \n        for j in range(n): \n            if (arr[(i + j) % n] != arr[j]): \n                diff += 1\n        minimum = min(diff, minimum) \n    return minimum"
      ],
      [
        0.8854879140853882,
        "def countShifts(arr):\n    \"\"\"\n    Given an array of integers arr, return the number of shifts needed to make it sorted.\n    An array arr is sorted if and only if arr[i] <= arr[i + 1] holds for every i (0-indexed).\n    We define a shift as moving the first element of an array to the end.\n    For example, [1, 2, 3] shifted once is [2, 3, 1].\n    Example 1:\n    Input: arr = [3,4,5,1,2]\n    Output: 1\n    Explanation\"\"\"\n    if len(arr) == 0:\n        return 0\n    for j in range(len(arr)):\n        new_arr = arr[j:]+arr[:j]\n        if is_sorted(new_arr):\n            return j\n    return -1"
      ]
    ],
    "MBPP/372": [
      [
        0.8912954330444336,
        "def even_odd_change(arr):\n    \"\"\"\n    Given an array of numbers, replace all even numbers with 0 and all odd numbers with 1.\n    \n    Example:\n    \n    Input: [1, 2, 3, 4, 5, 6]\n    Output: [1, 0, 1, 0, 1, 0]\n    \n    Input: [10, 11, 12, 13, 14, 15]\n    Output: [0, 1, 0, 1, 0, 1]\n\"\"\"\n    for i in range(len(arr)):\n        if arr[i] % 2 == 0:\n            arr[i] = 0\n        else:\n            arr[i] = 1\n    return arr"
      ]
    ],
    "MBPP/373": [
      [
        0.9088703989982605,
        "def least_frequent(array):\n    \"\"\"\n    Return the least frequent element in the given list.\n    \n    Args:\n        array (list): A list of integers.\n    \n    Returns:\n        int: The least frequent element in the list.\n    \"\"\"\n    frequency = {} \n    for item in array: \n        frequency[item] = frequency.get(item, 0) + 1\n    \n    least_frequent_number = min(frequency, key=frequency.get)\n    return least_frequent_number"
      ],
      [
        0.9032262563705444,
        "def frequency(arr, num):\n    \"\"\"\n    Return the frequency of num in the given array.\n    \"\"\"\n    return arr.count(num)\n    \n    def frequency(arr, num):\n    \"\"\"\n    Return the frequency of num in the given array.\n    \"\"\"\n    return arr.count(num)"
      ]
    ],
    "MBPP/374": [
      [
        0.8897498846054077,
        "def pell(n):\n    \"\"\"\n    Return the nth term of the Pell sequence.\n    \"\"\"\n    # create a dictionary to store computed values\n    pell_dict = {0: 0, 1: 1}\n    \"\"\"\n    # check if the value is already computed\n    if n not in pell_dict:\n        # calculate the nth term of the sequence\n        pell_dict[n] = 2 * pell(n-1) + pell(n-2)\n    return pell_dict[n]"
      ],
      [
        0.8890237808227539,
        "def nth_value(n):\n    \"\"\"\n    \"\"\"\n    if n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return 2 * nth_value(n-1)"
      ]
    ],
    "MBPP/375": [
      [
        0.9047266840934753,
        "def min_deletions(s):\n    \"\"\"\n    Given a string s, find the minimum number of characters you need to delete to make the string balanced. We define a string is balanced if it has equal number of closing and opening brackets.\n    :type s: str\n    :rtype: int\n    \"\"\"\n    freq = collections.Counter(s)\n    used = set()\n    deletions = 0\n\n    for count in freq.values():\n        while count in used and count > 0:\n            deletions += 1\n            count -= 1\n        used.add(count)\n\n    return deletions"
      ],
      [
        0.904708743095398,
        "def min_deletions(s):\n    \"\"\"\n    Given a string s, find the minimum number of characters you need to delete to make the string balanced. We define a string is balanced if it has equal number of closing and opening brackets.\n    :type s: str\n    :rtype: int\n    \"\"\"\n    freq = collections.Counter(s)\n    used = set()\n    deletions = 0\n\n    for count in freq.values():\n        while count in used and count > 0:\n            deletions += 1\n            count -= 1\n        used.add(count)\n\n    return deletions"
      ],
      [
        0.8889316916465759,
        "def minAddToMakeValid(s: str) -> int:\n    \"\"\"\n    \"\"\"\n    result = balance = 0\n    for c in s:\n        balance += 1 if c == '(' else -1\n        if balance == -1:\n            result += 1\n            balance += 1\n    return result + balance"
      ],
      [
        0.8880714774131775,
        "def minInsertions(s: str) -> int:\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    ans, depth = 0, 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            depth += 2\n        else:\n            if s[i - 1] == '(':\n                depth -= 1\n            else:\n                depth -= 2\n            if depth < 0:\n                ans -= depth\n                depth = 0\n    return ans + depth"
      ],
      [
        0.8859508037567139,
        "def min_parentheses(s: str) -> int:\n    \"\"\"\n    Given a string containing just the characters '(' and ')', find the minimum number of parentheses to be added to make the string valid.\n    \n    Example 1:\n    \n    Input: \"())\"\n    Output: 1\n    Example 2:\n    \n    Input: \"(((\"\n    Output: 3\n    Example 3:\n    \n    Input: \"()\"\n    Output: 0\n    Example 4:\n    \n    Input: \"()))((\"\n    Output: 4\n    \"\"\"\n    stack = []\n    count = 0\n    \n    for p in s:\n        if p == '(':\n            stack.append(p)\n        elif p == ')':\n            if stack:\n                stack.pop()\n            else:\n                count += 1\n    count += len(stack)\n    \n    return count"
      ]
    ],
    "MBPP/376": [
      [
        0.9362866878509521,
        "def check_odd_even(hex_number):\n    \"\"\"\n    Check if a hexadecimal number is odd or even.\n    \n    Args:\n        hex_number (str): The hexadecimal number to check.\n    \"\"\"\n    # Convert hexadecimal to decimal\n    decimal_number = int(hex_number, 16)\n    \n    # Check if the number is odd or even\n    if decimal_number % 2 == 0:\n        print(f\"The hex number {hex_number} is Even.\")\n    else:\n        print(f\"The hex number {hex_number} is Odd.\")"
      ],
      [
        0.9362764358520508,
        "def check_odd_even(hex_number):\n    \"\"\"\n    Check if a hexadecimal number is odd or even.\n    \n    Args:\n        hex_number (str): The hexadecimal number to check.\n    \"\"\"\n    # Convert hexadecimal to decimal\n    decimal_number = int(hex_number, 16)\n    \n    # Check if the number is odd or even\n    if decimal_number % 2 == 0:\n        print(f\"The hex number {hex_number} is Even.\")\n    else:\n        print(f\"The hex number {hex_number} is Odd.\")"
      ],
      [
        0.9282255172729492,
        "def check_hexadecimal(num):\n    \"\"\"\n    Check if a hexadecimal number is even or odd.\n\n    Args:\n        num (str): The hexadecimal number to check.\n\n    Returns:\n        str: \"Even\" if the number is even, \"Odd\" if the number is odd.\n    \"\"\"\n    # Convert hexadecimal to decimal\n    decimal_num = int(num, 16)\n\n    # Check if the number is even or odd\n    if decimal_num % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\""
      ]
    ],
    "MBPP/377": [
      [
        0.9333244562149048,
        "def maxPowerOfTwo(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    p = 0\n    while ((1 << (p + 1)) <= n): p += 1\n    return p"
      ],
      [
        0.9219517707824707,
        "def power_of_two(n):\n    \"\"\"\n    Given an integer n, return the power of 2 that is closest to n.\n    \"\"\"\n    result = 1\n    base = 2\n\n    while n > 0:\n        if n % 2 == 1:\n            result *= base\n        base *= base\n        n //= 2\n\n    return result\n    def power_of_two(n):\n    \"\"\"\n    Given an integer n, return the power of 2 that is closest to n.\n    \"\"\"\n    result = 1\n    base = 2\n\n    while n > 0:\n        if n % 2 == 1:\n            result *= base\n        base *= base\n        n //= 2\n\n    return result"
      ]
    ],
    "MBPP/378": [],
    "MBPP/379": [
      [
        0.9045181274414062,
        "def prepend_string_to_list(my_string, my_list):\n    \"\"\"\n    Prepend a string to all elements in a list\n    \"\"\"\n    for i in range(len(my_list)):\n        my_list[i] = my_string + my_list[i]\n    return my_list\n    \n    def prepend_string_to_list(my_string, my_list):\n    \"\"\"\n    Prepend a string to all elements in a list\n    \"\"\"\n    for item in my_list:\n        print(my_string + item)"
      ]
    ],
    "MBPP/380": [
      [
        0.9076905846595764,
        "def create_nested_dict(list1, list2, list3):\n    \"\"\"\n    Create a nested dictionary from three lists.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        dict: The nested dictionary.\n    \"\"\"\n    # create the nested dictionary\n    nested_dict = {}\n\n    for l1, l2, l3 in zip(list1, list2, list3):\n        # check if l3 is an iterable but not a string \n        # (since strings are iterable, but we don't want to treat them as such)\n        if isinstance(l3, (list, tuple)) and not isinstance(l3, str):\n            # convert l3 to dictionary if its iterable\n            l3 = {i: v for i, v in enumerate(l3)}\n        \n        nested_dict[l1] = {l2: l3}\n    return nested_dict"
      ]
    ],
    "MBPP/381": [
      [
        0.8920077681541443,
        "def maximum_generated(n: int) -> int:\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    if n == 0:\n        return 0\n    nums = [0] * (n + 1)\n    nums[1] = 1\n    for i in range(2, n + 1):\n        nums[i] = nums[i // 2] if i % 2 == 0 else nums[i // 2] + nums[i // 2 + 1]\n    return max(nums)"
      ],
      [
        0.8887335062026978,
        "def A(n):\n    \"\"\"\n    \"\"\"\n    if n == 0:\n        return 1\n    elif n % 2 == 0:\n        b = 2 ** (n.bit_length() - 1)\n        return 3 * A(n // 2) + 5 * A(n - b)\n    else:\n        return A(n // 2)"
      ]
    ],
    "MBPP/382": [
      [
        0.9012329578399658,
        "def max_length(list1): \n    \"\"\"\n    This function returns the longest string in a list\n    \n    :param list1: list of strings\n    :return: longest string\n    \"\"\"\n    return max(list1, key=len) "
      ]
    ],
    "MBPP/383": [
      [
        0.8964890241622925,
        "def is_distinct(my_list):\n    \"\"\"\n    Return True if all elements in my_list are distinct.\n    >>> is_distinct([1, 5, 7, 9])\n    True\n    >>> is_distinct([2, 2, 4, 6])\n    False\n    \"\"\"\n    seen = set()\n    for element in my_list:\n        if element in seen:\n            return False \n        seen.add(element)\n    return True"
      ]
    ],
    "MBPP/384": [
      [
        0.9445359110832214,
        "def first_non_repeated_char(string):\n    \"\"\"\n    Find the first non-repeated character in a string\n    :param string: string\n    :return: char\n    \"\"\"\n    for ch in string:\n        if string.count(ch) == 1:\n            return ch"
      ],
      [
        0.9437726736068726,
        "def first_nonrepeated_character(string):\n    \"\"\"\n    Given a string, find the first non-repeated character in it.\n    For example, in 'abacabad' the first non-repeated character is 'c'.\n    For 'abacabaabacaba' the answer is 'c' again.\n    The first non-repeated character in 'wsdef' is 'w'.\n    The answer should be case-sensitive, so for 'W' the answer is 'W'.\n    If there is no non-repeated character, return False.\n    \"\"\"\n    for char in string:\n        if string.count(char) == 1:\n            return char\n    return False"
      ],
      [
        0.939903736114502,
        "def first_non_repeating(str): \n    \"\"\"\n    Given a string, find the first non-repeating character in it and return its index. If it doesn't exist, return -1.\n    \n    Examples:\n    \n    s = \"leetcode\"\n    return 0.\n    \n    s = \"loveleetcode\"\n    return 2.\n    \n    s = \"aabb\"\n    return -1.\n    \n    s = \"aaabbbccc\"\n    return -1.\n    \n    s = \"aaabbbcccdd\"\n    return 8.\n    \n    s = \"\"\"\"\n    letters = {}\n  \n    # build a hash table of each character and its count \n    for char in str: \n        if char in letters: \n            letters[char] += 1 \n        else: \n            letters[char] = 1\n    \n    # find the first non-repeating character \n    for char in str: \n        if letters[char] == 1: \n            return char\n    return None"
      ]
    ],
    "MBPP/385": [],
    "MBPP/386": [
      [
        0.9345166683197021,
        "def median(num1, num2, num3): \n    \"\"\"\n    This function returns the median of three numbers\n    \"\"\"\n    \n    \"\"\"\n    Write your code here\n    \"\"\"\n    if (num1 > num2): \n        if (num3 > num1): \n            median = num1 \n        elif (num3 > num2): \n            median = num3\n        else: \n            median = num2\n    else: \n        if (num3 > num2): \n            median = num2\n        elif (num3 > num1): \n            median = num3\n        else: \n            median = num1\n    return median"
      ],
      [
        0.9334975481033325,
        "def median(a, b, c):\n    \"\"\"\n    Given three numbers, return the median value.\n    \n    >>> median(1, 2, 3)\n    2\n    >>> median(1, 2, 2)\n    2\n    >>> median(1, 2, 1)\n    1\n    \"\"\"\n    numbers = [a, b, c]\n    numbers.sort()\n    median_index = len(numbers) // 2\n    return numbers[median_index]"
      ],
      [
        0.9324808716773987,
        "def median(a, b, c):\n    \"\"\"\n    Given three numbers, return the median value.\n    \n    >>> median(1, 2, 3)\n    2\n    >>> median(1, 3, 2)\n    2\n    >>> median(2, 1, 3)\n    2\n    >>> median(2, 3, 1)\n    2\n    >>> median(3, 1, 2)\n    2\n    >>> median(3, 2, 1)\n    2\n    \"\"\"\n    if (a <= b <= c) or (c <= b <= a):\n        return b\n    elif (b <= a <= c) or (c <= a <= b):\n        return a\n    else:\n        return c"
      ],
      [
        0.9299930334091187,
        "def median(a, b, c):\n    \"\"\"\n    Given three numbers, return the median value.\n    \n    >>> median(1, 2, 3)\n    2\n    >>> median(1, 3, 2)\n    2\n    >>> median(2, 1, 3)\n    2\n    >>> median(2, 3, 1)\n    2\n    >>> median(3, 1, 2)\n    2\n    >>> median(3, 2, 1)\n    2\n    \"\"\"\n    median = (a + b + c) - min(a, b, c) - max(a, b, c)\n    return median"
      ]
    ],
    "MBPP/387": [],
    "MBPP/388": [
      [
        0.893403172492981,
        "def xor(a, b):\n    \"\"\"\n    Returns the XOR of two binary strings.\n    \"\"\"\n    result = []\n\n    for i in range(len(a)):\n        result.append(a[i] ^ b[i])\n\n    return result\n    def xor(a, b):\n    \"\"\"\n    Returns the XOR of two binary strings.\n    \"\"\"\n    result = []\n\n    for i in range(len(a)):\n        result.append(a[i] ^ b[i])\n\n    return result"
      ]
    ],
    "MBPP/389": [
      [
        0.9119685888290405,
        "def frequency(my_list): \n    \"\"\"\n    The frequency function takes a list as an argument and returns a list of tuples where the first element is the element from the original list and the second element is the frequency of that element in the list.\n    \n    For example, if the argument is [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,\"\"\"\n    frequency_list = [] \n    for item in my_list: \n        if item not in frequency_list: \n            frequency_list.append(item) \n  \n    for i in range(0, len(frequency_list)): \n        frequency_list[i] = (frequency_list[i], my_list.count(frequency_list[i])) \n          \n    return frequency_list"
      ],
      [
        0.9044647216796875,
        "def count_occurrences(lst):\n    \"\"\"\n    Given a list of integers, return a list of tuples where each tuple contains a number and the number of occurrences of that number in the list.\n    The list of tuples should be ordered in descending order based on the count of occurrences.\n    For example, given the list [1, 2, 3, 1, 2, 3, 1, 4, 5], return [(1, 3), (2, 2), (3, 2), (4, 1), (5, 1)].\n    \"\"\"\n    from collections import Counter\n    \n\"\"\"\n    count = Counter(lst)  # Count occurrences of each distinct integer\n    result = [(i, count[i]) for i in count]  # Convert to the desired output format\n    result.sort(key=lambda x: (-x[1], x[0]))  # Sort first by descending count, then by ascending integer\n    return result"
      ],
      [
        0.9020891189575195,
        "def list_element_frequency(input_list):\n    \"\"\"\n    This function takes a list as an input and returns a list of tuples.\n    Each tuple contains an element and its corresponding frequency in the input list.\n    The output list is sorted in ascending order based on the element values.\n    \n    Parameters:\n    input_list (list): The input list containing elements.\n    \n    Returns:\n    list: A list of tuples where each tuple contains an element and its frequency.\n    \n    Example:\n    input_list = [1, 2, 2, 3, 4, 4, 4, 5\"\"\"\n    counter = Counter(input_list)\n    unique_elements = list(OrderedDict.fromkeys(input_list))\n    output_list = [(element, counter[element]) for element in unique_elements]\n    return output_list"
      ]
    ],
    "MBPP/390": [
      [
        0.8906905651092529,
        "def sum_tuples(input_list):\n    \"\"\"\n    Write a function that takes a list of tuples as input and returns the sum of all the elements in the tuples.\n    For example, if the input is [(1, 2), (3, 4), (5, 6)], the output should be 21.\n    \"\"\"\n    total_sum = 0\n    for tup in input_list:\n        for elem in tup:\n            total_sum += elem\n    return total_sum"
      ]
    ],
    "MBPP/391": [
      [
        0.9024820327758789,
        "def C(n, k, p):\n    \"\"\"Calculate 'n choose k' modulo p.\"\"\"\n    if k > n:\n        return 0\n    if k > n-k:\n        k = n-k\n    num, den = 1, 1\n    for i in range(k):\n        num = (num * (n-i)) % p\n        den = (den * (i+1)) % p\n    return (num * pow(den, p-2, p)) % p"
      ],
      [
        0.8836112022399902,
        "def find_perm(n, r, p) : \n    \"\"\"\n    Find permutation of n elements taken r at a time\n    \"\"\"\n    return factorial(n, p) // factorial(n - r, p)\n    \n    def modInverse(a, m) : \n    \"\"\"\n    Find modular inverse of a under modulo m\n    \"\"\"\n    m0 = m \n    y = 0\n    x = 1\n    if (m == 1) : \n        return 0\n    while (a > 1) : \n        q = a // m \n        t = m \n        m = a\"\"\"\n    num = 1 \n    while (r > 0) : \n        num = ((num % p) * (n % p)) % p \n        n -= 1\n        r -= 1\n    den = 1\n    r = 7\n    while (r > 0): \n        den = ((den % p) * (r % p)) % p\n        r -= 1\n    den_inv = modInverse(den, p)\n    return (num * den_inv) % p"
      ]
    ],
    "MBPP/392": [],
    "MBPP/393": [
      [
        0.9256856441497803,
        "def min_num(a, b):\n    \"\"\"\n    Returns the minimum of two numbers.\n    :param a: first number\n    :param b: second number\n    :return: minimum of a and b\n    \"\"\"\n    return min(a, b)"
      ],
      [
        0.9256605505943298,
        "def min_num(a, b):\n    \"\"\"\n    Returns the minimum of two numbers.\n    :param a: first number\n    :param b: second number\n    :return: minimum of a and b\n    \"\"\"\n    return min(a, b)"
      ],
      [
        0.9231871366500854,
        "def minof2num(a, b):\n    \"\"\"\n    This function returns the minimum of two numbers\n    \"\"\"\n    if a < b:\n        return a\n    else:\n        return b\n    def minof2num(a, b):\n    \"\"\"\n    This function returns the minimum of two numbers\n    \"\"\"\n    if a < b:\n        return a\n    else:\n        return b"
      ],
      [
        0.922313928604126,
        "def get_max(num1, num2):\n    \"\"\"\n    Return the maximum of two numbers.\n    \"\"\"\n    return max(num1, num2)\n    def get_min(num1, num2):\n    \"\"\"\n    Return the minimum of two numbers.\n    \"\"\"\n    return max(num1, num2)"
      ],
      [
        0.9145485162734985,
        "def min_number(a, b):\n    \"\"\"\n    Return the minimum of two numbers.\n    \n    >>> min_number(1, 2)\n    1\n    >>> min_number(2, 1)\n    1\n    >>> min_number(1, 1)\n    1\n    \"\"\"\n    return min(a, b)"
      ],
      [
        0.9137495756149292,
        "def find_min(a, b, c):\n    \"\"\"Function which finds the minimum of three numbers\"\"\"\n    min_number = min(a, b, c)\n    return min_number"
      ],
      [
        0.9092329740524292,
        "def min(x, y):\n    \"\"\"\n    Return the minimum of two numbers.\n    \n    >>> min(1, 2)\n    1\n    >>> min(2, 1)\n    1\n    \"\"\"\n    if x < y:\n        return x\n    else:\n        return y"
      ],
      [
        0.9084606170654297,
        "def find_min(lst):\n    \"\"\"\n    Find the minimum value in a list of numbers\n    \"\"\"\n    min_val = lst[0] # Initialize the min_val with the first element of the tuple\n    for i in lst:\n        if i < min_val:\n            min_val = i\n    return min_val\n    def find_min(lst):\n    \"\"\"\n    Find the minimum value in a list of numbers\n    \"\"\"\n    min_val = lst[0] # Initialize the min_val with the first element of the tuple\n    for i in lst:\n        if i < min_val:\n            min_val = i\n    return min_val"
      ],
      [
        0.9073214530944824,
        "def find_min(numbers):\n    \"\"\"\n    Find the minimum number in a list of numbers.\n    :param numbers: a list of numbers\n    :return: the minimum number\n    \"\"\"\n    return min(numbers)"
      ]
    ],
    "MBPP/394": [],
    "MBPP/395": [
      [
        0.9245871901512146,
        "def parity(num):\n    \"\"\"\n    Return even or odd depending on the number\"\"\"\n    if num % 2 == 0:\n        return \"even\"\n    else:\n        return \"odd\""
      ],
      [
        0.9196885228157043,
        "def parity(num):\n    \"\"\"\n    Return the parity of a number.\n    \n    >>> parity(1)\n    'Odd'\n    >>> parity(2)\n    'Even'\n    >>> parity(3)\n    'Odd'\n    >>> parity(4)\n    'Even'\n    >>> parity(5)\n    'Odd'\n    >>> parity(6)\n    'Even'\n    >>> parity(7)\n    'Odd'\n    >>> parity(8)\n    'Even'\n    >>> parity(9)\n    'Odd'\n    >>> parity(10)\n\"\"\"\n    if type(num) != int:\n        return \"Error: Input is not an integer\"\n    elif num % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\""
      ],
      [
        0.9196423292160034,
        "def parity(num):\n    \"\"\"\n    Return even or odd for a given integer\n    \"\"\"\n    try:\n        if num % 2 == 0:\n            return \"even\"\n        else:\n            return \"odd\"\n    except TypeError:\n        return \"Error: input must be an integer\"\n    def parity(num):\n    \"\"\"\n    Return even or odd for a given integer\n    \"\"\"\n    try:\n        if num % 2 == 0:\n            return \"even\"\n        else:\n            return \"odd\"\n    except TypeError:\n        return \"Error: input must be an integer\""
      ],
      [
        0.9185214042663574,
        "def check_parity(n):\n    \"\"\"\n    Check parity of a number\n    :param n: number\n    :return: parity of the number\n    \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return (n & 1) ^ check_parity(n >> 1)"
      ],
      [
        0.9179957509040833,
        "def find_parity(num):\n    \"\"\"\n    Find the parity of a number.\n    \n    Args:\n        num (int): The number to check.\n    \n    Returns:\n        str: 'Even' if the number is even, 'Odd' otherwise.\n    \"\"\"\n    if num % 2 == 0:\n        return 'Even'\n    else:\n        return 'Odd'"
      ],
      [
        0.9173063039779663,
        "def check_parity(n):\n    \"\"\"\n    Check if a number is even or odd\n    \"\"\"\n    # Check if number is even\n    if n % 2 == 0:\n        print('The number {} is even.'.format(n))\n    # If it's not even, it must be odd\n    else:\n        print('The number {} is odd.'.format(n))\n    def check_parity(n):\n    \"\"\"\n    Check if a number is even or odd\n    \"\"\"\n    # Check if number is even\n    if n % 2 == 0:\n        print('The number {} is even.'.format(n))\n    # If it's not even, it must be odd\n    else:\n        print('The number {} is odd.'.format(n))"
      ],
      [
        0.9151862859725952,
        "def parity(n):\n    \"\"\"\n    Return the parity of n.\n    \n    The parity of a number is whether it is even or odd.\n    \n    >>> parity(0)\n    0\n    >>> parity(1)\n    1\n    >>> parity(2)\n    0\n    >>> parity(3)\n    1\n    >>> parity(4)\n    0\n    >>> parity(5)\n    1\n    >>> parity(6)\n    0\n    >>> parity(7)\n    1\n    >>> parity(8)\n    0\n    >>> parity(9)\n    1\n\"\"\"\n    # Base condition: If n is 0 or 1\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    power = 1\n    \n    while power <= n:\n        power *= 2\n\n    power /= 2\n\n    return (1 - parity(n - power))"
      ],
      [
        0.9148987531661987,
        "def check_parity(n):\n    \"\"\"\n    Check if a number is even or odd\n    :param n: number\n    \"\"\"\n    if n % 2 == 0:\n        print('The number is even')\n    else:\n        print('The number is odd')"
      ],
      [
        0.9140782356262207,
        "def check_parity(n):\n    \"\"\"\n    Check if a number is even or odd\n    :param n: number\n    \"\"\"\n    if n % 2 == 0:\n        print(str(n) + \" is even\")\n    else:\n        print(str(n) + \" is odd\")"
      ]
    ],
    "MBPP/396": [
      [
        0.9141411185264587,
        "def nextGreaterElement(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    # Converting the number n to a list of digits\n    digits = [int(d) for d in str(n)]\n\n    # Generating permutations of the digits\n    perm_digits = list(permutations(digits))\n\n    # Sorting the permutations\n    perm_numbers = sorted([int(''.join(map(str, perm))) for perm in perm_digits])\n\n    # Finding the smallest greater number and count number of valid permutations\n    cnt = 0\n    for x in perm_numbers:\n    # Valid number is greater than n and is within 32-bit integer limit\n        if x > n and x <= (2**31 - 1):\n            if cnt == 0:\n                smallest_greater = x\n            cnt += 1\n\n    if cnt == 0:\n        return -1, 0\n    else:\n    # Subtract one permutation which is the smallest greater number itself\n        permutation_cnt = factorial(len(digits)) // (2 * factorial(len(digits) - 2)) - 1\n        return smallest_greater, min(permutation_cnt, cnt - 1)"
      ],
      [
        0.912811815738678,
        "def nextGreaterElement(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    # Converting the number n to a list of digits\n    digits = [int(d) for d in str(n)]\n\n    # Generating permutations of the digits\n    perm_digits = list(permutations(digits))\n\n    # Sorting the permutations\n    perm_numbers = sorted([int(''.join(map(str, perm))) for perm in perm_digits])\n\n    # Finding the smallest greater number and count number of valid permutations\n    cnt = 0\n    for x in perm_numbers:\n        # Valid number is greater than n and is within 32-bit integer limit\n        if x > n and x <= (2**31 - 1) :\n            if cnt == 0:\n                smallest_greater = x\n            cnt += 1\n\n    if cnt == 0:\n        return -1, 0\n    else:\n        # Subtract one permutation which is the smallest greater number itself\n        permutation_cnt = factorial(len(digits)) // (2 * factorial(len(digits) - 2)) - 1\n        return smallest_greater, min(permutation_cnt, cnt - 1)"
      ],
      [
        0.9121452569961548,
        "def nextGreaterElement(n: int) -> int:\n    \"\"\"\n    Find the smallest integer greater than n whose digits are permutations of n's digits.\n    If no such integer exists, return -1.\n    :type n: int\n    :rtype: int\n    \"\"\"\n    num_str = str(n)\n    num_permutations = sorted(set(int(\"\".join(p)) for p in permutations(num_str)))\n    index = num_permutations.index(n)\n    if index + 1 < len(num_permutations) and num_permutations[index + 1] <= 2**31 - 1:\n        return num_permutations[index + 1]\n    return -1"
      ],
      [
        0.8966640830039978,
        "def largest_swap_permutations(num):\n    \"\"\"\n    Given an integer, find the largest permutation of the digits that is smaller than the given integer.\n    :param num: int\n    :return: int\n    \"\"\"\n    num_str = str(num)\n    even_digits = sorted([c for c in num_str if int(c) % 2 == 0], reverse=True)\n    odd_digits = sorted([c for c in num_str if int(c) % 2 == 1], reverse=True)\n\n    result = []\n    for c in num_str:\n        if int(c) % 2 == 0:\n            result.append(even_digits.pop(0))\n        else:\n            result.append(odd_digits.pop(0))\n\n    return int(''.join(result))"
      ]
    ],
    "MBPP/397": [
      [
        0.8944396376609802,
        "def kSmallestPairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n    \"\"\"\n    \"\"\"\n    if not nums1 or not nums2:\n        return []\n\n    heap = []\n    for n1 in nums1:\n        for n2 in nums2:\n            if len(heap) < k:\n                heapq.heappush(heap, (-n1 - n2, [n1, n2]))\n            else:\n                if n1 + n2 < -heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (-n1 - n2, [n1, n2]))\n\n    return [pair for _, pair in heap]"
      ]
    ],
    "MBPP/398": [
      [
        0.9020918011665344,
        "def find_smallest_product(arr):\n    \"\"\"\n    Find the pair of elements in an array that have the smallest product.\n    \n    Args:\n        arr (list): List of integers.\n    \n    Returns:\n        int: The product of the pair of elements with the smallest product.\n    \"\"\"\n    pair = min([(i, j) for i in arr for j in arr if i != j], key=lambda x: x[0]*x[1])\n    return pair[0]*pair[1]"
      ]
    ],
    "MBPP/399": [
      [
        0.89982670545578,
        "def find_smallest_value(L):\n    \"\"\"\n    Find the smallest value in a list L.\n    \n    >>> find_smallest_value([1, 2, 3, 4, 5])\n    1\n    >>> find_smallest_value([1, 2, 3, 4, 5, 0])\n    0\n    \"\"\"\n    return min(L)"
      ]
    ],
    "MBPP/400": [
      [
        0.9136513471603394,
        "def convertToCamelCase(s):\n    \"\"\"\n    Write a function that takes a string and returns it in camel case.\n    \n    The first word within the string should be lowercase, \n    while the rest of the words with an uppercase letter \n    in the beginning (capitalize).\n    \n    Examples\n    \"hello case\"  =>  \"helloCase\"\n    \"camel case word\"  =>  \"camelCaseWord\"\n    \"\"\"\n    s = s.title().replace(' ', '')\n    return s[0].lower() + s[1:]"
      ]
    ],
    "MBPP/401": [
      [
        0.9382392764091492,
        "def remove_odd(arr):\n    \"\"\"\n    Remove odd numbers from the list.\n    \"\"\"\n    return list(filter(lambda num: num % 2 == 0, arr))\n    def remove_odd(arr):\n    \"\"\"\n    Remove odd numbers from the list.\n    \"\"\"\n    return list(filter(lambda num: num % 2 == 0, arr))"
      ],
      [
        0.9296125173568726,
        "def remove_even_numbers(array):\n    \"\"\"\n    Remove all the even numbers from a given array.\n    \"\"\"\n    return list(filter(lambda x: x % 2 != 0, array))\n    def remove_even_numbers(array):\n    \"\"\"\n    Remove all the even numbers from a given array.\n    \"\"\"\n    return list(filter(lambda x: x % 2 != 0, array))"
      ],
      [
        0.9258266687393188,
        "def remove_evens(numbers):\n    \"\"\"\n    Given a list of numbers, return a new list with only the odd numbers.\n    \"\"\"\n    new_list = []\n    for i in numbers:\n        if i % 2 != 0:\n            new_list.append(i)\n    return new_list\n    def remove_evens(numbers):\n    \"\"\"\n    Given a list of numbers, return a new list with only the odd numbers.\n    \"\"\"\n    new_list = []\n    for i in numbers:\n        if i % 2 != 0:\n            new_list.append(i)\n    return new_list"
      ],
      [
        0.9258198738098145,
        "def remove_even_numbers(numbers):\n    \"\"\"\n    Removes all the even numbers from a list of numbers\n    \"\"\"\n    odd_numbers = []\n    for number in numbers:\n        if number % 2 != 0:\n            odd_numbers.append(number)\n    return odd_numbers\n    def remove_even_numbers(numbers):\n    \"\"\"\n    Removes all the even numbers from a list of numbers\n    \"\"\"\n    odd_numbers = []\n    for number in numbers:\n        if number % 2 != 0:\n            odd_numbers.append(number)\n    return odd_numbers"
      ]
    ],
    "MBPP/402": [
      [
        0.8885118961334229,
        "def get_nth(arr, n):\n    \"\"\"\n    Return the nth element of an array.\n    \n    >>> get_nth([1, 2, 3, 4], 2)\n    2\n    \"\"\"\n    return arr[n-1]"
      ],
      [
        0.8835195302963257,
        "def get_nth_element(lst, n):\n    \"\"\"\n    Return the nth element of a list.\n    \n    >>> get_nth_element([1, 2, 3, 4], 2)\n    3\n    >>> get_nth_element([1, 2, 3, 4], 4)\n    Index out of range\n    \"\"\"\n    try:\n        return lst[n]\n    except IndexError:\n        return 'Index out of range'"
      ],
      [
        0.8787717819213867,
        "def get_nth_element(arr, n):\n  \"\"\"\n    Returns the nth element of an array.\n    \n    Args:\n      arr: an array of integers\n      n: an integer\n    \n    Returns:\n      The nth element of the array.\n    \"\"\"\n  return arr[n]"
      ]
    ],
    "MBPP/403": [],
    "MBPP/404": [
      [
        0.9278503060340881,
        "def max_product(lst):\n    \"\"\"\n    This function receives a collection of numerical values (integers),\n    and returns the two elements within that list that, if multiplied\n    together, will yield the absolute highest possible product.\n    \"\"\"\n    \n    # To consider negative numbers and their product which can yield the highest product\n    lst.sort() # First sort the list in increasing order\n    \n    # Checking maximum positive product of first two elements and last two elements\n    product_1 = lst[0] * lst[1]\n    product_2 = lst[-1] * lst[-2]\n    \n    # If first two elements product is higher, return them\n    # Else, return last two elements\n    if product_1 > product_2:\n        return [lst[0], lst[1]]\n    else:\n        return [lst[-1], lst[-2]]"
      ],
      [
        0.9241726398468018,
        "def max_product_pair(lst):\n    \"\"\"\n    Find the pair of elements in a list that have the maximum product.\n    \n    Args:\n        lst: a list of integers\n    \n    Returns:\n        A tuple of two integers that have the maximum product.\n    \"\"\"\n    max_product = float('-inf')\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i]*lst[j] > max_product:\n                max_product = lst[i]*lst[j]\n                pair = (lst[i], lst[j])\n    return pair"
      ],
      [
        0.9214178323745728,
        "def find_max_product(arr):\n    \"\"\"\n    Find the maximum product of two integers in an array\n    :param arr: Array of integers\n    :return: Maximum product of two integers\n    \"\"\"\n    if len(arr) == 0:\n        return 0\n    max_pos_1 = float(\"-inf\")\n    max_pos_2 = float(\"-inf\")\n    max_neg_1 = float(\"inf\")\n    max_neg_2 = float(\"inf\")\n    for num in arr:\n        if num > max_pos_1:\n            max_pos_2 = max_pos_1\n            max_pos_1 = num\n        elif num > max_pos_2:\n            max_pos_2 = num\n\n        if num < max_neg_1:\n            max_neg_2 = max_neg_1\n            max_neg_1 = num\n        elif num < max_neg_2:\n            max_neg_2 = num\n    max_product = max((max_pos_1 * max_pos_2),(max_neg_1 * max_neg_2))\n    return max_product"
      ],
      [
        0.9198233485221863,
        "def max_prod_pair(array):\n    \"\"\"\n    Find the pair of elements in an array that have the maximum product.\n    :param array: list of integers\n    :return: list of two integers\n    \"\"\"\n    if len(array) < 2:\n        return None\n    max_product = array[0] * array[1]\n    max_pair = (array[0], array[1])\n    for i in range(len(array)):\n        for j in range(i+1, len(array)):\n            product = array[i] * array[j]\n            if product > max_product:\n                max_product = product\n                max_pair = (array[i], array[j])\n    return list(max_pair)"
      ],
      [
        0.9191478490829468,
        "def max_product_pair(nums):\n    \"\"\"\n    Find the pair of integers in the list that have the maximum product.\n    \n    Args:\n        nums (list): List of integers.\n    \n    Returns:\n        tuple: Pair of integers with the maximum product.\n    \"\"\"\n    nums.sort(reverse=True)  # Sort the list in descending order\n    max_product = 0\n    result_pair = ()\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n                result_pair = (min(nums[i], nums[j]), max(nums[i], nums[j]))\n\n    return result_pair"
      ]
    ],
    "MBPP/405": [
      [
        0.9114643335342407,
        "def maxSumDivThree(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    dp = [0, 0, 0]\n    for num in nums:\n        temp = dp[:]\n        for s in temp:\n            dp[(s + num) % 3] = max(dp[(s + num) % 3], s + num)\n    return dp[0]"
      ],
      [
        0.9114471077919006,
        "def maxSumDivThree(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    dp = [0, 0, 0]\n    for num in nums:\n        temp = dp[:]\n        for s in temp:\n            dp[(s + num) % 3] = max(dp[(s + num) % 3], s + num)\n    return dp[0]"
      ],
      [
        0.9023041725158691,
        "def sum_of_first_three(arr, index=0):\n    \"\"\"\n    Given an array of integers, return the sum of the first three elements.\n    \n    If the array has fewer than three elements, return the sum of all elements.\n    \n    For example, given [1, 2, 3, 4], return 6.\n    \n    Given [1, 2], return 3.\n    \n    Given [1], return 1.\n    \n    Given [], return 0.\n    \"\"\"\n    if index >= len(arr):\n        return 0\n    \n    if index == 2:\n        return max(arr[index] + arr[index - 1] + arr[index - 2], 0)\n    \n    return arr[index] + sum_of_first_three(arr, index + 1)"
      ],
      [
        0.8984776735305786,
        "def find_max_3_elements(lst): \n    \"\"\"\n    Find the maximum sum of 3 elements in a list\n    :param lst: list of integers\n    :return: maximum sum of 3 elements\n    \"\"\"\n    elements = [] \n    for i in range(len(lst)-2): \n        for j in range(i+1, len(lst)-1): \n            for k in range(j+1, len(lst)): \n                elements.append(lst[i] + lst[j] + lst[k]) \n    return max(elements) "
      ]
    ],
    "MBPP/406": [
      [
        0.8931699991226196,
        "def find_common_elements(list1, list2):\n    \"\"\"\n    Find common elements in two lists\n    \"\"\"\n    common_elements = []\n\n    for e1 in list1:\n        for e2 in list2:\n            if e1 == e2:\n               common_elements.append(e1)\n\n    return common_elements\n    def find_common_elements(list1, list2):\n    \"\"\"\n    Find common elements in two lists\n    \"\"\"\n    common_elements = []\n\n    for e1 in list1:\n        for e2 in list2:\n            if e1 == e2:\n               common_elements.append(e1)\n\n    return common_elements"
      ]
    ],
    "MBPP/407": [],
    "MBPP/408": [
      [
        0.8964580297470093,
        "def rounded_sum(numbers: List[float]) -> int:\n    \"\"\"\n    Return the sum of the list of numbers, rounded to the nearest integer.\n    If the sum is exactly half of an integer, round down.\n    \"\"\"\n    total_sum = sum(numbers)\n    rounded_sum = round(total_sum)\n    if rounded_sum % 2 != 0 and rounded_sum - total_sum == 0.5:\n        rounded_sum = int(rounded_sum) - 1 if int(rounded_sum) % 2 != 0 else int(rounded_sum)\n    return int(rounded_sum)"
      ]
    ],
    "MBPP/409": [
      [
        0.9272183775901794,
        "def sum_of_cube_even_numbers(n):\n    \"\"\"\n    Calculate the sum of the cubes of all even numbers from 2 to n.\n\n    Args:\n        n (int): The upper limit of the range.\n\n    Returns:\n        int: The sum of the cubes of all even numbers from 2 to n.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a positive integer\")\n\n    sum_of_cubes = 0\n    for num in range(2, n+1, 2):\n        sum_of_cubes += num**3\n\n    return sum_of_cubes"
      ]
    ],
    "MBPP/410": [],
    "MBPP/411": [
      [
        0.9147508144378662,
        "def cube_sum(arr):\n    \"\"\"\n    Write a function that takes an array of numbers and returns the average of the cubes of the numbers.\n    \n    Example:\n    \n    cube_sum([1, 2, 3, 4, 5]) \u279e 148.75\n    \n    1^3 + 2^3 + 3^3 + 4^3 + 5^3 = 152\n    \n    Average = 152 / 5 = 30.5\n    \n    round(30.5) = 30.75\"\"\"\n    sum = 0\n    for i in range(len(arr)):\n        arr[i] = arr[i] ** 3\n        sum += arr[i]\n    average = round(sum / len(arr))\n    return average"
      ],
      [
        0.9060145616531372,
        "def sum_of_cubes(n):\n    \"\"\"\n    Return the sum of the cubes of all numbers from 1 to n.\n    \"\"\"\n    result = 0\n    for i in range(1, n+1):\n        result += i ** 3\n    return result\n    def sum_of_cubes(n):\n    \"\"\"\n    Return the sum of the cubes of all numbers from 1 to n.\n    \"\"\"\n    result = 0\n    for i in range(1, n+1):\n        result += i ** 3\n    return result"
      ],
      [
        0.8996531367301941,
        "def accumulative_sum(n):\n    \"\"\"\n    Return the sum of the first n numbers\n    \"\"\"\n    sum = 0\n    for i in range(1, n+1):\n        sum += i\n    return sum\n    \n    def cube_sum(n):\n    \"\"\"\n    Return the sum of the first n numbers\n    \"\"\"\n    sum = 0\n    for i in range(1, n+1):\n        sum += i ** 3\n    return sum"
      ],
      [
        0.896259605884552,
        "def sum_of_cubes(n):\n    \"\"\"\n    Return the sum of the first n cubes.\n    \n    >>> sum_of_cubes(5)\n    225\n    \"\"\"\n    sum = 0\n    for i in range(1, n + 1):\n        sum += i ** 3\n    return sum"
      ],
      [
        0.8949471712112427,
        "def generate_cubes(n):\n    \"\"\"\n    Generate a list of the first n cubes.\n    \"\"\"\n    result = []\n    for x in range(n):\n        result.append(x**3)\n    return result\n    def generate_cubes(n):\n    \"\"\"\n    Generate a list of the first n cubes.\n    \"\"\"\n    result = []\n    for x in range(n):\n        result.append(x**3)\n    return result"
      ],
      [
        0.8946185111999512,
        "def generate_cubes(n):\n    \"\"\"\n    Generate a list of the first n cubes.\n    \"\"\"\n    return [x**3 for x in range(n)]\n    \n    def generate_cubes(n):\n    \"\"\"\n    Generate a list of the first n cubes.\n    \"\"\"\n    return [x**3 for x in range(n)]"
      ]
    ],
    "MBPP/412": [
      [
        0.9062097072601318,
        "def goldMining(mine):\n    \"\"\"\n    :type mine: List[List[int]]\n    :rtype: int\n    \"\"\"\n    def maxGold(mine, dp, i, j, cols):\n        if i < 0 or i >= len(mine) or j < 0 or j >= cols:\n            return 0\n        if dp[i][j][cols] != -1:\n            return dp[i][j][cols]\n        res = 0\n        for x, y in [(0, 1), (0, -1), (1, 0), (-1, 0\"\"\"\n    rows, cols = len(mine), len(mine[0])\n    dp = [[[-1 for _ in range(cols)] for _ in range(cols)] for _ in range(rows)]\n    return maxGold(mine, dp, 0, 0, cols-1)"
      ],
      [
        0.9024122953414917,
        "def goldMining(mine):\n    \"\"\"\n    :type mine: List[List[int]]\n    :rtype: int\n    \"\"\"\n    def maxGold(mine, dp, row, col, cols):\n        if row < 0 or row >= len(mine) or col < 0 or col >= cols:\n            return 0\n        if dp[row][col][cols] != -1:\n            return dp[row][col][cols]\n        res = 0\n        for i in range(col-1, col+2):\n            res = max(res, maxGold(mine, dp,\"\"\"\n    rows, cols = len(mine), len(mine[0])\n    dp = [[[-1 for _ in range(cols)] for __ in range(cols)] for ___ in range(rows)]\n    return maxGold(mine, dp, 0, 0, cols-1)"
      ],
      [
        0.888742208480835,
        "def maxGold(m, dp, x1, y1, y2):\n    \"\"\"\n    :type m: List[List[int]]\n    :type x1: int\n    :type y1: int\n    :type y2: int\n    :rtype: int\n    \"\"\"\n    x2 = x1 + y2 - y1\n    cols = len(m[0])\n    if y1 < 0 or y1 >= cols or y2 < 0 or y2 >= cols:\n        return float('-inf')\n    if dp[x1][y1][y2] != -1:\n        return dp[x1][y1][y2]\n    if x1 == len(m)-1:\n        return m[x1][y1] + (y1 != y2) * m[x2][y2]\n    ans = float('-inf')\n    for new_y1 in [y1-1, y1, y1+1]:\n        for new_y2 in [y2-1, y2, y2+1]:\n            ans = max(ans, maxGold(m, dp, x1+1, new_y1, new_y2))\n    dp[x1][y1][y2] = ans + m[x1][y1] + (y1 != y2) * m[x2][y2]\n    return dp[x1][y1][y2]"
      ],
      [
        0.8885666131973267,
        "def maxGold(m, dp, x1, y1, y2):\n    \"\"\"\n    :type m: List[List[int]]\n    :type x1: int\n    :type y1: int\n    :type y2: int\n    :rtype: int\n    \"\"\"\n    x2 = x1 + y2 - y1\n    cols = len(m[0])\n    if y1<0 or y1>=cols or y2<0 or y2>=cols:\n        return float('-inf')\n    if dp[x1][y1][y2] != -1:\n        return dp[x1][y1][y2]\n    if x1 == len(m)-1:\n        return m[x1][y1] + (y1 != y2) * m[x2][y2]\n    ans = float('-inf')\n    for new_y1 in [y1-1,y1,y1+1]:\n        for new_y2 in [y2-1,y2,y2+1]:\n            ans = max(ans, maxGold(m,dp,x1+1,new_y1,new_y2))\n    dp[x1][y1][y2] = ans + m[x1][y1] + (y1 != y2) * m[x2][y2]\n    return dp[x1][y1][y2]"
      ]
    ],
    "MBPP/413": [
      [
        0.8795528411865234,
        "def get_first_element(lst):\n    \"\"\"\n    Return the first element of the given list.\n    \"\"\"\n    return lst[0]\n    \n    def get_last_element(lst):\n    \"\"\"\n    Return the last element of the given list.\n    \"\"\"\n    return lst[-1]\n    \n    def get_second_element(lst):\n    \"\"\"\n    Return the second element of the given list.\n    \"\"\"\n    return lst[1]\n    \n    def get_second_to_last_element(lst):\n    \"\"\"\n    Return the second to last element of the given list.\"\"\"\n    result = []\n    for tuple in lst:\n        if tuple[0] % 2 == 1:\n            result.append(tuple[0])\n        else:\n            result.append(tuple[1])\n    return result"
      ],
      [
        0.8791627883911133,
        "def extract_third_last(colors):\n    \"\"\"\n    Write a function that takes a tuple of colors and prints the third last color.\n    If the tuple is too small to have a third last color, print \"Tuple is too small to have a third last item\".\n    \n    Example:\n    \n    >>> extract_third_last((\"red\", \"green\", \"blue\", \"yellow\"))\n    blue\n    >>> extract_third_last((\"red\", \"green\"))\n    Tuple is too small to have a third last item\n    \"\"\"\n    try:\n        print(colors[-3])\n    except IndexError:\n        print(\"Tuple is too small to have a third last item\")"
      ],
      [
        0.876011848449707,
        "def third_char(lst):\n    \"\"\"\n    Given a list of words, return the third letter of each word.\n    \"\"\"\n    return [word[2] for word in lst]\n    \n    def third_char(lst):\n    \"\"\"\n    Given a list of words, return the third letter of each word.\n    \"\"\"\n    third_chars = \"\"\n    for word in lst:\n        third_chars += word[2]\n    return third_chars"
      ]
    ],
    "MBPP/414": [],
    "MBPP/415": [],
    "MBPP/416": [
      [
        0.9283691644668579,
        "def format_date(date):\n    \"\"\"\n    Format a date from yyyy-mm-dd to dd-mm-yyyy\n    \"\"\"\n    splitted_date = date.split(\"-\")\n    reformatted_date = splitted_date[::-1]\n    return \"-\".join(reformatted_date)\n    def format_date(date):\n    \"\"\"\n    Format a date from yyyy-mm-dd to dd-mm-yyyy\n    \"\"\"\n    splitted_date = date.split(\"-\")\n    reformatted_date = splitted_date[::-1]\n    return \"-\".join(reformatted_date)"
      ],
      [
        0.908228874206543,
        "def format_date(date):\n    \"\"\"\n    Format a date from dd/mm/yyyy to yyyy-mm-dd\n    \"\"\"\n    date_list = date.split(\"/\")\n    date_list.reverse() \n    return \"-\".join(date_list) \n    def format_date(date):\n    \"\"\"\n    Format a date from dd/mm/yyyy to yyyy-mm-dd\n    \"\"\"\n    date_list = date.split(\"/\")\n    date_list.reverse() \n    return \"-\".join(date_list) "
      ],
      [
        0.903596043586731,
        "def format_date(date):\n    \"\"\"\n    Format a date from MM/DD/YYYY to YYYY/MM/DD\n    \"\"\"\n    date_list = date.split(\"/\")\n    return date_list[2] + \"/\" + date_list[0] + \"/\" + date_list[1]\n    \n    def format_date(date):\n    \"\"\"\n    Format a date from MM/DD/YYYY to YYYY/MM/DD\n    \"\"\"\n    date_list = date.split(\"/\")\n    return date_list[2] + \"/\" + date_list[0] + \"/\" + date_list[1]"
      ],
      [
        0.9004404544830322,
        "def convertDateFormat(inputDate):\n    \"\"\"\n    Converts a date in the format YYYY-MM-DD to MM-DD-YYYY\n    :param inputDate: The date to be converted\n    :return: The converted date\n    \"\"\"\n    dateList = inputDate.split('-')\n    newFormat = dateList[1] + \"-\" + dateList[0] + \"-\" + dateList[2]\n    return newFormat"
      ]
    ],
    "MBPP/417": [],
    "MBPP/418": [
      [
        0.8804166316986084,
        "def calc_tuples(tuple1, tuple2):\n    \"\"\"\n    \"\"\"\n    max_len = max(len(tuple1), len(tuple2))\n    tuple1 = tuple(list(tuple1) + [1]*(max_len - len(tuple1)))\n    tuple2 = tuple(list(tuple2) + [1]*(max_len - len(tuple2)))\n    result = [(tuple1[i] * tuple1[i+1]) + (tuple2[i] * tuple2[i+1]) for i in range(max_len - 1)]\n    return tuple(result)"
      ]
    ],
    "MBPP/419": [
      [
        0.8716647624969482,
        "def solve_quadratic(a, b, c):\n    \"\"\"\n    Solve the quadratic equation, ax**2 + bx + c = 0,\n    using discriminant formula.\n    \"\"\"\n    # calculate the discriminant\n    d = (b**2) - (4*a*c)\n    # find two solutions\n    sol1 = (-b-cmath.sqrt(d))/(2*a)\n    sol2 = (-b+cmath.sqrt(d))/(2*a)\n    return sol1, sol2\n    def solve_quadratic(a, b, c):\n    \"\"\"\n    Solve the quadratic equation, ax**2 + bx\"\"\"\n    # calculate the discriminant\n    d = (b**2) - (4*a*c)\n    # find two solutions\n    sol1 = (-b-cmath.sqrt(d))/(2*a)\n    sol2 = (-b+cmath.sqrt(d))/(2*a)\n    return sol1, sol2"
      ]
    ],
    "MBPP/420": [
      [
        0.9255360960960388,
        "def do_lists_share_common_elements(list1, list2):\n    \"\"\"\n    Return True if any element appears in both lists.\n    >>> do_lists_share_common_elements([1, 2, 3], [4, 5, 6])\n    False\n    >>> do_lists_share_common_elements([1, 2, 3], [2, 4, 6])\n    True\n    \"\"\"\n    for element in list1:\n        if element in list2:\n            return True\n    return False"
      ],
      [
        0.9247807264328003,
        "def has_common_element(list1, list2):\n    \"\"\"\n    Return True if the two lists have at least one element in common.\n    >>> has_common_element([1, 2, 3], [4, 5, 6])\n    False\n    >>> has_common_element([1, 2, 3], [2, 5, 6])\n    True\n    \"\"\"\n    for element in list1:\n        if element in list2:\n            return True\n    return False"
      ]
    ],
    "MBPP/421": [],
    "MBPP/422": [
      [
        0.906019926071167,
        "def filter_greater_than(arr, num):\n    \"\"\"\n    Return a new array with only the elements from the original array that are greater than the given number.\n    \"\"\"\n    return [x for x in arr if x > num]\n    def filter_greater_than(arr, num):\n    \"\"\"\n    Return a new array with only the elements from the original array that are greater than the given number.\n    \"\"\"\n    return [x for x in arr if x > num]"
      ],
      [
        0.8975059390068054,
        "def numbers_greater_than(arr, x):\n  \"\"\"\n  Return a list of all numbers greater than x\n  \"\"\"\n  return [num for num in arr if num > x]\n    def numbers_greater_than(arr, x):\n  \"\"\"\n  Return a list of all numbers greater than x\n  \"\"\"\n  return [num for num in arr if num > x]"
      ],
      [
        0.8945502638816833,
        "def count_greater_than(arr, num):\n    \"\"\"\n    Return the number of array elements that are greater than the given number.\n    \n    >>> count_greater_than([5, 4, 3, 2, 1], 2)\n    3\n    \"\"\"\n    count = 0\n\n    for item in arr:\n        if item > num:\n            count += 1\n    \n    return count"
      ]
    ],
    "MBPP/423": [
      [
        0.8974184989929199,
        "def check_string(s):\n    \"\"\"\n    Check if a string starts with a substring 'a' followed by two to three 'b's.\n    \"\"\"\n    pattern = '^[a][b]{2,3}$' ## matches if sequence starts with \"a\" and followed by 2 to 3 \"b\"\n    if re.match(pattern, s):\n        return True\n    else:\n        return False\n    \n    def check_string(s):\n    \"\"\"\n    Check if a string starts with a substring 'a' followed by two to three 'b's.\n    \"\"\"\n    pattern = '^[a-zA-Z]*py$' ## matches if sequence only consist uppercase or lowercase alphabets and ends with \"py\"\n    if re.match(pattern, s):\n        return True\n    else:\n        return False"
      ],
      [
        0.8936054110527039,
        "def match_pattern(string):\n    \"\"\"\n    Write a regex to match a string that has an 'a' followed by anything,\n    followed by a 'b'\n    \"\"\"\n    pattern = re.compile(r'abc(?=.*[0-9].*?[0-9].*).*xyz$')\n    return bool(pattern.match(string))"
      ],
      [
        0.8932604789733887,
        "def match_string(s):\n    \"\"\"\n    Match a string that contains 'a' followed by any characters, ending in 'b'.\n    \n    Args:\n        s (str): The string to be matched.\n    \n    Returns:\n        bool or str: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    if not isinstance(s, str):\n        return \"Error: Input is not a string.\"\n    pattern = 'a.*b$'\n    if re.search(pattern, s):\n        return True\n    else:\n        return \"Error: The string does not contain 'a' followed by any characters, ending in 'b'.\""
      ],
      [
        0.8876429796218872,
        "def implement_dfa(input_string):\n    \"\"\"\n    Implement a DFA that accepts the language L = {a^nb^n | n >= 0}\n    :param input_string:\n    :return: True if the input string is accepted by the DFA, False otherwise\n    \"\"\"\n    state = 0\n    a_count = 0\n    b_count = 0\n    for c in input_string:\n        if c == 'a':\n            a_count += 1\n            if state == 0:\n                state = 1\n        if c == 'b':\n            b_count += 1\n            if state == 1 and b_count < a_count + 1:\n                state = 2\n            elif state == 1 and b_count == a_count + 1:\n                state = 3\n    if state == 2:\n        return True\n    else:\n        return False"
      ]
    ],
    "MBPP/424": [
      [
        0.9449438452720642,
        "def get_last_digit(number):\n    \"\"\"\n    Write a function that returns the last digit of a given number.\n    \"\"\"\n    return number % 10\n    \n    def get_last_digit(number):\n    \"\"\"\n    Write a function that returns the last digit of a given number.\n    \"\"\"\n    return number % 10"
      ],
      [
        0.8983532786369324,
        "def last_non_zero_digit(n):\n    \"\"\"\n    Last non-zero digit in the factorial of a given number\n    \n    Args:\n        n (int): Given number\n    \n    Returns:\n        int: Last non-zero digit in the factorial of a given number\n    \"\"\"\n    # Array to store last non-zero digit of \n    # factorial of all numbers from 0 to 10\n    res = [1, 1, 2, 6, 4, 2, 2, 4, 2, 8]\n    \n    if (n < 10):\n        return res[n]\n   \n    if (((n//10)%10)%2 == 0):\n        return (6*last_non_zero_digit(n//5)*res[n%10]) % 10\n    else:\n        return (4*last_non_zero_digit(n//5)*res[n%10]) % 10"
      ],
      [
        0.8980202674865723,
        "def sum_last_digits(lst):\n    \"\"\"\n    Given a list of numbers, return the sum of the last digits.\n    \n    >>> sum_last_digits([2, 3, 4])\n    9\n    >>> sum_last_digits([13, 22, 14])\n    9\n    \"\"\"\n    ans = 0\n    for num in lst:\n        ans += int(num[-1])\n    return ans"
      ],
      [
        0.8957479000091553,
        "def rightmost_digit(num):\n    \"\"\"\n    Find the rightmost digit of a number.\n    >>> rightmost_digit(123)\n    3\n    >>> rightmost_digit(456789)\n    9\n    \"\"\"\n    # convert num to string\n    str_num = str(num)\n    # find the index position of \".\"\n    dot_position = str_num.index('.')\n    # find the rightmost digit before the \".\" and convert it to int\n    digit = int(str_num[dot_position - 1])\n    return digit"
      ]
    ],
    "MBPP/425": [
      [
        0.9094878435134888,
        "def negative(int_list):\n    \"\"\"\n    Return a list of the negative integers in the input list.\n    \n    >>> negative([1, -2, 3, -4])\n    [-2, -4]\n    \"\"\"\n    return [num for num in int_list if num < 0]"
      ],
      [
        0.9088325500488281,
        "def filter_negative(lst): \n    \"\"\"\n    This function takes a list of numbers and returns a list of only the negative numbers.\n    \n    Parameters:\n    lst (list): A list of numbers.\n    \n    Returns:\n    list: A list of only the negative numbers from the input list.\n    \"\"\"\n    neg_lst = [] \n    for num in lst: \n        if num < 0: \n            neg_lst.append(num) \n\n    return neg_lst"
      ],
      [
        0.9070844650268555,
        "def negative_list(numbers):\n    \"\"\"\n    Return a list of negative numbers from a given list of numbers.\n    \n    Args:\n        numbers (list): A list of numbers.\n    \n    Returns:\n        list: A list of negative numbers.\n    \"\"\"\n    return [num for num in numbers if num < 0]"
      ],
      [
        0.9059547781944275,
        "def get_negative_numbers(numbers):\n  \"\"\"\n  Returns a list of negative numbers from a list of numbers.\n  \n  Args:\n    numbers: A list of numbers.\n  \n  Returns:\n    A list of negative numbers.\n  \"\"\"\n  return [num for num in numbers if num < 0]"
      ]
    ],
    "MBPP/426": [
      [
        0.9338349103927612,
        "def remove_odd_index_characters(string):\n    \"\"\"\n    Remove characters which have odd index values in the given string\n    \"\"\"\n    result = \"\"\n    for i in range(len(string)):\n        if i % 2 == 0:\n            result += string[i]\n    return result\n    def remove_odd_index_characters(string):\n    \"\"\"\n    Remove characters which have odd index values in the given string\n    \"\"\"\n    result = \"\"\n    for i in range(len(string)):\n        if i % 2 == 0:\n            result += string[i]\n    return result"
      ],
      [
        0.9282875657081604,
        "def remove_odd_index_char(string):\n    \"\"\"\n    Remove the characters of odd index in a given string\n    \"\"\"\n    result = \"\"\n    for i in range(len(string)):\n        if i % 2 == 0:\n            result = result + string[i]\n    return result"
      ],
      [
        0.9264898300170898,
        "def remove_even(string):\n    \"\"\"\n    Remove all even occuring characters from a string\n    \"\"\"\n    result = \"\"\n    count = {}\n\n    for char in string:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n\n    for ch, val in count.items():\n        if val % 2 != 0:\n            result += ch\n    return result\n    def remove_even(string):\n    \"\"\"\n    Remove all even occuring characters from a string\n    \"\"\"\n    result = \"\"\n    count = {}\n\n    for char in string:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n\n    for ch, val in count.items():\n        if val % 2 != 0:\n            result += ch\n    return result"
      ],
      [
        0.918079137802124,
        "def remove_odd_characters(string):\n    \"\"\"\n    Remove odd characters from a string.\n    \n    Args:\n        string (str): The input string.\n    \n    Returns:\n        str: The modified string with odd characters removed.\n    \"\"\"\n    # Remove leading and trailing whitespace characters\n    string = string.strip()\n    \n    # Remove punctuation marks from the string\n    string = string.translate(str.maketrans('', '', string.punctuation))\n    \n    # Remove characters at odd indices\n    modified_string = ''\n    for index, char in enumerate(string):\n        if index % 2 == 0:\n            modified_string += char\n    \n    return modified_string"
      ]
    ],
    "MBPP/427": [],
    "MBPP/428": [
      [
        0.9093959927558899,
        "def int_to_int(int_list):\n    \"\"\"\n    \"\"\"\n    return int(''.join(str(e) for e in int_list))"
      ],
      [
        0.9093149304389954,
        "def list_to_int(list_of_ints):\n    \"\"\"\n    Converts a list of integers into a single integer.\n    \n    Args:\n        list_of_ints: A list of integers.\n    \n    Returns:\n        The integer created from concatenating the list of integers.\n    \"\"\"\n    number = 0\n    for integer in list_of_ints:\n        number = number * 10 + integer\n    return number"
      ]
    ],
    "MBPP/429": [
      [
        0.8957799077033997,
        "def find_adverb(string):\n    \"\"\"\n    Find the adverb in a sentence.\n    \n    Args:\n        string: a sentence to search for an adverb in\n    \n    Returns:\n        A tuple of the form (adverb, start, end) if an adverb is found,\n        or None otherwise.\n    \"\"\"\n    words = string.split(\" \")\n    for word in words:\n        if word.endswith('ly'):\n            start = string.index(word)\n            end = start + len(word) - 1\n            return (word, start, end)\n    return None"
      ]
    ],
    "MBPP/430": [
      [
        0.935171365737915,
        "def cube_surface_area(side):\n    \"\"\" \n    Calculate and return the total surface area of a cube \n    given the side length.\n    \"\"\"\n    return 6 * side**2"
      ]
    ],
    "MBPP/431": [],
    "MBPP/432": [
      [
        0.9214021563529968,
        "def find_largest_negative(arr):\n    \"\"\"\n    Find the largest negative number in an array.\n\n    Args:\n        arr (list): The input array.\n\n    Returns:\n        int or str: The largest negative number in the array, or a message if no negative numbers are found.\n    \"\"\"\n    if len(arr) == 0:\n        return \"Array is empty.\"\n\n    largest_negative = float('-inf')  # Initialize largest_negative as negative infinity\n\n    for num in arr:\n        if num < 0 and num > largest_negative:\n            largest_negative = num\n\n    if largest_negative == float('-inf'):\n        return \"No negative numbers found.\"\n    else:\n        return largest_negative"
      ],
      [
        0.906901478767395,
        "def get_highest_negative(array):\n    \"\"\"\n    Return the highest negative number in an array.\n    If there are no negative numbers, return None.\n    \n    >>> get_highest_negative([1, 2, 3, 4])\n    None\n    >>> get_highest_negative([1, -2, 3, -4])\n    -4\n    \"\"\"\n    n = float('-inf')\n    for num in array:\n        if num < 0 and num > n:\n            n = num\n    return n"
      ],
      [
        0.9021984338760376,
        "def find_largest_number(arr):\n    \"\"\"\n    Find the largest number in an array.\n    \n    Args:\n        arr (list): The array of numbers.\n    \n    Returns:\n        int: The largest number in the array.\n    \"\"\"\n    max_num = 0\n    for num in arr:\n        if num < 0:\n            return \"Error: Negative numbers are not allowed.\"\n        if num > max_num:\n            max_num = num\n    return max_num"
      ],
      [
        0.9008729457855225,
        "def largest_negative_integer(matrix):\n    \"\"\"\n    Find the largest negative integer in a matrix.\n    \n    Args:\n        matrix (list): A matrix of integers.\n    \n    Returns:\n        int: The largest negative integer in the matrix.\n    \"\"\"\n    if np.max(matrix) >= 0:\n        return -1\n    if np.min(matrix) > 0:\n        return np.min(matrix) - 1\n    low, high = np.min(matrix), -1\n    while low < high:\n        mid = low + (high - low) // 2\n        if is_present(matrix, mid):\n            low = mid + 1\n        else:\n            high = mid\n    return high - 1"
      ]
    ],
    "MBPP/433": [],
    "MBPP/434": [],
    "MBPP/435": [
      [
        0.9038769602775574,
        "def count_occurrences(lst):\n    \"\"\"\n    Given a list of integers, return a list of tuples where each tuple contains a number and the number of occurrences of that number in the list.\n    The list of tuples should be ordered in descending order based on the count of occurrences.\n    For example, given the list [1, 2, 3, 1, 2, 3, 1, 4, 5], return [(1, 3), (2, 2), (3, 2), (4, 1), (5, 1)].\n    \"\"\"\n    from collections import Counter\n    \n\"\"\"\n    count = Counter(lst)  # Count occurrences of each distinct integer\n    result = [(i, count[i]) for i in count]  # Convert to the desired output format\n    result.sort(key=lambda x: (-x[1], x[0]))  # Sort first by descending count, then by ascending integer\n    return result"
      ]
    ],
    "MBPP/436": [
      [
        0.9304458498954773,
        "def cube_elements(lst):\n    \"\"\"\n    Write a function that takes a list of numbers and returns a new list with each element \n    cubed.\n    \"\"\"\n    return [i ** 3 for i in lst]\n    \n    def cube_elements(lst):\n    \"\"\"\n    Write a function that takes a list of numbers and returns a new list with each element \n    cubed.\n    \"\"\"\n    return [i ** 3 for i in lst]"
      ]
    ],
    "MBPP/437": [],
    "MBPP/438": [
      [
        0.9113601446151733,
        "def is_valid_triangle(point1, point2, point3):\n    \"\"\"\n    Check if three points in 3D space can form a valid triangle\n    \"\"\"\n    # Check if all points are distinct\n    if point1 == point2 or point1 == point3 or point2 == point3:\n        return False\n\n    # Check if all points lie on a straight line\n    vector1 = [point2[i] - point1[i] for i in range(3)]\n    vector2 = [point3[i] - point1[i] for i in range(3)]\n    cross_product = [vector1[(i+1)%3]*vector2[(i+2)%3] - vector1[(i+2)%3]*vector2[(i+1)%3] for i in range(3)]\n    if all(c == 0 for c in cross_product):\n        return False\n\n    return True"
      ],
      [
        0.9096716046333313,
        "def is_valid_triangle(a, b, c): \n    \"\"\"\n    Check if a triangle is valid or not\n    :param a: side a\n    :param b: side b\n    :param c: side c\n    :return: True if the triangle is valid else False\n    \"\"\"\n    # A triangle should have 3 sides\n    if a + b <= c or a + c <= b or b + c <= a: \n        return False\n\n    # The sum of any two sides should always be greater than the third side\n    if a + b > c and a + c > b and b + c > a: \n        return True\n    return False"
      ]
    ],
    "MBPP/439": [],
    "MBPP/440": [],
    "MBPP/441": [],
    "MBPP/442": [],
    "MBPP/443": [
      [
        0.8931182026863098,
        "def has_z_followed_by_two_ys(string):\n    \"\"\"Does string contain a literal \"z\" followed by two \"y\" characters?\n    >>> has_z_followed_by_two_ys(\"ziy\")\n    True\n    >>> has_z_followed_by_two_ys(\"zy\")\n    False\n    >>> has_z_followed_by_two_ys(\"z\")\n    False\n    >>> has_z_followed_by_two_ys(\"zyy\")\n    False\n    >>> has_z_followed_by_two_ys(\"zxy\")\n    False\n    >>> has_z_followed_\"\"\"\n    return re.search(r'zy{2,}', string) is not None"
      ],
      [
        0.886824369430542,
        "def check_word(word):\n    \"\"\"\n    Check if a word contains 'ba' followed by either 'r' or 'z'\n    :param word: str - word to check\n    :return: bool - does word contain 'ba' followed by 'r' or 'z'\n    \"\"\"\n    regexp = r'ba[r|z|d]'\n    if re.search(regexp, word):\n        return True\n    return False"
      ],
      [
        0.8850387334823608,
        "def find_target_substrings(text):\n    \"\"\"\n    Find all substrings in the given text that start with 'a' and end with 'Z'.\n    \"\"\"\n    import re\n    \n    # TODO: Implement the function\"\"\"\n    pattern = re.compile(r'a.*Z')\n    return pattern.findall(text)"
      ],
      [
        0.8838974237442017,
        "def find_z_followed_by_2y(s):\n    \"\"\"\n    Find the index of the first occurrence of 'z' in a string, followed by two 'y's.\n    Return -1 if not found.\n    \n    >>> find_z_followed_by_2y('z')\n    -1\n    >>> find_z_followed_by_2y('zxy')\n    -1\n    >>> find_z_followed_by_2y('zyzy')\n    1\n    >>> find_z_followed_by_2y('zyzyz')\n    -1\n    >>> find_z_followed_\"\"\"\n    s = s.lower()\n    for index in range(len(s) - 2):\n        if s[index] == 'z' and s[index+1] == 'y' and s[index+2] == 'y':\n            return index\n    return -1"
      ]
    ],
    "MBPP/444": [
      [
        0.9016096591949463,
        "def check_days(month, year):\n    \"\"\"\n    Check if a month has 30 days.\n    \n    Args:\n        month (int): The month number (1-12).\n        year (int): The year.\n    \n    Returns:\n        bool: True if the month has 30 days, False otherwise.\n    \"\"\"\n    thirty_days_months = [4, 6, 9, 11]\n    if month in thirty_days_months:\n        return True\n    elif month == 2:\n        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):\n            return False  # February has 29 days in a leap year\n        else:\n            return True  # February has 28 days in a non-leap year\n    else:\n        return False  # Months not listed have 31 days"
      ]
    ],
    "MBPP/445": [],
    "MBPP/446": [],
    "MBPP/447": [
      [
        0.9249044060707092,
        "def calculate_area(length, width):\n    \"\"\"Calculate the area of a rectangle given its length and width.\"\"\"\n    area = length * width\n    return area"
      ],
      [
        0.9204224348068237,
        "def area_rectangle(length, width):\n  \"\"\"\n  This function calculates the area of a rectangle.\n  :param length: The length of the rectangle.\n  :param width: The width of the rectangle.\n  :return: The area of the rectangle.\n  \"\"\"\n  area = length * width\n  return area"
      ],
      [
        0.9193296432495117,
        "def calculateArea(width, height):\n    \"\"\"\n    Calculate the area of a rectangle.\n    \n    :param width: The width of the rectangle.\n    :param height: The height of the rectangle.\n    :return: The area of the rectangle.\n    \"\"\"\n    return width * height"
      ],
      [
        0.9170172214508057,
        "def area_rectangle(length, width):\n    \"\"\"\n    This function calculates the area of a rectangle.\n    :param length: The length of the rectangle.\n    :param width: The width of the rectangle.\n    :return: The area of the rectangle.\n    \"\"\"\n    return length * width"
      ],
      [
        0.916586697101593,
        "def calculate_area(width, height):\n    \"\"\"\n    Calculate the area of a rectangle.\n    \n    Args:\n        width (int): The width of the rectangle.\n        height (int): The height of the rectangle.\n    \n    Returns:\n        int: The area of the rectangle.\n    \"\"\"\n    return width * height"
      ],
      [
        0.9161219596862793,
        "def calculate_area(width: float, height: float) -> float:\n    \"\"\"\n    This function calculates the area of a rectangle.\n    \n    :param width: float - width of the rectangle\n    :param height: float - height of the rectangle\n    :return: float - area of the rectangle\n    \"\"\"\n    area = width * height\n    return area"
      ]
    ],
    "MBPP/448": [
      [
        0.9057762026786804,
        "def removeLetters(string, letter):\n    \"\"\"\n    Remove all instances of letter from string.\n    \"\"\"\n    new_string = \"\"\n    for char in string:\n        if char.lower() != letter.lower():\n            new_string += char\n    return new_string\n    def removeLetters(string, letter):\n    \"\"\"\n    Remove all instances of letter from string.\n    \"\"\"\n    new_string = \"\"\n    for char in string:\n        if char.lower() != letter.lower():\n            new_string += char\n    return new_string"
      ],
      [
        0.8996686935424805,
        "def remove_uppercase_characters(string):\n    \"\"\"\n    Remove all uppercase characters from a string.\n    \n    Args:\n        string (str): The string to remove uppercase characters from.\n    \n    Returns:\n        str: The string with all uppercase characters removed.\n    \"\"\"\n    return ''.join([c for c in string if not c.isupper()])"
      ]
    ],
    "MBPP/449": [
      [
        0.9079941511154175,
        "def remove_first_element(lists):\n    \"\"\"\n    Remove the first element from each sublist in the given list of lists.\n    \n    Args:\n    - lists: A list of lists.\n    \n    Returns:\n    - A new list of lists with the first element removed from each sublist.\n    \"\"\"\n    # Use list slicing to remove the first element of each sublist\n    return [lst[1:] for lst in lists]"
      ],
      [
        0.8978064060211182,
        "def first_element(lst):\n    \"\"\"\n    Return the first element of the given list.\n    >>> first_element([1, 2, 3])\n    1\n    >>> first_element([5, 6, 7])\n    5\n    \"\"\"\n    return lst[0]"
      ],
      [
        0.8883653283119202,
        "def get_first_element(lst):\n    \"\"\"\n    Return the first element of the given list.\n    \"\"\"\n    return lst[0]\n    \n    def get_last_element(lst):\n    \"\"\"\n    Return the last element of the given list.\n    \"\"\"\n    return lst[-1]\n    \n    def get_second_element(lst):\n    \"\"\"\n    Return the second element of the given list.\n    \"\"\"\n    return lst[1]\n    \n    def get_second_to_last_element(lst):\n    \"\"\"\n    Return the second to last element of the given list.\"\"\"\n    result = []\n    for tuple in lst:\n        if tuple[0] % 2 == 1:\n            result.append(tuple[0])\n        else:\n            result.append(tuple[1])\n    return result"
      ]
    ],
    "MBPP/450": [
      [
        0.9375022649765015,
        "def count_uppercase_characters(string):\n    \"\"\"\n    Count the number of uppercase characters in a string.\n    \n    >>> count_uppercase_characters('Python')\n    1\n    >>> count_uppercase_characters('PYTHON')\n    6\n    \"\"\"\n    chars = [c for c in string if c.isupper()]\n    return len(chars)"
      ]
    ],
    "MBPP/451": [
      [
        0.9192818403244019,
        "def all_combinations(list_of_numbers): \n    \"\"\"\n    This function takes a list of numbers and returns a list of all possible combinations of those numbers. \n    For example, if the input is [1, 2, 3], the output will be [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]. \n    The function uses recursion to generate all possible combinations. \n    The base case is when the list is empty, in which case the function returns an empty list. \n    The base case is also when the\"\"\"\n    if len(list_of_numbers) == 0: \n        return [] \n  \n    if len(list_of_numbers) == 1: \n        return [list_of_numbers] \n  \n    combinations = [] \n    for combination in all_combinations(list_of_numbers[1:]): \n        combinations.append(combination) \n        combinations.append([list_of_numbers[0]] + combination) \n  \n    return combinations"
      ],
      [
        0.9143268465995789,
        "def print_combinations(l): \n    \"\"\"\n    Print all possible combinations of a list\n    :param l: list\n    \"\"\"\n    # Get the length of the list\n    n = len(l) \n\n    # Create all possible combinations\n    for i in range(1 << n): \n        comb = [l[j] for j in range(n) if (i & (1 << j))] \n        print(comb)"
      ]
    ],
    "MBPP/452": [
      [
        0.9399199485778809,
        "def maxProductSubarray(array):\n    \"\"\"\n    Find the maximum product subarray in a given array.\n    \n    Args:\n        array: List[int]\n    \n    Returns:\n        int: Maximum product subarray\n    \"\"\"\n    max_product = float('-inf')\n    for window_start in range(len(arr)):\n        prod = 1\n        for window_end in range(window_start, len(arr)):\n            prod *= arr[window_end]\n            max_product = max(prod, max_product)\n    return max_product"
      ],
      [
        0.9354787468910217,
        "def max_product_subarray(arr):\n    \"\"\"\n    Find the maximum product subarray in an array.\n    :param arr: List[int]\n    :return: int\n    \"\"\"\n    n = len(arr)\n    min_ending_here = max_ending_here = max_so_far = arr[0]\n\n    for i in range(1, n):\n        if arr[i] < 0:\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_ending_here = min(arr[i], min_ending_here * arr[i])\n\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far"
      ]
    ],
    "MBPP/453": [
      [
        0.8848572969436646,
        "def is_same(my_list):\n  \"\"\"\n  Checks if all elements in a list are the same.\n  Args:\n    my_list: a list of elements\n  Returns:\n    True if all elements are the same, False otherwise\n  \"\"\"\n  for i in range(len(my_list)):\n    for j in range(i + 1, len(my_list)):\n      if my_list[i] != my_list[j]:\n        return False\n  return True"
      ]
    ],
    "MBPP/454": [
      [
        0.8957487344741821,
        "def remove_empty_values(my_dict):\n    \"\"\"\n    Removes all empty values from a dictionary.\n    \n    Args:\n        my_dict (dict): The dictionary to remove empty values from.\n    \n    Returns:\n        dict: The dictionary with empty values removed.\n    \"\"\"\n    return {k: v for k, v in my_dict.items() if v}"
      ]
    ],
    "MBPP/455": [
      [
        0.9290738105773926,
        "def findPeak(arr, n): \n    \"\"\"\n    :type arr: List[int]\n    :type n: int\n    :rtype: int\n    \"\"\"\n    # Corner Case \n    if (n == 1): \n        return arr[0] \n  \n    # If arr[0] is peak element \n    if (arr[0] >= arr[1]): \n        return arr[0] \n  \n    # If arr[n-1] is peak element \n    if (arr[n - 1] >= arr[n - 2]): \n        return arr[n - 1] \n  \n    # If there is no peak element \n    for i in range(1, n - 1): \n        if (arr[i] >= arr[i - 1] and arr[i] >= arr[i + 1]): \n            return arr[i] "
      ],
      [
        0.9284528493881226,
        "def find_peak_element(arr):\n    \"\"\"\n    Find a peak element in an array.\n    \n    Args:\n        arr: An array of integers.\n    \n    Returns:\n        The index of a peak element in the array.\n    \"\"\"\n    if len(arr) == 1:\n        return arr[0]\n    if arr[0] >= arr[1]:\n        return arr[0]\n    if arr[-1] >= arr[-2]:\n        return arr[-1]\n    for i in range(1, len(arr)-1):\n        if arr[i] >= arr[i-1] and arr[i] >= arr[i+1]:\n            return i"
      ]
    ],
    "MBPP/456": [
      [
        0.9363401532173157,
        "def convert_to_octal(num):\n    \"\"\"\n    This function converts a decimal number to octal\n    \"\"\"\n    oct_num = oct(num)\n    print(\"The octal form of {} is {}\".format(num, oct_num))\n    \n    def convert_to_octal(num):\n    \"\"\"\n    This function converts a decimal number to octal\n    \"\"\"\n    oct_num = oct(num)\n    print(\"The octal form of {} is {}\".format(num, oct_num))"
      ]
    ],
    "MBPP/457": [],
    "MBPP/458": [
      [
        0.907058835029602,
        "def maxProfit(prices, k):\n    \"\"\"\n    :type prices: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if not prices or k >= len(prices):\n        return 0\n\n    n = len(prices)\n\n    buy = [-prices[0]] * n\n    sell = [0] * n\n    cooldown = [0] * n\n\n    for i in range(1, n):\n        cooldown[i] = max(cooldown[i-1], sell[i-1])\n\n        if i > k:\n            sell[i] = max(sell[i-1], buy[i-1] + prices[i])\n            buy[i] = max(buy[i-1], cooldown[i-k-1] - prices[i])\n        else:\n            sell[i] = max(sell[i-1], buy[i-1] + prices[i])\n            buy[i] = max(buy[i-1], -prices[i])\n\n    return max(sell[-1], cooldown[-1])"
      ],
      [
        0.9070403575897217,
        "def maxProfit(prices, k):\n    \"\"\"\n    :type prices: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if not prices or k >= len(prices):\n        return 0\n\n    n = len(prices)\n\n    buy = [-prices[0]] * n\n    sell = [0] * n\n    cooldown = [0] * n\n\n    for i in range(1, n):\n        cooldown[i] = max(cooldown[i-1], sell[i-1])\n\n        if i > k:\n            sell[i] = max(sell[i-1], buy[i-1] + prices[i])\n            buy[i] = max(buy[i-1], cooldown[i-k-1] - prices[i])\n        else:\n            sell[i] = max(sell[i-1], buy[i-1] + prices[i])\n            buy[i] = max(buy[i-1], -prices[i])\n\n    return max(sell[-1], cooldown[-1])"
      ]
    ],
    "MBPP/459": [
      [
        0.9097142219543457,
        "def sum_tuples(input_list):\n    \"\"\"\n    Write a function that takes a list of tuples as input and returns the sum of all the elements in the tuples.\n    For example, if the input is [(1, 2), (3, 4), (5, 6)], the output should be 21.\n    \"\"\"\n    total_sum = 0\n    for tup in input_list:\n        for elem in tup:\n            total_sum += elem\n    return total_sum"
      ],
      [
        0.896437406539917,
        "def add_tuples(tpl1, tpl2):\n    \"\"\"\n    Add two tuples element-wise.\n    \n    >>> add_tuples((1, 2), (10, 20))\n    (11, 22)\n    >>> add_tuples((1, 2), (10, 20, 30))\n    Traceback (most recent call last):\n        ...\n    ValueError: tuples must be of the same length\n    \"\"\"\n    for a, b in tpl1: \n        for c, d in tpl2:\n            return (a+c, b+d)"
      ]
    ],
    "MBPP/460": [],
    "MBPP/461": [
      [
        0.9173572659492493,
        "def check_for_consecutive(arr):\n    \"\"\"\n    Check if an array contains consecutive numbers\n    \"\"\"\n    count = 0\n\n    for i in range(0, len(arr)):\n        if (i+1 < len(arr)) and (arr[i] + 1 == arr[i+1]):\n            count += 1\n\n    if count > 0:\n        return True\n    else:\n        return False\n    def check_for_consecutive(arr):\n    \"\"\"\n    Check if an array contains consecutive numbers\n    \"\"\"\n    count = 0\n\n    for i in range(0, len(arr)):\n        if (i+1 < len(arr)) and (arr[i] + 1 == arr[i+1]):\n            count += 1\n\n    if count > 0:\n        return True\n    else:\n        return False"
      ],
      [
        0.9141449928283691,
        "def has_consecutive_numbers(arr):\n    \"\"\"\n    Given an array of integers, return true if the array contains consecutive numbers.\n    \n    >>> has_consecutive_numbers([1, 2, 3, 4, 5])\n    True\n    >>> has_consecutive_numbers([1, 2, 4, 5])\n    False\n    >>> has_consecutive_numbers([1, 2, 3, 4, 6])\n    False\n    \"\"\"\n    arr.sort()\n    for i in range(len(arr)-1):\n        if arr[i+1] - arr[i] == 1:\n            return True\n    return False"
      ],
      [
        0.9134858250617981,
        "def is_consecutive(input_list):\n    \"\"\"\n    Check if all numbers in a list are consecutive\n    \"\"\"\n    if len(input_list) <= 1:\n        return True\n    for index, item in enumerate(input_list[1:]):\n        if item - input_list[index] != 1:\n            return False\n    return True\n    def is_consecutive(input_list):\n    \"\"\"\n    Check if all numbers in a list are consecutive\n    \"\"\"\n    if len(input_list) <= 1:\n        return True\n    for index, item in enumerate(input_list[1:]):\n        if item - input_list[index] != 1:\n            return False\n    return True"
      ],
      [
        0.909623384475708,
        "def is_consecutive(arr):\n    \"\"\"\n    Check if all elements in an array are consecutive\n    \"\"\"\n    return sorted(arr) == list(range(min(arr), max(arr)+1))\n    def is_consecutive(arr):\n    \"\"\"\n    Check if all elements in an array are consecutive\n    \"\"\"\n    return sorted(arr) == list(range(min(arr), max(arr)+1))"
      ],
      [
        0.9043477177619934,
        "def is_consecutive(array, start, end):\n    \"\"\" Check if there are any successive elements present between start and end index.\"\"\"\n    for i in range(start, end):\n        if array[i] + 1 == array[i + 1]:\n            return True\n    return False"
      ],
      [
        0.9034055471420288,
        "def check_consecutive(arr):\n    \"\"\"\n    Check if an array contains consecutive numbers\n    \n    Args:\n        arr (list): List of numbers\n    \n    Returns:\n        bool: True if consecutive, False otherwise\n    \"\"\"\n    for i in range(len(arr)-1):\n        if arr[i] + 1 == arr[i+1]:\n            return True\n    return False"
      ]
    ],
    "MBPP/462": [
      [
        0.8987722396850586,
        "def intersection(list1, list2):\n    \"\"\"\n    Find intersection of two lists\n    \"\"\"\n    return list(set(list1) & set(list2))\n    \n    def intersection(list1, list2):\n    \"\"\"\n    Find intersection of two lists\n    \"\"\"\n    set1 = set(list1)\n    set2 = set(list2)\n\n    return list(set1.intersection(set2))"
      ],
      [
        0.8960928320884705,
        "def find_intersection(arr1, arr2):\n    \"\"\"\n    Find intersection of two arrays\n    \"\"\"\n    set1 = set(arr1)\n    set2 = set(arr2)\n    intersection = set1 & set2\n    return list(intersection)\n    def find_intersection(arr1, arr2):\n    \"\"\"\n    Find intersection of two arrays\n    \"\"\"\n    set1 = set(arr1)\n    set2 = set(arr2)\n    intersection = set1 & set2\n    return list(intersection)"
      ]
    ],
    "MBPP/463": [],
    "MBPP/464": [],
    "MBPP/465": [
      [
        0.9166878461837769,
        "def sum_of_min_max(lst):\n    \"\"\"\n    Function to take a list of integers and returns the summation of the largest and smallest numbers\n    Arguments:\n    lst -- list -- list of integers\n    Output:\n    summation -- int -- summation of the largest and smallest numbers\n    \"\"\"\n    min_val = min(lst)\n    max_val = max(lst)\n    summation = min_val + max_val\n    return summation"
      ]
    ],
    "MBPP/466": [
      [
        0.9202669262886047,
        "def to_lower_case(s): \n    \"\"\"\n    Write a function that takes a string as input and returns the string in lower case.\n    \n    Parameters\n    ----------\n    s : str\n        Input string.\n    \n    Returns\n    -------\n    str\n        String in lower case.\n    \"\"\"\n    return s.lower() "
      ],
      [
        0.9135994911193848,
        "def to_lower_case(str):\n  \"\"\"\n  Converts a string to lower case.\n  \n  Args:\n    str: The string to be converted.\n  \n  Returns:\n    The string in lower case.\n  \"\"\"\n  return str.lower()"
      ],
      [
        0.9114802479743958,
        "def convert_string(input_str):\n    \"\"\"\n    Converts a string to lowercase.\n    \n    Args:\n        input_str (str): The string to be converted.\n        \n    Returns:\n        str: The converted string in lowercase.\n    \"\"\"\n    output = input_str.lower()    # Use the lower() method on the string directly\n    return output"
      ]
    ],
    "MBPP/467": [
      [
        0.9230068325996399,
        "def removeLetters(string, letter):\n    \"\"\"\n    Remove all instances of letter from string.\n    \"\"\"\n    new_string = \"\"\n    for char in string:\n        if char.lower() != letter.lower():\n            new_string += char\n    return new_string\n    def removeLetters(string, letter):\n    \"\"\"\n    Remove all instances of letter from string.\n    \"\"\"\n    new_string = \"\"\n    for char in string:\n        if char.lower() != letter.lower():\n            new_string += char\n    return new_string"
      ]
    ],
    "MBPP/468": [
      [
        0.9010103344917297,
        "def findNthDigit(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    size = 1\n    length = 9\n    start = 1\n\n    while n > length * size:\n        n -= length * size\n        size += 1\n        length *= 10\n        start *= 10\n\n    start += (n - 1) // size\n    s = str(start)\n    return int(s[(n - 1) % size])"
      ],
      [
        0.8986867666244507,
        "def non_zero_digit_in_factorial(n):\n    \"\"\"\n    Find the first non-zero digit in the factorial of a given number.\n    \n    Args:\n        n (int): The number to find the factorial of.\n    \n    Returns:\n        int: The first non-zero digit in the factorial of n.\n    \"\"\"\n    factorial = 1\n    for i in range(1, n+1):\n        factorial *= i\n        while factorial % 10 == 0:\n            factorial //= 10\n        factorial %= 1000000000\n    return factorial % 10"
      ],
      [
        0.894553005695343,
        "def non_zero_digit_in_factorial(n):\n    \"\"\"\n    Find the first non-zero digit in the factorial of a given number.\n    \n    Args:\n        n (int): The number to find the factorial of.\n    \n    Returns:\n        int: The first non-zero digit in the factorial of n.\n    \"\"\"\n    factorial = 1\n    for i in range(1, n+1):\n        factorial *= i\n        while factorial % 10 == 0:    # remove all trailing zeros\n            factorial //= 10\n        factorial %= 1000000000       # limit the size of factorial to prevent overflow\n    return factorial % 10"
      ]
    ],
    "MBPP/469": [
      [
        0.9394875764846802,
        "def maxOccurringChar(input): \n      \"\"\"\n      Find the maximum occurring character in a string\n      \n      Args:\n        input: string\n      \n      Returns:\n        string\n      \"\"\"\n      \n    # Create array to keep the count of  \n    # individual characters and  \n    # initialize the array as 0 \n    count = [0] * 256 \n  \n    # Construct character count array  \n    # from the input string. \n    for i in input: \n        count[ord(i)]+= 1\n    max = -1\n    c = '' \n  \n    # Traverse through the string and  \n    # maintain the count of each  \n    # character \n    for i in input: \n        if max < count[ord(i)]: \n            max = count[ord(i)] \n            c = i \n  \n    return c"
      ]
    ],
    "MBPP/470": [
      [
        0.9297561645507812,
        "def subset_sum(numbers, target, partial=[]):\n    \"\"\"\n    Return True if any combination of numbers in the list\n    add up to the target. Otherwise, return False.\n    \"\"\"\n    s = sum(partial)\n\n    if s == target: \n        return True\n    if s > target:\n        return False\n\n    for i, n in enumerate(numbers):\n        remaining = numbers[i+1:]\n        if subset_sum(remaining, target, partial + [n]):\n            return True\n    return False"
      ],
      [
        0.928465723991394,
        "def subset_sum(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: bool\n    \"\"\"\n    dp = [False] * (target + 1)\n    dp[0] = True\n    for num in nums:\n        for i in range(target, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n    return dp[target]"
      ],
      [
        0.9278894662857056,
        "def isSubsetSum(set, n, sum): \n    \"\"\"\n    Returns True if there is a subset of set with sum equal to given sum, else False\n    \"\"\"\n    \n    \"\"\"\n    The value of subset[i][j] will be True, if there is a subset of set[0..j-1] with sum equal to i\n    \"\"\"\n    \n    \"\"\"\n    subset = [[False for i in range(sum + 1)] for i in range(n + 1)] \n  \n    for i in range(n + 1): \n        subset[i][0] = True\n  \n    for i in range(1, sum + 1): \n         subset[0][i] = False\n             \n    for i in range(1,n + 1): \n        for j in range(1,sum + 1): \n            if j<set[i-1]: \n                subset[i][j] = subset[i-1][j] \n            if j>= set[i-1]: \n                subset[i][j] = subset[i-1][j] or subset[i - 1][j-set[i-1]] \n  \n    return subset[n][sum]"
      ],
      [
        0.924390435218811,
        "def is_subset_sum(arr, n): \n    \"\"\"\n    Returns True if there is a subset of arr[] with sum equal to n. \n    \"\"\"\n    # Base Cases\n    if n == 0:\n        return True\n    if len(arr) == 0 and n != 0:\n        return False\n  \n    # If last element is greater than n, then \n    # ignore it\n    if arr[-1] > n:\n        return is_subset_sum(arr[:-1], n)\n\n    # If last element is equal to n, \n    # return true\n    if arr[-1] == n:\n        return True\n        \n    # Else, check if sum can be obtained  \n    # by any of the following\n    # (a) including the last element  \n    # (b) excluding the last element    \n    return is_subset_sum(arr[:-1], n) or is_subset_sum(arr[:-1], n-arr[-1])"
      ],
      [
        0.9221571087837219,
        "def subset_sum(arr, target):\n    \"\"\"\n    Returns True if there is a subset of arr[] with sum equal to target.\n    :param arr: array of integers\n    :param target: target sum\n    :return: True if there is a subset of arr[] with sum equal to target\n    \"\"\"\n    # Check for the base cases \n    n = len(arr) \n    if n == 0: \n        return False\n              \n    # Create an array to store the current subset sum \n    s = [False] * (target + 1) \n    s[0] = True\n              \"\"\"\n    # Check for the base cases \n    n = len(arr) \n    if n == 0: \n        return False\n              \n    # Create an array to store the current subset sum \n    s = [False] * (target + 1) \n    s[0] = True\n              \n    # Loop over the given array and subtract its elements one by one from 'target' \n    # to get all the possible subset sums \n    for i in range(n): \n        t = arr[i] \n        while t <= target: \n            if s[target - t]: \n                s[t + target] = True\n            t += 1\n              \n    # Return true if target 0 can be reached with subset sum of given set \n    return s[target]"
      ]
    ],
    "MBPP/471": [],
    "MBPP/472": [],
    "MBPP/473": [],
    "MBPP/474": [],
    "MBPP/475": [],
    "MBPP/476": [
      [
        0.9109807014465332,
        "def sort_list(tuples):\n    \"\"\"\n    A function to sort a list of tuples by the second item in each tuple.\n    \"\"\"\n    return sorted(tuples, key=lambda x: x[1])"
      ]
    ],
    "MBPP/477": [
      [
        0.8963558077812195,
        "def findPerimeter(sides):\n  \"\"\"\n  Find the perimeter of a pentagon.\n  \n  @param sides: a list of 5 positive integers.\n  @return: the perimeter of the pentagon.\n  \"\"\"\n  if len(sides) != 5:\n    return \"Not a Pentagon\"\n  else:\n    return sum(sides)"
      ],
      [
        0.8900817632675171,
        "def area_hexagon(side_length):\n  \"\"\"\n  Return the area of a hexagon with the given side length.\n  \n  >>> area_hexagon(10)\n  43.30127018922193\n  \"\"\"\n  return 3 * (3 ** 0.5) * side_length ** 2 / 2"
      ],
      [
        0.8887258768081665,
        "def calculateArea(side): \n    \"\"\"\n    This function calculates the area of a regular hexagon.\n    \n    :param side: The length of one side of the hexagon.\n    :return: The area of the hexagon.\n    \"\"\"\n    area = (3 * math.sqrt(3) * (side * side)) / 2\n    return area"
      ]
    ],
    "MBPP/478": [
      [
        0.9188082218170166,
        "def most_frequent_value(array):\n    \"\"\"\n    Return the most frequent value in the given array.\n    \"\"\"\n    counter_dict = {}\n    for val in array:\n        if val in counter_dict:\n            counter_dict[val] += 1\n        else:\n            counter_dict[val] = 1\n    max_count = 0\n    frequent_val = 0\n    for key, val in counter_dict.items():\n        if val > max_count:\n            max_count = val\n            frequent_val = key\n    return frequent_val\n    def most_frequent\"\"\"\n    counter_dict = {}\n    for val in array:\n        if val in counter_dict:\n            counter_dict[val] += 1\n        else:\n            counter_dict[val] = 1\n    max_count = 0\n    frequent_val = 0\n    for key, val in counter_dict.items():\n        if val > max_count:\n            max_count = val\n            frequent_val = key\n    return frequent_val"
      ],
      [
        0.9181931018829346,
        "def highest_value_frequency(arr):\n    \"\"\"\n    Given an array of integers, find the highest value and its frequency.\n    \n    Parameters:\n    arr (list): List of integers\n    \n    Returns:\n    list: List containing the highest value and its frequency\n    \"\"\"\n    max_val = max(arr)\n    freq = arr.count(max_val)\n    return [max_val, freq]"
      ]
    ],
    "MBPP/479": [
      [
        0.8733251094818115,
        "def find_symmetric_pairs(matrix):\n    \"\"\"\n    Find a symmetric pair in a matrix.\n    \n    Args:\n        matrix (list): A matrix represented as a list of lists.\n    \n    Returns:\n        tuple: A tuple containing the indices of the symmetric pair.\n    \"\"\"\n    # Initialize an empty dictionary to store the rows and their reverse counterparts\n    rows = {}\n    \n    for i in range(len(matrix)):\n        # Convert each row to a tuple to make it hashable\n        row = tuple(matrix[i])\n        # Compute the reversed row\n        reversed_row = tuple(reversed(matrix[i]))\n        \n        # Check if the reversed row is in the dictionary\n        if reversed_row in rows:\n            # If the reversed row is in the dictionary, we found a symmetric pair.\n            # The symmetric pair is identified by the current row index and the stored row index.\n            symmetric_pair = (rows[reversed_row], i)\n            return symmetric_pair\n        else:\n            # If the reversed row is not in the dictionary, add the current row to the dictionary.\n            rows[row] = i\n\n    # If no symmetric pair is found, return None\n    return None"
      ]
    ],
    "MBPP/480": [
      [
        0.901929497718811,
        "def sum_geometric_sequence(a, r, n):\n    \"\"\"\n    Calculate the sum of a geometric sequence.\n    \n    Args:\n        a (float): The first term of the sequence.\n        r (float): The common ratio of the sequence.\n        n (int): The number of terms in the sequence.\n    \n    Returns:\n        float: The sum of the geometric sequence.\n    \"\"\"\n    total_sum = 0\n    for i in range(n):\n        total_sum += a * (r ** i)\n    return total_sum"
      ],
      [
        0.9011238813400269,
        "def geometric_progression(a, r=3, n=5):\n    \"\"\"\n    Calculate the sum of a geometric progression and print the terms.\n    \n    Parameters:\n    a (float): The first term of the progression.\n    r (float): The common ratio of the progression.\n    n (int): The number of terms in the progression.\n    \"\"\"\n    # calculate the sum of the geometric progression\n    sum = a * (1 - r**n) / (1 - r)\n    \n    # check if the sum falls within the specified range\n    if 300 <= sum <= 1200:\n        # print the sum and terms of the geometric progression\n        print(f'The sum of the geometric progression is: {sum}.')\n        print('Terms of the geometric progression:')\n        for i in range(n):\n            term = a * r**i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of the geometric progression is not within the valid range, but {sum}.')"
      ],
      [
        0.898700475692749,
        "def geometric_progression(a, r=3, n=5):\n    \"\"\"\n    Calculate the sum of a geometric progression and print the terms.\n    \n    Parameters:\n    a (float): first term of the progression\n    r (float): common ratio\n    n (int): number of terms\n    \"\"\"\n    # calculate the sum of geometric progression\n    sum = a * (1 - r**n) / (1 - r)\n    \n    # check if sum is within specified range\n    if 300 <= sum <= 1200:\n        # print the sum and terms of geometric progression\n        print(f'Sum of geometric progression: {sum}.')\n        print('Terms of geometric progression:')\n        for i in range(n):\n            term = a * r**i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of geometric progression is not within valid range, but {sum}.')"
      ]
    ],
    "MBPP/481": [
      [
        0.9222733378410339,
        "def binary_search(arr, x):\n    '''\n    Searching value in array using Binary Search\n    Args:\n        arr: Sorted array of integers\n        x: Integer to be searched\n    Returns:\n        True if integer is in array, else False\n    Complexity:\n        Time: O(log n)\n        Space: O(1)\n    '''\n    low = 0\n    high = len(arr) - 1\n    mid = 0\n\n    while low <= high:\n\n        mid = (high + low) // 2\n\n        if arr[mid] < x:\n            low = mid + 1\n\n        elif arr[mid] > x:\n            high = mid - 1\n\n        else:\n            return True\n\n    return False"
      ],
      [
        0.9222624897956848,
        "def binary_search(arr, x):\n    '''\n    Searching value in array using Binary Search\n    Args:\n        arr: Sorted array of integers\n        x: Integer to be searched\n    Returns:\n        True if integer is in array, else False\n    Complexity:\n        Time: O(log n)\n        Space: O(1)\n    '''\n    low = 0\n    high = len(arr) - 1\n    mid = 0\n\n    while low <= high:\n\n        mid = (high + low) // 2\n\n        if arr[mid] < x:\n            low = mid + 1\n\n        elif arr[mid] > x:\n            high = mid - 1\n\n        else:\n            return True\n\n    return False"
      ],
      [
        0.9213452339172363,
        "def binary_search(array, element):\n    \"\"\"\n    Return the index of element in array if present, else -1\n    \"\"\"\n    low = 0\n    high = len(array) - 1\n    while low <= high:\n        middle = (low + high) // 2\n        if array[middle] < element:\n            low = middle + 1\n        elif array[middle] > element:\n            high = middle - 1\n        else:\n            return middle\n    return -1  # if the element is not in the array"
      ],
      [
        0.9213368892669678,
        "def binary_search(array, element):\n    \"\"\"\n    Return the index of element in array if present, else -1\n    \"\"\"\n    low = 0\n    high = len(array) - 1\n    while low <= high:\n        middle = (low + high) // 2\n        if array[middle] < element:\n            low = middle + 1\n        elif array[middle] > element:\n            high = middle - 1\n        else:\n            return middle\n    return -1  # if the element is not in the array"
      ],
      [
        0.9210646152496338,
        "def binary_search(arr, low, high, x):\n    \"\"\"\n    Binary search algorithm\n    \"\"\"\n    if high >= low:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            return True\n        elif arr[mid] > x:\n            return binary_search(arr, low, mid - 1, x)\n        else:\n            return binary_search(arr, mid + 1, high, x)\n    else:\n        return False\n    \n    def linear_search(arr, x):\n    \"\"\"\n    Linear search algorithm\n    \"\"\"\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            return True\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False"
      ],
      [
        0.9207313060760498,
        "def binary_search(arr, low, high, x):\n  \"\"\"\n    Binary Search\"\"\"\n  \n    # Check base case\n    if high >= low:\n \n        mid = (high + low) // 2\n \n        if arr[mid] == x:\n            return mid\n \n        elif arr[mid] > x:\n            return binary_search(arr, low, mid - 1, x)\n \n        else:\n            return binary_search(arr, mid + 1, high, x)\n \n    else:\n        return -1"
      ],
      [
        0.9203308820724487,
        "def binary_search(arr, low, high, x):\n  \"\"\"\n    Binary Search\"\"\"\n  \n    if high >= low:\n        mid = (high + low) // 2\n  \n        if arr[mid] == x:\n            return mid\n  \n        elif arr[mid] > x:\n            return binary_search(arr, low, mid - 1, x)\n  \n        else:\n            return binary_search(arr, mid + 1, high, x)\n    else:\n        return -1"
      ],
      [
        0.9202941656112671,
        "def binary_search(arr, low, high, x):\n  \"\"\"\n    Binary Search\"\"\"\n  \n    if high >= low:\n        mid = (high + low) // 2\n  \n        if arr[mid] == x:\n            return mid\n  \n        elif arr[mid] > x:\n            return binary_search(arr, low, mid - 1, x)\n  \n        else:\n            return binary_search(arr, mid + 1, high, x)\n    else:\n        return -1"
      ],
      [
        0.9195572137832642,
        "def binarysearch(arr, x): \n    \"\"\"\n    Binary Search\n    :param arr: list\n    :param x: int\n    :return: int\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n    mid = 0\n  \n    while low <= high: \n        mid = (high + low) // 2\n  \n        if arr[mid] < x: \n            low = mid + 1\n        elif arr[mid] > x: \n            high = mid - 1\n        else: \n            return mid \n  \n    return -1"
      ]
    ],
    "MBPP/482": [
      [
        0.8593558073043823,
        "def generate_grid():\n    \"\"\"\n    Generate a 7x7 grid of integers\n    \"\"\"\n    table = [[0]*7 for _ in range(7)]\n    for i in range(1,8):\n        for j in range(1,8):\n            table[7-i][7-j] = i*j\n    return table\n    def generate_grid():\n    \"\"\"\n    Generate a 7x7 grid of integers\n    \"\"\"\n    table = [[0]*7 for _ in range(7)]\n    for i in range(1,8):\n        for j in range(1,8):\n            table[7-i][7-j] = i*j\n    return table"
      ],
      [
        0.859023928642273,
        "def xy_coordinates(x, y):\n    \"\"\"\n    This function takes in two lists of numbers and returns two new lists of numbers.\n    The first list is the x coordinates of the points and the second list is the y coordinates of the points.\n    The function takes in two lists of numbers and returns two new lists of numbers.\n    The first list is the x coordinates of the points and the second list is the y coordinates of the points.\n    The function takes in two lists of numbers and returns two new lists of numbers.\n    The first list is the x coordinates of the points and the second list is the y coordinates of the points.\n    \"\"\"\n    x_coordinates = []\n    y_coordinates = []\n    \n    for i in x:\n        x_coordinates.append(i * 2)\n    for i in y:\n        y_coordinates.append(i * 2)\n    \n    # Support for fractions\n    for i in x:\n        x_coordinates.append(i + 1/2)\n    for i in y:\n        y_coordinates.append(i + 1/2)\n    \n    return x_coordinates, y_coordinates"
      ]
    ],
    "MBPP/483": [],
    "MBPP/484": [
      [
        0.9151778221130371,
        "def removeLetters(string, letter):\n    \"\"\"\n    Remove all instances of letter from string.\n    \"\"\"\n    new_string = \"\"\n    for char in string:\n        if char.lower() != letter.lower():\n            new_string += char\n    return new_string\n    def removeLetters(string, letter):\n    \"\"\"\n    Remove all instances of letter from string.\n    \"\"\"\n    new_string = \"\"\n    for char in string:\n        if char.lower() != letter.lower():\n            new_string += char\n    return new_string"
      ]
    ],
    "MBPP/485": [
      [
        0.9060376286506653,
        "def find_nsmallest_absVals(nums, n):  \n    \"\"\"\n    Find the n smallest absolute values in a list of numbers.\n    \n    Args:\n        nums: a list of numbers\n        n: an integer\n    \n    Returns:\n        a list of n smallest absolute values\n    \"\"\"\n    nums_abs = []\n    \n    for num in nums:\n        heapq.heappush(nums_abs, abs(num))\n\n    result = []\n    for _ in range(n):\n        result.append(heapq.heappop(nums_abs))\n\n    return sorted(result)"
      ],
      [
        0.9021096229553223,
        "def smallest_nums(array):\n    \"\"\"Return 5 smallest numbers, in sorted order.\n\n    >>> smallest_nums([7, 8, 3, 1, 2, 9, 4])\n    [1, 2, 3, 4, 7]\n    \"\"\"\n    unique_nums = list(set(array))\n    unique_nums.sort()\n    return unique_nums[:5]"
      ],
      [
        0.9004090428352356,
        "def kth_smallest(lst, n, k):\n    \"\"\"\n    Find kth smallest number in a list\n    \n    Args:\n        lst: list of numbers\n        n: number of elements in list\n        k: kth smallest number\n    \n    Returns:\n        kth smallest number\n    \"\"\"\n    \n    # Using heap queue algorithm to sort list\n    sorted_list = heapq.nsmallest(n, lst)\n    \n    # Return kth smallest number\n    return sorted_list[k-1]"
      ],
      [
        0.8991832733154297,
        "def smallest_nums(array):\n    \"\"\"Return the 5 smallest numbers in a given array.\n    \"\"\"\n    \n    # Your code here\n    \n    # Returns the first 5 smallest unique numbers in a given array.\n    \n    # Your code here\n    \n    # Returns the first 5 smallest unique numbers in a given array.\n    \n    # Your code here\n    \n    # Returns the first 5 smallest unique numbers in a given array.\n    \n    # Your code here\n    \n    # Returns the first 5 smallest unique numbers in a given array.\n    \n    # Your code here\n    \"\"\"\n    unique_nums = list(set(array))  # Removes duplicates from the array.\n    unique_nums.sort()  # Sorts the array from smallest to biggest.\n    return unique_nums[:5]  # Returns the first 5 smallest unique numbers."
      ],
      [
        0.8947778940200806,
        "def minHeap(arr, n):\n    \"\"\"\n    Build a min heap from an array.\n    \"\"\"\n    for i in range(n // 2 - 1, -1, -1):\n        minHeapify(arr, n, i)\n    return arr\n    \n    def minHeapify(arr, n, i):\n    \"\"\"\n    Min heapify a subtree rooted at index i.\n    \"\"\"\n    left = 2 * i + 1\n    right = 2 * i + 2\n    smallest = i\n    if left < n and arr[left] < arr[smallest]:\n        \"\"\"\n    if not isMinHeap(arr, n):\n        buildMinHeap(arr, n)\n    return arr, arr[0]"
      ]
    ],
    "MBPP/486": [
      [
        0.9243783950805664,
        "def cone_surface_area(radius, slant_height):\n    \"\"\"\n    Calculate the surface area of a cone.\n    \n    Parameters:\n    - radius (float): The radius of the base of the cone.\n    - slant_height (float): The slant height of the cone.\n    \n    Returns:\n    - float: The surface area of the cone.\n    \"\"\"\n    base_area = math.pi * radius**2\n    lateral_area = math.pi * radius * slant_height\n    total_area = base_area + lateral_area\n    return total_area"
      ],
      [
        0.9216525554656982,
        "def cone_surface_area(r: float, h: float) -> float:\n    \"\"\"\n    Calculate the surface area of a cone.\n    \n    Parameters\n    ----------\n    r : float\n        The radius of the cone.\n    h : float\n        The height of the cone.\n    \n    Returns\n    -------\n    float\n        The surface area of the cone.\n    \n    Notes\n    -----\n    The surface area of a cone is given by the formula:\n    \n    .. math::\n        \\\\text{Surface Area} = \\\\pi r l\n    \n    where :math:`l` is the slant height of the cone.\n    \n    \"\"\"\n    if r <= 0 or h <= 0:\n        return \"Radius and Height must be greater than zero.\"\n    l = math.sqrt(r**2 + h**2)    # l is slant height\n    return math.pi * r * l"
      ],
      [
        0.9216408729553223,
        "def cone_surface_area(r: float, h: float) -> float:\n    \"\"\"\n    Calculate the surface area of a cone.\n    \n    Parameters\n    ----------\n    r : float\n        The radius of the cone.\n    h : float\n        The height of the cone.\n    \n    Returns\n    -------\n    float\n        The surface area of the cone.\n    \n    Notes\n    -----\n    The surface area of a cone is given by the formula:\n    \n    .. math::\n        \\\\text{Surface Area} = \\\\pi r l\n    \n    where :math:`l` is the slant height of the cone.\n    \n    \"\"\"\n    if r <= 0 or h <= 0:\n        return \"Radius and Height must be greater than zero.\"\n    l = math.sqrt(r**2 + h**2)    # l is slant height\n    return math.pi * r * l"
      ],
      [
        0.907596230506897,
        "def cone_surface_area_and_volume(radius, height):\n    \"\"\"\n    This function calculates the surface area and volume of a cone.\n    \n    Parameters:\n    radius (float): The radius of the cone.\n    height (float): The height of the cone.\n    \n    Returns:\n    tuple: A tuple containing the surface area and volume of the cone.\n    \"\"\"\n    surface_area = 3.14 * radius * (radius + ((height**2 + radius**2)**0.5))\n    volume = 3.14 * (radius**2) * (height/3)\n    return surface_area, volume"
      ]
    ],
    "MBPP/487": [
      [
        0.9132947325706482,
        "def gcd(a, b):\n    \"\"\"\n    Function to calculate GCD of two numbers\n    \"\"\"\n    # Base case\n    if b == 0:\n        return a\n    else:\n        # Recursive call\n        return gcd(b, a % b)"
      ]
    ],
    "MBPP/488": [
      [
        0.912738561630249,
        "def circumference_of_circle(diameter):\n    \"\"\"\n    This function calculates the circumference of a circle\n    :param diameter: diameter of the circle\n    :return: circumference of the circle\n    \"\"\"\n    circumference = 3.14 * diameter\n    return circumference"
      ],
      [
        0.9115329384803772,
        "def find_circle_area(diameter):\n    \"\"\"\n    Find the area of a circle.\n    \n    Args:\n        diameter: The diameter of the circle.\n    \n    Returns:\n        The area of the circle.\n    \"\"\"\n    radius = diameter / 2\n    area = math.pi * (radius ** 2)\n    return area"
      ],
      [
        0.9079892635345459,
        "def calculate_area(diameter):\n    \"\"\"\n    Calculate the area of a circle given its diameter.\n    \n    Args:\n        diameter: Diameter of the circle.\n    \n    Returns:\n        float: Area of the circle.\n    \"\"\"\n    if diameter <= 0:\n        return 0\n    \n    radius = diameter / 2\n    circumference = 2 * 3.14159 * radius\n    area = circumference * radius / 2\n    return area"
      ]
    ],
    "MBPP/489": [],
    "MBPP/490": [],
    "MBPP/491": [
      [
        0.9170641899108887,
        "def getRemainder(num1, num2):\n    \"\"\"\n    Return the remainder of num1 divided by num2.\n    \n    >>> getRemainder(10, 3)\n    1\n    >>> getRemainder(10, 2)\n    0\n    \"\"\"\n    return num1 % num2"
      ],
      [
        0.9141275882720947,
        "def get_remainder(n1, n2):\n    \"\"\"\n    Return the remainder of n1 divided by n2.\n    \n    >>> get_remainder(10, 3)\n    1\n    >>> get_remainder(10, 2)\n    0\n    \"\"\"\n    return n1 % n2"
      ],
      [
        0.9088664650917053,
        "def find_remainder(dividend, divisor):\n  \"\"\"\n    Find the remainder of a division\n    \n    Args:\n      dividend: dividend of division\n      divisor: divisor of division\n    Returns:\n      remainder: remainder of division\n    \"\"\"\n  return dividend % divisor"
      ],
      [
        0.9073973298072815,
        "def find_remainder(dividend, divisor):\n    \"\"\"\n    Find the remainder of a division\n    \"\"\"\n    # The quotient is the integer part of the division\n    quotient = dividend // divisor\n    # The remainder is what remains after subtracting divisor*quotient from the dividend\n    remainder = dividend - quotient * divisor\n    return remainder\n    def find_remainder(dividend, divisor):\n    \"\"\"\n    Find the remainder of a division\n    \"\"\"\n    # The quotient is the integer part of the division\n    quotient = dividend // divisor\n    # The remainder is what remains after subtracting divisor*quotient from the dividend\n    remainder = dividend - quotient * divisor\n    return remainder"
      ],
      [
        0.9064007997512817,
        "def calculate_remainder(a, b):\n    \"\"\"\n    Calculate the remainder of two integers.\n    \"\"\"\n    # Convert negative integers to positive\n    a = abs(a)\n    b = abs(b)\n\n    # Check if either input is zero\n    if a == 0 or b == 0:\n        return \"Error: Zero is not allowed as an input\"\n\n    # Find the greater and smaller integers\n    greater = max(a, b)\n    smaller = min(a, b)\n\n    # Calculate and return the remainder\n    remainder = greater % smaller\n    return remainder\n    def calculate_remainder(a\"\"\"\n    # Convert negative integers to positive\n    a = abs(a)\n    b = abs(b)\n\n    # Check if either input is zero\n    if a == 0 or b == 0:\n        return \"Error: Zero is not allowed as an input\"\n\n    # Find the greater and smaller integers\n    greater = max(a, b)\n    smaller = min(a, b)\n\n    # Calculate and return the remainder\n    remainder = greater % smaller\n    return remainder"
      ]
    ],
    "MBPP/492": [
      [
        0.9011297225952148,
        "def sum_pairs(input_list):\n    \"\"\"\n    \"\"\"\n    output_list = []\n    for i in range(len(input_list)-1):\n        sum = input_list[i] + input_list[i+1]\n        output_list.append(sum)\n    return output_list"
      ]
    ],
    "MBPP/493": [
      [
        0.9398937225341797,
        "def sum_of_cubes(n):\n    \"\"\"\n    Return the sum of the cubes of all numbers from 1 to n.\n    \"\"\"\n    result = 0\n    for i in range(1, n+1):\n        result += i ** 3\n    return result\n    def sum_of_cubes(n):\n    \"\"\"\n    Return the sum of the cubes of all numbers from 1 to n.\n    \"\"\"\n    result = 0\n    for i in range(1, n+1):\n        result += i ** 3\n    return result"
      ],
      [
        0.9336333274841309,
        "def sum_of_cubes(n):\n    \"\"\"\n    Return the sum of the first n cubes.\n    \n    >>> sum_of_cubes(5)\n    225\n    \"\"\"\n    sum = 0\n    for i in range(n+1):\n        sum += i**3 \n    return sum"
      ],
      [
        0.9302384257316589,
        "def sum_of_cubes(n):\n    \"\"\"\n    Return the sum of the first n cubes.\n    \n    >>> sum_of_cubes(5)\n    225\n    \"\"\"\n    sum = 0\n    for i in range(1, n + 1):\n        sum += i ** 3\n    return sum"
      ],
      [
        0.9292051792144775,
        "def calculate_sum_of_cubes(n):\n    \"\"\"\n    Calculate the sum of cubes of the first n natural numbers.\n    \n    Args:\n        n (int): The number of natural numbers to consider.\n    \n    Returns:\n        int: The sum of cubes of the first n natural numbers.\n    \"\"\"\n    sum = 0\n    for i in range(1, n + 1):\n        sum += i**3\n    return sum"
      ],
      [
        0.9291501045227051,
        "def accumulative_sum(n):\n    \"\"\"\n    Return the sum of the first n numbers\n    \"\"\"\n    sum = 0\n    for i in range(1, n+1):\n        sum += i\n    return sum\n    \n    def cube_sum(n):\n    \"\"\"\n    Return the sum of the first n numbers\n    \"\"\"\n    sum = 0\n    for i in range(1, n+1):\n        sum += i ** 3\n    return sum"
      ],
      [
        0.9287363290786743,
        "def sumOfCubes(n):\n    \"\"\"\n    Return the sum of the cubes of all numbers from 1 to n, inclusive.\n    \n    >>> sumOfCubes(5)\n    225\n    \"\"\"\n    sum = 0\n    \n    for num in range(1, n+1):\n        sum += num ** 3\n    \n    return sum"
      ],
      [
        0.9256159663200378,
        "def sum_cubes(n):\n    \"\"\"\n    Calculate the sum of cubes of all numbers from 1 to n.\n    \n    Args:\n        n (int): The upper limit of the range.\n    \n    Returns:\n        int: The sum of cubes of all numbers from 1 to n.\n    \"\"\"\n    # Initialize the result\n    result = 0\n\n    # Iterate over all numbers from 1 to n\n    for i in range(1, n+1):\n        # Add the cube of each number to the result\n        result += i ** 3\n\n    return result"
      ]
    ],
    "MBPP/494": [
      [
        0.9384191036224365,
        "def moveZerosToEnd(arr): \n    \"\"\"\n    Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.\n    \n    Example:\n    \n    Input: [0,1,0,3,12]\n    Output: [1,3,12,0,0]\n    Note:\n    \n    You must do this in-place without making a copy of the array.\n    Minimize the total number of operations.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \"\"\"\n    last_nonzero = 0\n    for i in range(len(arr)): \n        if arr[i] != 0:\n            arr[last_nonzero] = arr[i]\n            last_nonzero += 1\n\n    while last_nonzero < len(arr):\n        arr[last_nonzero] = 0\n        last_nonzero += 1\n\n    return arr"
      ],
      [
        0.9377168416976929,
        "def move_zeros(nums):\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    # List comprehension - It will first put all non-zero numbers, then append zeros to the end\n    return [num for num in nums if num != 0] + [0] * nums.count(0)"
      ],
      [
        0.937469482421875,
        "def move_zeros(nums):\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    # List comprehesion - It will first put all non-zero numbers, then append zeros to the end\n    return [num for num in nums if num != 0] + [0] * nums.count(0)"
      ],
      [
        0.9347382187843323,
        "def move_zeroes(nums):\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    for i in nums:\n        if i == 0:\n            nums.remove(i)\n            nums.append(i)\n    return nums"
      ],
      [
        0.9344936013221741,
        "def move_zeros(nums):\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    num_zeros = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[num_zeros], nums[i] = nums[i], nums[num_zeros]\n            num_zeros += 1\n    return nums"
      ],
      [
        0.9343514442443848,
        "def move_zeroes_to_end(array):\n    \"\"\"\n    This function takes a list of numbers as input, \n    moves all the zeroes to the end \n    and returns the updated list.\n    \"\"\"\n    # count the number of zeros\n    num_zeros = array.count(0)\n    \n    # remove all zeros from the list\n    array = [num for num in array if num != 0]\n    \n    # extend the list by the number of zeros\n    array.extend([0]*num_zeros)\n    \n    return array"
      ],
      [
        0.9318588972091675,
        "def move_zeroes(arr):\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    j = 0\n    for i in range(len(arr)):\n        if arr[i] != 0:\n            arr[j] = arr[i]\n            j += 1\n    for i in range(j, len(arr)):\n        arr[i] = 0"
      ]
    ],
    "MBPP/495": [
      [
        0.9077180624008179,
        "def comb(n, r):\n    \"\"\"\n    Returns the number of combinations of n items taken r at a time.\n    \"\"\"\n    return factorial(n) / (factorial(r) * factorial(n - r))\n    \n    def perm(n, r):\n    \"\"\"\n    Returns the number of permutations of n items taken r at a time.\n    \"\"\"\n    return factorial(n) / factorial(n - r)\n    \n    def factorial(n):\n    \"\"\"\n    Returns the factorial of n.\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        \"\"\"\n    perm_val = perm(n, r)\n    rFactorial = factorial(r)\n    answer = perm_val / rFactorial\n    return answer"
      ]
    ],
    "MBPP/496": [],
    "MBPP/497": [],
    "MBPP/498": [
      [
        0.9200259447097778,
        "def average_odd_numbers(start, end):\n    \"\"\"Calculate the average of odd numbers between start and end.\"\"\"\n    count = 0\n    total = 0\n    for i in range(start, end + 1):\n        if i % 2 == 1:\n            count += 1\n            total += i\n    if count > 0:\n        return total / count\n    else:\n        return None"
      ]
    ],
    "MBPP/499": [
      [
        0.9258499145507812,
        "def numSubarrayProductLessThanK(nums: List[int], k: int) -> int:\n    \"\"\"\n    \"\"\"\n    if k <= 1:\n        return 0\n    l = 0\n    count = 0\n    product = 1\n    for r in range(len(nums)):\n        product *= nums[r]\n        while product >= k:\n            product /= nums[l]\n            l += 1\n        count += r - l + 1\n    return count"
      ],
      [
        0.9235526323318481,
        "def numSubarrayProductLessThanK(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if k <= 1:\n        return 0\n    prod = 1\n    count = 0\n    left = 0\n    for right in range(len(nums)):\n        prod *= nums[right]\n        while prod >= k:\n            prod /= nums[left]\n            left += 1\n        count += right - left + 1\n    return count"
      ],
      [
        0.9235081672668457,
        "def numSubarrayProductLessThanK(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if k <= 1:\n        return 0\n    prod = 1\n    count = 0\n    left = 0\n    for right in range(len(nums)):\n        prod *= nums[right]\n        while prod >= k:\n            prod /= nums[left]\n            left += 1\n        count += right - left + 1\n    return count"
      ]
    ]
  },
  "block_wise": {
    "HumanEval/0": [
      [
        0.9196977019309998,
        "    for i in range(len(list_of_numbers)):\n        for j in range(i + 1, len(list_of_numbers)):\n            if abs(list_of_numbers[i] - list_of_numbers[j]) < threshold:\n                return True"
      ],
      [
        0.9194197654724121,
        "    for i in range(len(list_of_numbers)):\n        for j in range(i + 1, len(list_of_numbers)):\n            if abs(list_of_numbers[i] - list_of_numbers[j]) < threshold:\n                return True\n    return False"
      ],
      [
        0.9086583256721497,
        "        for j in range(i + 1, len(list_of_numbers)):\n            if abs(list_of_numbers[i] - list_of_numbers[j]) < threshold:\n                return True"
      ],
      [
        0.9011155366897583,
        "            if abs(list_of_numbers[i] - list_of_numbers[j]) < threshold:\n                return True"
      ],
      [
        0.8931774497032166,
        "    length = len(nums)\n    for i in range(length - 1):\n        for j in range(i + 1, length):\n            if abs(nums[i] - nums[j]) < threshold:\n                return True\n    return False"
      ],
      [
        0.8910671472549438,
        "    for i in range(length - 1):\n        for j in range(i + 1, length):\n            if abs(nums[i] - nums[j]) < threshold:\n                return True"
      ],
      [
        0.8813287019729614,
        "    for i in range(len(arr) - 1):\n        if abs(arr[i] - arr[i + 1]) > threshold:\n            return True"
      ],
      [
        0.8810958862304688,
        "    for i in range(len(arr) - 1):\n        if abs(arr[i] - arr[i + 1]) > threshold:\n            return True\n    return False"
      ],
      [
        0.8808964490890503,
        "        for j in range(i + 1, length):\n            if abs(nums[i] - nums[j]) < threshold:\n                return True"
      ],
      [
        0.8786838054656982,
        "    return math.fabs(a - b) < threshold"
      ]
    ],
    "HumanEval/1": [
      [
        0.9264861941337585,
        "    paren_string = paren_string.replace(' ', '')\n    parentheses_groups = []\n    stack = []\n    start = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            if not stack:\n                start = i\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n            if not stack:\n                parentheses_groups.append(paren_string[start:i + 1])\n    return parentheses_groups"
      ],
      [
        0.9259897470474243,
        "    stack = []\n    group = []\n    result = []\n    for char in paren_string:\n        if char == ' ':\n            continue\n        if char == '(':\n            stack.append(char)\n            group.append(char)\n        if char == ')':\n            stack.pop()\n            group.append(char)\n            if not stack:\n                result.append(''.join(group))\n                group = []\n    return result"
      ],
      [
        0.9240838289260864,
        "    paren_string = paren_string.replace(' ', '')\n    groups = []\n    start = 0\n    bal = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            bal += 1\n        else:\n            bal -= 1\n        if bal == 0:\n            groups.append(paren_string[start:i + 1])\n            start = i + 1\n    return groups"
      ],
      [
        0.9173109531402588,
        "    stack = []\n    groups = []\n    group = ''\n    for ch in paren_string.replace(' ', ''):\n        if ch in ['(', '{', '[']:\n            if stack:\n                group += ch\n            stack.append(ch)\n        elif ch in [')', '}', ']']:\n            group += ch\n            stack.pop()\n            if not stack:\n                groups.append(group)\n                group = ''\n    return groups"
      ],
      [
        0.9165716171264648,
        "    paren_string = paren_string.replace(' ', '')\n    stack_p = []\n    stack_s = []\n    result = []\n    inner_result = []\n    begin_index = 0\n    for idx, char in enumerate(paren_string):\n        if char == '(':\n            stack_p.append(idx)\n        elif char == '[':\n            stack_s.append(idx)\n        elif char == ')':\n            start = stack_p.pop()\n            if len(stack_p) == 0:\n                result.append(paren_string[start:idx + 1])\n                if inner_paren:\n                    inner_result += separate_paren_groups(paren_string[start + 1:idx], inner_paren)\n        elif char == ']':\n            start = stack_s.pop()\n            if len(stack_s) == 0:\n                result.append(paren_string[start:idx + 1])\n                if inner_paren:\n                    inner_result += separate_paren_groups(paren_string[start + 1:idx], inner_paren)\n    return result + inner_result"
      ],
      [
        0.9153119325637817,
        "    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            bal += 1\n        else:\n            bal -= 1\n        if bal == 0:\n            groups.append(paren_string[start:i + 1])\n            start = i + 1"
      ],
      [
        0.9149876832962036,
        "    for char in paren_string:\n        if char == ' ':\n            continue\n        if char == '(':\n            stack.append(char)\n            group.append(char)\n        if char == ')':\n            stack.pop()\n            group.append(char)\n            if not stack:\n                result.append(''.join(group))\n                group = []"
      ],
      [
        0.9136440753936768,
        "    replacements = {'(': ' ( ', ')': ' ) ', '[': ' [ ', ']': ' ] ', '{': ' { ', '}': ' } '}\n    for old, new in replacements.items():\n        paren_string = paren_string.replace(old, new)\n    words = paren_string.split()\n    stack = []\n    groups = []\n    for word in words:\n        if word in '([{':\n            stack.append([word])\n        else:\n            opener = {'(': ')', '[': ']', '{': '}'}[stack[-1][-1]]\n            if word != opener:\n                stack.append([])\n            stack[-1].append(word)\n            if len(stack[-1]) % 2 == 0:\n                groups.append(''.join(stack.pop()))\n    return groups"
      ],
      [
        0.9135307669639587,
        "    paren_string = paren_string.replace(' ', '')\n    start = ['(', '{', '[']\n    end = [')', '}', ']']\n    groups = []\n    temp_string = ''\n    counter = 0\n    for char in paren_string:\n        if char in start:\n            counter += 1\n            temp_string += char\n        elif char in end:\n            counter -= 1\n            temp_string += char\n            if counter == 0:\n                groups.append(temp_string)\n                temp_string = ''\n    return groups"
      ],
      [
        0.9131929874420166,
        "    for i, char in enumerate(paren_string):\n        if char == '(':\n            if not stack:\n                start = i\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n            if not stack:\n                parentheses_groups.append(paren_string[start:i + 1])"
      ]
    ],
    "HumanEval/2": [
      [
        0.9013906121253967,
        "    str_num = str(number)\n    decimal_index = str_num.index('.')\n    rightmost_int = int(str_num[decimal_index - 1])\n    return rightmost_int"
      ],
      [
        0.897246241569519,
        "    decimal_point = Decimal(10) ** (-precision)\n    if isinstance(number, (int, float)):\n        number = Decimal(number)\n    elif isinstance(number, str):\n        number = Decimal(number.replace(',', '.'))\n    return float(number.quantize(decimal_point, rounding=ROUND_DOWN))"
      ],
      [
        0.8963929414749146,
        "    string_num = str(number)\n    point_position = string_num.find('.')\n    if point_position == -1:\n        return None\n    integer_part = string_num[:point_position]\n    return int(integer_part[-1]) if integer_part else None"
      ],
      [
        0.8923089504241943,
        "    str_num = str(number)\n    if '.' in str_num:\n        return len(str_num.split('.')[1])\n    else:\n        return 0"
      ],
      [
        0.8888043165206909,
        "    try:\n        float(number)\n        return math.floor(number)\n    except (TypeError, ValueError):\n        raise ValueError('Input should be integer or float.')"
      ],
      [
        0.8888043165206909,
        "    try:\n        float(number)\n        return math.floor(number)\n    except (TypeError, ValueError):\n        raise ValueError('Input should be integer or float.')"
      ],
      [
        0.8876314163208008,
        "    try:\n        if not isinstance(number, (float, int)):\n            return 'Error: Invalid input.'\n        if abs(number) > 1.7e+308:\n            return 'Error: Number too large.'\n        return int(number // 1) if number >= 0 else int(number // 1) - 1\n    except TypeError:\n        return 'Error: Invalid input.'\n    except OverflowError:\n        return 'Error: Number too large.'"
      ],
      [
        0.8876314163208008,
        "    try:\n        if not isinstance(number, (float, int)):\n            return 'Error: Invalid input.'\n        if abs(number) > 1.7e+308:\n            return 'Error: Number too large.'\n        return int(number // 1) if number >= 0 else int(number // 1) - 1\n    except TypeError:\n        return 'Error: Invalid input.'\n    except OverflowError:\n        return 'Error: Number too large.'"
      ],
      [
        0.8875594139099121,
        "    elif fractional_part == 0.5:\n        return integer_part if integer_part > 0 else integer_part + 1\n    else:\n        return integer_part + 1 if integer_part > 0 else integer_part - 1"
      ],
      [
        0.8874699473381042,
        "    if fractional_part < 0.5:\n        return integer_part\n    elif fractional_part == 0.5:\n        return integer_part if integer_part > 0 else integer_part + 1\n    else:\n        return integer_part + 1 if integer_part > 0 else integer_part - 1"
      ]
    ],
    "HumanEval/3": [],
    "HumanEval/4": [
      [
        0.9397933483123779,
        "    mean = sum(numbers) / len(numbers)\n    differences = [abs(number - mean) for number in numbers]\n    mad = sum(differences) / len(numbers)\n    return mad"
      ],
      [
        0.9350194931030273,
        "    median_value = statistics.median(numbers)\n    absolute_deviations = []\n    for num in numbers:\n        absolute_deviations.append(abs(num - median_value))\n    mad = statistics.median(absolute_deviations)\n    return mad"
      ],
      [
        0.9128458499908447,
        "    n = len(numbers)\n    mean = sum(numbers) / n\n    squared_diff_sum = sum(((x - mean) ** 2 for x in numbers))\n    variance = squared_diff_sum / n\n    standard_deviation = variance ** 0.5\n    return standard_deviation"
      ],
      [
        0.9125761985778809,
        "    n = len(numbers)\n    mean = sum(numbers) / n\n    squared_differences = [(x - mean) ** 2 for x in numbers]\n    sum_squared_differences = sum(squared_differences)\n    variance = sum_squared_differences / n\n    standard_deviation = variance ** 0.5\n    return standard_deviation"
      ],
      [
        0.9118233323097229,
        "    return sum((abs(num - mean) for num in input_numbers)) / len(input_numbers)"
      ],
      [
        0.9067452549934387,
        "    mean = sum(numbers) / len(numbers)\n    sum_of_squared_differences = sum([(number - mean) ** 2 for number in numbers])\n    variance = sum_of_squared_differences / len(numbers)\n    standard_deviation = math.sqrt(variance)\n    return standard_deviation"
      ],
      [
        0.9063742756843567,
        "    n = len(numbers)\n    mean = sum(numbers) / n\n    squared_differences = [(x - mean) ** 2 for x in numbers]\n    variance = sum(squared_differences) / (n - 1)\n    standard_deviation = math.sqrt(variance)\n    return standard_deviation"
      ],
      [
        0.9058593511581421,
        "    mean = sum(numbers) / len(numbers)\n    squared_differences = [(num - mean) ** 2 for num in numbers]\n    variance = sum(squared_differences) / len(numbers)\n    return variance ** 0.5"
      ],
      [
        0.9054774045944214,
        "    median = np.median(numbers)\n    mad = np.median(np.abs(numbers - median))\n    threshold = 3.5 * mad\n    filtered_numbers = [x for x in numbers if abs(x - median) < threshold]\n    return np.mean(filtered_numbers)"
      ],
      [
        0.904514491558075,
        "    average = sum(numbers) / len(numbers)\n    sum_of_square_diffs = sum(((num - average) ** 2 for num in numbers))\n    variance = sum_of_square_diffs / len(numbers)\n    return math.sqrt(variance)"
      ]
    ],
    "HumanEval/5": [
      [
        0.9449357390403748,
        "    if not numbers:\n        return []\n    if delimeter > 0:\n        interspersed_numbers = [numbers[0]]\n        for num in numbers[1:]:\n            interspersed_numbers.extend([delimeter, num])\n    else:\n        abs_delimeter = abs(delimeter)\n        interspersed_numbers = [numbers[0]]\n        for index, num in enumerate(numbers[1:]):\n            if (index + 1) % abs_delimeter != 0:\n                interspersed_numbers.extend([delimeter, num])\n            else:\n                interspersed_numbers.append(num)\n    return interspersed_numbers"
      ],
      [
        0.9372299909591675,
        "    outcome = []\n    flattened_numbers = []\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimeter))\n        else:\n            flattened_numbers.append(num)\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i < len(flattened_numbers) - 1 and isinstance(delimeter, int) and (delimeter >= 0):\n            outcome.append(delimeter)\n    return outcome"
      ]
    ],
    "HumanEval/6": [
      [
        0.9246196746826172,
        "    depths = []\n    paren_groups = paren_string.split(' ')\n    for paren_group in paren_groups:\n        current_depth = 0\n        max_depth = 0\n        for i in range(len(paren_group)):\n            if paren_group[i] == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif paren_group[i] == ')':\n                current_depth -= 1\n        depths.append(max_depth)\n    return depths"
      ],
      [
        0.9205356240272522,
        "    result = []\n    for group in s.split(' '):\n        count, max_count = (0, 0)\n        for ch in group:\n            if ch == '(':\n                count += 1\n                max_count = max(max_count, count)\n            elif ch == ')':\n                count -= 1\n        result.append(max_count)\n    return result"
      ],
      [
        0.920148491859436,
        "    groups = s.split()\n    depths = []\n    for group in groups:\n        if not isValid(group):\n            raise Exception('Invalid group of parentheses in input string: ' + group)\n        depth = 0\n        max_depth = 0\n        for char in group:\n            if char == '(':\n                depth += 1\n                if depth > max_depth:\n                    max_depth = depth\n            elif char == ')':\n                depth -= 1\n        depths.append(max_depth)\n    return depths"
      ],
      [
        0.9145045876502991,
        "    for group in s.split(' '):\n        count, max_count = (0, 0)\n        for ch in group:\n            if ch == '(':\n                count += 1\n                max_count = max(max_count, count)\n            elif ch == ')':\n                count -= 1\n        result.append(max_count)"
      ],
      [
        0.9104483127593994,
        "    for paren_group in paren_groups:\n        current_depth = 0\n        max_depth = 0\n        for i in range(len(paren_group)):\n            if paren_group[i] == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif paren_group[i] == ')':\n                current_depth -= 1\n        depths.append(max_depth)"
      ],
      [
        0.904771089553833,
        "    for group in groups:\n        if not isValid(group):\n            raise Exception('Invalid group of parentheses in input string: ' + group)\n        depth = 0\n        max_depth = 0\n        for char in group:\n            if char == '(':\n                depth += 1\n                if depth > max_depth:\n                    max_depth = depth\n            elif char == ')':\n                depth -= 1\n        depths.append(max_depth)"
      ],
      [
        0.9047365188598633,
        "    paren_string = paren_string.replace(' ', '')\n    parentheses_groups = []\n    stack = []\n    start = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            if not stack:\n                start = i\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n            if not stack:\n                parentheses_groups.append(paren_string[start:i + 1])\n    return parentheses_groups"
      ],
      [
        0.9024267792701721,
        "        for i in range(len(paren_group)):\n            if paren_group[i] == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif paren_group[i] == ')':\n                current_depth -= 1"
      ],
      [
        0.8962388038635254,
        "            if paren_group[i] == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif paren_group[i] == ')':\n                current_depth -= 1"
      ],
      [
        0.8955767750740051,
        "    stack = []\n    group = []\n    result = []\n    for char in paren_string:\n        if char == ' ':\n            continue\n        if char == '(':\n            stack.append(char)\n            group.append(char)\n        if char == ')':\n            stack.pop()\n            group.append(char)\n            if not stack:\n                result.append(''.join(group))\n                group = []\n    return result"
      ]
    ],
    "HumanEval/7": [
      [
        0.9299337863922119,
        "    filtered_list = []\n    for string in string_list:\n        if substring in string:\n            filtered_list.append(string)\n    return filtered_list"
      ],
      [
        0.9299237728118896,
        "    filtered_list = []\n    for string in string_list:\n        if substring in string:\n            filtered_list.append(string)\n    return filtered_list"
      ],
      [
        0.9248831868171692,
        "    output = []\n    for s in strings:\n        if substring in s:\n            output.append(s)\n    return output"
      ],
      [
        0.9241589307785034,
        "    result = []\n    for s in strings:\n        if substring in s:\n            result.append(s)\n    return result"
      ],
      [
        0.9223769903182983,
        "    filtered_list = [s for s in string_list if substring in s]\n    return filtered_list"
      ],
      [
        0.9217667579650879,
        "    filtered_lst = []\n    for string in lst:\n        if substring in string:\n            filtered_lst.append(string)\n    return filtered_lst"
      ],
      [
        0.9214742183685303,
        "    for string in string_list:\n        if substring in string:\n            filtered_list.append(string)"
      ],
      [
        0.9214686155319214,
        "    for string in string_list:\n        if substring in string:\n            filtered_list.append(string)"
      ],
      [
        0.9193984866142273,
        "    result = []\n    for string in strings:\n        if substring in string and string not in result:\n            result.append(string)\n    return result"
      ],
      [
        0.9193828701972961,
        "    matches = []\n    for string in list_of_strings:\n        if substring.lower() in string.lower():\n            matches.append(string)\n    return matches"
      ]
    ],
    "HumanEval/8": [
      [
        0.9315944910049438,
        "    sum_num = sum(numbers)\n    product = 1\n    for num in numbers:\n        product *= num\n    return (sum_num, product)"
      ],
      [
        0.9301788210868835,
        "    total_sum = 0\n    total_product = 1\n    for number in numbers:\n        total_sum += number\n        total_product *= number\n    return (total_sum, total_product)"
      ],
      [
        0.9190466403961182,
        "    if len(numbers) == 0:\n        print('List is empty.')\n        return\n    s = 0\n    p = 1\n    for num in numbers:\n        s += num\n        p *= num\n    print('The sum is:', s)\n    print('The product is:', p)"
      ],
      [
        0.9050062298774719,
        "    if not lst:\n        return {'sum': 0, 'product': 0}\n    total = 1\n    for num in lst:\n        if not isinstance(num, (int, float)):\n            raise TypeError('List must contain only numbers')\n        total *= num\n    return {'sum': sum(lst), 'product': total}"
      ],
      [
        0.9043492078781128,
        "    sum_res = 0\n    product_res = 1\n    if not lst:\n        return (sum_res, None)\n    for x in lst:\n        if isinstance(x, (int, float)):\n            sum_res += x\n            product_res *= x\n        else:\n            raise ValueError('List contains non-numeric values.')\n    return (sum_res, product_res)"
      ],
      [
        0.9015790224075317,
        "    total_sum = sum(nums)\n    total_product = 1\n    for num in nums:\n        if num != 0:\n            total_product *= num\n    return (total_sum, total_product)"
      ],
      [
        0.8995956182479858,
        "    if not arr:\n        return 'The provided list is empty.'\n    total = 0\n    product = 1\n    count = 0\n    for element in arr:\n        if not isinstance(element, (int, float)):\n            print(f'Error: {element} is not a number. Skipping this element.')\n            continue\n        total += element\n        product *= element\n        count += 1\n    if count == 0:\n        return 'There were no numeric elements in the list.'\n    average = total / count\n    return (total, product, average)"
      ],
      [
        0.8988819122314453,
        "    sum_of_squares = 0\n    product_of_cubes = 1\n    for num in numbers:\n        if num % 2 == 0:\n            sum_of_squares += num * num\n        else:\n            product_of_cubes *= num * num * num\n    return (sum_of_squares, product_of_cubes)"
      ],
      [
        0.8976455926895142,
        "    for number in numbers:\n        total_sum += number\n        total_product *= number"
      ],
      [
        0.8974344730377197,
        "    for num in numbers:\n        if isinstance(num, (int, float, complex)):\n            if isinstance(num, complex):\n                num = num.imag\n            product *= num\n        elif isinstance(num, (set, list, tuple)):\n            product *= get_product(num)"
      ]
    ],
    "HumanEval/9": [
      [
        0.9201750159263611,
        "    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
      ],
      [
        0.908666729927063,
        "    if not numbers1 or not numbers2:\n        return ([], [])\n    max1 = numbers1[0]\n    max2 = numbers2[0]\n    rolling_max1 = [max1]\n    rolling_max2 = [max2]\n    for num in numbers1[1:]:\n        if num > max1:\n            max1 = num\n        rolling_max1.append(max1)\n    for num in numbers2[1:]:\n        if num > max2:\n            max2 = num\n        rolling_max2.append(max2)\n    return (rolling_max1, rolling_max2)"
      ],
      [
        0.9086098670959473,
        "    if not numbers1 or not numbers2:\n        return ([], [])\n    max1 = numbers1[0]\n    max2 = numbers2[0]\n    rolling_max1 = [max1]\n    rolling_max2 = [max2]\n    for num in numbers1[1:]:\n        if num > max1:\n            max1 = num\n        rolling_max1.append(max1)\n    for num in numbers2[1:]:\n        if num > max2:\n            max2 = num\n        rolling_max2.append(max2)\n    return (rolling_max1, rolling_max2)"
      ],
      [
        0.9042291641235352,
        "    for num in numbers1[1:]:\n        if num > max1:\n            max1 = num\n        rolling_max1.append(max1)"
      ],
      [
        0.9042202234268188,
        "    for num in numbers1[1:]:\n        if num > max1:\n            max1 = num\n        rolling_max1.append(max1)"
      ],
      [
        0.902834415435791,
        "    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))"
      ],
      [
        0.9009923338890076,
        "    for num in numbers2[1:]:\n        if num > max2:\n            max2 = num\n        rolling_max2.append(max2)"
      ],
      [
        0.9009866714477539,
        "    for num in numbers2[1:]:\n        if num > max2:\n            max2 = num\n        rolling_max2.append(max2)"
      ],
      [
        0.8997691869735718,
        "    max_num = numbers[0]\n    result = [max_num]\n    for i in numbers[1:]:\n        if i > max_num:\n            max_num = i\n        result.append(max_num)\n    return result"
      ],
      [
        0.8997573852539062,
        "    max_num = numbers[0]\n    result = [max_num]\n    for i in numbers[1:]:\n        if i > max_num:\n            max_num = i\n        result.append(max_num)\n    return result"
      ]
    ],
    "HumanEval/10": [
      [
        0.9333310127258301,
        "    palindrome_substr = longest_palindromic_postfix(string)\n    prefix = string[:len(string) - len(palindrome_substr)]\n    palindrome = string + prefix[::-1]\n    return palindrome"
      ],
      [
        0.9333086609840393,
        "    palindrome_substr = longest_palindromic_postfix(string)\n    prefix = string[:len(string) - len(palindrome_substr)]\n    palindrome = string + prefix[::-1]\n    return palindrome"
      ],
      [
        0.9299436807632446,
        "    string = ''.join(filter(str.isalnum, string.lower()))\n    prefix = ''.join(filter(str.isalnum, prefix.lower()))\n    suffix = ''.join(filter(str.isalnum, suffix.lower()))\n    string = prefix + string + suffix\n    postfix = longest_palindrome_postfix(string)\n    prefix_to_mirror = string[:-len(postfix)] if postfix else string\n    return string + prefix_to_mirror[::-1]"
      ],
      [
        0.9281924962997437,
        "    palindromic_postfix = longest_palindromic_postfix(string)\n    prefix = string[0:len(string) - len(palindromic_postfix)]\n    return string + prefix[::-1]"
      ],
      [
        0.9281749725341797,
        "    palindromic_postfix = longest_palindromic_postfix(string)\n    prefix = string[0:len(string) - len(palindromic_postfix)]\n    return string + prefix[::-1]"
      ],
      [
        0.9258687496185303,
        "    string = ''.join((ch for ch in string if ch.isalnum())).lower()\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return ''"
      ]
    ],
    "HumanEval/11": [
      [
        0.9333575963973999,
        "    result = []\n    for i in range(len(a)):\n        bit_a = int(a[i])\n        bit_b = int(b[i])\n        xor_result = bit_a ^ bit_b\n        result.append(str(xor_result))\n    return result"
      ],
      [
        0.9294401407241821,
        "    n = max(len(num1), len(num2))\n    num1 = num1.zfill(n)\n    num2 = num2.zfill(n)\n    num1 = int(num1, 2)\n    num2 = int(num2, 2)\n    xor_result = num1 ^ num2\n    xor_binary = bin(xor_result)[2:].zfill(n)\n    xor_list = [int(bit) for bit in xor_binary]\n    return xor_list"
      ],
      [
        0.9267842769622803,
        "    xor_result = int(a, 2) ^ int(b, 2)\n    xor_result_str = format(xor_result, 'b').zfill(len(a))\n    return xor_result_str"
      ],
      [
        0.9255679249763489,
        "    a_int = int(a, 2)\n    b_int = int(b, 2)\n    xor_result = a_int ^ b_int\n    return format(xor_result, 'b')"
      ],
      [
        0.9254258871078491,
        "    for i in range(len(a)):\n        bit_a = int(a[i])\n        bit_b = int(b[i])\n        xor_result = bit_a ^ bit_b\n        result.append(str(xor_result))"
      ],
      [
        0.9234309196472168,
        "    xor_result = bin(int(a, 2) ^ int(b, 2))[2:]\n    res = xor_result[0]\n    for x in xor_result[1:]:\n        if x != res[-1]:\n            res += x\n    return res"
      ],
      [
        0.9189093708992004,
        "    for i in range(len(a)):\n        xor_result += str(int(a[i]) ^ int(b[i]))"
      ],
      [
        0.9189092516899109,
        "    for i in range(len(a)):\n        xor_result += str(int(a[i]) ^ int(b[i]))"
      ],
      [
        0.9188973903656006,
        "    for i in range(len(a)):\n        xor_result += str(int(a[i]) ^ int(b[i]))"
      ],
      [
        0.9188896417617798,
        "    for i in range(len(a)):\n        xor_result += str(int(a[i]) ^ int(b[i]))"
      ]
    ],
    "HumanEval/12": [
      [
        0.9278738498687744,
        "    if not strings:\n        return None\n    longest_string = strings[0]\n    for string in strings:\n        if len(string) > len(longest_string):\n            longest_string = string\n    return longest_string"
      ],
      [
        0.927869439125061,
        "    if not strings:\n        return None\n    longest_string = strings[0]\n    for string in strings:\n        if len(string) > len(longest_string):\n            longest_string = string\n    return longest_string"
      ],
      [
        0.9226057529449463,
        "    if not strings:\n        return None\n    else:\n        max_length = len(max(strings, key=len))\n        for string in strings:\n            if len(string) == max_length:\n                return string"
      ],
      [
        0.9226057529449463,
        "    if not strings:\n        return None\n    else:\n        max_length = len(max(strings, key=len))\n        for string in strings:\n            if len(string) == max_length:\n                return string"
      ],
      [
        0.9222418665885925,
        "    if not strings:\n        return None\n    return max(strings, key=len)"
      ],
      [
        0.922233521938324,
        "    if not strings:\n        return None\n    return max(strings, key=len)"
      ],
      [
        0.9210304021835327,
        "    if strings is None:\n        return None\n    if not isinstance(strings, list):\n        raise NotAListError('Input is not a list')\n    max_length = -1\n    longest_str = None\n    for string in strings:\n        if len(string) > max_length:\n            max_length = len(string)\n            longest_str = string\n    return longest_str"
      ],
      [
        0.9201749563217163,
        "    if not strings:\n        return None\n    else:\n        return max(strings, key=len)"
      ],
      [
        0.9201749563217163,
        "    if not strings:\n        return None\n    else:\n        return max(strings, key=len)"
      ],
      [
        0.919323205947876,
        "    longest_string = None\n    max_length = 0\n    for string in strings:\n        if len(string) > max_length:\n            longest_string = string\n            max_length = len(string)\n    return longest_string"
      ]
    ],
    "HumanEval/13": [
      [
        0.9368824362754822,
        "    if b == 0:\n        return a\n    return greatest_common_divisor(b, a % b)"
      ],
      [
        0.9368740320205688,
        "    if b == 0:\n        return a\n    return greatest_common_divisor(b, a % b)"
      ]
    ],
    "HumanEval/14": [
      [
        0.9048323631286621,
        "    substrings = []\n    for i in range(len(string)):\n        current_substring = ''\n        for j in range(i, len(string)):\n            current_substring += string[j]\n            substrings.append(current_substring)\n    return substrings"
      ],
      [
        0.9033101201057434,
        "    substrings = set()\n    for i in range(len(string)):\n        for j in range(i + 1, len(string) + 1):\n            substrings.add(string[i:j])\n    return sorted(list(substrings))"
      ],
      [
        0.9016103148460388,
        "    substrings = []\n    for i in range(len(string)):\n        for j in range(i, len(string)):\n            substring = string[i:j + 1]\n            substrings.append(substring)\n    substrings.sort()\n    return substrings"
      ],
      [
        0.9007095098495483,
        "    substrings = []\n    for i in range(len(string)):\n        for j in range(i, len(string)):\n            substrings.append(string[i:j + 1])\n    return substrings"
      ],
      [
        0.8981368541717529,
        "    substrings = []\n    for i in range(len(string)):\n        for j in range(i + 1, len(string) + 1):\n            substrings.append(string[i:j])\n    return substrings"
      ],
      [
        0.8981330394744873,
        "    substrings = []\n    for i in range(len(string)):\n        for j in range(i + 1, len(string) + 1):\n            substrings.append(string[i:j])\n    return substrings"
      ],
      [
        0.8981279134750366,
        "    substrings = []\n    for i in range(len(string)):\n        for j in range(i + 1, len(string) + 1):\n            substrings.append(string[i:j])\n    return substrings"
      ],
      [
        0.8981267213821411,
        "    substrings = []\n    for i in range(len(string)):\n        for j in range(i + 1, len(string) + 1):\n            substrings.append(string[i:j])\n    return substrings"
      ],
      [
        0.8981219530105591,
        "    substrings = []\n    for i in range(len(string)):\n        for j in range(i + 1, len(string) + 1):\n            substrings.append(string[i:j])\n    return substrings"
      ],
      [
        0.8981031179428101,
        "    substrings = []\n    for i in range(len(string)):\n        for j in range(i + 1, len(string) + 1):\n            substrings.append(string[i:j])\n    return substrings"
      ]
    ],
    "HumanEval/15": [
      [
        0.9186404347419739,
        "    sequence = []\n    for i in range(n + 1):\n        sequence.append(str(i))\n    return ' '.join(sequence)"
      ],
      [
        0.8928039073944092,
        "    for i in range(n + 1):\n        sequence.append(str(i))"
      ],
      [
        0.8924891948699951,
        "    assert generate_sequence(5) == [1, 2, 3, 4, 5]\n    assert generate_sequence(10) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    assert generate_sequence(3) == [1, 2, 3]"
      ],
      [
        0.8918759822845459,
        "    sequence = []\n    for i in range(0, n + 1):\n        sequence.append(i)\n    return sequence"
      ],
      [
        0.8918759822845459,
        "    sequence = []\n    for i in range(0, n + 1):\n        sequence.append(i)\n    return sequence"
      ],
      [
        0.887938380241394,
        "    if n < 0:\n        print('Error: Negative input.')\n        return\n    elif n == 0:\n        print(0)\n        return\n    else:\n        print_sequence(n - 1)\n        print(n)"
      ],
      [
        0.887938380241394,
        "    if n < 0:\n        print('Error: Negative input.')\n        return\n    elif n == 0:\n        print(0)\n        return\n    else:\n        print_sequence(n - 1)\n        print(n)"
      ],
      [
        0.8879295587539673,
        "    if n < 0:\n        print('Error: Negative input.')\n        return\n    elif n == 0:\n        print(0)\n        return\n    else:\n        print_sequence(n - 1)\n        print(n)"
      ],
      [
        0.8879295587539673,
        "    if n < 0:\n        print('Error: Negative input.')\n        return\n    elif n == 0:\n        print(0)\n        return\n    else:\n        print_sequence(n - 1)\n        print(n)"
      ],
      [
        0.8871281147003174,
        "    try:\n        if 0 <= n <= 10 ** 9:\n            return ''.join((str(i) for i in range(n + 1)))\n        else:\n            return 'Input must be a non-negative integer no greater than 10^9'\n    except TypeError:\n        return 'Input must be an integer'"
      ]
    ],
    "HumanEval/16": [
      [
        0.9291220307350159,
        "    distinct_characters = set(string)\n    return len(distinct_characters)"
      ],
      [
        0.925786018371582,
        "    distinct_letters = set()\n    for char in string:\n        if char.islower():\n            distinct_letters.add(char)\n    return len(distinct_letters)"
      ],
      [
        0.923970103263855,
        "    distinct_chars = set(string)\n    return len(distinct_chars)"
      ],
      [
        0.9191524982452393,
        "    characters = set()\n    for char in string:\n        characters.add(char)\n    return len(characters)"
      ],
      [
        0.9163897037506104,
        "    distinct_words = set()\n    words = string.split()\n    for word in words:\n        distinct_words.add(word.lower())\n    return len(distinct_words)"
      ],
      [
        0.9157619476318359,
        "    unique_characters = set(string.lower().replace(' ', ''))\n    return len(unique_characters)"
      ],
      [
        0.9121776223182678,
        "    words = string.split()\n    distinct_words = set(words)\n    return len(distinct_words)"
      ],
      [
        0.9119484424591064,
        "    seen_chars = set()\n    count = 0\n    for char in string:\n        if char not in seen_chars:\n            seen_chars.add(char)\n            count += 1\n    return count"
      ],
      [
        0.9104049205780029,
        "    unique_chars = []\n    count = 0\n    for char in string:\n        if char not in unique_chars:\n            count += 1\n            unique_chars.append(char)\n    return count"
      ],
      [
        0.9102634191513062,
        "    unique_chars = set(string)\n    return len(unique_chars)"
      ]
    ],
    "HumanEval/17": [
      [
        0.9394757747650146,
        "    notes_map = {'o': 4, 'o|': 2, '.|': 1}\n    notes = music_string.split()\n    beats = [notes_map[note] for note in notes]\n    return beats"
      ],
      [
        0.9375298619270325,
        "    notes = music_string.split(' ')\n    beat_duration = []\n    for note in notes:\n        if note == 'o':\n            beat_duration.append(4)\n        elif note == 'o|':\n            beat_duration.append(2)\n        elif note == '.|':\n            beat_duration.append(1)\n    return beat_duration"
      ],
      [
        0.9186577796936035,
        "        if note == 'o':\n            beat_duration.append(4)\n        elif note == 'o|':\n            beat_duration.append(2)\n        elif note == '.|':\n            beat_duration.append(1)"
      ],
      [
        0.91819167137146,
        "    for note in notes:\n        if note == 'o':\n            beat_duration.append(4)\n        elif note == 'o|':\n            beat_duration.append(2)\n        elif note == '.|':\n            beat_duration.append(1)"
      ],
      [
        0.9113762378692627,
        "        elif note == 'o|':\n            beat_duration.append(2)\n        elif note == '.|':\n            beat_duration.append(1)"
      ],
      [
        0.8948849439620972,
        "        elif note == '.|':\n            beat_duration.append(1)"
      ],
      [
        0.8939126133918762,
        "    beats = []\n    measure = []\n    total_beats = 0\n    measures_count = 0\n    notes = music_string.split()\n    for note in notes:\n        note_value = NOTE_VALUES[note] * tempo_multiplier\n        if total_beats + note_value > 1:\n            beats.append(measure)\n            measure = []\n            total_beats = 0\n            measures_count += 1\n        measure.append(note_value)\n        total_beats += note_value\n    if measure:\n        beats.append(measure)\n        measures_count += 1\n    return (beats, measures_count)"
      ],
      [
        0.893900990486145,
        "    beats = []\n    measure = []\n    total_beats = 0\n    measures_count = 0\n    notes = music_string.split()\n    for note in notes:\n        note_value = NOTE_VALUES[note] * tempo_multiplier\n        if total_beats + note_value > 1:\n            beats.append(measure)\n            measure = []\n            total_beats = 0\n            measures_count += 1\n        measure.append(note_value)\n        total_beats += note_value\n    if measure:\n        beats.append(measure)\n        measures_count += 1\n    return (beats, measures_count)"
      ],
      [
        0.8897483348846436,
        "    if not 0 <= BPM <= 300:\n        raise Exception('BPM should be between 0 and 300')\n    music_notes = music_string.split(' ')\n    transposed_notes = []\n    for note in music_notes:\n        beats_per_note = 4 if note == 'o' else 2 if note == 'o|' else 1\n        transpose_val = 70 + BPM // 10 * beats_per_note\n        transposed_notes.append(transpose_val)\n    return transposed_notes"
      ],
      [
        0.878284215927124,
        "    for note in music_notes:\n        beats_per_note = 4 if note == 'o' else 2 if note == 'o|' else 1\n        transpose_val = 70 + BPM // 10 * beats_per_note\n        transposed_notes.append(transpose_val)"
      ]
    ],
    "HumanEval/18": [
      [
        0.9265977144241333,
        "    count, last_idx = (0, -1)\n    while True:\n        last_idx = string.find(substring, last_idx + 1)\n        if last_idx != -1:\n            count += 1\n        else:\n            break\n    return count"
      ],
      [
        0.9265834093093872,
        "    count, last_idx = (0, -1)\n    while True:\n        last_idx = string.find(substring, last_idx + 1)\n        if last_idx != -1:\n            count += 1\n        else:\n            break\n    return count"
      ],
      [
        0.920912504196167,
        "    subsequence_indices = [i for i in range(len(string)) if string[i:].startswith(substring)]\n    subsequence_count = 0\n    subsequence_positions = []\n    for i in range(len(subsequence_indices)):\n        if subsequence_indices[i] not in range(subsequence_indices[i - 1], subsequence_indices[i - 1] + len(substring)):\n            subsequence_count += 1\n            subsequence_positions.append(subsequence_indices[i])\n    return (subsequence_count, subsequence_positions)"
      ]
    ],
    "HumanEval/19": [
      [
        0.9015886187553406,
        "    num2words = {1: 'One', 2: 'Two', 3: 'Three', 4: 'Four', 5: 'Five', 6: 'Six', 7: 'Seven', 8: 'Eight', 9: 'Nine'}\n    valid_nums = sorted([n for n in arr if 1 <= n <= 9], reverse=True)\n    return [num2words[n] for n in valid_nums]"
      ],
      [
        0.8966484069824219,
        "    numbers = re.findall('\\\\d+', string)\n    numbers_greater_than_5 = [int(num) for num in numbers if int(num) > 5]\n    numbers_greater_than_5.sort(reverse=True)\n    return numbers_greater_than_5"
      ],
      [
        0.8950948715209961,
        "    return sorted(numbers, key=lambda x: int(str(x)[0]), reverse=True)"
      ],
      [
        0.8943517804145813,
        "    numbers = {0: 'zero', 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', 6: 'six', 7: 'seven', 8: 'eight', 9: 'nine'}\n    number_string = ''\n    while num != 0:\n        digit = num % 10\n        number_string = numbers[digit] + ' ' + number_string\n        num = num // 10\n    return number_string.strip()"
      ],
      [
        0.8915853500366211,
        "    string_nums = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']\n    return string_nums[num]"
      ],
      [
        0.8915671706199646,
        "    result = []\n    for num in lst:\n        try:\n            if 0 <= int(num) <= 10 and num not in result:\n                result.append(num)\n        except ValueError:\n            continue\n    return sorted(result)"
      ],
      [
        0.8912534713745117,
        "    negatives, zeros, positives = ([], [], [])\n    for num in numbers:\n        if num < 0:\n            negatives.append(num)\n        elif num > 0:\n            positives.append(num)\n        else:\n            zeros.append(num)\n    negatives.sort()\n    positives.sort()\n    result = negatives + zeros + positives\n    return result"
      ],
      [
        0.8909178972244263,
        "    numbers = []\n    strings = []\n    for element in arr:\n        if element.isdigit():\n            numbers.append(element)\n        else:\n            strings.append(element)\n    numbers.sort()\n    strings.sort()\n    sorted_arr = numbers + strings\n    return sorted_arr"
      ],
      [
        0.8888164758682251,
        "    return sorted(arr, key=lambda s: (extract_num(s), s.lower()))"
      ],
      [
        0.8887967467308044,
        "    converted_nums = []\n    for num in arr:\n        try:\n            converted_nums.append(int(num))\n        except ValueError:\n            continue\n    n = len(converted_nums)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if converted_nums[j] < converted_nums[j + 1]:\n                converted_nums[j], converted_nums[j + 1] = (converted_nums[j + 1], converted_nums[j])\n    return converted_nums"
      ]
    ],
    "HumanEval/20": [
      [
        0.9274997115135193,
        "    if len(numbers) < 2:\n        raise ValueError('The provided list must contain at least two numbers.')\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (None, None)\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    return closest_pair"
      ],
      [
        0.9243718981742859,
        "    numbers_with_indices = [(num, idx) for idx, num in enumerate(numbers)]\n    numbers_with_indices.sort()\n    num1, idx1, num2, idx2, min_distance = (None, -1, None, -1, float('inf'))\n    for i in range(1, len(numbers_with_indices)):\n        if numbers_with_indices[i][0] != numbers_with_indices[i - 1][0]:\n            distance = numbers_with_indices[i][0] - numbers_with_indices[i - 1][0]\n            if distance < min_distance:\n                num1, idx1 = numbers_with_indices[i - 1]\n                num2, idx2 = numbers_with_indices[i]\n                min_distance = distance\n    return (num1, idx1, num2, idx2)"
      ],
      [
        0.9192315340042114,
        "    if not numbers:\n        return []\n    if len(numbers) < 2:\n        return []\n    if any((not isinstance(i, (int, float)) for i in numbers)):\n        raise ValueError('All elements in the list should be integers or floats.')\n    numbers.sort()\n    smallest_diff = float('inf')\n    pairs = []\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < smallest_diff:\n            smallest_diff = diff\n            pairs = [(numbers[i - 1], numbers[i])]\n        elif diff == smallest_diff:\n            pairs.append((numbers[i - 1], numbers[i]))\n    return pairs"
      ],
      [
        0.9089609384536743,
        "    sorted_numbers = sorted(numbers)\n    return (sorted_numbers[1], sorted_numbers[-2])"
      ],
      [
        0.9071352481842041,
        "    smallest_difference = float('inf')\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            difference = abs(numbers[i] - numbers[j])\n            if difference < smallest_difference:\n                smallest_difference = difference\n                smallest_pair = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]), i, j) if numbers[i] < numbers[j] else (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]), j, i)\n    return smallest_pair"
      ],
      [
        0.9069873094558716,
        "    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])"
      ]
    ],
    "HumanEval/21": [
      [
        0.9181297421455383,
        "    min_elem = min(numbers)\n    scale = max(numbers) - min_elem\n    for i in range(len(numbers)):\n        numbers[i] = (numbers[i] - min_elem) / scale\n    return numbers"
      ],
      [
        0.9104619026184082,
        "    min_num = min(numbers)\n    max_num = max(numbers)\n    for i in range(0, len(numbers)):\n        numbers[i] = (numbers[i] - min_num) / (max_num - min_num)\n    return numbers"
      ],
      [
        0.9029601812362671,
        "    max_number = max(numbers)\n    min_number = min(numbers)\n    normalized_numbers = []\n    for number in numbers:\n        if max_number - min_number == 0:\n            normalized_numbers.append(0)\n        else:\n            normalized_numbers.append((number - min_number) / (max_number - min_number))\n    return normalized_numbers"
      ],
      [
        0.902244508266449,
        "    for i in range(len(numbers)):\n        numbers[i] = (numbers[i] - min_elem) / scale"
      ],
      [
        0.8993819952011108,
        "    for i in range(0, len(numbers)):\n        numbers[i] = (numbers[i] - min_num) / (max_num - min_num)"
      ],
      [
        0.8968309760093689,
        "    max_value = max(numbers)\n    normalized_numbers = [n / (2 * max_value) for n in numbers]\n    return normalized_numbers"
      ],
      [
        0.8962159156799316,
        "    for number in numbers:\n        if max_number - min_number == 0:\n            normalized_numbers.append(0)\n        else:\n            normalized_numbers.append((number - min_number) / (max_number - min_number))"
      ],
      [
        0.8954958915710449,
        "    min_n = min(nums)\n    max_n = max(nums)\n    return [(n - min_n) / (max_n - min_n) for n in nums]"
      ],
      [
        0.894136905670166,
        "    max_val = max(list_numbers)\n    normalized = [n / max_val for n in list_numbers]\n    return normalized"
      ],
      [
        0.8918997049331665,
        "    max_num = max(numbers)\n    min_num = min(numbers)\n    scaled_numbers = [(num - min_num) / (max_num - min_num) * target_width for num in numbers]\n    return scaled_numbers"
      ]
    ],
    "HumanEval/22": [
      [
        0.9043695330619812,
        "    int_list = []\n    for i in input_list:\n        if isinstance(i, int):\n            int_list.append(i)\n        else:\n            print('{} is not an integer. Ignoring...'.format(i))\n    return sorted(set(int_list))"
      ],
      [
        0.9027715921401978,
        "    output_list = set()\n    for i in input_list:\n        if isinstance(i, (int, float)):\n            output_list.add(int(i))\n        elif isinstance(i, str):\n            try:\n                output_list.add(int(i))\n            except ValueError:\n                print(f'Invalid integer value: {i}')\n                continue\n    return output_list"
      ],
      [
        0.9006220102310181,
        "    res = []\n    for item in my_list:\n        if type(item) == int:\n            res.append(item)\n    return res"
      ],
      [
        0.8991385698318481,
        "    return [val for val in values if isinstance(val, int)]"
      ],
      [
        0.8985050916671753,
        "    converted_integers = []\n    for value in args:\n        try:\n            converted_integers.append(int(value))\n        except ValueError:\n            print(f\"Error: '{value}' is not a valid integer. Skipping...\")\n    return converted_integers"
      ],
      [
        0.896186888217926,
        "    unique_values = []\n    for value in list_of_integers:\n        if value not in unique_values:\n            unique_values.append(value)\n    return unique_values"
      ],
      [
        0.8943580389022827,
        "    for i in input_list:\n        if isinstance(i, (int, float)):\n            output_list.add(int(i))\n        elif isinstance(i, str):\n            try:\n                output_list.add(int(i))\n            except ValueError:\n                print(f'Invalid integer value: {i}')\n                continue"
      ],
      [
        0.89412522315979,
        "    result = []\n    for sublist in values:\n        for value in sublist:\n            if isinstance(value, int):\n                result.append(value)\n    return result"
      ],
      [
        0.8916116952896118,
        "    list_of_integers = []\n    for string in list_of_strings:\n        list_of_integers.append(int(string))\n    return list_of_integers"
      ]
    ],
    "HumanEval/23": [
      [
        0.9189034104347229,
        "    length = 0\n    for c in string:\n        length += 1\n    return length"
      ],
      [
        0.9187778234481812,
        "    length = 0\n    for char in string:\n        length += 1\n    return length"
      ],
      [
        0.9187759160995483,
        "    length = 0\n    for char in string:\n        length += 1\n    return length"
      ],
      [
        0.9187736511230469,
        "    length = 0\n    for char in string:\n        length += 1\n    return length"
      ],
      [
        0.9135337471961975,
        "    len_str = 0\n    for char in str:\n        len_str += 1\n    return len_str"
      ],
      [
        0.9117221236228943,
        "    length = 0\n    for i in string:\n        length = length + 1\n    return length"
      ],
      [
        0.9071107506752014,
        "    return len(string)"
      ],
      [
        0.9070959687232971,
        "    return len(string)"
      ],
      [
        0.9070946574211121,
        "    return len(string)"
      ],
      [
        0.9070946574211121,
        "    return len(string)"
      ]
    ],
    "HumanEval/24": [
      [
        0.9362852573394775,
        "    if n == divisor:\n        return n\n    elif n % divisor == 0:\n        return find_largest_prime(n // divisor, divisor)\n    else:\n        return find_largest_prime(n, divisor + 1)"
      ],
      [
        0.9362852573394775,
        "    if n == divisor:\n        return n\n    elif n % divisor == 0:\n        return find_largest_prime(n // divisor, divisor)\n    else:\n        return find_largest_prime(n, divisor + 1)"
      ],
      [
        0.9362819194793701,
        "    if n == divisor:\n        return n\n    elif n % divisor == 0:\n        return find_largest_prime(n // divisor, divisor)\n    else:\n        return find_largest_prime(n, divisor + 1)"
      ],
      [
        0.9362819194793701,
        "    if n == divisor:\n        return n\n    elif n % divisor == 0:\n        return find_largest_prime(n // divisor, divisor)\n    else:\n        return find_largest_prime(n, divisor + 1)"
      ],
      [
        0.9356512427330017,
        "    elif n % divisor == 0:\n        return find_largest_prime(n // divisor, divisor)\n    else:\n        return find_largest_prime(n, divisor + 1)"
      ],
      [
        0.9356170296669006,
        "    elif n % divisor == 0:\n        return find_largest_prime(n // divisor, divisor)\n    else:\n        return find_largest_prime(n, divisor + 1)"
      ],
      [
        0.9317411184310913,
        "    if n < 2:\n        return 0\n    while n % 2 == 0:\n        n = n // 2\n    largest_factor = 1\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n    if n > 2:\n        largest_factor = n\n    return largest_factor"
      ],
      [
        0.9288069009780884,
        "    n = int(abs(n))\n    if n == 1:\n        return 1\n    largest = 2\n    while n % 2 == 0:\n        n = n // 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            largest = i\n            n = n // i\n    if n > 2:\n        largest = n\n    return largest"
      ],
      [
        0.9278652667999268,
        "    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i"
      ],
      [
        0.9278470277786255,
        "    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i"
      ]
    ],
    "HumanEval/25": [
      [
        0.9254420399665833,
        "    if not isinstance(n, int) or n <= 1:\n        raise ValueError('Input must be an integer greater than 1')\n    prime_factors = prime_factors_sieve(n)\n    return [prime_factors[i] for i in range(2, n + 1)]"
      ],
      [
        0.9240829944610596,
        "    if n == 1:\n        return []\n    factors = [1, n]\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            factors.append(i)\n            if i * i != n:\n                factors.append(n / i)\n    return sorted(factors)"
      ],
      [
        0.9239227175712585,
        "    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n //= 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n    if n > 2:\n        factors.append(n)\n    return factors"
      ],
      [
        0.9230512976646423,
        "    factors = []\n    i = 2\n    while n > 1:\n        while n % i == 0:\n            factors.append(i)\n            n /= i\n        i += 1\n    return factors"
      ],
      [
        0.9225526452064514,
        "    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n //= 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n    if n > 1:\n        factors.append(n)\n    return factors"
      ],
      [
        0.922059178352356,
        "    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n = n // 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n    if n > 2:\n        factors.append(n)\n    return factors"
      ],
      [
        0.9220589399337769,
        "    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n = n // 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n    if n > 2:\n        factors.append(n)\n    return factors"
      ],
      [
        0.9214940667152405,
        "    if n <= 0:\n        return []\n    factor_list = [1]\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                factor_list.append(i)\n            else:\n                factor_list.append(i)\n                factor_list.append(n // i)\n    factor_list.append(n)\n    return sorted(factor_list)"
      ],
      [
        0.9213076829910278,
        "    prime_factors = []\n    while n % 2 == 0:\n        prime_factors.append(2)\n        n //= 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            prime_factors.append(i)\n            n //= i\n    if n > 2:\n        prime_factors.append(n)\n    return prime_factors"
      ],
      [
        0.9212054014205933,
        "    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n = n // 2\n    while n % 3 == 0:\n        factors.append(3)\n        n = n // 3\n    for i in range(5, int(n ** 0.5) + 1, 6):\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n        while n % (i + 2) == 0:\n            factors.append(i + 2)\n            n = n // (i + 2)\n    if n > 2:\n        factors.append(n)\n    return factors"
      ]
    ],
    "HumanEval/26": [
      [
        0.9310524463653564,
        "    if len(numbers) == 0:\n        return []\n    if allow_consecutive_duplicates:\n        new_length = 1\n        for i in range(1, len(numbers)):\n            if numbers[i] != numbers[new_length - 1]:\n                numbers[new_length] = numbers[i]\n                new_length += 1\n    else:\n        seen = set()\n        new_length = 0\n        for i in range(len(numbers)):\n            if numbers[i] not in seen:\n                seen.add(numbers[i])\n                numbers[new_length] = numbers[i]\n                new_length += 1\n    return numbers[:new_length]"
      ],
      [
        0.9285057187080383,
        "    number_dict = {}\n    result = []\n    for i in range(len(numbers)):\n        if numbers[i] in number_dict:\n            continue\n        elif allow_consecutive_duplicates and i + 1 < len(numbers) and (numbers[i] == numbers[i + 1]):\n            number_dict[numbers[i]] = True\n        else:\n            number_dict[numbers[i]] = False\n        result.append(numbers[i])\n    return result"
      ],
      [
        0.923786461353302,
        "    numbers.sort()\n    new_list = []\n    for num in numbers:\n        if num not in new_list:\n            new_list.append(num)\n    return new_list"
      ],
      [
        0.9222785234451294,
        "    new_list = []\n    for number in numbers:\n        if number not in new_list:\n            new_list.append(number)\n    return new_list"
      ],
      [
        0.9213120341300964,
        "    write = 1\n    for read in range(1, len(numbers)):\n        if numbers[read] != numbers[read - 1]:\n            numbers[write] = numbers[read]\n            write += 1\n    return numbers[:write]"
      ],
      [
        0.9206469058990479,
        "    return list(set(numbers))"
      ],
      [
        0.9206333160400391,
        "    return list(set(numbers))"
      ],
      [
        0.9206333160400391,
        "    return list(set(numbers))"
      ],
      [
        0.9206283688545227,
        "    return list(set(numbers))"
      ],
      [
        0.9206283688545227,
        "    return list(set(numbers))"
      ]
    ],
    "HumanEval/27": [
      [
        0.9169416427612305,
        "    toggled_string = ''\n    for char in string:\n        if char.isalpha():\n            toggled_string += char.swapcase()\n        else:\n            toggled_string += char\n    return toggled_string"
      ],
      [
        0.9137905836105347,
        "    swapped_string = ''\n    for char in string:\n        if char.islower():\n            swapped_string += char.upper()\n        elif char.isupper():\n            swapped_string += char.lower()\n        else:\n            swapped_string += char\n    return swapped_string"
      ],
      [
        0.9125499129295349,
        "    for char in string:\n        if char.isalpha():\n            toggled_string += char.swapcase()\n        else:\n            toggled_string += char"
      ],
      [
        0.9120219945907593,
        "    new_string = ''\n    for char in string:\n        if char.isupper():\n            new_string += char.lower()\n        else:\n            new_string += char.upper()\n    return new_string"
      ],
      [
        0.9120078682899475,
        "    new_string = ''\n    for char in string:\n        if char.isupper():\n            new_string += char.lower()\n        else:\n            new_string += char.upper()\n    return new_string"
      ],
      [
        0.910712480545044,
        "    if not string:\n        return ''\n    first_char = string[0]\n    if first_char.isalpha():\n        return first_char.swapcase() + change_case(string[1:])\n    else:\n        return first_char + change_case(string[1:])"
      ],
      [
        0.9099439978599548,
        "    assert input_string and isinstance(input_string, str), 'Input must be a non-empty string'\n    if input_string.islower():\n        return input_string.upper()\n    elif input_string.isupper():\n        return input_string.lower()\n    else:\n        result = ''\n        for i, char in enumerate(input_string):\n            if i % 2 == 0:\n                result += char.lower()\n            else:\n                result += char.upper()\n        return result"
      ],
      [
        0.9079713225364685,
        "    new_string = ''\n    for char in string:\n        if char.isupper():\n            new_string += char.lower()\n        elif char.islower():\n            new_string += char.upper()\n        else:\n            new_string += char\n    return new_string"
      ],
      [
        0.907939076423645,
        "    new_string = ''\n    for char in string:\n        if char.isupper():\n            new_string += char.lower()\n        elif char.islower():\n            new_string += char.upper()\n        else:\n            new_string += char\n    return new_string"
      ],
      [
        0.9076094627380371,
        "    converted_string = ''\n    for char in string:\n        if char.islower():\n            converted_string += char.upper()\n        elif char.isupper():\n            converted_string += char.lower()\n        else:\n            converted_string += char\n    return converted_string"
      ]
    ],
    "HumanEval/28": [
      [
        0.9165719747543335,
        "    if len(strings) == 0:\n        return ''"
      ],
      [
        0.9165675640106201,
        "    if len(strings) == 0:\n        return ''"
      ],
      [
        0.9165571928024292,
        "    if len(strings) == 0:\n        return ''"
      ],
      [
        0.9165443778038025,
        "    if len(strings) == 0:\n        return ''"
      ],
      [
        0.9128233790397644,
        "    result = ''\n    for string in strings:\n        result += string\n    return result"
      ],
      [
        0.9102015495300293,
        "    result = ''\n    for string in list_of_strings:\n        result += string\n    return result"
      ],
      [
        0.9066702127456665,
        "    if not strings:\n        return ''"
      ],
      [
        0.9066702127456665,
        "    if not strings:\n        return ''"
      ],
      [
        0.9066702127456665,
        "    if not strings:\n        return ''"
      ],
      [
        0.9066645503044128,
        "    if not strings:\n        return ''"
      ]
    ],
    "HumanEval/29": [
      [
        0.9009544253349304,
        "    return [string for string in strings if string.startswith(prefix)]"
      ],
      [
        0.8966149091720581,
        "    result = []\n    for string in strings:\n        if string.startswith(letter):\n            result.append(string)\n    return result"
      ],
      [
        0.8938316106796265,
        "    return [s for s in string_list if s.startswith(prefix)]"
      ],
      [
        0.8938199877738953,
        "    return [s for s in string_list if s.startswith(prefix)]"
      ],
      [
        0.893645703792572,
        "    new_array = []\n    for word in array:\n        if not word.startswith(prefix):\n            new_array.append(word)\n    return new_array"
      ],
      [
        0.8936243057250977,
        "    result = []\n    for string in strings:\n        if string.startswith('a'):\n            result.append(string)\n    if len(result) == 0:\n        return []\n    return result"
      ],
      [
        0.8933694362640381,
        "    return list(filter(lambda s: s.startswith(char), strings))"
      ],
      [
        0.893303394317627,
        "    result = []\n    characters_lower = [char.lower() for char in characters]\n    for string in strings:\n        if string[0].lower() in characters_lower:\n            result.append(string)\n    return result"
      ],
      [
        0.8932956457138062,
        "    result = []\n    characters_lower = [char.lower() for char in characters]\n    for string in strings:\n        if string[0].lower() in characters_lower:\n            result.append(string)\n    return result"
      ],
      [
        0.8892428874969482,
        "        for word in strings:\n            if word.startswith(string):\n                filtered_list.append(word)"
      ]
    ],
    "HumanEval/30": [
      [
        0.9304673671722412,
        "    input_list = [1, -2, 3, -4, 5]\n    expected_output = [1, 3, 5]\n    assert positive(input_list) == expected_output"
      ],
      [
        0.9275839924812317,
        "    positive_nums = []\n    for n in lst:\n        if n > 0:\n            positive_nums.append(n)\n    return positive_nums"
      ],
      [
        0.9220691919326782,
        "    positives = []\n    for num in l:\n        if num > 0:\n            positives.append(num)\n    return bubble_sort(positives)"
      ],
      [
        0.9194426536560059,
        "    positive_list = []\n    for num in input_list:\n        if num > 0:\n            positive_list.append(num)\n    positive_list.sort()\n    return positive_list"
      ],
      [
        0.9192445278167725,
        "    positive_nums = [num for num in l if num > 0]\n    return sorted(positive_nums)"
      ],
      [
        0.9149878025054932,
        "    positive_integers = []\n    for num in input_list:\n        if num > 0:\n            positive_integers.append(num)\n    return positive_integers"
      ],
      [
        0.9129878282546997,
        "    positive_nums = []\n    for num in nums:\n        if num > 0:\n            positive_nums.append(num)\n    return positive_nums"
      ],
      [
        0.9086258411407471,
        "    result = []\n    for num in l:\n        if num > 0:\n            result.append(num)\n    return result"
      ]
    ],
    "HumanEval/31": [],
    "HumanEval/32": [
      [
        0.9055863618850708,
        "    coefficients = coefficients[::-1]\n    try:\n        roots = np.roots(coefficients)\n    except ZeroDivisionError as e:\n        return f'Error: Division by zero. Full error - {e}'\n    for i in range(len(roots)):\n        if np.iscomplex(roots[i]):\n            return f'Warning: One or more solutions are non-real.'\n    return roots"
      ],
      [
        0.9035755395889282,
        "    num_coeff = len(xs)\n    derivative = [i * xs[i] for i in range(1, num_coeff)]\n    integral = [xs[i] / (i + 1) for i in range(num_coeff)]\n    integral.insert(0, C)\n    zeros = np.roots(list(reversed(xs))).tolist()\n    return (derivative, integral, zeros)"
      ],
      [
        0.9005577564239502,
        "    roots = []\n    a = np.flip(coeffs[:-1])\n    b = np.array([coeffs[-1]])\n    x = np.roots(np.append(a, b))\n    for i in range(degree):\n        roots.append((x[i], 0))\n    return roots"
      ],
      [
        0.8949102163314819,
        "    result = 0\n    n = len(coefficients)\n    for i, coefficient in enumerate(coefficients):\n        result += coefficient * x ** (n - i - 1)\n    return result"
      ],
      [
        0.8945355415344238,
        "    if len(xs) == 0:\n        return 'Invalid polynomial'"
      ],
      [
        0.8939359784126282,
        "    result = 0\n    power = len(coefficients) - 1\n    for coeff in coefficients:\n        result += coeff * x ** power\n        power -= 1\n    return result"
      ],
      [
        0.8920365571975708,
        "    roots = np.roots(coefficients)\n    real_roots = [root.real if abs(root.imag) < 1e-05 else root for root in roots]\n    return real_roots"
      ],
      [
        0.8918818235397339,
        "    result = 0\n    for i in range(len(poly)):\n        result += poly[i] * (len(poly) - i - 1) * pow(x, len(poly) - i - 2)\n    return result"
      ],
      [
        0.8918153047561646,
        "    try:\n        roots = np.roots(coefficients)\n    except ZeroDivisionError as e:\n        return f'Error: Division by zero. Full error - {e}'"
      ],
      [
        0.8914489150047302,
        "    for i in range(len(poly)):\n        result += poly[i] * (len(poly) - i - 1) * pow(x, len(poly) - i - 2)"
      ]
    ],
    "HumanEval/33": [
      [
        0.9208225607872009,
        "    multiples_of_three = sorted([l[i] for i in range(len(l)) if (i + 1) % 3 == 0], reverse=True)\n    for i, value in enumerate(l):\n        if (i + 1) % 3 == 0:\n            l[i] = multiples_of_three.pop(0)\n    return l"
      ],
      [
        0.9198426008224487,
        "    aux = [l[i] for i in range(0, len(l), 3)]\n    aux.sort()\n    for i in range(0, len(l), 3):\n        l[i] = aux.pop(0)\n    return l"
      ],
      [
        0.9173316359519958,
        "    mod_map = {k: [] for k in range(0, 3)}\n    for item in lst:\n        mod = item % 3\n        mod_map[mod].append(item)\n    sorted_list = []\n    for key in mod_map.keys():\n        sorted_list.extend(sorted(mod_map[key]))\n    return sorted_list"
      ],
      [
        0.910081684589386,
        "    multiples_of_3 = [num for num in lst if num % 3 == 0]\n    others = [num for num in lst if num % 3 != 0]\n    if order == 'asc':\n        others = sorted(others)\n    else:\n        others = sorted(others, reverse=True)\n    result = others + multiples_of_3\n    return result"
      ],
      [
        0.9100762009620667,
        "    multiples_of_3 = [num for num in lst if num % 3 == 0]\n    others = [num for num in lst if num % 3 != 0]\n    if order == 'asc':\n        others = sorted(others)\n    else:\n        others = sorted(others, reverse=True)\n    result = others + multiples_of_3\n    return result"
      ],
      [
        0.9041569828987122,
        "    arr = array[:]\n    even_group = []\n    odd_group = []\n    mixed_group = []\n    for i, num in enumerate(arr):\n        if i % 2 == 0 and num % 2 == 0:\n            even_group.append((i, num))\n        elif i % 2 == 1 and num % 2 == 1:\n            odd_group.append((i, num))\n        else:\n            mixed_group.append((i, num))\n    groups = [even_group, odd_group, mixed_group]\n    for group in groups:\n        sum_indices = sum((i for i, _ in group))\n        if sum_indices % 3 == 0:\n            group.sort(key=lambda x: x[1])\n        elif sum_indices % 2 == 0:\n            group.sort(key=lambda x: -x[1])\n        else:\n            evens = [num for _, num in group if num % 2 == 0]\n            evens.sort()\n            for i, (index, num) in enumerate(group):\n                if num % 2 == 0:\n                    group[i] = (index, evens.pop(0))\n    sorted_nums = [num for _, num in even_group + odd_group + mixed_group]\n    return sorted_nums"
      ],
      [
        0.9005470871925354,
        "    divisible_by_3 = []\n    not_divisible_by_3 = []\n    for num in arr:\n        if num % 3 == 0:\n            divisible_by_3.append(num)\n        else:\n            not_divisible_by_3.append(num)\n    return divisible_by_3 + not_divisible_by_3"
      ],
      [
        0.8995972275733948,
        "    for num in arr:\n        if num % 3 == 0:\n            divisible_by_3.append(num)\n        else:\n            not_divisible_by_3.append(num)"
      ],
      [
        0.8992984890937805,
        "    even_items = [l[i] for i in range(0, len(l), 2)]\n    even_items.sort()\n    for i, e in enumerate(sorted(even_items)):\n        l[2 * i] = e\n    return l"
      ],
      [
        0.8984860181808472,
        "    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    even_indices_values.sort()\n    for i in range(0, len(l), 2):\n        l[i] = even_indices_values[i // 2]\n    return l"
      ]
    ],
    "HumanEval/34": [
      [
        0.9393376111984253,
        "    unique_set = set(l)\n    unique_list = sorted(list(unique_set))\n    return unique_list"
      ],
      [
        0.9347521066665649,
        "    unique_elements = list(set(l))\n    return sorted(unique_elements)"
      ],
      [
        0.9217838644981384,
        "    l = list(set(l))\n    l.sort()\n    return l"
      ],
      [
        0.919615626335144,
        "    unique_dict = {}\n    for num in lst:\n        unique_dict[num] = True\n    unique_list = list(unique_dict.keys())\n    unique_list.sort()\n    return unique_list"
      ],
      [
        0.9193819761276245,
        "    unique_set = set(lst)\n    unique_list = list(unique_set)\n    unique_list.sort()\n    return unique_list"
      ],
      [
        0.9158962368965149,
        "    unique_lst = list(set(lst))\n    unique_lst.sort()\n    return unique_lst"
      ],
      [
        0.9141676425933838,
        "    if type(l) != list:\n        raise TypeError('Input should be a list')\n    for i in l:\n        if type(i) != int:\n            raise ValueError('Input list should only contain integers')\n    return sorted(list(set(l)))"
      ],
      [
        0.9137210249900818,
        "    return sorted(list(set(l)))"
      ],
      [
        0.9137204885482788,
        "    return sorted(list(set(l)))"
      ],
      [
        0.9137172102928162,
        "    return sorted(list(set(l)))"
      ]
    ],
    "HumanEval/35": [
      [
        0.9228004813194275,
        "    max_elmt = l[0]\n    for x in l:\n        if x > max_elmt:\n            max_elmt = x\n    return max_elmt"
      ],
      [
        0.9202615022659302,
        "    max_value = l[0]\n    for n in l:\n        if n > max_value:\n            max_value = n\n    return max_value"
      ],
      [
        0.9197783470153809,
        "    max_element = lst[0]\n    for element in lst:\n        if element > max_element:\n            max_element = element\n    return max_element"
      ],
      [
        0.9197593927383423,
        "    max_element = lst[0]\n    for element in lst:\n        if element > max_element:\n            max_element = element\n    return max_element"
      ],
      [
        0.9195232391357422,
        "    max_element = lst[0]\n    for i in range(1, len(lst)):\n        if lst[i] > max_element:\n            max_element = lst[i]\n    return max_element"
      ],
      [
        0.9145311117172241,
        "    largest = l[0]\n    for i in range(1, len(l)):\n        if l[i] > largest:\n            largest = l[i]\n    return largest"
      ],
      [
        0.9136481285095215,
        "    max_element = None\n    for element in lst:\n        if max_element is None or max_element < element:\n            max_element = element\n    return max_element"
      ],
      [
        0.9130918979644775,
        "    max_value = 0\n    for element in list:\n        if element > max_value:\n            max_value = element\n    return max_value"
      ],
      [
        0.911694347858429,
        "    max_element = my_list[0]\n    for i in range(1, len(my_list)):\n        if my_list[i] > max_element:\n            max_element = my_list[i]\n    return max_element"
      ],
      [
        0.9108866453170776,
        "    for element in lst:\n        if max_element is None or max_element < element:\n            max_element = element"
      ]
    ],
    "HumanEval/36": [
      [
        0.9296451807022095,
        "    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count"
      ],
      [
        0.9180513620376587,
        "    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')"
      ],
      [
        0.9064677953720093,
        "    count = 0\n    for i in range(1, abs(m)):\n        if '3' in str(i) and (i % 7 == 0 or i % 14 == 0):\n            count += 1\n    return count"
      ],
      [
        0.9037972688674927,
        "        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')"
      ],
      [
        0.9024956226348877,
        "    count = 0\n    for num in range(start_num, end_num + 1):\n        if num % 7 == 0 and str(digit) in str(num):\n            count += 1\n    return count"
      ],
      [
        0.899082362651825,
        "    for num in range(start_num, end_num + 1):\n        if num % 7 == 0 and str(digit) in str(num):\n            count += 1"
      ],
      [
        0.896255373954773,
        "    count = 0\n    for i in range(n):\n        if '5' in str(i) or '7' in str(i):\n            if i % 9 == 0 or i % 12 == 0 or i % 15 == 0:\n                digits_sum = sum((int(digit) for digit in str(i)))\n                if digits_sum % 3 == 0 or digits_sum % 5 == 0:\n                    count += 1\n    return count"
      ],
      [
        0.8953722715377808,
        "    for i in range(1, abs(m)):\n        if '3' in str(i) and (i % 7 == 0 or i % 14 == 0):\n            count += 1"
      ],
      [
        0.8945675492286682,
        "    if n < 7:\n        return 0\n    elif n % 7 == 0 or n % 11 == 0:\n        return n + sum_multiples(n - 1)\n    else:\n        return sum_multiples(n - 1)"
      ],
      [
        0.8945675492286682,
        "    if n < 7:\n        return 0\n    elif n % 7 == 0 or n % 11 == 0:\n        return n + sum_multiples(n - 1)\n    else:\n        return sum_multiples(n - 1)"
      ]
    ],
    "HumanEval/37": [
      [
        0.9385440349578857,
        "    even_indices_sorted = sorted((l[i] for i in range(0, len(l), 2)))\n    result = l[:]\n    result[::2] = even_indices_sorted\n    return result"
      ],
      [
        0.9383949041366577,
        "    even_items = [l[i] for i in range(0, len(l), 2)]\n    even_items.sort()\n    for i, e in enumerate(sorted(even_items)):\n        l[2 * i] = e\n    return l"
      ],
      [
        0.936000645160675,
        "    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    even_indices_values.sort()\n    for i in range(0, len(l), 2):\n        l[i] = even_indices_values[i // 2]\n    return l"
      ],
      [
        0.9229893088340759,
        "    evens = sorted(l[::2])\n    for i in range(0, len(l), 2):\n        l[i] = evens.pop(0)\n    return l"
      ],
      [
        0.9221898913383484,
        "    evens = [l[i] for i in range(0, len(l), 2)]\n    odds = [l[i] for i in range(1, len(l), 2)]\n    evens.sort(key=lambda x: -x if x < 0 else x)\n    new_list = [None] * len(l)\n    new_list[::2] = evens\n    new_list[1::2] = odds\n    return new_list"
      ],
      [
        0.9208522439002991,
        "    odd_list = sorted((element for index, element in enumerate(l) if index % 2))\n    l_prime = [odd_list.pop(0) if index % 2 else element for index, element in enumerate(l)]\n    return l_prime"
      ],
      [
        0.9194427728652954,
        "    even_index_elements = [l[i] for i in range(0, len(l), 2)]\n    if even_index_elements:\n        new_sorted_chunk = []\n        for i in range(0, len(even_index_elements), k):\n            new_sorted_chunk += sorted(even_index_elements[i:i + k])\n        for i, val in enumerate(new_sorted_chunk):\n            l[i * 2] = val\n    return l"
      ],
      [
        0.9191133379936218,
        "    if even_index_elements:\n        new_sorted_chunk = []\n        for i in range(0, len(even_index_elements), k):\n            new_sorted_chunk += sorted(even_index_elements[i:i + k])\n        for i, val in enumerate(new_sorted_chunk):\n            l[i * 2] = val"
      ],
      [
        0.9179609417915344,
        "    for i, e in enumerate(sorted(even_items)):\n        l[2 * i] = e"
      ],
      [
        0.9177829623222351,
        "    for i in range(0, len(l), 2):\n        l[i] = even_indices_values[i // 2]"
      ]
    ],
    "HumanEval/38": [
      [
        0.9308345913887024,
        "    encoded_string = ''\n    for i in range(0, len(s), 3):\n        group = s[i:i + 3]\n        encoded_string += group[::-1]\n    return encoded_string"
      ],
      [
        0.9281808137893677,
        "    groups = [s[i:min(i + 3, len(s))] for i in range(0, len(s), 3)]\n    decoded_groups = [group[-1] + group[:-1] if len(group) == 3 else group for group in groups]\n    return ''.join(decoded_groups)"
      ],
      [
        0.9239972829818726,
        "    for i in range(0, len(s), 3):\n        group = s[i:i + 3]\n        encoded_string += group[::-1]"
      ]
    ],
    "HumanEval/39": [
      [
        0.9383587837219238,
        "    if n < 1:\n        raise ValueError('n must be a positive integer.')\n    prime_fibonacci_numbers = []\n    i = 2\n    while len(prime_fibonacci_numbers) < n:\n        sequence = generate_fibonacci_sequence(i)\n        number = sequence[-1]\n        if sympy.isprime(number):\n            prime_fibonacci_numbers.append(number)\n        i += 1\n    return prime_fibonacci_numbers[-1]"
      ],
      [
        0.9315730929374695,
        "    fib_nums = fibonacci_seq(n)\n    prime_in_fib = [num for num in fib_nums if is_prime(num)]\n    return prime_in_fib"
      ],
      [
        0.9306377172470093,
        "    while len(prime_fibonacci_numbers) < n:\n        sequence = generate_fibonacci_sequence(i)\n        number = sequence[-1]\n        if sympy.isprime(number):\n            prime_fibonacci_numbers.append(number)\n        i += 1"
      ],
      [
        0.9292850494384766,
        "    fib_nums = [fib(i) for i in range(n + 1)]\n    return [num for num in fib_nums if is_prime(num)]"
      ],
      [
        0.9258809685707092,
        "    fib_seq = fibonacci(n)\n    primes = [num for num in fib_seq if is_prime(num)]\n    return primes"
      ],
      [
        0.9249085783958435,
        "    if n < 1:\n        return -1\n    count = 0\n    fib1, fib2 = (1, 1)\n    while True:\n        fib1, fib2 = (fib2, fib1 + fib2)\n        if is_prime(fib2):\n            count += 1\n            if count == n:\n                return fib2"
      ],
      [
        0.9246553182601929,
        "    prime_numbers = SieveOfEratosthenes(n)\n    fib_numbers = fibonacci(n)\n    prime_fibs = [x for x in fib_numbers if x in prime_numbers]\n    return prime_fibs"
      ],
      [
        0.9245330691337585,
        "    fib_n = generate_fibonacci(n)\n    primes = [i for i in range(fib_n + 1) if is_prime(i)]\n    return primes"
      ],
      [
        0.9233629107475281,
        "    count = 0\n    num1, num2 = (0, 1)\n    while count < n:\n        fib_num = num1 + num2\n        if is_prime(fib_num):\n            count += 1\n        num1, num2 = (num2, fib_num)\n    return num2"
      ]
    ],
    "HumanEval/40": [
      [
        0.9074764251708984,
        "    if not all((num > 0 for num in lst)):\n        return False\n    if target_sum <= 0:\n        return False\n    if len(lst) != len(set(lst)):\n        return False\n    lst.sort()\n    n = len(lst)\n    for i in range(n - 2):\n        left, right = (i + 1, n - 1)\n        while left < right:\n            if lst[i] + lst[left] + lst[right] == target_sum:\n                return True\n            elif lst[i] + lst[left] + lst[right] < target_sum:\n                left += 1\n            else:\n                right -= 1\n    return False"
      ],
      [
        0.9036989808082581,
        "    found = False\n    for i in range(0, len(arr) - 2):\n        for j in range(i + 1, len(arr) - 1):\n            for k in range(j + 1, len(arr)):\n                if arr[i] + arr[j] + arr[k] == 0:\n                    print('Found triplets ' + str(arr[i]) + ', ' + str(arr[j]) + ', ' + str(arr[k]))\n                    found = True\n    if found == False:\n        print('No Triplets found')"
      ],
      [
        0.9014959931373596,
        "    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            for k in range(j + 1, len(nums)):\n                if nums[i] + nums[j] + nums[k] == 0:\n                    return True\n    return False"
      ],
      [
        0.8997225761413574,
        "    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            for k in range(j + 1, len(arr)):\n                if arr[i] + arr[j] + arr[k] == 0:\n                    triplets.append((arr[i], arr[j], arr[k]))"
      ],
      [
        0.8997094631195068,
        "    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            for k in range(j + 1, len(arr)):\n                if arr[i] + arr[j] + arr[k] == 0:\n                    triplets.append([arr[i], arr[j], arr[k]])"
      ],
      [
        0.8996568918228149,
        "    for i in range(0, len(arr) - 2):\n        for j in range(i + 1, len(arr) - 1):\n            for k in range(j + 1, len(arr)):\n                if arr[i] + arr[j] + arr[k] == 0:\n                    print('Found triplets ' + str(arr[i]) + ', ' + str(arr[j]) + ', ' + str(arr[k]))\n                    found = True"
      ],
      [
        0.8989090323448181,
        "    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            for k in range(j + 1, len(nums)):\n                if nums[i] + nums[j] + nums[k] == 0:\n                    return True"
      ],
      [
        0.8988787531852722,
        "    triplets = []\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            for k in range(j + 1, len(numbers)):\n                if numbers[i] + numbers[j] + numbers[k] == 0:\n                    triplets.append([numbers[i], numbers[j], numbers[k]])\n    return triplets"
      ],
      [
        0.8986356258392334,
        "    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            for k in range(j + 1, len(numbers)):\n                if numbers[i] + numbers[j] + numbers[k] == 0:\n                    triplets.append([numbers[i], numbers[j], numbers[k]])"
      ],
      [
        0.8976364135742188,
        "    triplets = []\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            for k in range(j + 1, len(arr)):\n                if arr[i] + arr[j] + arr[k] == 0:\n                    triplets.append([arr[i], arr[j], arr[k]])\n    return triplets"
      ]
    ],
    "HumanEval/41": [
      [
        0.8887654542922974,
        "    left_cars = sorted(left_cars, key=lambda x: x[0])\n    right_cars = sorted(right_cars, key=lambda x: x[0])\n    total_collisions = []\n    for t in range(n + 1):\n        for i in range(len(left_cars)):\n            for j in range(i, len(right_cars)):\n                if check_collision(left_cars[i], right_cars[j], t):\n                    total_collisions.append((i, j, t))\n    return total_collisions"
      ],
      [
        0.8850287199020386,
        "    left_cars = [Car(i, *times) for i, times in enumerate(left_lane_autos)]\n    right_cars = [Car(i, *times) for i, times in enumerate(right_lane_autos)]\n    collisions = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if are_colliding(left_cars[i], left_cars[j], p) and are_colliding(left_cars[i], left_cars[k], p):\n                    collisions.append((i, j, k))\n                if are_colliding(right_cars[i], right_cars[j], p) and are_colliding(right_cars[i], right_cars[k], p):\n                    collisions.append((i, j, k))\n    if n > 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    for l in range(k + 1, n):\n                        if are_colliding(left_cars[i], left_cars[j], p) and are_colliding(left_cars[i], left_cars[k], p) and are_colliding(left_cars[i], left_cars[l], p):\n                            collisions.append((i, j, k, l))\n                        if are_colliding(right_cars[i], right_cars[j], p) and are_colliding(right_cars[i], right_cars[k], p) and are_colliding(right_cars[i], right_cars[l], p):\n                            collisions.append((i, j, k, l))\n    return collisions"
      ],
      [
        0.885015606880188,
        "    left_cars = [Car(i, *times) for i, times in enumerate(left_lane_autos)]\n    right_cars = [Car(i, *times) for i, times in enumerate(right_lane_autos)]\n    collisions = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if are_colliding(left_cars[i], left_cars[j], p) and are_colliding(left_cars[i], left_cars[k], p):\n                    collisions.append((i, j, k))\n                if are_colliding(right_cars[i], right_cars[j], p) and are_colliding(right_cars[i], right_cars[k], p):\n                    collisions.append((i, j, k))\n    if n > 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    for l in range(k + 1, n):\n                        if are_colliding(left_cars[i], left_cars[j], p) and are_colliding(left_cars[i], left_cars[k], p) and are_colliding(left_cars[i], left_cars[l], p):\n                            collisions.append((i, j, k, l))\n                        if are_colliding(right_cars[i], right_cars[j], p) and are_colliding(right_cars[i], right_cars[k], p) and are_colliding(right_cars[i], right_cars[l], p):\n                            collisions.append((i, j, k, l))\n    return collisions"
      ],
      [
        0.8848022222518921,
        "        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    for l in range(k + 1, n):\n                        if are_colliding(left_cars[i], left_cars[j], p) and are_colliding(left_cars[i], left_cars[k], p) and are_colliding(left_cars[i], left_cars[l], p):\n                            collisions.append((i, j, k, l))\n                        if are_colliding(right_cars[i], right_cars[j], p) and are_colliding(right_cars[i], right_cars[k], p) and are_colliding(right_cars[i], right_cars[l], p):\n                            collisions.append((i, j, k, l))"
      ],
      [
        0.8847989439964294,
        "        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    for l in range(k + 1, n):\n                        if are_colliding(left_cars[i], left_cars[j], p) and are_colliding(left_cars[i], left_cars[k], p) and are_colliding(left_cars[i], left_cars[l], p):\n                            collisions.append((i, j, k, l))\n                        if are_colliding(right_cars[i], right_cars[j], p) and are_colliding(right_cars[i], right_cars[k], p) and are_colliding(right_cars[i], right_cars[l], p):\n                            collisions.append((i, j, k, l))"
      ],
      [
        0.8837414979934692,
        "    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if are_colliding(left_cars[i], left_cars[j], p) and are_colliding(left_cars[i], left_cars[k], p):\n                    collisions.append((i, j, k))\n                if are_colliding(right_cars[i], right_cars[j], p) and are_colliding(right_cars[i], right_cars[k], p):\n                    collisions.append((i, j, k))"
      ],
      [
        0.8837326765060425,
        "    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if are_colliding(left_cars[i], left_cars[j], p) and are_colliding(left_cars[i], left_cars[k], p):\n                    collisions.append((i, j, k))\n                if are_colliding(right_cars[i], right_cars[j], p) and are_colliding(right_cars[i], right_cars[k], p):\n                    collisions.append((i, j, k))"
      ],
      [
        0.8833754062652588,
        "    i = 0\n    if n % 2 == 0:\n        i += 2\n    else:\n        i -= 1\n    return i * (n // 2)"
      ],
      [
        0.8827618360519409,
        "    matches = 0\n    while n > 1:\n        matches += n // 2\n        n = (n + 1) // 2\n    return matches"
      ],
      [
        0.8827585577964783,
        "    matches = 0\n    while n > 1:\n        matches += n // 2\n        n = (n + 1) // 2\n    return matches"
      ]
    ],
    "HumanEval/42": [
      [
        0.8941209316253662,
        "    new_list = []\n    for i in list_int:\n        new_list.append(i + 1)\n    return new_list"
      ],
      [
        0.8930460214614868,
        "    for i in range(len(lst)):\n        lst[i] += 1\n    return lst"
      ],
      [
        0.889524519443512,
        "    lst_new = []\n    for i in lst:\n        lst_new.append(i + 1)\n    return lst_new"
      ],
      [
        0.8885980248451233,
        "    for i in range(len(lst)):\n        lst[i] += 1"
      ],
      [
        0.8879813551902771,
        "    return [elem + 1 for elem in lst]"
      ],
      [
        0.8878774046897888,
        "    for i in range(len(num_list)):\n        num_list[i] += 1\n    return num_list"
      ],
      [
        0.8864058256149292,
        "    for i in list_int:\n        new_list.append(i + 1)"
      ],
      [
        0.8854478597640991,
        "    transformed_list = []\n    for value in input_list:\n        transformed_value = value + 1\n        transformed_list.append(transformed_value)\n    return transformed_list"
      ],
      [
        0.8845611214637756,
        "    for i in lst:\n        lst_new.append(i + 1)"
      ],
      [
        0.8820666670799255,
        "    for i in range(len(lst) - 1):\n        lst[i] += 1\n        lst[i + 1] += 1\n    return lst"
      ]
    ],
    "HumanEval/43": [
      [
        0.8999028205871582,
        "    pairs = []\n    nums = sorted(l)\n    check_set = set()\n    for i, num in enumerate(nums):\n        if -num in check_set:\n            pairs.append((-num, num))\n        else:\n            check_set.add(num)\n    return pairs"
      ],
      [
        0.8984917402267456,
        "    pairs = set()\n    count = 0\n    for num in nums:\n        if -num in pairs:\n            pairs.remove(-num)\n            count += 1\n        else:\n            pairs.add(num)\n    return count == 2"
      ],
      [
        0.8979940414428711,
        "    if len(l) % 2 == 0:\n        s = sum(l)\n        if lower_bound <= s <= upper_bound:\n            return True\n        else:\n            return False\n    else:\n        return False"
      ],
      [
        0.8979940414428711,
        "    if len(l) % 2 == 0:\n        s = sum(l)\n        if lower_bound <= s <= upper_bound:\n            return True\n        else:\n            return False\n    else:\n        return False"
      ],
      [
        0.8979668617248535,
        "    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] + arr[j] == 0:\n                return True\n    return False"
      ],
      [
        0.8970838785171509,
        "    if len(l) % 2 != 0:\n        return False\n    total_sum = sum(l)\n    if lower_bound <= total_sum <= upper_bound:\n        return True\n    else:\n        return False"
      ],
      [
        0.8967243432998657,
        "    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] + arr[j] == 0:\n                return True"
      ]
    ],
    "HumanEval/44": [
      [
        0.9275479912757874,
        "    if not isinstance(x, str):\n        raise ValueError('Input x must be a string.')\n    if not isinstance(base, int):\n        raise ValueError('Input base must be an integer.')\n    if base not in (8, 10, 16):\n        raise ValueError('Base must be 8 (octal), 10 (decimal), or 16 (hexadecimal).')\n    binary = bin(int(x, base))[2:]\n    return binary"
      ],
      [
        0.9207617044448853,
        "    if base == 8:\n        decimal = int(x, 8)\n    elif base == 10:\n        decimal = int(x)\n    elif base == 16:\n        decimal = int(x, 16)\n    else:\n        raise ValueError('Invalid base, base must be in [8, 10, 16]')\n    binary = bin(decimal).replace('0b', '')\n    return binary"
      ],
      [
        0.9193068146705627,
        "    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
      ],
      [
        0.9187434911727905,
        "    convert_string = string.digits + string.ascii_lowercase\n    if num < base:\n        return convert_string[num]\n    else:\n        return int_to_string(num // base, base) + convert_string[num % base]"
      ],
      [
        0.9184775948524475,
        "    if base == 10:\n        return str(num)\n    elif base == 2:\n        return bin(num)\n    elif base == 8:\n        return oct(num)\n    elif base == 16:\n        return hex(num)\n    else:\n        alphabet = string.digits + string.ascii_lowercase\n        base_n = []\n        while num:\n            num, rem = divmod(num, base)\n            base_n.append(alphabet[rem])\n        return ''.join(reversed(base_n))"
      ],
      [
        0.9184775948524475,
        "    if base == 10:\n        return str(num)\n    elif base == 2:\n        return bin(num)\n    elif base == 8:\n        return oct(num)\n    elif base == 16:\n        return hex(num)\n    else:\n        alphabet = string.digits + string.ascii_lowercase\n        base_n = []\n        while num:\n            num, rem = divmod(num, base)\n            base_n.append(alphabet[rem])\n        return ''.join(reversed(base_n))"
      ],
      [
        0.9163768291473389,
        "    x = int(x, base)\n    binary = bin(x)\n    return binary[2:]"
      ],
      [
        0.9163603782653809,
        "    x = int(x, base)\n    binary = bin(x)\n    return binary[2:]"
      ],
      [
        0.9157972931861877,
        "    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
      ],
      [
        0.9151265025138855,
        "    if base < 2 or base > 10:\n        return -1\n    digits = []\n    while num > 0:\n        digits.append(str(num % base))\n        num //= base\n    if base == 2:\n        prefix = '0b'\n    elif base == 8:\n        prefix = '0o'\n    else:\n        prefix = ''\n    return '{}{}'.format(prefix, ''.join(digits[::-1]))"
      ]
    ],
    "HumanEval/45": [
      [
        0.9036229252815247,
        "    assert tri_area(6, 4) == 12"
      ],
      [
        0.9036173224449158,
        "    assert tri_area(6, 4) == 12"
      ]
    ],
    "HumanEval/46": [
      [
        0.9089230298995972,
        "    fibfib_array = [0, 0, 1, 1] + [0] * (n - 3)\n    for i in range(4, n + 1):\n        if i <= 1000:\n            fibfib_array[i] = fibfib_array[i - 1] + fibfib_array[i - 2] + fibfib_array[i - 3] + fibfib_array[i - 4]\n        else:\n            fibfib_array[i] = sum(fibfib_array[i - 1000:i])\n    return fibfib_array[n]"
      ],
      [
        0.9070357084274292,
        "    if not isinstance(n, int) or n < 0:\n        raise ValueError('The parameter n must be a non-negative integer')\n    if not isinstance(offset, int) or offset < 0:\n        raise ValueError('The offset must be a non-negative integer')\n    fib_seq = [None] * (n + offset + 1)\n    for i in range(offset):\n        fib_seq[i] = 0\n    fib_seq[offset:offset + 6] = [0, 1, 1, 2, 4, 7] + [None] * max(0, n - 6)\n    for i in range(offset + 6, n + offset + 1):\n        fib_seq[i] = fib_seq[i - 1] + fib_seq[i - 3] + fib_seq[i - 4] + fib_seq[i - 6]\n    return fib_seq[n + offset]"
      ],
      [
        0.9070250391960144,
        "    if not isinstance(n, int) or n < 0:\n        raise ValueError('The parameter n must be a non-negative integer')\n    if not isinstance(offset, int) or offset < 0:\n        raise ValueError('The offset must be a non-negative integer')\n    fib_seq = [None] * (n + offset + 1)\n    for i in range(offset):\n        fib_seq[i] = 0\n    fib_seq[offset:offset + 6] = [0, 1, 1, 2, 4, 7] + [None] * max(0, n - 6)\n    for i in range(offset + 6, n + offset + 1):\n        fib_seq[i] = fib_seq[i - 1] + fib_seq[i - 3] + fib_seq[i - 4] + fib_seq[i - 6]\n    return fib_seq[n + offset]"
      ],
      [
        0.9038613438606262,
        "    elif n == 0:\n        result = offset\n    elif n == 1:\n        result = 1 + offset\n    elif n == 2:\n        result = 1 + 2 * offset\n    elif n == 3:\n        result = 2 + 4 * offset\n    else:\n        result = fib_modified_with_offset(n - 1, offset, memo) + fib_modified_with_offset(n - 3, offset, memo) + fib_modified_with_offset(n - 4, offset, memo)"
      ],
      [
        0.903833270072937,
        "    elif n == 0:\n        result = offset\n    elif n == 1:\n        result = 1 + offset\n    elif n == 2:\n        result = 1 + 2 * offset\n    elif n == 3:\n        result = 2 + 4 * offset\n    else:\n        result = fib_modified_with_offset(n - 1, offset, memo) + fib_modified_with_offset(n - 3, offset, memo) + fib_modified_with_offset(n - 4, offset, memo)"
      ],
      [
        0.9033626317977905,
        "    elif n == 3:\n        result = 2 + 4 * offset\n    else:\n        result = fib_modified_with_offset(n - 1, offset, memo) + fib_modified_with_offset(n - 3, offset, memo) + fib_modified_with_offset(n - 4, offset, memo)"
      ],
      [
        0.9033549427986145,
        "    elif n == 3:\n        result = 2 + 4 * offset\n    else:\n        result = fib_modified_with_offset(n - 1, offset, memo) + fib_modified_with_offset(n - 3, offset, memo) + fib_modified_with_offset(n - 4, offset, memo)"
      ],
      [
        0.9028928279876709,
        "    elif n == 2:\n        result = 1 + 2 * offset\n    elif n == 3:\n        result = 2 + 4 * offset\n    else:\n        result = fib_modified_with_offset(n - 1, offset, memo) + fib_modified_with_offset(n - 3, offset, memo) + fib_modified_with_offset(n - 4, offset, memo)"
      ],
      [
        0.9028732776641846,
        "    elif n == 2:\n        result = 1 + 2 * offset\n    elif n == 3:\n        result = 2 + 4 * offset\n    else:\n        result = fib_modified_with_offset(n - 1, offset, memo) + fib_modified_with_offset(n - 3, offset, memo) + fib_modified_with_offset(n - 4, offset, memo)"
      ],
      [
        0.9023526310920715,
        "    elif n == 1:\n        result = 1 + offset\n    elif n == 2:\n        result = 1 + 2 * offset\n    elif n == 3:\n        result = 2 + 4 * offset\n    else:\n        result = fib_modified_with_offset(n - 1, offset, memo) + fib_modified_with_offset(n - 3, offset, memo) + fib_modified_with_offset(n - 4, offset, memo)"
      ]
    ],
    "HumanEval/47": [
      [
        0.9396935701370239,
        "    if len(l) % 2 == 0:\n        median = (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2\n    else:\n        median = l[len(l) // 2]"
      ],
      [
        0.9379260540008545,
        "    sorted_l = sorted(l)\n    len_l = len(l)\n    if len_l % 2 == 0:\n        median = (sorted_l[len_l // 2 - 1] + sorted_l[len_l // 2]) / 2\n    else:\n        median = sorted_l[(len_l - 1) // 2]\n    return median"
      ]
    ],
    "HumanEval/48": [],
    "HumanEval/49": [
      [
        0.9084287285804749,
        "    mod = 10 ** 9 + 7\n    x = (1 << p) - 1\n    y = (1 << p) - 2\n    z = pow(y, x - 1, mod)\n    return x * z % mod"
      ],
      [
        0.9083428382873535,
        "    mod = 10 ** 9 + 7\n    x = (1 << p) - 1\n    y = (1 << p) - 2\n    z = pow(y, x - 1, mod)\n    return x * z % mod"
      ],
      [
        0.903135359287262,
        "    return power(n, p - 2, p)"
      ],
      [
        0.8999300003051758,
        "    MOD = 10 ** 9 + 7\n    prod = 1\n    a = (1 << p) - 2\n    b = ((1 << p) - 1) % MOD\n    while a > 0:\n        if a % 2:\n            prod = prod * b % MOD\n        b = b * b % MOD\n        a //= 2\n    return prod"
      ],
      [
        0.899915337562561,
        "    MOD = 10 ** 9 + 7\n    prod = 1\n    a = (1 << p) - 2\n    b = ((1 << p) - 1) % MOD\n    while a > 0:\n        if a % 2:\n            prod = prod * b % MOD\n        b = b * b % MOD\n        a //= 2\n    return prod"
      ],
      [
        0.8935517072677612,
        "    if n == 0:\n        return 2 % m\n    elif n == 1:\n        return 1 % m"
      ],
      [
        0.8934813141822815,
        "    if n == 0:\n        return 2 % m\n    elif n == 1:\n        return 1 % m"
      ],
      [
        0.8925497531890869,
        "    if power < 0 or (modulo is not None and modulo <= 0):\n        raise ValueError('Power and modulo, if provided, should be positive.')\n    fact = 1\n    for i in range(1, n + 1):\n        fact = (fact * i) ** power\n        if modulo:\n            fact %= modulo\n    return fact"
      ],
      [
        0.8924601674079895,
        "    if p == 0:\n        return 1\n    result = 1\n    abs_p = abs(p)\n    while abs_p > 0:\n        if abs_p % 2 == 1:\n            result *= base\n        base *= base\n        abs_p //= 2\n    return result if p > 0 else 1 / result"
      ],
      [
        0.8924557566642761,
        "    result = 1\n    base = base % modulus\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = result * base % modulus\n        exponent = exponent >> 1\n        base = base * base % modulus\n    return result"
      ]
    ],
    "HumanEval/50": [
      [
        0.9387513995170593,
        "    decoded = ''\n    for c in s:\n        decoded += chr(ord(c) - 5)\n    return decoded"
      ],
      [
        0.9379106760025024,
        "    encoded = ''\n    for c in s:\n        encoded += chr(ord(c) + 5)\n    return encoded"
      ],
      [
        0.9361056089401245,
        "    shift_upper = 5\n    shift_lower = 8\n    return ''.join([chr((ord(char) - ord('A') + shift_upper) % 26 + ord('A')) if char.isupper() else chr((ord(char) - ord('a') + shift_lower) % 26 + ord('a')) if char.islower() else char for char in s])"
      ],
      [
        0.9341468214988708,
        "    decoded_string = ''\n    for char in encoded_string:\n        if char.isalpha():\n            shift_amount = 65 if char.isupper() else 97\n            decoded_char = chr((ord(char) - shift_amount - shift) % 26 + shift_amount)\n            decoded_string += decoded_char\n        else:\n            decoded_string += char\n    return decoded_string"
      ],
      [
        0.9314632415771484,
        "    upper = (65, 91)\n    lower = (97, 123)\n    result = ''\n    text = text[::-1]\n    shift = -5\n    for char in text:\n        ascii_val = ord(char)\n        if upper[0] <= ascii_val <= upper[1]:\n            result += chr((ascii_val - upper[0] + shift) % 26 + upper[0])\n        elif lower[0] <= ascii_val <= lower[1]:\n            result += chr((ascii_val - lower[0] + shift) % 26 + lower[0])\n        else:\n            result += char\n    return result"
      ],
      [
        0.9312594532966614,
        "    encoded_string = ''\n    for character in input_string:\n        if character.isalpha():\n            char_code = ord(character.lower()) if character.islower() else ord(character.upper())\n            char_code += shift\n            if character.islower() and char_code > ord('z'):\n                char_code -= 26\n            elif char_code > ord('Z'):\n                char_code -= 26\n            shifted_character = chr(char_code) if character.islower() else chr(char_code).upper()\n            encoded_string += shifted_character\n        else:\n            encoded_string += character\n    return encoded_string"
      ],
      [
        0.9300140738487244,
        "    encrypted_msg = ''\n    for c in msg:\n        encrypted_msg += chr(ord(c) + 5)\n    return encrypted_msg"
      ],
      [
        0.9296896457672119,
        "    encoded_string = ''\n    for char in string:\n        if char.isalpha():\n            if char.isupper():\n                base = ord('A')\n            else:\n                base = ord('a')\n            encoded_char = chr(base + (ord(char) - base + shift) % 26)\n            encoded_string += encoded_char\n        else:\n            encoded_string += char\n    return encoded_string"
      ],
      [
        0.9290949106216431,
        "    decoded_message = ''\n    for char in s:\n        if char.isalpha():\n            shift_amount = 65 if char.isupper() else 97\n            decoded_char = chr((ord(char) - shift_amount - shift) % 26 + shift_amount)\n            decoded_message += decoded_char\n        else:\n            decoded_message += char\n    return decoded_message"
      ],
      [
        0.928636908531189,
        "    encoded = ''\n    for i in range(len(s)):\n        shift = mask[i % len(mask)]\n        encoded += chr((ord(s[i]) - 97 + shift) % 26 + 97)\n    return encoded"
      ]
    ],
    "HumanEval/51": [
      [
        0.9380587339401245,
        "    no_vowels = ''\n    for character in text:\n        if character not in 'aeiouAEIOU':\n            no_vowels += character\n    return no_vowels"
      ],
      [
        0.9379623532295227,
        "    vowels = ['a', 'e', 'i', 'o', 'u']\n    no_vowels = ''\n    for letter in text:\n        if letter.lower() not in vowels:\n            no_vowels += letter\n    return no_vowels"
      ]
    ],
    "HumanEval/52": [
      [
        0.9341239333152771,
        "    if t <= 0:\n        raise ValueError('Threshold must be a positive integer')\n    if not l:\n        raise ValueError('Input list cannot be empty')\n    return all((i < t for i in l))"
      ],
      [
        0.9065929651260376,
        "    for i in l:\n        if i >= t:\n            return False\n    return True"
      ],
      [
        0.904969334602356,
        "    for item in l:\n        if isinstance(item, int) and item > t:\n            return False\n    return True"
      ],
      [
        0.9043049812316895,
        "    for num in l:\n        if num > t:\n            return False\n    return True"
      ],
      [
        0.9002653360366821,
        "    for i in l:\n        if isinstance(i, int) and i > t:\n            return False\n    return True"
      ],
      [
        0.8996913433074951,
        "    for i in l:\n        if i >= t:\n            return False"
      ],
      [
        0.8988613486289978,
        "    for item in l:\n        if isinstance(item, int) and item > t:\n            return False"
      ],
      [
        0.8963354825973511,
        "    for num in l:\n        if num > t:\n            return False"
      ],
      [
        0.8951560258865356,
        "    for element in l:\n        if type(element) is int:\n            if element > t:\n                return False\n    return True"
      ],
      [
        0.8947467803955078,
        "    for i in l:\n        if isinstance(i, int) and i > t:\n            return False"
      ]
    ],
    "HumanEval/53": [],
    "HumanEval/54": [
      [
        0.9180272221565247,
        "    for i in range(len(chars1)):\n        if chars1[i] != chars2[i]:\n            return False"
      ],
      [
        0.9159973859786987,
        "    s1 = ''.join((ch.lower() for ch in s1 if ch.isalnum()))\n    s2 = ''.join((ch.lower() for ch in s2 if ch.isalnum()))\n    char_count = {}\n    for ch in s1:\n        char_count[ch] = char_count.get(ch, 0) + 1\n    for ch in s2:\n        char_count[ch] = char_count.get(ch, 0) - 1\n    return all((count == 0 for count in char_count.values()))"
      ],
      [
        0.9143089056015015,
        "    ch_freq1 = count_char_freq(word1)\n    ch_freq2 = count_char_freq(word2)\n    if ch_freq1 == ch_freq2:\n        return True\n    return False"
      ],
      [
        0.9132440686225891,
        "    if len(s1_chars) != len(s2_chars):\n        return False"
      ],
      [
        0.9113649129867554,
        "    counter1, counter2 = (Counter(word1), Counter(word2))\n    return set(word1) == set(word2) and sorted(counter1.values()) == sorted(counter2.values())"
      ],
      [
        0.9112029075622559,
        "    if len(s1) != len(s2):\n        return False\n    char_counts1 = count_chars(s1)\n    char_counts2 = count_chars(s2)\n    if len(char_counts1) != len(char_counts2):\n        return False\n    for char, count in char_counts1.items():\n        if char not in char_counts2 or count != char_counts2[char]:\n            return False\n    return True"
      ],
      [
        0.9109646677970886,
        "    for char, count in char_counts1.items():\n        if char not in char_counts2 or count != char_counts2[char]:\n            return False"
      ],
      [
        0.9100642204284668,
        "    is_same = False\n    if len(str1) == len(str2):\n        str1_set = set(str1)\n        str2_set = set(str2)\n        if str1_set == str2_set:\n            is_same = True\n    return is_same"
      ],
      [
        0.9100067019462585,
        "    s1 = ''.join(filter(str.isalpha, s1.lower()))\n    s2 = ''.join(filter(str.isalpha, s2.lower()))\n    return sorted(s1) == sorted(s2)"
      ],
      [
        0.9099527597427368,
        "    s1 = ''.join(sorted(s1))\n    s2 = ''.join(sorted(s2))\n    return s1 == s2"
      ]
    ],
    "HumanEval/55": [],
    "HumanEval/56": [
      [
        0.9271270632743835,
        "    s = []\n    for bracket in brackets:\n        if bracket == '<':\n            s.append('<')\n        elif not s:\n            return False\n        else:\n            s.pop()\n    if not s:\n        return True\n    else:\n        return False"
      ],
      [
        0.9173280596733093,
        "    for bracket in brackets:\n        if bracket == '<':\n            s.append('<')\n        elif not s:\n            return False\n        else:\n            s.pop()"
      ],
      [
        0.9123591780662537,
        "        if bracket == '<':\n            s.append('<')\n        elif not s:\n            return False\n        else:\n            s.pop()"
      ],
      [
        0.9119085669517517,
        "    stack = []\n    opening_brackets = {'(', '{', '[', '<'}\n    closing_brackets = {')', '}', ']', '>'}\n    bracket_pairs = {'(': ')', '{': '}', '[': ']', '<': '>'}\n    for char in expression:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack:\n                return False\n            last_opening_bracket = stack.pop()\n            if bracket_pairs[last_opening_bracket] != char:\n                return False\n    return len(stack) == 0"
      ],
      [
        0.9078448414802551,
        "    for i, char in enumerate(expression):\n        if char in '([{<':\n            stack.append(char)\n            if char == '<':\n                angle_brackets_stack.append('<')\n                angle_brackets_positions.append(i)\n        elif char in ')]}>':\n            if not stack:\n                return False\n            top = stack.pop()\n            if char == ')':\n                if top != '(':\n                    return False\n            elif char == ']':\n                if top != '[':\n                    return False\n            elif char == '}':\n                if top != '{':\n                    return False\n            elif char == '>':\n                if top != '<':\n                    return False\n                angle_brackets_stack.pop()\n                angle_brackets_positions.pop()"
      ],
      [
        0.9073199033737183,
        "        if char in '([{<':\n            stack.append(char)\n            if char == '<':\n                angle_brackets_stack.append('<')\n                angle_brackets_positions.append(i)\n        elif char in ')]}>':\n            if not stack:\n                return False\n            top = stack.pop()\n            if char == ')':\n                if top != '(':\n                    return False\n            elif char == ']':\n                if top != '[':\n                    return False\n            elif char == '}':\n                if top != '{':\n                    return False\n            elif char == '>':\n                if top != '<':\n                    return False\n                angle_brackets_stack.pop()\n                angle_brackets_positions.pop()"
      ],
      [
        0.9056227207183838,
        "    stack = []\n    angle_brackets_stack = []\n    angle_brackets_positions = []\n    for i, char in enumerate(expression):\n        if char in '([{<':\n            stack.append(char)\n            if char == '<':\n                angle_brackets_stack.append('<')\n                angle_brackets_positions.append(i)\n        elif char in ')]}>':\n            if not stack:\n                return False\n            top = stack.pop()\n            if char == ')':\n                if top != '(':\n                    return False\n            elif char == ']':\n                if top != '[':\n                    return False\n            elif char == '}':\n                if top != '{':\n                    return False\n            elif char == '>':\n                if top != '<':\n                    return False\n                angle_brackets_stack.pop()\n                angle_brackets_positions.pop()\n    if stack or angle_brackets_stack:\n        return False\n    if angle_brackets_positions:\n        return angle_brackets_positions[0]\n    return True"
      ],
      [
        0.9046058058738708,
        "            elif char == '>':\n                if top != '<':\n                    return False\n                angle_brackets_stack.pop()\n                angle_brackets_positions.pop()"
      ],
      [
        0.9036117792129517,
        "    stack = []\n    bracket_pairs = {'(': ')', '[': ']', '{': '}', '<': '>', \"'\": \"'\"}\n    for char in input_string:\n        if char in bracket_pairs:\n            stack.append(char)\n        elif char in bracket_pairs.values():\n            if not stack or bracket_pairs[stack.pop()] != char:\n                return False\n    return not stack"
      ],
      [
        0.9032183885574341,
        "    stack = []\n    openers_to_closers = {'(': ')', '[': ']', '{': '}', '<': '>'}\n    closers = set(openers_to_closers.values())\n    for char in s:\n        if char in openers_to_closers:\n            stack.append(char)\n        elif char in closers:\n            if not stack:\n                return False\n            else:\n                last_unclosed_opener = stack.pop()\n                if not char == openers_to_closers[last_unclosed_opener]:\n                    return False\n    return stack == []"
      ]
    ],
    "HumanEval/57": [
      [
        0.9249036312103271,
        "    if is_nested:\n        return all((monotonic(sub_list, strict) for sub_list in l))\n    elif strict:\n        return all((i < j for i, j in zip(l, l[1:]))) or all((i > j for i, j in zip(l, l[1:])))\n    else:\n        return all((i <= j for i, j in zip(l, l[1:]))) or all((i >= j for i, j in zip(l, l[1:])))"
      ],
      [
        0.9248995780944824,
        "    if is_nested:\n        return all((monotonic(sub_list, strict) for sub_list in l))\n    elif strict:\n        return all((i < j for i, j in zip(l, l[1:]))) or all((i > j for i, j in zip(l, l[1:])))\n    else:\n        return all((i <= j for i, j in zip(l, l[1:]))) or all((i >= j for i, j in zip(l, l[1:])))"
      ],
      [
        0.9227299690246582,
        "    try:\n        is_nested = any((isinstance(i, list) for i in l))\n    except TypeError:\n        print('Input value is not iterable')\n        return False\n    if is_nested:\n        return all((monotonic(sub_list, strict) for sub_list in l))\n    elif strict:\n        return all((i < j for i, j in zip(l, l[1:]))) or all((i > j for i, j in zip(l, l[1:])))\n    else:\n        return all((i <= j for i, j in zip(l, l[1:]))) or all((i >= j for i, j in zip(l, l[1:])))"
      ],
      [
        0.9226861000061035,
        "    try:\n        is_nested = any((isinstance(i, list) for i in l))\n    except TypeError:\n        print('Input value is not iterable')\n        return False\n    if is_nested:\n        return all((monotonic(sub_list, strict) for sub_list in l))\n    elif strict:\n        return all((i < j for i, j in zip(l, l[1:]))) or all((i > j for i, j in zip(l, l[1:])))\n    else:\n        return all((i <= j for i, j in zip(l, l[1:]))) or all((i >= j for i, j in zip(l, l[1:])))"
      ],
      [
        0.9198437333106995,
        "    is_monotonic = True\n    for i in range(len(list) - 1):\n        if list[i] > list[i + 1]:\n            is_monotonic = False\n    return is_monotonic"
      ],
      [
        0.9195631742477417,
        "    increasing = decreasing = True\n    for i in range(len(l) - 1):\n        if strict:\n            if l[i] > l[i + 1]:\n                increasing = False\n            elif l[i] < l[i + 1]:\n                decreasing = False\n        elif l[i] >= l[i + 1]:\n            increasing = False\n        elif l[i] <= l[i + 1]:\n            decreasing = False\n        if not increasing and (not decreasing):\n            return False\n    return True"
      ],
      [
        0.9187198877334595,
        "    if len(l) < 2:\n        return True\n    if strict:\n        diff = [l[i + 1] - l[i] for i in range(len(l) - 1)]\n        if all((i > 0 for i in diff)):\n            return True\n        if all((i < 0 for i in diff)):\n            return True\n        return False\n    else:\n        diff = [l[i + 1] - l[i] for i in range(len(l) - 1)]\n        if all((i >= 0 for i in diff)):\n            return True\n        if all((i <= 0 for i in diff)):\n            return True\n        return False"
      ],
      [
        0.9185817241668701,
        "    if strict:\n        diff = [l[i + 1] - l[i] for i in range(len(l) - 1)]\n        if all((i > 0 for i in diff)):\n            return True\n        if all((i < 0 for i in diff)):\n            return True\n        return False\n    else:\n        diff = [l[i + 1] - l[i] for i in range(len(l) - 1)]\n        if all((i >= 0 for i in diff)):\n            return True\n        if all((i <= 0 for i in diff)):\n            return True\n        return False"
      ],
      [
        0.9184439778327942,
        "    increasing = decreasing = True\n    for i in range(len(l) - 1):\n        if strict:\n            if l[i] <= l[i + 1]:\n                increasing = False\n            elif l[i] >= l[i + 1]:\n                decreasing = False\n        elif l[i] < l[i + 1]:\n            increasing = False\n        elif l[i] > l[i + 1]:\n            decreasing = False\n    if not increasing and (not decreasing):\n        return False\n    return True"
      ],
      [
        0.9173667430877686,
        "    for i in range(len(l) - 1):\n        if strict:\n            if l[i] > l[i + 1]:\n                increasing = False\n            elif l[i] < l[i + 1]:\n                decreasing = False\n        elif l[i] >= l[i + 1]:\n            increasing = False\n        elif l[i] <= l[i + 1]:\n            decreasing = False\n        if not increasing and (not decreasing):\n            return False"
      ]
    ],
    "HumanEval/58": [
      [
        0.9372702836990356,
        "    common = list(set(l1) & set(l2))\n    common.sort()\n    return common"
      ],
      [
        0.9364875555038452,
        "    common = set(l1) & set(l2)\n    return sorted(list(common))"
      ],
      [
        0.9341560006141663,
        "    common = []\n    sorted1 = quick_sort(list1)\n    sorted2 = quick_sort(list2)\n    i = j = 0\n    while i < len(sorted1) and j < len(sorted2):\n        if sorted1[i] == sorted2[j]:\n            if len(common) == 0 or common[-1] != sorted1[i]:\n                common.append(sorted1[i])\n            i += 1\n            j += 1\n        elif sorted1[i] < sorted2[j]:\n            i += 1\n        else:\n            j += 1\n    return common"
      ],
      [
        0.9341472387313843,
        "    common = []\n    sorted1 = quick_sort(list1)\n    sorted2 = quick_sort(list2)\n    i = j = 0\n    while i < len(sorted1) and j < len(sorted2):\n        if sorted1[i] == sorted2[j]:\n            if len(common) == 0 or common[-1] != sorted1[i]:\n                common.append(sorted1[i])\n            i += 1\n            j += 1\n        elif sorted1[i] < sorted2[j]:\n            i += 1\n        else:\n            j += 1\n    return common"
      ],
      [
        0.934141993522644,
        "    common = []\n    sorted1 = quick_sort(list1)\n    sorted2 = quick_sort(list2)\n    i = j = 0\n    while i < len(sorted1) and j < len(sorted2):\n        if sorted1[i] == sorted2[j]:\n            if len(common) == 0 or common[-1] != sorted1[i]:\n                common.append(sorted1[i])\n            i += 1\n            j += 1\n        elif sorted1[i] < sorted2[j]:\n            i += 1\n        else:\n            j += 1\n    return common"
      ],
      [
        0.9339771270751953,
        "    dict_list1 = {i: True for i in l1}\n    common_elements = {i: True for i in l2 if i in dict_list1}\n    return sorted(common_elements.keys())"
      ],
      [
        0.9321593046188354,
        "    common_elements = []\n    for element in list1:\n        if element in list2 and element not in common_elements:\n            common_elements.append(element)\n    return sorted(common_elements)"
      ],
      [
        0.930749773979187,
        "    sorted1 = merge_sort(list1)\n    sorted2 = merge_sort(list2)\n    common = []\n    i, j = (0, 0)\n    while i < len(sorted1) and j < len(sorted2):\n        if sorted1[i] == sorted2[j]:\n            if not common or common[-1] != sorted1[i]:\n                common.append(sorted1[i])\n            i += 1\n            j += 1\n        elif sorted1[i] < sorted2[j]:\n            i += 1\n        else:\n            j += 1\n    return common"
      ],
      [
        0.9304750561714172,
        "    sorted1 = merge_sort(list1)\n    sorted2 = merge_sort(list2)\n    common = []\n    i, j = (0, 0)\n    while i < len(sorted1) and j < len(sorted2):\n        if sorted1[i] == sorted2[j]:\n            if not (common and common[-1] == sorted1[i]):\n                common.append(sorted1[i])\n            i += 1\n            j += 1\n        elif sorted1[i] < sorted2[j]:\n            i += 1\n        else:\n            j += 1\n    return common"
      ],
      [
        0.930425763130188,
        "    common_elements = [i for i in l1 if i in l2]\n    unique_common_elements = remove_duplicates(common_elements)\n    sorted_unique_common_elements = merge_sort(unique_common_elements)\n    return sorted_unique_common_elements"
      ]
    ],
    "HumanEval/59": [
      [
        0.9338700771331787,
        "    if n <= 1:\n        return 1\n    largest_prime_factor = 1\n    for i in range(2, n + 1):\n        if n % i == 0:\n            largest_prime_factor = i\n            break\n    return max(largest_prime_factor, largest_prime_factor(int(n / i)))"
      ],
      [
        0.9336888790130615,
        "    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2"
      ],
      [
        0.9336816072463989,
        "    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2"
      ],
      [
        0.9328658580780029,
        "    if n < 2:\n        return 0\n    while n % 2 == 0:\n        n = n // 2\n    largest_factor = 1\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n    if n > 2:\n        largest_factor = n\n    return largest_factor"
      ],
      [
        0.9325284957885742,
        "    largest_factor = 1\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    i = 3\n    while n != 1:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 2\n    return largest_factor"
      ],
      [
        0.9305192232131958,
        "    if n == 0:\n        raise ValueError('The prime factor of zero is undefined.')\n    n = abs(n)\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return max(factors)"
      ],
      [
        0.9301663041114807,
        "    while n % 2 == 0:\n        largest_factor = 2\n        n = n / 2"
      ],
      [
        0.9294538497924805,
        "    if not isinstance(n, int) or n < 1:\n        raise ValueError('Invalid input. Please provide a positive integer.')\n    if n == 1:\n        return 1\n    largest_factor = 1\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    p = 3\n    while p <= math.isqrt(n):\n        if n % p == 0:\n            largest_factor = p\n            n //= p\n        else:\n            p += 2\n    if n > 2:\n        largest_factor = n\n    return largest_factor"
      ],
      [
        0.9294328689575195,
        "    elif n % divisor == 0:\n        return find_largest_prime(n // divisor, divisor)\n    else:\n        return find_largest_prime(n, divisor + 1)"
      ],
      [
        0.9294247031211853,
        "    elif n % divisor == 0:\n        return find_largest_prime(n // divisor, divisor)\n    else:\n        return find_largest_prime(n, divisor + 1)"
      ]
    ],
    "HumanEval/60": [
      [
        0.9309861660003662,
        "    if n == 1:\n        return 1\n    else:\n        return n + sum_to_n(n - 1)"
      ],
      [
        0.9309861660003662,
        "    if n == 1:\n        return 1\n    else:\n        return n + sum_to_n(n - 1)"
      ]
    ],
    "HumanEval/61": [
      [
        0.9223072528839111,
        "    stack = []\n    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        elif bracket == ')':\n            if not stack or stack.pop() != '(':\n                return False\n    return not stack"
      ],
      [
        0.9173069000244141,
        "    for char in s:\n        if char == '(':\n            open_brackets += 1\n        elif char == ')':\n            if open_brackets == 0:\n                return False\n            open_brackets -= 1"
      ],
      [
        0.9161421656608582,
        "    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        elif bracket == ')':\n            if not stack or stack.pop() != '(':\n                return False"
      ],
      [
        0.9142302870750427,
        "    for char in string:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack:\n                return False\n            opening_bracket = stack.pop()\n            if opening_brackets.index(opening_bracket) != closing_brackets.index(char):\n                return False"
      ],
      [
        0.9126038551330566,
        "        if char == '(':\n            open_brackets += 1\n        elif char == ')':\n            if open_brackets == 0:\n                return False\n            open_brackets -= 1"
      ],
      [
        0.9117569923400879,
        "    for char in string:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if len(stack) == 0 or bracket_map[stack[-1]] != char:\n                return False\n            stack.pop()"
      ],
      [
        0.9117041826248169,
        "    open_brackets = 0\n    for char in s:\n        if char == '(':\n            open_brackets += 1\n        elif char == ')':\n            if open_brackets == 0:\n                return False\n            open_brackets -= 1\n    return open_brackets == 0"
      ],
      [
        0.910494863986969,
        "    for char in expr:\n        if char == '(':\n            open_brackets += 1\n        elif char == ')':\n            open_brackets -= 1\n        if open_brackets < 0:\n            return False"
      ],
      [
        0.9101969599723816,
        "    for i, char in enumerate(string):\n        if char in brackets:\n            stack.append((char, i))\n        elif len(stack) == 0 or brackets[stack.pop()[0]] != char:\n            return (False, 'Position ' + str(i))"
      ],
      [
        0.9101179838180542,
        "    for char in input_string:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False"
      ]
    ],
    "HumanEval/62": [
      [
        0.927435040473938,
        "    p = np.poly1d(xs[::-1])\n    derivative = p.deriv().c[::-1]\n    integral = p.integ().c[::-1]\n    integral[0] += C\n    derivative = list(filter(lambda a: a != 0, derivative))\n    integral = list(filter(lambda a: a != 0, integral))\n    return (derivative, integral)"
      ],
      [
        0.9247652292251587,
        "    derivative = []\n    integral = [C]\n    for i in range(len(xs)):\n        if i != 0:\n            derivative.append(i * xs[i])\n        if i + 1 != 0:\n            integral.append(xs[i] / (i + 1))\n    while integral[-1] == 0:\n        integral = integral[:-1]\n    while derivative and derivative[-1] == 0:\n        derivative = derivative[:-1]\n    return (derivative, integral)"
      ],
      [
        0.9247633814811707,
        "    derivative = []\n    integral = [C]\n    for i in range(len(xs)):\n        if i != 0:\n            derivative.append(i * xs[i])\n        if i + 1 != 0:\n            integral.append(xs[i] / (i + 1))\n    while integral[-1] == 0:\n        integral = integral[:-1]\n    while derivative and derivative[-1] == 0:\n        derivative = derivative[:-1]\n    return (derivative, integral)"
      ],
      [
        0.9245197176933289,
        "    for i in range(len(xs)):\n        if i != 0:\n            derivative.append(i * xs[i])\n        if i + 1 != 0:\n            integral.append(xs[i] / (i + 1))"
      ],
      [
        0.9245103001594543,
        "    for i in range(len(xs)):\n        if i != 0:\n            derivative.append(i * xs[i])\n        if i + 1 != 0:\n            integral.append(xs[i] / (i + 1))"
      ],
      [
        0.9224339127540588,
        "    derivative = []\n    integral = [C]\n    for i in range(len(xs)):\n        if i != 0:\n            derivative.append(i * xs[i])\n            integral.append(xs[i - 1] / i)\n        else:\n            derivative.append(0)\n            integral.append(xs[0])\n    while derivative and derivative[-1] == 0:\n        derivative.pop()\n    return (derivative, integral)"
      ],
      [
        0.9222123622894287,
        "    for i in range(len(xs)):\n        if i > 0:\n            derivative.append(i * xs[i])\n        if i > 0:\n            integral.append(xs[i - 1] / i)"
      ],
      [
        0.9221598505973816,
        "    if not xs:\n        return ([], [C])\n    derivative = []\n    integral = [C]\n    for i in range(len(xs)):\n        if i > 0:\n            derivative.append(i * xs[i])\n        if i > 0:\n            integral.append(xs[i - 1] / i)\n    integral.append(xs[-1] / len(xs))\n    while derivative and derivative[-1] == 0:\n        derivative.pop()\n    while len(integral) > 1 and integral[-1] == 0:\n        integral.pop()\n    return (derivative, integral)"
      ],
      [
        0.9212324619293213,
        "    for i in range(len(xs)):\n        if i != 0:\n            derivative.append(i * xs[i])\n            integral.append(xs[i - 1] / i)\n        else:\n            derivative.append(0)\n            integral.append(xs[0])"
      ],
      [
        0.9210360050201416,
        "    for i in range(len(xs)):\n        if i != 0:\n            derivative.append(i * xs[i])\n            integral.append(xs[i - 1] / i)\n        else:\n            derivative.append(0)"
      ]
    ],
    "HumanEval/63": [
      [
        0.9324117302894592,
        "    elif n == 2:\n        return 1\n    elif n > 2:\n        return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n    elif n < 0:\n        return fibfib(n + 3) - fibfib(n + 2) - fibfib(n + 1)"
      ],
      [
        0.9320661425590515,
        "    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    elif n > 2:\n        return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n    elif n < 0:\n        return fibfib(n + 3) - fibfib(n + 2) - fibfib(n + 1)"
      ],
      [
        0.9320661425590515,
        "    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    elif n > 2:\n        return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n    elif n < 0:\n        return fibfib(n + 3) - fibfib(n + 2) - fibfib(n + 1)"
      ],
      [
        0.9319714307785034,
        "    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    elif n > 2:\n        return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n    elif n < 0:\n        return fibfib(n + 3) - fibfib(n + 2) - fibfib(n + 1)"
      ],
      [
        0.9311102628707886,
        "    if n < 0:\n        raise ValueError('Negative arguments are not supported.')\n    if n < 3:\n        return [0, 0, 1][n]\n    else:\n        fibfib = [0, 0, 1] + [0] * (n - 2)\n        for i in range(3, n + 1):\n            fibfib[i] = fibfib[i - 1] + fibfib[i - 2] + fibfib[i - 3]\n        return fibfib[n]"
      ],
      [
        0.9294782876968384,
        "    elif n > 2:\n        return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n    elif n < 0:\n        return fibfib(n + 3) - fibfib(n + 2) - fibfib(n + 1)"
      ],
      [
        0.926540732383728,
        "    if n < 0:\n        raise ValueError('Error: Invalid input')\n    fibfib_values = [0, 0, 1] + [0] * (n - 2)\n    for i in range(3, n + 1):\n        fibfib_values[i] = fibfib_values[i - 1] + fibfib_values[i - 2] + fibfib_values[i - 3]\n    return fibfib_values[n]"
      ],
      [
        0.9255918860435486,
        "    if n == 0:\n        fib_cache[n] = 0\n    elif n == 1:\n        fib_cache[n] = 0\n    elif n == 2:\n        fib_cache[n] = 1\n    elif n in fib_cache:\n        return fib_cache[n]\n    else:\n        fib_cache[n] = fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)"
      ],
      [
        0.9255732297897339,
        "    if n == 0:\n        fib_cache[n] = 0\n    elif n == 1:\n        fib_cache[n] = 0\n    elif n == 2:\n        fib_cache[n] = 1\n    elif n in fib_cache:\n        return fib_cache[n]\n    else:\n        fib_cache[n] = fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)"
      ],
      [
        0.925527811050415,
        "    if n < 3:\n        return [0, 0, 1][n]\n    else:\n        fibfib = [0, 0, 1] + [0] * (n - 2)\n        for i in range(3, n + 1):\n            fibfib[i] = fibfib[i - 1] + fibfib[i - 2] + fibfib[i - 3]\n        return fibfib[n]"
      ]
    ],
    "HumanEval/64": [
      [
        0.9379554986953735,
        "    if type(s) != str:\n        raise ValueError('Invalid input, please provide a string.')\n    s = s.lower()\n    vowels = 'aeiou'\n    s = ''.join((char for char in s if char.isalpha()))\n    count = sum((1 for char in s if char in vowels))\n    s = s.split()\n    count += sum((1 for word in s if word.endswith('y')))\n    return count"
      ],
      [
        0.9360778331756592,
        "    if type(s) != str:\n        raise TypeError('Input must be a string!')\n    vowels = 'aeiou'\n    s = s.lower()\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s[-1] == 'y':\n        count += 1\n    return count"
      ],
      [
        0.9355736970901489,
        "    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    count = 0\n    for letter in word:\n        if letter in vowels:\n            count += 1\n    return count"
      ],
      [
        0.9345531463623047,
        "    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    return count"
      ],
      [
        0.9345407485961914,
        "    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    return count"
      ],
      [
        0.9334993362426758,
        "    vowels = 'aeiou'\n    s = s.lower()\n    count = 0\n    for i in s:\n        if i in vowels:\n            count += 1\n    if s[-1] == 'y':\n        count += 1\n    return count"
      ],
      [
        0.9331676363945007,
        "    if not isinstance(s, str):\n        raise TypeError('Input must be a string.')\n    vowels = 'aeiou'\n    s = s.lower()\n    count = sum((1 for char in s if char in vowels))\n    if s[-1] == 'y':\n        count += 1\n    return count"
      ],
      [
        0.932753324508667,
        "    vowels = 'aeiouy'\n    special_vowels = '\u00e0\u00e8\u00ec\u00f2\u00f9\u00ec\u00e9\u00eb\u00ef\u00fc\u00f8\u00e9\u00ea\u00ef\u00f4\u0153\u00f9'\n    if not isinstance(s, str):\n        return 'Error: Input must be a string'\n    if not all((char.isalpha() or char.isspace() or char in special_vowels for char in s)):\n        return 'Error: Input must contain only alphabetical characters'\n    s = s.lower()\n    count = sum((1 for char in s if char in vowels))\n    if s[-1] in 'y':\n        count += 1\n    return count"
      ],
      [
        0.9327421188354492,
        "    vowels = 'aeiouAEIOU'\n    count = 0\n    for char in word:\n        if char in vowels:\n            count += 1\n    return count"
      ],
      [
        0.9327402114868164,
        "    vowels = 'aeiouAEIOU'\n    count = 0\n    for char in word:\n        if char in vowels:\n            count += 1\n    return count"
      ]
    ],
    "HumanEval/65": [
      [
        0.8990480899810791,
        "    lengthOfX, result = (0, 0)\n    tempX = x\n    while tempX != 0:\n        tempX //= 10\n        lengthOfX += 1\n    if shift >= lengthOfX:\n        while x != 0:\n            result = result * 10 + x % 10\n            x //= 10\n    else:\n        rightPart = x % 10 ** shift\n        leftPart = x // 10 ** shift\n        multiplier = 10 ** (lengthOfX - shift)\n        result = rightPart * multiplier + leftPart\n    return result"
      ],
      [
        0.8956949710845947,
        "    if shift >= lengthOfX:\n        while x != 0:\n            result = result * 10 + x % 10\n            x //= 10\n    else:\n        rightPart = x % 10 ** shift\n        leftPart = x // 10 ** shift\n        multiplier = 10 ** (lengthOfX - shift)\n        result = rightPart * multiplier + leftPart"
      ],
      [
        0.8944485783576965,
        "    if not isinstance(string, str):\n        raise TypeError('The first argument must be a string.')\n    if not isinstance(shift_value, int):\n        raise TypeError('The second argument must be an integer.')\n    if len(string) == 0:\n        raise ValueError('The string cannot be empty.')\n    shift_value %= len(string)\n    string = string[-shift_value:] + string[:-shift_value]\n    return string"
      ],
      [
        0.8943771123886108,
        "    shift_total = sum((i * -1 if d == 0 else i for d, i in shift))\n    shift_total = shift_total % len(s)\n    return s[-shift_total:] + s[:-shift_total]"
      ],
      [
        0.8887749910354614,
        "    if not isinstance(string, str):\n        raise ValueError('Input must be a string.')\n    if not isinstance(reverse_val, int):\n        raise ValueError('The reversal value must be an integer.')\n    if len(string) == 0 or string.isspace():\n        raise ValueError('The string must be nonempty and contain non-whitespace characters.')\n    if reverse_val == 0:\n        raise ValueError('The reversal value cannot be zero.')\n    reverse_val %= len(string)\n    if reverse_val < 0:\n        reverse_val += len(string)\n    return string[-reverse_val:] + string[:-reverse_val]"
      ],
      [
        0.8868898153305054,
        "    if not isinstance(input_string, str):\n        raise Exception('First input must be a string')\n    if not isinstance(reversal_value, int):\n        raise Exception('Second input must be an integer')\n    if not input_string:\n        raise Exception(\"Input string can't be empty\")\n    reversal_value = reversal_value % len(input_string)\n    input_string = list(input_string)\n    if reversal_value > 0:\n        for _ in range(reversal_value):\n            input_string.insert(0, input_string.pop())\n    else:\n        for _ in range(abs(reversal_value)):\n            input_string.append(input_string.pop(0))\n    return ''.join(input_string)"
      ],
      [
        0.8859519958496094,
        "    assert isinstance(string, str), 'Input must be a string'\n    assert isinstance(num_chars, int), 'Reversal value must be an integer'\n    num_chars %= len(string)\n    return string[-num_chars:] + string[:-num_chars]"
      ],
      [
        0.8841220140457153,
        "    if shift >= 0:\n        return lst[shift:] + lst[:shift]\n    else:\n        return lst[shift:] + lst[:shift + len(lst)]"
      ],
      [
        0.8835864067077637,
        "    number_str = str(number)\n    if number < 0:\n        number_str = number_str[1:]\n        reversed_str = number_str[::-1]\n        reversed_str = '-' + reversed_str\n    else:\n        reversed_str = number_str[::-1]\n    reversed_digits = []\n    for char in reversed_str:\n        reversed_digits.append(char)\n    return reversed_digits"
      ],
      [
        0.8834429979324341,
        "    if len(lst) == 0:\n        return []\n    shift = shift % len(lst)\n    shifted_lst = []\n    if shift >= 0:\n        shifted_lst = lst[shift:] + lst[:shift]\n    else:\n        shifted_lst = lst[shift:] + lst[:shift]\n    return shifted_lst"
      ]
    ],
    "HumanEval/66": [
      [
        0.9281196594238281,
        "    return sum((ord(ch) for ch in s if ch.isupper()))"
      ],
      [
        0.928115725517273,
        "    return sum((ord(ch) for ch in s if ch.isupper()))"
      ],
      [
        0.9269676208496094,
        "    sum = 0\n    for c in x:\n        if 'A' <= c <= 'Z':\n            sum += ord(c)\n    return sum"
      ],
      [
        0.9223562479019165,
        "    ascii_sum = 0\n    for char in string:\n        if char.isalpha():\n            ascii_sum += ord(char)\n    return ascii_sum"
      ],
      [
        0.9160513877868652,
        "    for c in x:\n        if 'A' <= c <= 'Z':\n            sum += ord(c)"
      ],
      [
        0.9158889055252075,
        "    sum_ascii = 0\n    for char in string:\n        sum_ascii += ord(char)\n    return sum_ascii"
      ],
      [
        0.9144351482391357,
        "    return sum([ord(w[0]) for w in s.split()])"
      ],
      [
        0.9122053384780884,
        "        for i in s:\n            ascii_val = ord(i)\n            print(f'ASCII value of {i} is {ascii_val}')\n            total_sum += ascii_val"
      ],
      [
        0.9115537405014038,
        "    return sum([ord(c) for c in s])"
      ],
      [
        0.9107525944709778,
        "    total_sum = 0\n    for s in strings:\n        for i in s:\n            ascii_val = ord(i)\n            print(f'ASCII value of {i} is {ascii_val}')\n            total_sum += ascii_val\n    return total_sum"
      ]
    ],
    "HumanEval/67": [
      [
        0.924994707107544,
        "    fruits = list(map(int, re.findall('\\\\d+', s)))\n    apples, oranges = (fruits[0], fruits[1])\n    return n - apples - oranges"
      ],
      [
        0.8937680721282959,
        "    for distr in s:\n        fruit, count = distr.split()\n        fruits_count[fruit] = int(count)"
      ],
      [
        0.8931891322135925,
        "    fruit_counts = {fruit: 0 for fruit in fruits}\n    for fruit in s:\n        count, fruit_type = fruit.split(' ')\n        fruit_counts[fruit_type] = int(count)\n    total_specified_fruits = sum(fruit_counts.values())\n    unspecified_fruits = {fruit: n - total_specified_fruits for fruit in fruit_counts if fruit_counts[fruit] == 0}\n    return unspecified_fruits"
      ],
      [
        0.8917195796966553,
        "    result = {}\n    total_specified = 0\n    for fruit in s:\n        quantity = int(fruit.split(' ')[0])\n        total_specified += quantity\n    remaining_fruits = n - total_specified\n    for fruit in fruits:\n        if fruit not in s:\n            if remaining_fruits > max_quantity:\n                raise ValueError('Total quantity exceeds maximum allowed quantity for fruit type.')\n            else:\n                result[fruit] = remaining_fruits\n    return result"
      ],
      [
        0.8907132148742676,
        "    fruit_dict = {}\n    for fruit in s:\n        fruit_name, count = fruit.split()\n        fruit_dict[fruit_name] = int(count)\n    for fruit in fruits:\n        if fruit in servings:\n            n -= servings[fruit]\n            if n < 0:\n                raise ValueError('Not enough fruits for the servings.')\n    if n % len(fruits) != 0:\n        raise ValueError('Cannot equally distribute remaining fruits.')\n    remaining_per_fruit = n // len(fruits)\n    result = {}\n    for fruit in fruits:\n        if fruit not in fruit_dict:\n            result[fruit] = remaining_per_fruit\n    return result"
      ],
      [
        0.88887619972229,
        "    for record in s:\n        record = record.split(' ')\n        quantity = int(record[0])\n        fruit = record[1]\n        distribution[fruit] += quantity\n        n -= quantity * fruit_prices[fruit]"
      ],
      [
        0.8883052468299866,
        "    distribution = {}\n    for fruit in fruits:\n        distribution[fruit] = 0\n    for record in s:\n        record = record.split(' ')\n        quantity = int(record[0])\n        fruit = record[1]\n        distribution[fruit] += quantity\n        n -= quantity * fruit_prices[fruit]\n    for fruit in fruits:\n        if distribution[fruit] == 0:\n            distribution[fruit] = n // fruit_prices[fruit]\n            n -= distribution[fruit] * fruit_prices[fruit]\n    return {k: v for k, v in distribution.items() if v > 0}"
      ],
      [
        0.886786699295044,
        "    if multiplier < 0 or multiplier > 100:\n        raise ValueError('Multiplier is not valid. It should range from 0 to 100')\n    fruit_dict = {item.split(' ')[1]: int(item.split(' ')[0]) for item in fruits}\n    non_fruit_dict = {item.split(' ')[1]: int(item.split(' ')[0]) for item in non_fruit_items}\n    if n < sum(fruit_dict.values()) + sum(non_fruit_dict.values()):\n        return 'Error'\n    if s % 2 != 0:\n        fruit_dict = {k: v * multiplier for k, v in fruit_dict.items()}\n    fruit_dict = {k: v for k, v in fruit_dict.items() if v > 0}\n    non_fruit_dict = {k: v for k, v in non_fruit_dict.items() if v > 0}\n    return (fruit_dict, non_fruit_dict)"
      ],
      [
        0.8850457668304443,
        "    if apples < 0 or oranges < 0:\n        return 'Error: The counts cannot be negative.'\n    else:\n        return apples + oranges"
      ],
      [
        0.8850457668304443,
        "    if apples < 0 or oranges < 0:\n        return 'Error: The counts cannot be negative.'\n    else:\n        return apples + oranges"
      ]
    ],
    "HumanEval/68": [
      [
        0.9207025766372681,
        "    result = []\n    even_nodes = []\n    for idx, node in enumerate(nodes):\n        if node % 2 == 0 and node != 0:\n            even_nodes.append((node, idx))\n    if even_nodes:\n        even_nodes.sort()\n        min_val = even_nodes[0][0]\n        for node, idx in even_nodes:\n            if node == min_val:\n                result = [node, idx]\n    return result"
      ],
      [
        0.9165580868721008,
        "    if type(lst) is not list:\n        return 'Error: The provided input is not a list!'\n    smallest_even = float('inf')\n    smallest_even_indices = []\n    for i in range(len(lst)):\n        if type(lst[i]) is not int:\n            return 'Error: List contains non-integer values!'\n        if lst[i] % 2 == 0 and lst[i] < smallest_even:\n            smallest_even = lst[i]\n            smallest_even_indices = [i]\n        elif lst[i] == smallest_even:\n            smallest_even_indices.append(i)\n    if smallest_even == float('inf'):\n        return 'No even number found!'\n    else:\n        return (smallest_even, smallest_even_indices)"
      ],
      [
        0.9159443378448486,
        "    smallest_even = smallest_odd = [float('inf'), -1]\n    for idx, val in enumerate(nodes):\n        if val % 2 == 0 and val < smallest_even[0]:\n            smallest_even = [val, idx]\n        elif val % 2 != 0 and val < smallest_odd[0]:\n            smallest_odd = [val, idx]\n    smallest_nodes = []\n    if smallest_even[1] != -1:\n        smallest_nodes.append(smallest_even)\n    if smallest_odd[1] != -1:\n        smallest_nodes.append(smallest_odd)\n    return smallest_nodes"
      ],
      [
        0.9138013124465942,
        "    min_even_node, min_even_val = (None, float('inf'))\n    for node in nodes:\n        if node.value < min_even_val and node.value % 2 == 0:\n            min_even_node, min_even_val = (node, node.value)\n        elif node.value == min_even_val:\n            min_even_node = node\n    if min_even_node is None:\n        return []\n    else:\n        return [min_even_node]"
      ],
      [
        0.9118924140930176,
        "    second_smallest_even = float('inf')\n    indices = []\n    for i, num in enumerate(lst):\n        if num % 2 == 0 and num < second_smallest_even:\n            second_smallest_even = num\n            indices = [i]\n        elif num % 2 == 0 and num == second_smallest_even:\n            indices.append(i)\n    return indices"
      ],
      [
        0.9091996550559998,
        "    smallest_even_node, smallest_odd_node = ([float('inf'), ''], [float('inf'), ''])\n    stack = [(root, path)]\n    while stack:\n        node, path = stack.pop()\n        if node['value'] % 2 == 0 and node['value'] < smallest_even_node[0]:\n            smallest_even_node = [node['value'], path]\n        elif node['value'] % 2 == 1 and node['value'] < smallest_odd_node[0]:\n            smallest_odd_node = [node['value'], path]\n        if node['right']:\n            stack.append((node['right'], path + '->' + str(node['right']['value'])))\n        if node['left']:\n            stack.append((node['left'], path + '->' + str(node['left']['value'])))\n    return ([smallest_even_node] if smallest_even_node[0] != float('inf') else []) + ([smallest_odd_node] if smallest_odd_node[0] != float('inf') else [])"
      ],
      [
        0.9035148620605469,
        "        if val % 2 == 0 and val < smallest_even[0]:\n            smallest_even = [val, idx]\n        elif val % 2 != 0 and val < smallest_odd[0]:\n            smallest_odd = [val, idx]"
      ],
      [
        0.9026234149932861,
        "    even_list = [num for num in lst if num % 2 == 0]\n    return min(even_list) if even_list else None"
      ],
      [
        0.9023441672325134,
        "    even_numbers = [num for num in lst if num % 2 == 0]\n    if even_numbers:\n        return min(even_numbers)\n    else:\n        return 'Element does not exist'"
      ],
      [
        0.9014334678649902,
        "    for i in range(len(lst)):\n        if type(lst[i]) is not int:\n            return 'Error: List contains non-integer values!'\n        if lst[i] % 2 == 0 and lst[i] < smallest_even:\n            smallest_even = lst[i]\n            smallest_even_indices = [i]\n        elif lst[i] == smallest_even:\n            smallest_even_indices.append(i)"
      ]
    ],
    "HumanEval/69": [
      [
        0.9129770994186401,
        "    freq = {}\n    for num in lst:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    greatest = -1\n    for num, count in freq.items():\n        if count >= num * num:\n            greatest = max(greatest, num)\n    return greatest"
      ],
      [
        0.9088579416275024,
        "    freq_count = {}\n    for num in lst:\n        if num > 0:\n            if num not in freq_count:\n                freq_count[num] = 1\n            else:\n                freq_count[num] += 1\n    sorted_freq_count = sorted(freq_count.items(), key=lambda x: x[1], reverse=True)\n    if sorted_freq_count:\n        return sorted_freq_count[0][0]\n    else:\n        return None"
      ],
      [
        0.9082995653152466,
        "    index = -1\n    for i in range(len(lst)):\n        if lst[i] == 7:\n            index = i\n            break\n    if index == -1:\n        return -1\n    else:\n        return index"
      ],
      [
        0.9079490900039673,
        "    freq_counter = {}\n    for n in lst:\n        if n in freq_counter:\n            freq_counter[n] += 1\n        else:\n            freq_counter[n] = 1\n    rare_values = [n for n in freq_counter if freq_counter[n] <= n // 2]\n    if not rare_values:\n        return -1\n    return min(rare_values)"
      ],
      [
        0.9071341753005981,
        "    freq = {}\n    for i in lst:\n        freq[i] = freq.get(i, 0) + 1\n    filtered = [key for key, value in freq.items() if value <= key / 2]\n    if not filtered:\n        return -1\n    return min(filtered)"
      ],
      [
        0.9063591957092285,
        "    index = -1\n    count = 0\n    longest_subseq_start = 0\n    longest_subseq_len = 0\n    current_subseq_start = 0\n    current_subseq_len = 0\n    for i in range(len(lst)):\n        if lst[i] == item:\n            if index == -1:\n                index = i\n            count += 1\n        if i > 0 and lst[i] == lst[i - 1] + 1:\n            if current_subseq_len == 0:\n                current_subseq_start = i - 1\n            current_subseq_len += 1\n        else:\n            if current_subseq_len > longest_subseq_len:\n                longest_subseq_start = current_subseq_start\n                longest_subseq_len = current_subseq_len\n            current_subseq_len = 0\n    if current_subseq_len > longest_subseq_len:\n        longest_subseq_start = current_subseq_start\n        longest_subseq_len = current_subseq_len\n    return (index, count, longest_subseq_start, longest_subseq_len)"
      ],
      [
        0.9052175879478455,
        "    if not lst:\n        return 'Error: List is empty'\n    elif not all((isinstance(num, int) for num in lst)):\n        return 'Error: List contains non-integer elements'\n    else:\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            if lst[i] == lst[i + 1]:\n                continue\n            else:\n                return lst[i]"
      ],
      [
        0.9052175879478455,
        "    if not lst:\n        return 'Error: List is empty'\n    elif not all((isinstance(num, int) for num in lst)):\n        return 'Error: List contains non-integer elements'\n    else:\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            if lst[i] == lst[i + 1]:\n                continue\n            else:\n                return lst[i]"
      ],
      [
        0.9049245119094849,
        "    for el in lst:\n        if el > smallest:\n            return el"
      ],
      [
        0.9048796892166138,
        "    for i in range(len(lst)):\n        if lst[i] == item:\n            if index == -1:\n                index = i\n            count += 1\n        if i > 0 and lst[i] == lst[i - 1] + 1:\n            if current_subseq_len == 0:\n                current_subseq_start = i - 1\n            current_subseq_len += 1\n        else:\n            if current_subseq_len > longest_subseq_len:\n                longest_subseq_start = current_subseq_start\n                longest_subseq_len = current_subseq_len\n            current_subseq_len = 0"
      ]
    ],
    "HumanEval/70": [
      [
        0.9067033529281616,
        "    if not lst:\n        return []\n    if len(lst) == 1:\n        return lst\n    max_value = max(lst)\n    lst.remove(max_value)\n    return [max_value] + sort_descending(lst)"
      ],
      [
        0.9054127335548401,
        "    while len(lst) > 0:\n        min_value = min(lst)\n        out_lst.append(min_value)\n        lst.remove(min_value)\n        if len(lst) > 0:\n            max_value = max(lst)\n            out_lst.append(max_value)\n            lst.remove(max_value)"
      ],
      [
        0.9015185832977295,
        "    res = []\n    lst_float = []\n    for item in lst:\n        try:\n            lst_float.append(float(item))\n        except ValueError:\n            pass\n    if lst_float == []:\n        return res\n    lst_float.sort()\n    while len(lst_float) > 0:\n        min_num = min(lst_float)\n        while min_num in lst_float:\n            res.append(min_num)\n            lst_float.remove(min_num)\n        if len(lst_float) > 0:\n            max_num = max(lst_float)\n            while max_num in lst_float:\n                lst_float.remove(max_num)\n            res.append(max_num)\n    return res"
      ],
      [
        0.9005295634269714,
        "    odd_numbers = [num for num in lst if num % 2 != 0]\n    if len(odd_numbers) == 0:\n        return []\n    odd_numbers.sort(reverse=True)\n    odd_numbers = list(set(odd_numbers))\n    return odd_numbers"
      ],
      [
        0.8999285101890564,
        "    sorted_list = []\n    while lst:\n        max_val = max(lst)\n        lst.remove(max_val)\n        sorted_list.append(max_val)\n    return sorted_list"
      ],
      [
        0.8996865749359131,
        "        for num in lst:\n            if num > max_val:\n                second_max_val = max_val\n                max_val = num\n            elif num > second_max_val and num != max_val:\n                second_max_val = num\n            if num < min_val:\n                second_min_val = min_val\n                min_val = num\n            elif num < second_min_val and num != min_val:\n                second_min_val = num"
      ],
      [
        0.8995206952095032,
        "    sorted_lst = []\n    while lst:\n        min_value = min(lst)\n        sorted_lst.append(min_value)\n        lst.remove(min_value)\n    return sorted_lst"
      ],
      [
        0.8994662761688232,
        "        for num in lst:\n            if num > max_val:\n                second_max_val = max_val\n                max_val = num\n            elif num > second_max_val:\n                second_max_val = num\n            if num < min_val:\n                second_min_val = min_val\n                min_val = num\n            elif num < second_min_val:\n                second_min_val = num"
      ],
      [
        0.8992816805839539,
        "    sorted_list = []\n    while len(lst) != 0:\n        maximum = None\n        for value in lst:\n            try:\n                if not maximum:\n                    maximum = value\n                elif value > maximum:\n                    maximum = value\n            except TypeError:\n                return 'Error: List contains non-comparable types.'\n        while maximum in lst:\n            lst.remove(maximum)\n        sorted_list.append(maximum)\n    return sorted_list"
      ],
      [
        0.8991618156433105,
        "    for num in lst:\n        if num > max_value:\n            second_max_value = max_value\n            max_value = num\n        elif num > second_max_value and num != max_value:\n            second_max_value = num\n        if num < min_value:\n            second_min_value = min_value\n            min_value = num\n        elif num < second_min_value and num != min_value:\n            second_min_value = num"
      ]
    ],
    "HumanEval/71": [
      [
        0.9314859509468079,
        "    if a + b > c and a + c > b and (b + c > a):\n        p = (a + b + c) / 2.0\n        area = (p * (p - a) * (p - b) * (p - c)) ** 0.5\n        return round(area, 2)\n    else:\n        return -1"
      ],
      [
        0.9314859509468079,
        "    if a + b > c and a + c > b and (b + c > a):\n        p = (a + b + c) / 2.0\n        area = (p * (p - a) * (p - b) * (p - c)) ** 0.5\n        return round(area, 2)\n    else:\n        return -1"
      ],
      [
        0.9275043606758118,
        "    if a + b > c and b + c > a and (c + a > b):\n        if a == b == c:\n            triangle_type = 'Equilateral'\n        elif a == b or b == c or c == a:\n            triangle_type = 'Isosceles'\n        else:\n            triangle_type = 'Scalene'\n        s = (a + b + c) / 2\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return (round(area, 2), triangle_type)\n    else:\n        return -1"
      ],
      [
        0.9275043606758118,
        "    if a + b > c and b + c > a and (c + a > b):\n        if a == b == c:\n            triangle_type = 'Equilateral'\n        elif a == b or b == c or c == a:\n            triangle_type = 'Isosceles'\n        else:\n            triangle_type = 'Scalene'\n        s = (a + b + c) / 2\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return (round(area, 2), triangle_type)\n    else:\n        return -1"
      ],
      [
        0.927497148513794,
        "    if a + b > c and b + c > a and (c + a > b):\n        if a == b == c:\n            triangle_type = 'Equilateral'\n        elif a == b or b == c or c == a:\n            triangle_type = 'Isosceles'\n        else:\n            triangle_type = 'Scalene'\n        s = (a + b + c) / 2\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return (round(area, 2), triangle_type)\n    else:\n        return -1"
      ],
      [
        0.927497148513794,
        "    if a + b > c and b + c > a and (c + a > b):\n        if a == b == c:\n            triangle_type = 'Equilateral'\n        elif a == b or b == c or c == a:\n            triangle_type = 'Isosceles'\n        else:\n            triangle_type = 'Scalene'\n        s = (a + b + c) / 2\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return (round(area, 2), triangle_type)\n    else:\n        return -1"
      ],
      [
        0.9255488514900208,
        "    if a + b > c and a + c > b and (b + c > a):\n        s = (a + b + c) / 2\n        area = sqrt(s * (s - a) * (s - b) * (s - c))\n        return area\n    else:\n        return 'Invalid triangle'"
      ],
      [
        0.9255488514900208,
        "    if a + b > c and a + c > b and (b + c > a):\n        s = (a + b + c) / 2\n        area = sqrt(s * (s - a) * (s - b) * (s - c))\n        return area\n    else:\n        return 'Invalid triangle'"
      ],
      [
        0.9249489307403564,
        "    if a + b <= c or b + c <= a or c + a <= b:\n        return 'Invalid triangle'\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    rounded_area = round(area)\n    return rounded_area"
      ],
      [
        0.9248555898666382,
        "    if a + b > c and a + c > b and (b + c > a):\n        s = (a + b + c) / 2\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return area\n    else:\n        return 'The provided dimensions do not form a valid triangle.'"
      ]
    ],
    "HumanEval/72": [
      [
        0.9124611020088196,
        "    if not isinstance(q, (list, tuple)):\n        return 'Non-sequence input'\n    if not all((isinstance(item, (int, float)) for item in q)):\n        return 'Non-numeric input'\n    if q != sorted(q) and q != sorted(q, reverse=True):\n        return 'Unsorted list error'\n    if q == q[::-1] and sum(q) <= w:\n        return True\n    else:\n        return False"
      ],
      [
        0.9103405475616455,
        "    if not isinstance(q, (list, tuple, str)):\n        return 'Non-sequence input'\n    for i in q:\n        if not isinstance(i, (int, float)):\n            return 'Non-numeric input'\n    return is_palindrome(q) and sum(q) <= w"
      ],
      [
        0.9067307114601135,
        "    q_len = len(q)\n    for i in range(q_len // 2):\n        if q[i] != q[q_len - 1 - i]:\n            return False\n    if sum(q) > w:\n        return False\n    return True"
      ],
      [
        0.9055743217468262,
        "    if q == q[::-1]:\n        if sum(q) <= w:\n            return True\n        else:\n            return False\n    else:\n        return False"
      ],
      [
        0.9055743217468262,
        "    if q == q[::-1]:\n        if sum(q) <= w:\n            return True\n        else:\n            return False\n    else:\n        return False"
      ],
      [
        0.9053846597671509,
        "    if q == q[::-1] and sum(q) <= w:\n        return True\n    else:\n        return False"
      ],
      [
        0.9053846597671509,
        "    if q == q[::-1] and sum(q) <= w:\n        return True\n    else:\n        return False"
      ],
      [
        0.905364990234375,
        "    if q == q[::-1] and sum(q) <= w:\n        return True\n    else:\n        return False"
      ],
      [
        0.9016804695129395,
        "    if all((isinstance(i, int) for i in q)):\n        if q == q[::-1] and sum((i for i in q)) <= w:\n            return True"
      ],
      [
        0.9013283252716064,
        "    if len(q) > e and q == q[::-1] and (sum(q) <= w):\n        return True\n    else:\n        return False"
      ]
    ],
    "HumanEval/73": [
      [
        0.9133563041687012,
        "    changes = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[-i - 1]:\n            changes += 1\n        if changes > limit:\n            return -1\n    return changes"
      ],
      [
        0.911381185054779,
        "    if arr == arr[::-1]:\n        return 0\n    n = len(arr)\n    l = 0\n    r = n - 1\n    counter = 0\n    changes = set()\n    while l <= r:\n        if arr[l] == arr[r]:\n            l += 1\n            r -= 1\n        else:\n            counter += 1\n            changes.add((min(arr[l], arr[r]), max(arr[l], arr[r])))\n            if len(changes) > limit:\n                return -1\n            arr[l] = arr[r] = min(arr[l], arr[r])\n            l += 1\n            r -= 1\n    return counter"
      ],
      [
        0.9095230102539062,
        "    n = len(arr)\n    changes = 0\n    for i in range(n // 2):\n        if arr[i] != arr[n - 1 - i]:\n            changes += 1\n        if changes > limit:\n            break\n    return min(changes, limit)"
      ],
      [
        0.9067809581756592,
        "    i, j = (0, len(arr) - 1)\n    changes = 0\n    unique_elements = set()\n    while i <= j:\n        if arr[i] != arr[j]:\n            changes += 1\n            if arr[i] not in unique_elements:\n                limit -= 1\n                if limit < 0:\n                    return changes\n                unique_elements.add(arr[i])\n            arr[j] = arr[i]\n        i += 1\n        j -= 1\n    return changes"
      ],
      [
        0.90476393699646,
        "    n = len(arr)\n    count = 0\n    for i in range(n // 2):\n        if arr[i] != arr[n - i - 1]:\n            count += 1\n            if count > limit:\n                return count\n    return count"
      ],
      [
        0.9043543934822083,
        "    for i in range(n // 2):\n        if arr[i] != arr[n - i - 1]:\n            count += 1\n            if count > limit:\n                return count"
      ],
      [
        0.902381181716919,
        "    for i in range(len(arr) // 2):\n        if arr[i] != arr[-i - 1]:\n            changes += 1\n        if changes > limit:\n            return -1"
      ],
      [
        0.9023770093917847,
        "    i, j = (0, len(arr) - 1)\n    count = 0\n    while i < j:\n        if arr[i] != arr[j]:\n            count += 1\n            if count > limit:\n                return -1\n            arr[j] = arr[i]\n        i += 1\n        j -= 1\n    return count"
      ]
    ],
    "HumanEval/74": [
      [
        0.9324888586997986,
        "    cleaned_lst1 = [str.replace(' ', '').lower() for str in lst1]\n    cleaned_lst2 = [str.replace(' ', '').lower() for str in lst2]\n    seen = set()\n    unique_lst1 = [string for string in lst1 if string.lower() not in seen and (not seen.add(string.lower()))]\n    unique_lst2 = [string for string in lst2 if string.lower() not in seen and (not seen.add(string.lower()))]\n    count_lst1 = sum([len(str) for str in cleaned_lst1])\n    count_lst2 = sum([len(str) for str in cleaned_lst2])\n    if count_lst1 <= count_lst2:\n        return unique_lst1\n    else:\n        return unique_lst2"
      ],
      [
        0.9240758419036865,
        "    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2"
      ],
      [
        0.9222332835197449,
        "    import re\n    lst1 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst1]\n    lst2 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst2]\n    lst1, lst2 = (list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2)))\n    return lst1 if sum((len(s) for s in lst1)) <= sum((len(s) for s in lst2)) else lst2"
      ],
      [
        0.9218987226486206,
        "    len1 = sum((len(word.replace(' ', '')) for word in lst1))\n    len2 = sum((len(word.replace(' ', '')) for word in lst2))\n    if len1 <= len2:\n        lst = lst1\n        other_lst = lst2\n    else:\n        lst = lst2\n        other_lst = lst1\n    res = []\n    other_set = set((str.lower() for str in other_lst))\n    for string in lst:\n        if string.lower() not in other_set:\n            res.append(string)\n            other_set.add(string.lower())\n    return res"
      ],
      [
        0.919605016708374,
        "    lst1 = list(dict.fromkeys([i.lower() for i in lst1]))\n    lst2 = list(dict.fromkeys([i.lower() for i in lst2]))\n    lst1_no_space = [i.replace(' ', '') for i in lst1]\n    lst2_no_space = [i.replace(' ', '') for i in lst2]\n    if sum((i.isnumeric() for i in lst1_no_space)) > len(lst1_no_space) / 2 or sum((i.isnumeric() for i in lst2_no_space)) > len(lst2_no_space) / 2:\n        return []\n    count1 = sum((len(i) for i in lst1_no_space))\n    count2 = sum((len(i) for i in lst2_no_space))\n    if count1 <= count2:\n        return lst1\n    else:\n        return lst2"
      ],
      [
        0.9188370108604431,
        "    lst1 = [string for string in lst1 if not any((char.isdigit() for char in string))]\n    lst2 = [string for string in lst2 if not any((char.isdigit() for char in string))]\n    seen1 = set()\n    seen2 = set()\n    lst1 = [x for x in lst1 if not (x.lower() in seen1 or seen1.add(x.lower()))]\n    lst2 = [x for x in lst2 if not (x.lower() in seen2 or seen2.add(x.lower()))]\n    len1 = sum((len(s.replace(' ', '')) for s in lst1))\n    len2 = sum((len(s.replace(' ', '')) for s in lst2))\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2"
      ],
      [
        0.9165415167808533,
        "    lst1 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst1]\n    lst2 = [re.sub('\\\\W+', '', s).lower() if not case_sensitive else re.sub('\\\\W+', '', s) for s in lst2]\n    lst1, lst2 = (list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2)))\n    return lst1 if sum((len(s) for s in lst1)) <= sum((len(s) for s in lst2)) else lst2"
      ],
      [
        0.9086713194847107,
        "    lst1 = sorted(set(lst1), key=lst1.index)\n    lst2 = sorted(set(lst2), key=lst2.index)\n    total_chars1, total_chars2, total_numeric = (0, 0, 0)\n    for word in lst1:\n        total_chars1 += len(word.replace(' ', ''))\n        total_numeric += sum((c.isdigit() for c in word))\n    for word in lst2:\n        total_chars2 += len(word.replace(' ', ''))\n        total_numeric += sum((c.isdigit() for c in word))\n    total_chars = total_chars1 + total_chars2\n    if total_numeric / total_chars > 0.3:\n        return []\n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2"
      ],
      [
        0.9073697924613953,
        "    if ignore_nums:\n        lst1 = [''.join(filter(lambda x: not x.isdigit(), s)) for s in lst1]\n        lst2 = [''.join(filter(lambda x: not x.isdigit(), s)) for s in lst2]\n    if unique_chars:\n        lst1 = [''.join(sorted(s.lower())) for s in lst1]\n        lst2 = [''.join(sorted(s.lower())) for s in lst2]\n    results = [s for s in lst2 if s in lst1]\n    return results"
      ],
      [
        0.9064405560493469,
        "    if not list1 and (not list2):\n        return (None, None)\n    if not list1:\n        list1.append('')\n    if not list2:\n        list2.append('')\n    max_word1 = min(sorted([(len(set(word.lower())), word) for word in list1]))[1]\n    max_word2 = min(sorted([(len(set(word.lower())), word) for word in list2]))[1]\n    return (max_word1, max_word2)"
      ]
    ],
    "HumanEval/75": [
      [
        0.9212557673454285,
        "    prime_factors = []\n    for i in range(2, a + 1):\n        if a % i == 0 and is_prime(i):\n            prime_factors.append(i)\n    if len(prime_factors) == 3:\n        product = 1\n        for factor in prime_factors:\n            product *= factor\n        if product == a:\n            return True\n    return False"
      ],
      [
        0.9117467403411865,
        "    if len(prime_factors) == 3:\n        product = 1\n        for factor in prime_factors:\n            product *= factor\n        if product == a:\n            return True"
      ],
      [
        0.9088541865348816,
        "    for possible_factor in range(2, a):\n        if a % possible_factor == 0 and is_prime(possible_factor):\n            primes.append(possible_factor)\n            a = a // possible_factor\n        if len(primes) > 3:\n            return 'Not a product of 3 distinct prime numbers.'"
      ],
      [
        0.9088271856307983,
        "    primes = get_distinct_primes(a)\n    return len(primes) == 3"
      ]
    ],
    "HumanEval/76": [
      [
        0.9209518432617188,
        "    if x <= 0 or y <= 0 or (not isinstance(x, int)) or (not isinstance(y, int)):\n        return False\n    power = 0\n    while x ** power <= y:\n        if x ** power == y:\n            return True\n        power += 1\n    return False"
      ],
      [
        0.9116774201393127,
        "    if not (isinstance(x, int) and isinstance(y, int)):\n        return 'Error: Both inputs must be integers.'\n    if x in [-1, 1]:\n        return y == x\n    if x == 0 and y != 0:\n        return True\n    elif y == 0 and x != 0:\n        return True\n    if y == 1:\n        return False\n    while y != 1:\n        if y % x != 0:\n            return False\n        y = y // x\n    return True"
      ],
      [
        0.9116694927215576,
        "    if x <= 0 or not isinstance(x, int) or isinstance(x, float):\n        return False\n    if y <= 0 or not isinstance(y, int) or isinstance(y, float):\n        return False\n    if x == 1:\n        return y == 1\n    power = 0\n    while y % x == 0:\n        y = y / x\n        power += 1\n    return y == 1"
      ],
      [
        0.9096775054931641,
        "    if n == 0:\n        return 1\n    elif n < 0:\n        return 1 / power(x, -n)\n    else:\n        partial = power(x, n // 2)\n        result = partial * partial\n        if n % 2 == 1:\n            result *= x\n        return result"
      ],
      [
        0.9096775054931641,
        "    if n == 0:\n        return 1\n    elif n < 0:\n        return 1 / power(x, -n)\n    else:\n        partial = power(x, n // 2)\n        result = partial * partial\n        if n % 2 == 1:\n            result *= x\n        return result"
      ],
      [
        0.9080367088317871,
        "    if n <= 1:\n        return False\n    for a in range(2, int(math.sqrt(n)) + 1):\n        b = math.log(n, a)\n        if b.is_integer() and a ** int(b) == n:\n            return True\n    return False"
      ],
      [
        0.9070392847061157,
        "    elif n < 0:\n        return 1 / power(x, -n)\n    else:\n        partial = power(x, n // 2)\n        result = partial * partial\n        if n % 2 == 1:\n            result *= x\n        return result"
      ],
      [
        0.9066441059112549,
        "    if n <= 0:\n        return False\n    sqroot = int(n ** 0.5)\n    if int(sqroot ** 2) == n:\n        return True\n    else:\n        return False"
      ],
      [
        0.9064412713050842,
        "    if n == 0:\n        return 1\n    temp_result = power(x, int(n / 2))\n    if n % 2 == 0:\n        return temp_result * temp_result\n    elif n > 0:\n        return x * temp_result * temp_result\n    else:\n        return temp_result * temp_result / x"
      ],
      [
        0.9061049818992615,
        "    square_root = math.sqrt(n)\n    return square_root.is_integer()"
      ]
    ],
    "HumanEval/77": [
      [
        0.9359630346298218,
        "    a = abs(a)\n    root = round(a ** (1 / 3))\n    return root ** 3 == a"
      ],
      [
        0.9356940984725952,
        "    cube_root = round(n ** (1 / 3))\n    return cube_root ** 3 == n"
      ],
      [
        0.9356825947761536,
        "    cube_root = round(n ** (1 / 3))\n    return cube_root ** 3 == n"
      ],
      [
        0.9356069564819336,
        "    cube_root = n ** (1 / 3.0)\n    return round(cube_root) ** 3 == n"
      ],
      [
        0.93504798412323,
        "    cube_root = round(n ** (1.0 / 3))\n    return cube_root ** 3 == n"
      ],
      [
        0.9329211711883545,
        "    cube_root = round(num ** (1 / 3))\n    return cube_root ** 3 == num"
      ],
      [
        0.9314131140708923,
        "    cbrt = int(round(n ** (1 / 3)))\n    return cbrt * cbrt * cbrt == n"
      ],
      [
        0.9284152984619141,
        "    root = round(n ** (1 / 3))\n    return root ** 3 == n"
      ],
      [
        0.928362250328064,
        "    if not isinstance(n, (int, float)) or n < 0:\n        raise ValueError('Input must be a non-negative number')\n    i = 0\n    while i * i * i <= n:\n        if i * i * i == n:\n            return True\n        i += 1\n    return False"
      ],
      [
        0.9254531860351562,
        "    if n < 0:\n        return False\n    root = n ** (1.0 / 3.0)\n    return round(root) ** 3 == n"
      ]
    ],
    "HumanEval/78": [
      [
        0.8991833925247192,
        "    for seperator in sep:\n        if seperator in s:\n            return s.split(seperator)\n    upper_case_chars = [char for char in s if char.isupper()]\n    total = sum((1 for char in upper_case_chars if is_prime(ord(char) - ord('A'))))\n    return total"
      ],
      [
        0.8950701951980591,
        "    count = 0\n    upper_vowels = ('A', 'E', 'I', 'O', 'U')\n    for i in range(len(s)):\n        if is_prime(i) and s[i] in upper_vowels:\n            count += 1\n    return count"
      ],
      [
        0.8942976593971252,
        "    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    prime_chars = []\n    for char in stringA:\n        if char.isalpha() and ord(char) in primes:\n            prime_chars.append(char)\n    return prime_chars"
      ],
      [
        0.8939042091369629,
        "    count = 0\n    upper_vowels = ['A', 'E', 'I', 'O', 'U']\n    for i in range(len(s)):\n        if is_prime(i) and s[i] in upper_vowels:\n            count += 1\n    return count"
      ],
      [
        0.8936193585395813,
        "    count = 0\n    for c in num:\n        if c in ['2', '3', '5', '7', 'B', 'D']:\n            count += 1\n    return count"
      ],
      [
        0.8933451175689697,
        "    count = 0\n    for i in range(len(s)):\n        if is_prime(i + 1):\n            if s[i] in 'AEIOU':\n                count += 1\n    return count"
      ],
      [
        0.8925343751907349,
        "    vowels = ['A', 'E', 'I', 'O', 'U']\n    return len([c for i, c in enumerate(s) if is_prime(i) and c in vowels])"
      ],
      [
        0.8918024897575378,
        "    hex_to_bin_map = {'0': '0000', '1': '0001', '2': '0010', '3': '0011', '4': '0100', '5': '0101', '6': '0110', '7': '0111', '8': '1000', '9': '1001', 'A': '1010', 'B': '1011', 'C': '1100', 'D': '1101', 'E': '1110', 'F': '1111'}\n    binary_num = ''\n    for digit in hex_num:\n        binary_num += hex_to_bin_map[digit]\n    return binary_num"
      ],
      [
        0.8916840553283691,
        "    if str.isupper():\n        return sum([1 for c in str if (ord(c) - ord('A')) % 2 == 0])\n    elif ' ' in str:\n        return str.split()"
      ],
      [
        0.8915690183639526,
        "            elif int(hex_dec) == 12:\n                res += 'C'\n            elif int(hex_dec) == 13:\n                res += 'D'\n            elif int(hex_dec) == 14:\n                res += 'E'\n            elif int(hex_dec) == 15:\n                res += 'F'"
      ]
    ],
    "HumanEval/79": [
      [
        0.9199225902557373,
        "    binary = []\n    while decimal > 0:\n        binary.insert(0, decimal % 2)\n        decimal //= 2\n    return ''.join((str(bit) for bit in binary))"
      ],
      [
        0.9186347723007202,
        "    if decimal % 2 == 0:\n        return decimal_to_binary(decimal // 2) + '0'"
      ],
      [
        0.916945219039917,
        "    if decimal == 0:\n        return '0'\n    binary = decimal % 2\n    return str(decimal_to_binary(decimal // 2)) + str(binary)"
      ],
      [
        0.9153889417648315,
        "    if decimal == 0:\n        return '0'\n    elif decimal == 1:\n        return '1'\n    else:\n        return decimal_to_binary(decimal // 2) + str(decimal % 2)"
      ],
      [
        0.9153889417648315,
        "    if decimal == 0:\n        return '0'\n    elif decimal == 1:\n        return '1'\n    else:\n        return decimal_to_binary(decimal // 2) + str(decimal % 2)"
      ],
      [
        0.9143929481506348,
        "    if decimal == 0:\n        return '0'\n    binary = ''\n    while decimal > 0:\n        remainder = decimal % 2\n        binary += str(remainder)\n        decimal //= 2\n    return binary[::-1]"
      ],
      [
        0.9142754673957825,
        "    if decimal == 0:\n        return '0'\n    binary = ''\n    negative = False\n    if decimal < 0:\n        negative = True\n        decimal = abs(decimal)\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal //= 2\n    if negative:\n        binary = '-' + binary\n    return binary"
      ],
      [
        0.9138781428337097,
        "    binary = []\n    while decimal > 0:\n        binary.append(decimal % 2)\n        decimal //= 2\n    return binary[::-1]"
      ],
      [
        0.9138652682304382,
        "    if decimal == 0:\n        return '0'\n    binary = ''\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal = decimal // 2\n    return binary"
      ],
      [
        0.9135996103286743,
        "    if decimal < 0:\n        return '-' + decimal_to_binary(-decimal)\n    if 'e' in str(decimal):\n        decimal = '{:.10f}'.format(decimal)\n        decimal = decimal.rstrip('0').rstrip('.')\n    if '.' in str(decimal):\n        whole, decimal = str(decimal).split('.')\n        whole = int(whole)\n        decimal = float('0.' + decimal)\n        return decimal_to_binary(whole) + '.' + decimal_to_binary(decimal)\n    if decimal == 0:\n        return '0'\n    return decimal_to_binary(decimal // 2) + str(decimal % 2)"
      ]
    ],
    "HumanEval/80": [
      [
        0.9038690328598022,
        "    if len(s) < 3:\n        return False\n    if len(set((s[i:i + 3] for i in range(len(s))))) < len(s) - 2:\n        return False\n    counter = Counter(s)\n    if any((value < 3 for value in counter.values())):\n        return False\n    if any((len(list(group)) >= 4 for key, group in groupby(s))):\n        return False\n    for key in counter.keys():\n        if len(set((s[i + 1] for i in range(len(s) - 1) if s[i] == key))) < 2:\n            return False\n    return True"
      ],
      [
        0.9012349247932434,
        "    pattern_dict = {}\n    for i in range(len(s) - n + 1):\n        sequence = s[i:i + n]\n        if sequence in pattern_dict:\n            pattern_dict[sequence] += 1\n        else:\n            pattern_dict[sequence] = 1\n    all_happy = all((count >= 2 for count in pattern_dict.values()))\n    return ('happy' if all_happy else 'not happy', [pattern for pattern in pattern_dict.keys()])"
      ],
      [
        0.9009674787521362,
        "    if not s.isalpha() or not s.islower():\n        return 'Error: Invalid Input. Please enter only lowercase alphabets.'\n    if len(s) < 3:\n        return False\n    alphabets_count = {}\n    sets = set()\n    for i in range(len(s) - 2):\n        subset = s[i:i + 3]\n        if subset in sets or subset[0] == subset[1] or subset[1] == subset[2]:\n            return False\n        sets.add(subset)\n        for c in subset:\n            if c in alphabets_count:\n                alphabets_count[c] += 1\n            else:\n                alphabets_count[c] = 1\n    count_even = list(filter(lambda c: c % 2 == 0, alphabets_count.values()))\n    count_odd = list(filter(lambda c: c % 2 != 0, alphabets_count.values()))\n    return len(count_odd) == 0 and len(count_even) < 3"
      ],
      [
        0.9002488255500793,
        "    if not s.isalpha() or not s.islower():\n        return 'Error: Invalid Input. Please enter only lowercase alphabets.'\n    if len(s) < 3:\n        return False\n    alphabets_count = {}\n    sets = set()\n    for i in range(len(s) - 2):\n        subset = s[i:i + 3]\n        if subset in sets or subset[0] == subset[1] or subset[1] == subset[2]:\n            return False\n        sets.add(subset)\n        for c in subset:\n            if c in alphabets_count:\n                alphabets_count[c] += 1\n            else:\n                alphabets_count[c] = 1\n    count_even = list(filter(lambda c: c % 2 == 0, alphabets_count.values()))\n    count_odd = list(filter(lambda c: c % 2 != 0, alphabets_count.values()))\n    return len(count_odd) == 0 and len(count_even) <= 3"
      ],
      [
        0.8958139419555664,
        "    if len(set((s[i:i + 3] for i in range(len(s))))) < len(s) - 2:\n        return False"
      ]
    ],
    "HumanEval/81": [
      [
        0.9334306716918945,
        "    elif 80 <= numerical_grade < 90:\n        letter_grade = 'B'\n        gpa = 3.0 + (numerical_grade - 80) / 10\n    elif 70 <= numerical_grade < 80:\n        letter_grade = 'C'\n        gpa = 2.0 + (numerical_grade - 70) / 10\n    elif 60 <= numerical_grade < 70:\n        letter_grade = 'D'\n        gpa = 1.0 + (numerical_grade - 60) / 10\n    else:\n        letter_grade = 'F'\n        gpa = 0.0"
      ],
      [
        0.9325463771820068,
        "    if numerical_grade >= 90:\n        letter_grade = 'A'\n        gpa = 4.0\n    elif 80 <= numerical_grade < 90:\n        letter_grade = 'B'\n        gpa = 3.0 + (numerical_grade - 80) / 10\n    elif 70 <= numerical_grade < 80:\n        letter_grade = 'C'\n        gpa = 2.0 + (numerical_grade - 70) / 10\n    elif 60 <= numerical_grade < 70:\n        letter_grade = 'D'\n        gpa = 1.0 + (numerical_grade - 60) / 10\n    else:\n        letter_grade = 'F'\n        gpa = 0.0\n    return (letter_grade, round(gpa, 2))"
      ],
      [
        0.9322755336761475,
        "    if numerical_grade >= 90:\n        letter_grade = 'A'\n        gpa = 4.0\n    elif 80 <= numerical_grade < 90:\n        letter_grade = 'B'\n        gpa = 3.0 + (numerical_grade - 80) / 10\n    elif 70 <= numerical_grade < 80:\n        letter_grade = 'C'\n        gpa = 2.0 + (numerical_grade - 70) / 10\n    elif 60 <= numerical_grade < 70:\n        letter_grade = 'D'\n        gpa = 1.0 + (numerical_grade - 60) / 10\n    else:\n        letter_grade = 'F'\n        gpa = 0.0"
      ],
      [
        0.9318190813064575,
        "    elif 70 <= numerical_grade < 80:\n        letter_grade = 'C'\n        gpa = 2.0 + (numerical_grade - 70) / 10\n    elif 60 <= numerical_grade < 70:\n        letter_grade = 'D'\n        gpa = 1.0 + (numerical_grade - 60) / 10\n    else:\n        letter_grade = 'F'\n        gpa = 0.0"
      ],
      [
        0.9263331890106201,
        "    elif gpa >= 3.7:\n        return 'A-'\n    elif gpa >= 3.3:\n        return 'B+'\n    elif gpa >= 3.0:\n        return 'B'\n    elif gpa >= 2.7:\n        return 'B-'\n    elif gpa >= 2.3:\n        return 'C+'\n    elif gpa >= 2.0:\n        return 'C'\n    elif gpa >= 1.7:\n        return 'C-'\n    elif gpa >= 1.3:\n        return 'D+'\n    elif gpa >= 1.0:\n        return 'D'\n    else:\n        return 'F'"
      ],
      [
        0.925186812877655,
        "    elif 60 <= numerical_grade < 70:\n        letter_grade = 'D'\n        gpa = 1.0 + (numerical_grade - 60) / 10\n    else:\n        letter_grade = 'F'\n        gpa = 0.0"
      ],
      [
        0.9245609045028687,
        "    try:\n        num_grade = float(num_grade)\n        assert 0 <= num_grade <= 100\n    except ValueError:\n        return 'Error: Grade must be a numerical value.'\n    except AssertionError:\n        return 'Error: Grade must be in the range 0 - 100.'\n    if num_grade >= 90:\n        letter = 'A'\n    elif num_grade >= 80:\n        letter = 'B'\n    elif num_grade >= 70:\n        letter = 'C'\n    elif num_grade >= 60:\n        letter = 'D'\n    else:\n        letter = 'F'\n    if letter != 'F':\n        if num_grade % 10 >= 7:\n            letter += '+'\n        elif num_grade % 10 < 3:\n            letter += '-'\n    return letter"
      ],
      [
        0.9230833053588867,
        "    try:\n        num_grade = float(num_grade)\n        assert 0 <= num_grade <= 100\n    except ValueError:\n        return 'Error: Grade must be a numerical value.'\n    except AssertionError:\n        return 'Error: Grade must be in the range 0 - 100.'\n    letter = 'A' if num_grade >= 90 else 'B' if num_grade >= 80 else 'C' if num_grade >= 70 else 'D' if num_grade >= 60 else 'F'\n    if letter != 'F':\n        letter = letter + '+' if num_grade % 10 >= 7 else letter + '-' if num_grade % 10 < 3 else letter\n    return letter"
      ],
      [
        0.922905683517456,
        "    if gpa >= 4.0:\n        return 'A'\n    elif gpa >= 3.7:\n        return 'A-'\n    elif gpa >= 3.3:\n        return 'B+'\n    elif gpa >= 3.0:\n        return 'B'\n    elif gpa >= 2.7:\n        return 'B-'\n    elif gpa >= 2.3:\n        return 'C+'\n    elif gpa >= 2.0:\n        return 'C'\n    elif gpa >= 1.7:\n        return 'C-'\n    elif gpa >= 1.3:\n        return 'D+'\n    elif gpa >= 1.0:\n        return 'D'\n    else:\n        return 'F'"
      ],
      [
        0.922905683517456,
        "    if gpa >= 4.0:\n        return 'A'\n    elif gpa >= 3.7:\n        return 'A-'\n    elif gpa >= 3.3:\n        return 'B+'\n    elif gpa >= 3.0:\n        return 'B'\n    elif gpa >= 2.7:\n        return 'B-'\n    elif gpa >= 2.3:\n        return 'C+'\n    elif gpa >= 2.0:\n        return 'C'\n    elif gpa >= 1.7:\n        return 'C-'\n    elif gpa >= 1.3:\n        return 'D+'\n    elif gpa >= 1.0:\n        return 'D'\n    else:\n        return 'F'"
      ]
    ],
    "HumanEval/82": [
      [
        0.9385717511177063,
        "    length = len(string)\n    if is_prime(length):\n        return True\n    else:\n        return False"
      ],
      [
        0.9293311238288879,
        "    length = len(string)\n    return is_prime(length)"
      ],
      [
        0.929328203201294,
        "    length = len(string)\n    return is_prime(length)"
      ],
      [
        0.9211979508399963,
        "    return is_prime(len(string))"
      ],
      [
        0.9189767837524414,
        "    assert is_prime(4) == 'no'\n    assert is_prime(3) == 'yes'\n    assert is_prime(8) == 'no'"
      ],
      [
        0.9177343845367432,
        "    for i in range(2, math.isqrt(length) + 1):\n        if length % i == 0:\n            return 'Composite'\n    else:\n        return 'Prime'"
      ],
      [
        0.9174209237098694,
        "    length = len(array)\n    if is_prime(length):\n        print('The length of the array is a prime number.')\n    else:\n        print('The length of the array is a composite number.')"
      ],
      [
        0.9164505004882812,
        "    if is_prime(length):\n        print('The length of the array is a prime number.')\n    else:\n        print('The length of the array is a composite number.')"
      ],
      [
        0.9147790670394897,
        "    if is_prime(length):\n        return True\n    else:\n        return False"
      ],
      [
        0.9142241477966309,
        "    if n > 1:\n        for i in range(2, n):\n            if n % i == 0:\n                is_prime = 'No'\n                break\n        else:\n            is_prime = 'Yes'\n    elif n == 1:\n        is_prime = 'No'\n    else:\n        return 'Error: Input should be greater than 0'"
      ]
    ],
    "HumanEval/83": [
      [
        0.9218134880065918,
        "    start = 10 ** (n - 1)\n    end = 10 ** n\n    numbers_with_one_ends = [i for i in range(start, end) if str(i)[0] == '1' or str(i)[-1] == '1']\n    return numbers_with_one_ends"
      ],
      [
        0.9218064546585083,
        "    start = 10 ** (n - 1)\n    end = 10 ** n\n    numbers_with_one_ends = [i for i in range(start, end) if str(i)[0] == '1' or str(i)[-1] == '1']\n    return numbers_with_one_ends"
      ],
      [
        0.9104087948799133,
        "    for num in range(10 ** (n - 1), upper_limit, step):\n        str_num = str(num)\n        if str_num[0] == str_num[-1] == '1' and (not any((digit in unwanted_digits for digit in str_num))):\n            count += 1"
      ],
      [
        0.9076025485992432,
        "    if n <= 0 or not isinstance(n, int):\n        return 'The first parameter must be a positive integer.'\n    if n == 1:\n        return 'The function is not applicable for n = 1 because such a number cannot end and start with 1'\n    if x < 0 or y < 0 or (not isinstance(x, int)) or (not isinstance(y, int)):\n        return 'The second and third parameters must be non-negative integers.'\n    start = 10 ** (n - 1) + 1\n    end = 10 ** n\n    total = 0\n    for num in range(start, end, 15):\n        str_num = str(num)\n        if str_num[0] == str_num[-1] == '1' and str(x) not in str_num and (str(y) not in str_num):\n            total += 1\n    return total"
      ],
      [
        0.9026767611503601,
        "    if n == 1:\n        return 'The function is not applicable for n = 1 because such a number cannot end and start with 1'"
      ],
      [
        0.9016861319541931,
        "    start, end = (10 ** (n - 1), 10 ** n)\n    counter = 0\n    for i in range(start, end):\n        if int(str(i)[0]) == 1 or int(str(i)[-1]) == 1:\n            for prime in primes:\n                if i % prime == 0:\n                    counter += 1\n                    break\n    return counter"
      ],
      [
        0.901678204536438,
        "    start, end = (10 ** (n - 1), 10 ** n)\n    counter = 0\n    for i in range(start, end):\n        if int(str(i)[0]) == 1 or int(str(i)[-1]) == 1:\n            for prime in primes:\n                if i % prime == 0:\n                    counter += 1\n                    break\n    return counter"
      ],
      [
        0.8977203369140625,
        "    start = 10 ** (n - 1) + 1\n    end = 10 ** n\n    step = 10 if n == 1 else 100\n    numbers = list(range(start, end, step))\n    numbers.extend(list(range(start - 1, end - 1, step)))\n    count = 0\n    for num in numbers:\n        if is_prime(num) or is_fibonacci(num):\n            count += 1\n    return count"
      ],
      [
        0.890810489654541,
        "    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)"
      ],
      [
        0.8907747268676758,
        "    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)"
      ]
    ],
    "HumanEval/84": [
      [
        0.9075460433959961,
        "    binary = []\n    while n > 0:\n        binary.append(n % 2)\n        n = n // 2\n    binary = binary[::-1]\n    binary = ''.join(map(str, binary))\n    return binary"
      ],
      [
        0.9069971442222595,
        "    num_as_binary = bin(int(num))[2:]\n    return num_as_binary"
      ],
      [
        0.9067275524139404,
        "    binary = bin(num)\n    return binary[2:]"
      ],
      [
        0.90666264295578,
        "    if num < 100 or num > 999:\n        return 'Invalid input. The number must be a three-digit number.'\n    binary = ''\n    while num > 0:\n        binary = str(num % 2) + binary\n        num //= 2\n    binary = binary.zfill(9)\n    return binary"
      ],
      [
        0.9066399335861206,
        "    if n == 0:\n        return 0\n    s = ''\n    while n > 0:\n        if n % 2 == 0:\n            s = '0' + s\n        else:\n            s = '1' + s\n        n = n // 2\n    return s"
      ],
      [
        0.9066122770309448,
        "    bin = []\n    while n != 0:\n        bin.append(n % 2)\n        n = n // 2\n    return ''.join((str(i) for i in bin[::-1]))"
      ],
      [
        0.9060823917388916,
        "    binary = ''\n    if n == 0:\n        return '0'\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary"
      ],
      [
        0.9057472348213196,
        "    result = []\n    while n > 0:\n        result.append(n % 2)\n        n //= 2\n    return ''.join((str(x) for x in reversed(result)))"
      ],
      [
        0.9057084321975708,
        "    if num == 0:\n        return '0'\n    binary = ''\n    num = abs(num)\n    while num > 0:\n        binary = str(num % 2) + binary\n        num = num // 2\n    return binary"
      ],
      [
        0.9057022929191589,
        "    binary = ''\n    stack = []\n    while n > 0:\n        stack.append(n % 2)\n        n = n // 2\n    while stack:\n        binary += str(stack.pop())\n    return binary"
      ]
    ],
    "HumanEval/85": [
      [
        0.9330551624298096,
        "                for i in range(0, len(lst), 2):\n                    if isinstance(lst[i], int):\n                        if lst[i] % 2 != 0:\n                            result += lst[i]\n                    else:\n                        return 'Error: List contains non-integer element.'"
      ],
      [
        0.9330496788024902,
        "                for i in range(0, len(lst), 2):\n                    if isinstance(lst[i], int):\n                        if lst[i] % 2 != 0:\n                            result += lst[i]\n                    else:\n                        return 'Error: List contains non-integer element.'"
      ],
      [
        0.932725727558136,
        "    return sum((x for x in lst if x % 2 == 0))"
      ],
      [
        0.9295152425765991,
        "    sum = 0\n    for num in lst:\n        if num % 2 == 0:\n            sum += num\n    return sum"
      ],
      [
        0.9295117855072021,
        "    sum = 0\n    for num in lst:\n        if num % 2 == 0:\n            sum += num\n    return sum"
      ],
      [
        0.9295116066932678,
        "    sum = 0\n    for num in lst:\n        if num % 2 == 0:\n            sum += num\n    return sum"
      ],
      [
        0.9291999340057373,
        "    return sum((num for num in lst if num % 2 == 0))"
      ],
      [
        0.9281501173973083,
        "            try:\n                for i in range(0, len(lst), 2):\n                    if isinstance(lst[i], int):\n                        if lst[i] % 2 != 0:\n                            result += lst[i]\n                    else:\n                        return 'Error: List contains non-integer element.'\n            except Exception as e:\n                return f'An unexpected error occurred: {str(e)}'"
      ],
      [
        0.9281338453292847,
        "            try:\n                for i in range(0, len(lst), 2):\n                    if isinstance(lst[i], int):\n                        if lst[i] % 2 != 0:\n                            result += lst[i]\n                    else:\n                        return 'Error: List contains non-integer element.'\n            except Exception as e:\n                return f'An unexpected error occurred: {str(e)}'"
      ],
      [
        0.9260724782943726,
        "    total = 0\n    for num in lst:\n        if num % 2 == 0:\n            total += num\n    return total"
      ]
    ],
    "HumanEval/86": [
      [
        0.9323215484619141,
        "    words = s.split()\n    for i, word in enumerate(words):\n        chars = list(word)\n        chars.sort()\n        words[i] = ''.join(chars)\n    s = ' '.join(words)\n    return s"
      ],
      [
        0.9305096864700317,
        "    words = s.split()\n    sorted_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(sorted_words)"
      ],
      [
        0.9284158945083618,
        "    words = s.split(' ')\n    sorted_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(sorted_words)"
      ],
      [
        0.9268074631690979,
        "    unscrambled = ''\n    words = s.split(' ')\n    for i in range(len(words)):\n        unscrambled += intricate_sort(words[i]) + ' '\n    return unscrambled[:len(unscrambled) - 1]"
      ],
      [
        0.922571063041687,
        "    sorted_words = [custom_sort(word) for word in s.split(' ')]\n    return ' '.join(sorted_words)"
      ],
      [
        0.9225708246231079,
        "    sorted_words = [custom_sort(word) for word in s.split(' ')]\n    return ' '.join(sorted_words)"
      ],
      [
        0.9222714900970459,
        "    words_list = s.split(' ')\n    ordered_words_list = [custom_order(word) for word in words_list]\n    ordered_s = ' '.join(ordered_words_list)\n    return ordered_s"
      ],
      [
        0.9222686290740967,
        "    words_list = s.split(' ')\n    ordered_words_list = [custom_order(word) for word in words_list]\n    ordered_s = ' '.join(ordered_words_list)\n    return ordered_s"
      ],
      [
        0.9218586683273315,
        "    words = re.split('(\\\\W+)', s)\n    rearranged_words = [''.join(sorted(word, key=str.lower)) for word in words]\n    return ''.join(rearranged_words)"
      ],
      [
        0.9196187257766724,
        "    words = s.split(' ')\n    intricate_sorted = ''\n    for i in range(len(words)):\n        chars = list(words[i])\n        chars.sort(key=lambda x: (compute_char_freq(words[i])[x], ord(x)))\n        words[i] = ''.join(chars)\n        intricate_sorted += words[i] + ' '\n    return intricate_sorted[:len(intricate_sorted) - 1]"
      ]
    ],
    "HumanEval/87": [
      [
        0.9319692254066467,
        "    result = []\n    for row_index, row in enumerate(lst):\n        for column_index, element in enumerate(row):\n            if element == x:\n                result.append((row_index, column_index))\n    result.sort(key=lambda a: (a[0], -a[1]))\n    return result"
      ],
      [
        0.9151132106781006,
        "    for row_index, row in enumerate(lst):\n        for column_index, element in enumerate(row):\n            if element == x:\n                result.append((row_index, column_index))"
      ],
      [
        0.9072812795639038,
        "    row_index = None\n    col_index = None\n    for row in range(len(lst)):\n        for col in range(len(lst[row])):\n            if lst[row][col] == item:\n                row_index = row\n                col_index = col\n    if row_index is None and col_index is None:\n        return None\n    else:\n        return (row_index, col_index)"
      ],
      [
        0.9071722030639648,
        "    if is_reversed:\n        matrix = [row[::-1] for row in matrix]\n    coordinates = []\n    for i in range(len(matrix)):\n        for j in range(len(matrix[i])):\n            if matrix[i][j] == x:\n                tuple = [i, j] if not is_reversed else [i, len(matrix[i]) - j - 1]\n                coordinates.append(tuple)\n    coordinates.sort(key=lambda x: (x[0], x[1]))\n    return coordinates"
      ],
      [
        0.9048237800598145,
        "    for row in range(len(lst)):\n        for col in range(len(lst[row])):\n            if lst[row][col] == item:\n                row_index = row\n                col_index = col"
      ],
      [
        0.9023923873901367,
        "    for i, row in enumerate(lst):\n        if value in row:\n            return (i, row.index(value))"
      ],
      [
        0.9023923873901367,
        "    for i, row in enumerate(lst):\n        if value in row:\n            return (i, row.index(value))"
      ],
      [
        0.9013012647628784,
        "        for col in range(len(lst[row])):\n            if lst[row][col] == item:\n                row_index = row\n                col_index = col"
      ],
      [
        0.9000331163406372,
        "    for i in range(len(arr)):\n        for j in range(len(arr[i])):\n            if arr[i][j] == x:\n                return (i, j)"
      ],
      [
        0.900023877620697,
        "    for i in range(len(arr)):\n        for j in range(len(arr[i])):\n            if arr[i][j] == x:\n                return (i, j)"
      ]
    ],
    "HumanEval/88": [
      [
        0.9318153858184814,
        "    elif (first_element + last_element) % 2 == 0:\n        array.sort(reverse=True)\n    else:\n        array = sorted((i for i in array if i % 2 == 0)) + [i for i in array if i % 2 != 0]"
      ],
      [
        0.9314126968383789,
        "    if not array or len(array) == 1:\n        return array\n    copy = array[:]\n    copy.sort()\n    if (copy[0] + copy[-1]) % 2 == 0:\n        copy.reverse()\n    return copy"
      ],
      [
        0.9298883080482483,
        "    if len(array) < 2:\n        return array\n    first = array[0]\n    penultimate = array[-2]\n    sum_value = first + penultimate\n    is_even_sum = sum_value % 2 == 0\n    is_sum_divisible_by_6 = sum_value % 6 == 0\n    is_sum_divisible_by_4 = sum_value % 4 == 0\n    even_section = []\n    odd_section = []\n    diff_section = []\n    for num in array:\n        is_even = num % 2 == 0\n        if is_even:\n            even_section.append(num)\n        elif is_even_sum:\n            odd_section.append(num)\n        else:\n            diff_section.append(num)\n    if is_sum_divisible_by_6:\n        even_section.sort()\n        odd_section.sort()\n        diff_section.sort()\n    elif is_sum_divisible_by_4:\n        even_section.sort(reverse=True)\n        odd_section.sort(reverse=True)\n        diff_section.sort(reverse=True)\n    else:\n        even_section.sort()\n    return even_section + odd_section + diff_section"
      ],
      [
        0.9252099990844727,
        "    if (first_element + last_element) % 3 == 0:\n        array.sort()\n    elif (first_element + last_element) % 2 == 0:\n        array.sort(reverse=True)\n    else:\n        array = sorted((i for i in array if i % 2 == 0)) + [i for i in array if i % 2 != 0]"
      ],
      [
        0.9235507249832153,
        "    first_element = array[0] if array else 0\n    last_element = array[-1] if array else 0\n    is_first_odd = first_element % 2 == 1\n    is_last_odd = last_element % 2 == 1\n    if is_first_odd and is_last_odd:\n        grouping = 'odd_group'\n    elif not is_first_odd and (not is_last_odd):\n        grouping = 'even_group'\n    else:\n        grouping = 'mixed_group'\n    if (first_element + last_element) % 3 == 0:\n        array.sort()\n    elif (first_element + last_element) % 2 == 0:\n        array.sort(reverse=True)\n    else:\n        array = sorted((i for i in array if i % 2 == 0)) + [i for i in array if i % 2 != 0]\n    return {'even_group': [], 'odd_group': [], 'mixed_group': []}.update({grouping: array})"
      ],
      [
        0.920208215713501,
        "    even_numbers = []\n    for number in numbers:\n        if number % 2 == 0:\n            even_numbers.append(number)\n    if len(even_numbers) == 0:\n        return []\n    even_numbers.sort()\n    sorted_numbers = []\n    for number in even_numbers:\n        sorted_numbers.append(number)\n    odd_numbers = []\n    for number in numbers:\n        if number % 2 != 0:\n            odd_numbers.append(number)\n    odd_numbers.sort(reverse=True)\n    for number in odd_numbers:\n        sorted_numbers.append(number)\n    return sorted_numbers"
      ],
      [
        0.9181340932846069,
        "    even_numbers = []\n    odd_numbers = []\n    for num in numbers:\n        if num % 2 == 0:\n            even_numbers.append(num)\n        else:\n            odd_numbers.append(num)\n    even_numbers.sort()\n    odd_numbers.sort(reverse=True)\n    sorted_list = even_numbers + odd_numbers\n    return sorted_list"
      ],
      [
        0.9167149066925049,
        "    filtered_arr = [num for num in arr if num % 2 != 0]\n    sorted_arr = sorted(filtered_arr, reverse=True)\n    sum_odd_numbers = sum(sorted_arr)\n    return (sorted_arr, sum_odd_numbers)"
      ],
      [
        0.9143692851066589,
        "    odds = []\n    evens = []\n    for num in numbers:\n        if num % 2 == 0:\n            evens.append(num)\n        else:\n            odds.append(num)\n    evens.sort(reverse=True)\n    return odds + evens"
      ],
      [
        0.9125405550003052,
        "    odd_numbers = [num for num in my_list if num % 2 != 0]\n    even_numbers = [num for num in my_list if num % 2 == 0]\n    for i in range(len(odd_numbers) - 1):\n        for j in range(len(odd_numbers) - 1):\n            if odd_numbers[j] > odd_numbers[j + 1]:\n                odd_numbers[j], odd_numbers[j + 1] = (odd_numbers[j + 1], odd_numbers[j])\n    for i in range(len(even_numbers) - 1):\n        for j in range(len(even_numbers) - 1):\n            if even_numbers[j] > even_numbers[j + 1]:\n                even_numbers[j], even_numbers[j + 1] = (even_numbers[j + 1], even_numbers[j])\n    return even_numbers + odd_numbers"
      ]
    ],
    "HumanEval/89": [
      [
        0.9239885807037354,
        "    encrypted_string = ''\n    for i in range(len(string)):\n        char = string[i]\n        encrypted_string += chr(ord(char) + 2)\n    return encrypted_string"
      ],
      [
        0.9213706254959106,
        "    encrypted_string = ''\n    for char in string:\n        if char.isalpha():\n            upper_case_max = 90\n            lower_case_max = 122\n            ascii_value = ord(char)\n            shifted_asc = ascii_value + shift\n            if shifted_asc > upper_case_max and char.isupper():\n                shifted_asc = 64 + (shifted_asc - upper_case_max)\n            elif shifted_asc > lower_case_max and char.islower():\n                shifted_asc = 96 + (shifted_asc - lower_case_max)\n            encrypted_string += chr(shifted_asc)\n        else:\n            encrypted_string += char\n    return encrypted_string"
      ],
      [
        0.9203897714614868,
        "    cipher = ''\n    for char in string:\n        ascii_val = ord(char)\n        encrypted_val = ascii_val + 2\n        encrypted_char = chr(encrypted_val)\n        cipher += encrypted_char\n    return cipher"
      ],
      [
        0.9197925329208374,
        "    encrypted_string = ''\n    for char in string:\n        if char == ' ':\n            encrypted_string += ' '\n        else:\n            ascii_value = ord(char)\n            shifted_ascii_value = ascii_value + shift\n            if shifted_ascii_value > ord('Z'):\n                shifted_ascii_value -= 26\n            encrypted_string += chr(shifted_ascii_value)\n    return encrypted_string"
      ],
      [
        0.9183432459831238,
        "    rotated_text = ''\n    for letter in text:\n        char_code = ord(letter)\n        char_code += 2\n        if char_code > ord('z'):\n            char_code -= 26\n        rotated_text += chr(char_code)\n    return rotated_text"
      ],
      [
        0.9173702001571655,
        "    for letter in text:\n        char_code = ord(letter)\n        char_code += 2\n        if char_code > ord('z'):\n            char_code -= 26\n        rotated_text += chr(char_code)"
      ],
      [
        0.9171622395515442,
        "    for char in string:\n        if char.isalpha():\n            upper_case_max = 90\n            lower_case_max = 122\n            ascii_value = ord(char)\n            shifted_asc = ascii_value + shift\n            if shifted_asc > upper_case_max and char.isupper():\n                shifted_asc = 64 + (shifted_asc - upper_case_max)\n            elif shifted_asc > lower_case_max and char.islower():\n                shifted_asc = 96 + (shifted_asc - lower_case_max)\n            encrypted_string += chr(shifted_asc)\n        else:\n            encrypted_string += char"
      ],
      [
        0.9171584844589233,
        "    encrypted = ''\n    for char in string:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n        else:\n            encrypted += char\n    return encrypted"
      ]
    ],
    "HumanEval/90": [
      [
        0.9512578248977661,
        "    if len(lst) < 2:\n        return None\n    smallest = float('inf')\n    next_smallest = float('inf')\n    for i in range(0, len(lst)):\n        if lst[i] < smallest:\n            next_smallest = smallest\n            smallest = lst[i]\n        elif lst[i] > smallest and lst[i] < next_smallest:\n            next_smallest = lst[i]\n    return None if next_smallest == float('inf') else next_smallest"
      ],
      [
        0.9447739720344543,
        "    if not lst or len(lst) < 2:\n        return None\n    smallest = second_smallest = float('inf')\n    for element in lst:\n        if element < smallest:\n            second_smallest = smallest\n            smallest = element\n        elif smallest < element < second_smallest:\n            second_smallest = element\n    return None if second_smallest == float('inf') else second_smallest"
      ],
      [
        0.9356889724731445,
        "    if len(lst) < 2:\n        return None\n    first_min = second_min = float('inf')\n    for num in lst:\n        if num < first_min:\n            second_min = first_min\n            first_min = num\n        elif num < second_min and num != first_min:\n            second_min = num\n    if second_min == float('inf'):\n        return None\n    return second_min"
      ],
      [
        0.9331862330436707,
        "    if len(arr) < 2:\n        return None\n    smallest = float('inf')\n    second_smallest = float('inf')\n    for num in arr:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n    return second_smallest if second_smallest != float('inf') else None"
      ],
      [
        0.9324913620948792,
        "    if len(lst) < 2:\n        return None\n    lst.sort()\n    smallest = lst[0]\n    for el in lst:\n        if el > smallest:\n            return el\n    return None"
      ],
      [
        0.9307579398155212,
        "    if len(my_list) < 2:\n        return None\n    smallest = float('inf')\n    second_smallest = float('inf')\n    for num in my_list:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n    if second_smallest == float('inf'):\n        return None\n    return second_smallest"
      ],
      [
        0.928528904914856,
        "    if len(lst) < 2:\n        return None\n    largest = float('-inf')\n    second_largest = float('-inf')\n    for num in lst:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n    return second_largest"
      ],
      [
        0.9276971817016602,
        "    if len(lst) < 2:\n        return None\n    largest = float('-inf')\n    second_largest = float('-inf')\n    for num in lst:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num != largest:\n            second_largest = num\n    return second_largest"
      ],
      [
        0.9274832606315613,
        "    if len(lst) < 2:\n        return None\n    max_val = second_max = float('-inf')\n    unique_elements = set(lst)\n    if len(unique_elements) < 2:\n        return None\n    for num in unique_elements:\n        if num > max_val:\n            second_max = max_val\n            max_val = num\n        elif num > second_max:\n            second_max = num\n    return second_max"
      ],
      [
        0.9230998158454895,
        "    max_num = second_max = float('-inf')\n    for num in lst:\n        if num > max_num:\n            second_max, max_num = (max_num, num)\n        elif max_num > num > second_max:\n            second_max = num\n    if second_max == float('-inf'):\n        return None\n    return second_max"
      ]
    ],
    "HumanEval/91": [
      [
        0.9441654682159424,
        "    sentences = [sentence.strip() for sentence in re.split('[.!?]', S) if sentence.strip()]\n    boring_count = 0\n    exciting_count = 0\n    for sentence in sentences:\n        if sentence.startswith('I'):\n            boring_count += 1\n        if sentence.endswith('!'):\n            exciting_count += 1\n    return (boring_count, exciting_count)"
      ],
      [
        0.9334797859191895,
        "    boring_sent_count = 0\n    exciting_sent_count = 0\n    sentences = re.split('\\\\.|\\\\?|\\\\!', S)\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I'):\n            boring_sent_count += 1\n        if sentence.endswith('!'):\n            exciting_sent_count += 1\n    return (boring_sent_count, exciting_sent_count)"
      ],
      [
        0.9314954876899719,
        "    sentences = [s.strip() for s in S.replace('!', '!. ').replace('.', '. ').replace('?', '? ').split() if s]\n    mundane_count = sum((s.startswith('I') for s in sentences))\n    enthusiastic_count = sum((s.endswith('!') for s in sentences))\n    return (mundane_count, enthusiastic_count)"
      ],
      [
        0.9140270352363586,
        "    sentences = [sentence.strip() for sentence in re.split('[.!?]', S) if sentence]\n    dull_count = len([sentence for sentence in sentences if sentence.startswith('He')])\n    excited_count = len([sentence for sentence in sentences if sentence.endswith('?')])\n    return (dull_count, excited_count)"
      ],
      [
        0.9137551784515381,
        "    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I'):\n            boring_sent_count += 1\n        if sentence.endswith('!'):\n            exciting_sent_count += 1"
      ],
      [
        0.9127048254013062,
        "    for sentence in sentences:\n        if sentence.startswith('I'):\n            boring_count += 1\n        if sentence.endswith('!'):\n            exciting_count += 1"
      ],
      [
        0.9090558290481567,
        "        if sentence.startswith('I'):\n            boring_count += 1"
      ],
      [
        0.9035824537277222,
        "        if sentence.startswith('I'):\n            boring_sent_count += 1"
      ],
      [
        0.8916347026824951,
        "    count = 0\n    sentence = sentence.lower()\n    word = word.lower()\n    for i in range(len(sentence)):\n        if sentence[i] == ' ' or sentence[i] in ['.', ',', '?', '!', ';', ':']:\n            if sentence[i - len(word):i] == word:\n                count += 1\n    if sentence[len(sentence) - len(word):] == word:\n        count += 1\n    return count"
      ],
      [
        0.8905940055847168,
        "    count = 0\n    for i in range(len(sentence)):\n        if sentence[i] == ' ':\n            count += 1\n    count += 1\n    return count"
      ]
    ],
    "HumanEval/92": [
      [
        0.913934051990509,
        "    sum = x + y + z\n    if sum % 2 == 0:\n        return True\n    else:\n        return False"
      ],
      [
        0.9138966202735901,
        "    sum = x + y + z\n    if sum % 2 == 0:\n        return True\n    else:\n        return False"
      ],
      [
        0.9096477627754211,
        "    if x == y and y == z:\n        return True\n    else:\n        return False"
      ],
      [
        0.9096477627754211,
        "    if x == y and y == z:\n        return True\n    else:\n        return False"
      ],
      [
        0.9059178829193115,
        "    if isinstance(x, (int, complex)) and isinstance(y, (int, complex)) and isinstance(z, (int, complex)):\n        if x ** 2 + y ** 2 == z ** 2:\n            return True\n        else:\n            raise ValueError('Provided values cannot satisfy the equation: x^2 + y^2 = z^2')\n    else:\n        raise TypeError('Inputs must be integers or complex numbers')"
      ],
      [
        0.9059178829193115,
        "    if isinstance(x, (int, complex)) and isinstance(y, (int, complex)) and isinstance(z, (int, complex)):\n        if x ** 2 + y ** 2 == z ** 2:\n            return True\n        else:\n            raise ValueError('Provided values cannot satisfy the equation: x^2 + y^2 = z^2')\n    else:\n        raise TypeError('Inputs must be integers or complex numbers')"
      ],
      [
        0.9043641090393066,
        "    if x + y > z and x + z > y and (y + z > x):\n        return True\n    else:\n        return False"
      ],
      [
        0.9043641090393066,
        "    if x + y > z and x + z > y and (y + z > x):\n        return True\n    else:\n        return False"
      ],
      [
        0.9022274017333984,
        "        if -100 <= a <= 100 and -100 <= b <= 100 and (-100 <= c <= 100):\n            return a + b + c\n        elif isinstance(a, int):\n            return 'Numbers are not within the range of -100 to 100.'\n        else:\n            return 'Numbers are not within the range of -100.0 to 100.0.'"
      ],
      [
        0.9020248651504517,
        "    if not type(x) == type(y) == type(z) == int:\n        return 'Error: Inputs must be integers.'"
      ]
    ],
    "HumanEval/93": [
      [
        0.9262090921401978,
        "    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    all_chars = string.ascii_lowercase + string.ascii_uppercase\n    vowels_shifted = deque(vowels)\n    vowels_shifted.rotate(-shift)\n    con_shifted = deque(consonants)\n    con_shifted.rotate(-shift)\n    trans_lowercase = str.maketrans(vowels + consonants, ''.join(vowels_shifted + con_shifted))\n    trans_uppercase = str.maketrans(vowels.upper() + consonants.upper(), ''.join(vowels_shifted + con_shifted).upper())\n    trans = {**trans_lowercase, **trans_uppercase}\n    swapped_message = message.swapcase()\n    shifted_message = swapped_message.translate(trans)\n    encrypted_message = ''\n    for i, char in enumerate(shifted_message):\n        if char not in string.ascii_letters:\n            encrypted_message += char\n            continue\n        encrypted_message += all_chars[(all_chars.index(char) + i * shift * ord(char)) % len(all_chars)]\n    return encrypted_message"
      ],
      [
        0.9236932992935181,
        "    for i in range(len(message)):\n        if message[i] == ' ':\n            encoded_message += ' '\n        elif message[i].lower() not in vowels:\n            if message[i].islower():\n                encoded_message += alphabet[(alphabet.index(message[i]) + shift) % 26]\n            else:\n                encoded_message += alphabet[(alphabet.index(message[i].lower()) + shift) % 26].upper()\n        elif message[i].islower():\n            encoded_message += alphabet[(alphabet.index(message[i]) - shift) % 26]\n        else:\n            encoded_message += alphabet[(alphabet.index(message[i].lower()) - shift) % 26].upper()"
      ],
      [
        0.9213772416114807,
        "    vowels = 'aeiou'\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encoded_message = ''\n    for i in range(len(message)):\n        if message[i] == ' ':\n            encoded_message += ' '\n        elif message[i].lower() not in vowels:\n            if message[i].islower():\n                encoded_message += alphabet[(alphabet.index(message[i]) + shift) % 26]\n            else:\n                encoded_message += alphabet[(alphabet.index(message[i].lower()) + shift) % 26].upper()\n        elif message[i].islower():\n            encoded_message += alphabet[(alphabet.index(message[i]) - shift) % 26]\n        else:\n            encoded_message += alphabet[(alphabet.index(message[i].lower()) - shift) % 26].upper()\n    new_message = ''\n    for i in range(len(encoded_message)):\n        if encoded_message[i] != ' ':\n            new_index = (i + 1) * shift * ord(encoded_message[i])\n            while new_index > len(encoded_message) - 1:\n                new_index -= len(encoded_message)\n            new_message += str(new_index) + encoded_message[i]\n        else:\n            new_message += ' '\n    return new_message"
      ],
      [
        0.9210046529769897,
        "    char_map = {chr(i): chr(i + 10) for i in range(97, 123)}\n    encoded_msg = ''\n    for char in message:\n        if char in char_map:\n            encoded_msg += char_map[char]\n        else:\n            encoded_msg += char\n    return encoded_msg"
      ],
      [
        0.9205999374389648,
        "        elif message[i].lower() not in vowels:\n            if message[i].islower():\n                encoded_message += alphabet[(alphabet.index(message[i]) + shift) % 26]\n            else:\n                encoded_message += alphabet[(alphabet.index(message[i].lower()) + shift) % 26].upper()\n        elif message[i].islower():\n            encoded_message += alphabet[(alphabet.index(message[i]) - shift) % 26]\n        else:\n            encoded_message += alphabet[(alphabet.index(message[i].lower()) - shift) % 26].upper()"
      ],
      [
        0.919834315776825,
        "        if message[i] == ' ':\n            encoded_message += ' '\n        elif message[i].lower() not in vowels:\n            if message[i].islower():\n                encoded_message += alphabet[(alphabet.index(message[i]) + shift) % 26]\n            else:\n                encoded_message += alphabet[(alphabet.index(message[i].lower()) + shift) % 26].upper()\n        elif message[i].islower():\n            encoded_message += alphabet[(alphabet.index(message[i]) - shift) % 26]\n        else:\n            encoded_message += alphabet[(alphabet.index(message[i].lower()) - shift) % 26].upper()"
      ],
      [
        0.9170151352882385,
        "    vowels = ('a', 'e', 'i', 'o', 'u')\n    encrypted_word = ''\n    for ch in word:\n        if ch in vowels:\n            if ch == 'u':\n                encrypted_word += 'a'\n            else:\n                encrypted_word += chr(ord(ch) + 1)\n        else:\n            encrypted_word += ch\n    return encrypted_word"
      ],
      [
        0.9167841672897339,
        "    encoded = ''\n    for ch in message:\n        if ch.isalpha():\n            if ch.isupper():\n                encoded += chr((ord(ch) - 65 + 13) % 26 + 65)\n            else:\n                encoded += chr((ord(ch) - 97 + 13) % 26 + 97)\n        else:\n            encoded += ch\n    return encoded"
      ],
      [
        0.916702926158905,
        "    consonants = 'bcdfghjklmnpqrstvwxyz'\n    encoded_s = ''\n    for char in s:\n        if char.lower() in consonants:\n            encoded_s += consonants[(consonants.index(char.lower()) + 1) % len(consonants)]\n        else:\n            encoded_s += char\n    return encoded_s"
      ],
      [
        0.9162760376930237,
        "    encrypted_message = ''\n    for c in message:\n        if c.isalpha():\n            if c >= 'a' and c <= 'z':\n                encrypted_message += chr(219 - ord(c))\n            else:\n                encrypted_message += chr(155 - ord(c))\n        else:\n            encrypted_message += c\n    return encrypted_message"
      ]
    ],
    "HumanEval/94": [
      [
        0.9467540979385376,
        "    max_prime = 0\n    for i in lst:\n        if is_prime(i) and i > max_prime:\n            max_prime = i\n    return sum_digits(max_prime)"
      ],
      [
        0.9381372928619385,
        "    return max((sum_of_digits(i) for i in lst if is_prime(i)))"
      ],
      [
        0.9381181001663208,
        "    return max((sum_of_digits(i) for i in lst if is_prime(i)))"
      ],
      [
        0.9316754937171936,
        "    lst.sort()\n    primes = []\n    for i in lst:\n        if i > 10 and is_prime(i, primes):\n            primes.append(i)\n    return sum(primes)"
      ],
      [
        0.9307544231414795,
        "    largest_prime = None\n    for num in lst:\n        if largest_prime is None or num > largest_prime:\n            if is_prime(num):\n                largest_prime = num\n    return largest_prime"
      ],
      [
        0.9302141666412354,
        "    prime_numbers = []\n    for num in lst:\n        if is_prime(num):\n            prime_numbers.append(num)\n        else:\n            return 'Error: List contains non-prime numbers.'\n    if not prime_numbers:\n        return 'Error: List is empty.'\n    else:\n        return max(prime_numbers)"
      ],
      [
        0.9295162558555603,
        "    prime_numbers = []\n    for num in lst:\n        if is_prime(num):\n            prime_numbers.append(num)\n            if len(prime_numbers) == 3:\n                break\n    return sum(prime_numbers)"
      ],
      [
        0.929330587387085,
        "    for i in lst:\n        if isprime(i):\n            digit_sum = digitSum(i)\n            if isprime(digit_sum) and i > maxPrime:\n                maxPrime = i\n                sumDigits = digit_sum"
      ],
      [
        0.9293210506439209,
        "    for i in lst:\n        if isprime(i):\n            digit_sum = digitSum(i)\n            if isprime(digit_sum) and i > maxPrime:\n                maxPrime = i\n                sumDigits = digit_sum"
      ],
      [
        0.9287527799606323,
        "    lst.sort(reverse=True)\n    result = 0\n    for num in lst:\n        if num % 2 == 0 and (not is_prime(num)) and (not num % 3 == 0) and (not num % 5 == 0) and has_prime_number_of_digits(num):\n            result += num\n    return result"
      ]
    ],
    "HumanEval/95": [
      [
        0.9316221475601196,
        "    if not d:\n        return False\n    lower = 0\n    upper = 0\n    for key in d:\n        if key.islower():\n            lower += 1\n        elif key.isupper():\n            upper += 1\n        else:\n            return False\n    if lower == len(d) or upper == len(d):\n        return True\n    else:\n        return False"
      ],
      [
        0.9312478303909302,
        "    if not bool(dict):\n        return False\n    keys = dict.keys()\n    is_lower = all((key == key.lower() for key in keys))\n    is_upper = all((key == key.upper() for key in keys))\n    if is_lower or is_upper:\n        return True\n    return False"
      ],
      [
        0.9219108819961548,
        "    upper_case = 0\n    lower_case = 0\n    for key in dct:\n        if key.isupper():\n            upper_case += 1\n        elif key.islower():\n            lower_case += 1\n        else:\n            return False\n    return upper_case == len(dct) or lower_case == len(dct)"
      ],
      [
        0.9209568500518799,
        "    if not dct:\n        return False\n    lower_case = sum([k.islower() for k in dct.keys()])\n    upper_case = sum([k.isupper() for k in dct.keys()])\n    is_alpha = sum([k.isalpha() for k in dct.keys()])\n    return is_alpha == len(dct) and (lower_case == len(dct) or upper_case == len(dct))"
      ],
      [
        0.9189454317092896,
        "    for key in dct:\n        if key.isupper():\n            upper_case += 1\n        elif key.islower():\n            lower_case += 1\n        else:\n            return False"
      ],
      [
        0.918137788772583,
        "    if not dct:\n        return False\n    lower_case = sum([k.islower() for k in dct.keys()])\n    upper_case = sum([k.isupper() for k in dct.keys()])\n    return lower_case == len(dct) or upper_case == len(dct)"
      ],
      [
        0.9181094169616699,
        "    if not dct:\n        return False\n    lower_case = sum([k.islower() for k in dct.keys()])\n    upper_case = sum([k.isupper() for k in dct.keys()])\n    return lower_case == len(dct) or upper_case == len(dct)"
      ],
      [
        0.9175105094909668,
        "    if len(dct) == 0:\n        return False\n    lower_case = sum((k.islower() for k in dct.keys()))\n    upper_case = sum((k.isupper() for k in dct.keys()))\n    mix_case = any((not k.isupper() and (not k.islower()) for k in dct.keys()))\n    return not (lower_case == len(dct) or upper_case == len(dct) or mix_case)"
      ],
      [
        0.9155030250549316,
        "    for key in d:\n        if key.islower():\n            lower += 1\n        elif key.isupper():\n            upper += 1\n        else:\n            return False"
      ],
      [
        0.9098288416862488,
        "    if not isinstance(input_dict, dict):\n        raise TypeError('The argument must be a dictionary.')\n    elif not input_dict:\n        return 'The dictionary is empty.'\n    else:\n        return 'The dictionary is not empty.'"
      ]
    ],
    "HumanEval/96": [
      [
        0.9374005794525146,
        "    if not isinstance(n, int) or n < 0:\n        return 'Error: n must be a non-negative integer'\n    primes = []\n    i = 0\n    while i <= n:\n        if is_prime(i):\n            primes.append(i)\n        i += 1\n    return primes"
      ],
      [
        0.9329354763031006,
        "    if n < 2:\n        return []\n    primes = []\n    for possible_prime in range(2, n):\n        is_prime = True\n        for num in range(2, possible_prime):\n            if possible_prime % num == 0:\n                is_prime = False\n        if is_prime:\n            primes.append(possible_prime)\n    return primes"
      ],
      [
        0.9323546290397644,
        "    if n <= 0:\n        return []\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if is_prime(num):\n            primes.append(num)\n        num += 1\n    return primes"
      ],
      [
        0.9322728514671326,
        "    if n <= 0:\n        raise ValueError('The provided number should be a positive integer')\n    return [x for x in range(2, n) if is_prime(x)]"
      ],
      [
        0.9319793581962585,
        "    try:\n        n = int(n)\n        assert n >= 0\n    except ValueError:\n        return 'Error: The input must be an integer.'\n    except AssertionError:\n        return 'Error: The input must be a non-negative integer.'\n    primes = [True for _ in range(n + 1)]\n    p = 2\n    while p ** 2 <= n:\n        if primes[p] is True:\n            for i in range(p ** 2, n + 1, p):\n                primes[i] = False\n        p += 1\n    prime_numbers = [p for p in range(2, n) if primes[p]]\n    return prime_numbers"
      ],
      [
        0.9318251013755798,
        "    count = 0\n    num = 0\n    primes = []\n    while count < n:\n        if is_prime(num):\n            primes.append(num)\n            count += 1\n        num += 1\n    return primes"
      ],
      [
        0.9318135976791382,
        "    if not isinstance(n, int) or n <= 0:\n        return 'Error: The input must be a positive integer'\n    primes = [True] * (n + 1)\n    primes[0] = primes[1] = False\n    p = 2\n    while p * p <= n:\n        if primes[p] == True:\n            for i in range(p * p, n + 1, p):\n                primes[i] = False\n        p += 1\n    return [p for p in range(2, n + 1) if primes[p]]"
      ],
      [
        0.9313969612121582,
        "    num = 2\n    count = 0\n    prime_numbers = []\n    while count < limit:\n        if is_prime(num):\n            prime_numbers.append(num)\n            count += 1\n        num += 1\n    return prime_numbers"
      ],
      [
        0.9309356212615967,
        "    if type(n) != int or n <= 0:\n        raise ValueError('n must be a positive integer greater than zero')\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if is_prime(num):\n            primes.append(num)\n        num += 1\n    return primes"
      ],
      [
        0.9307852983474731,
        "    if n <= 1:\n        return []\n    prime_numbers = []\n    for i in range(2, n + 1):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n        if is_prime:\n            prime_numbers.append(i)\n    return prime_numbers"
      ]
    ],
    "HumanEval/97": [
      [
        0.931093692779541,
        "    last_digit_a = abs(a) % 10\n    last_digit_b = abs(b) % 10\n    return last_digit_a * last_digit_b"
      ],
      [
        0.9117335677146912,
        "    unit_digit1 = num1 % 10\n    unit_digit2 = num2 % 10\n    return unit_digit1 * unit_digit2"
      ],
      [
        0.9036250114440918,
        "    product = 1\n    a_str = str(a)\n    b_str = str(b)\n    for digit in a_str:\n        product *= int(digit)\n    for digit in b_str:\n        product *= int(digit)\n    return product"
      ],
      [
        0.9034533500671387,
        "    a = str(a)\n    b = str(b)\n    last_two_a = int(a[-2:])\n    last_two_b = int(b[-2:])\n    return last_two_a + last_two_b"
      ],
      [
        0.8969472646713257,
        "    if not isinstance(n, int):\n        raise ValueError('Input must be an integer.')\n    if n < 0:\n        n = -n\n    least_digit = n % 10\n    print('The least significant digit of', n, 'is', least_digit)\n    return least_digit"
      ],
      [
        0.8923767805099487,
        "    return last_ten_digits(a * b)"
      ],
      [
        0.8923529386520386,
        "    a = abs(a)\n    b = abs(b)\n    if a == 0 or b == 0:\n        return 'Error: Zero is not allowed as an input'\n    greater = max(a, b)\n    smaller = min(a, b)\n    remainder = greater % smaller\n    return remainder"
      ],
      [
        0.8912255764007568,
        "    a = abs(a)\n    b = abs(b)\n    sign = -1 if (a < 0) ^ (b < 0) else 1\n    a = int(a)\n    b = int(b)\n    product = 0\n    while b > 0:\n        product += a\n        b -= 1\n    product = float(product)\n    product *= sign\n    return product"
      ],
      [
        0.8877585530281067,
        "    elif num1 < 0 or num2 < 0:\n        product = -abs(num1) * abs(num2)\n    else:\n        product = num1 * num2"
      ],
      [
        0.886858344078064,
        "    x = max(min(x, 1000), 1)\n    return x % 10"
      ]
    ],
    "HumanEval/98": [
      [
        0.9478957653045654,
        "    assert 1 <= len(s) <= 1000, 'Invalid string length. It should be between 1 and 1000 characters'\n    vowels = set('AEIOU')\n    count = sum((1 for i in range(0, len(s)) if s[i].isupper() and s[i] in vowels and (i % 2 == 0)))\n    return count"
      ],
      [
        0.9457566738128662,
        "    upper_vowels = ['A', 'E', 'I', 'O', 'U']\n    count = sum((1 for i in range(len(s)) if i % 2 == 0 and s[i] in upper_vowels))\n    return count"
      ],
      [
        0.9451885223388672,
        "    upper_vowels = 'AEIOU'\n    even_letters = s[::2]\n    counter = sum((1 for letter in even_letters if letter in upper_vowels))\n    return counter"
      ],
      [
        0.944034993648529,
        "    upper_vowels = 'AEIOU'\n    return sum((1 for i in range(len(s)) if i % 2 == 0 and s[i] in upper_vowels))"
      ],
      [
        0.9440107345581055,
        "    upper_vowels = 'AEIOU'\n    return sum((1 for i in range(len(s)) if i % 2 == 0 and s[i] in upper_vowels))"
      ],
      [
        0.9327834844589233,
        "    return sum((1 for i, c in enumerate(s) if c.isupper() and c in 'AEIOU' and (i % 2 == 0)))"
      ],
      [
        0.9325428009033203,
        "    assert 1 <= len(s) <= 1000, 'String length should be between 1 and 1000 characters'\n    vow = ['A', 'E', 'I', 'O', 'U']\n    count = sum((1 for i in range(len(s)) if i % 2 == 0 and s[i] in vow))\n    return count"
      ],
      [
        0.9292922019958496,
        "    upper_vowels = 'AEIOU'\n    lower_vowels = 'aeiou'\n    odd_upper, even_lower = (0, 0)\n    for i in range(len(s)):\n        if i % 2 == 0:\n            if s[i] in lower_vowels:\n                even_lower += 1\n        elif s[i] in upper_vowels:\n            odd_upper += 1\n    return (odd_upper, even_lower)"
      ],
      [
        0.9276909828186035,
        "    try:\n        assert isinstance(s, str), 'Invalid input'\n        vowel_list = ['A', 'E', 'I', 'O', 'U']\n        return sum([1 for i in range(len(s)) if s[i] in vowel_list and i % 2 == 0])\n    except:\n        return 'Invalid input'"
      ],
      [
        0.9276909828186035,
        "    try:\n        assert isinstance(s, str), 'Invalid input'\n        vowel_list = ['A', 'E', 'I', 'O', 'U']\n        return sum([1 for i in range(len(s)) if s[i] in vowel_list and i % 2 == 0])\n    except:\n        return 'Invalid input'"
      ]
    ],
    "HumanEval/99": [
      [
        0.9153082370758057,
        "    try:\n        num = float(value)\n    except ValueError:\n        return 'Error: Invalid input.'\n    if num < low or num > high:\n        return 'Error: Out of range.'\n    int_part = int(num)\n    decimal_part = abs(num - int_part)\n    if decimal_part < 0.5:\n        return int_part\n    elif num >= 0:\n        return int_part + 1\n    else:\n        return int_part - 1"
      ],
      [
        0.910211443901062,
        "    try:\n        num_value = Decimal(value)\n    except InvalidOperation:\n        return 'Error: Invalid input.'\n    if not low <= num_value <= high:\n        return 'Error: Beyond range.'\n    decimal, integer = divmod(num_value, 1)\n    if decimal <= Decimal('0.5'):\n        return int(integer + 1)\n    elif decimal <= Decimal('-0.5'):\n        return int(integer - 1)\n    else:\n        return int(integer)"
      ],
      [
        0.9094333052635193,
        "    try:\n        num_value = Decimal(value)\n    except InvalidOperation:\n        return 'Error: Invalid input.'\n    if not low <= num_value <= high:\n        return 'Error: Beyond range.'\n    decimal, integer = divmod(num_value, 1)\n    if decimal >= Decimal('0.5'):\n        return int(integer + 1)\n    elif decimal <= Decimal('-0.5'):\n        return int(integer - 1)\n    else:\n        return int(integer)"
      ],
      [
        0.9087764024734497,
        "    try:\n        value = float(value)\n    except ValueError:\n        return 'Error: Invalid input.'\n    if not low <= value <= high:\n        return 'Error: Out of range.'\n    decimal = value - int(value)\n    if decimal >= 0.5 and value >= 0:\n        value += 1\n    elif decimal <= -0.5 and value <= 0:\n        value -= 1\n    return int(value)"
      ],
      [
        0.9064860343933105,
        "    try:\n        num = float(value)\n        rounded = int(num)\n        if num - int(num) >= 0.5:\n            if num < 0:\n                rounded += 1\n            else:\n                rounded -= 1\n        if not is_prime(rounded):\n            rounded = closest_prime(rounded)\n        return rounded\n    except ValueError:\n        return 'Error: Invalid input.'"
      ],
      [
        0.9064860343933105,
        "    try:\n        num = float(value)\n        rounded = int(num)\n        if num - int(num) >= 0.5:\n            if num < 0:\n                rounded += 1\n            else:\n                rounded -= 1\n        if not is_prime(rounded):\n            rounded = closest_prime(rounded)\n        return rounded\n    except ValueError:\n        return 'Error: Invalid input.'"
      ],
      [
        0.9062358140945435,
        "    try:\n        float_digit = float(digit)\n    except ValueError:\n        return 'Error: Invalid input.'\n    if not lower_bound <= float_digit <= upper_bound:\n        return 'Error: Out of range.'\n    integ, frac = divmod(float_digit, 1)\n    if frac >= 0.5:\n        if float_digit > 0:\n            rounded_value = integ\n        else:\n            rounded_value = integ - 1\n    else:\n        rounded_value = integ\n    return int(rounded_value)"
      ],
      [
        0.906152606010437,
        "    try:\n        num = float(decimal_in_str_format)\n    except ValueError:\n        return 'Error: Invalid input.'\n    if num < lower_bound or num > upper_bound:\n        return 'Error: Beyond range.'\n    if num >= 0:\n        decimal = num - int(num)\n        if decimal < 0.5:\n            return int(num)\n        else:\n            return int(num) + 1\n    else:\n        decimal = -num + int(-num)\n        if decimal < 0.5:\n            return int(num)\n        else:\n            return int(num) - 1"
      ],
      [
        0.9055969715118408,
        "    try:\n        value = float(value)\n        if value < low or value > high:\n            return 'Error: Out of range.'\n        elif value >= 0:\n            return int(value) if value - int(value) < 0.5 else int(value) + 1\n        else:\n            return int(value) if abs(value - int(value)) < 0.5 else int(value) - 1\n    except ValueError:\n        return 'Error: Invalid input.'"
      ],
      [
        0.9055969715118408,
        "    try:\n        value = float(value)\n        if value < low or value > high:\n            return 'Error: Out of range.'\n        elif value >= 0:\n            return int(value) if value - int(value) < 0.5 else int(value) + 1\n        else:\n            return int(value) if abs(value - int(value)) < 0.5 else int(value) - 1\n    except ValueError:\n        return 'Error: Invalid input.'"
      ]
    ],
    "HumanEval/100": [
      [
        0.8978773951530457,
        "    stones = [n]\n    for i in range(1, n):\n        if pattern == 'odd':\n            stones.append(stones[-1] + 2 * i + 1)\n        elif pattern == 'even':\n            stones.append(stones[-1] + 2 * i + offset)\n    return stones"
      ],
      [
        0.8962353467941284,
        "    stones = [n]\n    for i in range(1, n):\n        if pattern == 'odd':\n            stones.append(n + 2 * i + offset)\n        elif pattern == 'even':\n            stones.append(n + 2 * i - 1 + offset)\n    return stones"
      ],
      [
        0.894518256187439,
        "    stones = [n + offset]\n    for i in range(1, n):\n        if pattern == 'odd':\n            stones.append(stones[-1] + 2 * i - 1)\n        elif pattern == 'even':\n            stones.append(stones[-1] + 2 * i)\n    return stones"
      ],
      [
        0.8944116234779358,
        "    for n in range(1, len(a)):\n        a[n] = a[n - 1] + 2\n    return a"
      ],
      [
        0.893936812877655,
        "    for i in range(1, n):\n        if pattern == 'odd':\n            stones.append(stones[-1] + 2 * i - 1)\n        elif pattern == 'even':\n            stones.append(stones[-1] + 2 * i)"
      ],
      [
        0.8938546776771545,
        "    stones = [n + 2 * i for i in range(n)]\n    return stones"
      ],
      [
        0.892432451248169,
        "    if n == 1:\n        return 1\n    elif n % 2 == 0:\n        return sum_of_odd_numbers(n - 1)\n    else:\n        return n + sum_of_odd_numbers(n - 2)"
      ],
      [
        0.892432451248169,
        "    if n == 1:\n        return 1\n    elif n % 2 == 0:\n        return sum_of_odd_numbers(n - 1)\n    else:\n        return n + sum_of_odd_numbers(n - 2)"
      ],
      [
        0.8922889232635498,
        "    for i in range(1, n):\n        if pattern == 'odd':\n            stones.append(stones[-1] + 2 * i + 1)\n        elif pattern == 'even':\n            stones.append(stones[-1] + 2 * i + offset)"
      ],
      [
        0.8917273283004761,
        "    elif n % 2 == 0:\n        return sum_of_odd_numbers(n - 1)\n    else:\n        return n + sum_of_odd_numbers(n - 2)"
      ]
    ],
    "HumanEval/101": [
      [
        0.9103398323059082,
        "    words = s.split(' ')\n    return words"
      ],
      [
        0.9103398323059082,
        "    words = s.split(' ')\n    return words"
      ],
      [
        0.9097162485122681,
        "    words = []\n    word = ''\n    for i in range(len(string)):\n        if string[i] == ' ':\n            words.append(word)\n            word = ''\n        else:\n            word += string[i]\n    if word != '':\n        words.append(word)\n    return words"
      ],
      [
        0.909195601940155,
        "    words = []\n    word = ''\n    for c in s:\n        if c.isspace():\n            if word:\n                words.append(word)\n            word = ''\n        else:\n            word += c\n    if word:\n        words.append(word)\n    return words"
      ],
      [
        0.9089457988739014,
        "    word = ''\n    list_of_words = []\n    for char in string:\n        if char == ' ':\n            list_of_words.append(word)\n            word = ''\n        else:\n            word += char\n    list_of_words.append(word)\n    return list_of_words"
      ],
      [
        0.9070054292678833,
        "    words = []\n    word = ''\n    for char in string:\n        if char != ' ':\n            word += char\n        elif word != '':\n            words.append(word)\n            word = ''\n    if word != '':\n        words.append(word)\n    return words"
      ],
      [
        0.9063661098480225,
        "    words = string.split(' ')\n    return words"
      ],
      [
        0.9063631296157837,
        "    words = string.split(' ')\n    return words"
      ],
      [
        0.9063519835472107,
        "    words = string.split(' ')\n    return words"
      ],
      [
        0.9063441157341003,
        "    words = string.split(' ')\n    return words"
      ]
    ],
    "HumanEval/102": [
      [
        0.9298559427261353,
        "    maxEvenNumber = -1\n    if y >= x:\n        for i in range(x, y + 1):\n            if i % 2 == 0:\n                maxEvenNumber = i\n    return maxEvenNumber"
      ],
      [
        0.9169257283210754,
        "    if y >= x:\n        for i in range(x, y + 1):\n            if i % 2 == 0:\n                maxEvenNumber = i"
      ],
      [
        0.9104064106941223,
        "    for i in range(y, x - 1, -1):\n        if i % z == 0 and i % 2 == 0:\n            return i\n    return -1"
      ],
      [
        0.9103742241859436,
        "    for i in range(y, x - 1, -1):\n        if i % z == 0 and i % 2 == 0:\n            return i\n    return -1"
      ],
      [
        0.9093164801597595,
        "        for i in range(x, y + 1):\n            if i % 2 == 0:\n                maxEvenNumber = i"
      ],
      [
        0.9079453945159912,
        "    if not type(x) == type(y) == type(z) == int:\n        return 'Error: Inputs must be integers.'\n    if not (x >= 0 and y >= 0 and (z >= 0)):\n        return 'Error: Inputs must be positive.'\n    if x > y:\n        return 'Error: x should be less than or equal to y.'\n    largest_num = None\n    for i in range(y, x - 1, -1):\n        if i % z == 0 and i % 2 == 0:\n            largest_num = i\n            break\n    return largest_num"
      ],
      [
        0.9065008163452148,
        "    for i in range(y, x - 1, -1):\n        if i % z == 0 and i % 2 == 0:\n            return i"
      ],
      [
        0.9064511656761169,
        "    for i in range(y, x - 1, -1):\n        if i % z == 0 and i % 2 == 0:\n            return i"
      ],
      [
        0.9064016938209534,
        "    for num in range(y, x - 1, -1):\n        if num % 2 == 0 and num % z == 0:\n            return num\n    return -1"
      ],
      [
        0.9044733047485352,
        "    highest_even = y if y % 2 == 0 else y - 1\n    for i in range(highest_even, x - 1, -2):\n        if i % z == 0:\n            return i\n    return -1"
      ]
    ],
    "HumanEval/103": [
      [
        0.9289141893386841,
        "    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    total, count = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)\n    elif base == 8:\n        return oct(avg)\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)"
      ],
      [
        0.9216184020042419,
        "    if m < n or base < 2 or base > 10:\n        return -1\n    avg = math.ceil(sum(range(n, m + 1)) / (m - n + 1))\n    if base == 2:\n        return bin(avg)\n    elif base == 8:\n        return oct(avg)\n    elif base == 10:\n        return str(avg)\n    else:\n        return manual_base_conversion(avg, base)"
      ],
      [
        0.9134619235992432,
        "    if n > m or base < 2 or base > 10:\n        return -1\n    tot_sum, weight = (0, 0)\n    for i in range(n, m + 1):\n        divs = [1, i] + [j for j in range(2, int(i ** 0.5) + 1) if i % j == 0]\n        divs_for_calc = divs + [i / j for j in divs if j * j != i]\n        div_count = len(divs_for_calc)\n        tot_sum += i * div_count\n        weight += div_count\n    weighted_avg = round(tot_sum / weight)\n    total_sequence = (weighted_avg * 2 + weight - 1) * weight // 2\n    if base == 2:\n        return bin(total_sequence)\n    elif base == 8:\n        return oct(total_sequence)\n    elif base == 10:\n        return str(total_sequence)\n    else:\n        res = ''\n        num = total_sequence\n        while num > 0:\n            res = str(num % base) + res\n            num //= base\n        return res"
      ],
      [
        0.9126744270324707,
        "    if n > m or base not in range(3, 13):\n        return -1\n    else:\n        factor_sums, nums = ([], [])\n        for i in range(n, m + 1):\n            factor_sum = sum([j for j in range(1, i + 1) if i % j == 0])\n            factor_sums.append(factor_sum)\n            nums.append(i)\n        weights = [i / sum(factor_sums) for i in factor_sums]\n        weighted_nums = [nums[i] * weights[i] for i in range(len(nums))]\n        median = round(sum(weighted_nums))\n        if base == 10:\n            return str(median)\n        elif base == 2:\n            return bin(median)\n        elif base == 8:\n            return oct(median)\n        else:\n            return hex(median)"
      ],
      [
        0.9126744270324707,
        "    if n > m or base not in range(3, 13):\n        return -1\n    else:\n        factor_sums, nums = ([], [])\n        for i in range(n, m + 1):\n            factor_sum = sum([j for j in range(1, i + 1) if i % j == 0])\n            factor_sums.append(factor_sum)\n            nums.append(i)\n        weights = [i / sum(factor_sums) for i in factor_sums]\n        weighted_nums = [nums[i] * weights[i] for i in range(len(nums))]\n        median = round(sum(weighted_nums))\n        if base == 10:\n            return str(median)\n        elif base == 2:\n            return bin(median)\n        elif base == 8:\n            return oct(median)\n        else:\n            return hex(median)"
      ],
      [
        0.9126291275024414,
        "    if n > m or base < 2 or base > 10:\n        return -1\n    divisor_count = 0\n    divisor_sum = 0\n    for i in range(n, m + 1):\n        divisor_count += sum((1 for x in range(1, i + 1) if i % x == 0))\n        divisor_sum += sum((x for x in range(1, i + 1) if i % x == 0))\n    divisor_weighted_mean = round(divisor_sum / divisor_count)\n    if base == 2:\n        return bin(divisor_weighted_mean)\n    elif base == 8:\n        return oct(divisor_weighted_mean)\n    elif base == 10:\n        return divisor_weighted_mean\n    else:\n        return -1"
      ],
      [
        0.9105050563812256,
        "    if n > m or base < 2 or base > 10:\n        return -1\n    total, weight_sum = (0, 0)\n    for num in range(n, m + 1):\n        weight = count_divisors(num)\n        total += num * weight\n        weight_sum += weight\n    avg = round(total / weight_sum)\n    if base == 2:\n        return bin(avg)\n    elif base == 8:\n        return oct(avg)\n    elif base == 10:\n        return avg\n    else:\n        return int(str(avg), base)"
      ],
      [
        0.9104859828948975,
        "    if n > m:\n        return -1\n    if base < 2 or base > 10:\n        return -1\n    total, total_weight = (0, 0)\n    for i in range(n, m + 1):\n        weight_i, weight_end = alternate_fn(i, m)\n        total += i * weight_i\n        total_weight += weight_i\n    if total_weight == 0:\n        return format(0, '#' + str(base + 1) + 'b')\n    res = int(round(total / total_weight))\n    if base == 10:\n        return str(res)\n    elif base == 2:\n        return format(res, '#0b')\n    elif base == 8:\n        return format(res, '#0o')"
      ],
      [
        0.9097390174865723,
        "    if n > m:\n        return -1\n    if base < 2 or base > 10:\n        return -1\n    total, total_weight = (0, 0)\n    for i in range(n, m + 1):\n        weight_i, weight_end = alternate_fn(i, m)\n        total += i * weight_i\n        total_weight += weight_i\n    if total_weight == 0:\n        return format(0, '#' + str(base + 1) + 'b')\n    res = int(round(total / total_weight))\n    if base == 10:\n        return str(res)\n    elif base == 2:\n        return format(res, 'b')\n    elif base == 8:\n        return format(res, 'o')"
      ],
      [
        0.9085877537727356,
        "    if n >= m or base < 2 or base > 10:\n        return -1\n    total_sum_weight = (0, 0)\n    for i in range(n, m + 1):\n        divs = [1, i] + [x for x in range(2, int(i ** 0.5) + 1) if i % x == 0]\n        divs_for_calc = divs + [i / x for x in divs if x * x != i]\n        div_count = len(divs_for_calc)\n        total_sum_weight += (i * div_count, div_count)\n    weighted_avg = round(total_sum_weight[0] / total_sum_weight[1])\n    total_sequence = (weighted_avg * 2 + total_sum_weight[1] - 1) * total_sum_weight[1] // 2\n    if base == 2:\n        return bin(total_sequence)\n    elif base == 8:\n        return oct(total_sequence)\n    elif base == 10:\n        return str(total_sequence)\n    else:\n        num = total_sequence\n        res = ''\n        while num > 0:\n            res = str(num % base) + res\n            num //= base\n        return res"
      ]
    ],
    "HumanEval/104": [
      [
        0.9239221811294556,
        "    unique_list = []\n    for ele in x:\n        if ele not in unique_list:\n            digit_sum = sum((int(digit) for digit in str(ele)))\n            if digit_sum % 2 == 1:\n                unique_list.append(ele)\n    return sorted(unique_list)"
      ],
      [
        0.9226208925247192,
        "    unique_nums = set(x)\n    odd_digits_sum_nums = [num for num in unique_nums if sum((int(digit) for digit in str(num))) % 2 != 0]\n    return sorted(odd_digits_sum_nums)"
      ],
      [
        0.9164827466011047,
        "    result = []\n    for num in x:\n        if num < 0:\n            continue\n        digit_sum = sum((int(digit) for digit in str(num)))\n        if digit_sum % 2 == 0:\n            continue\n        if num in result:\n            continue\n        result.append(num)\n    return sorted(result)"
      ],
      [
        0.9164765477180481,
        "    result = []\n    for num in x:\n        if num < 0:\n            continue\n        digit_sum = sum((int(digit) for digit in str(num)))\n        if digit_sum % 2 == 0:\n            continue\n        if num in result:\n            continue\n        result.append(num)\n    return sorted(result)"
      ],
      [
        0.9155070781707764,
        "    odd_sum_digits = []\n    for i in set(x):\n        if sum((int(digit) for digit in str(i))) % 2 != 0:\n            odd_sum_digits.append(i)\n    return sorted(odd_sum_digits)"
      ],
      [
        0.9152475595474243,
        "    lst = [int(x) for x in lst]\n    if any((x < 0 for x in lst)):\n        raise ValueError('Negative numbers are not allowed')\n    if len(set(lst)) != len(lst):\n        raise ValueError('Duplicate numbers are not allowed')\n    result = [x for x in lst if 10 < x < 100 and x % 2 != 0]\n    result.sort()\n    return result"
      ],
      [
        0.9088971614837646,
        "    odd_numbers = [num for num in arr if num % 2 != 0]\n    odd_numbers = sort_odd_numbers(odd_numbers)\n    odd_numbers = remove_duplicates(odd_numbers)\n    return odd_numbers"
      ],
      [
        0.9085005521774292,
        "    odd_sum_set = set()\n    for num in x:\n        if sum((int(digit) for digit in str(num))) % 2 != 0:\n            odd_sum_set.add(num)\n    return sorted(list(odd_sum_set))"
      ],
      [
        0.9075504541397095,
        "    odd_numbers = []\n    for num in input_list:\n        if num % 2 != 0:\n            odd_numbers.append(num)\n    odd_numbers.sort()\n    odd_numbers = list(set(odd_numbers))\n    return odd_numbers"
      ],
      [
        0.907029926776886,
        "    if not arr:\n        return []\n    first = arr[0]\n    if first % 2 == 0:\n        return remove_even_duplicates(arr[1:])\n    return [first] + remove_even_duplicates([x for x in arr if x != first])"
      ]
    ],
    "HumanEval/105": [
      [
        0.9439730644226074,
        "    num2words = {1: 'One', 2: 'Two', 3: 'Three', 4: 'Four', 5: 'Five', 6: 'Six', 7: 'Seven', 8: 'Eight', 9: 'Nine'}\n    valid_nums = sorted([n for n in arr if 1 <= n <= 9], reverse=True)\n    return [num2words[n] for n in valid_nums]"
      ],
      [
        0.9076486825942993,
        "    ones = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']\n    teens = ['ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen']\n    tens = ['', '', 'twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety']\n    words = ''\n    if num < 10:\n        words += ones[num]\n    elif num < 20:\n        words += teens[num % 10]\n    else:\n        words += tens[num // 10]\n        if num % 10 != 0:\n            words += ' ' + ones[num % 10]\n    return words"
      ],
      [
        0.905189037322998,
        "    clean_arr = [''.join(filter(str.isalpha, item.lower())) for item in arr]\n    sorted_arr = sorted(clean_arr, key=len)\n    reversed_str = [item[::-1] for item in sorted_arr]\n    return reversed_str"
      ],
      [
        0.9047633409500122,
        "    filtered_arr = [x for x in arr if x <= 10 or x % 5 != 0]\n    filtered_arr.sort(reverse=True)\n    return filtered_arr"
      ],
      [
        0.9044753909111023,
        "    converted_nums = []\n    for num in arr:\n        try:\n            converted_nums.append(int(num))\n        except ValueError:\n            continue\n    n = len(converted_nums)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if converted_nums[j] < converted_nums[j + 1]:\n                converted_nums[j], converted_nums[j + 1] = (converted_nums[j + 1], converted_nums[j])\n    return converted_nums"
      ],
      [
        0.903559148311615,
        "    if num == 9:\n        return 'nine'"
      ],
      [
        0.902928352355957,
        "    lt_20 = ['', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen']\n    gt_20 = ['', '', 'twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety']\n    if N < 20:\n        return lt_20[N]\n    if N < 100:\n        return gt_20[N // 10] + ' ' + lt_20[N % 10]\n    if N < 1000:\n        return lt_20[N // 100] + ' hundred ' + convertToWords(N % 100)"
      ],
      [
        0.9026180505752563,
        "    if num == 100:\n        return 'one hundred'\n    elif num < 10:\n        return ones[num]\n    elif num < 20:\n        return teens[num - 10]\n    elif num < 100:\n        if num % 10 == 0:\n            return tens[num // 10]\n        else:\n            return tens[num // 10] + '-' + ones[num % 10]"
      ],
      [
        0.902556300163269,
        "    if num == 0:\n        return 'zero'\n    digits = ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']\n    teens = ['ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen']\n    tens = ['twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety']\n    num_words = ''\n    if num >= 1000:\n        num_words += digits[int(num / 1000) - 1] + ' thousand '\n        num %= 1000\n    if num >= 100:\n        num_words += digits[int(num / 100) - 1] + ' hundred '\n        num %= 100\n    if num >= 20:\n        num_words += tens[int(num / 10) - 2] + ' '\n        num %= 10\n    if num >= 10:\n        num_words += teens[num - 10] + ' '\n    else:\n        num_words += digits[num - 1] + ' '\n    return num_words.strip()"
      ],
      [
        0.9024184942245483,
        "    number_words = {0: 'zero', 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', 6: 'six', 7: 'seven', 8: 'eight', 9: 'nine', 10: 'ten', 11: 'eleven', 12: 'twelve', 13: 'thirteen', 14: 'fourteen', 15: 'fifteen', 16: 'sixteen', 17: 'seventeen', 18: 'eighteen', 19: 'nineteen'}\n    tens_words = {20: 'twenty', 30: 'thirty', 40: 'forty', 50: 'fifty', 60: 'sixty', 70: 'seventy', 80: 'eighty', 90: 'ninety'}\n    if number < 20:\n        return number_words[number]\n    elif number < 100:\n        tens = number // 10 * 10\n        ones = number % 10\n        return tens_words[tens] + '-' + number_words[ones] if ones > 0 else tens_words[tens]\n    else:\n        hundreds = number // 100\n        remainder = number % 100\n        if remainder > 0:\n            return number_words[hundreds] + ' hundred ' + convert_number_to_words(remainder)\n        else:\n            return number_words[hundreds] + ' hundred'"
      ]
    ],
    "HumanEval/106": [
      [
        0.9349962472915649,
        "    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(sum(range(i + 1)))\n        else:\n            result.append(math.factorial(i))\n    return result"
      ],
      [
        0.9349782466888428,
        "    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(sum(range(i + 1)))\n        else:\n            result.append(math.factorial(i))\n    return result"
      ],
      [
        0.9334205389022827,
        "    for i in range(n):\n        if i % 2 == 0:\n            resultList[i] = factorial(i)\n        else:\n            resultList[i] = cumulative_sum(i)"
      ],
      [
        0.9305440187454224,
        "    resultList = [0] * n\n    for i in range(n):\n        if i % 2 == 0:\n            resultList[i] = factorial(i)\n        else:\n            resultList[i] = cumulative_sum(i)\n    return resultList"
      ],
      [
        0.928083598613739,
        "    elif n == 1:\n        return [1]\n    else:\n        array = list(range(1, n + 1))\n        odd_numbers = [num for num in array if num % 2 != 0]\n        factorial_numbers = [factorial(num) for num in odd_numbers]\n        return factorial_numbers"
      ],
      [
        0.9263874292373657,
        "    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(sum(range(i + 1)))\n        else:\n            result.append(math.factorial(i))"
      ],
      [
        0.926377534866333,
        "    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(sum(range(i + 1)))\n        else:\n            result.append(math.factorial(i))"
      ],
      [
        0.9260532855987549,
        "    if i % 2 == 0:\n        return math.factorial(i)\n    else:\n        return sum(range(1, i + 1))"
      ],
      [
        0.9260532855987549,
        "    if i % 2 == 0:\n        return math.factorial(i)\n    else:\n        return sum(range(1, i + 1))"
      ],
      [
        0.9242022037506104,
        "        if i % 2 == 0:\n            resultList[i] = factorial(i)\n        else:\n            resultList[i] = cumulative_sum(i)"
      ]
    ],
    "HumanEval/107": [
      [
        0.9099169969558716,
        "    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)"
      ],
      [
        0.9099094867706299,
        "    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)"
      ],
      [
        0.9098970890045166,
        "    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)"
      ],
      [
        0.9098914861679077,
        "    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)"
      ],
      [
        0.9090319275856018,
        "    even_count = 0\n    odd_count = 0\n    num = abs(num)\n    for digit in str(num):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)"
      ],
      [
        0.9086751937866211,
        "    str_n = str(n)\n    decimal_palindrome = str_n == str_n[::-1]\n    binary_n = bin(n).replace('0b', '')\n    binary_palindrome = binary_n == binary_n[::-1]\n    return (decimal_palindrome, binary_palindrome)"
      ],
      [
        0.9085236191749573,
        "    palindromes = []\n    largest_palindrome = 0\n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            palindromes.append(i)\n            if i > largest_palindrome:\n                largest_palindrome = i\n    return (palindromes, largest_palindrome)"
      ],
      [
        0.9082458019256592,
        "    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):\n        if digit.isdigit():\n            if int(digit) % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)"
      ],
      [
        0.9072295427322388,
        "    even_count = 0\n    odd_count = 0\n    for num in arr:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)"
      ],
      [
        0.9064913988113403,
        "    even_count = 0\n    odd_count = 0\n    num = abs(num)\n    for digit in str(num):\n        if digit != '0':\n            if int(digit) % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n        else:\n            even_count += 1\n    return (even_count, odd_count)"
      ]
    ],
    "HumanEval/108": [
      [
        0.9186872243881226,
        "    count = 0\n    for i in arr:\n        if i > 0:\n            count += 1\n    return count"
      ],
      [
        0.9140210151672363,
        "    count = 0\n    for num in nums:\n        if num > 0:\n            count += 1\n    print('Number of positive numbers:', count)"
      ],
      [
        0.9126380681991577,
        "    count = 0\n    for num in numbers:\n        if num > 0:\n            count += 1\n    return count"
      ],
      [
        0.9114486575126648,
        "    return sum((1 for num in arr if num > 0))"
      ],
      [
        0.9106417298316956,
        "    count = 0\n    for num in nums:\n        if num > 0:\n            count += 1\n    return count"
      ],
      [
        0.9104793667793274,
        "    return sum([num for num in arr if num > 0])"
      ],
      [
        0.9103732109069824,
        "    if not arr:\n        return 0\n    else:\n        current_num = arr[0]\n        if current_num > 0:\n            return current_num + sum_of_positives(arr[1:])\n        else:\n            return sum_of_positives(arr[1:])"
      ],
      [
        0.9103732109069824,
        "    if not arr:\n        return 0\n    else:\n        current_num = arr[0]\n        if current_num > 0:\n            return current_num + sum_of_positives(arr[1:])\n        else:\n            return sum_of_positives(arr[1:])"
      ],
      [
        0.9096509218215942,
        "    count = 0\n    for num in arr:\n        digit_sum = sum((int(digit) for digit in str(abs(num))))\n        if num < 0:\n            digit_sum = -digit_sum\n        if digit_sum > 0 and digit_sum % 4 == 0:\n            count += 1\n    return count"
      ],
      [
        0.9095370769500732,
        "    return sum((x for x in arr if x > 0))"
      ]
    ],
    "HumanEval/109": [
      [
        0.9151409268379211,
        "    right_shifts_required = 0\n    if len(arr) == 0 or len(arr) == 1:\n        return [True, right_shifts_required]\n    for i in range(len(arr) - 1, 0, -1):\n        if arr[i] < arr[i - 1]:\n            if right_shifts_required != 0:\n                return [False, -1]\n            right_shifts_required = i\n    return [True, right_shifts_required]"
      ],
      [
        0.9050660729408264,
        "    for i in range(len(arr) - 1, 0, -1):\n        if arr[i] < arr[i - 1]:\n            if right_shifts_required != 0:\n                return [False, -1]\n            right_shifts_required = i"
      ],
      [
        0.9039638042449951,
        "    if len(arr) == 0:\n        return True\n    for j in range(len(arr)):\n        new_arr = arr[j:] + arr[:j]\n        if is_sorted(new_arr):\n            return True\n    return False"
      ],
      [
        0.9039446115493774,
        "    if len(arr) == 0:\n        return True\n    for _ in range(len(arr)):\n        odd_count = 0\n        even_count = 0\n        for num in arr:\n            if num % 2 == 1:\n                odd_count += 1\n            if odd_count > 0 and num % 2 == 0:\n                even_count += 1\n        if even_count == len(arr) - odd_count:\n            return True\n        arr.append(arr.pop(0))\n    return False"
      ],
      [
        0.9018522500991821,
        "    for j in range(len(arr)):\n        new_arr = arr[j:] + arr[:j]\n        if is_sorted(new_arr):\n            return True"
      ],
      [
        0.9001134634017944,
        "    for _ in range(len(arr)):\n        odd_count = 0\n        even_count = 0\n        for num in arr:\n            if num % 2 == 1:\n                odd_count += 1\n            if odd_count > 0 and num % 2 == 0:\n                even_count += 1\n        if even_count == len(arr) - odd_count:\n            return True\n        arr.append(arr.pop(0))"
      ],
      [
        0.8988852500915527,
        "    return move_two_balls(arr) and count_smaller_than_first(arr)"
      ],
      [
        0.8968949317932129,
        "    if arr == sorted(arr):\n        return True\n    elif arr == sorted(arr, reverse=True):\n        return True\n    else:\n        return False"
      ],
      [
        0.8968949317932129,
        "    if arr == sorted(arr):\n        return True\n    elif arr == sorted(arr, reverse=True):\n        return True\n    else:\n        return False"
      ],
      [
        0.8965829610824585,
        "    n = len(arr)\n    if n <= 1:\n        return True\n    for i in range(1, n):\n        if arr[i] < arr[i - 1]:\n            return False\n    return True"
      ]
    ],
    "HumanEval/110": [
      [
        0.935279130935669,
        "    odd1 = sum((1 for num in lst1 if num % 2 != 0))\n    even2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if odd1 == even2 else 'NO'"
      ],
      [
        0.9339094161987305,
        "    for i in range(len(lst1)):\n        if lst1[i] % 2 != 0:\n            has_swap = False\n            for j in range(len(lst2)):\n                if lst2[j] % 2 == 0:\n                    lst1[i], lst2[j] = (lst2[j], lst1[i])\n                    has_swap = True\n                    break\n            if not has_swap:\n                return 'NO'"
      ],
      [
        0.932579755783081,
        "    if sum(lst1) % 2 != 0 or sum(lst2) % 2 != 0:\n        return 'No'\n    for i in range(len(lst1)):\n        if lst1[i] % 2 != 0:\n            has_swap = False\n            for j in range(len(lst2)):\n                if lst2[j] % 2 == 0:\n                    lst1[i], lst2[j] = (lst2[j], lst1[i])\n                    has_swap = True\n                    break\n            if not has_swap:\n                return 'NO'\n    return 'YES'"
      ],
      [
        0.9311299920082092,
        "    sum_lst1 = sum(lst1)\n    sum_lst2 = sum(lst2)\n    if (sum_lst1 + sum_lst2) % 2 != 0:\n        return 'NO'\n    has_odd_lst1 = any((i % 2 != 0 for i in lst1))\n    has_even_lst2 = any((i % 2 == 0 for i in lst2))\n    return 'YES' if has_odd_lst1 and has_even_lst2 else 'NO'"
      ],
      [
        0.930328369140625,
        "    sum1, sum2 = (sum(lst1), sum(lst2))\n    if (sum1 + sum2) % 2 == 1:\n        return 'NO'\n    odd1 = min((i for i in lst1 if i % 2 == 1)) if any((i % 2 == 1 for i in lst1)) else float('inf')\n    even2 = min((i for i in lst2 if i % 2 == 0)) if any((i % 2 == 0 for i in lst2)) else float('inf')\n    if odd1 == float('inf') or even2 == float('inf') or odd1 > even2:\n        return 'NO'\n    return 'YES'"
      ],
      [
        0.9302670359611511,
        "    if (sum(lst1) + sum(lst2)) % 2 != 0:\n        return 'NO'\n    odd_lst1 = [x for x in lst1 if x % 2 != 0]\n    even_lst2 = [x for x in lst2 if x % 2 == 0]\n    if len(odd_lst1) > len(even_lst2):\n        return 'NO'\n    return 'YES'"
      ],
      [
        0.9300742149353027,
        "    swap_lst1 = [x for x in lst1 if x % 2 != 0]\n    swap_lst2 = [x for x in lst2 if x % 2 == 0]\n    if (sum(lst1) + sum(lst2)) % 2 != 0:\n        return 'NO'\n    if len(swap_lst1) == len(swap_lst2):\n        return 'YES'\n    else:\n        return 'NO'"
      ],
      [
        0.9299088716506958,
        "    lst1_odd = [i for i in lst1 if i % 2 != 0]\n    lst2_even = [i for i in lst2 if i % 2 == 0]\n    for odd in lst1_odd:\n        for even in lst2_even:\n            if odd - even == (sum(lst1) - sum(lst2)) // 2:\n                return 'YES'\n    return 'NO'"
      ],
      [
        0.9297925233840942,
        "    sum1, sum2 = (sum(lst1), sum(lst2))\n    even_sum1, even_sum2 = (sum((i for i in lst1 if i % 2 == 0)), sum((i for i in lst2 if i % 2 == 0)))\n    odd_sum1, odd_sum2 = (sum1 - even_sum1, sum2 - even_sum2)\n    if abs(odd_sum1 - odd_sum2) % 2 != 0:\n        return 'NO'\n    return 'YES'"
      ],
      [
        0.9297876358032227,
        "    sum1, sum2 = (sum(lst1), sum(lst2))\n    even_sum1, even_sum2 = (sum((i for i in lst1 if i % 2 == 0)), sum((i for i in lst2 if i % 2 == 0)))\n    odd_sum1, odd_sum2 = (sum1 - even_sum1, sum2 - even_sum2)\n    if abs(odd_sum1 - odd_sum2) % 2 != 0:\n        return 'NO'\n    return 'YES'"
      ]
    ],
    "HumanEval/111": [
      [
        0.9417455196380615,
        "    count = {}\n    max_count = 0\n    max_count_chars = []\n    for char in test:\n        if char != ' ':\n            if char.lower() in count:\n                count[char.lower()] += 1\n            else:\n                count[char.lower()] = 1\n            if count[char.lower()] > max_count:\n                max_count = count[char.lower()]\n    for char, char_count in count.items():\n        if char_count == max_count:\n            max_count_chars.append(char)\n    result = {char: max_count for char in max_count_chars}\n    return result"
      ],
      [
        0.9397285580635071,
        "    count = {}\n    for char in test:\n        if char != ' ':\n            if char.lower() in count:\n                count[char.lower()] += 1\n            else:\n                count[char.lower()] = 1\n    max_count = 0\n    for char, cnt in count.items():\n        if cnt > max_count:\n            max_count = cnt\n    max_chars = {}\n    for char, cnt in count.items():\n        if cnt == max_count:\n            max_chars[char] = cnt\n    return max_chars"
      ],
      [
        0.9390907287597656,
        "    count = {}\n    for char in test:\n        if char != ' ':\n            if char.lower() in count:\n                count[char.lower()] += 1\n            else:\n                count[char.lower()] = 1\n    max_value = max(count.values()) if count else 0\n    return {k: v for k, v in count.items() if v == max_value}"
      ],
      [
        0.9377082586288452,
        "    count = {}\n    for char in test:\n        if char != ' ':\n            if char.lower() in count:\n                count[char.lower()] += 1\n            else:\n                count[char.lower()] = 1\n    max_freq = max(count.values()) if count else 0\n    return {char: count for char, count in count.items() if count == max_freq}"
      ],
      [
        0.937471866607666,
        "    import re\n    test = re.sub('[^A-Za-z0-9 ]+', '', test)\n    test = test.lower()\n    letters = test.split(' ')\n    histogram = {}\n    for letter in letters:\n        if letter:\n            histogram[letter + '_' + str(letters.count(letter))] = letters.count(letter)\n    return histogram"
      ],
      [
        0.9371655583381653,
        "    count = {}\n    for char in test:\n        if char != ' ':\n            if char.lower() in count:\n                count[char.lower()] += 1\n            else:\n                count[char.lower()] = 1\n    max_count = max(count.values(), default=0)\n    return {char: count_ for char, count_ in count.items() if count_ == max_count}"
      ],
      [
        0.937090277671814,
        "    count = {}\n    for char in test:\n        if char != ' ':\n            if char.lower() in count:\n                count[char.lower()] += 1\n            else:\n                count[char.lower()] = 1\n    max_freq = max(count.values(), default=0)\n    return {k: v for k, v in count.items() if v == max_freq}"
      ],
      [
        0.9346421360969543,
        "    tally = {}\n    max_count = 0\n    for chartype in test:\n        if chartype != ' ':\n            if chartype.lower() in tally:\n                tally[chartype.lower()] += 1\n            else:\n                tally[chartype.lower()] = 1\n            if tally[chartype.lower()] > max_count:\n                max_count = tally[chartype.lower()]\n    return tally"
      ],
      [
        0.9321920871734619,
        "    count = {}\n    for char in test:\n        if char != ' ':\n            char = char.lower()\n            if char in count:\n                count[char] += 1\n            else:\n                count[char] = 1\n    max_freq = max(count.values()) if count else 0\n    max_freq_chars = {k: v for k, v in count.items() if v == max_freq}\n    return max_freq_chars"
      ],
      [
        0.9310002326965332,
        "    histogram = {}\n    for char in test:\n        char = char.lower()\n        histogram[char] = histogram.get(char, 0) + 1\n    histogram_list = sorted(histogram.items(), key=lambda x: x[0])\n    return histogram_list"
      ]
    ],
    "HumanEval/112": [
      [
        0.9100486040115356,
        "    s = ''.join((s[i] for i in range(len(s)) if s[i] != s[i - 1] and s[i] not in c))\n    return (s, s == s[::-1])"
      ],
      [
        0.909625768661499,
        "    result = ''.join((ch for ch in s if ch not in c))\n    palindrome = result == result[::-1]\n    num_alphabets = len(set(result))\n    return (result, palindrome, num_alphabets == n)"
      ],
      [
        0.8963276147842407,
        "    s = s.lower()\n    special_chars = [',', '.', '!', '?', ' ', \"'\"]\n    for special_char in special_chars:\n        s = s.replace(special_char, '')\n    if not s == s[::-1]:\n        return 'The string is not a palindrome.'\n    else:\n        s = s.replace(' ', '')\n        words = s.split()\n        palindromes = [word for word in words if word == word[::-1]]\n        return palindromes"
      ],
      [
        0.890853226184845,
        "    modified_string = string.replace(char, '')\n    reversed_string = modified_string[::-1]\n    return reversed_string"
      ],
      [
        0.8890777826309204,
        "    word = word.lower()\n    reversed_word = word[::-1]\n    if word == reversed_word:\n        return 'Characteristics of a palindrome present.'\n    else:\n        return 'Characteristics of a palindrome absent.'"
      ]
    ],
    "HumanEval/113": [
      [
        0.9508276581764221,
        "    output = []\n    for idx, str in enumerate(lst):\n        odd_count = sum((1 for s in str if int(s) % 2 != 0))\n        even_count = sum((1 for s in str if int(s) % 2 == 0))\n        replace_string = f'the number of odd elements {odd_count}n the str{even_count}ng {even_count} of the {odd_count}nput.'\n        output.append(replace_string)\n    return output"
      ],
      [
        0.9489438533782959,
        "    result = []\n    for i, s in enumerate(lst):\n        if not isinstance(s, str):\n            raise ValueError('ERROR: All elements in the list must be strings.')\n        try:\n            odd_nums = len([int(n) for n in s if int(n) % 2 != 0])\n        except ValueError:\n            raise ValueError('ERROR: All characters in the strings must be numeric.')\n        result.append('the calculation of odd segments {}n the str{}ng {} of the {}nput set.'.format(odd_nums, i + 1, odd_nums, i + 1))\n    return result"
      ],
      [
        0.947394609451294,
        "    result = []\n    for idx, s in enumerate(lst, 1):\n        odd_digits = sum((int(ch) % 2 for ch in s if ch.isdigit()))\n        if odd_digits == 0:\n            raise ValueError(f\"The string '{s}' contains no digits.\")\n        result.append(f'the quantity of odd components {odd_digits}n the str{odd_digits}ng {idx} of the {idx}nput.')\n    return result"
      ],
      [
        0.9471353888511658,
        "    output = []\n    for idx, string in enumerate(lst):\n        odd_count = sum((1 for s in string if int(s) % 2 != 0))\n        even_count = sum((1 for s in string if int(s) % 2 == 0))\n        replace_string = f'the number of odd elements are {odd_count} of the string {even_count} of the input'\n        output.append(replace_string)\n    return output"
      ],
      [
        0.9466519355773926,
        "    result = []\n    for i, s in enumerate(lst):\n        if not isinstance(s, str):\n            return 'ERROR'\n        if not s.isdigit():\n            return 'ERROR'\n        odd_count = sum((1 for char in s if int(char) % 2 != 0))\n        result.append('the count of odd parts {}n the str{}ng {} of the {}nput.'.format(odd_count, odd_count, odd_count, odd_count))\n    return result"
      ],
      [
        0.9396233558654785,
        "    for i, s in enumerate(lst):\n        if not isinstance(s, str):\n            return 'ERROR'\n        if not s.isdigit():\n            return 'ERROR'\n        odd_count = sum((1 for char in s if int(char) % 2 != 0))\n        result.append('the count of odd parts {}n the str{}ng {} of the {}nput.'.format(odd_count, odd_count, odd_count, odd_count))"
      ],
      [
        0.9391834735870361,
        "    for i, s in enumerate(lst):\n        if not isinstance(s, str):\n            raise ValueError('ERROR: All elements in the list must be strings.')\n        try:\n            odd_nums = len([int(n) for n in s if int(n) % 2 != 0])\n        except ValueError:\n            raise ValueError('ERROR: All characters in the strings must be numeric.')\n        result.append('the calculation of odd segments {}n the str{}ng {} of the {}nput set.'.format(odd_nums, i + 1, odd_nums, i + 1))"
      ],
      [
        0.9390414357185364,
        "    for idx, str in enumerate(lst):\n        odd_count = sum((1 for s in str if int(s) % 2 != 0))\n        even_count = sum((1 for s in str if int(s) % 2 == 0))\n        replace_string = f'the number of odd elements {odd_count}n the str{even_count}ng {even_count} of the {odd_count}nput.'\n        output.append(replace_string)"
      ],
      [
        0.9389358758926392,
        "    for idx, s in enumerate(lst, 1):\n        odd_digits = sum((int(ch) % 2 for ch in s if ch.isdigit()))\n        if odd_digits == 0:\n            raise ValueError(f\"The string '{s}' contains no digits.\")\n        result.append(f'the quantity of odd components {odd_digits}n the str{odd_digits}ng {idx} of the {idx}nput.')"
      ],
      [
        0.9386336207389832,
        "    result = []\n    for s in lst:\n        count = sum((int(c) % 2 == 0 for c in s if c.isdigit()))\n        result.append(f'the number of even characters {count}n the str{count}ng {count} of the {count}nput.')\n    return result"
      ]
    ],
    "HumanEval/114": [
      [
        0.9226868748664856,
        "    min_prefix = 0\n    prefix = 0\n    for num in nums:\n        prefix += num\n        min_prefix = min(min_prefix, prefix)\n    return -min_prefix if min_prefix < 0 else 0"
      ],
      [
        0.9226727485656738,
        "    min_prefix = 0\n    prefix = 0\n    for num in nums:\n        prefix += num\n        min_prefix = min(min_prefix, prefix)\n    return -min_prefix if min_prefix < 0 else 0"
      ],
      [
        0.9185606837272644,
        "    for num in nums:\n        sum += num\n        min_sum = min(min_sum, sum)"
      ],
      [
        0.9156765937805176,
        "    for num in nums:\n        curr_sum += num\n        min_sum = min(min_sum, curr_sum)"
      ],
      [
        0.9135719537734985,
        "    current_sum = min_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n    return min_sum"
      ],
      [
        0.9133195877075195,
        "    for num in nums:\n        prefix += num\n        min_prefix = min(min_prefix, prefix)"
      ],
      [
        0.913304328918457,
        "    for num in nums:\n        prefix += num\n        min_prefix = min(min_prefix, prefix)"
      ]
    ],
    "HumanEval/115": [
      [
        0.9311409592628479,
        "    count = [0] * len(grid[0])\n    for row in grid:\n        for j in range(len(row)):\n            count[j] += row[j]\n    count.sort()\n    time = 0\n    while count:\n        i = len(count) - 1\n        while i >= 0 and count[i] > 0:\n            count[i] -= bucket_capacity\n            i -= 1\n        count = [x for x in count if x > 0]\n        time += 1\n    return time - 1 if len(grid[0]) > bucket_capacity else time"
      ],
      [
        0.9289500117301941,
        "    rows, cols = (len(grid), len(grid[0]))\n    lowerings = 0\n    for i in range(rows):\n        remaining_capacity = capacity\n        for j in range(cols):\n            if grid[i][j] == 1:\n                remaining_capacity -= 1\n                if remaining_capacity == 0:\n                    lowerings += 1\n                    remaining_capacity = capacity\n        if remaining_capacity != capacity:\n            lowerings += 1\n    return lowerings"
      ],
      [
        0.9204750061035156,
        "    for i in range(rows):\n        remaining_capacity = capacity\n        for j in range(cols):\n            if grid[i][j] == 1:\n                remaining_capacity -= 1\n                if remaining_capacity == 0:\n                    lowerings += 1\n                    remaining_capacity = capacity\n        if remaining_capacity != capacity:\n            lowerings += 1"
      ],
      [
        0.9107372760772705,
        "            if grid[i][j] == 1:\n                remaining_capacity -= 1\n                if remaining_capacity == 0:\n                    lowerings += 1\n                    remaining_capacity = capacity"
      ],
      [
        0.9101908206939697,
        "        for j in range(cols):\n            if grid[i][j] == 1:\n                remaining_capacity -= 1\n                if remaining_capacity == 0:\n                    lowerings += 1\n                    remaining_capacity = capacity"
      ],
      [
        0.8946092128753662,
        "    if not grid or not grid[0]:\n        return 0\n    rows, cols = (len(grid), len(grid[0]))\n    left_max = [0] * rows\n    right_max = [0] * rows\n    water_volume = 0\n    for j in range(cols):\n        cur_left_max = 0\n        cur_right_max = 0\n        for i in range(rows):\n            left_max[i] = max(left_max[i], cur_left_max)\n            cur_left_max = max(cur_left_max, grid[i][j])\n            right_max[rows - 1 - i] = max(right_max[rows - 1 - i], cur_right_max)\n            cur_right_max = max(cur_right_max, grid[rows - 1 - i][j])\n        for i in range(rows):\n            height = min(left_max[i], right_max[i]) - grid[i][j]\n            if height > 0:\n                water_volume += height\n    return water_volume"
      ],
      [
        0.8942951560020447,
        "    if not grid or not grid[0]:\n        return 0\n    m, n = (len(grid), len(grid[0]))\n    left_max = [[0] * n for _ in range(m)]\n    right_max = [[0] * n for _ in range(m)]\n    top_max = [[0] * n for _ in range(m)]\n    bottom_max = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            left_max[i][j] = max(left_max[i][j - 1], grid[i][j]) if j > 0 else grid[i][j]\n            top_max[i][j] = max(top_max[i - 1][j], grid[i][j]) if i > 0 else grid[i][j]\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            right_max[i][j] = max(right_max[i][j + 1], grid[i][j]) if j < n - 1 else grid[i][j]\n            bottom_max[i][j] = max(bottom_max[i + 1][j], grid[i][j]) if i < m - 1 else grid[i][j]\n    total_water = 0\n    for i in range(m):\n        for j in range(n):\n            water_level = min(left_max[i][j], right_max[i][j], top_max[i][j], bottom_max[i][j])\n            total_water += max(0, water_level - grid[i][j])\n    return total_water"
      ],
      [
        0.8938917517662048,
        "    while count:\n        i = len(count) - 1\n        while i >= 0 and count[i] > 0:\n            count[i] -= bucket_capacity\n            i -= 1\n        count = [x for x in count if x > 0]\n        time += 1"
      ],
      [
        0.8931001424789429,
        "    distance = -1\n    water_cells = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                water_cells.append((i, j))\n    if not water_cells or len(water_cells) == n * n:\n        return distance\n    directions = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    while water_cells:\n        size = len(water_cells)\n        for _ in range(size):\n            x, y = water_cells.popleft()\n            for dx, dy in directions:\n                newX, newY = (x + dx, y + dy)\n                if 0 <= newX < n and 0 <= newY < n and (grid[newX][newY] == 0):\n                    grid[newX][newY] = 1\n                    water_cells.append((newX, newY))\n        distance += 1\n    return distance - 1"
      ],
      [
        0.8893305063247681,
        "    if n == 0 or capacity == 0:\n        return 0"
      ]
    ],
    "HumanEval/116": [
      [
        0.9380141496658325,
        "    arr.sort(key=lambda x: (bin(x).count('1'), bin(x).count('0'), -x))\n    return arr"
      ],
      [
        0.9359575510025024,
        "    arr.sort()\n    bin_count = lambda x: bin(x).count('1')\n    arr.sort(key=bin_count)\n    return arr"
      ],
      [
        0.9359508752822876,
        "    arr.sort()\n    bin_count = lambda x: bin(x).count('1')\n    arr.sort(key=bin_count)\n    return arr"
      ],
      [
        0.9345101118087769,
        "    bin_counts = [[str(bin(i)).count('1'), str(bin(int(str(i), 4))).count('1'), str(bin(int(str(i), 16))).count('1'), i] for i in arr]\n    bin_counts.sort()\n    sorted_list = [i[3] for i in bin_counts]\n    return sorted_list"
      ],
      [
        0.9311870336532593,
        "    arr.sort(key=lambda x: (len(bin(abs(x))) - 2, x, bin(abs(x)).count('1')))\n    return arr"
      ],
      [
        0.9310650825500488,
        "    binary_len_arr = [(num, len(bin(num)[2:])) for num in arr]\n    binary_len_arr.sort(key=lambda x: (x[1], x[0]))\n    return [num for num, _ in binary_len_arr]"
      ],
      [
        0.9304429888725281,
        "    return sorted(arr, key=lambda x: (bin(x).count('1'), x))"
      ],
      [
        0.9304386377334595,
        "    return sorted(arr, key=lambda x: (bin(x).count('1'), x))"
      ],
      [
        0.9304325580596924,
        "    return sorted(arr, key=lambda x: (bin(x).count('1'), x))"
      ],
      [
        0.9286805391311646,
        "    return sorted(arr, key=lambda x: (len(bin(x)) - 2, x))"
      ]
    ],
    "HumanEval/117": [
      [
        0.9261029958724976,
        "    words = s.split()\n    selected_words = []\n    for i in range(len(words)):\n        if count_consonants(words[i]) == n:\n            if selected_words and i > 0 and (count_consonants(words[i - 1]) == n):\n                selected_words[-1] += words[i]\n            else:\n                selected_words.append(words[i])\n    return [(count_vowels(word), word) for word in selected_words]"
      ],
      [
        0.9213624000549316,
        "    for i in range(len(words)):\n        if count_consonants(words[i]) == n:\n            if selected_words and i > 0 and (count_consonants(words[i - 1]) == n):\n                selected_words[-1] += words[i]\n            else:\n                selected_words.append(words[i])"
      ],
      [
        0.9196083545684814,
        "    vowels = 'aeiou'\n    if s == '':\n        return []\n    words = s.split(' ')\n    segments = []\n    for word in words:\n        count = 0\n        start = 0\n        for i in range(len(word)):\n            if word[i].lower() in vowels:\n                count += 1\n            if count == n:\n                segments.append(word[start:i + 1])\n                count = 0\n                start = i + 1\n    return segments"
      ],
      [
        0.9142547845840454,
        "        if count_consonants(words[i]) == n:\n            if selected_words and i > 0 and (count_consonants(words[i - 1]) == n):\n                selected_words[-1] += words[i]\n            else:\n                selected_words.append(words[i])"
      ],
      [
        0.9139598608016968,
        "    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    if not s:\n        return []\n    phrases_with_required_counts = []\n    current_phrase = []\n    current_consonants = 0\n    current_vowels = 0\n    for word in s.split():\n        word_cons = len([ch for ch in word.lower() if ch in consonants])\n        word_vows = len([ch for ch in word.lower() if ch in vowels])\n        if current_consonants + word_cons == n and current_vowels + word_vows == m:\n            current_phrase.append(word)\n            phrases_with_required_counts.append(' '.join(current_phrase))\n            current_phrase = []\n            current_consonants = 0\n            current_vowels = 0\n        elif current_consonants + word_cons > n or current_vowels + word_vows > m:\n            current_phrase = [word]\n            current_consonants = word_cons\n            current_vowels = word_vows\n        else:\n            current_phrase.append(word)\n            current_consonants += word_cons\n            current_vowels += word_vows\n    return phrases_with_required_counts"
      ],
      [
        0.9139412045478821,
        "    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    if not s:\n        return []\n    phrases_with_required_counts = []\n    current_phrase = []\n    current_consonants = 0\n    current_vowels = 0\n    for word in s.split():\n        word_cons = len([ch for ch in word.lower() if ch in consonants])\n        word_vows = len([ch for ch in word.lower() if ch in vowels])\n        if current_consonants + word_cons == n and current_vowels + word_vows == m:\n            current_phrase.append(word)\n            phrases_with_required_counts.append(' '.join(current_phrase))\n            current_phrase = []\n            current_consonants = 0\n            current_vowels = 0\n        elif current_consonants + word_cons > n or current_vowels + word_vows > m:\n            current_phrase = [word]\n            current_consonants = word_cons\n            current_vowels = word_vows\n        else:\n            current_phrase.append(word)\n            current_consonants += word_cons\n            current_vowels += word_vows\n    return phrases_with_required_counts"
      ],
      [
        0.9119724035263062,
        "            if selected_words and i > 0 and (count_consonants(words[i - 1]) == n):\n                selected_words[-1] += words[i]\n            else:\n                selected_words.append(words[i])"
      ],
      [
        0.9119058847427368,
        "    if not s:\n        return []\n    vowels = 'aeiouAEIOU'\n    result = []\n    for word in s.split():\n        word_vowels = [char for char in word if char in vowels]\n        if len(word_vowels) == n:\n            result.append(word)\n        else:\n            segments = [word[i:i + n] for i in range(0, len(word), n)]\n            result.extend((segment for segment in segments if sum((ch in vowels for ch in segment)) == n))\n    return result"
      ],
      [
        0.9098202586174011,
        "    vowels = 'aeiouAEIOU'\n    words = s.split()\n    segments = []\n    for word in words:\n        cnt = 0\n        segment = ''\n        for char in word:\n            if char in vowels:\n                cnt += 1\n            segment += char\n            if cnt == n:\n                segments.append(segment)\n                cnt = 0\n                segment = ''\n    return segments"
      ],
      [
        0.9094170331954956,
        "    if not s or not any((letter in s for letter in l)):\n        return []\n    vowels = set(l)\n    words = s.split()\n    result = []\n    for word in words:\n        if sum((1 for ch in word if ch in vowels)) == n:\n            if result and sum((1 for ch in result[-1] if ch in vowels)) == n:\n                removed_vowel = random.choice([vowel for vowel in result[-1] if vowel in vowels])\n                result[-1] = result[-1].replace(removed_vowel, '', 1)\n                result[-1] += word\n            else:\n                result.append(word)\n    return result"
      ]
    ],
    "HumanEval/118": [
      [
        0.9181517362594604,
        "    vowels = 'AEIOUaeiou'\n    for i in range(1, len(word) - 1):\n        if word[i] in vowels and word[i - 1] not in vowels:\n            return word[i]\n    return ''"
      ],
      [
        0.918147623538971,
        "    vowels = 'AEIOUaeiou'\n    for i in range(1, len(word) - 1):\n        if word[i] in vowels and word[i - 1] not in vowels:\n            return word[i]\n    return ''"
      ],
      [
        0.9161227345466614,
        "    vowels = 'aeiouAEIOU'\n    farthest_index = -1\n    farthest_distance = -1\n    for index, letter in enumerate(word):\n        if letter in vowels:\n            if index != 0 and index != len(word) - 1:\n                left_distance = index - [i for i in range(index) if word[i] not in vowels][-1]\n                right_distance = [i for i in range(index, len(word)) if word[i] not in vowels][0] - index\n                min_distance = min(left_distance, right_distance)\n                if min_distance > farthest_distance:\n                    farthest_index = index\n                    farthest_distance = min_distance\n    return word[farthest_index] if farthest_index != -1 else ''"
      ],
      [
        0.9155797362327576,
        "    vowels_lower = 'aeiou'\n    vowels_upper = 'AEIOU'\n    consonants_lower = 'bcdfghjklmnpqrstvwxyz'\n    consonants_upper = 'BCDFGHJKLMNPQRSTVWXYZ'\n    word = word[::-1]\n    for i in range(1, len(word) - 1):\n        if word[i] in vowels_lower and word[i - 1] in consonants_lower and (word[i + 1] in consonants_lower) or (word[i] in vowels_upper and word[i - 1] in consonants_upper and (word[i + 1] in consonants_upper)):\n            return word[i]\n    return ''"
      ],
      [
        0.9152066707611084,
        "    if len(word) < 3:\n        return ''\n    is_vowel = ['aeiouAEIOU'.find(c) != -1 for c in word]\n    for i in range(len(word) - 2, 0, -1):\n        if is_vowel[i - 1] == is_vowel[i + 1] == False and is_vowel[i] == True:\n            return word[i]\n    return ''"
      ],
      [
        0.914842963218689,
        "    vowels = 'aeiouAEIOU'\n    farthest_index = -1\n    farthest_distance = -1\n    for index, letter in enumerate(word):\n        if letter in vowels:\n            if index != 0 and index != len(word) - 1:\n                left_distance = index - max((i for i in range(index) if word[i] not in vowels))\n                right_distance = min((i for i in range(index, len(word)) if word[i] not in vowels)) - index\n                min_distance = min(left_distance, right_distance)\n                if min_distance > farthest_distance:\n                    farthest_index = index\n                    farthest_distance = min_distance\n    return word[farthest_index] if farthest_index != -1 else ''"
      ],
      [
        0.9147351980209351,
        "    reversed_word = word[::-1]\n    for i in range(1, len(reversed_word) - 1):\n        if reversed_word[i] in 'aeiouAEIOU' and reversed_word[i - 1] not in 'aeiouAEIOU' and (reversed_word[i + 1] not in 'aeiouAEIOU'):\n            return reversed_word[i]\n    return ''"
      ],
      [
        0.9147257804870605,
        "    reversed_word = word[::-1]\n    for i in range(1, len(reversed_word) - 1):\n        if reversed_word[i] in 'aeiouAEIOU' and reversed_word[i - 1] not in 'aeiouAEIOU' and (reversed_word[i + 1] not in 'aeiouAEIOU'):\n            return reversed_word[i]\n    return ''"
      ],
      [
        0.9143480062484741,
        "    vowels = 'aeiouAEIOU'\n    for i in range(len(word) - 1, 0, -1):\n        if word[i] in vowels and word[i - 1] not in vowels and (word[i + 1] not in vowels):\n            return word[i]\n    return ''"
      ],
      [
        0.9132934808731079,
        "    vowels = 'aeiouAEIOU'\n    for i in reversed(range(1, len(word) - 1)):\n        if word[i] in vowels and word[i - 1] not in vowels and (word[i + 1] not in vowels):\n            return word[i]\n    return ''"
      ]
    ],
    "HumanEval/119": [
      [
        0.9256728887557983,
        "    string = ''.join(lst)\n    parentheses_stack = []\n    for i in string:\n        if i == '(':\n            parentheses_stack.append(i)\n        else:\n            if not parentheses_stack:\n                return 'No'\n            parentheses_stack.pop()\n    if parentheses_stack:\n        return 'No'\n    return 'Yes'"
      ],
      [
        0.9228885769844055,
        "    total = ''.join(lst)\n    stack = []\n    for char in total:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return 'No'\n            stack.pop()\n    return 'Yes' if not stack else 'No'"
      ],
      [
        0.9212137460708618,
        "    opening_parentheses = ['(', '[']\n    closing_parentheses = [')', ']']\n    stack = []\n    s = ''.join(lst)\n    for i in s:\n        if i in opening_parentheses:\n            stack.append(i)\n        elif i in closing_parentheses:\n            if not stack or opening_parentheses.index(stack.pop()) != closing_parentheses.index(i):\n                return 'No'\n    if stack:\n        return 'No'\n    return 'Yes'"
      ],
      [
        0.9212011098861694,
        "    str_lst = ''.join(lst)\n    depth = 0\n    for c in str_lst:\n        if c == '(':\n            depth += 1\n        elif c == ')':\n            depth -= 1\n        if depth < 0:\n            return 'No'\n    if depth != 0:\n        return 'No'\n    return 'Yes'"
      ],
      [
        0.9201107025146484,
        "    stack = []\n    bracket_map = {'(': ')', '[': ']'}\n    for bracket in lst[0] + lst[1]:\n        if bracket in bracket_map:\n            stack.append(bracket)\n        else:\n            try:\n                if bracket_map[stack.pop()] != bracket:\n                    return False\n            except IndexError:\n                return False\n    return stack == []"
      ],
      [
        0.91965651512146,
        "    for sub in lst:\n        for char in sub:\n            if char == '(':\n                opening_brackets += 1\n            elif char == ')':\n                if opening_brackets == 0:\n                    return 'No'\n                opening_brackets -= 1"
      ],
      [
        0.9195977449417114,
        "    for c in str_lst:\n        if c == '(':\n            depth += 1\n        elif c == ')':\n            depth -= 1\n        if depth < 0:\n            return 'No'"
      ],
      [
        0.9190965294837952,
        "    for string in lst:\n        for char in string:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack or stack.pop() != '(':\n                    return 'No'"
      ],
      [
        0.9190124273300171,
        "    stack = []\n    for string in lst:\n        for char in string:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack or stack.pop() != '(':\n                    return 'No'\n    return 'Yes' if not stack else 'No'"
      ],
      [
        0.9165945649147034,
        "    opening_brackets = 0\n    for sub in lst:\n        for char in sub:\n            if char == '(':\n                opening_brackets += 1\n            elif char == ')':\n                if opening_brackets == 0:\n                    return 'No'\n                opening_brackets -= 1\n    return 'Yes' if opening_brackets == 0 else 'No'"
      ]
    ],
    "HumanEval/120": [
      [
        0.9259288907051086,
        "    if len(arr) < k:\n        return arr\n    for i in range(1, len(arr)):\n        j = i - 1\n        while j >= 0 and arr[j] < arr[j + 1]:\n            arr[j], arr[j + 1] = (arr[j + 1], arr[j])\n            j -= 1\n    return arr[:k]"
      ],
      [
        0.9252508878707886,
        "    if k <= len(arr) and k > 0:\n        max_heap = [-num for num in arr]\n        heapq.heapify(max_heap)\n        for _ in range(k):\n            smallest = heapq.heappop(max_heap)\n        return -smallest"
      ],
      [
        0.9226902723312378,
        "    arr.sort(reverse=True)\n    ans = []\n    for i in range(k):\n        ans.append(arr[i])\n    return ans"
      ],
      [
        0.9219975471496582,
        "    arr.sort()\n    return arr[:-k]"
      ],
      [
        0.9205211400985718,
        "    top_k = []\n    for num in arr:\n        if len(top_k) < k:\n            top_k.append(num)\n        else:\n            min_num = min(top_k)\n            if num > min_num:\n                top_k.remove(min_num)\n                top_k.append(num)\n    return top_k"
      ],
      [
        0.9191430807113647,
        "    arr.sort(reverse=True)\n    return arr[:k]"
      ],
      [
        0.9184861183166504,
        "    arr.sort()\n    return arr[len(arr) - k]"
      ],
      [
        0.9184821248054504,
        "    arr.sort()\n    return arr[len(arr) - k]"
      ],
      [
        0.9184650182723999,
        "    arr.sort()\n    return arr[-k:]"
      ],
      [
        0.9174765348434448,
        "    freq_dict = {}\n    for i in arr:\n        if i in freq_dict:\n            freq_dict[i] += 1\n        else:\n            freq_dict[i] = 1\n    sorted_freq_dict = sorted(freq_dict.items(), key=lambda kv: kv[1], reverse=True)\n    k_most_freq = []\n    for i in range(k):\n        k_most_freq.append(sorted_freq_dict[i][0])\n    return k_most_freq"
      ]
    ],
    "HumanEval/121": [
      [
        0.9382939338684082,
        "    return sum((x for x in lst if x % 2 == 0))"
      ],
      [
        0.9355632066726685,
        "    sum = 0\n    for num in lst:\n        if num % 2 == 0:\n            sum += num\n    return sum"
      ],
      [
        0.9355589747428894,
        "    sum = 0\n    for num in lst:\n        if num % 2 == 0:\n            sum += num\n    return sum"
      ],
      [
        0.9355555176734924,
        "    sum = 0\n    for num in lst:\n        if num % 2 == 0:\n            sum += num\n    return sum"
      ],
      [
        0.9354623556137085,
        "    return sum((num for num in lst if num % 2 == 0))"
      ],
      [
        0.9354013204574585,
        "    sum = 0\n    for ele in lst:\n        if ele % 2 == 1:\n            sum += ele\n    return sum"
      ],
      [
        0.9352834224700928,
        "    sum = 0\n    for num in lst:\n        if num % 2 != 0:\n            sum += num\n    return sum"
      ],
      [
        0.9347200393676758,
        "                for i in range(0, len(lst), 2):\n                    if isinstance(lst[i], int):\n                        if lst[i] % 2 != 0:\n                            result += lst[i]\n                    else:\n                        return 'Error: List contains non-integer element.'"
      ],
      [
        0.9347178936004639,
        "                for i in range(0, len(lst), 2):\n                    if isinstance(lst[i], int):\n                        if lst[i] % 2 != 0:\n                            result += lst[i]\n                    else:\n                        return 'Error: List contains non-integer element.'"
      ],
      [
        0.9340937733650208,
        "    sum_even = 0\n    for i in lst:\n        if i % 2 == 0:\n            sum_even += i\n    return sum_even"
      ]
    ],
    "HumanEval/122": [
      [
        0.8954623937606812,
        "    if K <= len(arr) // 2:\n        sorted_arr = sorted(arr, reverse=True)\n        sum_of_max_digits = sum(sorted_arr[:K])\n        return sum_of_max_digits\n    else:\n        sorted_arr = sorted(arr)\n        sum_of_min_digits = -sum(sorted_arr[:len(arr) - K])\n        return sum_of_min_digits"
      ],
      [
        0.8952850699424744,
        "    retrieved_elements = arr[2:5]\n    sum_of_elements = sum(retrieved_elements)\n    if sum_of_elements >= 100:\n        return sum_of_elements\n    else:\n        return sum_of_elements / 10"
      ],
      [
        0.8914470076560974,
        "    if K > len(arr):\n        return -1\n    if K <= len(arr) // 2:\n        sorted_arr = sorted(arr, reverse=True)\n        sum_of_max_digits = sum(sorted_arr[:K])\n        return sum_of_max_digits\n    else:\n        sorted_arr = sorted(arr)\n        sum_of_min_digits = -sum(sorted_arr[:len(arr) - K])\n        return sum_of_min_digits"
      ],
      [
        0.8906842470169067,
        "    include = 0\n    exclude = 0\n    selected_elements = set()\n    for i in range(len(arr)):\n        new_include = max(include, exclude)\n        include = arr[i] + exclude\n        exclude = max(include, exclude)\n        include = new_include\n        if arr[i] % 2 == 1 or arr[i] < 0:\n            i += 1\n        elif arr[i] > 0 and arr[i] % 2 == 0 and (arr[i] not in selected_elements):\n            selected_elements.add(arr[i])\n            if len(selected_elements) == k:\n                break\n    return sum(selected_elements)"
      ],
      [
        0.8894398212432861,
        "    len1 = len(arr1)\n    len2 = len(arr2)\n    min_len = min(len1, len2)\n    new_array = []\n    for i in range(min_len):\n        new_element = arr1[i] + arr2[i]\n        new_array.append(new_element)\n        if new_element > 100:\n            new_array[-1] = 100\n    if len1 > len2:\n        for i in range(min_len, len1):\n            new_element = arr1[i]\n            if new_element > 100:\n                new_element = 100\n            if sum(new_array) + new_element > 1000:\n                break\n            new_array.append(new_element)\n    if len2 > len1:\n        for i in range(min_len, len2):\n            new_element = arr2[i]\n            if new_element > 100:\n                new_element = 100\n            if sum(new_array) + new_element > 1000:\n                break\n            new_array.append(new_element)\n    return new_array"
      ],
      [
        0.8879009485244751,
        "    total = 0\n    for num in arr:\n        if len(str(num)) == 3:\n            total += num\n    return total"
      ],
      [
        0.8876810073852539,
        "    if K > len(arr):\n        return -1\n    sorted_arr = sorted(arr, reverse=True)\n    sum_of_max_digits = sum(sorted_arr[:K])\n    return sum_of_max_digits"
      ],
      [
        0.8867008686065674,
        "    if index <= 2:\n        return arr[index] + sum_of_first_three_elements(arr, index + 1)\n    else:\n        return 0"
      ],
      [
        0.8867008686065674,
        "    if index <= 2:\n        return arr[index] + sum_of_first_three_elements(arr, index + 1)\n    else:\n        return 0"
      ],
      [
        0.8834466934204102,
        "    arr.sort()\n    return arr[0] + arr[1]"
      ]
    ],
    "HumanEval/123": [
      [
        0.9235935211181641,
        "    collatz = []\n    while n != 1:\n        collatz.append(n)\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n    collatz.append(1)\n    return collatz"
      ],
      [
        0.9072116613388062,
        "    while n != 1:\n        collatz.append(n)\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1"
      ],
      [
        0.9057536125183105,
        "        if n % 2 == 0:\n            sequence, steps = collatz(n // 2)\n            collatz_dict[n] = ([n] + sequence, steps + 1)\n        else:\n            sequence, steps = collatz(3 * n + 1)\n            collatz_dict[n] = ([n] + sequence, steps + 1)"
      ],
      [
        0.9053941965103149,
        "    if n not in collatz_dict:\n        if n % 2 == 0:\n            sequence, steps = collatz(n // 2)\n            collatz_dict[n] = ([n] + sequence, steps + 1)\n        else:\n            sequence, steps = collatz(3 * n + 1)\n            collatz_dict[n] = ([n] + sequence, steps + 1)\n    return collatz_dict[n]"
      ],
      [
        0.9050689339637756,
        "    if n not in collatz_dict:\n        if n % 2 == 0:\n            sequence, steps = collatz(n // 2)\n            collatz_dict[n] = ([n] + sequence, steps + 1)\n        else:\n            sequence, steps = collatz(3 * n + 1)\n            collatz_dict[n] = ([n] + sequence, steps + 1)"
      ],
      [
        0.9023639559745789,
        "    odd_numbers = []\n    for i in range(1, n + 1):\n        if i % 2 != 0:\n            odd_numbers.append(i)\n    return odd_numbers"
      ],
      [
        0.9003139734268188,
        "    odd_numbers = [num for num in arr if num % 2 != 0]\n    odd_numbers = sort_odd_numbers(odd_numbers)\n    odd_numbers = remove_duplicates(odd_numbers)\n    return odd_numbers"
      ],
      [
        0.8992223739624023,
        "    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    elif n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    else:\n        sequence = []\n        while n != 1:\n            sequence.append(n)\n            n = n / 2 if n % 2 == 0 else 3 * n + 1\n        sequence.append(1)\n    return sequence"
      ],
      [
        0.8989180326461792,
        "    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    elif n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    else:\n        sequence = []\n        while n != 1:\n            sequence.append(n)\n            n = n / 2 if n % 2 == 0 else 3 * n + 1\n        sequence.append(1)"
      ],
      [
        0.8983014225959778,
        "    collatz = collatzSequence(n)\n    primes = generatePrimes(max(collatz))\n    collatz = [i for i in collatz if i in primes]\n    collatz.sort()\n    return collatz"
      ]
    ],
    "HumanEval/124": [
      [
        0.9252256155014038,
        "    month_map = {'jan': 1, 'feb': 2, 'mar': 3, 'apr': 4, 'may': 5, 'jun': 6, 'jul': 7, 'aug': 8, 'sep': 9, 'oct': 10, 'nov': 11, 'dec': 12}\n    month_days_map = {1: 31, 2: 28, 3: 31, 4: 30, 5: 31, 6: 30, 7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31}\n    date = date.strip()\n    separators = ['/', '-', '.']\n    separator = None\n    for sep in separators:\n        if sep in date:\n            separator = sep\n            break\n    if separator is None:\n        return False\n    parts = date.split(separator)\n    if len(parts) != 3:\n        return False\n    if separator == '.':\n        month, day, year = (parts[0], parts[1], parts[2])\n    else:\n        month, day, year = (parts[0], parts[1], parts[2][:4])\n    if month.isdigit():\n        month = int(month)\n    else:\n        month = month_map.get(month.lower())\n    if month is None or month < 1 or month > 12:\n        return False\n    if not year.isdigit() or len(year) != 4:\n        return False\n    year = int(year)\n    if year < 1582 or (year == 1582 and month < 10) or (year == 1582 and month == 10 and (day < 4)):\n        return False\n    if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n        month_days_map[2] = 29\n    if not day.isdigit() or int(day) < 1 or int(day) > month_days_map[month]:\n        return False\n    return True"
      ],
      [
        0.9229251146316528,
        "    date_parts = input_date.split('/')\n    if len(date_parts) != 3:\n        return 'Invalid date'\n    day = int(date_parts[1])\n    month = int(date_parts[0])\n    year = int(date_parts[2])\n    if month < 1 or month > 12:\n        return 'Invalid date'\n    if day < 1 or day > 31:\n        return 'Invalid date'\n    if month in [4, 6, 9, 11] and day > 30:\n        return 'Invalid date'\n    if month == 2:\n        if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            if day > 29:\n                return 'Invalid date'\n        elif day > 28:\n            return 'Invalid date'\n    converted_date = str(day).zfill(2) + '-' + str(month).zfill(2) + '-' + str(year)\n    return converted_date"
      ],
      [
        0.9224104881286621,
        "    try:\n        day, month, year = map(int, date_str.split('/'))\n        if year < 1:\n            return 'Invalid date'\n        if month < 1 or month > 12:\n            return 'Invalid date'\n        if month in [4, 6, 9, 11] and day > 30:\n            return 'Invalid date'\n        if month == 2:\n            if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n                if day > 29:\n                    return 'Invalid date'\n            elif day > 28:\n                return 'Invalid date'\n        elif day > 31:\n            return 'Invalid date'\n        return 'Valid date'\n    except ValueError:\n        return 'Invalid date'"
      ],
      [
        0.9224104881286621,
        "    try:\n        day, month, year = map(int, date_str.split('/'))\n        if year < 1:\n            return 'Invalid date'\n        if month < 1 or month > 12:\n            return 'Invalid date'\n        if month in [4, 6, 9, 11] and day > 30:\n            return 'Invalid date'\n        if month == 2:\n            if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n                if day > 29:\n                    return 'Invalid date'\n            elif day > 28:\n                return 'Invalid date'\n        elif day > 31:\n            return 'Invalid date'\n        return 'Valid date'\n    except ValueError:\n        return 'Invalid date'"
      ],
      [
        0.9210453033447266,
        "    regex = '^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-[0-9]{4}$'\n    p = re.compile(regex)\n    if re.search(p, date) == None:\n        return False\n    else:\n        mm, dd, yyyy = map(int, date.split('-'))\n        if is_leap_year(yyyy) and mm == 2 and (dd > 29):\n            return False\n        if not is_leap_year(yyyy) and mm == 2 and (dd > 28):\n            return False\n        if dd > monthrange(yyyy, mm)[1]:\n            return False\n        return True"
      ],
      [
        0.9192676544189453,
        "    if len(date_str) != 10:\n        return False\n    month, day, year = date_str.split('/')\n    try:\n        month = int(month)\n        if month < 1 or month > 12:\n            return False\n    except ValueError:\n        return False\n    try:\n        day = int(day)\n        if day < 1 or day > 31:\n            return False\n    except ValueError:\n        return False\n    try:\n        year = int(year)\n    except ValueError:\n        return False\n    if month == 2 and day == 29:\n        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            return True\n        else:\n            return False\n    if month == 2 and day > 28:\n        return False\n    elif month in [4, 6, 9, 11] and day > 30:\n        return False\n    return True"
      ],
      [
        0.9183874130249023,
        "    year, month, day = map(int, date.split('-'))\n    if month < 1 or month > 12:\n        return 'No'\n    if day < 1 or day > 31:\n        return 'No'\n    if month in [4, 6, 9, 11] and day > 30:\n        return 'No'\n    if month == 2:\n        if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            if day > 29:\n                return 'No'\n        elif day > 28:\n            return 'No'\n    return 'Yes'"
      ],
      [
        0.9172987937927246,
        "    month, day, year = input_date.split('/')\n    if not 1 <= int(month) <= 12:\n        return ('Invalid date', False)\n    if not 1 <= int(day) <= 31:\n        return ('Invalid date', False)\n    if not 1000 <= int(year) <= 9999:\n        return ('Invalid date', False)\n    converted_date = f'{day}-{month}-{year}'\n    weekday = calendar.weekday(int(year), int(month), int(day))\n    is_weekday = weekday < 5\n    return (converted_date, is_weekday)"
      ],
      [
        0.9169000387191772,
        "    regex_ = '^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-[0-9]{4}$'\n    p = re.compile(regex)\n    if re.search(p, date) == None:\n        return False\n    else:\n        mm, dd, yyyy = map(int, date.split('-'))\n        if is_leap_year(yyyy) and mm == 2 and (dd > 29):\n            return False\n        if not is_leap_year(yyyy) and mm == 2 and (dd > 28):\n            return False\n        if dd > monthrange(yyyy, mm)[1]:\n            return False\n        return True"
      ],
      [
        0.9143874645233154,
        "    if re.search(p, date) == None:\n        return False\n    else:\n        mm, dd, yyyy = map(int, date.split('-'))\n        if is_leap_year(yyyy) and mm == 2 and (dd > 29):\n            return False\n        if not is_leap_year(yyyy) and mm == 2 and (dd > 28):\n            return False\n        if dd > monthrange(yyyy, mm)[1]:\n            return False\n        return True"
      ]
    ],
    "HumanEval/125": [
      [
        0.9241569638252258,
        "    if ' ' in txt or ',' in txt:\n        return [word for word in txt.replace(',', ' ').split()]\n    else:\n        return sum((1 for i in range(len(txt)) if i % 2 and txt[i].islower()))"
      ],
      [
        0.9241569638252258,
        "    if ' ' in txt or ',' in txt:\n        return [word for word in txt.replace(',', ' ').split()]\n    else:\n        return sum((1 for i in range(len(txt)) if i % 2 and txt[i].islower()))"
      ],
      [
        0.8986536860466003,
        "    if ',' in text:\n        return text.split(',')\n    elif ':' in text:\n        return text.split(':')\n    else:\n        return sum((c.islower() and (ord(c) - ord('a')) % 2 for c in text))"
      ],
      [
        0.8986536860466003,
        "    if ',' in text:\n        return text.split(',')\n    elif ':' in text:\n        return text.split(':')\n    else:\n        return sum((c.islower() and (ord(c) - ord('a')) % 2 for c in text))"
      ],
      [
        0.8964356184005737,
        "    if ',' in s:\n        return s.split(',')\n    elif ':' in s:\n        return s.split(':')\n    else:\n        return len([i for i in s if i.islower() and ord(i) % 2 == 1])"
      ],
      [
        0.8964356184005737,
        "    if ',' in s:\n        return s.split(',')\n    elif ':' in s:\n        return s.split(':')\n    else:\n        return len([i for i in s if i.islower() and ord(i) % 2 == 1])"
      ],
      [
        0.8956098556518555,
        "    if ' ' in str:\n        return str.split()\n    elif ';' in str:\n        return str.split(';')\n    else:\n        return sum([(ord(ch) - ord('A')) % 2 == 0 for ch in str if ch.isupper()])"
      ],
      [
        0.8956098556518555,
        "    if ' ' in str:\n        return str.split()\n    elif ';' in str:\n        return str.split(';')\n    else:\n        return sum([(ord(ch) - ord('A')) % 2 == 0 for ch in str if ch.isupper()])"
      ],
      [
        0.8946389555931091,
        "    if ',' in str:\n        return str.split(',')\n    if ';' in str:\n        return str.split(';')\n    if str.isupper():\n        return sum([1 for c in str if (ord(c) - ord('A')) % 2 == 0])\n    elif ' ' in str:\n        return str.split()\n    counts = {'upper': 0, 'lower': 0, 'digits': 0, 'others': 0}\n    for c in str:\n        if c.isupper():\n            counts['upper'] += 1\n        elif c.islower():\n            counts['lower'] += 1\n        elif c.isdigit():\n            counts['digits'] += 1\n        else:\n            counts['others'] += 1\n    return counts"
      ],
      [
        0.8935330510139465,
        "    count = 0\n    text_list = text.split()\n    for word in text_list:\n        count = count + 1\n    return count"
      ]
    ],
    "HumanEval/126": [
      [
        0.925591230392456,
        "    if not lst:\n        return True\n    if lst[0] > lst[1]:\n        return False\n    return is_sorted(lst[1:])"
      ],
      [
        0.9255355596542358,
        "    if len(lst) <= 1:\n        return True\n    mid = len(lst) // 2\n    left = lst[:mid]\n    right = lst[mid:]\n    return is_sorted(left) and is_sorted(right) and (left[-1] <= right[0])"
      ],
      [
        0.9247540235519409,
        "    if not lst or len(lst) == 1:\n        print('List needs at least two elements for comparison.')\n        return False\n    try:\n        for i in range(len(lst) - 1):\n            if not isinstance(lst[i], (int, float)) or not isinstance(lst[i + 1], (int, float)):\n                print('Non-numeric values found in list.')\n                return False\n            if lst[i] >= lst[i + 1]:\n                return False\n        return True\n    except Exception as e:\n        print(f'Unexpected error: {e}')\n        return False"
      ],
      [
        0.924433708190918,
        "        for i in range(len(lst) - 1):\n            if not isinstance(lst[i], (int, float)) or not isinstance(lst[i + 1], (int, float)):\n                print('Non-numeric values found in list.')\n                return False\n            if lst[i] >= lst[i + 1]:\n                return False"
      ],
      [
        0.9232003092765808,
        "    if not lst:\n        return True\n    if not all((isinstance(i, int) for i in lst)):\n        raise ValueError('List must contain only integers.')\n    lst.sort()\n    for i in range(1, len(lst)):\n        if lst[i] == lst[i - 1]:\n            return False\n    return True"
      ],
      [
        0.9231412410736084,
        "    is_sorted = True\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i + 1]:\n            is_sorted = False\n            break\n    return is_sorted"
      ],
      [
        0.9220023155212402,
        "    if not lst:\n        raise ValueError('List is empty.')\n    if len(lst) == 1:\n        raise ValueError('List contains only one element.')\n    for i in range(len(lst) - 1):\n        if not (isinstance(lst[i], int) or isinstance(lst[i], float)) or not (isinstance(lst[i + 1], int) or isinstance(lst[i + 1], float)):\n            raise ValueError('List contains non-numeric values.')\n        if lst[i] <= lst[i + 1]:\n            return False\n    return True"
      ],
      [
        0.9218246340751648,
        "    if not lst:\n        print('List is empty.')\n        return False\n    if not all((isinstance(x, (int, float)) for x in lst)):\n        print('All elements in the list are not numerical values.')\n        return False\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True"
      ],
      [
        0.9218223690986633,
        "    if not lst:\n        print('List is empty.')\n        return False\n    if not all((isinstance(x, (int, float)) for x in lst)):\n        print('All elements in the list are not numerical values.')\n        return False\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True"
      ],
      [
        0.9213091135025024,
        "    if not isinstance(lst, list):\n        raise ValueError('The input must be a list.')\n    if len(lst) < 1:\n        raise ValueError('The list is empty.')\n    if len(lst) < 2:\n        raise ValueError('The list must contain more than one element.')\n    if not all((isinstance(item, (int, float)) for item in lst)):\n        raise ValueError('All elements in the list should be numeric.')\n    for i in range(len(lst) - 1):\n        if lst[i] >= lst[i + 1]:\n            return False\n    return True"
      ]
    ],
    "HumanEval/127": [
      [
        0.9030736684799194,
        "    elif all((sieve[i] for i in lst1)):\n        return 'YES'\n    else:\n        return 'NO'"
      ],
      [
        0.9030609726905823,
        "    elif all((sieve[i] for i in lst1)):\n        return 'YES'\n    else:\n        return 'NO'"
      ],
      [
        0.8990699052810669,
        "    if a < 0 or b < 0:\n        return 'Invalid input. Please enter non-negative values.'\n    elif a > b:\n        return 'Invalid input. The start number should be less than or equal to the end number.'\n    primes = []\n    for num in range(a, b + 1):\n        if num > 1:\n            for i in range(2, num):\n                if num % i == 0:\n                    break\n            else:\n                primes.append(num)\n    return (primes, len(primes))"
      ],
      [
        0.8967109322547913,
        "    if start_num > end_num:\n        return 'Error: start_num is greater than end_num'\n    start_num = max(start_num, -20)\n    end_num = min(end_num, 100)\n    count = 0\n    for num in range(start_num, end_num + 1):\n        if num > 1:\n            is_prime = True\n            for i in range(2, int(num ** 0.5) + 1):\n                if num % i == 0:\n                    is_prime = False\n                    break\n            if is_prime:\n                count += 1\n    return count"
      ],
      [
        0.8948162794113159,
        "    if prime_numbers:\n        print('Prime numbers between', start, 'and', end, 'are:')\n        for prime in prime_numbers:\n            print(prime)\n    else:\n        print('There are no prime numbers between', start, 'and', end)"
      ],
      [
        0.894804835319519,
        "    if prime_numbers:\n        print('Prime numbers between', start, 'and', end, 'are:')\n        for prime in prime_numbers:\n            print(prime)\n    else:\n        print('There are no prime numbers between', start, 'and', end)"
      ],
      [
        0.8944292068481445,
        "    assert is_prime(4) == 'no'\n    assert is_prime(3) == 'yes'\n    assert is_prime(8) == 'no'"
      ],
      [
        0.8935296535491943,
        "    max_limit = max(end_1, end_2)\n    primes = sieve_eratosthenes(max_limit)\n    return [prime for prime in primes if max(start_1, start_2) <= prime <= min(end_1, end_2)]"
      ],
      [
        0.8933018445968628,
        "    if not (isinstance(x, int) and isinstance(y, int) and (x > 0) and (y > 0)):\n        return 'x and y must be positive integers'\n    elif x >= y:\n        return 'x must be less than y'\n    nums = list(range(x, y + 1))\n    for num in nums:\n        is_prime = True\n        for i in range(2, num):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            print(num)"
      ],
      [
        0.8930823802947998,
        "    if change:\n        return 'YES' if sum(lst1) == sum1 and sum(lst2) == sum2 else 'NO'\n    elif all((sieve[i] for i in lst1)):\n        return 'YES'\n    else:\n        return 'NO'"
      ]
    ],
    "HumanEval/128": [
      [
        0.9400964975357056,
        "    if not arr or 0 in arr:\n        return None\n    distinct_arr = list(set(arr))\n    signs_prod = 1\n    for num in distinct_arr:\n        signs_prod *= 1 if num > 0 else -1\n    sum_abs = sum((abs(num) for num in distinct_arr))\n    return signs_prod * sum_abs"
      ],
      [
        0.9387320280075073,
        "    if len(arr) == 0 or 0 in arr:\n        return None\n    arr = list(set(arr))\n    prod = 1\n    sgn_prod = 1\n    for num in arr:\n        prod *= abs(num)\n        sgn_prod *= 1 if num > 0 else -1\n    return prod * sgn_prod"
      ],
      [
        0.9375760555267334,
        "    if not arr or len(arr) > 500 or any((abs(x) > 500 for x in arr)):\n        return None\n    arr = [x for x in arr if x != 0]\n    unique_arr = list(set(arr))\n    sign_product = 1\n    sum_ = 0\n    for x in unique_arr:\n        sign_product *= 1 if x > 0 else -1\n        sum_ += abs(x)\n    return sign_product * sum_"
      ],
      [
        0.9356793761253357,
        "    if not arr:\n        return None\n    arr = list(set([i for i in arr if i != 0]))\n    if not arr:\n        return None\n    sign_product = 1\n    abs_val_sum = 0\n    for i in arr:\n        sign_product *= -1 if i < 0 else 1\n        abs_val_sum += abs(i)\n    return sign_product * abs_val_sum"
      ],
      [
        0.9351511001586914,
        "    if len(arr) == 0 or (len(arr) == 1 and arr[0] == 0):\n        return None\n    result = 0\n    total_sign = 1\n    seen = set()\n    for num in arr:\n        if num != 0:\n            sign = 1 if num > 0 else -1\n            total_sign *= sign\n            seen.add(abs(num))\n    result = total_sign * sum(seen)\n    return result"
      ],
      [
        0.9339354038238525,
        "    if arr is None or len(arr) == 0:\n        return None\n    distinct_elements = set(filter(None, arr))\n    if len(distinct_elements) == 0:\n        return None\n    sum_of_products = 0\n    for element in distinct_elements:\n        product_of_tags = arr.count(element) if element > 0 else -arr.count(element)\n        sum_of_products += abs(element) * product_of_tags\n    return sum_of_products"
      ],
      [
        0.9323292970657349,
        "    unique_primes = set()\n    for i in arr:\n        if is_prime(abs(i)):\n            unique_primes.add(i)\n    if not unique_primes:\n        return None\n    summed_magnitudes = sum((abs(x) for x in unique_primes))\n    multiplied_signs = sign(sum((sign(x) for x in unique_primes)))\n    return summed_magnitudes * multiplied_signs"
      ],
      [
        0.9289535284042358,
        "    if not arr:\n        return None\n    distinct_signs_product = 1\n    distinct_absolute_sums = 0\n    distinct_elements = set()\n    for n in arr:\n        if n == 0:\n            return None\n        absolute_value = abs(n)\n        if absolute_value in distinct_elements:\n            continue\n        distinct_elements.add(absolute_value)\n        sign = n / absolute_value\n        distinct_signs_product *= sign\n        distinct_absolute_sums += absolute_value\n    return distinct_signs_product * distinct_absolute_sums"
      ],
      [
        0.9270734786987305,
        "    if not arr:\n        return None\n    pos = {x for x in arr if x > 0}\n    neg = {x for x in arr if x < 0}\n    total_sum = sum(pos) + sum(neg)\n    total_mult = len(pos) * len(neg) if neg else len(pos)\n    return total_sum * total_mult"
      ],
      [
        0.9251378774642944,
        "    if not arr:\n        return None\n    val, sign = (0, 1)\n    for num in arr:\n        if num == 0:\n            return None\n        else:\n            val += abs(num) * (1 if num > 0 else -1)\n    return val"
      ]
    ],
    "HumanEval/129": [
      [
        0.935864269733429,
        "    n = len(grid)\n    pq = PriorityQueue()\n    for i in range(n):\n        for j in range(n):\n            pq.put((grid[i][j], (i, j)))\n    smallest_k_paths = []\n    for _ in range(k):\n        _, (i, j) = pq.get()\n        visited = [[False] * n for _ in range(n)]\n        visited[i][j] = True\n        q = deque([(i, j, [grid[i][j]])])\n        while q:\n            x, y, path = q.popleft()\n            if len(path) == k:\n                smallest_k_paths.append(sorted(path))\n                break\n            for dx, dy in directions:\n                nx, ny = (x + dx, y + dy)\n                if isValid(nx, ny, n) and (not visited[nx][ny]):\n                    visited[nx][ny] = True\n                    q.append((nx, ny, path + [grid[nx][ny]]))\n    return smallest_k_paths"
      ],
      [
        0.935860276222229,
        "    n = len(grid)\n    pq = PriorityQueue()\n    for i in range(n):\n        for j in range(n):\n            pq.put((grid[i][j], (i, j)))\n    smallest_k_paths = []\n    for _ in range(k):\n        _, (i, j) = pq.get()\n        visited = [[False] * n for _ in range(n)]\n        visited[i][j] = True\n        q = deque([(i, j, [grid[i][j]])])\n        while q:\n            x, y, path = q.popleft()\n            if len(path) == k:\n                smallest_k_paths.append(sorted(path))\n                break\n            for dx, dy in directions:\n                nx, ny = (x + dx, y + dy)\n                if isValid(nx, ny, n) and (not visited[nx][ny]):\n                    visited[nx][ny] = True\n                    q.append((nx, ny, path + [grid[nx][ny]]))\n    return smallest_k_paths"
      ],
      [
        0.929392397403717,
        "    N = len(grid)\n    minheap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = set([(0, 0)])\n    while minheap:\n        cost, i, j, path = heapq.heappop(minheap)\n        if len(path) == k:\n            return path[:k]\n        for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if 0 <= x < N and 0 <= y < N and ((x, y) not in visited):\n                visited.add((x, y))\n                new_cost = cost + grid[x][y]\n                new_path = path + [grid[x][y]]\n                heapq.heappush(minheap, (new_cost, x, y, new_path))"
      ],
      [
        0.9290235638618469,
        "    n = len(grid)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    heap = [(grid[0][0], 0, 0)]\n    visit = [[0 for _ in range(n)] for _ in range(n)]\n    visit[0][0] = 1\n    cell_values = []\n    while heap:\n        value, x, y = heapq.heappop(heap)\n        cell_values.append(value)\n        if len(cell_values) == k:\n            break\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not visit[nx][ny]):\n                visit[nx][ny] = 1\n                heapq.heappush(heap, (grid[nx][ny], nx, ny))\n    return sorted(cell_values[:k])"
      ],
      [
        0.928361177444458,
        "    if not grid or len(grid) == 0:\n        return []\n    N = len(grid)\n    M = len(grid[0])\n    if k < N * M:\n        return []\n    dp = [[0 for _ in range(N)] for __ in range(M)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, N):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for i in range(1, M):\n        dp[0][i] = dp[0][i - 1] + grid[0][i]\n    for i in range(1, M):\n        for j in range(1, N):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    path = []\n    i, j = (M - 1, N - 1)\n    while len(path) < k:\n        path.append(grid[i][j])\n        if i > 0 and j > 0:\n            if dp[i - 1][j] < dp[i][j - 1]:\n                i -= 1\n            else:\n                j -= 1\n        elif i > 0:\n            i -= 1\n        elif j > 0:\n            j -= 1\n        else:\n            break\n    return sorted(path)"
      ],
      [
        0.9275223016738892,
        "    pq, path, visited, result = ([], [], set(), [])\n    n = len(grid)\n    pq.append((grid[0][0], 0, 0))\n    while pq:\n        val, x, y = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return path\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_x, new_y = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return path"
      ],
      [
        0.9275161623954773,
        "    pq, path, visited, result = ([], [], set(), [])\n    n = len(grid)\n    pq.append((grid[0][0], 0, 0))\n    while pq:\n        val, x, y = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return path\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_x, new_y = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return path"
      ],
      [
        0.9268295764923096,
        "    N = len(grid)\n    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = [[0 for _ in range(N)] for _ in range(N)]\n    ret = []\n    for i in range(N):\n        for j in range(N):\n            heap = [(grid[i][j], i, j)]\n            min_val = [grid[i][j]]\n            while heap and len(min_val) < K:\n                cost, x, y = heapq.heappop(heap)\n                if visited[x][y] == 1:\n                    continue\n                visited[x][y] = 1\n                for dx, dy in direction:\n                    nx, ny = (x + dx, y + dy)\n                    if 0 <= nx < N and 0 <= ny < N and (visited[nx][ny] == 0):\n                        min_val.append(grid[nx][ny])\n                        heapq.heappush(heap, (grid[nx][ny], nx, ny))\n            visited = [[0 for _ in range(N)] for _ in range(N)]\n            min_val.sort()\n            ret.append(min_val[:K])\n    return ret"
      ],
      [
        0.9266260862350464,
        "    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blocked_cell in blocked_cells:\n        distances[blocked_cell[0]][blocked_cell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    while not queue.empty():\n        cur_i, cur_j = queue.get()\n        for direction in directions:\n            new_i, new_j = (cur_i + direction[0], cur_j + direction[1])\n            if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                new_distance = distances[cur_i][cur_j] + 1\n                if new_distance < distances[new_i][new_j]:\n                    distances[new_i][new_j] = new_distance\n                    queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
      ],
      [
        0.9261231422424316,
        "    while pq:\n        val, x, y = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return path\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_x, new_y = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))"
      ]
    ],
    "HumanEval/130": [
      [
        0.9249154329299927,
        "    for i in range(3, n + 1):\n        trib[i] = trib[i - 3] + trib[i - 2] + trib[i - 1]"
      ],
      [
        0.9238795042037964,
        "    if n == 0:\n        return 0\n    elif n == 1 or n == 2:\n        return 1\n    trib = [0, 1, 1] + [0] * (n - 2)\n    for i in range(3, n + 1):\n        trib[i] = trib[i - 1] + trib[i - 2] + trib[i - 3]\n    return trib[n]"
      ],
      [
        0.923575758934021,
        "    for i in range(3, n + 1):\n        trib[i] = trib[i - 1] + trib[i - 2] + trib[i - 3]"
      ],
      [
        0.9234954714775085,
        "    if n in memo:\n        return memo[n]\n    elif n == 0:\n        return 0\n    elif n == 1 or n == 2:\n        return 1\n    elif n < 0:\n        result = tribonacci(n + 3, memo) - tribonacci(n + 2, memo) - tribonacci(n + 1, memo)\n    else:\n        result = tribonacci(n - 1, memo) + tribonacci(n - 2, memo) + tribonacci(n - 3, memo)"
      ],
      [
        0.9234778881072998,
        "    if n in memo:\n        return memo[n]\n    elif n == 0:\n        return 0\n    elif n == 1 or n == 2:\n        return 1\n    elif n < 0:\n        result = tribonacci(n + 3, memo) - tribonacci(n + 2, memo) - tribonacci(n + 1, memo)\n    else:\n        result = tribonacci(n - 1, memo) + tribonacci(n - 2, memo) + tribonacci(n - 3, memo)"
      ],
      [
        0.9226125478744507,
        "    sequence = []\n    if n < 0:\n        return sequence\n    if n >= 0:\n        sequence.append(3)\n    if n >= 2:\n        sequence.append(2)\n    if n >= 3:\n        sequence.append(sequence[-2] + sequence[-1] + 1)\n    for i in range(4, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i // 2)\n        else:\n            sequence.append(sequence[-2] + sequence[-1] + sequence[-3])\n    return sequence"
      ],
      [
        0.9223664402961731,
        "    if n in memo:\n        return memo[n]\n    elif n == 0:\n        return 0\n    elif n == 1 or n == 2:\n        return 1\n    elif n < 0:\n        result = tribonacci(n + 3, memo) - tribonacci(n + 2, memo) - tribonacci(n + 1, memo)\n    else:\n        result = tribonacci(n - 1, memo) + tribonacci(n - 2, memo) + tribonacci(n - 3, memo)\n    memo[n] = result\n    return result"
      ],
      [
        0.922335684299469,
        "    if n in memo:\n        return memo[n]\n    elif n == 0:\n        return 0\n    elif n == 1 or n == 2:\n        return 1\n    elif n < 0:\n        result = tribonacci(n + 3, memo) - tribonacci(n + 2, memo) - tribonacci(n + 1, memo)\n    else:\n        result = tribonacci(n - 1, memo) + tribonacci(n - 2, memo) + tribonacci(n - 3, memo)\n    memo[n] = result\n    return result"
      ],
      [
        0.9207459688186646,
        "    elif n == 0:\n        return 0\n    elif n == 1 or n == 2:\n        return 1\n    elif n < 0:\n        result = tribonacci(n + 3, memo) - tribonacci(n + 2, memo) - tribonacci(n + 1, memo)\n    else:\n        result = tribonacci(n - 1, memo) + tribonacci(n - 2, memo) + tribonacci(n - 3, memo)"
      ],
      [
        0.9207361936569214,
        "    elif n == 0:\n        return 0\n    elif n == 1 or n == 2:\n        return 1\n    elif n < 0:\n        result = tribonacci(n + 3, memo) - tribonacci(n + 2, memo) - tribonacci(n + 1, memo)\n    else:\n        result = tribonacci(n - 1, memo) + tribonacci(n - 2, memo) + tribonacci(n - 3, memo)"
      ]
    ],
    "HumanEval/131": [
      [
        0.9132908582687378,
        "    if not numbers:\n        return round(product)\n    elif 10 < numbers[0] < 20 and numbers[0] % 2 != 0:\n        return product_of_odd_numbers(numbers[1:], product * numbers[0])\n    else:\n        return product_of_odd_numbers(numbers[1:], product)"
      ],
      [
        0.9132908582687378,
        "    if not numbers:\n        return round(product)\n    elif 10 < numbers[0] < 20 and numbers[0] % 2 != 0:\n        return product_of_odd_numbers(numbers[1:], product * numbers[0])\n    else:\n        return product_of_odd_numbers(numbers[1:], product)"
      ],
      [
        0.9111405611038208,
        "    elif 10 < numbers[0] < 20 and numbers[0] % 2 != 0:\n        return product_of_odd_numbers(numbers[1:], product * numbers[0])\n    else:\n        return product_of_odd_numbers(numbers[1:], product)"
      ],
      [
        0.9067743420600891,
        "    n = [int(i) for i in str(n)]\n    odd = [i for i in n if i % 2 != 0]\n    even = [i for i in n if i % 2 == 0]\n    if len(odd) == 0:\n        half = len(even) // 2\n        product = 1\n        for num in even[:half]:\n            product *= num\n        return product\n    elif len(even) == 0:\n        half = len(odd) // 2\n        return sum(odd[:half])\n    else:\n        product = 1\n        for num in odd:\n            product *= num\n        return product + sum(even)"
      ],
      [
        0.9067422747612,
        "    n = [int(i) for i in str(n)]\n    evens = [i for i in n if i % 2 == 0]\n    odds = [i for i in n if i % 2 != 0]\n    if len(odds) == 0:\n        half = len(evens) // 2\n        product = 1\n        for i in range(half):\n            product *= evens[i]\n        return product\n    elif len(evens) == 0:\n        half = len(odds) // 2\n        return sum(odds[:half])\n    else:\n        return sum(evens) + eval('*'.join((str(i) for i in odds)))"
      ],
      [
        0.9045974612236023,
        "    s = str(n)\n    evens = [int(d) for d in s if int(d) % 2 == 0]\n    odds = [int(d) for d in s if int(d) % 2 == 1]\n    if len(evens) == len(s):\n        half = len(evens) // 2\n        result = 1\n        for i in range(half):\n            result *= evens[i]\n        return result\n    elif len(odds) == len(s):\n        half = len(odds) // 2\n        return sum(odds[:half])\n    else:\n        return sum(evens) * prod(odds)"
      ]
    ],
    "HumanEval/132": [
      [
        0.9089632034301758,
        "        elif char == '[' and nestedCount == 0:\n            count += 1\n        elif char == ']' and nestedCount == 0:\n            count -= 1\n        elif char == '[' and nestedCount > 0:\n            nestedCount += 1\n        elif char == ']' and nestedCount > 0:\n            nestedCount -= 1"
      ],
      [
        0.9070448875427246,
        "        elif char == '[':\n            is_nested = True\n        elif char == ']':\n            if is_nested:\n                count -= 1\n                is_nested = False"
      ],
      [
        0.9061774611473083,
        "        elif char == ']' and nestedCount == 0:\n            count -= 1\n        elif char == '[' and nestedCount > 0:\n            nestedCount += 1\n        elif char == ']' and nestedCount > 0:\n            nestedCount -= 1"
      ],
      [
        0.9060753583908081,
        "    open_bracket = set('{[(')\n    close_bracket = set('}])')\n    matching_bracket = {('}', '{'), (')', '('), (']', '[')}\n    stack = []\n    for i in string:\n        if i in open_bracket:\n            stack.append(i)\n        elif i in close_bracket:\n            if len(stack) == 0:\n                return False\n            elif (i, stack[-1]) not in matching_bracket:\n                return False\n            stack.pop()\n    if len(stack) == 0:\n        return True\n    else:\n        return False"
      ],
      [
        0.9041455388069153,
        "        elif char == '[' and nestedCount > 0:\n            nestedCount += 1\n        elif char == ']' and nestedCount > 0:\n            nestedCount -= 1"
      ],
      [
        0.9035516977310181,
        "    for char in string:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if len(stack) == 0 or stack[-1] != bracket_pairs[char]:\n                return False\n            stack.pop()"
      ],
      [
        0.9035272598266602,
        "    open_brace_stack = []\n    for char in string:\n        if char in ('{', '(', '['):\n            open_brace_stack.append(char)\n        elif char in ('}', ')', ']'):\n            if len(open_brace_stack) == 0:\n                return False\n            elif char == '}' and open_brace_stack[-1] == '{' or (char == ']' and open_brace_stack[-1] == '[') or (char == ')' and open_brace_stack[-1] == '('):\n                open_brace_stack.pop()\n            else:\n                return False\n    if len(open_brace_stack) > 0:\n        return False\n    return True"
      ],
      [
        0.903236448764801,
        "    for char in string:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack:\n                return False\n            opening_bracket = stack.pop()\n            if opening_brackets.index(opening_bracket) != closing_brackets.index(char):\n                return False"
      ],
      [
        0.9025713801383972,
        "    opening_brackets = {'(', '[', '{'}\n    closing_brackets = {')', ']', '}'}\n    bracket_map = {'(': ')', '[': ']', '{': '}'}\n    stack = []\n    for char in string:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if len(stack) == 0 or bracket_map[stack[-1]] != char:\n                return False\n            stack.pop()\n    return len(stack) == 0"
      ],
      [
        0.9025671482086182,
        "    stack = []\n    for i in bracket_list:\n        if i == '[' or i == '{':\n            stack.append(i)\n        elif i == ']':\n            if len(stack) != 0 and stack[-1] == '[':\n                stack.pop()\n            else:\n                return False\n        elif i == '}':\n            if len(stack) != 0 and stack[-1] == '{':\n                stack.pop()\n            else:\n                return False\n        elif i == ')':\n            if len(stack) != 0 and stack[-1] == '(':\n                stack.pop()\n            else:\n                return False\n    if len(stack) == 0:\n        return True\n    else:\n        return False"
      ]
    ],
    "HumanEval/133": [
      [
        0.9241422414779663,
        "    squared_list = []\n    for i in lst:\n        squared_list.append(i * i)\n    return squared_list"
      ],
      [
        0.9208261966705322,
        "    sum = 0\n    for element in lst:\n        sum += element ** 2\n    return sum"
      ],
      [
        0.9189855456352234,
        "    if idx < len(lst):\n        return lst[idx] ** 2 + recursive_sum_of_squares(lst, idx + 1)\n    else:\n        return 0"
      ],
      [
        0.9189855456352234,
        "    if idx < len(lst):\n        return lst[idx] ** 2 + recursive_sum_of_squares(lst, idx + 1)\n    else:\n        return 0"
      ],
      [
        0.9166054725646973,
        "    squares = []\n    for n in lst:\n        squares.append(n ** 2)\n    return squares"
      ],
      [
        0.9158025979995728,
        "    return sum([num ** 2 for num in lst])"
      ],
      [
        0.9158010482788086,
        "    return sum([num ** 2 for num in lst])"
      ],
      [
        0.9157797694206238,
        "    return sum([num ** 2 for num in lst])"
      ],
      [
        0.9147270321846008,
        "    return sum(map(lambda x: math.ceil(abs(x)) ** 2, lst))"
      ],
      [
        0.9145387411117554,
        "    for i in lst:\n        squared_list.append(i * i)"
      ]
    ],
    "HumanEval/134": [
      [
        0.9002631306648254,
        "    processed = ''.join((c for c in txt if c.isalpha()))\n    if len(processed) < 3:\n        return 'There are less than three alphabetic characters in the string.'\n    return processed[-3]"
      ],
      [
        0.8943980932235718,
        "    vowels = ['a', 'e', 'i', 'o', 'u']\n    last_char = word[-1].lower()\n    return last_char in vowels"
      ],
      [
        0.8928314447402954,
        "    words = sentence.split()\n    last_word = words[-1]\n    return last_word"
      ],
      [
        0.8911231756210327,
        "    last_char = text[-1].lower()\n    if last_char == 'z':\n        return 'a'\n    elif not last_char.isalpha():\n        return 'Please input a string ending with a alphabet.'\n    else:\n        return chr(ord(last_char) + 1)"
      ],
      [
        0.8901891708374023,
        "            if len(word) > 1 and (not word.isalpha()):\n                last_char = word[-1]\n                if not last_char.isalnum():\n                    punctuation = last_char\n                    word = word[:-1]"
      ],
      [
        0.8884354829788208,
        "    j = len(input_string)\n    for char in input_string:\n        j -= 1\n    if j == 0 and input_string[-1].isdigit():\n        print('Last character was a digit')\n    else:\n        print('Last character was not a digit')"
      ],
      [
        0.886505126953125,
        "    string = string.rstrip()\n    if len(string) > 0:\n        return string[-1]\n    else:\n        return 'Error: No non-space character found'"
      ],
      [
        0.8863300085067749,
        "    if len(string) > 0:\n        return string[-1]\n    else:\n        return 'Error: No non-space character found'"
      ],
      [
        0.8861998915672302,
        "    word = ''.join(filter(str.isalnum, word)).lower()\n    if len(word) <= 1:\n        return True\n    elif word[0] != word[-1]:\n        return False\n    else:\n        return is_palindrome(word[1:-1])"
      ],
      [
        0.8856022357940674,
        "    word = ''.join((e for e in word if e.isalnum())).lower()\n    if len(word) <= 1:\n        return True\n    elif word[0] == word[-1]:\n        return palindrome_check(word[1:-1])\n    else:\n        return False"
      ]
    ],
    "HumanEval/135": [
      [
        0.9048401713371277,
        "    for i in range(1, len(arr)):\n        if arr[i] < arr[i - 1]:\n            last_checked_index = i - 1\n            break"
      ],
      [
        0.9025793075561523,
        "    pairs = zip(arr, arr[1:])\n    ascending = all((a <= b for a, b in pairs))\n    if ascending:\n        return True\n    else:\n        for i, (a, b) in enumerate(zip(arr, arr[1:])):\n            if a > b:\n                return (False, i + 1)"
      ],
      [
        0.9020427465438843,
        "    for i in range(len(arr)):\n        if arr[i] > value:\n            return i\n    return -1"
      ],
      [
        0.9012589454650879,
        "    for i in range(len(arr) - 1):\n        if arr[i] < arr[i + 1]:\n            misplaced = arr[i + 1]\n            misplaced_idx = i + 1\n            break"
      ],
      [
        0.9005457758903503,
        "    for j in range(len(arr)):\n        new_arr = arr[j:] + arr[:j]\n        if is_sorted(new_arr):\n            return j"
      ],
      [
        0.8991960287094116,
        "    if len(arr) == 0:\n        return -1\n    max_val = arr[0]\n    max_index = 0\n    for i in range(1, len(arr)):\n        if arr[i] > max_val:\n            max_val = arr[i]\n            max_index = i\n        elif arr[i] == max_val:\n            if i < max_index:\n                max_index = i\n    return max_index"
      ],
      [
        0.8991130590438843,
        "    nums.sort(reverse=True)\n    for i, num in enumerate(nums):\n        if num <= i:\n            return i\n    return -1"
      ],
      [
        0.8990725874900818,
        "    if len(arr) == 0:\n        return 0\n    for j in range(len(arr)):\n        new_arr = arr[j:] + arr[:j]\n        if is_sorted(new_arr):\n            return j\n    return -1"
      ],
      [
        0.8988988399505615,
        "    n = len(arr1)\n    dp = [float('inf')] * n\n    for a in arr2:\n        new_dp = [float('inf')] * n\n        p = 0\n        for i in range(n):\n            if a < arr1[i]:\n                new_dp[i] = p\n            if i > 0 and dp[i - 1] < p:\n                p = dp[i - 1]\n            if arr1[i] > arr1[i + 1]:\n                return -1\n        dp = new_dp\n    return dp[-1]"
      ],
      [
        0.8982211351394653,
        "    m = -1\n    for i in range(len(a)):\n        if a[i] > i:\n            m = a[i]\n            break\n    return m"
      ]
    ],
    "HumanEval/136": [
      [
        0.9228713512420654,
        "    if not lst:\n        return (None, None, None, None)\n    all_negative = list(filter(lambda x: x < 0, lst))\n    all_non_negative = list(filter(lambda x: x >= 0, lst))\n    negative_even = [i for i in all_negative if i % 2 == 0]\n    negative_odd = [i for i in all_negative if i % 2 != 0]\n    non_negative_even = [i for i in all_non_negative if i % 2 == 0]\n    non_negative_odd = [i for i in all_non_negative if i % 2 != 0]\n    a = max(negative_even) if negative_even else None\n    b = min(non_negative_even) if non_negative_even else None\n    c = max(negative_odd) if negative_odd else None\n    d = min(non_negative_odd) if non_negative_odd else None\n    return (a, b, c, d)"
      ],
      [
        0.9228613376617432,
        "    if not lst:\n        return (None, None, None, None)\n    all_negative = list(filter(lambda x: x < 0, lst))\n    all_non_negative = list(filter(lambda x: x >= 0, lst))\n    negative_even = [i for i in all_negative if i % 2 == 0]\n    negative_odd = [i for i in all_negative if i % 2 != 0]\n    non_negative_even = [i for i in all_non_negative if i % 2 == 0]\n    non_negative_odd = [i for i in all_non_negative if i % 2 != 0]\n    a = max(negative_even) if negative_even else None\n    b = min(non_negative_even) if non_negative_even else None\n    c = max(negative_odd) if negative_odd else None\n    d = min(non_negative_odd) if non_negative_odd else None\n    return (a, b, c, d)"
      ],
      [
        0.9228252172470093,
        "    max_neg_even = max_neg_odd = min_non_neg_even = min_non_neg_odd = None\n    for num in lst:\n        if num % 2 == 0:\n            if num >= 0:\n                if min_non_neg_even is None or num < min_non_neg_even:\n                    min_non_neg_even = num\n            elif max_neg_even is None or num > max_neg_even:\n                max_neg_even = num\n        elif num >= 0:\n            if min_non_neg_odd is None or num < min_non_neg_odd:\n                min_non_neg_odd = num\n        elif max_neg_odd is None or num > max_neg_odd:\n            max_neg_odd = num\n    return (max_neg_even, min_non_neg_even, max_neg_odd, min_non_neg_odd)"
      ],
      [
        0.9203234910964966,
        "    highest_neg_even = highest_non_neg_even = smallest_neg_even = smallest_non_neg_even = smallest_neg_odd = highest_non_neg_odd = None\n    for num in lst:\n        if num % 2 == 0:\n            if num < 0:\n                if highest_neg_even is None or highest_neg_even < num:\n                    highest_neg_even = num\n                if smallest_neg_even is None or smallest_neg_even > num:\n                    smallest_neg_even = num\n            else:\n                if highest_non_neg_even is None or highest_non_neg_even < num:\n                    highest_non_neg_even = num\n                if smallest_non_neg_even is None or smallest_non_neg_even > num:\n                    smallest_non_neg_even = num\n        elif num < 0:\n            if smallest_neg_odd is None or smallest_neg_odd > num:\n                smallest_neg_odd = num\n        elif highest_non_neg_odd is None or highest_non_neg_odd < num:\n            highest_non_neg_odd = num\n    return (highest_neg_even, highest_non_neg_even, smallest_neg_even, smallest_non_neg_even, smallest_neg_odd, highest_non_neg_odd)"
      ],
      [
        0.919914960861206,
        "    highest_neg_even = smallest_neg_even = highest_non_neg_even = smallest_non_neg_even = smallest_neg_odd = highest_non_neg_odd = None\n    for num in lst:\n        if num % 2 == 0:\n            if num < 0:\n                if highest_neg_even is None or highest_neg_even < num:\n                    highest_neg_even = num\n                if smallest_neg_even is None or smallest_neg_even > num:\n                    smallest_neg_even = num\n            else:\n                if highest_non_neg_even is None or highest_non_neg_even < num:\n                    highest_non_neg_even = num\n                if smallest_non_neg_even is None or smallest_non_neg_even > num:\n                    smallest_non_neg_even = num\n        elif num < 0:\n            if smallest_neg_odd is None or smallest_neg_odd > num:\n                smallest_neg_odd = num\n        elif highest_non_neg_odd is None or highest_non_neg_odd < num:\n            highest_non_neg_odd = num\n    return (highest_neg_even, highest_non_neg_even, smallest_neg_even, smallest_non_neg_even, smallest_neg_odd, highest_non_neg_odd)"
      ],
      [
        0.9183312654495239,
        "    neg = sorted([n for n in lst if n < 0], reverse=True)[0] if any((n < 0 for n in lst)) else None\n    pos = sorted([n for n in lst if n > 0])[0] if any((n > 0 for n in lst)) else None\n    return [neg, pos]"
      ],
      [
        0.9176356792449951,
        "    negative_evens = [x for x in lst if x < 0 and x % 2 == 0]\n    non_negative_evens = [x for x in lst if x >= 0 and x % 2 == 0]\n    negative_odds = [x for x in lst if x < 0 and x % 2 != 0]\n    non_negative_odds = [x for x in lst if x >= 0 and x % 2 != 0]\n    a = max(negative_evens) if negative_evens else None\n    b = min(non_negative_evens) if non_negative_evens else None\n    c = max(negative_odds) if negative_odds else None\n    d = min(non_negative_odds) if non_negative_odds else None\n    return (a, b, c, d)"
      ],
      [
        0.9143264889717102,
        "    for num in lst:\n        if num % 2 == 0:\n            if num < 0:\n                if highest_neg_even is None or highest_neg_even < num:\n                    highest_neg_even = num\n                if smallest_neg_even is None or smallest_neg_even > num:\n                    smallest_neg_even = num\n            else:\n                if highest_non_neg_even is None or highest_non_neg_even < num:\n                    highest_non_neg_even = num\n                if smallest_non_neg_even is None or smallest_non_neg_even > num:\n                    smallest_non_neg_even = num\n        elif num < 0:\n            if smallest_neg_odd is None or smallest_neg_odd > num:\n                smallest_neg_odd = num\n        elif highest_non_neg_odd is None or highest_non_neg_odd < num:\n            highest_non_neg_odd = num"
      ],
      [
        0.9143187999725342,
        "    for num in lst:\n        if num % 2 == 0:\n            if num < 0:\n                if highest_neg_even is None or highest_neg_even < num:\n                    highest_neg_even = num\n                if smallest_neg_even is None or smallest_neg_even > num:\n                    smallest_neg_even = num\n            else:\n                if highest_non_neg_even is None or highest_non_neg_even < num:\n                    highest_non_neg_even = num\n                if smallest_non_neg_even is None or smallest_non_neg_even > num:\n                    smallest_non_neg_even = num\n        elif num < 0:\n            if smallest_neg_odd is None or smallest_neg_odd > num:\n                smallest_neg_odd = num\n        elif highest_non_neg_odd is None or highest_non_neg_odd < num:\n            highest_non_neg_odd = num"
      ],
      [
        0.9135918021202087,
        "    for num in lst:\n        if num % 2 == 0:\n            if num >= 0:\n                if min_non_neg_even is None or num < min_non_neg_even:\n                    min_non_neg_even = num\n            elif max_neg_even is None or num > max_neg_even:\n                max_neg_even = num\n        elif num >= 0:\n            if min_non_neg_odd is None or num < min_non_neg_odd:\n                min_non_neg_odd = num\n        elif max_neg_odd is None or num > max_neg_odd:\n            max_neg_odd = num"
      ]
    ],
    "HumanEval/137": [
      [
        0.907997190952301,
        "    aC = str(a).replace(',', '.') if isinstance(a, str) else str(a)\n    bC = str(b).replace(',', '.') if isinstance(b, str) else str(b)\n    aN = float(aC)\n    bN = float(bC)\n    if aN > bN:\n        return a\n    elif aN < bN:\n        return b\n    return None"
      ],
      [
        0.9073505401611328,
        "    try:\n        if isinstance(a, str):\n            a = float(a.replace(',', '.'))\n        if isinstance(b, str):\n            b = float(b.replace(',', '.'))\n        if a > b:\n            return isinstance(a, float) and str(a).replace('.', ',') or a\n        elif b > a:\n            return isinstance(b, float) and str(b).replace('.', ',') or b\n        return None\n    except ValueError:\n        return None"
      ],
      [
        0.9073505401611328,
        "    try:\n        if isinstance(a, str):\n            a = float(a.replace(',', '.'))\n        if isinstance(b, str):\n            b = float(b.replace(',', '.'))\n        if a > b:\n            return isinstance(a, float) and str(a).replace('.', ',') or a\n        elif b > a:\n            return isinstance(b, float) and str(b).replace('.', ',') or b\n        return None\n    except ValueError:\n        return None"
      ],
      [
        0.9062379002571106,
        "    if num1 == num2:\n        return 'Both numbers are equal.'\n    elif num1 < 0 and num2 < 0:\n        if abs(num1) < abs(num2):\n            return num1\n        else:\n            return num2\n    elif num1 < 0 or num2 < 0:\n        if abs(num1) > abs(num2):\n            return num1\n        else:\n            return num2\n    elif isinstance(num1, float) or isinstance(num2, float):\n        if isinstance(num1, int):\n            num1 = float(num1)\n        if isinstance(num2, int):\n            num2 = float(num2)\n        if num1 > num2:\n            return num1\n        else:\n            return num2\n    elif num1 > num2:\n        return num1\n    else:\n        return num2"
      ],
      [
        0.9062379002571106,
        "    if num1 == num2:\n        return 'Both numbers are equal.'\n    elif num1 < 0 and num2 < 0:\n        if abs(num1) < abs(num2):\n            return num1\n        else:\n            return num2\n    elif num1 < 0 or num2 < 0:\n        if abs(num1) > abs(num2):\n            return num1\n        else:\n            return num2\n    elif isinstance(num1, float) or isinstance(num2, float):\n        if isinstance(num1, int):\n            num1 = float(num1)\n        if isinstance(num2, int):\n            num2 = float(num2)\n        if num1 > num2:\n            return num1\n        else:\n            return num2\n    elif num1 > num2:\n        return num1\n    else:\n        return num2"
      ],
      [
        0.9053362607955933,
        "    if num1 == num2:\n        return 'The two numbers are equal.'\n    elif isinstance(num1, complex) or isinstance(num2, complex):\n        if isinstance(num1, complex) and isinstance(num2, complex):\n            return max(num1, num2, key=lambda x: abs(x))\n        elif isinstance(num1, complex):\n            return num1\n        else:\n            return num2\n    else:\n        num1 = abs(num1)\n        num2 = abs(num2)\n        if num1 == num2:\n            return 'The two numbers have the same absolute value.'\n        elif num1 > num2:\n            return num1\n        else:\n            return num2"
      ],
      [
        0.9053362607955933,
        "    if num1 == num2:\n        return 'The two numbers are equal.'\n    elif isinstance(num1, complex) or isinstance(num2, complex):\n        if isinstance(num1, complex) and isinstance(num2, complex):\n            return max(num1, num2, key=lambda x: abs(x))\n        elif isinstance(num1, complex):\n            return num1\n        else:\n            return num2\n    else:\n        num1 = abs(num1)\n        num2 = abs(num2)\n        if num1 == num2:\n            return 'The two numbers have the same absolute value.'\n        elif num1 > num2:\n            return num1\n        else:\n            return num2"
      ],
      [
        0.9019237160682678,
        "    if len(nums) == 0 and len(strings) == 0:\n        return None\n    elif len(nums) == 0:\n        return max(strings)\n    elif len(strings) == 0:\n        return max(nums)\n    else:\n        max_num = max(nums)\n        max_string = max(strings)\n        if max_num > max_string:\n            return max_num\n        else:\n            return max_string"
      ],
      [
        0.9019237160682678,
        "    if len(nums) == 0 and len(strings) == 0:\n        return None\n    elif len(nums) == 0:\n        return max(strings)\n    elif len(strings) == 0:\n        return max(nums)\n    else:\n        max_num = max(nums)\n        max_string = max(strings)\n        if max_num > max_string:\n            return max_num\n        else:\n            return max_string"
      ],
      [
        0.9017466306686401,
        "    if x > y:\n        return x\n    elif y > x:\n        return y\n    else:\n        return 'Both numbers are equal.'"
      ]
    ],
    "HumanEval/138": [
      [
        0.899093508720398,
        "    if n % 4 == 0 and n % 2 == 0 and (n > 0):\n        return True"
      ],
      [
        0.899093508720398,
        "    if n % 4 == 0 and n % 2 == 0 and (n > 0):\n        return True"
      ],
      [
        0.8961004614830017,
        "    if sum % 2 == 0:\n        return True\n    else:\n        return False"
      ],
      [
        0.896091103553772,
        "    if sum % 2 == 0:\n        return True\n    else:\n        return False"
      ],
      [
        0.8942937254905701,
        "    divisible_by_4 = n & 3 == 0\n    divisible_by_8 = n & 7 == 0\n    return divisible_by_4 != divisible_by_8"
      ],
      [
        0.8938644528388977,
        "    if n < 3:\n        return False\n    current_num = 2\n    while current_num * 2 < n:\n        sub_sum = n\n        for i in range(current_num):\n            sub_sum = sub_sum - i\n        if sub_sum % current_num == 0:\n            return True\n        current_num = current_num + 1\n    return False"
      ],
      [
        0.8936927914619446,
        "    primes = [2, 3, 5, 7, 11, 13]\n    count = 0\n    for prime in primes:\n        if n % prime == 0:\n            count += 1\n    return count == 4"
      ],
      [
        0.8936910629272461,
        "    primes = [2, 3, 5, 7, 11, 13]\n    count = 0\n    for prime in primes:\n        if n % prime == 0:\n            count += 1\n    return count == 4"
      ]
    ],
    "HumanEval/139": [],
    "HumanEval/140": [
      [
        0.9071969985961914,
        "    text_without_spaces = text.replace(' ', '')\n    lower_case_text = text_without_spaces.lower()\n    normalized_text = ''\n    for character in lower_case_text:\n        if character.isalnum():\n            normalized_text += character\n        else:\n            normalized_text += '_'\n    return normalized_text"
      ],
      [
        0.9062480330467224,
        "    text = re.sub(' {2,}', '-', text)\n    text = re.sub(' $', '!', text)\n    text = text.replace(' ', '_')\n    text = re.sub('-\\\\b', '_', text)\n    text = re.sub('-{2,}$', lambda m: '!' * len(m.group()), text)\n    return text"
      ],
      [
        0.9060805439949036,
        "    result = ''\n    for char in text:\n        if char.isalnum():\n            result += char.lower()\n        elif char.isspace():\n            continue\n        else:\n            result += '_'\n    return result"
      ],
      [
        0.9058205485343933,
        "    text = re.sub('[^\\\\w\\\\s]', '', text)\n    words = text.split()\n    return '_'.join(words)"
      ],
      [
        0.9037963151931763,
        "    pattern = '[^a-zA-Z0-9\\\\s]'\n    text = re.sub(pattern, '_', text)\n    return text"
      ],
      [
        0.9027502536773682,
        "    input_text = re.sub(' +', ' ', input_text)\n    words = input_text.split(' ')\n    words = [word.upper() for word in words]\n    input_text = '_'.join(words)\n    input_text = re.sub('_+', '-', input_text)\n    return input_text"
      ],
      [
        0.9018467664718628,
        "    text = re.sub('[^ws]', '', text)\n    words = text.split()\n    return '_'.join(words)"
      ],
      [
        0.9003390073776245,
        "    input_string = input_string.strip()\n    words = []\n    current_word = ''\n    for char in input_string:\n        if char.isalpha():\n            current_word += char\n        elif char == ' ':\n            if current_word:\n                words.append(current_word)\n                current_word = ''\n        elif char in string.punctuation:\n            continue\n    if current_word:\n        words.append(current_word)\n    return '_'.join(words)"
      ],
      [
        0.8998246192932129,
        "    return re.sub('(\\\\w+[\\\\.,;:!?\\\\)])( )', '\\\\1_', text)"
      ]
    ],
    "HumanEval/141": [
      [
        0.9410456418991089,
        "    valid_extensions = ['txt', 'exe', 'dll', 'png', 'jpg', 'jpeg']\n    period_count = file_name.count('.')\n    if period_count != 1:\n        return 'No'\n    split_name = file_name.split('.', 1)\n    if len(split_name[0]) > 5 or not split_name[0][0].isalpha():\n        return 'No'\n    if split_name[1] in valid_extensions:\n        return 'Yes'\n    return 'No'"
      ],
      [
        0.9339779615402222,
        "    reserved_chars = {'<', '>', ':', '\"', '/', '\\\\', '|', '?', '*'}\n    if any((c in file_name for c in reserved_chars)):\n        return 'No'\n    if not 5 <= len(file_name) <= 50:\n        return 'No'\n    parts = file_name.split('.')\n    if len(parts) != 2:\n        return 'No'\n    name, extension = parts\n    if not re.match('^[a-zA-Z][a-zA-Z0-9]*$', name) or not any((c.isupper() for c in name)) or (not any((c.islower() for c in name))) or (len(re.findall('\\\\d{4,}', name)) > 0):\n        return 'No'\n    if extension not in ['txt', 'exe', 'dll', 'pdf', 'jpeg']:\n        return 'No'\n    return 'Yes'"
      ],
      [
        0.9334911108016968,
        "    if not 5 <= len(file_name) <= 50:\n        return 'No'\n    name, dot, extension = file_name.rpartition('.')\n    if not dot or extension not in ['txt', 'exe', 'dll', 'pdf', 'jpeg']:\n        return 'No'\n    if not (re.search('[A-Za-z].*', name) and re.search('[A-Z]', name) and re.search('[a-z]', name) and (not re.search('\\\\d{4,}', name))):\n        return 'No'\n    if len(re.findall('[A-Za-z]', name)) != 2:\n        return 'No'\n    return 'Yes'"
      ],
      [
        0.9330171346664429,
        "    reserved_chars = ['<', '>', ':', '\"', '/', '\\\\', '|', '?', '*']\n    if any((c in file_name for c in reserved_chars)):\n        return 'No'\n    if not 5 <= len(file_name) <= 50:\n        return 'No'\n    parts = file_name.split('.')\n    if len(parts) != 2:\n        return 'No'\n    name, extension = parts\n    if not re.match('^[a-zA-Z][a-zA-Z0-9]*$', name) or not any((c.isupper() for c in name)) or (not any((c.islower() for c in name))) or (len(re.findall('\\\\d{4,}', name)) > 0):\n        return 'No'\n    if extension not in ['txt', 'exe', 'dll', 'pdf', 'jpeg']:\n        return 'No'\n    return 'Yes'"
      ],
      [
        0.9325264692306519,
        "    if not 5 <= len(file_name) <= 50:\n        return 'No'\n    name, dot, extension = file_name.rpartition('.')\n    if not dot or extension not in ['txt', 'exe', 'dll', 'pdf', 'jpeg']:\n        return 'No'\n    if not (re.match('[A-Za-z].*$', name) and re.search('[A-Z]', name) and re.search('[a-z]', name) and (not re.search('\\\\d{4,}', name))):\n        return 'No'\n    if len(re.findall('[A-Za-z]', name)) < 2:\n        return 'No'\n    return 'Yes'"
      ],
      [
        0.9294204115867615,
        "    if len(file_name) < 5 or len(file_name) > 50:\n        return 'No'\n    if not re.match('^(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\d)(?=.*[.])[^A-Z]*{A-Z}[^A-Z]*$', file_name):\n        return 'No'\n    if re.search('\\\\d{4,}', file_name):\n        return 'No'\n    split_name = file_name.split('.')\n    if len(split_name) != 2:\n        return 'No'\n    if not re.match('^[a-zA-Z]', split_name[0]) or len(split_name[0]) < 2:\n        return 'No'\n    valid_extensions = ['txt', 'exe', 'dll', 'pdf', 'jpeg']\n    if split_name[1] not in valid_extensions:\n        return 'No'\n    return 'Yes'"
      ],
      [
        0.9277865886688232,
        "    for name in list_of_file_names:\n        split_name = name.split('.')\n        if len(split_name) != 2 or not split_name[0] or (not split_name[1]):\n            return 'No'\n        if split_name[1].lower() not in ['txt', 'exe', 'dll', 'pdf', 'jpeg']:\n            return 'No'\n        if not re.search('[a-zA-Z].*(a-zA-Z)', split_name[0]) or len(re.findall('\\\\d', split_name[0])) > 3:\n            return 'No'"
      ],
      [
        0.9276504516601562,
        "    for name in list_of_file_names:\n        split_name = name.split('.')\n        if len(split_name) != 2 or not split_name[0] or (not split_name[1]):\n            return 'No'\n        if split_name[1].lower() not in ['txt', 'exe', 'dll', 'pdf', 'jpeg']:\n            return 'No'\n        if not re.search('[a-zA-Z].*[a-zA-Z]', split_name[0]) or len(re.findall('\\\\d', split_name[0])) > 3:\n            return 'No'"
      ],
      [
        0.926611065864563,
        "    extension_regex = re.compile('^.*\\\\.(exe|dll|pdf|jpeg|txt)$')\n    filename_regex = re.compile('^[a-zA-Z]\\\\w{2,}$')\n    alphanumeric_regex = re.compile('^(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\W)(?!.*[0-9]{4,})')\n    if not 5 <= len(file_name) <= 50:\n        return 'No'\n    if not extension_regex.match(file_name):\n        return 'No'\n    filename = file_name.split('.')[0]\n    if not filename_regex.match(filename):\n        return 'No'\n    len_before_alphanumeric_check = len(filename)\n    filename = re.sub('\\\\W+', '', filename)\n    if len_before_alphanumeric_check - len(filename) < 3 or not alphanumeric_regex.match(filename):\n        return 'No'\n    return 'Yes'"
      ],
      [
        0.9230705499649048,
        "    if len(file_name) < 5 or len(file_name) > 50:\n        return 'No'\n    list_of_file_names = file_name.split('/')\n    for name in list_of_file_names:\n        split_name = name.split('.')\n        if len(split_name) != 2 or not split_name[0] or (not split_name[1]):\n            return 'No'\n        if split_name[1].lower() not in ['txt', 'exe', 'dll', 'pdf', 'jpeg']:\n            return 'No'\n        if not re.search('[a-zA-Z].*(a-zA-Z)', split_name[0]) or len(re.findall('\\\\d', split_name[0])) > 3:\n            return 'No'\n    return 'Yes'"
      ]
    ],
    "HumanEval/142": [
      [
        0.921373188495636,
        "    sum = 0\n    for i in lst:\n        if isinstance(i, list):\n            sum += sum_squares_divisible_by_3(i)\n        elif i % 3 == 0:\n            sum += i ** 2\n    return sum"
      ],
      [
        0.9211909770965576,
        "    for i in lst:\n        if isinstance(i, list):\n            sum += sum_squares_divisible_by_3(i)\n        elif i % 3 == 0:\n            sum += i ** 2"
      ],
      [
        0.9195255637168884,
        "    sum_of_cubes = 0\n    for element in lst:\n        sum_of_cubes += sum_of_digit_cubes(element)\n    return sum_of_cubes"
      ],
      [
        0.916732132434845,
        "    new_lst = []\n    for item in lst:\n        if not isinstance(item, int):\n            continue\n        elif item < 0:\n            continue\n        else:\n            new_lst.append(item ** 3)\n    return new_lst"
      ],
      [
        0.9165831804275513,
        "    sum = 0\n    for num in lst:\n        if num > 0 and num % 2 != 0:\n            sum += num ** 3\n    return sum"
      ],
      [
        0.9160711169242859,
        "    result = 0\n    for num in lst:\n        if num >= 0 and num % 2 == 0 and (num % 5 != 0):\n            result += num ** 3\n    return result"
      ],
      [
        0.914875864982605,
        "    square_list = negative_even_squares(lst)\n    return sum(square_list)"
      ],
      [
        0.9137255549430847,
        "    result = []\n    for i in lst:\n        if type(i) == list:\n            result.append(cube_nested_list(i))\n        else:\n            result.append(i ** 3)\n    return result"
      ],
      [
        0.9132936000823975,
        "    return sum((i ** 3 for i in lst if i > 0))"
      ],
      [
        0.9129346013069153,
        "    filtered_list = [val for val in lst if isinstance(val, (int, float))]\n    processed_list = []\n    for num in filtered_list:\n        cube = num ** 3\n        if cube % 2 == 0:\n            processed_list.append(cube + 3)\n        else:\n            processed_list.append(cube - 2)\n    resulting_list = [val for val in processed_list if val > 10]\n    return resulting_list"
      ]
    ],
    "HumanEval/143": [
      [
        0.9492268562316895,
        "    words = sentence.split(' ')\n    result = []\n    for word in words:\n        if is_prime(len(word)):\n            result.append(word)\n    return ' '.join(result)"
      ],
      [
        0.9318417906761169,
        "    output = ''\n    words = sentence.split()\n    for word in words:\n        word_stripped = word.strip('.,?!')\n        if check_prime(len(word_stripped)):\n            if output != '':\n                output += ' '\n            output += word\n    return output"
      ],
      [
        0.9190689325332642,
        "    sentence = ''.join(sentence.split(' '))\n    added_chars = set()\n    result = ''\n    for length in range(len(sentence)):\n        if is_prime(length):\n            for i in range(len(sentence) - length + 1):\n                substring = sentence[i:i + length]\n                is_added_before = False\n                for char in substring:\n                    if char in added_chars:\n                        is_added_before = True\n                        break\n                if not is_added_before:\n                    result += substring\n                    for char in substring:\n                        added_chars.add(char)\n    return result"
      ],
      [
        0.919049859046936,
        "    sentence = ''.join(sentence.split(' '))\n    added_chars = set()\n    result = ''\n    for length in range(len(sentence)):\n        if is_prime(length):\n            for i in range(len(sentence) - length + 1):\n                substring = sentence[i:i + length]\n                is_added_before = False\n                for char in substring:\n                    if char in added_chars:\n                        is_added_before = True\n                        break\n                if not is_added_before:\n                    result += substring\n                    for char in substring:\n                        added_chars.add(char)\n    return result"
      ],
      [
        0.9125736355781555,
        "    for word in words:\n        word_stripped = word.strip('.,?!')\n        if check_prime(len(word_stripped)):\n            if output != '':\n                output += ' '\n            output += word"
      ],
      [
        0.9065773487091064,
        "    words = ''\n    unique_words = ''\n    word_start = 0\n    word_end = 0\n    sentence_length = len(sentence)\n    while word_end < sentence_length:\n        if sentence[word_end] == ' ':\n            current_word = sentence[word_start:word_end]\n            if current_word not in words:\n                words += current_word + ' '\n                unique_words += current_word + ' '\n            word_start = word_end + 1\n        word_end += 1\n    current_word = sentence[word_start:word_end]\n    if current_word not in words:\n        unique_words += current_word\n    return unique_words.strip()"
      ],
      [
        0.9056922197341919,
        "    sentence = list(sentence)\n    unique_words = set()\n    current_word = ''\n    updated_sentence = []\n    for char in sentence:\n        if char.isalnum():\n            current_word += char\n        else:\n            if current_word not in unique_words:\n                unique_words.add(current_word)\n                updated_sentence.append(current_word)\n            current_word = ''\n    if current_word not in unique_words:\n        updated_sentence.append(current_word)\n    updated_sentence = ' '.join(updated_sentence)\n    return updated_sentence"
      ],
      [
        0.9055370092391968,
        "    prime_chars = []\n    for char in string:\n        unicode_val = ord(char)\n        if is_prime(unicode_val):\n            prime_chars.append(char)\n    return prime_chars"
      ],
      [
        0.9052931666374207,
        "    for length in range(len(sentence)):\n        if is_prime(length):\n            for i in range(len(sentence) - length + 1):\n                substring = sentence[i:i + length]\n                is_added_before = False\n                for char in substring:\n                    if char in added_chars:\n                        is_added_before = True\n                        break\n                if not is_added_before:\n                    result += substring\n                    for char in substring:\n                        added_chars.add(char)"
      ],
      [
        0.9052736163139343,
        "    for length in range(len(sentence)):\n        if is_prime(length):\n            for i in range(len(sentence) - length + 1):\n                substring = sentence[i:i + length]\n                is_added_before = False\n                for char in substring:\n                    if char in added_chars:\n                        is_added_before = True\n                        break\n                if not is_added_before:\n                    result += substring\n                    for char in substring:\n                        added_chars.add(char)"
      ]
    ],
    "HumanEval/144": [
      [
        0.9128746390342712,
        "    import math\n    for z in [x, y]:\n        if '/' not in z:\n            return 'Input must be a fraction.'\n        parts = z.split('/')\n        if len(parts) != 2 or not parts[0].isdigit() or (not parts[1].isdigit()):\n            return 'Input must be a valid fraction.'\n    x_num, x_den = map(int, x.split('/'))\n    y_num, y_den = map(int, y.split('/'))\n    num = x_num * y_num\n    den = x_den * y_den\n    gcd = math.gcd(num, den)\n    while gcd != 1:\n        num //= gcd\n        den //= gcd\n        gcd = math.gcd(num, den)\n    return f'{num}/{den}'"
      ],
      [
        0.9044533967971802,
        "    num1 = ''.join((str(i) for i in arr1))\n    num2 = ''.join((str(i) for i in arr2))\n    if num1 == '0' or num2 == '0':\n        return 'Cannot divide by zero'\n    elif int(num1) % int(num2) == 0:\n        return True\n    else:\n        return False"
      ],
      [
        0.9025425314903259,
        "    if num1 == '0' or num2 == '0':\n        return 'Cannot divide by zero'\n    elif int(num1) % int(num2) == 0:\n        return True\n    else:\n        return False"
      ],
      [
        0.9005825519561768,
        "    for z in [x, y]:\n        if '/' not in z:\n            return 'Input must be a fraction.'\n        parts = z.split('/')\n        if len(parts) != 2 or not parts[0].isdigit() or (not parts[1].isdigit()):\n            return 'Input must be a valid fraction.'"
      ],
      [
        0.9001284837722778,
        "    if not (isinstance(x, int) and isinstance(y, int)):\n        return 'Error: Both inputs must be integers.'\n    if x in [-1, 1]:\n        return y == x\n    if x == 0 and y != 0:\n        return True\n    elif y == 0 and x != 0:\n        return True\n    if y == 1:\n        return False\n    while y != 1:\n        if y % x != 0:\n            return False\n        y = y // x\n    return True"
      ],
      [
        0.8982381820678711,
        "    elif num1 % num2 == 0 and num1 > 0 and (num2 > 0):\n        return True\n    else:\n        return False"
      ],
      [
        0.8961391448974609,
        "    if a <= 0 or b <= 0:\n        return 'Error: Both numbers should be positive.'\n    return a % b == 0"
      ],
      [
        0.8936072587966919,
        "    elif int(num1) % int(num2) == 0:\n        return True\n    else:\n        return False"
      ],
      [
        0.8933595418930054,
        "    num1, den1 = fraction1\n    num2, den2 = fraction2\n    common_den = den1 * den2 // math.gcd(den1, den2)\n    num_sum = num1 * common_den // den1 + num2 * common_den // den2\n    common_factor = math.gcd(num_sum, common_den)\n    return (num_sum // common_factor, common_den // common_factor)"
      ],
      [
        0.8928163051605225,
        "    if num2 == 0:\n        return False\n    quotient = num1 // num2\n    product = quotient * num2\n    return product == num1"
      ]
    ],
    "HumanEval/145": [
      [
        0.908768892288208,
        "    if not arr:\n        return []\n    result = []\n    sum_of_digits = []\n    for i in range(0, len(arr)):\n        digit_sum = 0\n        for j in str(arr[i]):\n            digit_sum += int(j)\n        result.append(arr[i])\n        sum_of_digits.append(digit_sum)\n    sorted_index = [i[0] for i in sorted(enumerate(sum_of_digits), key=lambda p: p[1])]\n    sorted_arr = []\n    for k in sorted_index:\n        sorted_arr.append(result[k])\n    return sorted_arr"
      ],
      [
        0.9054207801818848,
        "    positive_nums = sorted([x for x in a if x >= 0], reverse=True)\n    negative_nums = sorted([x for x in a if x < 0], reverse=True)\n    return positive_nums + negative_nums"
      ],
      [
        0.9053500890731812,
        "    return sorted(lst, key=lambda x: sum_of_digits(x), reverse=True)"
      ],
      [
        0.9052106142044067,
        "    return sorted(arr, key=lambda x: (sum((int(digit) for digit in str(x))), x))"
      ],
      [
        0.9051886796951294,
        "    return sorted(arr, key=lambda x: (sum((int(digit) for digit in str(x))), x))"
      ],
      [
        0.9041523337364197,
        "    n = len(nums)\n    for i in range(n - 1):\n        for j in range(0, n - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = (nums[j + 1], nums[j])\n    sorted_nums = []\n    start_index = 0\n    while start_index < len(nums):\n        end_index = start_index + 1\n        while end_index < len(nums) and nums[start_index] == nums[end_index]:\n            end_index += 1\n        sublist = nums[start_index:end_index]\n        sublist.sort(key=get_digit_sum)\n        sorted_nums.extend(sublist)\n        start_index = end_index\n    return sorted_nums"
      ],
      [
        0.9039953947067261,
        "    sorted_negatives = sorted((x for x in num_list if x < 0))\n    j = 0\n    for i in range(len(num_list)):\n        if num_list[i] < 0:\n            num_list[i] = sorted_negatives[j]\n            j += 1\n    return num_list"
      ],
      [
        0.9039610624313354,
        "    if len(arr) == 0:\n        return arr\n    max_val = max((abs(x) for x in arr))\n    max_digits = len(str(abs(max_val)))\n    buckets = [[] for _ in range(10)]\n    sign_buckets = {True: [], False: []}\n    for i in range(max_digits):\n        for num in arr:\n            digit_val = abs(num // 10 ** i % 10)\n            buckets[digit_val].append(num)\n        arr.clear()\n        for bucket in buckets:\n            arr += bucket\n            bucket.clear()\n    for num in arr:\n        if num < 0:\n            sign_buckets[False].append(num)\n        else:\n            sign_buckets[True].append(num)\n    arr[:] = sign_buckets[False][::-1] + sign_buckets[True]\n    return arr"
      ],
      [
        0.9026987552642822,
        "    arr.sort(key=lambda x: (get_digit_sum(x), x % 10))\n    return arr"
      ],
      [
        0.9017442464828491,
        "    negative_nums = [num for num in list if num < 0]\n    positive_nums = [num for num in list if num >= 0]\n    negative_nums.sort()\n    positive_nums.sort()\n    sorted_list = []\n    for num in reversed(negative_nums):\n        sorted_list.append(num)\n    for num in positive_nums:\n        sorted_list.append(num)\n    return sorted_list"
      ]
    ],
    "HumanEval/146": [
      [
        0.9267112016677856,
        "    odd_numbers = []\n    for num in array:\n        if num > 10 and num < 100 and (num % 2 != 0):\n            odd_numbers.append(num)\n    return len(odd_numbers)"
      ],
      [
        0.9217833280563354,
        "    count = 0\n    for num in arr:\n        if num > 10 and num < 100 and (num % 2 != 0):\n            count += 1\n    return count"
      ],
      [
        0.9186230897903442,
        "    filtered_nums = []\n    for num in nums:\n        if num > 10:\n            filtered_nums.append(num)\n    return filtered_nums"
      ],
      [
        0.9177412986755371,
        "    count = 0\n    for num in arr:\n        if num > 10 and num % 2 == 0:\n            count += 1\n    return count"
      ],
      [
        0.9150418043136597,
        "    filteredNumbers = []\n    for number in numbers:\n        if number >= 10:\n            filteredNumbers.append(number)\n    return filteredNumbers"
      ],
      [
        0.9131412506103516,
        "    for num in arr:\n        if num > 10 and num < 100 and (num % 2 != 0):\n            count += 1"
      ],
      [
        0.9121783971786499,
        "    count = 0\n    for num in arr:\n        if num > 10 and num % 3 == 0 and (num % 2 != 0):\n            count += 1\n    return count"
      ],
      [
        0.9099557995796204,
        "    for num in nums:\n        if num > 10:\n            filtered_nums.append(num)"
      ],
      [
        0.9098466038703918,
        "    for num in arr:\n        if num > 0 and num % 2 != 0 and (num > 10) and (num < 100):\n            odd_numbers.append(num)"
      ],
      [
        0.9080095291137695,
        "    for num in arr:\n        if num > 10 and num % 2 == 0:\n            count += 1"
      ]
    ],
    "HumanEval/147": [
      [
        0.9420053958892822,
        "    a = [0] * n\n    count = [0] * 3\n    pairs = [0] * 3\n    triples = 0\n    for i in range(n):\n        a[i] = i * i - i + 1\n        count[a[i] % 3] += 1\n    for j in range(3):\n        for k in range(j + 1, 3):\n            pairs[k] += count[j] * count[k]\n        triples += count[j] * (count[j] - 1) * (count[j] - 2) // 6\n    triples += pairs[0] + 2 * (pairs[1] + pairs[2])\n    return triples"
      ],
      [
        0.9334529042243958,
        "    a = [i * i - i + 1 + i % 3 for i in range(1, n + 1)]\n    triple_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                product = a[i] * a[j] % a[k]\n                if product % n == 0:\n                    triple_count += 1\n    return triple_count"
      ],
      [
        0.9120931029319763,
        "    count = 0\n    for i in range(1, n + 1):\n        if i % 3 == 0:\n            count += 1\n    return count"
      ],
      [
        0.9111279845237732,
        "    for i in range(n):\n        a[i] = i * i - i + 1\n        count[a[i] % 3] += 1"
      ],
      [
        0.9111063480377197,
        "    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        count = 0\n        for i in range(1, n + 1):\n            if i % 2 == 0:\n                count += 3 * 2 ** (i // 2 - 1)\n            else:\n                count += 2 * 2 ** (i // 2)\n        return count"
      ],
      [
        0.9111063480377197,
        "    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        count = 0\n        for i in range(1, n + 1):\n            if i % 2 == 0:\n                count += 3 * 2 ** (i // 2 - 1)\n            else:\n                count += 2 * 2 ** (i // 2)\n        return count"
      ],
      [
        0.9105859994888306,
        "    a, b = (0, 1)\n    result = []\n    while len(result) < n:\n        a, b = (b, a + b)\n        if a % 3 == 0:\n            result.append(a)\n    return result"
      ],
      [
        0.9105521440505981,
        "    a = [i * i - i + p + i % p for i in range(1, n + 1)]\n    counters = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                product_modulus = a[i] * a[j] % a[k]\n                if product_modulus % n == 0 or product_modulus % p == 0:\n                    counters += 1\n    return counters"
      ],
      [
        0.9104490280151367,
        "    l = set()\n    x = 3\n    while x < n:\n        l.add(x)\n        x += 3\n    return sum(l)"
      ],
      [
        0.9094349145889282,
        "    S = [0 for _ in range(n + 1)]\n    S[0] = S[1] = 1\n    for i in range(2, n + 1):\n        S[i] = 3 * (2 * i - 1) * S[i - 1] // (i - 1) - S[i - 2]\n    return S[n]"
      ]
    ],
    "HumanEval/148": [
      [
        0.9516469836235046,
        "    solar_system = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if is_valid(planet1) and is_valid(planet2):\n        planet1_index = solar_system.index(planet1.capitalize())\n        planet2_index = solar_system.index(planet2.capitalize())\n        if planet1_index < planet2_index:\n            return tuple((solar_system[i] for i in range(planet1_index + 1, planet2_index)))\n        if planet2_index < planet1_index:\n            return tuple((solar_system[i] for i in range(planet2_index + 1, planet1_index)))\n        return ()\n    else:\n        return ()"
      ],
      [
        0.9484492540359497,
        "    if not is_valid(planet1) or not is_valid(planet2):\n        return ()\n    planet_order = ('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune')\n    planet1_index = planet_order.index(planet1)\n    planet2_index = planet_order.index(planet2)\n    if planet1_index < planet2_index:\n        return planet_order[planet1_index + 1:planet2_index]\n    else:\n        return planet_order[planet2_index + 1:planet1_index]"
      ],
      [
        0.9441422820091248,
        "    if is_valid(planet1) and is_valid(planet2):\n        planet1_index = solar_system.index(planet1.capitalize())\n        planet2_index = solar_system.index(planet2.capitalize())\n        if planet1_index < planet2_index:\n            return tuple((solar_system[i] for i in range(planet1_index + 1, planet2_index)))\n        if planet2_index < planet1_index:\n            return tuple((solar_system[i] for i in range(planet2_index + 1, planet1_index)))\n        return ()\n    else:\n        return ()"
      ],
      [
        0.9333457350730896,
        "    if is_valid(planet1) and is_valid(planet2):\n        list_of_planets = sorted(planet_distances.items(), key=lambda x: x[1])\n        planet1_index = next((i for i, v in enumerate(list_of_planets) if v[0] == planet1))\n        planet2_index = next((i for i, v in enumerate(list_of_planets) if v[0] == planet2))\n        if planet1_index < planet2_index:\n            return tuple(list_of_planets[planet1_index + 1:planet2_index])\n        else:\n            return tuple(list_of_planets[planet2_index + 1:planet1_index])\n    else:\n        return ()"
      ],
      [
        0.9333457350730896,
        "    if is_valid(planet1) and is_valid(planet2):\n        list_of_planets = sorted(planet_distances.items(), key=lambda x: x[1])\n        planet1_index = next((i for i, v in enumerate(list_of_planets) if v[0] == planet1))\n        planet2_index = next((i for i, v in enumerate(list_of_planets) if v[0] == planet2))\n        if planet1_index < planet2_index:\n            return tuple(list_of_planets[planet1_index + 1:planet2_index])\n        else:\n            return tuple(list_of_planets[planet2_index + 1:planet1_index])\n    else:\n        return ()"
      ],
      [
        0.9333393573760986,
        "    if is_valid(planet1) and is_valid(planet2):\n        list_of_planets = sorted(planet_distances.items(), key=lambda x: x[1])\n        planet1_index = next((i for i, v in enumerate(list_of_planets) if v[0] == planet1))\n        planet2_index = next((i for i, v in enumerate(list_of_planets) if v[0] == planet2))\n        if planet1_index < planet2_index:\n            return tuple(list_of_planets[planet1_index + 1:planet2_index])\n        else:\n            return tuple(list_of_planets[planet2_index + 1:planet1_index])\n    else:\n        return ()"
      ],
      [
        0.9333393573760986,
        "    if is_valid(planet1) and is_valid(planet2):\n        list_of_planets = sorted(planet_distances.items(), key=lambda x: x[1])\n        planet1_index = next((i for i, v in enumerate(list_of_planets) if v[0] == planet1))\n        planet2_index = next((i for i, v in enumerate(list_of_planets) if v[0] == planet2))\n        if planet1_index < planet2_index:\n            return tuple(list_of_planets[planet1_index + 1:planet2_index])\n        else:\n            return tuple(list_of_planets[planet2_index + 1:planet1_index])\n    else:\n        return ()"
      ],
      [
        0.9312659502029419,
        "    if is_valid(planet1) and is_valid(planet2):\n        sorted_planets = sorted(PLANETS, key=PLANETS.get)\n        idx1, idx2 = (sorted_planets.index(planet1), sorted_planets.index(planet2))\n        if idx2 < idx1:\n            idx1, idx2 = (idx2, idx1)\n        planets_between = sorted_planets[idx1 + 1:idx2]\n        result = []\n        for planet in planets_between:\n            time_to_planet = PLANETS[planet] * 10 ** 6 / SPEED_OF_LIGHT\n            result.append((planet, time_to_planet))\n        return tuple(result)\n    else:\n        return ()"
      ],
      [
        0.9312659502029419,
        "    if is_valid(planet1) and is_valid(planet2):\n        sorted_planets = sorted(PLANETS, key=PLANETS.get)\n        idx1, idx2 = (sorted_planets.index(planet1), sorted_planets.index(planet2))\n        if idx2 < idx1:\n            idx1, idx2 = (idx2, idx1)\n        planets_between = sorted_planets[idx1 + 1:idx2]\n        result = []\n        for planet in planets_between:\n            time_to_planet = PLANETS[planet] * 10 ** 6 / SPEED_OF_LIGHT\n            result.append((planet, time_to_planet))\n        return tuple(result)\n    else:\n        return ()"
      ],
      [
        0.9286821484565735,
        "    planet_list = sorted(orbit_time.keys(), key=lambda p: orbit_time[p])\n    if is_valid(planet1) and is_valid(planet2):\n        start = min(planet_list.index(planet1), planet_list.index(planet2))\n        end = max(planet_list.index(planet1), planet_list.index(planet2))\n        return tuple([(planet, round(orbit_time[planet] * LIGHT_SPEED, 2)) for planet in planet_list[start + 1:end]])\n    else:\n        return ()"
      ]
    ],
    "HumanEval/149": [
      [
        0.9334352016448975,
        "    import re\n    filtered_list = [x for x in lst if len(x) % 2 == 0 and (not bool(re.search('\\\\d', x)))]\n    return sorted(filtered_list, key=lambda x: (len(x), x.lower()), reverse=reverse)"
      ],
      [
        0.929091215133667,
        "    filtered_list = []\n    for word in lst:\n        if len(word) > 4 and any((char.isupper() for char in word)) and (sum((ord(char) for char in word if char.isupper())) % 3 == 0):\n            filtered_list.append(word)\n    return sorted(filtered_list, key=len)"
      ],
      [
        0.9260175228118896,
        "    clean_lst = [s for s in lst if len(s) % 2 == 0 and (not any((c.isdigit() for c in s)))]\n    if not sort_function:\n        sort_function = lambda s: sum((ord(c) for c in s))\n    if secondary_sort_function:\n        clean_lst.sort(key=secondary_sort_function)\n    clean_lst.sort(key=sort_function, reverse=reverse)\n    filtered_lst = [s for s in clean_lst if min_sum <= sort_function(s) <= (max_sum if max_sum else float('inf'))]\n    return filtered_lst"
      ],
      [
        0.9242918491363525,
        "    vowels = ['a', 'e', 'i', 'o', 'u']\n    filtered_words = [word for word in word_list if len(word) % 2 == 0 and word.islower() and (word[0] not in vowels) and (word[-1] not in vowels)]\n    sorted_words = sorted(filtered_words, key=lambda x: (-len(x), x))\n    return sorted_words"
      ],
      [
        0.9236211776733398,
        "    filtered = [string for string in lst if len(string) % 2 == 0 and (not any((char.isdigit() for char in string)))]\n    sorted_list = sorted(filtered, key=lambda x: (len(x), x.casefold()), reverse=reverse)\n    return sorted_list"
      ],
      [
        0.9214116930961609,
        "    cleaned_lst = [i for i in lst if len(i) % 2 == 0 and (not any((c.isdigit() for c in i)))]\n    cleaned_lst = [''.join((c for c in s if c not in string.punctuation)) for s in cleaned_lst]\n    result = sorted(cleaned_lst, key=lambda x: (len(x), x.lower()), reverse=reverse)\n    return result"
      ],
      [
        0.9208716154098511,
        "    if len(word_list) <= 1:\n        return []\n    filtered_words = [word for word in word_list if len(word) % 2 == 0 and word.islower()]\n    filtered_words.sort(key=len, reverse=True)\n    return filtered_words"
      ],
      [
        0.9187750816345215,
        "    filtered_list = []\n    for string in lst:\n        if len(string) > 1:\n            filtered_list.append(string)\n    return filtered_list"
      ],
      [
        0.9187374711036682,
        "    vowels = ['a', 'e', 'i', 'o', 'u']\n    filtered_words = []\n    for word in word_list:\n        if len(word) % 2 == 0 and (not any((c.isupper() for c in word))) and (word[0].lower() not in vowels) and (word[-1].lower() not in vowels):\n            filtered_words.append(word)\n    filtered_words.sort(key=lambda x: (-len(x), x))\n    return filtered_words"
      ],
      [
        0.9183799624443054,
        "    vowels = 'AEIOUaeiou'\n    new_lst = []\n    for string in lst:\n        new_string = ''\n        for char in string:\n            if char not in vowels:\n                new_string += char\n        new_lst.append(new_string)\n    new_lst.sort(reverse=True, key=len)\n    return new_lst"
      ]
    ],
    "HumanEval/150": [
      [
        0.9269874095916748,
        "    return x if _is_prime(n) else y"
      ],
      [
        0.9162203669548035,
        "    if y_is_prime:\n        print(f'{y} is a prime number with factors: {y_factors}')\n    else:\n        print(f'{y} is not a prime number. Factors: {y_factors}')"
      ],
      [
        0.9131581783294678,
        "    if n > 1:\n        for i in range(2, n):\n            if n % i == 0:\n                is_prime = 'No'\n                break\n        else:\n            is_prime = 'Yes'\n    elif n == 1:\n        is_prime = 'No'\n    else:\n        return 'Error: Input should be greater than 0'"
      ],
      [
        0.9127991199493408,
        "    assert is_prime(4) == 'no'\n    assert is_prime(3) == 'yes'\n    assert is_prime(8) == 'no'"
      ],
      [
        0.912460446357727,
        "        if is_prime(x):\n            print(str(x) + ' is a prime number.')"
      ],
      [
        0.9124236702919006,
        "    elif n == 1:\n        is_prime = 'No'\n    else:\n        return 'Error: Input should be greater than 0'"
      ],
      [
        0.9115632176399231,
        "    elif n > 1:\n        for i in range(2, int(sqrt) + 1):\n            if n % i == 0:\n                return 'neither'\n        return 'prime'\n    else:\n        return 'neither'"
      ],
      [
        0.9115540981292725,
        "    elif n > 1:\n        for i in range(2, int(sqrt) + 1):\n            if n % i == 0:\n                return 'neither'\n        return 'prime'\n    else:\n        return 'neither'"
      ],
      [
        0.9112107753753662,
        "    result = ''\n    if val >= 50:\n        result = 'Passed, '\n    else:\n        result = 'Failed, '\n    if val > 1:\n        for i in range(2, val):\n            if val % i == 0:\n                return result + 'Not Prime'\n        return result + 'Prime Number'\n    else:\n        return result + 'Not Prime'"
      ],
      [
        0.9110668301582336,
        "    try:\n        n = int(n)\n    except ValueError:\n        return 'Error: Input is not an integer'\n    if n % 2 == 0:\n        odd_or_even = 'Even'\n    else:\n        odd_or_even = 'Odd'\n    if n > 1:\n        for i in range(2, n):\n            if n % i == 0:\n                is_prime = 'No'\n                break\n        else:\n            is_prime = 'Yes'\n    elif n == 1:\n        is_prime = 'No'\n    else:\n        return 'Error: Input should be greater than 0'\n    return '{0} is an {1} number and it is {2} a prime number'.format(n, odd_or_even, 'not' if is_prime == 'No' else '')"
      ]
    ],
    "HumanEval/151": [
      [
        0.9263818264007568,
        "    sum_of_squares = 0\n    for num in lst:\n        if num % 2 == 0:\n            square = num * num\n            sum_of_squares += square\n    return sum_of_squares"
      ],
      [
        0.9244989156723022,
        "    square_list = negative_even_squares(lst)\n    return sum(square_list)"
      ],
      [
        0.9234728813171387,
        "    squared_nums = []\n    total_sum = 0\n    for num in lst:\n        if isinstance(num, int) and num % 2 == 0 and (num < 10):\n            squared_num = num ** 2\n            squared_nums.append(str(squared_num))\n            total_sum += squared_num\n    squared_nums_str = ', '.join(squared_nums)\n    print('Squared numbers:', squared_nums_str)\n    print('Sum of squared numbers:', total_sum)"
      ],
      [
        0.9209561347961426,
        "    return sum((i ** 2 for i in lst if i < 0 and i % 2 == 0))"
      ],
      [
        0.9208032488822937,
        "    return sum((i ** 2 for i in lst if i % 2 == 0))"
      ],
      [
        0.9206917881965637,
        "    sum = 0\n    for num in lst:\n        if num > 0 and num % 2 != 0:\n            sum += num ** 3\n    return sum"
      ],
      [
        0.9201177358627319,
        "    return sum((i ** 2 for i in lst if isinstance(i, int) and i < 0 and (i % 2 == 0)))"
      ],
      [
        0.9197143316268921,
        "    return sum((x ** 2 for x in lst if x % 2 == 0))"
      ],
      [
        0.918651282787323,
        "    sum = 0\n    for num in lst:\n        if num % 2 != 0:\n            sum += num\n    return sum"
      ],
      [
        0.9174841046333313,
        "    result = 0\n    for num in lst:\n        if num >= 0 and num % 2 == 0 and (num % 5 != 0):\n            result += num ** 3\n    return result"
      ]
    ],
    "HumanEval/152": [
      [
        0.9207730293273926,
        "    differences = []\n    for score, guess in zip(scores, guesses):\n        difference = abs(score - guess)\n        if guess == score:\n            differences.append(difference)\n        else:\n            if guess == 0 and score != 0:\n                difference += 2\n            differences.append(difference)\n    return differences"
      ],
      [
        0.9100604057312012,
        "    for score, guess in zip(scores, guesses):\n        difference = abs(score - guess)\n        if guess == score:\n            differences.append(difference)\n        else:\n            if guess == 0 and score != 0:\n                difference += 2\n            differences.append(difference)"
      ],
      [
        0.9060152173042297,
        "        if guess == score:\n            differences.append(difference)\n        else:\n            if guess == 0 and score != 0:\n                difference += 2\n            differences.append(difference)"
      ],
      [
        0.9018695950508118,
        "    diff = []\n    for i in range(len(arr1)):\n        diff.append(abs(arr1[i] - arr2[i]))\n    return diff"
      ],
      [
        0.9006720781326294,
        "    if len(list1) != len(list2):\n        return 'Error: The lists do not have the same length.'\n    discrepancies = []\n    for i in range(len(list1)):\n        if type(list1[i]) is not int or type(list2[i]) is not int:\n            return 'Error: The lists contain non-numerical values.'\n        discrepancies.append(abs(list1[i] - list2[i]))\n    return discrepancies"
      ],
      [
        0.9006077647209167,
        "    differences = [abs(a - b) for a, b in zip(game, guess)]\n    n = len(differences)\n    mean = sum(differences) / n\n    variance = sum(((xi - mean) ** 2 for xi in differences)) / n\n    std_dev = math.sqrt(variance)\n    differences.append(variance)\n    differences.append(std_dev)\n    return differences"
      ],
      [
        0.897401750087738,
        "    result = []\n    for i in range(len(l1)):\n        result.append(abs(l1[i] - l2[i]))\n    return result"
      ],
      [
        0.8895915746688843,
        "    for i in range(len(list1)):\n        if type(list1[i]) is not int or type(list2[i]) is not int:\n            return 'Error: The lists contain non-numerical values.'\n        discrepancies.append(abs(list1[i] - list2[i]))"
      ],
      [
        0.8887806534767151,
        "    if len(arr_a) != len(arr_b):\n        return 'Arrays are of unequal lengths.'\n    else:\n        return [a - b for a, b in zip(arr_a, arr_b)]"
      ],
      [
        0.8887806534767151,
        "    if len(arr_a) != len(arr_b):\n        return 'Arrays are of unequal lengths.'\n    else:\n        return [a - b for a, b in zip(arr_a, arr_b)]"
      ]
    ],
    "HumanEval/153": [
      [
        0.881567120552063,
        "    longest_string = ''\n    longest_string_length = 0\n    longest_string_uppercase_count = 0\n    for string in strings:\n        uppercase_count = sum((1 for char in string if char.isupper()))\n        if uppercase_count > 0 and len(string) > longest_string_length:\n            uppercase_chars = [char for char in string if char.isupper()]\n            if uppercase_chars == sorted(uppercase_chars):\n                longest_string = string\n                longest_string_length = len(string)\n                longest_string_uppercase_count = uppercase_count\n    return (longest_string, longest_string_uppercase_count)"
      ],
      [
        0.8808785080909729,
        "    extension_count = {}\n    for file_name in file_names:\n        parts = file_name.split('.')\n        if len(parts) > 1:\n            extension = parts[-1].lower()\n        else:\n            extension = 'No Extension'\n        extension_count[extension] = extension_count.get(extension, 0) + 1\n    return extension_count"
      ],
      [
        0.8783256411552429,
        "    classes = {'A-E': [], 'F-J': [], 'K-O': [], 'P-T': [], 'U-Z': []}\n    for name in names:\n        name = name.upper()\n        if name[0] <= 'E':\n            classes['A-E'].append(name)\n        elif name[0] <= 'J':\n            classes['F-J'].append(name)\n        elif name[0] <= 'O':\n            classes['K-O'].append(name)\n        elif name[0] <= 'T':\n            classes['P-T'].append(name)\n        else:\n            classes['U-Z'].append(name)\n    for key in classes.keys():\n        classes[key] = sorted(classes[key], reverse=True)\n    return classes"
      ],
      [
        0.8763468861579895,
        "    strings = [capitalize_words(string) for string in strings]\n    strings.sort(key=lambda string: len(string.split()), reverse=True)\n    return strings"
      ],
      [
        0.875733494758606,
        "    file_extension_count = {}\n    for file_name in file_names:\n        if '.' in file_name:\n            extension = file_name.split('.')[-1]\n        else:\n            extension = 'No Extension'\n        file_extension_count[extension] = file_extension_count.get(extension, 0) + 1\n    return file_extension_count"
      ],
      [
        0.8756536245346069,
        "    if not names:\n        return ([], 'The list is empty.')\n    lengths = [len(name) for name in names]\n    max_length = max(lengths)\n    longest_names = [name for name in names if len(name) == max_length]\n    if len(longest_names) > 1:\n        result = 'The longest names are ' + ', '.join(longest_names) + ' with a length of ' + str(max_length) + '.'\n    else:\n        result = 'The longest name is ' + longest_names[0] + ' with a length of ' + str(max_length) + '.'\n    return (lengths, result)"
      ],
      [
        0.8749217987060547,
        "    frequency = {}\n    max_count = 0\n    most_frequent_name = ''\n    for name in names:\n        lowercase_name = name.lower()\n        if lowercase_name in frequency:\n            frequency[lowercase_name] += 1\n        else:\n            frequency[lowercase_name] = 1\n        if frequency[lowercase_name] > max_count:\n            max_count = frequency[lowercase_name]\n            most_frequent_name = lowercase_name\n    return most_frequent_name"
      ],
      [
        0.8733556270599365,
        "    longestString = ''\n    for string in strings:\n        if any((char.isupper() for char in string)):\n            if len(string) > len(longestString):\n                uppercase_letters = [char for char in string if char.isupper()]\n                if uppercase_letters == sorted(uppercase_letters):\n                    longestString = string\n    return longestString"
      ],
      [
        0.8732947111129761,
        "    for string in strings:\n        uppercase_count = sum((1 for char in string if char.isupper()))\n        if uppercase_count > 0 and len(string) > longest_string_length:\n            uppercase_chars = [char for char in string if char.isupper()]\n            if uppercase_chars == sorted(uppercase_chars):\n                longest_string = string\n                longest_string_length = len(string)\n                longest_string_uppercase_count = uppercase_count"
      ],
      [
        0.8729702234268188,
        "    extension_count = {}\n    for file_name in file_list:\n        parts = file_name.split('.')\n        if len(parts) > 1:\n            extension = parts[-1]\n        else:\n            extension = ''\n        extension_count[extension] = extension_count.get(extension, 0) + 1\n    return extension_count"
      ]
    ],
    "HumanEval/154": [
      [
        0.9380649924278259,
        "    import re\n    a = re.sub('[^a-zA-Z]', '', a.lower())\n    b = re.sub('[^a-zA-Z]', '', b.lower())\n    if len(b) > len(a):\n        return False\n    for i in range(len(b)):\n        rotation = b[i:] + b[:i]\n        if rotation in a:\n            return True\n    return False"
      ],
      [
        0.9366060495376587,
        "    import re\n    a = re.sub('[\\\\W_]+', '', a).lower()\n    b = re.sub('[\\\\W_]+', '', b).lower()\n    if set(a) != set(b):\n        return False\n    rotated_b = [b[i:] + b[:i] for i in range(len(b))]\n    for i in range(len(a) - len(b) + 1):\n        if a[i:i + len(b)] in rotated_b:\n            return True\n    return False"
      ],
      [
        0.9342398643493652,
        "    for i in range(len(b)):\n        rotation = b[i:] + b[:i]\n        if rotation in a:\n            return True"
      ],
      [
        0.9335331916809082,
        "    for i in range(len(a) - len(b) + 1):\n        if a[i:i + len(b)] in rotated_b:\n            return True"
      ],
      [
        0.9331351518630981,
        "    a_clean = ''.join((e for e in a if e.isalnum())).lower()\n    b_clean = ''.join((e for e in b if e.isalnum())).lower()\n    if len(b_clean) > len(a_clean):\n        return False\n    a_twice = a_clean + a_clean\n    for i in range(len(b_clean)):\n        rotated_b = b_clean[i:] + b_clean[:i]\n        if rotated_b in a_twice:\n            return True\n    return False"
      ],
      [
        0.9331250786781311,
        "    a_clean = ''.join((e for e in a if e.isalnum())).lower()\n    b_clean = ''.join((e for e in b if e.isalnum())).lower()\n    if len(b_clean) > len(a_clean):\n        return False\n    a_twice = a_clean + a_clean\n    for i in range(len(b_clean)):\n        rotated_b = b_clean[i:] + b_clean[:i]\n        if rotated_b in a_twice:\n            return True\n    return False"
      ],
      [
        0.9297969341278076,
        "    n = len(b)\n    if n == 0:\n        return True\n    if n > len(a):\n        return False\n    for i in range(n):\n        if b in a:\n            return True\n        b = b[n - 1:] + b[:n - 1]\n    return False"
      ],
      [
        0.9297138452529907,
        "    a = ''.join(re.findall('[a-zA-Z0-9]*', a)).lower()\n    b = ''.join(re.findall('[a-zA-Z0-9]*', b)).lower()\n    cycle = lambda s: [s[i:] + s[:i] for i in range(len(s))]\n    return any((c in a for c in cycle(b)))"
      ],
      [
        0.9292978048324585,
        "    a = ''.join((e for e in a if e.isalnum())).lower()\n    b = ''.join((e for e in b if e.isalnum())).lower()\n    b_rotations = [b[i:] + b[:i] for i in range(len(b))]\n    for b_rot in b_rotations:\n        if b_rot in a:\n            return True\n    return False"
      ],
      [
        0.9257858991622925,
        "    a = a.lower()\n    b = b.lower()\n    if len(b) > len(a):\n        return False\n    for _ in b:\n        if b in a:\n            return True\n        b = b[1:] + b[0]\n    return False"
      ]
    ],
    "HumanEval/155": [
      [
        0.9415621757507324,
        "    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):\n        if digit.isdigit():\n            if int(digit) % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)"
      ],
      [
        0.9414446949958801,
        "    even_count = 0\n    odd_count = 0\n    num = abs(num)\n    for digit in str(num):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)"
      ],
      [
        0.9399968981742859,
        "    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)"
      ],
      [
        0.9399964213371277,
        "    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)"
      ],
      [
        0.939993143081665,
        "    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)"
      ],
      [
        0.9399926066398621,
        "    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)"
      ],
      [
        0.9383900761604309,
        "    even_count = 0\n    odd_count = 0\n    num = abs(num)\n    for digit in str(num):\n        if digit != '0':\n            if int(digit) % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n        else:\n            even_count += 1\n    return (even_count, odd_count)"
      ],
      [
        0.9340523481369019,
        "    num = int(num)\n    num_str = str(num)\n    if num_str[0] == '-':\n        num_str = num_str[1:]\n    elif num_str[0] == '0' and len(num_str) > 1:\n        num_str = num_str.lstrip('0')\n    even_count = 0\n    odd_count = 0\n    for digit in num_str:\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)"
      ],
      [
        0.9307491183280945,
        "    even_count = 0\n    odd_count = 0\n    even_sum = 0\n    odd_sum = 0\n    for digit in str(abs(num)):\n        if int(digit) % 2 == 0:\n            even_count += 1\n            even_sum += int(digit)\n        else:\n            odd_count += 1\n            odd_sum += int(digit)\n    return ((even_count, odd_count), (even_sum, odd_sum))"
      ],
      [
        0.9207031726837158,
        "    even_count = 0\n    odd_count = 0\n    for num in arr:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)"
      ]
    ],
    "HumanEval/156": [
      [
        0.920760452747345,
        "    elif num >= 400:\n        return 'CD' + intToRoman(num - 400)\n    elif num >= 100:\n        return 'C' + intToRoman(num - 100)\n    elif num >= 90:\n        return 'XC' + intToRoman(num - 90)\n    elif num >= 50:\n        return 'L' + intToRoman(num - 50)\n    elif num >= 40:\n        return 'XL' + intToRoman(num - 40)\n    elif num >= 10:\n        return 'X' + intToRoman(num - 10)\n    elif num >= 9:\n        return 'IX' + intToRoman(num - 9)\n    elif num >= 5:\n        return 'V' + intToRoman(num - 5)\n    elif num >= 4:\n        return 'IV' + intToRoman(num - 4)\n    elif num >= 1:\n        return 'I' + intToRoman(num - 1)\n    else:\n        return ''"
      ],
      [
        0.9206554889678955,
        "    elif num >= 500:\n        return 'D' + intToRoman(num - 500)\n    elif num >= 400:\n        return 'CD' + intToRoman(num - 400)\n    elif num >= 100:\n        return 'C' + intToRoman(num - 100)\n    elif num >= 90:\n        return 'XC' + intToRoman(num - 90)\n    elif num >= 50:\n        return 'L' + intToRoman(num - 50)\n    elif num >= 40:\n        return 'XL' + intToRoman(num - 40)\n    elif num >= 10:\n        return 'X' + intToRoman(num - 10)\n    elif num >= 9:\n        return 'IX' + intToRoman(num - 9)\n    elif num >= 5:\n        return 'V' + intToRoman(num - 5)\n    elif num >= 4:\n        return 'IV' + intToRoman(num - 4)\n    elif num >= 1:\n        return 'I' + intToRoman(num - 1)\n    else:\n        return ''"
      ],
      [
        0.9205751419067383,
        "    elif num >= 900:\n        return 'CM' + intToRoman(num - 900)\n    elif num >= 500:\n        return 'D' + intToRoman(num - 500)\n    elif num >= 400:\n        return 'CD' + intToRoman(num - 400)\n    elif num >= 100:\n        return 'C' + intToRoman(num - 100)\n    elif num >= 90:\n        return 'XC' + intToRoman(num - 90)\n    elif num >= 50:\n        return 'L' + intToRoman(num - 50)\n    elif num >= 40:\n        return 'XL' + intToRoman(num - 40)\n    elif num >= 10:\n        return 'X' + intToRoman(num - 10)\n    elif num >= 9:\n        return 'IX' + intToRoman(num - 9)\n    elif num >= 5:\n        return 'V' + intToRoman(num - 5)\n    elif num >= 4:\n        return 'IV' + intToRoman(num - 4)\n    elif num >= 1:\n        return 'I' + intToRoman(num - 1)\n    else:\n        return ''"
      ],
      [
        0.9203097224235535,
        "    if num >= 1000:\n        return 'M' + intToRoman(num - 1000)\n    elif num >= 900:\n        return 'CM' + intToRoman(num - 900)\n    elif num >= 500:\n        return 'D' + intToRoman(num - 500)\n    elif num >= 400:\n        return 'CD' + intToRoman(num - 400)\n    elif num >= 100:\n        return 'C' + intToRoman(num - 100)\n    elif num >= 90:\n        return 'XC' + intToRoman(num - 90)\n    elif num >= 50:\n        return 'L' + intToRoman(num - 50)\n    elif num >= 40:\n        return 'XL' + intToRoman(num - 40)\n    elif num >= 10:\n        return 'X' + intToRoman(num - 10)\n    elif num >= 9:\n        return 'IX' + intToRoman(num - 9)\n    elif num >= 5:\n        return 'V' + intToRoman(num - 5)\n    elif num >= 4:\n        return 'IV' + intToRoman(num - 4)\n    elif num >= 1:\n        return 'I' + intToRoman(num - 1)\n    else:\n        return ''"
      ],
      [
        0.9203097224235535,
        "    if num >= 1000:\n        return 'M' + intToRoman(num - 1000)\n    elif num >= 900:\n        return 'CM' + intToRoman(num - 900)\n    elif num >= 500:\n        return 'D' + intToRoman(num - 500)\n    elif num >= 400:\n        return 'CD' + intToRoman(num - 400)\n    elif num >= 100:\n        return 'C' + intToRoman(num - 100)\n    elif num >= 90:\n        return 'XC' + intToRoman(num - 90)\n    elif num >= 50:\n        return 'L' + intToRoman(num - 50)\n    elif num >= 40:\n        return 'XL' + intToRoman(num - 40)\n    elif num >= 10:\n        return 'X' + intToRoman(num - 10)\n    elif num >= 9:\n        return 'IX' + intToRoman(num - 9)\n    elif num >= 5:\n        return 'V' + intToRoman(num - 5)\n    elif num >= 4:\n        return 'IV' + intToRoman(num - 4)\n    elif num >= 1:\n        return 'I' + intToRoman(num - 1)\n    else:\n        return ''"
      ],
      [
        0.9196265935897827,
        "    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    numerals = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']\n    mini_roman = ''\n    for i in range(len(values)):\n        count = num // values[i]\n        num %= values[i]\n        mini_roman += numerals[i] * count\n    return mini_roman"
      ],
      [
        0.9194827675819397,
        "    elif num >= 90:\n        return 'XC' + intToRoman(num - 90)\n    elif num >= 50:\n        return 'L' + intToRoman(num - 50)\n    elif num >= 40:\n        return 'XL' + intToRoman(num - 40)\n    elif num >= 10:\n        return 'X' + intToRoman(num - 10)\n    elif num >= 9:\n        return 'IX' + intToRoman(num - 9)\n    elif num >= 5:\n        return 'V' + intToRoman(num - 5)\n    elif num >= 4:\n        return 'IV' + intToRoman(num - 4)\n    elif num >= 1:\n        return 'I' + intToRoman(num - 1)\n    else:\n        return ''"
      ],
      [
        0.9193638563156128,
        "    elif num >= 100:\n        return 'C' + intToRoman(num - 100)\n    elif num >= 90:\n        return 'XC' + intToRoman(num - 90)\n    elif num >= 50:\n        return 'L' + intToRoman(num - 50)\n    elif num >= 40:\n        return 'XL' + intToRoman(num - 40)\n    elif num >= 10:\n        return 'X' + intToRoman(num - 10)\n    elif num >= 9:\n        return 'IX' + intToRoman(num - 9)\n    elif num >= 5:\n        return 'V' + intToRoman(num - 5)\n    elif num >= 4:\n        return 'IV' + intToRoman(num - 4)\n    elif num >= 1:\n        return 'I' + intToRoman(num - 1)\n    else:\n        return ''"
      ],
      [
        0.9176202416419983,
        "    elif num >= 9:\n        return 'IX' + intToRoman(num - 9)\n    elif num >= 5:\n        return 'V' + intToRoman(num - 5)\n    elif num >= 4:\n        return 'IV' + intToRoman(num - 4)\n    elif num >= 1:\n        return 'I' + intToRoman(num - 1)\n    else:\n        return ''"
      ],
      [
        0.9172192811965942,
        "    elif num >= 50:\n        return 'L' + intToRoman(num - 50)\n    elif num >= 40:\n        return 'XL' + intToRoman(num - 40)\n    elif num >= 10:\n        return 'X' + intToRoman(num - 10)\n    elif num >= 9:\n        return 'IX' + intToRoman(num - 9)\n    elif num >= 5:\n        return 'V' + intToRoman(num - 5)\n    elif num >= 4:\n        return 'IV' + intToRoman(num - 4)\n    elif num >= 1:\n        return 'I' + intToRoman(num - 1)\n    else:\n        return ''"
      ]
    ],
    "HumanEval/157": [
      [
        0.9295626282691956,
        "    sides = sorted([a, b, c])\n    if sides[0] ** 2 + sides[1] ** 2 == sides[2] ** 2:\n        print(\"It's a right-angled triangle.\")\n        area = 0.5 * sides[0] * sides[1]\n        print('Area of the triangle is', area, 'square units.')\n    else:\n        print(\"It's not a right-angled triangle.\")"
      ],
      [
        0.9227838516235352,
        "    if sides[0] ** 2 + sides[1] ** 2 == sides[2] ** 2:\n        print(\"It's a right-angled triangle.\")\n        area = 0.5 * sides[0] * sides[1]\n        print('Area of the triangle is', area, 'square units.')\n    else:\n        print(\"It's not a right-angled triangle.\")"
      ],
      [
        0.9137266278266907,
        "    if a <= 0 or b <= 0 or c <= 0 or (a + b <= c) or (a + c <= b) or (b + c <= a):\n        raise ValueError('Invalid side lengths. They do not form a valid triangle.')\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    perimeter = a + b + c\n    is_right_angled = a ** 2 + b ** 2 == c ** 2 or a ** 2 + c ** 2 == b ** 2 or b ** 2 + c ** 2 == a ** 2\n    return (area, perimeter, is_right_angled)"
      ],
      [
        0.9122225046157837,
        "    elif s1 ** 2 + s2 ** 2 == s3 ** 2 or s2 ** 2 + s3 ** 2 == s1 ** 2 or s3 ** 2 + s1 ** 2 == s2 ** 2:\n        return 'Right'\n    else:\n        return 'Scalene'"
      ],
      [
        0.9091096520423889,
        "    if a <= 0 or b <= 0 or c <= 0:\n        return False\n    if a + b <= c or a + c <= b or b + c <= a:\n        return False\n    sides = sorted([a, b, c])\n    return sides[2] ** 2 == sides[0] ** 2 + sides[1] ** 2"
      ],
      [
        0.9078623056411743,
        "    sides = sorted([a, b, c])\n    a, b, c = (sides[0], sides[1], sides[2])\n    if a ** 2 + b ** 2 == c ** 2:\n        return True\n    else:\n        return False"
      ],
      [
        0.9069454073905945,
        "    if side1 + side2 > side3 and side1 + side3 > side2 and (side2 + side3 > side1):\n        return True\n    else:\n        return False"
      ],
      [
        0.9069454073905945,
        "    if side1 + side2 > side3 and side1 + side3 > side2 and (side2 + side3 > side1):\n        return True\n    else:\n        return False"
      ],
      [
        0.906613826751709,
        "    if a + b > c and a + c > b and (b + c > a):\n        return True\n    else:\n        return False"
      ],
      [
        0.906613826751709,
        "    if a + b > c and a + c > b and (b + c > a):\n        return True\n    else:\n        return False"
      ]
    ],
    "HumanEval/158": [
      [
        0.9479293823242188,
        "    max_word = ''\n    max_unique_chars = 0\n    for word in words:\n        unique_chars = set(word.lower())\n        num_unique_chars = len(unique_chars)\n        if num_unique_chars == max_unique_chars:\n            if word.lower() < max_word.lower():\n                max_word = word\n        elif num_unique_chars > max_unique_chars:\n            max_word = word\n            max_unique_chars = num_unique_chars\n    return max_word"
      ],
      [
        0.9440244436264038,
        "    max_unique_count = 0\n    max_unique_word = ''\n    for word in words:\n        unique_chars = len(set(word.lower()))\n        if unique_chars > max_unique_count:\n            max_unique_count = unique_chars\n            max_unique_word = word\n        elif unique_chars == max_unique_count:\n            max_unique_word = min(max_unique_word, word)\n    return max_unique_word"
      ],
      [
        0.9437535405158997,
        "    max_unique_count = 0\n    max_word = None\n    for word in words:\n        unique_count = len(set(word.lower()))\n        if unique_count > max_unique_count:\n            max_unique_count = unique_count\n            max_word = word\n        elif unique_count == max_unique_count:\n            max_word = min(word, max_word)\n    return max_word"
      ],
      [
        0.9406874179840088,
        "    max_unique_count = 0\n    max_unique_word = None\n    for word in sorted(words):\n        temp_word = word\n        if not case_sensitive:\n            temp_word = word.lower()\n        unique_char_count = len(set(temp_word))\n        if unique_char_count > max_unique_count:\n            max_unique_count = unique_char_count\n            max_unique_word = word\n    return max_unique_word"
      ],
      [
        0.9372619390487671,
        "    for word in words:\n        unique_chars = set(word.lower())\n        num_unique_chars = len(unique_chars)\n        if num_unique_chars == max_unique_chars:\n            if word.lower() < max_word.lower():\n                max_word = word\n        elif num_unique_chars > max_unique_chars:\n            max_word = word\n            max_unique_chars = num_unique_chars"
      ],
      [
        0.9370896816253662,
        "    max_word = words[0]\n    max_unique = 0\n    for word in words:\n        temp_word = word\n        if not case_sensitive:\n            temp_word = word.lower()\n        unique_count = len(set(temp_word))\n        if unique_count > max_unique or (unique_count == max_unique and word < max_word):\n            max_unique = unique_count\n            max_word = word\n    return max_word"
      ],
      [
        0.93565434217453,
        "    for word in words:\n        unique_count = len(set(word.lower()))\n        if unique_count > max_unique_count:\n            max_unique_count = unique_count\n            max_word = word\n        elif unique_count == max_unique_count:\n            max_word = min(word, max_word)"
      ],
      [
        0.9337390661239624,
        "    for word in words:\n        unique_chars = len(set(word.lower()))\n        if unique_chars > max_unique_count:\n            max_unique_count = unique_chars\n            max_unique_word = word\n        elif unique_chars == max_unique_count:\n            max_unique_word = min(max_unique_word, word)"
      ],
      [
        0.9329670667648315,
        "    if len(words) == 0:\n        return ''\n    longest_word = ''\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            if len(set(word)) == len(word):\n                longest_word = word\n                max_length = len(word)\n    return longest_word"
      ],
      [
        0.9328545331954956,
        "    if not words:\n        raise ValueError(\"'words' list can't be empty\")\n    max_count, max_word = (0, '')\n    for word in words:\n        unique_chars = set(word.lower()) if not case_sensitive else set(word)\n        if len(unique_chars) > max_count or (len(unique_chars) == max_count and word < max_word):\n            max_count = len(unique_chars)\n            max_word = word\n    return max_word"
      ]
    ],
    "HumanEval/159": [
      [
        0.874882698059082,
        "    postEatWeight = totalWeight - amountEaten\n    combinedWeight = postEatWeight / 7\n    largerBoxPostEat = combinedWeight * 4\n    smallerBoxPostEat = combinedWeight * 3\n    largerBox = largerBoxPostEat + amountEaten\n    smallerBox = smallerBoxPostEat\n    return (round(largerBox), round(smallerBox))"
      ],
      [
        0.8630219101905823,
        "    left_over = n\n    distribution = {}\n    for veg in vegetables:\n        name, amount = veg.split(' ')\n        amount = int(amount)\n        left_over -= amount\n    if left_over < 0:\n        return 'Error: More vegetables present than total number in the crate.'\n    for leftover in servings:\n        serving = servings[leftover]\n        if type(serving) == str:\n            serving = int(serving.strip('%')) / 100\n        distribution[leftover] = serving * left_over\n    return distribution"
      ],
      [
        0.8627986311912537,
        "    total_weight = 50\n    weight_removed = 7\n    ratio = 7 / 3\n    boxB_weight = (total_weight - weight_removed) / (ratio + 1)\n    boxA_weight = total_weight - boxB_weight\n    return (boxA_weight, boxB_weight)"
      ],
      [
        0.8596807718276978,
        "    elif d1 > d2:\n        res = num[0] + d2\n    else:\n        res = num[1] + d1"
      ],
      [
        0.8566960692405701,
        "    fulfilled_requests = [0] * len(request_list)\n    remaining_requests = request_list.copy()\n    for i in range(len(request_list)):\n        if num_books >= request_list[i]:\n            fulfilled_requests[i] = 1\n            remaining_requests[i] = 0\n            num_books -= request_list[i]\n        else:\n            remaining_requests[i] -= num_books\n            num_books = 0\n    return (fulfilled_requests, remaining_requests)"
      ],
      [
        0.8566628098487854,
        "    left = 0\n    right = len(arr) - 1\n    while left < right:\n        s = arr[left] + arr[right]\n        if s == num:\n            return (arr[left], arr[right])\n        elif s > num:\n            right -= 1\n        else:\n            left += 1\n    return None"
      ],
      [
        0.8560139536857605,
        "    remaining_strawberries = max_strawberries + jonathon_strawberries - consumed_strawberries\n    return remaining_strawberries"
      ],
      [
        0.8556411266326904,
        "    bagels = (N - A) / 3\n    croissants = A + 2 * bagels\n    breadsticks = N - croissants - bagels\n    return (bagels, croissants, breadsticks)"
      ],
      [
        0.8553732633590698,
        "    if first_number < min_rest:\n        return first_number\n    else:\n        return min_rest"
      ],
      [
        0.8549933433532715,
        "    while left < right:\n        s = arr[left] + arr[right]\n        if s == num:\n            return (arr[left], arr[right])\n        elif s > num:\n            right -= 1\n        else:\n            left += 1"
      ]
    ],
    "HumanEval/160": [
      [
        0.9237489700317383,
        "    result = operand[0]\n    for i in range(len(operator)):\n        if operator[i] == '+':\n            result += operand[i + 1]\n        elif operator[i] == '-':\n            result -= operand[i + 1]\n        elif operator[i] == '*':\n            result *= operand[i + 1]\n        elif operator[i] == '//':\n            result //= operand[i + 1]\n        elif operator[i] == '**':\n            result **= operand[i + 1]\n        elif operator[i] == 'sin':\n            result -= math.sin(math.radians(operand[i + 1]))\n        elif operator[i] == 'cos':\n            result -= math.cos(math.radians(operand[i + 1]))\n        elif operator[i] == 'tan':\n            result -= math.tan(math.radians(operand[i + 1]))\n    return result"
      ],
      [
        0.9206002950668335,
        "    result = operand_set[0]\n    operator_mapping = {'+': lambda x, y: x + y, '-': lambda x, y: x - y, '*': lambda x, y: x * y, '/': lambda x, y: x / y, '**': lambda x, y: x ** y}\n    for i in range(1, len(operand_set)):\n        operator = operator_mapping[operator_set[i - 1]]\n        result = operator(result, operand_set[i])\n    return result"
      ],
      [
        0.9184269905090332,
        "    operation_mapping = {'+': operator.add, '-': operator.sub, '*': operator.mul, '//': operator.floordiv, '**': operator.pow}\n    if len(operator_set) != len(operand_set) - 1:\n        raise ValueError('Invalid lengths of operator_set and operand_set')\n    operation_sequence = [(operation_mapping[op], operand_set[i + 1]) for i, op in enumerate(operator_set)]\n    final_result = functools.reduce(lambda x, tup: tup[0](x, tup[1]), operation_sequence, operand_set[0])\n    return final_result"
      ],
      [
        0.9172701239585876,
        "    elif operator == '-':\n        return str(int(operand_values[0]) - sum([int(value) for value in operand_values[1:]]))\n    elif operator == '*':\n        return str(int(operand_values[0]) * int(operand_values[1]))\n    elif operator == '/':\n        return str(int(operand_values[0]) / int(operand_values[1]))"
      ],
      [
        0.9168603420257568,
        "    elif operator == '-':\n        return operand1 - operand2\n    elif operator == '*':\n        return operand1 * operand2\n    elif operator == '/':\n        return operand1 / operand2"
      ],
      [
        0.9166440963745117,
        "    ops = {'+': operator.add, '-': operator.sub, '*': operator.mul, '//': operator.floordiv, '**': operator.pow}\n    result = operand_set[0]\n    for index in range(len(operator_set)):\n        result = ops[operator_set[index]](result, operand_set[index + 1])\n    return result"
      ],
      [
        0.9161158204078674,
        "    for i in range(0, len(operators)):\n        op = operators[i]\n        num = operands[i + 1]\n        if op == '+':\n            result += num\n        elif op == '-':\n            result -= num\n        elif op == '*':\n            result *= num\n        elif op == '/':\n            result /= num\n        elif op == '//':\n            result //= num\n        elif op == '**':\n            result **= num\n        elif op == '%':\n            result %= num\n        else:\n            return 'Invalid operator found: {0}'.format(op)"
      ],
      [
        0.916101336479187,
        "    for i in range(0, len(operators)):\n        op = operators[i]\n        num = operands[i + 1]\n        if op == '+':\n            result += num\n        elif op == '-':\n            result -= num\n        elif op == '*':\n            result *= num\n        elif op == '/':\n            result /= num\n        elif op == '//':\n            result //= num\n        elif op == '**':\n            result **= num\n        elif op == '%':\n            result %= num\n        else:\n            return 'Invalid operator found: {0}'.format(op)"
      ],
      [
        0.9160983562469482,
        "    for i in range(0, len(operators)):\n        op = operators[i]\n        num = operands[i + 1]\n        if op == '+':\n            result += num\n        elif op == '-':\n            result -= num\n        elif op == '*':\n            result *= num\n        elif op == '/':\n            result /= num\n        elif op == '//':\n            result //= num\n        elif op == '**':\n            result **= num\n        elif op == '%':\n            result %= num\n        else:\n            return 'Invalid operator found: {0}'.format(op)"
      ],
      [
        0.9152498245239258,
        "        elif operator == '-':\n            return left_operand - right_operand\n        elif operator == '*':\n            return left_operand * right_operand\n        elif operator == '/':\n            return left_operand / right_operand"
      ]
    ],
    "HumanEval/161": [
      [
        0.9295119643211365,
        "    if not any((char.isalpha() for char in s)):\n        return s[::-1]\n    else:\n        result = ''\n        for char in s:\n            if char.isalpha():\n                if char.islower():\n                    result += char.upper()\n                else:\n                    result += char.lower()\n            else:\n                result += char\n        return result"
      ],
      [
        0.9295119643211365,
        "    alpha_list = [c for c in s if c.isalpha()]\n    alpha_list.reverse()\n    result = ''\n    j = 0\n    for i in range(len(s)):\n        if s[i].isalpha():\n            result += alpha_list[j].swapcase()\n            j += 1\n        else:\n            result += s[i]\n    return result"
      ],
      [
        0.9295119643211365,
        "    if not any((char.isalpha() for char in s)):\n        return s[::-1]\n    else:\n        result = ''\n        for char in s:\n            if char.isalpha():\n                if char.islower():\n                    result += char.upper()\n                else:\n                    result += char.lower()\n            else:\n                result += char\n        return result"
      ],
      [
        0.9260289669036865,
        "    s = ''.join([i for i in s if i.isalpha()])\n    return s[::-1]"
      ],
      [
        0.9219298362731934,
        "    non_alpha_chars = [(i, c) for i, c in enumerate(s) if not c.isalpha()]\n    reversed_str = [c for c in reversed(s) if c.isalpha()]\n    for i, c in non_alpha_chars:\n        reversed_str.insert(i, c)\n    result = ''.join(reversed_str)\n    return result"
      ],
      [
        0.9216717481613159,
        "    reversed_str = ''\n    for char in input_str:\n        if char.isalpha():\n            if char.islower():\n                reversed_str = char.upper() + reversed_str\n            else:\n                reversed_str = char.lower() + reversed_str\n        else:\n            reversed_str = char + reversed_str\n    return reversed_str"
      ],
      [
        0.920608401298523,
        "    reversed_str = ''\n    for char in input_str:\n        if char.isalpha():\n            if char.isupper():\n                reversed_str = char.lower() + reversed_str\n            else:\n                reversed_str = char.upper() + reversed_str\n        else:\n            reversed_str = char + reversed_str\n    return reversed_str"
      ],
      [
        0.9176254868507385,
        "    result = ''\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                result += char.upper()\n            else:\n                result += char.lower()\n        else:\n            result += char\n    return result"
      ],
      [
        0.9168269634246826,
        "    result = ''\n    for letter in s:\n        if letter.isupper():\n            result += letter.lower()\n        else:\n            result += letter.upper()\n    return result"
      ],
      [
        0.9162634015083313,
        "    swapped = ''\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                swapped += char.upper()\n            else:\n                swapped += char.lower()\n        else:\n            swapped += char\n    return swapped"
      ]
    ],
    "HumanEval/162": [
      [
        0.9239767789840698,
        "    if text == '':\n        return None\n    hash_object = hashlib.md5()\n    hash_object.update(text.encode('utf-8'))\n    return hash_object.hexdigest()"
      ],
      [
        0.8963247537612915,
        "    if not isinstance(text, str):\n        print('The input must be a string.')\n        return None\n    elif not text:\n        print('The string must not be empty.')\n        return None"
      ],
      [
        0.8935219049453735,
        "    hasher = hashlib.md5()\n    hasher.update(input_string.encode('utf-8'))\n    return hasher.hexdigest()"
      ],
      [
        0.8925294280052185,
        "    m = hashlib.md5()\n    m.update(input_string.encode('utf-8'))\n    return m.hexdigest()"
      ],
      [
        0.890769898891449,
        "    elif not text:\n        print('The string must not be empty.')\n        return None"
      ],
      [
        0.8897905349731445,
        "    result = hashlib.sha256(text.encode()).hexdigest()\n    return result"
      ],
      [
        0.8896827697753906,
        "    return hashlib.md5(input_string).hexdigest()"
      ],
      [
        0.8884862065315247,
        "    if text is None or text == '':\n        return 'The text is empty or null.'"
      ],
      [
        0.8884673118591309,
        "    if text is None or text == '':\n        return 'The text is empty or null.'"
      ],
      [
        0.8866147994995117,
        "    md5_hash = hashlib.md5()\n    md5_hash.update(input_string.encode('utf-8'))\n    return md5_hash.hexdigest()[:length]"
      ]
    ],
    "HumanEval/163": [
      [
        0.9128303527832031,
        "    even_numbers = []\n    for i in range(2, n + 1, 2):\n        even_numbers.append(i)\n    return even_numbers"
      ],
      [
        0.9123980402946472,
        "    even_numbers = []\n    for number in range(start, end + 1):\n        if number % 2 == 0:\n            even_numbers.append(number)\n    return even_numbers"
      ],
      [
        0.9086024165153503,
        "    even_numbers = []\n    i = 0\n    while len(even_numbers) < n:\n        if i % 2 == 0:\n            even_numbers.append(i)\n        i += 1\n    return even_numbers"
      ],
      [
        0.9073820114135742,
        "    even_numbers = []\n    for i in range(number + 1):\n        if i % 2 == 0:\n            even_numbers.append(i)\n    print('Even numbers between 0 and {}: {}'.format(number, even_numbers))"
      ],
      [
        0.9058805704116821,
        "    even_list = []\n    for num in range(0, 101):\n        if num % 2 == 0:\n            even_list.append(num)\n    return even_list"
      ],
      [
        0.90535569190979,
        "    return list((i for i in range(a, b + 1) if i % 2 == 0))"
      ],
      [
        0.9046947956085205,
        "    even_nums = []\n    for i in range(0, num + 1):\n        if i % 2 == 0:\n            even_nums.append(i)\n    print(even_nums)"
      ],
      [
        0.9042752385139465,
        "    evens = []\n    for i in range(1, num + 1):\n        if i % 2 == 0:\n            evens.append(i)\n    return evens"
      ],
      [
        0.9034497737884521,
        "    for number in range(start, end + 1):\n        if number % 2 == 0:\n            even_numbers.append(number)"
      ],
      [
        0.9021055102348328,
        "    even_numbers = []\n    for i in range(start, end + 1):\n        if even and lst[i] % 2 == 0:\n            even_numbers.append(lst[i])\n        elif not even and lst[i] % 2 != 0:\n            even_numbers.append(lst[i])\n    return even_numbers"
      ]
    ],
    "MBPP/0": [
      [
        0.8935022354125977,
        "    new_string = given_string.replace(character, '')\n    return new_string"
      ],
      [
        0.8933295011520386,
        "    result = ''\n    for c in string:\n        if c != char:\n            result += c\n    return result"
      ],
      [
        0.8930686116218567,
        "    char = char.lower()\n    modified_string = ''\n    i = 0\n    while i < len(string):\n        current_char = string[i].lower()\n        if current_char == char:\n            i += 1\n        else:\n            modified_string += string[i]\n            i += 1\n    return modified_string"
      ],
      [
        0.8915549516677856,
        "    string_list = list(string)\n    for i in string_list:\n        if i == char:\n            string_list.remove(i)\n    string = ''.join(string_list)\n    return string"
      ],
      [
        0.8910537958145142,
        "    res = ''\n    for i in range(len(string)):\n        if string[i] != char:\n            res += string[i]\n    return res"
      ],
      [
        0.8907175064086914,
        "    new_string = string.replace(char, '')\n    return new_string"
      ],
      [
        0.8887303471565247,
        "    modified_string = string.replace(char, '')\n    reversed_string = modified_string[::-1]\n    return reversed_string"
      ],
      [
        0.8870867490768433,
        "    modified_string = ''\n    for c in input_string:\n        if c != char:\n            modified_string += c\n    return modified_string"
      ],
      [
        0.886863112449646,
        "    newString = ''\n    for ch in s:\n        if ch != character:\n            newString += ch\n    return newString"
      ],
      [
        0.8857054710388184,
        "    new_string = ''\n    for char in input_string:\n        if char != character_to_remove:\n            new_string += char\n    return new_string"
      ]
    ],
    "MBPP/1": [
      [
        0.9157993793487549,
        "    sums = get_row_sums(arr)\n    sorted_arr = [x for _, x in sorted(zip(sums, arr), reverse=True)]\n    return sorted_arr"
      ],
      [
        0.9088024497032166,
        "    row_sums = [sum(row) for row in arr]\n    rows_with_sums = [(row_sum, row) for row_sum, row in zip(row_sums, arr) if not any((num < 0 for num in row))]\n    sorted_rows = sorted(rows_with_sums, key=lambda x: x[0])\n    sorted_arr = [row for _, row in sorted_rows]\n    return sorted_arr"
      ],
      [
        0.9086021184921265,
        "    for row in matrix:\n        row.sort()"
      ],
      [
        0.9085951447486877,
        "    for row in matrix:\n        row.sort()"
      ],
      [
        0.9055625200271606,
        "    for i in range(len(arr)):\n        for j in range(len(arr[i])):\n            for k in range(len(arr[i]) - j - 1):\n                if arr[i][k] > arr[i][k + 1]:\n                    arr[i][k], arr[i][k + 1] = (arr[i][k + 1], arr[i][k])\n    sum_rows = [(sum(arr[i]), i) for i in range(len(arr))]\n    sum_rows.sort()\n    arr = [arr[i] for _, i in sum_rows]\n    return arr"
      ],
      [
        0.9041557312011719,
        "    for row in matrix:\n        row.sort()\n    return matrix"
      ],
      [
        0.9040737152099609,
        "    array.sort(key=lambda x: sum(x))\n    return array"
      ],
      [
        0.9039385318756104,
        "    sort_rows = []\n    for i in range(len(matrix)):\n        sorted_cols = sorted(matrix[i])\n        sort_rows.append(sorted_cols)\n    return sort_rows"
      ],
      [
        0.9002572298049927,
        "    arr.sort(key=lambda x: sum(x))\n    return arr"
      ],
      [
        0.8990293741226196,
        "    for col in range(len(matrix[0])):\n        column = [matrix[row][col] for row in range(len(matrix))]\n        column.sort(reverse=True)\n        for row in range(len(matrix)):\n            matrix[row][col] = column[row]"
      ]
    ],
    "MBPP/2": [
      [
        0.9292007088661194,
        "    counter = Counter(words)\n    most_common = counter.most_common()\n    most_common_words = [x[0] for x in most_common]\n    return most_common_words"
      ]
    ],
    "MBPP/3": [
      [
        0.9031164646148682,
        "    assert a >= 0 and b >= 0 and (c >= 0) and (h >= 0), 'Ensure non-negative prism dimensions'\n    assert a + b > c and b + c > a and (c + a > b), 'Ensure valid triangle dimensions'\n    v = a * b * c / (4 * math.sqrt((a + b + c) * (-a + b + c) * (a - b + c) * (a + b - c))) * h\n    return v"
      ],
      [
        0.9006482362747192,
        "    assert a >= 0 and b >= 0 and (c >= 0) and (h >= 0), 'Ensure non-negative prism dimensions'\n    assert a + b > c and b + c > a and (c + a > b), 'Ensure valid triangle dimensions'\n    s = a * h + b * h + c * h + a * b * c / (2 * math.sqrt((a + b + c) * (-a + b + c) * (a - b + c) * (a + b - c)))\n    return s"
      ],
      [
        0.8990471363067627,
        "    volume = 1 / 3 * base_area * height\n    return volume"
      ],
      [
        0.8981781601905823,
        "    volume = side ** 2 * height / 3\n    return volume"
      ],
      [
        0.8971623182296753,
        "    elif base == 0 or height == 0:\n        return 0\n    else:\n        volume = 1 / 3 * base * height\n        return volume"
      ],
      [
        0.8971431255340576,
        "    if base < 0 or height < 0:\n        return 'Error: Base and height must be zero or positive numbers.'\n    elif base == 0 or height == 0:\n        return 0\n    else:\n        volume = 1 / 3 * base * height\n        return volume"
      ],
      [
        0.8971431255340576,
        "    if base < 0 or height < 0:\n        return 'Error: Base and height must be zero or positive numbers.'\n    elif base == 0 or height == 0:\n        return 0\n    else:\n        volume = 1 / 3 * base * height\n        return volume"
      ],
      [
        0.8959054350852966,
        "    base_area = base_side ** 2\n    lateral_area = base_side * slant_height\n    surface_area = base_area + lateral_area\n    height = math.sqrt(slant_height ** 2 - (base_side / 2) ** 2)\n    volume = base_area * height / 3\n    return (surface_area, volume)"
      ],
      [
        0.8927569389343262,
        "    base_area = base_length * base_width\n    volume = 1 / 3 * base_area * height\n    return volume"
      ],
      [
        0.8924069404602051,
        "    base_area = base_length1 * base_width1\n    top_area = top_length2 * top_width2\n    volume = 1 / 3 * height * (base_area + top_area + sqrt(base_area * top_area))\n    return volume"
      ]
    ],
    "MBPP/4": [
      [
        0.8883125185966492,
        "    pattern = re.compile(delimiter, re.IGNORECASE)\n    return pattern.split(my_string)"
      ],
      [
        0.886772871017456,
        "    output = []\n    for string in strings:\n        if string == '':\n            output.append(('', ''))\n        elif char in string:\n            index = string.index(char)\n            output.append((string[:index], string[index + 1:]))\n        else:\n            output.append(None)\n    return output"
      ],
      [
        0.8861655592918396,
        "    for item in lst:\n        if item[0].islower():\n            lower_case.append(item)\n        else:\n            upper_case.append(item)"
      ],
      [
        0.8859021067619324,
        "    words = []\n    word = ''\n    for char in string:\n        if char != ' ':\n            word += char\n        else:\n            if word.isupper():\n                words.append(word)\n            word = ''\n    if word.isupper():\n        words.append(word)\n    return words"
      ],
      [
        0.8856807947158813,
        "    result = []\n    for string in lst:\n        if char in string:\n            index = string.index(char)\n            substring1 = string[:index]\n            substring2 = string[index + 1:]\n            result.append((substring1, substring2))\n        else:\n            result.append(('None', 'None'))\n    return result"
      ],
      [
        0.8837289810180664,
        "    result = []\n    current_word = ''\n    for char in string:\n        if char == delimiter:\n            result.append(current_word)\n            current_word = ''\n        else:\n            current_word += char\n    result.append(current_word)\n    return result"
      ],
      [
        0.8823074698448181,
        "    lower_case = []\n    upper_case = []\n    for item in lst:\n        if item[0].islower():\n            lower_case.append(item)\n        else:\n            upper_case.append(item)\n    return lower_case + upper_case"
      ]
    ],
    "MBPP/5": [
      [
        0.8898218870162964,
        "    elif cases['Underscore']:\n        return 'Underscore'"
      ],
      [
        0.8838483095169067,
        "    return re.findall('[A-Z][^A-Z]*', s)"
      ],
      [
        0.8827824592590332,
        "    pattern = '\\\\b(?<![bcdfghjklmnpqrstvwxyz])[a-z]*a[a-z]+\\\\b'\n    words = re.findall(pattern, string, re.I)\n    return words"
      ],
      [
        0.8818235993385315,
        "    pattern = re.compile('[a-z\\\\W].*\\\\d$')\n    matches = pattern.findall(s)\n    return matches"
      ],
      [
        0.8817222714424133,
        "    pattern = '\\\\b\\\\w*[bcdfghjklmnpqrstvwxyz]{3}\\\\w*\\\\b'\n    return re.findall(pattern, text, re.I)"
      ],
      [
        0.8800414800643921,
        "    string = string.strip()\n    converted_string = ''\n    prev_char = ''\n    for char in string:\n        if char.isalpha():\n            if prev_char == ' ':\n                converted_string += '_'\n            converted_string += char\n        prev_char = char\n    return converted_string"
      ],
      [
        0.8799607753753662,
        "    matches = re.finditer('.+?(?:(?<=[a-z])(?=[A-Z])|(?<=[A-Z])(?=[A-Z][a-z])|$)', identifier)\n    return [m.group(0) for m in matches]"
      ],
      [
        0.8796290755271912,
        "    pattern = re.compile('a.*Z')\n    return pattern.findall(text)"
      ],
      [
        0.8788444399833679,
        "    pattern = '\\\\b[aA]\\\\w*\\\\b'\n    matches = re.findall(pattern, text)\n    return matches"
      ],
      [
        0.8780224323272705,
        "    pattern = '[a-zA-Z]*a[a-zA-Z]*'\n    result = re.findall(pattern, text)\n    return result"
      ]
    ],
    "MBPP/6": [
      [
        0.8896439671516418,
        "    perimeter = sum(sides)\n    return perimeter"
      ],
      [
        0.8876674771308899,
        "    perimeter = 2 * math.pi * radius\n    return perimeter"
      ],
      [
        0.887175977230072,
        "    area = n * n\n    perimeter = 4 * n\n    return (area, perimeter)"
      ],
      [
        0.8830826282501221,
        "    perimeter = side1 + side2 + side3\n    return perimeter"
      ],
      [
        0.8811260461807251,
        "    import math\n    return math.sqrt(4)"
      ]
    ],
    "MBPP/7": [
      [
        0.9303379654884338,
        "    str1_list = list(str1)\n    str2_list = list(str2)\n    for char in str1_list:\n        if char in str2_list:\n            str1_list.remove(char)\n    output_str = ''.join(str1_list)\n    return output_str"
      ],
      [
        0.9269521236419678,
        "    return_char = [ch for ch in s1 if ch not in s2]\n    return ''.join(return_char)"
      ],
      [
        0.9210196733474731,
        "    for char in second_string:\n        first_string = first_string.replace(char, '')"
      ],
      [
        0.9210057258605957,
        "    for char in second_string:\n        first_string = first_string.replace(char, '')"
      ],
      [
        0.9199011921882629,
        "    new_string = ''\n    for char in string2:\n        if char not in string1:\n            new_string += char\n    return new_string"
      ],
      [
        0.9158872365951538,
        "    substring = ''\n    for char in string_1:\n        if char not in string_2:\n            substring += char\n    return substring"
      ],
      [
        0.9137983322143555,
        "    return [char for char in stringA if char not in set(stringB)]"
      ],
      [
        0.9130845665931702,
        "    t_set = set(t)\n    result = [char for char in s if char not in t_set]\n    return ''.join(result)"
      ],
      [
        0.9123449325561523,
        "    new_string = ''\n    for char in string:\n        if char != remove_char:\n            new_string += char\n    return new_string"
      ],
      [
        0.9104128479957581,
        "    new_string = ''\n    for char in input_string:\n        if char != character_to_remove:\n            new_string += char\n    return new_string"
      ]
    ],
    "MBPP/8": [
      [
        0.9274294376373291,
        "    duplicates = set()\n    for num in arr:\n        if num in duplicates:\n            return True\n        duplicates.add(num)\n    return False"
      ],
      [
        0.9272282719612122,
        "    dup_set = set()\n    for i in arr:\n        if i in dup_set:\n            return True\n        else:\n            dup_set.add(i)\n    return False"
      ],
      [
        0.9252391457557678,
        "    mySet = set()\n    for item in arr:\n        if item in mySet:\n            return True\n        else:\n            mySet.add(item)\n    return False"
      ],
      [
        0.9236360192298889,
        "    seen_elements = {}\n    for element in arr:\n        if element in seen_elements:\n            return True\n        else:\n            seen_elements[element] = 1\n    return False"
      ],
      [
        0.9233723282814026,
        "    for element in array1:\n        if type(element) == int:\n            if element in Hash1:\n                return True\n            Hash1[element] = 1"
      ],
      [
        0.9233717322349548,
        "    seen = set()\n    for num in array:\n        if num in seen:\n            return True\n        else:\n            seen.add(num)\n    return False"
      ],
      [
        0.9224867820739746,
        "    for item in arr:\n        if item in mySet:\n            return True\n        else:\n            mySet.add(item)"
      ],
      [
        0.9220190048217773,
        "    seen = set()\n    for element in array:\n        if element in seen:\n            return True\n        seen.add(element)\n    return False"
      ],
      [
        0.9219200611114502,
        "    seen = {}\n    for num in arr:\n        if num in seen:\n            return True\n        else:\n            seen[num] = True\n    return False"
      ],
      [
        0.9218522310256958,
        "    count = {}\n    for elem in arr:\n        if elem in count:\n            return True\n        else:\n            count[elem] = 0\n    return False"
      ]
    ],
    "MBPP/9": [
      [
        0.8898142576217651,
        "        if num >= 2 and num <= 6 and (num % 3 == 0):\n            return True\n        else:\n            return False"
      ],
      [
        0.889068603515625,
        "    return number % 7 == 0"
      ],
      [
        0.8880895376205444,
        "    try:\n        num = int(input_num)\n        if num >= 2 and num <= 6 and (num % 3 == 0):\n            return True\n        else:\n            return False\n    except ValueError:\n        return False"
      ],
      [
        0.8880895376205444,
        "    try:\n        num = int(input_num)\n        if num >= 2 and num <= 6 and (num % 3 == 0):\n            return True\n        else:\n            return False\n    except ValueError:\n        return False"
      ],
      [
        0.887243390083313,
        "    return num % 4 == 0 or num % 6 == 0"
      ],
      [
        0.8867993354797363,
        "    if number <= 3:\n        return True"
      ],
      [
        0.8864123821258545,
        "    if number % 7 == 0:\n        return True\n    return False"
      ],
      [
        0.8860408067703247,
        "    if number % 10 == 0:\n        return True\n    return False"
      ],
      [
        0.8859274387359619,
        "    return '3' in str(number)"
      ],
      [
        0.8854297399520874,
        "    if number == 2 or number == 3:\n        return True"
      ]
    ],
    "MBPP/10": [
      [
        0.9231947660446167,
        "    multiples = []\n    for i in range(start, end + 1):\n        if i % m == 0:\n            multiples.append(i)\n    return multiples"
      ],
      [
        0.9197291135787964,
        "    i = 0\n    multiples_list = []\n    while i < n:\n        i += multiple\n        if i <= n:\n            multiples_list.append(i)\n    return multiples_list"
      ],
      [
        0.9187780618667603,
        "    multiples = []\n    for i in range(start, end + 1):\n        if i % n == 0:\n            multiples.append(i)\n    return multiples"
      ],
      [
        0.9183543920516968,
        "    numbers = list(range(start, end + 1))\n    multiples = [i for i in numbers if i % n == 0]\n    return multiples"
      ],
      [
        0.916021466255188,
        "    for i in range(start, end + 1):\n        if i % m == 0:\n            multiples.append(i)"
      ],
      [
        0.9148183465003967,
        "        if i % m == 0:\n            multiples.append(i)"
      ],
      [
        0.9148125052452087,
        "    while i < n:\n        i += multiple\n        if i <= n:\n            multiples_list.append(i)"
      ],
      [
        0.9144061803817749,
        "    for i in range(start, end + 1):\n        if i % n == 0:\n            multiples.append(i)"
      ],
      [
        0.9139091968536377,
        "    for i in range(start, upper_limit + 1):\n        if i % n == 0:\n            multiples.append(i)"
      ],
      [
        0.9136213064193726,
        "    multiples = []\n    start = max(n, lower_limit)\n    for i in range(start, upper_limit + 1):\n        if i % n == 0:\n            multiples.append(i)\n    return multiples"
      ]
    ],
    "MBPP/11": [
      [
        0.9256086349487305,
        "    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return -1"
      ],
      [
        0.9256068468093872,
        "    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return -1"
      ],
      [
        0.9240059852600098,
        "    seen = set()\n    for i in A:\n        if i in seen:\n            return i\n        seen.add(i)\n    return -1"
      ],
      [
        0.923652708530426,
        "    seen = dict()\n    for i, n in enumerate(arr):\n        if n in seen:\n            return i\n        else:\n            seen[n] = True\n    return -1"
      ],
      [
        0.9226357936859131,
        "    seen = set()\n    for i in range(len(arr)):\n        elem = arr[i]\n        if elem in seen:\n            return i\n        else:\n            seen.add(elem)\n    return None"
      ],
      [
        0.9209039211273193,
        "    number_frequencies = {}\n    number_indices = {}\n    duplicate_index = {}\n    for i in range(len(a)):\n        if a[i] not in number_frequencies:\n            number_frequencies[a[i]] = 1\n            number_indices[a[i]] = i\n        elif a[i] in number_frequencies:\n            if number_frequencies[a[i]] < 2:\n                number_frequencies[a[i]] += 1\n                number_indices[a[i]] = i\n    for number in number_frequencies:\n        if number_frequencies[number] == 2:\n            duplicate_index[number] = number_indices[number]\n    if not duplicate_index:\n        return -1\n    else:\n        minimal_index_key = min(duplicate_index, key=duplicate_index.get)\n        return duplicate_index[minimal_index_key]"
      ],
      [
        0.9207968711853027,
        "    seen = {}\n    for i in range(len(arr)):\n        if arr[i] in seen:\n            return i\n        else:\n            seen[arr[i]] = True\n    return -1"
      ],
      [
        0.9203717708587646,
        "    seen = set()\n    for element in arr:\n        if element in seen:\n            return element\n        else:\n            seen.add(element)\n    return None"
      ],
      [
        0.9196879267692566,
        "    for i, n in enumerate(arr):\n        if n in seen:\n            return i\n        else:\n            seen[n] = True"
      ],
      [
        0.9194589853286743,
        "    elements = set()\n    for a in arr:\n        if a in elements:\n            return a\n        else:\n            elements.add(a)\n    return None"
      ]
    ],
    "MBPP/12": [
      [
        0.9312211871147156,
        "    for lst in list_of_lists:\n        if max_sum is None or sum(lst) > max_sum:\n            max_sum = sum(lst)\n            max_list = lst"
      ],
      [
        0.9267818927764893,
        "    max_sum = None\n    max_list = None\n    for lst in list_of_lists:\n        if max_sum is None or sum(lst) > max_sum:\n            max_sum = sum(lst)\n            max_list = lst\n    return max_list"
      ],
      [
        0.9173154234886169,
        "    sum_list = [sum(row) for row in arr]\n    max_element = max(sum_list)\n    return max_element"
      ],
      [
        0.9035146236419678,
        "    max_sum = float('-inf')\n    max_row = None\n    row_sums = []\n    for i in range(len(arr)):\n        row_sum = sum(arr[i])\n        row_sums.append(row_sum)\n        if row_sum > max_sum:\n            max_sum = row_sum\n            max_row = arr[i]\n    return (max_row, row_sums)"
      ],
      [
        0.9034614562988281,
        "    for lis in lists:\n        if not lis:\n            result.append(0)\n        else:\n            max_num = -10 ** 18\n            for num in lis:\n                max_num = max(max_num, num)\n            result.append(max_num)"
      ],
      [
        0.9021005034446716,
        "    sums = [sum(sublist) for sublist in arr]\n    highest_sum = max(sums)\n    highest_sum_arrays = [[arr[i], highest_sum] for i in range(len(arr)) if sums[i] == highest_sum]\n    flattened_list = [item for sublist in highest_sum_arrays for item in sublist]\n    return flattened_list"
      ],
      [
        0.900605320930481,
        "    max_sum = max((sum(sublist) for sublist in lst))\n    max_index = next((i for i, sublist in enumerate(lst) if sum(sublist) == max_sum))\n    return (max_sum, max_index)"
      ],
      [
        0.900556206703186,
        "    max_sum = max((sum(sublist) for sublist in lst))\n    max_index = next((i for i, sublist in enumerate(lst) if sum(sublist) == max_sum))\n    return (max_sum, max_index)"
      ],
      [
        0.8997026085853577,
        "    lists = [x, y, z]\n    result = []\n    for lis in lists:\n        if not lis:\n            result.append(0)\n        else:\n            max_num = -10 ** 18\n            for num in lis:\n                max_num = max(max_num, num)\n            result.append(max_num)\n    result = list(dict.fromkeys(result))\n    return result"
      ],
      [
        0.8992716073989868,
        "    max_sum = 0\n    for inner_arr in arr:\n        curr_sum = 0\n        for sub_arr in inner_arr:\n            curr_sum += sum(sub_arr)\n        if curr_sum > max_sum:\n            max_sum = curr_sum\n    return max_sum"
      ]
    ],
    "MBPP/13": [
      [
        0.9327227473258972,
        "    decimal_number = 0\n    for digit in binary_number:\n        decimal_number = decimal_number * 2 + int(digit)\n    return decimal_number"
      ],
      [
        0.9317863583564758,
        "    decimal = 0\n    for digit in binary:\n        decimal = decimal * 2 + int(digit)\n    return decimal"
      ],
      [
        0.931767463684082,
        "    decimal = 0\n    for digit in binary:\n        decimal = decimal * 2 + int(digit)\n    return decimal"
      ],
      [
        0.9317631721496582,
        "    decimal = 0\n    for digit in binary:\n        decimal = decimal * 2 + int(digit)\n    return decimal"
      ],
      [
        0.9317542910575867,
        "    decimal = 0\n    for digit in binary:\n        decimal = decimal * 2 + int(digit)\n    return decimal"
      ],
      [
        0.9297353029251099,
        "    if not isinstance(binary_num, str):\n        raise ValueError('Input number must be a binary string.')\n    decimal_num = int(binary_num, 2)\n    return decimal_num"
      ],
      [
        0.9296039342880249,
        "    binary = str(binary)\n    decimal = 0\n    for digit in binary:\n        decimal = decimal * 2 + int(digit)\n    return decimal"
      ],
      [
        0.929593563079834,
        "    binary = str(binary)\n    decimal = 0\n    for digit in binary:\n        decimal = decimal * 2 + int(digit)\n    return decimal"
      ],
      [
        0.928455114364624,
        "    decimal = 0\n    for i in range(0, len(binary)):\n        decimal += int(binary[i]) * 2 ** (len(binary) - 1 - i)\n    return decimal"
      ],
      [
        0.928343653678894,
        "    decimal_num = 0\n    for digit in binary_num:\n        decimal_num = decimal_num * 2 + int(digit)\n    return decimal_num"
      ]
    ],
    "MBPP/14": [
      [
        0.9236128926277161,
        "    unique_lst = set(lst)\n    product = 1\n    for num in unique_lst:\n        product *= num\n    return product"
      ],
      [
        0.9166404008865356,
        "    distinct_nums = set(num_list)\n    product = reduce(operator.mul, distinct_nums, 1)\n    return product"
      ],
      [
        0.9158223271369934,
        "    product = 1\n    for num in arr:\n        if num % 3 == 0 and num != 4:\n            product *= num\n    return product"
      ],
      [
        0.9143580794334412,
        "    if len(array) == 1:\n        return array[0]\n    else:\n        return array[0] * product(array[1:])"
      ],
      [
        0.9143580794334412,
        "    if len(array) == 1:\n        return array[0]\n    else:\n        return array[0] * product(array[1:])"
      ],
      [
        0.9140768051147461,
        "    product = 1\n    for i in range(len(arr)):\n        product *= arr[i]\n    return product"
      ],
      [
        0.9134902954101562,
        "    product = 1\n    unique_numbers = set(seq)\n    for number in unique_numbers:\n        product *= number\n    return product"
      ],
      [
        0.913489818572998,
        "    product = 1\n    unique_numbers = set(seq)\n    for number in unique_numbers:\n        product *= number\n    return product"
      ],
      [
        0.9134044647216797,
        "    for i in range(len(arr)):\n        product *= arr[i]"
      ],
      [
        0.9130109548568726,
        "    for num in distinct_arr:\n        product *= num"
      ]
    ],
    "MBPP/15": [
      [
        0.8865698575973511,
        "    for t in tuples:\n        if 'k' in t:\n            return True\n    return False"
      ],
      [
        0.8855915069580078,
        "    if not isinstance(k, int):\n        return \"Error: Argument 'k' should be an integer\"\n    if not all((isinstance(t, tuple) for t in tuples)):\n        return 'Error: All elements should be tuples'\n    indices = [i for i, t in enumerate(tuples) if k in t]\n    if not indices:\n        return f'No tuples found containing the number {k}'\n    return indices"
      ],
      [
        0.8820208311080933,
        "    for t in tuples:\n        if 'k' in t:\n            return True"
      ],
      [
        0.8812617063522339,
        "    for i in t:\n        if type(i) == tuple:\n            count += find_frequency(i, k)\n        elif i == k:\n            count += 1"
      ],
      [
        0.8812515735626221,
        "    for i in t:\n        if type(i) == tuple:\n            count += find_frequency(i, k)\n        elif i == k:\n            count += 1"
      ],
      [
        0.8801748752593994,
        "    count = 0\n    for i in t:\n        if type(i) == tuple:\n            count += find_frequency(i, k)\n        elif i == k:\n            count += 1\n    return count"
      ],
      [
        0.8801641464233398,
        "    count = 0\n    for i in t:\n        if type(i) == tuple:\n            count += find_frequency(i, k)\n        elif i == k:\n            count += 1\n    return count"
      ],
      [
        0.8796579837799072,
        "    if not all((isinstance(t, tuple) for t in tuples)):\n        raise TypeError('All input items must be of type tuple.')\n    elif not isinstance(k, int):\n        raise TypeError('The search key must be an integer.')\n    indices = [i for i, t in enumerate(tuples) if k in t]\n    if not indices:\n        return f\"The integer '{k}' was not found in any tuple.\"\n    else:\n        return indices"
      ],
      [
        0.8796533346176147,
        "    if not all((isinstance(t, tuple) for t in tuples)):\n        raise TypeError('All input items must be of type tuple.')\n    elif not isinstance(k, int):\n        raise TypeError('The search key must be an integer.')\n    indices = [i for i, t in enumerate(tuples) if k in t]\n    if not indices:\n        return f\"The integer '{k}' was not found in any tuple.\"\n    else:\n        return indices"
      ],
      [
        0.8793767690658569,
        "    if check_presence:\n        return element in my_tuple\n    else:\n        return element not in my_tuple"
      ]
    ],
    "MBPP/16": [
      [
        0.9047301411628723,
        "    output_string = ''\n    for char in input_string:\n        if not char.isdigit():\n            output_string += char\n    return output_string"
      ],
      [
        0.9047287702560425,
        "    output_string = ''\n    for char in input_string:\n        if not char.isdigit():\n            output_string += char\n    return output_string"
      ],
      [
        0.9039291739463806,
        "    filtered = []\n    for item in arr:\n        if item.isdigit():\n            filtered.append(item)\n    return filtered"
      ],
      [
        0.9029483795166016,
        "    filtered_list = []\n    for string in strings_list:\n        if any((char.isalnum() for char in string)):\n            filtered_list.append(string)\n    return filtered_list"
      ],
      [
        0.897061288356781,
        "    filtered_words = []\n    for word in list_of_strings:\n        if not any((char.isdigit() for char in word)):\n            if not word[0].isupper():\n                filtered_words.append(word)\n    return filtered_words"
      ],
      [
        0.8966808319091797,
        "    non_numbers = [character for character in input_string if not character.isdigit()]\n    return ''.join(non_numbers)"
      ],
      [
        0.8957465291023254,
        "    output = ''.join(filter(lambda x: not x.isdigit(), string))\n    return output"
      ],
      [
        0.8952904939651489,
        "    lowercase_letters = []\n    for string in strings:\n        lowercase_letters += remove_digits_special_chars(string)\n    return lowercase_letters"
      ],
      [
        0.8951559066772461,
        "    numbers = []\n    for char in my_string:\n        if char.isdigit():\n            numbers.append(char)\n    return numbers"
      ],
      [
        0.895067572593689,
        "    modified_document = ''\n    for ch in document:\n        if not ch.isdigit():\n            modified_document += ch\n    return modified_document"
      ]
    ],
    "MBPP/17": [
      [
        0.9105063676834106,
        "    if type(n) in (float, complex):\n        return 'Binomial coefficients are not defined for floating point and complex numbers.'"
      ],
      [
        0.9104688167572021,
        "    if type(n) in (float, complex):\n        return 'Binomial coefficients are not defined for floating point and complex numbers.'"
      ],
      [
        0.9087896943092346,
        "    if type(n) not in (int, float, complex, list, tuple):\n        return 'Invalid input. Please enter a positive integer, a floating point number, a complex number, a list or a tuple.'\n    if type(n) in (float, complex):\n        return 'Binomial coefficients are not defined for floating point and complex numbers.'\n    if type(n) == int and n < 0:\n        return 'Invalid input. Please enter a non-negative integer.'\n    if type(n) in (list, tuple):\n        try:\n            cumulative_product = 1\n            for i in n:\n                if i < 0 or type(i) != int:\n                    return 'Invalid input in list/tuple. Please ensure all elements are non-negative integers.'\n                if i > 0:\n                    cumulative_product *= functools.reduce(operator.mul, (math.comb(i, j) for j in range(i + 1)), 1)\n            return cumulative_product\n        except TypeError:\n            return\n    elif type(n) == int:\n        return functools.reduce(operator.mul, (math.comb(n, i) for i in range(n + 1)), 1)"
      ],
      [
        0.908073902130127,
        "    if type(n) not in (int, float, complex, list, tuple):\n        return 'Invalid input. Please enter a positive integer, a floating point number, a complex number, a list or a tuple.'\n    if type(n) in (float, complex):\n        return 'Binomial coefficients are not defined for floating point and complex numbers.'\n    if type(n) == int and n < 0:\n        return 'Invalid input. Please enter a non-negative integer.'\n    if type(n) in (list, tuple):\n        try:\n            cumul_product = 1\n            for i in n:\n                if i < 0 or type(i) != int:\n                    return 'Invalid input in list/tuple. Please assure all elements are non-negative integers.'\n                if i > 0:\n                    cumul_product *= functools.reduce(operator.mul, (math.comb(i, j) for j in range(i + 1)), 1)\n            return cumul_product\n        except TypeError:\n            return\n    elif type(n) == int:\n        return functools.reduce(operator.mul, (math.comb(n, i) for i in range(n + 1)), 1)"
      ],
      [
        0.9074580073356628,
        "    if n == k or k == 0:\n        return 1\n    return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k)"
      ],
      [
        0.9048932790756226,
        "    if k == 0 or k == n:\n        return 1\n    return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k)"
      ],
      [
        0.9041604995727539,
        "    coefficient = []\n    for k in range(n + 1):\n        coefficient.append(int(math.factorial(n) / (math.factorial(k) * math.factorial(n - k))))\n    return coefficient"
      ],
      [
        0.8973772525787354,
        "    for k in range(n + 1):\n        coefficient.append(int(math.factorial(n) / (math.factorial(k) * math.factorial(n - k))))"
      ],
      [
        0.8967903852462769,
        "    if k == 0 or k == n:\n        return 1\n    else:\n        return (binomial_coefficient(n - 1, k - 1, modulo) + binomial_coefficient(n - 1, k, modulo)) % modulo"
      ]
    ],
    "MBPP/18": [
      [
        0.9176737070083618,
        "    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    for num in arr:\n        if freq[num] % 2 != 0:\n            return num\n    return None"
      ],
      [
        0.916891872882843,
        "    for num in arr:\n        if freq[num] % 2 != 0:\n            return num"
      ],
      [
        0.9165377616882324,
        "    for num in arr:\n        if frequency[num] % 2 != 0:\n            return num"
      ],
      [
        0.913617730140686,
        "    count_dict = {}\n    for num in arr:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    for key, value in count_dict.items():\n        if value % 2 == 1:\n            return key\n    return None"
      ],
      [
        0.9114210605621338,
        "    counter_dict = {}\n    for num in lst:\n        if num in counter_dict:\n            counter_dict[num] += 1\n        else:\n            counter_dict[num] = 1\n    odd_occurrence_list = [num for num, freq in counter_dict.items() if freq % 2 == 1]\n    return odd_occurrence_list"
      ],
      [
        0.9112945795059204,
        "    count = {}\n    for num in arr:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    for num in arr:\n        if count[num] % 2 == 1:\n            return num\n    return -1"
      ],
      [
        0.9104864597320557,
        "    for num in arr:\n        if count[num] % 2 == 1:\n            return num"
      ],
      [
        0.9088071584701538,
        "    counter = Counter(array)\n    odd_counter = {k: v for k, v in counter.items() if k % 2 != 0}\n    if odd_counter:\n        return max(odd_counter, key=odd_counter.get)\n    else:\n        return 'No odd numbers in array'"
      ],
      [
        0.9077858924865723,
        "    count_dict = {}\n    for num in arr:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    for num, count in count_dict.items():\n        if count % 2 != 0:\n            return num\n    return -1"
      ],
      [
        0.9073256254196167,
        "    for i in range(len(arr)):\n        if arr[i] % 2 != 0:\n            return arr[i]\n    return 'No odd number found'"
      ]
    ],
    "MBPP/19": [
      [
        0.915766179561615,
        "    count = 0\n    for i in range(len(input_str)):\n        for j in range(i + 1, len(input_str) + 1):\n            substr = input_str[i:j]\n            if substr[0] == substr[-1]:\n                count += 1\n    return count"
      ],
      [
        0.9149429798126221,
        "            if substr[0] == substr[-1]:\n                count += 1"
      ],
      [
        0.9137494564056396,
        "    for i in range(len(input_str)):\n        for j in range(i + 1, len(input_str) + 1):\n            substr = input_str[i:j]\n            if substr[0] == substr[-1]:\n                count += 1"
      ],
      [
        0.9116255044937134,
        "    count = 0\n    for s in lst:\n        if len(s) >= 2 and s[0] == s[-1]:\n            count += 1\n    return count"
      ],
      [
        0.9114566445350647,
        "        for j in range(i + 1, len(input_str) + 1):\n            substr = input_str[i:j]\n            if substr[0] == substr[-1]:\n                count += 1"
      ],
      [
        0.9099735021591187,
        "    for s in lst:\n        if len(s) >= 2 and s[0] == s[-1]:\n            count += 1"
      ],
      [
        0.9082250595092773,
        "        while l >= 0 and r < n and (s[l] == s[r]):\n            count += 1\n            dp[r] = (dp[r] + dp[l]) % MOD\n            l -= 1\n            r += 1"
      ],
      [
        0.9082250595092773,
        "        while l >= 0 and r < n and (s[l] == s[r]):\n            count += 1\n            dp[r] = (dp[r] + dp[l]) % MOD\n            l -= 1\n            r += 1"
      ],
      [
        0.9065709710121155,
        "    for i in range(n):\n        l = r = i\n        while l >= 0 and r < n and (s[l] == s[r]):\n            count += 1\n            l -= 1\n            r += 1"
      ],
      [
        0.9046937227249146,
        "            if substring == substring[::-1]:\n                count += 1"
      ]
    ],
    "MBPP/20": [
      [
        0.927685558795929,
        "    frequency = {}\n    for value in array:\n        if value in frequency:\n            frequency[value] += 1\n        else:\n            frequency[value] = 1\n    heap = []\n    for value, freq in frequency.items():\n        heapq.heappush(heap, (freq, value))\n        if len(heap) > k:\n            heapq.heappop(heap)\n    k_most_common = []\n    while heap:\n        freq, value = heapq.heappop(heap)\n        k_most_common.append((value, freq))\n    k_most_common.reverse()\n    return k_most_common"
      ],
      [
        0.9235748052597046,
        "    frequency = Counter(nums)\n    min_heap = []\n    for num, freq in frequency.items():\n        heappush(min_heap, (freq, num))\n        if len(min_heap) > k:\n            heappop(min_heap)\n    return [heappop(min_heap)[1] for _ in range(k)]"
      ],
      [
        0.9223538041114807,
        "    counter = Counter(nums)\n    heap = []\n    for num, count in counter.items():\n        heapq.heappush(heap, (count, num))\n        if len(heap) > k:\n            heapq.heappop(heap)\n    return [num for count, num in heap]"
      ],
      [
        0.9214645028114319,
        "    freq_map = defaultdict(int)\n    for num in nums:\n        freq_map[num] += 1\n    min_heap = []\n    for num, freq in freq_map.items():\n        if len(min_heap) < k:\n            heapq.heappush(min_heap, (freq, num))\n        elif freq > min_heap[0][0]:\n            heapq.heappop(min_heap)\n            heapq.heappush(min_heap, (freq, num))\n    result = []\n    while min_heap:\n        result.append(heapq.heappop(min_heap)[1])\n    return result[::-1]"
      ],
      [
        0.9212324619293213,
        "    count = Counter(nums)\n    heap = []\n    for num, freq in count.items():\n        if len(heap) < k:\n            heapq.heappush(heap, (freq, num))\n        elif freq > heap[0][0]:\n            heapq.heapreplace(heap, (freq, num))\n    return [x[1] for x in heap]"
      ],
      [
        0.9210920929908752,
        "    for num, count in counter.items():\n        heapq.heappush(heap, (count, num))\n        if len(heap) > k:\n            heapq.heappop(heap)"
      ],
      [
        0.9208821058273315,
        "    for num, freq in frequency.items():\n        heappush(min_heap, (freq, num))\n        if len(min_heap) > k:\n            heappop(min_heap)"
      ],
      [
        0.9205962419509888,
        "    freq_map = {}\n    for num in nums:\n        freq_map[num] = freq_map.get(num, 0) + 1\n    min_heap = []\n    for num, freq in freq_map.items():\n        heapq.heappush(min_heap, (freq, num))\n        if len(min_heap) > k:\n            heapq.heappop(min_heap)\n    result = []\n    while min_heap:\n        result.append(heapq.heappop(min_heap)[1])\n    result.reverse()\n    return result"
      ],
      [
        0.9202529788017273,
        "        if len(heap) < k:\n            heapq.heappush(heap, (freq, num))\n        elif freq > heap[0][0]:\n            heapq.heapreplace(heap, (freq, num))"
      ],
      [
        0.9199120998382568,
        "    for value, freq in frequency.items():\n        heapq.heappush(heap, (freq, value))\n        if len(heap) > k:\n            heapq.heappop(heap)"
      ]
    ],
    "MBPP/21": [],
    "MBPP/22": [
      [
        0.9260730743408203,
        "    binary_number = bin(decimal_number).replace('0b', '')\n    return binary_number"
      ],
      [
        0.9185986518859863,
        "    if n > 1:\n        decimalToBinary(n // 2)"
      ],
      [
        0.9185972213745117,
        "    binary_num = bin(decimal_num)\n    binary_num = binary_num[2:]\n    return binary_num"
      ],
      [
        0.9184532165527344,
        "    binary = ''\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal = decimal // 2\n    return binary"
      ],
      [
        0.9184191823005676,
        "    binary = ''\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal = decimal // 2\n    return binary"
      ],
      [
        0.9184033870697021,
        "    binary = bin(decimal)[2:]\n    return binary"
      ],
      [
        0.9183006286621094,
        "    if num > 1:\n        decimal_to_binary(num // 2)"
      ],
      [
        0.9178834557533264,
        "    decimal = 0\n    for digit in binary:\n        decimal = decimal * 2 + int(digit)\n    print('Decimal: ', decimal)\n    binary = input('Enter a binary number: ')\n    binaryConversion(binary)"
      ],
      [
        0.9177542924880981,
        "    binary = []\n    while decimal > 0:\n        binary.append(decimal % 2)\n        decimal = decimal // 2\n    binary.reverse()\n    return binary"
      ],
      [
        0.9176636934280396,
        "    if decimal == 0:\n        return '0'\n    binary = ''\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal = decimal // 2\n    return binary"
      ]
    ],
    "MBPP/23": [
      [
        0.9294337630271912,
        "    sorted_arr = sorted(arr)\n    curr = sorted_arr[0]\n    for element in sorted_arr[1:]:\n        if element != curr + 1:\n            return curr + 1\n        else:\n            curr = element\n    return missing"
      ],
      [
        0.9209897518157959,
        "    all_nums = set(range(1, arr[-1] + 1))\n    arr_nums = set(arr)\n    missing_number = list(all_nums - arr_nums)[0]\n    return missing_number"
      ]
    ],
    "MBPP/24": [
      [
        0.8968980312347412,
        "        if triangular_number <= n:\n            count += 1"
      ],
      [
        0.8882505893707275,
        "    count = 0\n    for i in range(n):\n        triangular_number = i * (i + 1) // 2\n        if triangular_number <= n:\n            count += 1\n    return count"
      ],
      [
        0.8876500129699707,
        "        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4"
      ],
      [
        0.8876383304595947,
        "        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4"
      ],
      [
        0.8871201872825623,
        "    index = math.ceil((math.sqrt(8 * math.pow(10, n - 1) + 1) - 1) / 2)\n    triang_num = index * (index + 1) // 2\n    return (index, triang_num)"
      ],
      [
        0.8851717710494995,
        "    for i in range(n):\n        triangular_number = i * (i + 1) // 2\n        if triangular_number <= n:\n            count += 1"
      ],
      [
        0.8836828470230103,
        "    if n == 1:\n        return 1\n    else:\n        return n + triangle_num(n - 1)"
      ],
      [
        0.8836828470230103,
        "    if n == 1:\n        return 1\n    else:\n        return n + triangle_num(n - 1)"
      ],
      [
        0.8834736347198486,
        "        if triangular_num >= start and triangular_num <= end:\n            count += 1"
      ],
      [
        0.8827284574508667,
        "    for square in square_generator(n):\n        square_sum += square"
      ]
    ],
    "MBPP/25": [
      [
        0.8853890895843506,
        "    if n > 0:\n        return Decimal(fibonacci(n)) / Decimal(fibonacci(n - 1))\n    else:\n        return 0"
      ],
      [
        0.8830133676528931,
        "    getcontext().prec = 1000\n    if n > 0:\n        return Decimal(fibonacci(n)) / Decimal(fibonacci(n - 1))\n    else:\n        return 0"
      ],
      [
        0.8794726133346558,
        "    if a % 2 != 0:\n        if n < 0:\n            return 'Cannot use negative indices with this value of a'\n        elif n == 0:\n            return a\n        elif n == 1:\n            return b\n        elif n == 2:\n            return 1\n    else:\n        if n == 0:\n            return a\n        elif n == 1:\n            return b\n        elif n == 2:\n            return 1\n        if n < 0:\n            if b > 10 and b % 2 == 0:\n                return a + b - n"
      ],
      [
        0.8781769871711731,
        "    if fractional_part > 0:\n        next_digit = int(fractional_part * base)\n        result += str(next_digit)\n        fractional_part -= next_digit / base\n        next_digits = recursive_function(fractional_part, base, precision - 1)\n        result += next_digits"
      ],
      [
        0.8781167268753052,
        "    if a % 2 != 0:\n        if n < 0:\n            return 'Cannot use negative indices with this value of a'\n        if n == 0:\n            return a\n        if n == 1:\n            return b\n        if n == 2:\n            return 1\n    else:\n        if n == 0:\n            return a\n        if n == 1:\n            return b\n        if n == 2:\n            return 1\n        if n < 0:\n            if b > 10 and b % 2 == 0:\n                return a + b - n"
      ],
      [
        0.8775906562805176,
        "    if not isinstance(number, (int, float)) or not isinstance(base, int) or (not isinstance(precision, int)):\n        return 'Invalid input. Please provide a number, base, and precision as integers or floats.'\n    if base <= 0 or precision < 0:\n        return 'Invalid input. Base should be a positive integer and precision should be a non-negative integer.'\n    if precision == 0:\n        return str(round(number))\n    integer_part = int(number)\n    fractional_part = abs(number - integer_part)\n    result = str(integer_part) + '.'\n    if fractional_part > 0:\n        next_digit = int(fractional_part * base)\n        result += str(next_digit)\n        fractional_part -= next_digit / base\n        next_digits = recursive_function(fractional_part, base, precision - 1)\n        result += next_digits\n    return result"
      ],
      [
        0.8753545880317688,
        "        if numerator >= denominator:\n            numerator -= denominator\n            decimal += 1\n        else:\n            break"
      ],
      [
        0.874433696269989,
        "    if not isinstance(n, int):\n        raise ValueError('Input must be an integer.')\n    if n < 0:\n        n = -n\n    least_digit = n % 10\n    print('The least significant digit of', n, 'is', least_digit)\n    return least_digit"
      ],
      [
        0.8737269639968872,
        "    getcontext().prec = n + 1\n    fib_n = calculate_fib_number(n)\n    fib_n1 = calculate_fib_number(n - 1)\n    golden_number = fib_n / fib_n1\n    return round(golden_number, n)"
      ],
      [
        0.8736559152603149,
        "    if n == 0:\n        return count\n    else:\n        return recursive_function(n // 10, count + 1)"
      ]
    ],
    "MBPP/26": [
      [
        0.9319460988044739,
        "    strings = [element for element in mixed_list if isinstance(element, str)]\n    strings.sort()\n    sorted_list = []\n    i = 0\n    for element in mixed_list:\n        if isinstance(element, str):\n            sorted_list.append(strings[i])\n            i += 1\n        else:\n            sorted_list.append(element)\n    return sorted_list"
      ],
      [
        0.9284327030181885,
        "    int_list = list(filter(lambda x: isinstance(x, int), mixed_list))\n    str_list = list(filter(lambda x: isinstance(x, str), mixed_list))\n    str_list.sort()\n    sorted_list = int_list + str_list\n    return sorted_list"
      ],
      [
        0.9248067140579224,
        "    nums = [num for num in list1 if isinstance(num, int)]\n    strings = [s for s in list1 if isinstance(s, str)]\n    sorted_nums = sorted(nums)\n    sorted_strings = sorted(strings)\n    sorted_list = sorted_nums + sorted_strings\n    return sorted_list"
      ],
      [
        0.9202629327774048,
        "    strings = [item for item in mixed_list if isinstance(item, str)]\n    indices = [index for index, item in enumerate(mixed_list) if isinstance(item, str)]\n    strings.sort()\n    for i, index in enumerate(indices):\n        mixed_list[index] = strings[i]\n    return mixed_list"
      ],
      [
        0.9171537160873413,
        "    for element in mixed_list:\n        if isinstance(element, str):\n            sorted_list.append(strings[i])\n            i += 1\n        else:\n            sorted_list.append(element)"
      ],
      [
        0.9168510437011719,
        "    str_indices = [i for i, x in enumerate(mixed_list) if type(x) == str]\n    str_list = sorted([x for x in mixed_list if type(x) == str])\n    for i, index in enumerate(str_indices):\n        mixed_list[index] = str_list[i]\n    return mixed_list"
      ],
      [
        0.9155541658401489,
        "    str_list = [item for item in mixed_list if isinstance(item, str)]\n    str_list.sort()\n    int_index_list = [i for i, item in enumerate(mixed_list) if isinstance(item, int)]\n    for index, string in zip(int_index_list, str_list):\n        mixed_list.insert(index, string)\n    for i in int_index_list:\n        mixed_list.remove(mixed_list[i + len(int_index_list)])\n    return mixed_list"
      ],
      [
        0.9151340126991272,
        "    numbers = []\n    strings = []\n    for element in arr:\n        if element.isdigit():\n            numbers.append(element)\n        else:\n            strings.append(element)\n    numbers.sort()\n    strings.sort()\n    sorted_arr = numbers + strings\n    return sorted_arr"
      ],
      [
        0.9144963026046753,
        "    integers = []\n    strings = []\n    for element in arr:\n        if isinstance(element, int):\n            integers.append(element)\n        elif isinstance(element, str):\n            if not re.search('[^a-zA-Z]', element):\n                strings.append(element.lower())\n    integers.sort()\n    strings.sort(key=lambda x: len(x))\n    return integers + strings"
      ],
      [
        0.9142650365829468,
        "    string_list = sorted([x for x in mix_list if isinstance(x, str)])\n    non_string_list = [x for x in mix_list if not isinstance(x, str)]\n    return non_string_list + string_list"
      ]
    ],
    "MBPP/27": [
      [
        0.9199866056442261,
        "    odd_numbers = []\n    even_numbers = []\n    for num in lst:\n        if num % 2 == 0:\n            even_numbers.append(num)\n        else:\n            odd_numbers.append(num)\n    return (odd_numbers, even_numbers)"
      ],
      [
        0.9196422100067139,
        "    even = []\n    odd = []\n    for i in lst:\n        if i % 2 == 0:\n            even.append(i)\n        else:\n            odd.append(i)\n    return (even, odd)"
      ],
      [
        0.91841721534729,
        "    odd_list = []\n    even_list = []\n    for num in l:\n        if num % 2 == 0:\n            even_list.append(num)\n        else:\n            odd_list.append(num)\n    return (even_list, odd_list)"
      ],
      [
        0.9171104431152344,
        "    odd_list = []\n    even_list = []\n    for i in my_list:\n        if i % 2 == 0:\n            even_list.append(i)\n        else:\n            odd_list.append(i)\n    return (odd_list, even_list)"
      ],
      [
        0.9167214632034302,
        "    even = []\n    odd = []\n    for number in arr:\n        if number % 2 == 0:\n            even.append(number)\n        else:\n            odd.append(number)\n    return (even, odd)"
      ],
      [
        0.9167214035987854,
        "    even = []\n    odd = []\n    for number in arr:\n        if number % 2 == 0:\n            even.append(number)\n        else:\n            odd.append(number)\n    return (even, odd)"
      ],
      [
        0.9161020517349243,
        "    even = []\n    odd = []\n    for i in arr:\n        if i % 2 == 0:\n            even.append(i)\n        else:\n            odd.append(i)\n    return (even, odd)"
      ],
      [
        0.9157766103744507,
        "    odd = []\n    even = []\n    for num in arr:\n        if num % 2 == 0:\n            even.append(num)\n        else:\n            odd.append(num)\n    return (odd, even)"
      ],
      [
        0.9154547452926636,
        "    odd = []\n    even = []\n    for x in arr:\n        if x % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n    return (odd, even)"
      ],
      [
        0.9148949980735779,
        "    odd_numbers = []\n    even_numbers = []\n    for num in mylist:\n        if num % 2 == 0:\n            even_numbers.append(num)\n        else:\n            odd_numbers.append(num)\n    return (odd_numbers, even_numbers)"
      ]
    ],
    "MBPP/28": [
      [
        0.9145445823669434,
        "    is_palindromeable = False\n    for i in range(len(string)):\n        j = len(string) - i - 1\n        if string[i] == string[j]:\n            is_palindromeable = True\n        else:\n            is_palindromeable = False\n            break\n    if is_palindromeable:\n        print('It is possible to rearrange the letters in the string to create a palindrome.')\n    else:\n        print('It is not possible to rearrange the letters in the string to create a palindrome.')"
      ],
      [
        0.9033040404319763,
        "    if is_palindromeable:\n        print('It is possible to rearrange the letters in the string to create a palindrome.')\n    else:\n        print('It is not possible to rearrange the letters in the string to create a palindrome.')"
      ],
      [
        0.9031730890274048,
        "    if all((v % 2 == 0 for v in letter_fre_dict.values())) and all((v >= 2 for v in letter_fre_dict.values())):\n        return not any((s[i] == s[i + 1] for i in range(len(s) - 1)))"
      ],
      [
        0.8992611169815063,
        "    for i in range(len(arr)):\n        s1 = arr[i]\n        for j in range(i + 1, len(arr)):\n            s2 = arr[j]\n            if sorted(s1) != sorted(s2):\n                return False\n    return True"
      ],
      [
        0.8989501595497131,
        "    for i in range(len(arr)):\n        s1 = arr[i]\n        for j in range(i + 1, len(arr)):\n            s2 = arr[j]\n            if sorted(s1) != sorted(s2):\n                return False"
      ],
      [
        0.8961955308914185,
        "    if is_palindrome(s) and can_rearrange_to_palindrome(s):\n        return True\n    return False"
      ],
      [
        0.8961407542228699,
        "    if is_palindrome(s) and can_rearrange_to_palindrome(s):\n        return True"
      ],
      [
        0.8958625793457031,
        "    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            return False\n        letter_count[s[i]] = letter_count.get(s[i], 0) + 1"
      ],
      [
        0.8947417140007019,
        "    is_anagrams = True\n    for i in range(len(a) - 1):\n        if not is_anagram(a[i], a[i + 1]):\n            is_anagrams = False\n            break\n    return is_anagrams"
      ],
      [
        0.8943107724189758,
        "    for i in range(len(str)):\n        for j in range(i + 1, len(str)):\n            if str[i] == str[j]:\n                return False"
      ]
    ],
    "MBPP/29": [
      [
        0.907184898853302,
        "    freq_dict = {}\n    for item in list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict"
      ],
      [
        0.9067159295082092,
        "    freq = {}\n    for element in lst:\n        if element in freq:\n            freq[element] += 1\n        else:\n            freq[element] = 1\n    return freq"
      ],
      [
        0.906667172908783,
        "    if not input_list:\n        return {}\n    frequency_counter = Counter(input_list)\n    frequency_dict = dict(frequency_counter)\n    return frequency_dict"
      ],
      [
        0.9059315919876099,
        "    frequency_dict = dict(Counter(input_list))\n    return frequency_dict"
      ],
      [
        0.9053337574005127,
        "    frequency_dict = {}\n    for element in lst:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict"
      ],
      [
        0.9053122401237488,
        "    frequency = {}\n    for item in arr:\n        for element in item.values():\n            if element in frequency:\n                frequency[element] += 1\n            else:\n                frequency[element] = 1\n    return frequency"
      ],
      [
        0.9048202633857727,
        "    frequency = {}\n    for item in my_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency"
      ],
      [
        0.9026111364364624,
        "    frequency = {}\n    for i in lst:\n        if i in frequency:\n            frequency[i] += 1\n        else:\n            frequency[i] = 1\n    return frequency"
      ],
      [
        0.9017436504364014,
        "    frequency_dict = {}\n    for sublist in matrix:\n        if isinstance(sublist, list):\n            for item in sublist:\n                if isinstance(item, list):\n                    for subitem in item:\n                        frequency_dict[subitem] = frequency_dict.get(subitem, 0) + 1\n                else:\n                    frequency_dict[item] = frequency_dict.get(item, 0) + 1\n        else:\n            frequency_dict[sublist] = frequency_dict.get(sublist, 0) + 1\n    return frequency_dict"
      ],
      [
        0.9016973972320557,
        "    frequency_dict = {}\n    for sublist in matrix:\n        if isinstance(sublist, list):\n            for item in sublist:\n                if isinstance(item, list):\n                    for subitem in item:\n                        frequency_dict[subitem] = frequency_dict.get(subitem, 0) + 1\n                else:\n                    frequency_dict[item] = frequency_dict.get(item, 0) + 1\n        else:\n            frequency_dict[sublist] = frequency_dict.get(sublist, 0) + 1\n    return frequency_dict"
      ]
    ],
    "MBPP/30": [
      [
        0.9334943294525146,
        "    even_numbers = filter(lambda num: num % 2 == 0, numbers)\n    return list(even_numbers)"
      ]
    ],
    "MBPP/31": [
      [
        0.9148580431938171,
        "    unique_elements = set()\n    total_sum = 0\n    for element in arr:\n        if element not in unique_elements:\n            unique_elements.add(element)\n            total_sum += element\n    return total_sum"
      ],
      [
        0.9148404598236084,
        "    unique_elements = set()\n    total_sum = 0\n    for element in arr:\n        if element not in unique_elements:\n            unique_elements.add(element)\n            total_sum += element\n    return total_sum"
      ],
      [
        0.9146536588668823,
        "    arr = sorted(arr)\n    total_sum = sum(arr)\n    print('Sum of elements:', total_sum)\n    count_dict = dict()\n    for i in arr:\n        if i in count_dict:\n            count_dict[i] += 1\n        else:\n            count_dict[i] = 1\n    max_freq = max(count_dict.values())\n    max_freq_nums = sorted([key for key, value in count_dict.items() if value == max_freq])\n    if len(max_freq_nums) > 0:\n        print('Element with highest cumulative frequency:', max_freq_nums)\n    else:\n        print('No repeated elements.')"
      ],
      [
        0.9091377854347229,
        "    for num in array:\n        if array.count(num) == 1:\n            sum += num"
      ],
      [
        0.9085156321525574,
        "    unique_integers = set()\n    total_sum = 0\n    for num in lst:\n        if num not in unique_integers:\n            unique_integers.add(num)\n            total_sum += num\n    return total_sum"
      ],
      [
        0.9078803062438965,
        "    for element in arr:\n        if element not in unique_elements:\n            unique_elements.add(element)\n            total_sum += element"
      ],
      [
        0.9078797101974487,
        "    for element in arr:\n        if element not in unique_elements:\n            unique_elements.add(element)\n            total_sum += element"
      ],
      [
        0.9069874882698059,
        "    unique_elements = set()\n    for element in my_list:\n        unique_elements.add(element)\n    sum_of_elements = 0\n    for unique_element in unique_elements:\n        sum_of_elements += unique_element\n    return sum_of_elements"
      ],
      [
        0.9060685634613037,
        "    for num in arr:\n        if num not in unique_nums:\n            unique_nums.append(num)\n            sum += num"
      ],
      [
        0.9060282707214355,
        "    unique_numbers = set()\n    total_sum = 0\n    for num in lst:\n        if num not in unique_numbers:\n            unique_numbers.add(num)\n            total_sum += num\n    return total_sum"
      ]
    ],
    "MBPP/32": [
      [
        0.8857033252716064,
        "    pattern = re.compile('a.*Z')\n    return pattern.findall(text)"
      ],
      [
        0.8850178718566895,
        "    pattern = re.compile('[a-z\\\\W].*\\\\d$')\n    matches = pattern.findall(s)\n    return matches"
      ],
      [
        0.8826394081115723,
        "    pattern = '\\\\b\\\\w*[bcdfghjklmnpqrstvwxyz]{3}\\\\w*\\\\b'\n    return re.findall(pattern, text, re.I)"
      ],
      [
        0.8821999430656433,
        "    return re.findall('[A-Z][^A-Z]*', s)"
      ],
      [
        0.8819348812103271,
        "    elif cases['Underscore']:\n        return 'Underscore'"
      ],
      [
        0.8815767168998718,
        "    pattern_ab = '\\\\b(?:[A-Z][^A-Z]*){4}\\\\b'\n    matches_ab = re.findall(pattern_ab, text)\n    pattern_cd = '\\\\b(?:[C][D]){4}\\\\b'\n    matches_cd = re.findall(pattern_cd, text)\n    return matches_ab + matches_cd"
      ],
      [
        0.8815728425979614,
        "    pattern_ab = '\\\\b(?:[A-Z][^A-Z]*){4}\\\\b'\n    matches_ab = re.findall(pattern_ab, text)\n    pattern_cd = '\\\\b(?:[C][D]){4}\\\\b'\n    matches_cd = re.findall(pattern_cd, text)\n    return matches_ab + matches_cd"
      ],
      [
        0.8812544345855713,
        "    pattern = '[a-zA-Z]*a[a-zA-Z]*'\n    result = re.findall(pattern, text)\n    return result"
      ],
      [
        0.8812242150306702,
        "    pattern = '[a-zA-Z]*a[a-zA-Z]*'\n    result = re.findall(pattern, text)\n    return result"
      ],
      [
        0.8805678486824036,
        "    pattern = '\\\\b[aA]\\\\w*\\\\b'\n    matches = re.findall(pattern, text)\n    return matches"
      ]
    ],
    "MBPP/33": [
      [
        0.8953014612197876,
        "    words = sentence.split()\n    matches = []\n    for word in words:\n        if word[0] == letter:\n            matches.append(word)\n    return matches"
      ],
      [
        0.8944974541664124,
        "    pattern = '^hello people$'\n    result = re.match(pattern, s)\n    if result:\n        return True\n    else:\n        return False"
      ],
      [
        0.8930805325508118,
        "    return word == 'hello'"
      ],
      [
        0.8927688002586365,
        "    return re.search(word, string)"
      ],
      [
        0.8909099102020264,
        "    pattern = re.compile('^phoenix', re.IGNORECASE | re.MULTILINE)\n    matches = pattern.findall(text)\n    if matches:\n        return 'The lexeme \"phoenix\" is found at the inception of a paragraph.'\n    else:\n        return 'The lexeme \"phoenix\" is NOT found at the inception of a paragraph.'"
      ],
      [
        0.8894956111907959,
        "    words = source_string.split()\n    result = []\n    for word in words:\n        if word[0].lower() == letter:\n            result.append(word)\n    return result"
      ],
      [
        0.8894665837287903,
        "    result = []\n    words = string.split(' ')\n    for word in words:\n        if word[0] == letter:\n            result.append(word)\n    return result"
      ],
      [
        0.8876655101776123,
        "    pattern = '\\\\bA\\\\w*\\\\b'\n    words_starting_with_A = re.findall(pattern, text)\n    return words_starting_with_A"
      ],
      [
        0.8876148462295532,
        "    pattern = re.compile('\\\\b(beginning|starting)\\\\b', re.IGNORECASE)\n    return pattern.findall(input_str)"
      ],
      [
        0.8871334791183472,
        "    results = []\n    for word in words:\n        if word.startswith(s):\n            results.append(word)\n    return results"
      ]
    ],
    "MBPP/34": [
      [
        0.9341455698013306,
        "    num1 = arr[0]\n    num2 = arr[1]\n    gcd = math.gcd(num1, num2)\n    for i in range(2, len(arr)):\n        gcd = math.gcd(gcd, arr[i])\n    return gcd"
      ],
      [
        0.9341355562210083,
        "    num1 = arr[0]\n    num2 = arr[1]\n    gcd = math.gcd(num1, num2)\n    for i in range(2, len(arr)):\n        gcd = math.gcd(gcd, arr[i])\n    return gcd"
      ],
      [
        0.9341233968734741,
        "    num1 = arr[0]\n    num2 = arr[1]\n    gcd = math.gcd(num1, num2)\n    for i in range(2, len(arr)):\n        gcd = math.gcd(gcd, arr[i])\n    return gcd"
      ],
      [
        0.9319241642951965,
        "    num1 = arr[0]\n    for i in range(1, len(arr)):\n        num1 = gcd(num1, arr[i])\n    return num1"
      ],
      [
        0.9314443469047546,
        "    num1 = arr[0]\n    num2 = arr[1]\n    hcf = math.gcd(num1, num2)\n    for i in range(2, len(arr)):\n        hcf = math.gcd(hcf, arr[i])\n    return hcf"
      ],
      [
        0.9295242428779602,
        "    result = arr[0]\n    for i in arr[1:]:\n        result = gcd(result, i)\n    return result"
      ],
      [
        0.9263591170310974,
        "    arr_len = len(nums)\n    if arr_len == 1:\n        return nums[0]\n    else:\n        g = gcd(nums[0], nums[1])\n        for i in range(2, arr_len):\n            g = gcd(g, nums[i])\n    return g"
      ],
      [
        0.9228516817092896,
        "    for i in range(len(arr)):\n        gcd_val = gcd(gcd_val, arr[i])"
      ],
      [
        0.9225709438323975,
        "    result = arr[0]\n    for i in range(1, len(arr)):\n        result = gcd_recursion(result, arr[i])\n    return result"
      ],
      [
        0.9220433235168457,
        "    if len(array) == 0:\n        return 'Array is empty'\n    if len(array) == 1:\n        return abs(array[0])\n    result = abs(array[0])\n    for i in range(1, len(array)):\n        result = gcd(result, abs(array[i]))\n    return result"
      ]
    ],
    "MBPP/35": [
      [
        0.9132770299911499,
        "    for i in range(len(my_list)):\n        for j in range(i + 1, len(my_list)):\n            if my_list[i] != my_list[j]:\n                return False\n    return True"
      ],
      [
        0.9117287993431091,
        "    unique_numbers = set(numbers)\n    if len(numbers) == len(unique_numbers):\n        return True\n    else:\n        return False"
      ],
      [
        0.9105596542358398,
        "    first_elem = arr[0]\n    is_equal = True\n    for elem in arr:\n        if elem != first_elem:\n            is_equal = False\n            break\n    return is_equal"
      ],
      [
        0.9089961051940918,
        "    if len(numbers) == len(unique_numbers):\n        return True\n    else:\n        return False"
      ],
      [
        0.9070613384246826,
        "    if len(numbers) == len(set(numbers)):\n        return True\n    else:\n        return False"
      ],
      [
        0.9070613384246826,
        "    if len(numbers) == len(set(numbers)):\n        return True\n    else:\n        return False"
      ],
      [
        0.9064140319824219,
        "    for i in range(len(my_list)):\n        for j in range(i + 1, len(my_list)):\n            if my_list[i] != my_list[j]:\n                return False"
      ],
      [
        0.9052616357803345,
        "    return len(num_list) == len(set(num_list))"
      ],
      [
        0.9049234390258789,
        "    elif all((x == arr[0] for x in arr)):\n        return True\n    else:\n        return False"
      ],
      [
        0.9042202234268188,
        "    unique_list = []\n    for i in my_list:\n        if i not in unique_list:\n            unique_list.append(i)\n    if len(unique_list) == len(my_list):\n        return True\n    else:\n        return False"
      ]
    ],
    "MBPP/36": [
      [
        0.896355390548706,
        "    last_digit_a = abs(a) % 10\n    last_digit_b = abs(b) % 10\n    return last_digit_a * last_digit_b"
      ],
      [
        0.8955261707305908,
        "    if b == 0:\n        return a\n    else:\n        return divisor_function(b, a % b)"
      ],
      [
        0.8955261707305908,
        "    if b == 0:\n        return a\n    else:\n        return divisor_function(b, a % b)"
      ],
      [
        0.8927644491195679,
        "    if b == 0:\n        return 'Cannot divide by zero'\n    result = 0\n    power = 1\n    while a >= b:\n        divisor = b\n        power_of_2 = 1\n        while divisor << 1 <= a:\n            divisor <<= 1\n            power_of_2 <<= 1\n        a -= divisor\n        result += power_of_2\n    return a"
      ],
      [
        0.8921276330947876,
        "    return last_ten_digits(a * b)"
      ],
      [
        0.8912484645843506,
        "    if not b % a:\n        return 0"
      ],
      [
        0.8901526927947998,
        "    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n        while factorial % 10 == 0:\n            factorial //= 10\n        factorial %= 1000000000\n    return factorial % 10"
      ],
      [
        0.8901399374008179,
        "    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n        while factorial % 10 == 0:\n            factorial //= 10\n        factorial %= 1000000000\n    return factorial % 10"
      ],
      [
        0.8894123435020447,
        "    if a > b:\n        return findGCD(a - b, b)"
      ],
      [
        0.8885712027549744,
        "    if a > b:\n        return gcf(a - b, b)"
      ]
    ],
    "MBPP/37": [
      [
        0.8925512433052063,
        "    odd_set = set()\n    for num in lst:\n        if num % 2 != 0:\n            odd_set.add(num)\n    return list(odd_set)"
      ],
      [
        0.892090380191803,
        "    odd_nums = [num for num in arr if num % 2 == 1]\n    return odd_nums"
      ],
      [
        0.8915214538574219,
        "    odd_nums = []\n    for num in nums:\n        if num % 2 != 0:\n            odd_nums.append(num)\n    return odd_nums"
      ],
      [
        0.8896796703338623,
        "    odd_arr = []\n    for num in arr:\n        if num % 2 != 0:\n            odd_arr.append(num)\n    return odd_arr"
      ],
      [
        0.8893517255783081,
        "    odd_arr = []\n    for num in arr:\n        if num % 2 == 1:\n            odd_arr.append(num)\n    return odd_arr"
      ],
      [
        0.8893333673477173,
        "    odd_list = []\n    for number in original_list:\n        if number % 2 != 0:\n            odd_list.append(number)\n    return odd_list"
      ],
      [
        0.8886145949363708,
        "    oddNums = []\n    for num in nums:\n        if num % 2 == 1:\n            oddNums.append(num)\n    return oddNums"
      ],
      [
        0.8876538276672363,
        "    odds = []\n    for num in arr:\n        if num % 2 != 0:\n            odds.append(num)\n    return odds"
      ],
      [
        0.8876150250434875,
        "    odd_nums = []\n    for i in arr:\n        if i % 2 != 0:\n            odd_nums.append(i)\n    return odd_nums"
      ],
      [
        0.8871062994003296,
        "    odd_nums = []\n    for num in numbers:\n        if num % 2 == 1:\n            odd_nums.append(num)\n    return odd_nums"
      ]
    ],
    "MBPP/38": [
      [
        0.8894197940826416,
        "    output_list = []\n    for element in input_list:\n        try:\n            output_list.append(element[index])\n        except IndexError:\n            output_list.append('')\n    return output_list"
      ],
      [
        0.8890827298164368,
        "    for element in input_list:\n        try:\n            output_list.append(element[index])\n        except IndexError:\n            output_list.append('')"
      ],
      [
        0.8844093680381775,
        "    if len(my_list) < n:\n        return 'Error: List contains less than n elements'\n    elif isinstance(my_list[0], list):\n        return [x[2] for x in my_list if len(x) >= 3]\n    else:\n        return my_list[2]"
      ],
      [
        0.8844093680381775,
        "    if len(my_list) < n:\n        return 'Error: List contains less than n elements'\n    elif isinstance(my_list[0], list):\n        return [x[2] for x in my_list if len(x) >= 3]\n    else:\n        return my_list[2]"
      ],
      [
        0.8810790777206421,
        "    extracted_elements = []\n    for i in range(3):\n        extracted_elements.append(lst[i])\n    return extracted_elements"
      ],
      [
        0.8807437419891357,
        "    for sublist in input_list:\n        if len(sublist) >= 1:\n            first_list.append(sublist[0])\n            if len(sublist) >= 2:\n                second_list.append(sublist[1])"
      ],
      [
        0.8793918490409851,
        "    first_list = []\n    second_list = []\n    for sublist in input_list:\n        if len(sublist) >= 1:\n            first_list.append(sublist[0])\n            if len(sublist) >= 2:\n                second_list.append(sublist[1])\n    return [first_list, second_list]"
      ],
      [
        0.8777686357498169,
        "    column_index = t[1]\n    column_values = [row[column_index] for row in grid]\n    return column_values"
      ],
      [
        0.8760937452316284,
        "                if all((elem == first for elem in sub_list)):\n                    result.append(first)\n                else:\n                    result.append(None)"
      ],
      [
        0.8752939701080322,
        "    getter = itemgetter(*indices)\n    items = list(getter(items_all))\n    return items"
      ]
    ],
    "MBPP/39": [
      [
        0.9017757177352905,
        "    min_value = min(list1)\n    return min_value"
      ],
      [
        0.893377423286438,
        "    shortest_words = []\n    min_length = len(words_list[0])\n    for word in words_list:\n        if len(word) < min_length:\n            min_length = len(word)\n            shortest_words = [word]\n        elif len(word) == min_length:\n            shortest_words.append(word)\n    return shortest_words"
      ],
      [
        0.8909814953804016,
        "    shortest = input_list[0]\n    for word in input_list:\n        if len(word) < len(shortest):\n            shortest = word\n    return shortest"
      ],
      [
        0.8880941867828369,
        "    min_length = min((len(city) for city in cities))\n    shortest_cities = [city for city in cities if len(city) == min_length]\n    return shortest_cities"
      ],
      [
        0.8876590728759766,
        "    min_length = len(strings[0])\n    shortest_string = strings[0]\n    for string in strings[1:]:\n        if len(string) < min_length:\n            min_length = len(string)\n            shortest_string = string\n    return shortest_string"
      ],
      [
        0.8866062164306641,
        "    min_val = list[0]\n    for num in list:\n        if num < min_val:\n            min_val = num\n    return min_val"
      ],
      [
        0.8866005539894104,
        "    min_val = list[0]\n    for num in list:\n        if num < min_val:\n            min_val = num\n    return min_val"
      ],
      [
        0.8856693506240845,
        "    input_list = list(set(input_list))\n    return find_min(input_list)"
      ],
      [
        0.8853512406349182,
        "    if len(lst) == 1:\n        return lst[0]\n    else:\n        return min(lst[0], find_minimum(lst[1:]))"
      ],
      [
        0.8853512406349182,
        "    if len(lst) == 1:\n        return lst[0]\n    else:\n        return min(lst[0], find_minimum(lst[1:]))"
      ]
    ],
    "MBPP/40": [
      [
        0.9217349886894226,
        "    if side1 == side2 == side3:\n        print('Equilateral triangle')\n        return"
      ],
      [
        0.9198529720306396,
        "    if a == b and b == c:\n        return 'Equilateral triangle'"
      ],
      [
        0.9183226227760315,
        "    if a == b == c:\n        return 'Equilateral triangle'"
      ],
      [
        0.9124480485916138,
        "        if a == b == c and a != 0:\n            return 'Equilateral'"
      ],
      [
        0.912250280380249,
        "    if a == b == c:\n        triangle_type = 'Equilateral'\n    elif a != b and b != c and (a != c):\n        triangle_type = 'Scalene'\n    else:\n        triangle_type = 'Isosceles'"
      ],
      [
        0.9073838591575623,
        "        if a == b == c:\n            triangle_type = 'Equilateral'\n        elif a == b or b == c or c == a:\n            triangle_type = 'Isosceles'\n        else:\n            triangle_type = 'Scalene'"
      ],
      [
        0.9073770046234131,
        "        if a == b == c:\n            triangle_type = 'Equilateral'\n        elif a == b or b == c or c == a:\n            triangle_type = 'Isosceles'\n        else:\n            triangle_type = 'Scalene'"
      ],
      [
        0.9058823585510254,
        "    if a == b and b == c:\n        return 'Equilateral triangle'\n    elif a == b or b == c or a == c:\n        return 'Isosceles triangle'\n    else:\n        return 'Scalene triangle'"
      ],
      [
        0.9053143262863159,
        "    if A == B and B == C:\n        return 'Equilateral Triangle'\n    elif A == B or B == C or A == C:\n        return 'Isosceles Triangle'\n    else:\n        return 'Scalene Triangle'"
      ],
      [
        0.9053143262863159,
        "    if A == B and B == C:\n        return 'Equilateral Triangle'\n    elif A == B or B == C or A == C:\n        return 'Isosceles Triangle'\n    else:\n        return 'Scalene Triangle'"
      ]
    ],
    "MBPP/41": [
      [
        0.9049040675163269,
        "    areas = []\n    for p in parallelograms:\n        angle_in_radians = math.radians(p[2])\n        area = p[0] * p[1] * math.sin(angle_in_radians)\n        areas.append(area)\n    return areas"
      ],
      [
        0.9048106670379639,
        "    assert calculate_area(6, 4) == 12\n    assert calculate_area(6, 4, shape='parallelogram') == 24"
      ],
      [
        0.9044114351272583,
        "    if x <= 0 or y <= 0 or x >= y or (angle <= 0) or (angle >= 180):\n        raise ValueError('Invalid parameters for a parallelogram')\n    return x * y * math.sin(math.radians(angle))"
      ],
      [
        0.8989388942718506,
        "    for p in parallelograms:\n        angle_in_radians = math.radians(p[2])\n        area = p[0] * p[1] * math.sin(angle_in_radians)\n        areas.append(area)"
      ],
      [
        0.8930141925811768,
        "    area = length * width\n    return area"
      ],
      [
        0.8930042386054993,
        "    area = length * width\n    return area"
      ],
      [
        0.892493486404419,
        "    area = 0.5 * side_a * side_b\n    return area"
      ]
    ],
    "MBPP/42": [
      [
        0.922330379486084,
        "    if len(string) < 2:\n        return False\n    return string[0] == string[-1]"
      ],
      [
        0.9089089035987854,
        "    output_list = []\n    for string in input_list:\n        if string[0] == string[-1]:\n            output_list.append(string)\n    return output_list"
      ],
      [
        0.9089089035987854,
        "    output_list = []\n    for string in input_list:\n        if string[0] == string[-1]:\n            output_list.append(string)\n    return output_list"
      ],
      [
        0.9061794877052307,
        "    word_list = my_string.split()\n    for word in word_list:\n        if word[0] != word[-1]:\n            return False\n    return True"
      ],
      [
        0.903364360332489,
        "    my_string = ''.join((char for char in input_str if char not in string.punctuation))\n    words = my_string.split()\n    count = 0\n    for word in words:\n        if word[0].lower() == word[-1].lower():\n            count += 1\n    return (count == len(words), count)"
      ],
      [
        0.9027965068817139,
        "    for string in input_list:\n        if string[0] == string[-1]:\n            output_list.append(string)"
      ],
      [
        0.9027780294418335,
        "    for string in input_list:\n        if string[0] == string[-1]:\n            output_list.append(string)"
      ],
      [
        0.9016807675361633,
        "    elif str[0] == str[-1]:\n        return isAnagram(str[1:-1])\n    else:\n        return False"
      ],
      [
        0.900642454624176,
        "    elif word[0] == word[-1]:\n        return palindrome_check(word[1:-1])\n    else:\n        return False"
      ],
      [
        0.9006321430206299,
        "    elif word[0] == word[-1]:\n        return palindrome_check(word[1:-1])\n    else:\n        return False"
      ]
    ],
    "MBPP/43": [],
    "MBPP/44": [
      [
        0.9034754037857056,
        "        for i in range(n):\n            term = a * r ** i\n            print(term)"
      ],
      [
        0.9034656286239624,
        "        for i in range(n):\n            term = a * r ** i\n            print(term)"
      ],
      [
        0.9023756384849548,
        "    geometric_sequence = [first_term]\n    for _ in range(1, total_terms):\n        next_term = geometric_sequence[-1] * common_ratio\n        geometric_sequence.append(next_term)\n    return geometric_sequence"
      ],
      [
        0.9023408889770508,
        "    geometric_sequence = [first_term]\n    for _ in range(1, total_terms):\n        next_term = geometric_sequence[-1] * common_ratio\n        geometric_sequence.append(next_term)\n    return geometric_sequence"
      ],
      [
        0.8968919515609741,
        "    for _ in range(1, total_terms):\n        next_term = geometric_sequence[-1] * common_ratio\n        geometric_sequence.append(next_term)"
      ],
      [
        0.8968838453292847,
        "    for _ in range(1, total_terms):\n        next_term = geometric_sequence[-1] * common_ratio\n        geometric_sequence.append(next_term)"
      ],
      [
        0.8851804733276367,
        "    sum = a * (1 - r ** n) / (1 - r)\n    if 300 <= sum <= 1200:\n        print(f'Sum of geometric progression: {sum}.')\n        print('Terms of geometric progression:')\n        for i in range(n):\n            term = a * r ** i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of geometric progression is not within valid range, but {sum}.')"
      ],
      [
        0.8849542737007141,
        "    sum = a * (1 - r ** n) / (1 - r)\n    if 300 <= sum <= 1200:\n        print(f'The sum of the geometric progression is: {sum}.')\n        print('Terms of the geometric progression:')\n        for i in range(n):\n            term = a * r ** i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of the geometric progression is not within the valid range, but {sum}.')"
      ],
      [
        0.8837755918502808,
        "    total_sum = 0\n    for i in range(n):\n        total_sum += a * r ** i\n    return total_sum"
      ],
      [
        0.8836991786956787,
        "    gp = [a]\n    for i in range(1, n):\n        gp.append(gp[-1] * r)\n    return gp"
      ]
    ],
    "MBPP/45": [
      [
        0.9209355115890503,
        "    if num == reverse:\n        return True\n    else:\n        return False"
      ],
      [
        0.9153075218200684,
        "    if rev == num:\n        return True\n    else:\n        return False"
      ],
      [
        0.9153075218200684,
        "    if rev == num:\n        return True\n    else:\n        return False"
      ],
      [
        0.915286123752594,
        "    if rev == num:\n        return True\n    else:\n        return False"
      ],
      [
        0.9152277708053589,
        "    temp = num\n    rev = 0\n    while temp > 0:\n        rev = rev * 10 + temp % 10\n        temp = temp // 10\n    if rev == num:\n        return True\n    else:\n        return False"
      ],
      [
        0.91518235206604,
        "    if num == rev:\n        return True\n    else:\n        return False"
      ],
      [
        0.9151732921600342,
        "    if num == rev:\n        return True\n    else:\n        return False"
      ],
      [
        0.9149579405784607,
        "    rev = n[::-1]\n    return n == rev"
      ],
      [
        0.9147549867630005,
        "    x = n\n    rev = 0\n    while x > 0:\n        dig = x % 10\n        rev = rev * 10 + dig\n        x = x // 10\n    if n == rev:\n        return True\n    else:\n        return False"
      ],
      [
        0.9147495031356812,
        "    temp = num\n    rev = 0\n    while temp > 0:\n        rev = rev * 10 + temp % 10\n        temp = temp // 10\n    if num == rev:\n        return True\n    else:\n        return False"
      ]
    ],
    "MBPP/46": [
      [
        0.9051604866981506,
        "    for i in digits:\n        largest = largest * 10 + i"
      ],
      [
        0.8984189033508301,
        "    largest_number = ''\n    for number in arr:\n        largest_number += str(number)\n    return int(largest_number)"
      ]
    ],
    "MBPP/47": [
      [
        0.9036495089530945,
        "    if abs(x) == abs(y):\n        return True\n    else:\n        return False"
      ],
      [
        0.9036495089530945,
        "    if abs(x) == abs(y):\n        return True\n    else:\n        return False"
      ],
      [
        0.8956394791603088,
        "    if num1 ^ num2 >= 0:\n        if abs_num1 > abs_num2:\n            return 1\n        elif abs_num1 < abs_num2:\n            return -1\n        else:\n            return 0\n    elif num1 < 0:\n        return 1\n    else:\n        return -1"
      ],
      [
        0.8952537775039673,
        "    elif num1 < 0:\n        return 1\n    else:\n        return -1"
      ],
      [
        0.8936898708343506,
        "    abs_num1 = abs(num1)\n    abs_num2 = abs(num2)\n    if num1 ^ num2 >= 0:\n        if abs_num1 > abs_num2:\n            return 1\n        elif abs_num1 < abs_num2:\n            return -1\n        else:\n            return 0\n    elif num1 < 0:\n        return 1\n    else:\n        return -1"
      ],
      [
        0.8887724876403809,
        "    if num1 < 0 or num2 < 0:\n        raise ValueError('Input numbers cannot be negative.')\n    if num1 % 2 == 0 and num2 % 2 != 0:\n        return True\n    else:\n        return False"
      ],
      [
        0.8846558332443237,
        "        if num1 > num2:\n            return '1'\n        elif num1 < num2:\n            return '-1'"
      ],
      [
        0.8844513297080994,
        "    return (x >= 0) == (y >= 0)"
      ],
      [
        0.8844330310821533,
        "    return (x >= 0) == (y >= 0)"
      ],
      [
        0.8839975595474243,
        "    diff = a - b\n    if diff == 0:\n        return True\n    else:\n        return False"
      ]
    ],
    "MBPP/48": [
      [
        0.9015012979507446,
        "        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4"
      ],
      [
        0.9014909267425537,
        "        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4"
      ],
      [
        0.8902581930160522,
        "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"
      ],
      [
        0.8902581930160522,
        "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"
      ],
      [
        0.890254020690918,
        "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"
      ],
      [
        0.890254020690918,
        "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"
      ],
      [
        0.8891839385032654,
        "    if n in memory:\n        return memory[n]\n    if n < 1 or n > 1000 or (not isinstance(n, int)):\n        return 'Invalid input'\n    elif n == 1:\n        return 1\n    else:\n        memory[n] = n * (7 * n - 5) // 2\n        return nonagonal(n - 1, memory)"
      ],
      [
        0.8891648054122925,
        "    if n in memory:\n        return memory[n]\n    if n < 1 or n > 1000 or (not isinstance(n, int)):\n        return 'Invalid input'\n    elif n == 1:\n        return 1\n    else:\n        memory[n] = n * (7 * n - 5) // 2\n        return nonagonal(n - 1, memory)"
      ],
      [
        0.8886972069740295,
        "    if type(n) != int or n < 0:\n        return 'ERROR: Invalid Input'\n    if n > 5000:\n        return 'ERROR: Input number too large'\n    if n in computed:\n        return computed[n]\n    computed[n] = n * (5 * n - 3) / 2 + heptagonal(n - 1)\n    return computed[n]"
      ],
      [
        0.8886882066726685,
        "    if n < 1 or n > 1000 or (not isinstance(n, int)):\n        return 'Invalid input'\n    elif n == 1:\n        return 1\n    else:\n        memory[n] = n * (7 * n - 5) // 2\n        return nonagonal(n - 1, memory)"
      ]
    ],
    "MBPP/49": [
      [
        0.9034944772720337,
        "    dp = {}\n    maxLength = 0\n    for num in arr:\n        dp[num] = dp.get(num - difference, 0) + 1\n        maxLength = max(maxLength, dp[num])\n    return maxLength"
      ],
      [
        0.9034719467163086,
        "    dp = {}\n    maxLength = 0\n    for num in arr:\n        dp[num] = dp.get(num - difference, 0) + 1\n        maxLength = max(maxLength, dp[num])\n    return maxLength"
      ],
      [
        0.9019003510475159,
        "    arr = sorted(arr)\n    max_length = 1\n    length = 1\n    for i in range(len(arr) - 1):\n        if arr[i] + 1 == arr[i + 1]:\n            length = length + 1\n        else:\n            if length > max_length:\n                max_length = length\n            length = 1\n    return max_length"
      ],
      [
        0.9007587432861328,
        "    max_length = 0\n    length = 0\n    for i in range(len(arr) - 1):\n        if arr[i + 1] == arr[i] + 1:\n            length += 1\n        else:\n            max_length = max(max_length, length)\n            length = 0\n    return max(max_length, length) + 1"
      ],
      [
        0.9002622365951538,
        "    max_length = 0\n    cur_length = 1\n    for i in range(len(arr) - 1):\n        if arr[i] + 1 == arr[i + 1]:\n            cur_length += 1\n        else:\n            if cur_length > max_length:\n                max_length = cur_length\n            cur_length = 1\n    if cur_length > max_length:\n        max_length = cur_length\n    return max_length"
      ],
      [
        0.8999264240264893,
        "    max_length = 0\n    start_index = 0\n    while start_index < len(arr) - 1 and arr[start_index] + 1 == arr[start_index + 1]:\n        start_index += 1\n    for i in range(start_index + 1, len(arr)):\n        prev = arr[i - 1]\n        curr = arr[i]\n        if prev + 1 == curr:\n            length = i - start_index + 1\n            if length > max_length:\n                max_length = length\n        else:\n            start_index = i\n    return max_length"
      ],
      [
        0.8992247581481934,
        "    for i in range(len(arr) - 1):\n        if arr[i + 1] == arr[i] + 1:\n            length += 1\n        else:\n            max_length = max(max_length, length)\n            length = 0"
      ],
      [
        0.8988118171691895,
        "    max_diff = 0\n    for i in range(0, len(arr) - 1):\n        diff = arr[i + 1] - arr[i]\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff"
      ],
      [
        0.8984203338623047,
        "    cur_length = 1\n    max_length = 1\n    for i in range(1, len(arr)):\n        if arr[i] - 1 == arr[i - 1]:\n            cur_length += 1\n        else:\n            if cur_length > max_length:\n                max_length = cur_length\n            cur_length = 1\n    if cur_length > max_length:\n        max_length = cur_length\n    return max_length"
      ],
      [
        0.8977590799331665,
        "        if arr[i + 1] == arr[i] + 1:\n            length += 1\n        else:\n            max_length = max(max_length, length)\n            length = 0"
      ]
    ],
    "MBPP/50": [
      [
        0.8965426087379456,
        "    count = 0\n    for num in range(start, end + 1):\n        count += str(num).count(str(digit))\n    return count"
      ]
    ],
    "MBPP/51": [
      [
        0.9316339492797852,
        "    smallest_number = num_list[0]\n    for num in num_list:\n        if num < smallest_number:\n            smallest_number = num\n    return smallest_number"
      ],
      [
        0.931399941444397,
        "    smallest = list[0]\n    i = 1\n    while i < len(list):\n        if list[i] < smallest:\n            smallest = list[i]\n        i += 1\n    return smallest"
      ],
      [
        0.9273426532745361,
        "    smallest = lst[0]\n    for number in lst:\n        if number < smallest:\n            smallest = number\n    return smallest"
      ],
      [
        0.9261994361877441,
        "    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest"
      ],
      [
        0.9243289828300476,
        "    smallest = givenList[0]\n    for num in givenList[1:]:\n        if num < smallest:\n            smallest = num\n    return smallest"
      ],
      [
        0.9239944219589233,
        "    smallest_number = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < smallest_number:\n            smallest_number = arr[i]\n    return smallest_number"
      ],
      [
        0.9239901900291443,
        "    smallest_number = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < smallest_number:\n            smallest_number = arr[i]\n    return smallest_number"
      ],
      [
        0.9229352474212646,
        "    smallest = float('inf')\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest"
      ],
      [
        0.9228798747062683,
        "    n = len(arr)\n    smallest = arr[0]\n    for i in range(1, n):\n        if arr[i] < smallest:\n            smallest = arr[i]\n    return smallest"
      ],
      [
        0.9226624369621277,
        "    smallest = arr[0]\n    for num in arr:\n        smallest = min(smallest, num)\n    return smallest"
      ]
    ],
    "MBPP/52": [
      [
        0.906682550907135,
        "    maxDifference = 0\n    for i in range(len(elementList)):\n        for j in range(i + 1, len(elementList)):\n            if elementList[j] - elementList[i] > maxDifference:\n                maxDifference = elementList[j] - elementList[i]\n    return maxDifference"
      ],
      [
        0.9037089347839355,
        "    maxDifference = 0\n    maxDifferencePair = ()\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            difference = abs(arr[i] - arr[j])\n            if difference > maxDifference:\n                maxDifference = difference\n                maxDifferencePair = (arr[i], arr[j])\n    return maxDifferencePair"
      ],
      [
        0.8991773128509521,
        "    max_difference = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] - arr[i] > max_difference:\n                max_difference = arr[j] - arr[i]\n    return max_difference"
      ],
      [
        0.8981812000274658,
        "    if not arr:\n        return\n    min_el = arr[0]\n    max_diff = arr[1] - arr[0]\n    pair = (arr[0], arr[1])\n    for i in range(1, len(arr)):\n        if arr[i] < min_el:\n            min_el = arr[i]\n        elif arr[i] - min_el > max_diff:\n            max_diff = arr[i] - min_el\n            pair = (min_el, arr[i])\n    return (max_diff, pair)"
      ],
      [
        0.8950934410095215,
        "    for i in range(len(elementList)):\n        for j in range(i + 1, len(elementList)):\n            if elementList[j] - elementList[i] > maxDifference:\n                maxDifference = elementList[j] - elementList[i]"
      ]
    ],
    "MBPP/53": [
      [
        0.9126307368278503,
        "    sorted_list = sorted(tuples, key=lambda x: x[1])\n    return sorted_list"
      ],
      [
        0.9110075831413269,
        "    sorted_list = sorted(tuples, key=lambda tup: tup[1])\n    return sorted_list"
      ],
      [
        0.906570553779602,
        "    sorted_list = sorted(tuples_list, key=lambda x: x[0])\n    return sorted_list"
      ]
    ],
    "MBPP/54": [],
    "MBPP/55": [
      [
        0.9301419258117676,
        "    positive_numbers = 0\n    for num in input_numbers:\n        if num > 0:\n            positive_numbers += 1\n    return positive_numbers"
      ],
      [
        0.9274849891662598,
        "    count = 0\n    for num in nums:\n        if num > 0:\n            count += 1\n    print('Number of positive numbers:', count)"
      ],
      [
        0.9153268337249756,
        "    count = 0\n    for num in numbers:\n        if num > 0:\n            count += 1\n    return count"
      ],
      [
        0.9085139632225037,
        "    result = 0\n    for num in numbers:\n        if num > 0:\n            result += 1\n    return result"
      ],
      [
        0.9078720808029175,
        "    positive_integers = []\n    for num in input_list:\n        if num > 0:\n            positive_integers.append(num)\n    return positive_integers"
      ],
      [
        0.907593309879303,
        "    count = 0\n    for i in arr:\n        if i > 0:\n            count += 1\n    return count"
      ],
      [
        0.9057207107543945,
        "    for num in numbers:\n        if num > 0:\n            count += 1"
      ],
      [
        0.9056857824325562,
        "    for num in input_list:\n        if num > 0:\n            positive_list.append(num)"
      ],
      [
        0.9054811000823975,
        "    positive_nums = []\n    for n in lst:\n        if n > 0:\n            positive_nums.append(n)\n    return positive_nums"
      ],
      [
        0.9047286510467529,
        "    input_list = [1, -2, 3, -4, 5]\n    expected_output = [1, 3, 5]\n    assert positive(input_list) == expected_output"
      ]
    ],
    "MBPP/56": [
      [
        0.888710618019104,
        "    for j in range(1, i + 1):\n        bell_matrix[i][j] = bell_matrix[i - 1][j - 1] + bell_matrix[i][j - 1]"
      ],
      [
        0.888710618019104,
        "    for j in range(1, i + 1):\n        bell_matrix[i][j] = bell_matrix[i - 1][j - 1] + bell_matrix[i][j - 1]"
      ],
      [
        0.8870828747749329,
        "    for i in range(1, n + 1):\n        bell_matrix[i][0] = bell_matrix[i - 1][i - 1]"
      ],
      [
        0.8870828747749329,
        "    for i in range(1, n + 1):\n        bell_matrix[i][0] = bell_matrix[i - 1][i - 1]"
      ],
      [
        0.886833667755127,
        "        for j in range(1, i + 1):\n            bell_matrix[i][j] = bell_matrix[i - 1][j - 1] + bell_matrix[i][j - 1]"
      ],
      [
        0.886833667755127,
        "        for j in range(1, i + 1):\n            bell_matrix[i][j] = bell_matrix[i - 1][j - 1] + bell_matrix[i][j - 1]"
      ],
      [
        0.8846511244773865,
        "        for j in range(1, i + 1):\n            Bell[i][j] = Bell[i - 1][j] + Bell[i][j - 1]"
      ],
      [
        0.8846511244773865,
        "        for j in range(1, i + 1):\n            Bell[i][j] = Bell[i - 1][j] + Bell[i][j - 1]"
      ],
      [
        0.8834362030029297,
        "        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]"
      ],
      [
        0.8834362030029297,
        "        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]"
      ]
    ],
    "MBPP/57": [
      [
        0.9142146110534668,
        "    is_monotonic = True\n    for i in range(len(list) - 1):\n        if list[i] > list[i + 1]:\n            is_monotonic = False\n    return is_monotonic"
      ],
      [
        0.9073672294616699,
        "    for i in range(len(list) - 1):\n        if list[i] > list[i + 1]:\n            is_monotonic = False"
      ],
      [
        0.9044870138168335,
        "    try:\n        is_nested = any((isinstance(i, list) for i in l))\n    except TypeError:\n        print('Input value is not iterable')\n        return False\n    if is_nested:\n        return all((monotonic(sub_list, strict) for sub_list in l))\n    elif strict:\n        return all((i < j for i, j in zip(l, l[1:]))) or all((i > j for i, j in zip(l, l[1:])))\n    else:\n        return all((i <= j for i, j in zip(l, l[1:]))) or all((i >= j for i, j in zip(l, l[1:])))"
      ],
      [
        0.9023445844650269,
        "    length = len(array)\n    if length <= 1:\n        return True\n    difference = array[length - 1] - array[0]\n    if difference >= 0:\n        is_ascending = True\n    else:\n        is_ascending = False\n    for i in range(1, length):\n        difference = array[i] - array[i - 1]\n        if difference > 0 and (not is_ascending) or (difference < 0 and is_ascending):\n            return False\n    return True"
      ],
      [
        0.8974828720092773,
        "    status = False\n    check = arr[0]\n    for i in range(1, len(arr)):\n        if check < arr[i]:\n            check = arr[i]\n            status = True\n        else:\n            status = False\n            break\n    return status"
      ],
      [
        0.8939199447631836,
        "        if list[i] > list[i + 1]:\n            is_monotonic = False"
      ],
      [
        0.8931002616882324,
        "    if is_nested:\n        return all((monotonic(sub_list, strict) for sub_list in l))\n    elif strict:\n        return all((i < j for i, j in zip(l, l[1:]))) or all((i > j for i, j in zip(l, l[1:])))\n    else:\n        return all((i <= j for i, j in zip(l, l[1:]))) or all((i >= j for i, j in zip(l, l[1:])))"
      ],
      [
        0.8929349184036255,
        "    n = len(arr)\n    if all((arr[i] <= arr[i + 1] for i in range(n - 1))):\n        return True\n    else:\n        return False"
      ],
      [
        0.8897340297698975,
        "    if not arr:\n        return True\n    prev_el = arr[0]\n    for el in arr[1:]:\n        if el < prev_el:\n            return False\n        prev_el = el\n    return True"
      ],
      [
        0.889224112033844,
        "    n = len(arr)\n    for i in range(1, n):\n        if arr[i] < arr[i - 1]:\n            return False\n    return True"
      ]
    ],
    "MBPP/58": [
      [
        0.9234124422073364,
        "    if isinstance(sublist, list):\n        if sublist == []:\n            return True\n        elif sublist == main_list:\n            return True\n        elif len(sublist) > len(main_list):\n            return False\n        else:\n            for i in range(len(main_list)):\n                if main_list[i] == sublist[0]:\n                    return is_sublist(main_list[i + 1:], sublist[1:])\n            return False\n    else:\n        return sublist in main_list"
      ],
      [
        0.9234124422073364,
        "    if isinstance(sublist, list):\n        if sublist == []:\n            return True\n        elif sublist == main_list:\n            return True\n        elif len(sublist) > len(main_list):\n            return False\n        else:\n            for i in range(len(main_list)):\n                if main_list[i] == sublist[0]:\n                    return is_sublist(main_list[i + 1:], sublist[1:])\n            return False\n    else:\n        return sublist in main_list"
      ],
      [
        0.9215701818466187,
        "        if sublist == []:\n            return True\n        elif sublist == main_list:\n            return True\n        elif len(sublist) > len(main_list):\n            return False\n        else:\n            for i in range(len(main_list)):\n                if main_list[i] == sublist[0]:\n                    return is_sublist(main_list[i + 1:], sublist[1:])\n            return False"
      ],
      [
        0.9211695194244385,
        "    for i in range(len(lst1) - len(sublst) + 1):\n        if lst1[i:i + len(sublst)] == sublst:\n            return True\n    return False"
      ],
      [
        0.9197482466697693,
        "    for i in range(len(lst1) - len(sublst) + 1):\n        if lst1[i:i + len(sublst)] == sublst:\n            return True"
      ],
      [
        0.9197253584861755,
        "        elif sublist == main_list:\n            return True\n        elif len(sublist) > len(main_list):\n            return False\n        else:\n            for i in range(len(main_list)):\n                if main_list[i] == sublist[0]:\n                    return is_sublist(main_list[i + 1:], sublist[1:])\n            return False"
      ],
      [
        0.9197019338607788,
        "    i, j = (0, 0)\n    n1, n2 = (len(sub_list), len(main_list))\n    while i < n1 and j < n2:\n        if sub_list[i] == main_list[j]:\n            i += 1\n        j += 1\n    return i == n1"
      ],
      [
        0.9195061922073364,
        "    str_lst = ''.join(map(str, lst))\n    str_sublist = ''.join(map(str, sublist))\n    return str_sublist in str_lst"
      ],
      [
        0.9163451790809631,
        "                if main_list[i] == sublist[0]:\n                    return is_sublist(main_list[i + 1:], sublist[1:])"
      ],
      [
        0.9150938391685486,
        "        elif len(sublist) > len(main_list):\n            return False\n        else:\n            for i in range(len(main_list)):\n                if main_list[i] == sublist[0]:\n                    return is_sublist(main_list[i + 1:], sublist[1:])\n            return False"
      ]
    ],
    "MBPP/59": [
      [
        0.9101132154464722,
        "    len_first = len(lst[0])\n    return all((len(x) == len_first for x in lst))"
      ],
      [
        0.9057382941246033,
        "    if not list_of_strings:\n        print('The list is empty.')\n    else:\n        string_length = len(list_of_strings[0])\n        all_equal_length = all((len(string) == string_length for string in list_of_strings))\n        if all_equal_length:\n            print('All strings in the list are of equal length.')\n        else:\n            print('Not all strings in the list are of equal length.')"
      ],
      [
        0.9057382941246033,
        "    if not list_of_strings:\n        print('The list is empty.')\n    else:\n        string_length = len(list_of_strings[0])\n        all_equal_length = all((len(string) == string_length for string in list_of_strings))\n        if all_equal_length:\n            print('All strings in the list are of equal length.')\n        else:\n            print('Not all strings in the list are of equal length.')"
      ],
      [
        0.9036808013916016,
        "    length = len(arr[0])\n    for n in arr:\n        if len(n) != length:\n            return False\n    return True"
      ],
      [
        0.9035951495170593,
        "    string_length = len(string_list[0])\n    for string in string_list:\n        if len(string) != string_length:\n            return False\n    return True"
      ],
      [
        0.9022980332374573,
        "        if all_equal_length:\n            print('All strings in the list are of equal length.')\n        else:\n            print('Not all strings in the list are of equal length.')"
      ],
      [
        0.8978866934776306,
        "    if not lst:\n        return True\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True"
      ],
      [
        0.8960908651351929,
        "    first_elem = arr[0]\n    is_equal = True\n    for elem in arr:\n        if elem != first_elem:\n            is_equal = False\n            break\n    return is_equal"
      ],
      [
        0.8955456018447876,
        "    if len(arr) == 0:\n        return False\n    return all((arr[0] == x for x in arr))"
      ],
      [
        0.8934072256088257,
        "    if len(lst) == 0:\n        return False\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True"
      ]
    ],
    "MBPP/60": [],
    "MBPP/61": [
      [
        0.9086328744888306,
        "    root = int(sqrt(n))\n    return n == root * root"
      ],
      [
        0.906577467918396,
        "    square_root = int(num ** 0.5)\n    return square_root * square_root == num"
      ],
      [
        0.9064910411834717,
        "    for i in range(0, int(n ** 0.5) + 1):\n        for j in range(i, int(n ** 0.5) + 1):\n            if i * i + j * j == n:\n                return True\n    return False"
      ],
      [
        0.9059733152389526,
        "    for i in range(int(math.sqrt(n)) + 1):\n        if math.isqrt(n - i * i) ** 2 == n - i * i:\n            return True"
      ],
      [
        0.905969500541687,
        "    for i in range(int(math.sqrt(n)) + 1):\n        if math.isqrt(n - i * i) ** 2 == n - i * i:\n            return True\n    return False"
      ],
      [
        0.9058382511138916,
        "    root = int(n ** 0.5)\n    return n == root * root"
      ],
      [
        0.9058364629745483,
        "    square_root = math.sqrt(n)\n    return square_root.is_integer()"
      ],
      [
        0.9058330059051514,
        "    for i in range(0, int(math.sqrt(n)) + 1):\n        for j in range(0, int(math.sqrt(n)) + 1):\n            if i * i + j * j == n:\n                return True\n    return False"
      ],
      [
        0.9058234691619873,
        "    root = int(n ** 0.5)\n    return n == root * root"
      ],
      [
        0.905735433101654,
        "    root = math.sqrt(n)\n    return n == int(root + 0.5) ** 2"
      ]
    ],
    "MBPP/62": [
      [
        0.9141456484794617,
        "    pattern = re.compile(delimiter, re.IGNORECASE)\n    return pattern.split(my_string)"
      ],
      [
        0.9129692316055298,
        "    return re.split('|'.join(map(re.escape, delimiters)), s)"
      ],
      [
        0.9129440784454346,
        "    return re.split('|'.join(map(re.escape, delimiters)), s)"
      ],
      [
        0.9106648564338684,
        "    result = []\n    delimiter_stack = []\n    current_word = ''\n    for char in string:\n        if char in delimiters:\n            if not delimiter_stack:\n                result.append(current_word)\n                current_word = ''\n            else:\n                current_word += char\n        else:\n            current_word += char\n        if char in delimiters:\n            delimiter_stack.append(char)\n        elif delimiter_stack and char == delimiter_stack[-1]:\n            delimiter_stack.pop()\n    result.append(current_word)\n    return result"
      ],
      [
        0.9091101884841919,
        "    return string.split(delimiter)"
      ],
      [
        0.9091071486473083,
        "    return string.split(delimiter)"
      ],
      [
        0.9091071486473083,
        "    return string.split(delimiter)"
      ],
      [
        0.9090888500213623,
        "    return string.split(delimiter)"
      ],
      [
        0.9090885519981384,
        "    return string.split(delimiter)"
      ],
      [
        0.9081543684005737,
        "    splits = string.split(delimiter)\n    final_splits = []\n    for s in splits:\n        split_substrings = re.split(regex_pattern, s)\n        split_substrings = [x for x in split_substrings if x]\n        final_splits.append(split_substrings)\n    return final_splits"
      ]
    ],
    "MBPP/63": [
      [
        0.8983497619628906,
        "    result = []\n    for string, pattern in patterns:\n        if re.search(pattern, string):\n            result.append(True)\n        else:\n            result.append(False)\n    return result"
      ],
      [
        0.89751136302948,
        "    if re.match(pattern, sequence):\n        return True\n    else:\n        return False"
      ],
      [
        0.8970226049423218,
        "    pattern = re.compile('abbccd')\n    match = pattern.match(sequence)\n    if match:\n        return True\n    return False"
      ],
      [
        0.896980345249176,
        "    pattern = re.compile('abbccd')\n    match = pattern.match(sequence)\n    if match:\n        return True\n    return False"
      ],
      [
        0.8924723863601685,
        "    for string, pattern in patterns:\n        if re.search(pattern, string):\n            result.append(True)\n        else:\n            result.append(False)"
      ],
      [
        0.8924547433853149,
        "    for pattern in patterns:\n        if code.count(pattern) > 1:\n            return False"
      ],
      [
        0.8924459218978882,
        "    for pattern in patterns:\n        if code.count(pattern) > 1:\n            return False"
      ],
      [
        0.8907196521759033,
        "    if pat.match(seq):\n        return True\n    else:\n        return False"
      ],
      [
        0.890075147151947,
        "    for pattern in patterns:\n        if pattern in input_string:\n            found_patterns.append(pattern)"
      ],
      [
        0.8882672190666199,
        "    found_patterns = []\n    for pattern in patterns:\n        if pattern in input_string:\n            found_patterns.append(pattern)\n    return found_patterns"
      ]
    ],
    "MBPP/64": [
      [
        0.9003798961639404,
        "    if not isinstance(k, int):\n        return \"Error: Argument 'k' should be an integer\"\n    if not all((isinstance(t, tuple) for t in tuples)):\n        return 'Error: All elements should be tuples'\n    indices = [i for i, t in enumerate(tuples) if k in t]\n    if not indices:\n        return f'No tuples found containing the number {k}'\n    return indices"
      ],
      [
        0.8977481126785278,
        "    multiples = []\n    for n in arr:\n        if n % num == 0:\n            multiples.append(n)\n    return multiples"
      ],
      [
        0.8973555564880371,
        "    multiples_dict = {}\n    for i in lst:\n        if i in multiples_dict:\n            multiples_dict[i] += 1\n        else:\n            multiples_dict[i] = 1\n    multiple_counts = {}\n    for element, count in multiples_dict.items():\n        if count % k == 0:\n            multiple_counts[element] = count // k\n    return multiple_counts"
      ],
      [
        0.8961057662963867,
        "    divisible_numbers = []\n    for num in numbers:\n        if num % divisor == 0:\n            divisible_numbers.append(num)\n    return divisible_numbers"
      ],
      [
        0.8960109949111938,
        "    if k == 0:\n        return 'Error: Division by zero is undefined'\n    count = 0\n    for i in arr:\n        if isinstance(i, list):\n            count += count_divisible_by_k(i, k)\n        elif isinstance(i, (int, float)):\n            if i % k == 0:\n                count += 1\n    return count"
      ],
      [
        0.8958995938301086,
        "    sublist = []\n    for element in lst:\n        if element > threshold and element % divisor == 0:\n            sublist.append(element)\n    return sublist"
      ],
      [
        0.8948439359664917,
        "    new_arr = []\n    for i in arr:\n        if i % divisor == 0:\n            new_arr.append(i)\n    return new_arr"
      ],
      [
        0.8935140371322632,
        "    elements = []\n    for i in arr:\n        if i % number == 0:\n            elements.append(i)\n    return elements"
      ],
      [
        0.8927046656608582,
        "    count = 0\n    if len(arr) == 0:\n        return count\n    for element in arr[0]:\n        if element % k == 0 and element % m == 1:\n            count += 1\n    return count + countDivisible(arr[1:], k, m)"
      ],
      [
        0.8925551176071167,
        "    filtered_list = []\n    for num in input_list:\n        if num % criteria == 0:\n            filtered_list.append(num)\n    return filtered_list"
      ]
    ],
    "MBPP/65": [
      [
        0.9050391912460327,
        "    x1, y1, x2, y2 = map(int, rect.split())\n    return (x2 - x1) * (y2 - y1)"
      ],
      [
        0.887770414352417,
        "    width = abs(x2 - x1)\n    height = abs(y2 - y1)\n    return width * height"
      ],
      [
        0.8871716260910034,
        "    length = abs(x2 - x1)\n    width = abs(y2 - y1)\n    return length * width"
      ],
      [
        0.8850581645965576,
        "    return [length * width for length, width in rectangle_pairs]"
      ],
      [
        0.8850499391555786,
        "    return [length * width for length, width in rectangle_pairs]"
      ],
      [
        0.8850207328796387,
        "    points = set()\n    for rectangle in coordinates:\n        for x in range(rectangle[0], rectangle[2]):\n            for y in range(rectangle[1], rectangle[3]):\n                points.add((x, y))\n    return len(points)"
      ],
      [
        0.8846858739852905,
        "    if r > l and b > t:\n        return (r - l) * (b - t)\n    else:\n        return 0"
      ],
      [
        0.8836591243743896,
        "    x1, y1 = rectangle[0]\n    x2, y2 = rectangle[1]\n    x3, y3 = rectangle[2]\n    x4, y4 = rectangle[3]\n    length = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    width = math.sqrt((x3 - x2) ** 2 + (y3 - y2) ** 2)\n    area = length * width\n    perimeter = 2 * (length + width)\n    return (area, perimeter)"
      ],
      [
        0.8827654719352722,
        "    area_sum = 0\n    for rectangle in rectangles:\n        area_sum += rectangle['length'] * rectangle['width']\n    return area_sum"
      ],
      [
        0.8809770345687866,
        "    squares = group.split()\n    total_area = sum((int(side) ** 2 for side in squares))\n    return total_area"
      ]
    ],
    "MBPP/66": [
      [
        0.8945975303649902,
        "    digits = [int(s) for s in string if s.isdigit()]\n    even_nums_sum = sum((d for d in digits if d % 2 == 0))\n    return (digits, even_nums_sum)"
      ],
      [
        0.8923784494400024,
        "        if int(digit) % 2 == 0:\n            even_sum += int(digit)\n            even_count += 1\n        else:\n            odd_sum += int(digit)\n            odd_count += 1"
      ],
      [
        0.8910857439041138,
        "        if int(digit) % 2 == 0:\n            even_count += 1\n            even_sum += int(digit)\n        else:\n            odd_count += 1\n            odd_sum += int(digit)"
      ],
      [
        0.8894226551055908,
        "    numList = calculateFibonacci(n, m)\n    oddSum, evenSum, oddCount, evenCount = (0, 0, 0, 0)\n    for num in numList:\n        if num % 2 != 0 and oddCount < n:\n            oddSum += num\n            oddCount += 1\n        elif num % 2 == 0 and evenCount < m:\n            evenSum += num\n            evenCount += 1\n    difference = abs(oddSum - evenSum)\n    return (oddSum, evenSum, difference)"
      ],
      [
        0.8889919519424438,
        "    diff = 0\n    evenSum = 0\n    for i in range(0, len(arr), 2):\n        evenSum += arr[i]\n    oddSum = 0\n    for i in range(1, len(arr), 2):\n        oddSum += arr[i]\n    diff = evenSum - oddSum\n    return abs(diff)"
      ],
      [
        0.8885011672973633,
        "    numbers = nums.split(',')\n    odd_numbers = []\n    even_numbers = []\n    for num in numbers:\n        if int(num) % 2 == 0:\n            even_numbers.append(int(num))\n        else:\n            odd_numbers.append(int(num))\n    sum_odd = sum(odd_numbers)\n    sum_even = sum(even_numbers)\n    if sum_odd > sum_even:\n        return sum_odd\n    else:\n        return sum_even"
      ],
      [
        0.8881651759147644,
        "    even_sum = 0\n    odd_sum = 0\n    for i in range(len(arr)):\n        if i % 2 == 0:\n            even_sum += arr[i]\n        else:\n            odd_sum += arr[i]\n    return abs(even_sum - odd_sum)"
      ],
      [
        0.8881614208221436,
        "    even_sum = 0\n    odd_sum = 0\n    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):\n        if int(digit) % 2 == 0:\n            even_sum += int(digit)\n            even_count += 1\n        else:\n            odd_sum += int(digit)\n            odd_count += 1\n    return {'even': {'sum': even_sum, 'count': even_count}, 'odd': {'sum': odd_sum, 'count': odd_count}}"
      ],
      [
        0.8879481554031372,
        "    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):\n        if digit.isdigit():\n            if int(digit) % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)"
      ]
    ],
    "MBPP/67": [
      [
        0.9048863649368286,
        "        if number & 1:\n            count += 1"
      ],
      [
        0.9024717807769775,
        "    count = 0\n    for n in arr:\n        if n % 2 == 1:\n            count += 1\n    return count"
      ],
      [
        0.901982307434082,
        "    odd_pairs = []\n    pair_count = 0\n    for i in range(len(lst) - 1):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) & 1:\n                pair_count += 1\n                odd_pairs.append((lst[i], lst[j]))\n    return (pair_count, odd_pairs)"
      ],
      [
        0.9019408822059631,
        "    odd_pairs = []\n    pair_count = 0\n    for i in range(len(lst) - 1):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) & 1:\n                pair_count += 1\n                odd_pairs.append((lst[i], lst[j]))\n    return (pair_count, odd_pairs)"
      ],
      [
        0.8993247747421265,
        "    limit = int(log2(n))\n    cnt = 0\n    for i in range(limit, -1, -1):\n        j = n - (1 << i)\n        if j < i:\n            break\n        cnt += sum_odd(min(i, j - i)) - sum_odd(i // 2)\n        cnt += sum_even(min(i - 1, j - i)) - sum_even((i - 1) // 2)\n    return cnt"
      ],
      [
        0.8984699845314026,
        "    count = 0\n    for i in range(len(arr)):\n        if arr[i] % 2 != 0:\n            count = count + 1\n    return count"
      ],
      [
        0.897388219833374,
        "        if n & 1:\n            count += 1"
      ],
      [
        0.8968019485473633,
        "    count = 0\n    for num in arr:\n        if num % 2 != 0:\n            count += 1\n    return count"
      ],
      [
        0.8967719078063965,
        "    for n in arr:\n        if n % 2 == 1:\n            count += 1"
      ],
      [
        0.8967653512954712,
        "        if bitwise_and & 1:\n            count += 1"
      ]
    ],
    "MBPP/68": [
      [
        0.9106627702713013,
        "    if len(string) % 2 == 0:\n        print('The string is even.')\n    else:\n        print('The string is odd.')"
      ],
      [
        0.9106627702713013,
        "    if len(string) % 2 == 0:\n        print('The string is even.')\n    else:\n        print('The string is odd.')"
      ]
    ],
    "MBPP/69": [
      [
        0.9239391684532166,
        "    if n < 0:\n        return 'Input must be a non-negative integer.'\n    tetra_list = [1, 4, 2, 6]\n    for i in range(4, n + 1):\n        if i % 2 == 0:\n            tetra_list.append(1 + i // 2)\n        elif i % 3 == 0:\n            tetra_list.append(tetra_list[i - 1] + tetra_list[i - 2])\n        else:\n            tetra_list.append(tetra_list[i - 1] + tetra_list[i - 2] + tetra_list[i - 3])\n    return tetra_list[:n + 1]"
      ],
      [
        0.9172743558883667,
        "    for i in range(4, n + 1):\n        if i % 2 == 0:\n            tetra_list.append(1 + i // 2)\n        elif i % 3 == 0:\n            tetra_list.append(tetra_list[i - 1] + tetra_list[i - 2])\n        else:\n            tetra_list.append(tetra_list[i - 1] + tetra_list[i - 2] + tetra_list[i - 3])"
      ],
      [
        0.9147508144378662,
        "    tetra_sequence = [0, 4, 2, 6, 3]\n    for i in range(5, n + 1):\n        if i % 2 == 0:\n            tetra_sequence.append(1 + i // 2)\n        elif i % 3 == 0:\n            tetra_sequence.append(tetra_sequence[i - 1] + tetra_sequence[i - 2])\n        else:\n            tetra_sequence.append(tetra_sequence[i - 1] + tetra_sequence[i - 2] + tetra_sequence[i - 3])\n    return tetra_sequence[1:n + 1]"
      ],
      [
        0.9138253927230835,
        "        if i % 2 == 0:\n            tetra_sequence.append(1 + i // 2)\n        elif i % 3 == 0:\n            tetra_sequence.append(tetra_sequence[i - 1] + tetra_sequence[i - 2])\n        else:\n            tetra_sequence.append(tetra_sequence[i - 1] + tetra_sequence[i - 2] + tetra_sequence[i - 3])"
      ],
      [
        0.9136544466018677,
        "    for i in range(5, n + 1):\n        if i % 2 == 0:\n            tetra_sequence.append(1 + i // 2)\n        elif i % 3 == 0:\n            tetra_sequence.append(tetra_sequence[i - 1] + tetra_sequence[i - 2])\n        else:\n            tetra_sequence.append(tetra_sequence[i - 1] + tetra_sequence[i - 2] + tetra_sequence[i - 3])"
      ],
      [
        0.9106837511062622,
        "        if i % 2 == 0:\n            tetra_list.append(1 + i // 2)\n        elif i % 3 == 0:\n            tetra_list.append(tetra_list[i - 1] + tetra_list[i - 2])\n        else:\n            tetra_list.append(tetra_list[i - 1] + tetra_list[i - 2] + tetra_list[i - 3])"
      ],
      [
        0.9058029651641846,
        "        elif i % 3 == 0:\n            tetra_sequence.append(tetra_sequence[i - 1] + tetra_sequence[i - 2])\n        else:\n            tetra_sequence.append(tetra_sequence[i - 1] + tetra_sequence[i - 2] + tetra_sequence[i - 3])"
      ],
      [
        0.8944582939147949,
        "        elif i % 3 == 0:\n            tetra_list.append(tetra_list[i - 1] + tetra_list[i - 2])\n        else:\n            tetra_list.append(tetra_list[i - 1] + tetra_list[i - 2] + tetra_list[i - 3])"
      ],
      [
        0.883368968963623,
        "    if n in memo:\n        return memo[n]\n    elif n == 0:\n        return 0\n    elif n == 1 or n == 2:\n        return 1\n    elif n < 0:\n        result = tribonacci(n + 3, memo) - tribonacci(n + 2, memo) - tribonacci(n + 1, memo)\n    else:\n        result = tribonacci(n - 1, memo) + tribonacci(n - 2, memo) + tribonacci(n - 3, memo)"
      ],
      [
        0.8833537697792053,
        "    if n in memo:\n        return memo[n]\n    elif n == 0:\n        return 0\n    elif n == 1 or n == 2:\n        return 1\n    elif n < 0:\n        result = tribonacci(n + 3, memo) - tribonacci(n + 2, memo) - tribonacci(n + 1, memo)\n    else:\n        result = tribonacci(n - 1, memo) + tribonacci(n - 2, memo) + tribonacci(n - 3, memo)"
      ]
    ],
    "MBPP/70": [
      [
        0.8972415924072266,
        "    return zip(list1, list2)"
      ],
      [
        0.8882050514221191,
        "    if len(tuple1) != len(tuple2):\n        return 'Error: The tuples do not have the same number of elements.'\n    else:\n        dictionary = {}\n        for i in range(len(tuple1)):\n            dictionary[tuple1[i]] = tuple2[i]\n        return dictionary"
      ],
      [
        0.8882050514221191,
        "    if len(tuple1) != len(tuple2):\n        return 'Error: The tuples do not have the same number of elements.'\n    else:\n        dictionary = {}\n        for i in range(len(tuple1)):\n            dictionary[tuple1[i]] = tuple2[i]\n        return dictionary"
      ],
      [
        0.8852648735046387,
        "    if len(t1) != len(t2):\n        raise ValueError('Tuples are not of equal length')\n    else:\n        combined_dict = dict(zip(t1, t2))\n        return json.dumps(combined_dict)"
      ],
      [
        0.8852648735046387,
        "    if len(t1) != len(t2):\n        raise ValueError('Tuples are not of equal length')\n    else:\n        combined_dict = dict(zip(t1, t2))\n        return json.dumps(combined_dict)"
      ],
      [
        0.8849730491638184,
        "    return [x for t in zip(list1, list2) for x in t]"
      ],
      [
        0.8845043778419495,
        "    return list(zip(list1, list2))"
      ],
      [
        0.8806685209274292,
        "    merged = ()\n    length = min(len(t1), len(t2))\n    for i in range(length):\n        merged += (t1[i],)\n        merged += (t2[i],)\n    return merged + t1[length:] + t2[length:]"
      ],
      [
        0.8800736665725708,
        "    return [item for sublist in zip(list1, list2) for item in sublist]"
      ],
      [
        0.8800665140151978,
        "    return [item for sublist in zip(list1, list2) for item in sublist]"
      ]
    ],
    "MBPP/71": [
      [
        0.9099823832511902,
        "    pi = 3.14159\n    volume = 4 / 3 * pi * radius ** 3\n    return volume"
      ],
      [
        0.9080633521080017,
        "    volume = 4 / 3 * math.pi * math.pow(radius, 3)\n    return volume"
      ],
      [
        0.9061641693115234,
        "    volume = 4 / 3 * 3.142 * radius ** 3\n    return round(volume, 2)"
      ],
      [
        0.9059352874755859,
        "    volume = 4 / 3 * math.pi * radius ** 3\n    return volume"
      ]
    ],
    "MBPP/72": [
      [
        0.8926318883895874,
        "    elif not last_char.isalpha():\n        return 'Please input a string ending with a alphabet.'\n    else:\n        return chr(ord(last_char) + 1)"
      ],
      [
        0.8915952444076538,
        "    for c in mystring:\n        new_str += chr(ord(c) + 1)"
      ],
      [
        0.8907754421234131,
        "    new_str = ''\n    for c in mystring:\n        new_str += chr(ord(c) + 1)\n    return new_str"
      ],
      [
        0.8905482292175293,
        "        if char.isalpha():\n            new_string += chr(ord(char) + 1)\n        elif char.isdigit():\n            new_string += chr(ord(char) + 1)\n        else:\n            new_string += char"
      ],
      [
        0.8904914855957031,
        "    if original_string != '':\n        for char in original_string:\n            new_string += char\n        new_string += 'a'\n        print(new_string)\n    else:\n        print('String cannot be increased.')"
      ],
      [
        0.889331042766571,
        "    new_string = ''\n    for char in string:\n        if char.isalpha():\n            new_string += chr(ord(char) + 1)\n        elif char.isdigit():\n            new_string += chr(ord(char) + 1)\n        else:\n            new_string += char\n    return new_string"
      ],
      [
        0.8889539241790771,
        "    for char in string:\n        if char.isalpha():\n            new_string += chr(ord(char) + 1)\n        elif char.isdigit():\n            new_string += chr(ord(char) + 1)\n        else:\n            new_string += char"
      ],
      [
        0.8885715007781982,
        "    word = word.strip()\n    count = 0\n    for char in word:\n        count += 1\n        if count == 3:\n            return char"
      ],
      [
        0.8879324793815613,
        "    transformed_string = ''\n    for char in str:\n        char_int = ord(char)\n        if char_int == 122:\n            transformed_string += chr(97)\n        else:\n            transformed_string += chr(char_int + 1)\n    return transformed_string"
      ],
      [
        0.8871617317199707,
        "    result = ''\n    for char in s:\n        result += chr(ord(char) + 1)\n    return result"
      ]
    ],
    "MBPP/73": [
      [
        0.9105169177055359,
        "    if n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return 2 * nth_value(n - 1)"
      ],
      [
        0.9105169177055359,
        "    if n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return 2 * nth_value(n - 1)"
      ],
      [
        0.9049450755119324,
        "    elif n == 2:\n        return 2\n    else:\n        return 2 * nth_value(n - 1)"
      ],
      [
        0.9032402038574219,
        "    if n in [0, 1]:\n        return n"
      ],
      [
        0.9026053547859192,
        "    if n <= 0:\n        raise ValueError('n should be greater than zero')\n    elif n == 1:\n        return 0\n    elif n <= 3:\n        return n - 1\n    else:\n        return 1"
      ],
      [
        0.9026053547859192,
        "    if n <= 0:\n        raise ValueError('n should be greater than zero')\n    elif n == 1:\n        return 0\n    elif n <= 3:\n        return n - 1\n    else:\n        return 1"
      ],
      [
        0.9006128311157227,
        "    elif n <= 3:\n        return n - 1\n    else:\n        return 1"
      ],
      [
        0.9006028175354004,
        "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n)"
      ],
      [
        0.9006028175354004,
        "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n)"
      ],
      [
        0.8999742269515991,
        "    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Invalid input, please enter a positive whole number.')\n    seq = [0, 2]\n    while len(seq) < n:\n        new_term = seq[-1] + seq[-2]\n        seq.append(new_term)\n    return seq[-1]"
      ]
    ],
    "MBPP/74": [
      [
        0.9211633205413818,
        "    surface_area = 4 * math.pi * radius * radius\n    return surface_area"
      ],
      [
        0.9203821420669556,
        "    surface_area = 4 * 3.14159 * radius ** 2\n    return round(surface_area, 2)"
      ],
      [
        0.9036475419998169,
        "    pi = 3.14159\n    surface_area = 4 * pi * radius ** 2\n    volume = 4 / 3 * pi * radius ** 3\n    return (surface_area, volume)"
      ],
      [
        0.9019544124603271,
        "    surface_area = 4 * math.pi * radius ** 2\n    volume = 4 / 3 * math.pi * radius ** 3\n    return (surface_area, volume)"
      ],
      [
        0.8997478485107422,
        "    if not isinstance(radius, (int, float)):\n        raise TypeError('The radius must be a numeric value.')\n    elif radius < 0:\n        raise ValueError('The radius cannot be negative.')\n    surface_area = 4 * math.pi * radius ** 2\n    return round(surface_area, 2)"
      ],
      [
        0.8990501165390015,
        "    if type(radius) != int or radius <= 0:\n        raise ValueError('Radius should be a positive integer')\n    surface_area = 4 * math.pi * radius ** 2\n    rounded_surface_area = round(surface_area, 2)\n    return rounded_surface_area"
      ]
    ],
    "MBPP/75": [
      [
        0.8995764255523682,
        "    while True:\n        hexagonal = n * (2 * n - 1)\n        if isPentagonal(hexagonal):\n            return hexagonal\n        n += 1"
      ],
      [
        0.8932449817657471,
        "        if isPentagonal(hexagonal):\n            return hexagonal"
      ],
      [
        0.8929467797279358,
        "    n = 144\n    while True:\n        hexagonal = n * (2 * n - 1)\n        if isPentagonal(hexagonal):\n            return hexagonal\n        n += 1\n    return None"
      ],
      [
        0.8905327320098877,
        "        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4"
      ],
      [
        0.8860144019126892,
        "    if type(n) != int or n < 0:\n        return 'ERROR: Invalid Input'\n    if n > 5000:\n        return 'ERROR: Input number too large'\n    if n in computed:\n        return computed[n]\n    computed[n] = n * (5 * n - 3) / 2 + heptagonal(n - 1)\n    return computed[n]"
      ],
      [
        0.8776531219482422,
        "    while count < n:\n        pentagonal = x * (3 * x - 1) // 2\n        yield pentagonal\n        x += 2\n        count += 1"
      ],
      [
        0.875400185585022,
        "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"
      ],
      [
        0.875400185585022,
        "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"
      ],
      [
        0.8750653266906738,
        "    if n == 1:\n        if sequence:\n            return [1]\n        else:\n            return 1\n    else:\n        previous_seq = nonagonal_calc(n - 1, sequence=True)\n        current_value = n * (7 * n - 5) // 2\n        if sequence:\n            return previous_seq + [current_value]\n        else:\n            return current_value"
      ],
      [
        0.8744978904724121,
        "    if not isinstance(n, int) or n < 1:\n        return \"Warning: Invalid input. 'n' should be a positive integer.\"\n    x = 1\n    count = 0\n    while count < n:\n        pentagonal = x * (3 * x - 1) // 2\n        yield pentagonal\n        x += 2\n        count += 1"
      ]
    ],
    "MBPP/76": [
      [
        0.903810441493988,
        "    return {**dict1, **dict2, **dict3}"
      ],
      [
        0.8861516118049622,
        "    dict3 = dict1.copy()\n    dict3.update(dict2)\n    return dict3"
      ],
      [
        0.8857178688049316,
        "        elif key in dict1:\n            dict3[key] = dict1[key]\n        else:\n            dict3[key] = dict2[key]"
      ]
    ],
    "MBPP/77": [
      [
        0.9293187856674194,
        "    frequency = {}\n    for item in my_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency"
      ],
      [
        0.9282239675521851,
        "    freq = {}\n    for element in lst:\n        if element in freq:\n            freq[element] += 1\n        else:\n            freq[element] = 1\n    return freq"
      ],
      [
        0.9254363775253296,
        "    frequency_dict = {}\n    for element in lst:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict"
      ],
      [
        0.9251856803894043,
        "    freq_dict = {}\n    for item in list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict"
      ],
      [
        0.9238341450691223,
        "    for element in elements:\n        frequencies[element] = my_list.count(element)"
      ],
      [
        0.9237633347511292,
        "    frequency = {}\n    for i in lst:\n        if i in frequency:\n            frequency[i] += 1\n        else:\n            frequency[i] = 1\n    return frequency"
      ],
      [
        0.92364501953125,
        "    if not isinstance(lst, list):\n        raise TypeError('Input is not a list')\n    frequency = {}\n    for element in lst:\n        if not isinstance(element, (int, float)):\n            raise TypeError('List contains elements that are not numbers')\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency"
      ],
      [
        0.9206636548042297,
        "    frequency_list = []\n    for item in my_list:\n        if item not in frequency_list:\n            frequency_list.append(item)\n    for i in range(0, len(frequency_list)):\n        frequency_list[i] = (frequency_list[i], my_list.count(frequency_list[i]))\n    return frequency_list"
      ],
      [
        0.9193477630615234,
        "    if not input_list:\n        return {}\n    frequency_counter = Counter(input_list)\n    frequency_dict = dict(frequency_counter)\n    return frequency_dict"
      ],
      [
        0.9180501699447632,
        "    for element in list:\n        if element in frequency_dict.keys():\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1"
      ]
    ],
    "MBPP/78": [
      [
        0.9046329259872437,
        "    closest_low = 0\n    for i in range(len(arr)):\n        if num > arr[i] > closest_low:\n            closest_low = arr[i]\n    return closest_low"
      ],
      [
        0.901627779006958,
        "    while True:\n        n -= 1\n        if is_prime(n):\n            return n"
      ],
      [
        0.901627779006958,
        "    while True:\n        n -= 1\n        if is_prime(n):\n            return n"
      ],
      [
        0.9012535810470581,
        "    if n < 0:\n        return -1\n    elif n <= 1:\n        return 0\n    new_size = int(n / 0.5) + 1\n    return new_size - n"
      ],
      [
        0.8997445106506348,
        "    for i in range(len(arr)):\n        if num > arr[i] > closest_low:\n            closest_low = arr[i]"
      ],
      [
        0.8987901210784912,
        "            if l[mid] == n:\n                return n\n            elif l[mid] < n:\n                left = mid\n            else:\n                right = mid"
      ],
      [
        0.8987013697624207,
        "    if n <= 2:\n        return -1\n    prime = n - 1\n    found = False\n    while not found:\n        if check_prime(prime) == True:\n            found = True\n        prime -= 1\n    return prime + 1"
      ],
      [
        0.8965843915939331,
        "    for i in range(n, 0, -1):\n        if is_prime(i):\n            return i"
      ],
      [
        0.8965843915939331,
        "    for i in range(n, 0, -1):\n        if is_prime(i):\n            return i"
      ],
      [
        0.896420419216156,
        "    elif n >= l[-1]:\n        return l[-1]\n    else:\n        left, right = (0, len(l) - 1)\n        while left < right - 1:\n            mid = (left + right) // 2\n            if l[mid] == n:\n                return n\n            elif l[mid] < n:\n                left = mid\n            else:\n                right = mid\n        if l[right] - n <= n - l[left]:\n            return l[right]\n        else:\n            return l[left]"
      ]
    ],
    "MBPP/79": [
      [
        0.9385227560997009,
        "    word_list = text.split()\n    longest_word = max(word_list, key=len)\n    longest_word_length = len(longest_word)\n    return longest_word_length"
      ],
      [
        0.9335407018661499,
        "    words = string.split()\n    longest_length = 0\n    for word in words:\n        if len(word) > longest_length:\n            longest_length = len(word)\n    return longest_length"
      ],
      [
        0.9329982399940491,
        "    words = sentence.split()\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length"
      ],
      [
        0.9329981803894043,
        "    words = sentence.split()\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length"
      ],
      [
        0.9327255487442017,
        "    words = string.split()\n    longest_word_length = 0\n    for word in words:\n        if len(word) > longest_word_length:\n            longest_word_length = len(word)\n    return longest_word_length"
      ],
      [
        0.9317890405654907,
        "    longest = 0\n    words = sentence.split()\n    for word in words:\n        if len(word) > longest:\n            longest = len(word)\n    return longest"
      ],
      [
        0.9309384822845459,
        "    words = sentence.split()\n    longest_word = ''\n    for word in words:\n        if len(word) > len(longest_word):\n            longest_word = word\n    return len(longest_word)"
      ],
      [
        0.9307042360305786,
        "    longest_word = max(words, key=len)\n    return longest_word"
      ],
      [
        0.9299757480621338,
        "    longest_word = ''\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            longest_word = word\n            max_length = len(word)\n    return longest_word"
      ],
      [
        0.9299694895744324,
        "    words = sentence.split(' ')\n    longest_word = 0\n    for word in words:\n        if len(word) > longest_word:\n            longest_word = len(word)\n    return longest_word"
      ]
    ],
    "MBPP/80": [
      [
        0.9352319240570068,
        "    for string in string_list:\n        if substring in string:\n            return True\n    return False"
      ],
      [
        0.9309239387512207,
        "    for string in string_list:\n        if substring in string:\n            return True"
      ],
      [
        0.9265003204345703,
        "    for item in lst:\n        if substring in item:\n            return True\n    return False"
      ],
      [
        0.9230149984359741,
        "    for substring in substrings:\n        if substring in string:\n            return True\n    return False"
      ],
      [
        0.9219099879264832,
        "    if substring in string:\n        return True\n    else:\n        return False"
      ],
      [
        0.9219099879264832,
        "    if substring in string:\n        return True\n    else:\n        return False"
      ],
      [
        0.9219086170196533,
        "    if substring in string:\n        return True\n    else:\n        return False"
      ],
      [
        0.9219086170196533,
        "    if substring in string:\n        return True\n    else:\n        return False"
      ],
      [
        0.92190021276474,
        "    if substring in string:\n        return True\n    else:\n        return False"
      ],
      [
        0.92190021276474,
        "    if substring in string:\n        return True\n    else:\n        return False"
      ]
    ],
    "MBPP/81": [
      [
        0.8872003555297852,
        "    num = 1 / 2 * (math.sqrt(8 * x + 1) - 1)\n    return int(num) == num"
      ],
      [
        0.8863439559936523,
        "    root = math.sqrt(num)\n    return root.is_integer()"
      ],
      [
        0.886300802230835,
        "    root = math.sqrt(num)\n    return root.is_integer()"
      ],
      [
        0.8833931684494019,
        "    return num % 4 == 0 or num % 6 == 0"
      ],
      [
        0.8824251294136047,
        "    if number % 2 == 0:\n        return False\n    else:\n        return True"
      ],
      [
        0.8824251294136047,
        "    if number % 2 == 0:\n        return False\n    else:\n        return True"
      ],
      [
        0.882392168045044,
        "    if number % 2 == 0:\n        return False\n    else:\n        return True"
      ],
      [
        0.882392168045044,
        "    if number % 2 == 0:\n        return False\n    else:\n        return True"
      ],
      [
        0.8818081021308899,
        "    root = math.sqrt(n)\n    return n == int(root + 0.5) ** 2"
      ],
      [
        0.8817868828773499,
        "    if number % 10 == 0:\n        return True\n    return False"
      ]
    ],
    "MBPP/82": [
      [
        0.9148586988449097,
        "    result = 1\n    for i in range(b):\n        result = result * a\n    return result"
      ],
      [
        0.9120935201644897,
        "    return float('%.3f' % pow(a, b))"
      ],
      [
        0.9108773469924927,
        "    return pow(num, power)"
      ],
      [
        0.9108743071556091,
        "    return pow(num, power)"
      ],
      [
        0.90727299451828,
        "    result = 1\n    if b >= 0:\n        for _ in range(b):\n            result *= a\n    else:\n        for _ in range(-b):\n            result /= a\n    return result"
      ],
      [
        0.9058274030685425,
        "    sum_result = a + b\n    power_result = a ** b\n    return (sum_result, power_result)"
      ],
      [
        0.9048712253570557,
        "    try:\n        float_number = float(number)\n    except ValueError:\n        return 'Error: The input is not a valid numerical value!'\n    return pow(float_number, power)"
      ],
      [
        0.9035940766334534,
        "        for _ in range(b):\n            result *= a"
      ],
      [
        0.9015156030654907,
        "    result = pow(number, power)\n    return float(result)"
      ],
      [
        0.9014190435409546,
        "    elif a < 0:\n        return a * b\n    else:\n        return b ** 2"
      ]
    ],
    "MBPP/83": [
      [
        0.881722092628479,
        "    min_value = tpl[0]\n    for i in tpl:\n        if i < min_value:\n            min_value = i\n    return min_value"
      ],
      [
        0.8817185163497925,
        "    min_value = tpl[0]\n    for i in tpl:\n        if i < min_value:\n            min_value = i\n    return min_value"
      ],
      [
        0.8734389543533325,
        "    min_value = None\n    min_index = -1\n    for i in range(len(numbers)):\n        if min_value is None or numbers[i] > min_value:\n            min_value = numbers[i]\n            min_index = i\n    return (min_index, numbers[min_index])"
      ],
      [
        0.872460663318634,
        "    if len(arr) == 0:\n        return (None, None)\n    min_value = arr[0]\n    min_index = 0\n    for i in range(1, len(arr)):\n        if arr[i] < min_value:\n            min_value = arr[i]\n            min_index = i\n    return (min_value, min_index)"
      ],
      [
        0.8712706565856934,
        "    if len(tup_list) == 0:\n        return 'The tuple list is empty.'\n    if k > len(tup_list):\n        return 'K is greater than the size of list. Returning all records.'\n    tup_list.sort(key=lambda x: x[0])\n    return tup_list[:k]"
      ],
      [
        0.8699585795402527,
        "    min_val = arr[0]\n    min_index = 0\n    for i, num in enumerate(arr):\n        if num < min_val:\n            min_val = num\n            min_index = i\n    return (min_val, min_index)"
      ],
      [
        0.8692935705184937,
        "            if tuple_value < tuple_item:\n                index = i\n                break"
      ],
      [
        0.8685747385025024,
        "    max_values = []\n    for tup in list_of_tuples:\n        max_values.append(max(tup))\n    return max_values"
      ],
      [
        0.86780846118927,
        "            if value > minimum_value:\n                return (value, key)"
      ],
      [
        0.8675603866577148,
        "    min_val = arr[0]\n    min_index = 0\n    for i in range(1, len(arr)):\n        if arr[i] < min_val:\n            min_val = arr[i]\n            min_index = i\n    return (min_val, min_index)"
      ]
    ],
    "MBPP/84": [
      [
        0.8956077098846436,
        "            if subsequence_length < min_length:\n                min_length = subsequence_length"
      ],
      [
        0.8903441429138184,
        "    min_value = min(list1)\n    return min_value"
      ],
      [
        0.8865119218826294,
        "    if minlength == n + 1:\n        print('Not Possible')\n    else:\n        print('Minimum length of subarray is: %d' % minlength)"
      ],
      [
        0.8836588859558105,
        "    if len(lst) == 1:\n        return lst[0]\n    else:\n        return min(lst[0], find_minimum(lst[1:]))"
      ],
      [
        0.8836588859558105,
        "    if len(lst) == 1:\n        return lst[0]\n    else:\n        return min(lst[0], find_minimum(lst[1:]))"
      ],
      [
        0.8834091424942017,
        "    if isinstance(lst, list):\n        return min((recurs_min(sub) for sub in lst))\n    elif isinstance(lst, int):\n        return lst\n    else:\n        raise ValueError('Input list contains non-integer values')"
      ],
      [
        0.8834091424942017,
        "    if isinstance(lst, list):\n        return min((recurs_min(sub) for sub in lst))\n    elif isinstance(lst, int):\n        return lst\n    else:\n        raise ValueError('Input list contains non-integer values')"
      ],
      [
        0.8813356161117554,
        "    input_list = list(set(input_list))\n    return find_min(input_list)"
      ],
      [
        0.8806067705154419,
        "        if len(sublist) != sublist_length:\n            return False"
      ],
      [
        0.8804660439491272,
        "    if not lst:\n        return float('inf')\n    if isinstance(lst[0], list):\n        a = find_min(lst[0])\n    else:\n        a = lst[0]\n    b = find_min(lst[1:])\n    return a if a < b else b"
      ]
    ],
    "MBPP/85": [
      [
        0.9216490983963013,
        "    divisors = 0\n    for i in range(1, number + 1):\n        if number % i == 0:\n            divisors += 1\n    print('Number of divisors:', divisors)"
      ],
      [
        0.9201942682266235,
        "    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count"
      ],
      [
        0.9201762676239014,
        "    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count"
      ],
      [
        0.9201656579971313,
        "    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count"
      ],
      [
        0.9197947382926941,
        "    count = 0\n    for i in range(1, x + 1):\n        if x % i == 0:\n            count = count + 1\n    return count"
      ],
      [
        0.9165308475494385,
        "    divisors = [i for i in range(1, n + 1) if n % i == 0]\n    return divisors"
      ],
      [
        0.9165216684341431,
        "    divisors = [i for i in range(1, n + 1) if n % i == 0]\n    return divisors"
      ],
      [
        0.9162620306015015,
        "    divisors = [i for i in range(1, int(n / 2) + 1) if n % i == 0]\n    divisors.append(n)\n    return divisors"
      ],
      [
        0.9162578582763672,
        "    divisors = [i for i in range(1, int(n / 2) + 1) if n % i == 0]\n    divisors.append(n)\n    return divisors"
      ],
      [
        0.9143408536911011,
        "    divisors = []\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisors.append(i)\n    return sum(divisors)"
      ]
    ],
    "MBPP/86": [
      [
        0.9047385454177856,
        "    freq_dict = {}\n    for item in list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict"
      ],
      [
        0.9017285108566284,
        "    for i in range(0, len(frequency_list)):\n        frequency_list[i] = (frequency_list[i], my_list.count(frequency_list[i]))"
      ],
      [
        0.9008973836898804,
        "    frequency_list = []\n    for item in my_list:\n        if item not in frequency_list:\n            frequency_list.append(item)\n    for i in range(0, len(frequency_list)):\n        frequency_list[i] = (frequency_list[i], my_list.count(frequency_list[i]))\n    return frequency_list"
      ],
      [
        0.8994886875152588,
        "    frequency = {}\n    for item in my_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency"
      ],
      [
        0.8993456363677979,
        "    frequency_dict = {}\n    for sublist in matrix:\n        if isinstance(sublist, list):\n            for item in sublist:\n                if isinstance(item, list):\n                    for subitem in item:\n                        frequency_dict[subitem] = frequency_dict.get(subitem, 0) + 1\n                else:\n                    frequency_dict[item] = frequency_dict.get(item, 0) + 1\n        else:\n            frequency_dict[sublist] = frequency_dict.get(sublist, 0) + 1\n    return frequency_dict"
      ],
      [
        0.8993127346038818,
        "    frequency_dict = {}\n    for sublist in matrix:\n        if isinstance(sublist, list):\n            for item in sublist:\n                if isinstance(item, list):\n                    for subitem in item:\n                        frequency_dict[subitem] = frequency_dict.get(subitem, 0) + 1\n                else:\n                    frequency_dict[item] = frequency_dict.get(item, 0) + 1\n        else:\n            frequency_dict[sublist] = frequency_dict.get(sublist, 0) + 1\n    return frequency_dict"
      ],
      [
        0.899026095867157,
        "    if not input_list:\n        return {}\n    frequency_counter = Counter(input_list)\n    frequency_dict = dict(frequency_counter)\n    return frequency_dict"
      ],
      [
        0.8988651037216187,
        "    freq = {}\n    for element in lst:\n        if element in freq:\n            freq[element] += 1\n        else:\n            freq[element] = 1\n    return freq"
      ],
      [
        0.8988641500473022,
        "    frequency_dict = dict(Counter(input_list))\n    return frequency_dict"
      ],
      [
        0.8985060453414917,
        "    frequency = {}\n    for i in lst:\n        if i in frequency:\n            frequency[i] += 1\n        else:\n            frequency[i] = 1\n    return frequency"
      ]
    ],
    "MBPP/87": [
      [
        0.924433708190918,
        "    sum_list = 0\n    length_list = len(mylist)\n    for item in mylist:\n        sum_list += item\n    return sum_list / length_list"
      ],
      [
        0.9233635663986206,
        "    s = 0\n    for i in my_list:\n        s += i\n    return s / len(my_list)"
      ],
      [
        0.9232916831970215,
        "    total = sum(num_list)\n    length = len(num_list)\n    return total / length"
      ],
      [
        0.9232696890830994,
        "    total = 0\n    for i in list:\n        total += i\n    return total / len(list)"
      ],
      [
        0.92289799451828,
        "    product = 1\n    for i in list:\n        product *= i\n    return product ** (1.0 / len(list))"
      ],
      [
        0.92289799451828,
        "    product = 1\n    for i in list:\n        product *= i\n    return product ** (1.0 / len(list))"
      ],
      [
        0.9217953681945801,
        "    sum = 0\n    length = len(list)\n    for item in list:\n        sum += item\n    return sum / length"
      ],
      [
        0.9213599562644958,
        "    total = 0\n    for num in input_list:\n        total += num\n    return total / len(input_list)"
      ],
      [
        0.9210866689682007,
        "    total = 0\n    for num in list_of_numbers:\n        total += num\n    return total / len(list_of_numbers)"
      ],
      [
        0.9210770726203918,
        "    total = 0\n    for num in list_of_numbers:\n        total += num\n    return total / len(list_of_numbers)"
      ]
    ],
    "MBPP/88": [],
    "MBPP/89": [
      [
        0.9298737049102783,
        "    num = int(num)\n    num += 1\n    while not is_palindrome(str(num)):\n        num += 1\n    return num"
      ],
      [
        0.9233894944190979,
        "    prime = N + 1\n    while True:\n        if is_palindrome(prime):\n            return prime\n        prime += 1"
      ],
      [
        0.922540545463562,
        "    N += 1\n    while not is_palindrome(N):\n        N += 1\n    return N"
      ],
      [
        0.9204354882240295,
        "    while not is_palindrome(N):\n        N += 1"
      ],
      [
        0.9187624454498291,
        "    while not is_palindrome(str(num)):\n        num += 1"
      ],
      [
        0.9157408475875854,
        "    num = int(n)\n    left = num - 1\n    right = num + 1\n    while True:\n        if is_palindrome(str(left)):\n            return left\n        if is_palindrome(str(right)):\n            return right\n        left -= 1\n        right += 1"
      ],
      [
        0.9157384634017944,
        "    num = int(n)\n    left = num - 1\n    right = num + 1\n    while True:\n        if is_palindrome(str(left)):\n            return left\n        if is_palindrome(str(right)):\n            return right\n        left -= 1\n        right += 1"
      ],
      [
        0.9136845469474792,
        "    while True:\n        if is_palindrome(prime):\n            return prime\n        prime += 1"
      ],
      [
        0.9129340052604675,
        "    elif is_palindrome(n) and is_prime(n):\n        return n\n    else:\n        return find_largest_prime_palindrome(n - 1)"
      ],
      [
        0.9085729718208313,
        "    if n == 100:\n        return n\n    elif is_palindrome(n) and is_prime(n):\n        return n\n    else:\n        return find_largest_prime_palindrome(n - 1)"
      ]
    ],
    "MBPP/90": [
      [
        0.9308001399040222,
        "    sorted_arr = sorted(arr)\n    return sorted_arr[k - 1]"
      ],
      [
        0.9282589554786682,
        "    if k > len(arr):\n        return 'k is greater than the number of unique elements'\n    else:\n        return arr[k - 1]"
      ],
      [
        0.9279881715774536,
        "    input_array.sort()\n    return input_array[k - 1]"
      ],
      [
        0.9278619289398193,
        "    if k > len(arr):\n        return None\n    else:\n        sorted_arr = sorted(arr)\n        return sorted_arr[k - 1]"
      ],
      [
        0.9278619289398193,
        "    if k > len(arr):\n        return None\n    else:\n        sorted_arr = sorted(arr)\n        return sorted_arr[k - 1]"
      ],
      [
        0.9264690279960632,
        "    sorted_arr = sorted(arr)[::-1]\n    return sorted_arr[k - 1]"
      ],
      [
        0.9264675378799438,
        "    sorted_arr = sorted(arr)[::-1]\n    return sorted_arr[k - 1]"
      ],
      [
        0.9258804321289062,
        "    if k > len(arr):\n        return 'Error: k is out of bounds.'\n    else:\n        return arr[k - 1]"
      ],
      [
        0.924019992351532,
        "    if k > len(arr) or k <= 0:\n        return None\n    for i in range(k):\n        min_element = arr[0]\n        min_index = 0\n        for j in range(1, len(arr)):\n            if arr[j] < min_element:\n                min_element = arr[j]\n                min_index = j\n        arr[min_index], arr[i] = (arr[i], arr[min_index])\n    return arr[k - 1]"
      ],
      [
        0.923766553401947,
        "    if k > len(nums):\n        return 'k is bigger than the size of the list'\n    else:\n        return nums[k - 1]"
      ]
    ],
    "MBPP/91": [
      [
        0.9247964024543762,
        "    words = snake_case.split('_')\n    camel_case = words[0]\n    for word in words[1:]:\n        camel_case += word.capitalize()\n    return camel_case"
      ],
      [
        0.9221047163009644,
        "    camel_case = ''\n    for word in str.split():\n        camel_case += word.capitalize()\n    return camel_case"
      ]
    ],
    "MBPP/92": [
      [
        0.8906870484352112,
        "    return math.factorial(m + n - 2) // (math.factorial(n - 1) * math.factorial(m - 1))"
      ],
      [
        0.88893723487854,
        "    if n > m:\n        return 0"
      ],
      [
        0.8876044750213623,
        "    if n > m:\n        return 'Error: n should be less than or equal to m.'"
      ],
      [
        0.8875895738601685,
        "    if n > m:\n        return 'Error: n should be less than or equal to m.'"
      ],
      [
        0.8862558603286743,
        "    if n == m:\n        return 1"
      ],
      [
        0.8862354755401611,
        "    if n == m:\n        return 1"
      ],
      [
        0.8832582235336304,
        "    if m > n:\n        return 0"
      ],
      [
        0.8832582235336304,
        "    if m > n:\n        return 0"
      ],
      [
        0.879114031791687,
        "    if (n, m) in memo:\n        return memo[n, m]"
      ],
      [
        0.8791067600250244,
        "    if (n, m) in memo:\n        return memo[n, m]"
      ]
    ],
    "MBPP/93": [
      [
        0.904645562171936,
        "    for sublist in lists:\n        sublist.sort()"
      ],
      [
        0.8916612267494202,
        "    for sublist in lists:\n        sublist.sort()\n    lists.sort(key=lambda x: x[0])\n    return lists"
      ],
      [
        0.8882632255554199,
        "    sorted_list = sorted(list_of_strings)\n    return sorted_list"
      ],
      [
        0.8878780603408813,
        "    sorted_list = sorted(list_of_strings, key=lambda str: str.lower())\n    return sorted_list"
      ],
      [
        0.8874186277389526,
        "    list_of_strings.sort()\n    for string in list_of_strings:\n        print(string)"
      ],
      [
        0.8868726491928101,
        "    sorted_sublists = [sorted(sublist, reverse=True) for sublist in lst]\n    sorted_lst = sorted(sorted_sublists, key=lambda x: min(x), reverse=True)\n    return sorted_lst"
      ],
      [
        0.8864985704421997,
        "    strings_list = input_list\n    strings_list.sort(key=len)\n    return strings_list"
      ],
      [
        0.8856813907623291,
        "    sorted_list = sorted(strings, key=len)\n    return sorted_list"
      ],
      [
        0.8836424350738525,
        "    for sublist in arr:\n        bubble_sort(sublist)"
      ],
      [
        0.8832833170890808,
        "    sortedList = [sorted(lst) for lst in lists]\n    sortedList.sort(key=len)\n    return sortedList"
      ]
    ],
    "MBPP/94": [
      [
        0.9040787220001221,
        "    true_sum: int = 0\n    false_sum: int = 0\n    for i in range(len(x)):\n        if isinstance(x[i], bool) and x[i] is True:\n            true_sum += 1\n        elif isinstance(x[i], bool) and x[i] is False:\n            false_sum += 1\n    return (true_sum, false_sum)"
      ],
      [
        0.8972114324569702,
        "    count = 0\n    for l in ls:\n        if l == 1:\n            count += 1\n    return count"
      ],
      [
        0.8912967443466187,
        "    count = 0\n    for i in my_list:\n        if i == char:\n            count += 1\n    return count"
      ],
      [
        0.8910148739814758,
        "    true_sum: int = 0\n    false_sum: int = 0\n    for i in range(len(x)):\n        if isinstance(x[i], bool) and x[i] is True:\n            true_sum += 2\n        elif isinstance(x[i], bool) and x[i] is False:\n            false_sum += 2\n    return (true_sum, false_sum)"
      ],
      [
        0.8909772634506226,
        "    true_sum: int = 0\n    false_sum: int = 0\n    for i in range(len(x)):\n        if isinstance(x[i], bool) and x[i] is True:\n            true_sum += 2\n        elif isinstance(x[i], bool) and x[i] is False:\n            false_sum += 2\n    return (true_sum, false_sum)"
      ],
      [
        0.8908747434616089,
        "    count = 0\n    for i in lst:\n        if i == x:\n            count += 1\n    return count"
      ],
      [
        0.8908746838569641,
        "    count = 0\n    for i in lst:\n        if i == x:\n            count += 1\n    return count"
      ],
      [
        0.8905704617500305,
        "    count = sum((x % 1 != 0 for x in myList))\n    return count"
      ],
      [
        0.8893463611602783,
        "    for i in range(len(x)):\n        if isinstance(x[i], bool) and x[i] is True:\n            true_sum += 1\n        elif isinstance(x[i], bool) and x[i] is False:\n            false_sum += 1"
      ],
      [
        0.8890926837921143,
        "    count = 0\n    for i in input_list:\n        if i == element:\n            count += 1\n    return count"
      ]
    ],
    "MBPP/95": [
      [
        0.890766441822052,
        "    additions = []\n    for i in range(len(list1)):\n        additions.append(list1[i] + list2[i])\n    return additions"
      ],
      [
        0.886352002620697,
        "    for element in list:\n        tupleList.append((element,))"
      ],
      [
        0.8859602212905884,
        "    for i in range(len(list1)):\n        additions.append(list1[i] + list2[i])"
      ],
      [
        0.8859531879425049,
        "    tupleList = []\n    for element in list:\n        tupleList.append((element,))\n    return tupleList"
      ],
      [
        0.8848867416381836,
        "    return list_to_append + list_to_add"
      ]
    ],
    "MBPP/96": [
      [
        0.8800690174102783,
        "    hex_num = hex(num).lstrip('0x').upper()\n    count = hex_num.count('0')\n    return count"
      ],
      [
        0.8791757822036743,
        "    my_int_in_hex = hex(my_int)[2:]\n    count = 0\n    index_list = []\n    for i in range(len(hex_string)):\n        if hex_string[i] == my_int_in_hex:\n            count += 1\n            index_list.append(i)\n    return (count, index_list)"
      ],
      [
        0.8787362575531006,
        "    for i in range(len(hex_string)):\n        if hex_string[i] == my_int_in_hex:\n            count += 1\n            index_list.append(i)"
      ],
      [
        0.8774327039718628,
        "    tally = 0\n    int_locations = []\n    for i, char in enumerate(hex_string):\n        if char == str(my_int):\n            tally += 1\n            int_locations.append(i)\n    return (tally, int_locations)"
      ],
      [
        0.8752556443214417,
        "    hex_output = ''\n    for character in input_string:\n        ascii_val = ord(character)\n        hex_val = hex(ascii_val)[2:]\n        hex_output += hex_val + ' '\n    return hex_output.rstrip()"
      ],
      [
        0.8744489550590515,
        "    counter_dict = {}\n    if start_number > 0:\n        while start_number >= 0:\n            counter_dict[start_number] = bin(start_number)[2:]\n            start_number -= 1\n    else:\n        while start_number <= 0:\n            counter_dict[start_number] = bin(start_number & 4294967295)[2:]\n            start_number += 1\n    return counter_dict"
      ],
      [
        0.8738586902618408,
        "    decimal_num = int(hex_num, 16)\n    binary_num = bin(decimal_num)\n    return binary_num"
      ],
      [
        0.873664915561676,
        "    my_int = str(my_int)\n    indices = [i for i, x in enumerate(hex_string) if x == my_int]\n    return (len(indices), indices)"
      ]
    ],
    "MBPP/97": [],
    "MBPP/98": [
      [
        0.8900451064109802,
        "    return binary_string.count('1')"
      ],
      [
        0.8857401609420776,
        "    for bit in binary_string:\n        if bit == '1':\n            count += 1"
      ],
      [
        0.8850492238998413,
        "    count = 0\n    for bit in binary_string:\n        if bit == '1':\n            count += 1\n    return count"
      ],
      [
        0.883312463760376,
        "    return binary.count('1')"
      ],
      [
        0.880691647529602,
        "    result = 0\n    bit_place = 0\n    while n > 0:\n        if n & 1 == 1:\n            if bit_place % 2 == 0:\n                result += 1\n        n >>= 1\n        bit_place += 1\n    return result"
      ],
      [
        0.8805960416793823,
        "    for char in binary_str:\n        if char == '1':\n            count += 1"
      ],
      [
        0.8804523348808289,
        "    while n > 0:\n        if n & 1 == 1:\n            if bit_place % 2 == 0:\n                result += 1\n        n >>= 1\n        bit_place += 1"
      ],
      [
        0.8781188726425171,
        "    for c in s:\n        count = count + 1 if c == '1' else 0\n        result = (result + count) % mod"
      ],
      [
        0.8781005144119263,
        "    for c in s:\n        count = count + 1 if c == '1' else 0\n        result = (result + count) % mod"
      ],
      [
        0.8779504299163818,
        "        if binaryNumber % 10 == 1:\n            count += 1"
      ]
    ],
    "MBPP/99": [
      [
        0.8904544711112976,
        "    arr.sort()\n    missing = []\n    for i in range(arr[0], arr[-1] + 1):\n        if i not in arr:\n            missing.append(i)\n    return missing"
      ],
      [
        0.8894385099411011,
        "    number_set = set(numbers)\n    complete_set = set(range(min(numbers), max(numbers) + 1))\n    missing_numbers = complete_set - number_set\n    return list(missing_numbers)"
      ],
      [
        0.8894097208976746,
        "    number_set = set(numbers)\n    complete_set = set(range(min(numbers), max(numbers) + 1))\n    missing_numbers = complete_set - number_set\n    return list(missing_numbers)"
      ],
      [
        0.8893870115280151,
        "    return [x for x in range(lst[0], lst[-1] + 1) if x not in lst]"
      ],
      [
        0.8893850445747375,
        "    return [x for x in range(lst[0], lst[-1] + 1) if x not in lst]"
      ],
      [
        0.889354407787323,
        "    start = arr[0]\n    end = arr[len(arr) - 1]\n    result = []\n    for i in range(start, end + 1):\n        if i not in arr:\n            result.append(i)\n    return result"
      ],
      [
        0.8855795860290527,
        "    ranges = []\n    numbers.sort()\n    start = numbers[0]\n    for i in range(1, len(numbers)):\n        if numbers[i] == numbers[i - 1] + 1:\n            continue\n        else:\n            ranges.append(list(range(start, numbers[i - 1] + 1)))\n            start = numbers[i]\n    ranges.append(list(range(start, numbers[-1] + 1)))\n    return ranges"
      ],
      [
        0.8853608965873718,
        "    start = min(start_1, start_2)\n    end = max(end_1, end_2)\n    return list(range(start, end + 1))"
      ],
      [
        0.8844737410545349,
        "    for i in range(arr[0], arr[-1] + 1):\n        if i not in arr:\n            missing.append(i)"
      ],
      [
        0.8837907314300537,
        "    return list(range(start, end + 1))"
      ]
    ],
    "MBPP/100": [
      [
        0.9306983351707458,
        "    list1_flat = set(flatten(list1))\n    list2_flat = set(flatten(list2))\n    common = list1_flat.intersection(list2_flat)\n    return list(common)"
      ],
      [
        0.9281349778175354,
        "    set1 = set(flatten(list1))\n    set2 = set(flatten(list2))\n    common_items = set1.intersection(set2)\n    return list(common_items)"
      ],
      [
        0.9280052781105042,
        "    flat_list1 = flatten(list_one)\n    flat_list2 = flatten(list_two)\n    common_list = [value for value in flat_list1 if value in flat_list2]\n    return common_list"
      ],
      [
        0.9266336560249329,
        "    list1 = flatten_list(list1)\n    list2 = flatten_list(list2)\n    common_items = []\n    for item in list1:\n        if item in list2 and item not in common_items:\n            common_items.append(item)\n    return common_items"
      ],
      [
        0.9258133172988892,
        "    common_items = []\n    list1 = flatten_list(list1)\n    list2 = flatten_list(list2)\n    for item in list1:\n        if item in list2:\n            common_items.append(item)\n    return common_items"
      ],
      [
        0.9212514162063599,
        "    list_of_sets = [set(lst) for lst in list_of_lists]\n    common_set = set.intersection(*list_of_sets)\n    common_list = list(common_set)\n    return common_list"
      ],
      [
        0.9209737777709961,
        "    common = []\n    for value in list1:\n        if value in list2:\n            common.append(value)\n    return common"
      ],
      [
        0.9209583401679993,
        "    common = []\n    for element1 in list1:\n        for element2 in list2:\n            if element1 == element2:\n                common.append(element1)\n    return common"
      ],
      [
        0.9205236434936523,
        "    common = []\n    for item in list1:\n        if item in list2:\n            common.append(item)\n    return common"
      ],
      [
        0.9204890131950378,
        "    common = []\n    for i in list1:\n        for j in list2:\n            if i == j:\n                common.append(i)\n    return common"
      ]
    ],
    "MBPP/101": [
      [
        0.9196661710739136,
        "    perimeter = 2 * math.pi * radius\n    return perimeter"
      ],
      [
        0.9032785892486572,
        "    area = 3.14 * radius ** 2\n    perimeter = 2 * 3.14 * radius\n    return (area, perimeter)"
      ],
      [
        0.9024999141693115,
        "    circumference = 2 * 3.14 * radius\n    return circumference"
      ],
      [
        0.8975180983543396,
        "    return math.pi * cylinder['radius'] ** 2 * cylinder['height']"
      ],
      [
        0.8966156244277954,
        "    pi = 3.14\n    return pi * radius ** 2 * height"
      ],
      [
        0.8928848505020142,
        "    radius = ''.join(filter(str.isdigit, radius))\n    radius = float(radius)\n    circumference = 2 * math.pi * radius\n    return circumference"
      ],
      [
        0.8923834562301636,
        "    pi = 3.14\n    circumference = 2 * pi * r\n    area = pi * r ** 2\n    return (circumference, area)"
      ],
      [
        0.8918233513832092,
        "    approximation_pi = 3.14\n    circumference = 2 * approximation_pi * radius\n    return circumference"
      ],
      [
        0.8914366960525513,
        "    circ = 2 * 3.14 * radius\n    return circ"
      ],
      [
        0.8910186290740967,
        "    radius = ''.join(filter(str.isdigit, radius))\n    if not radius.isdigit():\n        return 'Error: Invalid radius input'\n    radius = float(radius)\n    circumference = 2 * math.pi * radius\n    return circumference"
      ]
    ],
    "MBPP/102": [
      [
        0.9220234751701355,
        "    try:\n        int(string)\n        return True\n    except ValueError:\n        return False"
      ],
      [
        0.9220234751701355,
        "    try:\n        int(string)\n        return True\n    except ValueError:\n        return False"
      ],
      [
        0.9215967059135437,
        "    for i in range(0, len(str)):\n        if str[i].isdigit() == False:\n            return False\n    return True"
      ],
      [
        0.9170644283294678,
        "    try:\n        num = int(input)\n    except ValueError:\n        return False\n    return True"
      ],
      [
        0.9165903925895691,
        "    try:\n        int(s)\n        return True\n    except ValueError:\n        return False"
      ],
      [
        0.9165903925895691,
        "    try:\n        int(s)\n        return True\n    except ValueError:\n        return False"
      ],
      [
        0.9157981872558594,
        "    for c in string:\n        if not c.isdigit():\n            return False\n    return True"
      ],
      [
        0.9151633381843567,
        "    for i in range(0, len(str)):\n        if str[i].isdigit() == False:\n            return False"
      ],
      [
        0.9145486950874329,
        "    for i in range(len(string)):\n        if not string[i].isdigit():\n            return False\n    return True"
      ],
      [
        0.9139341115951538,
        "    pattern = '^[0-9]+$'\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False"
      ]
    ],
    "MBPP/103": [
      [
        0.9065843224525452,
        "    for i in range(0, len(frequency_list)):\n        frequency_list[i] = (frequency_list[i], my_list.count(frequency_list[i]))"
      ],
      [
        0.9012141823768616,
        "    frequency_list = []\n    for item in my_list:\n        if item not in frequency_list:\n            frequency_list.append(item)\n    for i in range(0, len(frequency_list)):\n        frequency_list[i] = (frequency_list[i], my_list.count(frequency_list[i]))\n    return frequency_list"
      ],
      [
        0.8946806788444519,
        "    word_freq_dict = {}\n    for word, freq in word_tuples:\n        if word in word_freq_dict:\n            word_freq_dict[word] += freq\n        else:\n            word_freq_dict[word] = freq\n    return word_freq_dict"
      ],
      [
        0.8928815722465515,
        "    freq_dict = {}\n    for item in list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict"
      ],
      [
        0.8916035294532776,
        "    frequency = {}\n    for item in my_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency"
      ],
      [
        0.8911077976226807,
        "    freq = {}\n    for element in lst:\n        if element in freq:\n            freq[element] += 1\n        else:\n            freq[element] = 1\n    return freq"
      ],
      [
        0.8907713294029236,
        "    frequency_dict = {}\n    for element in lst:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict"
      ],
      [
        0.8898603320121765,
        "    frequency = {}\n    for i in lst:\n        if i in frequency:\n            frequency[i] += 1\n        else:\n            frequency[i] = 1\n    return frequency"
      ],
      [
        0.8895935416221619,
        "    for item in list:\n        if item not in freq:\n            freq[item] = 1\n        else:\n            freq[item] += 1"
      ],
      [
        0.8895878791809082,
        "    for item in list:\n        if item not in freq:\n            freq[item] = 1\n        else:\n            freq[item] += 1"
      ]
    ],
    "MBPP/104": [
      [
        0.9123679399490356,
        "    if dictionary:\n        for key, value in dictionary.items():\n            if isinstance(value, dict):\n                if check_empty_dict(value) == False:\n                    return False\n            else:\n                return False\n        return True\n    else:\n        return True"
      ],
      [
        0.9123679399490356,
        "    if dictionary:\n        for key, value in dictionary.items():\n            if isinstance(value, dict):\n                if check_empty_dict(value) == False:\n                    return False\n            else:\n                return False\n        return True\n    else:\n        return True"
      ],
      [
        0.9123556613922119,
        "    if dictionary:\n        for key, value in dictionary.items():\n            if isinstance(value, dict):\n                if check_empty_dict(value) == False:\n                    return False\n            else:\n                return False\n        return True\n    else:\n        return True"
      ],
      [
        0.9123556613922119,
        "    if dictionary:\n        for key, value in dictionary.items():\n            if isinstance(value, dict):\n                if check_empty_dict(value) == False:\n                    return False\n            else:\n                return False\n        return True\n    else:\n        return True"
      ],
      [
        0.9072432518005371,
        "        for key, value in dictionary.items():\n            if isinstance(value, dict):\n                if check_empty_dict(value) == False:\n                    return False\n            else:\n                return False"
      ],
      [
        0.9072311520576477,
        "        for key, value in dictionary.items():\n            if isinstance(value, dict):\n                if check_empty_dict(value) == False:\n                    return False\n            else:\n                return False"
      ],
      [
        0.9070345163345337,
        "    if isinstance(nested_list, list):\n        if not nested_list:\n            return True\n        else:\n            return all((check_empty_nested_list(sub_list) for sub_list in nested_list))\n    else:\n        return False"
      ],
      [
        0.9070345163345337,
        "    if isinstance(nested_list, list):\n        if not nested_list:\n            return True\n        else:\n            return all((check_empty_nested_list(sub_list) for sub_list in nested_list))\n    else:\n        return False"
      ],
      [
        0.9061027765274048,
        "    elif not input_dict:\n        return 'The dictionary is empty.'\n    else:\n        return 'The dictionary is not empty.'"
      ],
      [
        0.9025170207023621,
        "        if not nested_list:\n            return True\n        else:\n            return all((check_empty_nested_list(sub_list) for sub_list in nested_list))"
      ]
    ],
    "MBPP/105": [
      [
        0.8866246938705444,
        "        elif isinstance(i, int):\n            if i < 0:\n                return 'Error: Negative number in tuple.'\n            else:\n                lst.append(math.factorial(i))\n        else:\n            return 'Error: Tuple contains non-integer element.'"
      ],
      [
        0.8865193128585815,
        "    number = 0\n    for integer in list_of_ints:\n        number = number * 10 + integer\n    return number"
      ],
      [
        0.8844189643859863,
        "    return int(''.join((str(e) for e in int_list)))"
      ],
      [
        0.8835376501083374,
        "    if len(arr) == 0:\n        return 1\n    return eval('*'.join(map(str, arr)))"
      ],
      [
        0.8831291198730469,
        "    for i in tup:\n        if isinstance(i, tuple):\n            result = factorial_tuple(i, lst)\n            if isinstance(result, str):\n                return result\n        else:\n            fact = factorial(i)\n            if fact is None:\n                return f\"Error: Invalid input '{i}' in tuple\"\n            else:\n                lst.append(fact)"
      ],
      [
        0.8829628229141235,
        "            if not isinstance(i, int):\n                return 'Error: Non-integer input in tuple'"
      ],
      [
        0.8823133707046509,
        "            if i < 0:\n                return 'Error: Negative number in tuple.'\n            else:\n                lst.append(math.factorial(i))"
      ],
      [
        0.882286012172699,
        "    if not isinstance(t, tuple):\n        raise ValueError('The input should be a tuple.')\n    for element in t:\n        if not isinstance(element, int):\n            raise ValueError('All elements in the tuple should be integers.')\n    reversed_tuple = ()\n    for i in range(len(t) - 1, -1, -1):\n        reversed_tuple += (t[i],)\n    return reversed_tuple"
      ],
      [
        0.8822718858718872,
        "    if not isinstance(t, tuple):\n        raise ValueError('The input should be a tuple.')\n    for element in t:\n        if not isinstance(element, int):\n            raise ValueError('All elements in the tuple should be integers.')\n    reversed_tuple = ()\n    for i in range(len(t) - 1, -1, -1):\n        reversed_tuple += (t[i],)\n    return reversed_tuple"
      ],
      [
        0.882269024848938,
        "        if isinstance(i, tuple):\n            error_message = factorial_tuple(i, lst)\n            if error_message:\n                return error_message\n        elif isinstance(i, int):\n            if i < 0:\n                return 'Error: Negative number in tuple.'\n            else:\n                lst.append(math.factorial(i))\n        else:\n            return 'Error: Tuple contains non-integer element.'"
      ]
    ],
    "MBPP/106": [
      [
        0.915752649307251,
        "    float_list = []\n    for x in input_list:\n        try:\n            float_list.append(float(x))\n        except ValueError:\n            print(f\"Error: '{x}' cannot be converted to a float\")\n    return float_list"
      ],
      [
        0.9034278392791748,
        "    for i in range(len(lst)):\n        try:\n            lst[i] = float(lst[i])\n        except ValueError:\n            continue"
      ],
      [
        0.9016536474227905,
        "    for i in range(len(lst)):\n        if type(lst[i]) == str:\n            try:\n                lst[i] = float(lst[i])\n            except ValueError:\n                pass"
      ],
      [
        0.9015383124351501,
        "    floats = []\n    for s in str_list:\n        floats.append(float(s))\n    return floats"
      ],
      [
        0.900789201259613,
        "    for x in input_list:\n        try:\n            float_list.append(float(x))\n        except ValueError:\n            print(f\"Error: '{x}' cannot be converted to a float\")"
      ],
      [
        0.9005160331726074,
        "    return [float(i) for i in list_]"
      ],
      [
        0.8999524712562561,
        "    list_numbers = []\n    for x in list_strings:\n        a = float(x)\n        list_numbers.append(a)\n    return list_numbers"
      ],
      [
        0.8925843238830566,
        "    for i in range(len(l)):\n        if type(l[i]) == str:\n            try:\n                l[i] = float(l[i])\n            except ValueError:\n                pass"
      ],
      [
        0.8925673961639404,
        "    new_list = []\n    for item in lst:\n        try:\n            if isinstance(item, bool):\n                new_list.append(int(item))\n            else:\n                new_list.append(int(float(item)))\n        except (TypeError, ValueError):\n            new_list.append(-1)\n    return new_list"
      ],
      [
        0.8925145864486694,
        "    for item in l:\n        if not isinstance(item, (int, float)):\n            try:\n                converted_list.append(float(item))\n            except (ValueError, TypeError):\n                converted_list.append(None)\n        else:\n            converted_list.append(item)"
      ]
    ],
    "MBPP/107": [
      [
        0.9168053269386292,
        "    return [char for char in string]"
      ],
      [
        0.9141913652420044,
        "    char_list = []\n    for character in string:\n        char_list.append(character)\n    return char_list"
      ],
      [
        0.9112480878829956,
        "    charList = []\n    for char in string:\n        charList.append(char)\n    return charList"
      ],
      [
        0.9105046987533569,
        "    char_list = []\n    for char in string:\n        char_list.append(char)\n    return char_list"
      ],
      [
        0.9103701710700989,
        "    l = []\n    for c in s:\n        l.append(c)\n    return l"
      ],
      [
        0.9094976782798767,
        "    result = []\n    for character in string:\n        result.append(character)\n    return result"
      ],
      [
        0.9093276262283325,
        "    return list(input_string)"
      ],
      [
        0.9093194007873535,
        "    return list(input_string)"
      ],
      [
        0.9093133807182312,
        "    return list(input_string)"
      ],
      [
        0.9092049598693848,
        "    result = []\n    for i in range(len(string)):\n        result.append(string[i])\n    return result"
      ]
    ],
    "MBPP/108": [
      [
        0.9118441939353943,
        "    freq_count = [0] * len(array)\n    for i in range(len(array)):\n        if freq_count[array[i]] == 1:\n            return array[i]\n        else:\n            freq_count[array[i]] += 1\n    return None"
      ],
      [
        0.9104114770889282,
        "    count = {}\n    for num in lst:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    for num in lst:\n        if count[num] == 1:\n            return num"
      ],
      [
        0.9100409746170044,
        "    counts = Counter(arr)\n    for num in arr:\n        if counts[num] == 1:\n            return num\n    return None"
      ],
      [
        0.908836305141449,
        "    number_count = {}\n    for num in arr:\n        if num not in number_count:\n            number_count[num] = 1\n        else:\n            number_count[num] += 1\n    for key, value in number_count.items():\n        if value == 1:\n            return key"
      ],
      [
        0.9079709053039551,
        "    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    for num in arr:\n        if freq[num] == 1:\n            return num\n    return None"
      ],
      [
        0.9079073667526245,
        "    for i in range(len(arr)):\n        for j in range(i, len(arr)):\n            if arr[i] < arr[j]:\n                arr[i], arr[j] = (arr[j], arr[i])\n    unique_elements = []\n    for num in arr:\n        if num not in unique_elements:\n            unique_elements.append(num)\n    if len(unique_elements) < 2:\n        return 'Error: Less than 2 unique elements'\n    else:\n        return unique_elements[1]"
      ],
      [
        0.9077256917953491,
        "    dictionary = {}\n    for num in arr:\n        if num not in dictionary:\n            dictionary[num] = 1\n        else:\n            dictionary[num] += 1\n    for key, value in dictionary.items():\n        if value == 1:\n            return key"
      ],
      [
        0.9073616862297058,
        "    counter = dict()\n    for num in A:\n        if num not in counter:\n            counter[num] = 1\n        else:\n            counter[num] += 1\n    for num in sorted(A, reverse=True):\n        if counter[num] == 1:\n            return num\n    return -1"
      ],
      [
        0.9073085784912109,
        "    d = {}\n    for i in arr:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n    for key, value in d.items():\n        if value == 1:\n            return key\n    return -1"
      ],
      [
        0.9064387083053589,
        "    count_dict = {}\n    for element in arr:\n        if element in count_dict:\n            count_dict[element] += 1\n        else:\n            count_dict[element] = 1\n    for element, count in count_dict.items():\n        if count == 1:\n            return arr.index(element)\n    return -1"
      ]
    ],
    "MBPP/109": [
      [
        0.9108669757843018,
        "    for pair in combinations(lst, 2):\n        product = pair[0] * pair[1]\n        if product > max_product:\n            max_product = product\n            max_pair = pair"
      ],
      [
        0.9096786975860596,
        "    if len(lst) < 2:\n        return None\n    max_product = float('-inf')\n    max_pair = None\n    for pair in combinations(lst, 2):\n        product = pair[0] * pair[1]\n        if product > max_product:\n            max_product = product\n            max_pair = pair\n    return list(max_pair)"
      ],
      [
        0.9071627855300903,
        "    max_product = float('-inf')\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] * lst[j] > max_product:\n                max_product = lst[i] * lst[j]\n                pair = (lst[i], lst[j])\n    return pair"
      ],
      [
        0.9058259129524231,
        "    max_product = float('-inf')\n    max_lists = []\n    for lst in list_of_lists:\n        flat_list = list(flatten(lst))\n        if flat_list:\n            temp_product = float(product(flat_list))\n            if temp_product > max_product:\n                max_product = temp_product\n                max_lists = [flat_list]\n            elif temp_product == max_product:\n                max_lists.append(flat_list)\n    return (max_product, max_lists)"
      ],
      [
        0.9057348966598511,
        "        if product > max_product:\n            max_product = product\n            max_pair = pair"
      ],
      [
        0.9048483371734619,
        "    if not lst:\n        return []\n    possible_pairs = [[lst[i], lst[j]] for i in range(len(lst)) for j in range(i + 1, len(lst))]\n    products = [pair[0] * pair[1] for pair in possible_pairs]\n    max_product = max(products)\n    return [possible_pairs[i] for i in range(len(products)) if products[i] == max_product]"
      ]
    ],
    "MBPP/110": [
      [
        0.9250504374504089,
        "    found = False\n    for i in range(0, len(arr) - 2):\n        for j in range(i + 1, len(arr) - 1):\n            for k in range(j + 1, len(arr)):\n                if arr[i] + arr[j] + arr[k] == 0:\n                    print('Found triplets ' + str(arr[i]) + ', ' + str(arr[j]) + ', ' + str(arr[k]))\n                    found = True\n    if found == False:\n        print('No Triplets found')"
      ],
      [
        0.9188776016235352,
        "                if array[i] + array[j] + array[k] == target_sum:\n                    triplets.append([array[i], array[j], array[k]])"
      ],
      [
        0.9167721271514893,
        "    for i in range(0, len(arr) - 2):\n        for j in range(i + 1, len(arr) - 1):\n            for k in range(j + 1, len(arr)):\n                if arr[i] + arr[j] + arr[k] == 0:\n                    print('Found triplets ' + str(arr[i]) + ', ' + str(arr[j]) + ', ' + str(arr[k]))\n                    found = True"
      ],
      [
        0.9159861207008362,
        "    array.sort()\n    triplets = []\n    for i in range(len(array)):\n        for j in range(i + 1, len(array)):\n            for k in range(j + 1, len(array)):\n                if array[i] + array[j] + array[k] == target_sum:\n                    triplets.append([array[i], array[j], array[k]])\n    return triplets"
      ],
      [
        0.9154179096221924,
        "    triplets = []\n    n = len(array)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if array[i] + array[j] + array[k] == target:\n                    triplets.append((array[i], array[j], array[k]))\n    return triplets"
      ],
      [
        0.9149442315101624,
        "            for k in range(j + 1, len(arr)):\n                if arr[i] + arr[j] + arr[k] == 0:\n                    print('Found triplets ' + str(arr[i]) + ', ' + str(arr[j]) + ', ' + str(arr[k]))\n                    found = True"
      ],
      [
        0.9140879511833191,
        "    arr.sort()\n    triplets = []\n    for i in range(0, len(arr) - 2):\n        l = i + 1\n        r = len(arr) - 1\n        while l < r:\n            if arr[i] + arr[l] + arr[r] == sum:\n                triplets.append([arr[i], arr[l], arr[r]])\n                l += 1\n                r -= 1\n            elif arr[i] + arr[l] + arr[r] < sum:\n                l += 1\n            else:\n                r -= 1\n    return triplets"
      ],
      [
        0.9140818119049072,
        "    for i in range(len(array)):\n        for j in range(i + 1, len(array)):\n            for k in range(j + 1, len(array)):\n                if array[i] + array[j] + array[k] == target_sum:\n                    triplets.append([array[i], array[j], array[k]])"
      ]
    ],
    "MBPP/111": [
      [
        0.8977925181388855,
        "    return findNthPolite(n)"
      ],
      [
        0.8977662324905396,
        "    return findNthPolite(n)"
      ],
      [
        0.8908370137214661,
        "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n)"
      ],
      [
        0.8908370137214661,
        "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n)"
      ],
      [
        0.8876878619194031,
        "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n) + nth_prime(n)"
      ],
      [
        0.8876878619194031,
        "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n) + nth_prime(n)"
      ],
      [
        0.8854479789733887,
        "    for i in range(2, n):\n        newNumber = prevNumber + currentNumber\n        prevNumber = currentNumber\n        currentNumber = newNumber"
      ],
      [
        0.8853105306625366,
        "    count = 0\n    num1, num2 = (0, 1)\n    while count < n:\n        fib_num = num1 + num2\n        if is_prime(fib_num):\n            count += 1\n        num1, num2 = (num2, fib_num)\n    return num2"
      ],
      [
        0.8851787447929382,
        "    if n == 1:\n        return 169"
      ],
      [
        0.8848992586135864,
        "    if n in [0, 1]:\n        return n"
      ]
    ],
    "MBPP/112": [
      [
        0.9043622612953186,
        "    amicable_pairs = []\n    for i in range(2, n + 1):\n        divisors_sum = sum(find_divisors(i))\n        if i != divisors_sum and sum(find_divisors(divisors_sum)) == i:\n            if sorted([i, divisors_sum]) not in amicable_pairs:\n                amicable_pairs.append(sorted([i, divisors_sum]))\n    return amicable_pairs"
      ],
      [
        0.8974796533584595,
        "    for i in range(2, n + 1):\n        divisors_sum = sum(find_divisors(i))\n        if i != divisors_sum and sum(find_divisors(divisors_sum)) == i:\n            if sorted([i, divisors_sum]) not in amicable_pairs:\n                amicable_pairs.append(sorted([i, divisors_sum]))"
      ],
      [
        0.8925368189811707,
        "    aliquot_sum = 0\n    for i in range(1, number):\n        if number % i == 0:\n            aliquot_sum += i\n    return aliquot_sum"
      ],
      [
        0.890262246131897,
        "            if sorted([i, divisors_sum]) not in amicable_pairs:\n                amicable_pairs.append(sorted([i, divisors_sum]))"
      ],
      [
        0.8897556066513062,
        "    for number in range(limit + 1):\n        sum = sum + number"
      ],
      [
        0.8896053433418274,
        "        if i != divisors_sum and sum(find_divisors(divisors_sum)) == i:\n            if sorted([i, divisors_sum]) not in amicable_pairs:\n                amicable_pairs.append(sorted([i, divisors_sum]))"
      ],
      [
        0.8889552354812622,
        "    for i in range(1, number):\n        if number % i == 0:\n            sum += i"
      ],
      [
        0.8886860609054565,
        "    sum = 0\n    for number in range(limit + 1):\n        sum = sum + number\n    return sum"
      ],
      [
        0.8874677419662476,
        "    sum = n * (n + 1) / 2\n    return sum"
      ],
      [
        0.887457549571991,
        "    sum_number = 0\n    for num in range(1, number + 1):\n        sum_number += num\n    return sum_number"
      ]
    ],
    "MBPP/113": [
      [
        0.8908109664916992,
        "    magnitude = abs(z)\n    angle = math.phase(z)\n    return (magnitude, angle)"
      ],
      [
        0.8902772665023804,
        "    r = Abs(num)\n    theta = arg(num)\n    return complex(r * cos(theta), r * sin(theta))"
      ],
      [
        0.888110876083374,
        "    real = magnitude * math.cos(angle)\n    imaginary = magnitude * math.sin(angle)\n    return (real, imaginary)"
      ],
      [
        0.8866607546806335,
        "    abs_diff = abs(num1 - num2)\n    rad_angle = cmath.phase(num1) - cmath.phase(num2)\n    deg_angle = math.degrees(rad_angle)\n    return (abs_diff, deg_angle)"
      ],
      [
        0.8745326399803162,
        "    return 180 - angle"
      ],
      [
        0.8720937371253967,
        "    if imag == 0.0 and real == 0.0:\n        return complex_zero"
      ],
      [
        0.8707728981971741,
        "        if num.is_Polar:\n            c_num = polarToComplex(num)\n        else:\n            c_num = cartesianToComplex(num)"
      ],
      [
        0.8691363334655762,
        "    return x.imag"
      ],
      [
        0.8685915470123291,
        "    if isinstance(c, complex):\n        return (c.real, c.imag)\n    return (c, 0)"
      ],
      [
        0.8677178621292114,
        "    complex_num1 = complex(a1, b1)\n    complex_num2 = complex(a2, b2)\n    diff = complex_num1 - complex_num2\n    modulus = abs(diff)\n    return modulus"
      ]
    ],
    "MBPP/114": [
      [
        0.9054516553878784,
        "    for c in s:\n        if c == '1':\n            current_ones += 1\n            current_zeros = 0\n        else:\n            current_zeros += 1\n            current_ones = 0\n        max_ones = max(max_ones, current_ones)\n        max_zeros = max(max_zeros, current_zeros)"
      ],
      [
        0.9054420590400696,
        "    for c in s:\n        if c == '1':\n            current_ones += 1\n            current_zeros = 0\n        else:\n            current_zeros += 1\n            current_ones = 0\n        max_ones = max(max_ones, current_ones)\n        max_zeros = max(max_zeros, current_zeros)"
      ],
      [
        0.9033670425415039,
        "    max_len = 0\n    cur_len = 0\n    for bit in binary_str:\n        if bit == '1':\n            cur_len += 1\n        elif bit == '0':\n            if cur_len > max_len:\n                max_len = cur_len\n            cur_len = 0\n    return max_len"
      ],
      [
        0.9028051495552063,
        "    maxLength = 0\n    count = 0\n    for i in range(len(inpString)):\n        if inpString[i] == '1':\n            count += 1\n        else:\n            if count > maxLength:\n                maxLength = count\n            count = 0\n    if count > maxLength:\n        maxLength = count\n    return maxLength"
      ],
      [
        0.9004928469657898,
        "    for bit in binary_str:\n        if bit == '1':\n            cur_len += 1\n        elif bit == '0':\n            if cur_len > max_len:\n                max_len = cur_len\n            cur_len = 0"
      ],
      [
        0.9004883766174316,
        "    for i in range(len(binary_string)):\n        if binary_string[i] == '0':\n            if start == -1:\n                start = i\n        elif start != -1:\n            length = i - start\n            if length > max_length:\n                max_start = start\n                max_length = length\n            start = -1"
      ],
      [
        0.8991833925247192,
        "    max_score = 0\n    max_substrings = 0\n    for i in range(1, len(s)):\n        left = s[:i]\n        right = s[i:]\n        if '000' in left or '111' in left:\n            continue\n        score = left.count('0') + right.count('1')\n        substrings = right.split('0')\n        substrings = sum((1 for sub in substrings if sub.startswith('1') and sub.endswith('1')))\n        if score > max_score:\n            max_score = score\n            max_substrings = substrings\n        elif score == max_score:\n            max_substrings = max(max_substrings, substrings)\n    return [max_score, max_substrings]"
      ],
      [
        0.8987106680870056,
        "    for char in s:\n        if char == '1':\n            current_count += 1\n            max_count = max(max_count, current_count)\n        else:\n            current_count = 0"
      ],
      [
        0.8975120186805725,
        "        if char == '1':\n            current_count += 1\n            max_count = max(max_count, current_count)\n        else:\n            current_count = 0"
      ],
      [
        0.8973971009254456,
        "        if bit == '1':\n            cur_len += 1\n        elif bit == '0':\n            if cur_len > max_len:\n                max_len = cur_len\n            cur_len = 0"
      ]
    ],
    "MBPP/115": [
      [
        0.8969346880912781,
        "    gcd = 1\n    for i in range(1, min(num1, num2) + 1):\n        if num1 % i == 0 and num2 % i == 0:\n            gcd = i\n    common_factors = [i for i in range(1, gcd + 1) if gcd % i == 0]\n    return common_factors"
      ],
      [
        0.8958377838134766,
        "    gcd_value = math.gcd(a, b)\n    lcm_value = abs(a * b) / gcd_value\n    return (gcd_value, lcm_value)"
      ],
      [
        0.895796537399292,
        "    gcd = 1\n    if num1 < num2:\n        small = num1\n    else:\n        small = num2\n    for i in range(1, small + 1):\n        if num1 % i == 0 and num2 % i == 0:\n            gcd = i\n    return gcd"
      ],
      [
        0.8951839208602905,
        "    if num2 == 0:\n        return num1\n    return greatest_common_divisor(num2, num1 % num2)"
      ],
      [
        0.8944165110588074,
        "    divisors = []\n    for i in range(1, min(a, b) + 1):\n        if a % i == 0 and b % i == 0:\n            divisors.append(i)\n    return len(divisors)"
      ],
      [
        0.8935210108757019,
        "    lcm = math.lcm(a, b)\n    gcd = math.gcd(a, b)\n    return (lcm, gcd)"
      ],
      [
        0.89250248670578,
        "    return math.gcd(n1, n2)"
      ],
      [
        0.8916451930999756,
        "    smaller_number = min(A, B)\n    prime_factors = []\n    for i in range(2, int(math.sqrt(smaller_number)) + 1):\n        while smaller_number % i == 0:\n            prime_factors.append(i)\n            smaller_number //= i\n    if smaller_number > 1:\n        prime_factors.append(smaller_number)\n    largest_common_divisor = 1\n    for prime_factor in prime_factors:\n        if A % prime_factor == 0 and B % prime_factor == 0:\n            largest_common_divisor *= prime_factor\n    return largest_common_divisor"
      ],
      [
        0.8913954496383667,
        "    smallest = min(A, B)\n    largest_divisor = 1\n    for i in range(1, smallest + 1):\n        if A % i == 0 and B % i == 0:\n            largest_divisor = i\n    return largest_divisor"
      ]
    ],
    "MBPP/116": [
      [
        0.9086955785751343,
        "    if y == 0:\n        return 0\n    if y < 0:\n        return -multiply(x, -y)\n    if x < 0:\n        return -multiply(-x, y)\n    if y % 1 != 0 or x % 1 != 0:\n        return float(x) * float(y)\n    if x > 1000000 or y > 1000000:\n        return x * y\n    return (x << int(y - 1).bit_length()) + multiply(x, y - (1 << int(y - 1).bit_length()))"
      ]
    ],
    "MBPP/117": [
      [
        0.9383945465087891,
        "    return [w for w in word_list if len(w) > n]"
      ],
      [
        0.9340401887893677,
        "    return [word for word in words if len(word) >= n]"
      ],
      [
        0.9312149882316589,
        "    for word in words:\n        if len(word) > n:\n            print(word)"
      ],
      [
        0.9238461256027222,
        "    new_list = [word for word in word_list if len(word) > 5]\n    return new_list"
      ],
      [
        0.9213696122169495,
        "    filtered_words = []\n    for word in words:\n        if len(word) > condition:\n            filtered_words.append(word)\n    return filtered_words"
      ],
      [
        0.9191796183586121,
        "    words = text.split()\n    unique_words = set(words)\n    long_words = [word for word in unique_words if len(word) > n]\n    return long_words"
      ],
      [
        0.9189049005508423,
        "    new_list = []\n    for word in lst:\n        if len(word) > 3:\n            new_list.append(word)\n    return new_list"
      ],
      [
        0.9187384843826294,
        "    filtered_words = []\n    for word in words:\n        if len(word) > 5:\n            filtered_words.append(word)\n    return filtered_words"
      ],
      [
        0.9184577465057373,
        "        if len(word) > n:\n            long_words.append(word)\n        else:\n            short_words.append(word)"
      ],
      [
        0.9167727828025818,
        "    filtered_words = []\n    for word in words:\n        if len(word) > 3:\n            filtered_words.append(word)\n    return filtered_words"
      ]
    ],
    "MBPP/118": [
      [
        0.9014210104942322,
        "    while num <= n * n:\n        magic_square[i][j] = num\n        i -= 1\n        j += 1\n        if i < 0:\n            i = n - 1\n        if j >= n:\n            j = 0\n        if magic_square[i][j] != 0:\n            i += 1\n            j -= 1\n        num += 1"
      ],
      [
        0.8981744050979614,
        "    magic_square = [[0] * n for _ in range(n)]\n    i = 0\n    j = n // 2\n    num = 1\n    while num <= n * n:\n        magic_square[i][j] = num\n        i -= 1\n        j += 1\n        if i < 0:\n            i = n - 1\n        if j >= n:\n            j = 0\n        if magic_square[i][j] != 0:\n            i += 1\n            j -= 1\n        num += 1\n    return magic_square"
      ],
      [
        0.895277738571167,
        "    for row in magic_square:\n        print(' '.join((str(x).rjust(len(str(n * n))) for x in row)))"
      ],
      [
        0.8923771381378174,
        "        if magic_square[i][j] != 0:\n            i += 1\n            j -= 1"
      ],
      [
        0.891608715057373,
        "    while num <= n * n:\n        magic_square[i][j] = num\n        num += 1\n        newi, newj = ((i - 1) % n, (j + 1) % n)\n        if magic_square[newi][newj]:\n            i += 1\n        else:\n            i, j = (newi, newj)"
      ],
      [
        0.8876791596412659,
        "    sum_value = calculate_sum(matrix)\n    return check_prime(sum_value)"
      ],
      [
        0.8854791522026062,
        "    if sum((matrix[i][i] for i in range(size))) != magic_constant or sum((matrix[i][size - i - 1] for i in range(size))) != magic_constant:\n        return False"
      ],
      [
        0.8845279812812805,
        "        if magic_square[newi][newj]:\n            i += 1\n        else:\n            i, j = (newi, newj)"
      ],
      [
        0.8844475150108337,
        "    for i in range(size):\n        if sum(matrix[i]) != magic_constant or sum([row[i] for row in matrix]) != magic_constant:\n            return False"
      ],
      [
        0.8840947151184082,
        "    matrix = [m[:] for m in matrix]\n    size = len(matrix)\n    magic_constant = sum(matrix[0])\n    for i in range(size):\n        if sum(matrix[i]) != magic_constant or sum([row[i] for row in matrix]) != magic_constant:\n            return False\n    if sum((matrix[i][i] for i in range(size))) != magic_constant or sum((matrix[i][size - i - 1] for i in range(size))) != magic_constant:\n        return False\n    return True"
      ]
    ],
    "MBPP/119": [
      [
        0.9411230087280273,
        "    counts = {}\n    for item in my_list:\n        if item in counts:\n            counts[item] += 1\n        else:\n            counts[item] = 1\n    max_frequency = 0\n    max_item = None\n    for item in counts:\n        if counts[item] > max_frequency:\n            max_frequency = counts[item]\n            max_item = item\n    return max_item"
      ],
      [
        0.9380264282226562,
        "    max_count = 0\n    max_item = None\n    dict = {}\n    for item in list:\n        if item in dict:\n            dict[item] += 1\n        else:\n            dict[item] = 1\n    for key, value in dict.items():\n        if value > max_count:\n            max_count = value\n            max_item = key\n    return max_item"
      ],
      [
        0.9375565052032471,
        "    frequency_dict = {}\n    max_count = 0\n    max_item = None\n    for item in input_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n        if frequency_dict[item] > max_count:\n            max_count = frequency_dict[item]\n            max_item = item\n    return (max_item, max_count)"
      ],
      [
        0.9369833469390869,
        "    freq_dict = {}\n    for item in lst:\n        freq_dict[item] = freq_dict.get(item, 0) + 1\n    max_count = 0\n    max_item = lst[0]\n    for key, value in freq_dict.items():\n        if value > max_count:\n            max_count = value\n            max_item = key\n    return max_item"
      ],
      [
        0.935531497001648,
        "    frequency = {}\n    most_frequent_item = None\n    max_frequency = 0\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n        if frequency[item] > max_frequency:\n            max_frequency = frequency[item]\n            most_frequent_item = item\n    return most_frequent_item"
      ],
      [
        0.9352599382400513,
        "    max_frequency = 0\n    most_frequent_item = None\n    for item in input_list:\n        frequency = input_list.count(item)\n        if frequency > max_frequency:\n            max_frequency = frequency\n            most_frequent_item = item\n    return most_frequent_item"
      ],
      [
        0.9343314170837402,
        "    max_count = -1\n    max_item = None\n    count = {}\n    for item in lst:\n        if item in count:\n            count[item] += 1\n        else:\n            count[item] = 1\n        if count[item] > max_count:\n            max_count = count[item]\n            max_item = item\n    return max_item"
      ],
      [
        0.9338744282722473,
        "    frequency_dict = {}\n    for item in input_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    most_frequent_item = max(frequency_dict, key=frequency_dict.get)\n    return most_frequent_item"
      ],
      [
        0.933148980140686,
        "    max_count = -1\n    max_item = None\n    counts = {}\n    for item in lst:\n        if item not in counts:\n            counts[item] = 0\n        counts[item] += 1\n        if counts[item] > max_count:\n            max_count = counts[item]\n            max_item = item\n    return max_item"
      ],
      [
        0.9331010580062866,
        "    freq = {}\n    for item in list:\n        if item not in freq:\n            freq[item] = 1\n        else:\n            freq[item] += 1\n    max_freq = -1\n    for key in freq.keys():\n        if freq[key] > max_freq:\n            max_freq = freq[key]\n            res = key\n    return res"
      ]
    ],
    "MBPP/120": [
      [
        0.9315897226333618,
        "    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    reverse_string = ''\n    for char in reversed(string):\n        if char not in vowels:\n            reverse_string += char\n    return reverse_string"
      ],
      [
        0.9278151988983154,
        "    vowels = 'aeiouAEIOU'\n    replaced = ''.join([char if c in vowels else c for c in string])\n    return replaced[::-1]"
      ],
      [
        0.9271721839904785,
        "    vowels = ['a', 'e', 'i', 'o', 'u']\n    output_str = ''\n    for letter in input_str:\n        if letter not in vowels:\n            output_str += letter\n    return output_str[::-1]"
      ],
      [
        0.9270474314689636,
        "    vowels = 'aeiouAEIOU'\n    result = ''\n    for char in string:\n        if char not in vowels:\n            result += char\n    return result[::-1]"
      ],
      [
        0.9257559180259705,
        "    vowels = ['A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u']\n    output = ''\n    for char in string:\n        if char not in vowels:\n            output += char\n    return output[::-1]"
      ],
      [
        0.9248135089874268,
        "    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    reversed_string = ''\n    for char in original_string[::-1]:\n        if char not in vowels:\n            reversed_string += char\n    return reversed_string"
      ],
      [
        0.9244412779808044,
        "    vowels = reverse_vowels(paragraph, len(paragraph) - 1)\n    vowels = list(dict.fromkeys(vowels))\n    print(' '.join(vowels))"
      ],
      [
        0.9238820672035217,
        "    vowels = ['a', 'e', 'i', 'o', 'u']\n    consonants = []\n    for char in string:\n        if char.lower() not in vowels and char.isalpha():\n            consonants.append(char)\n    consonants.reverse()\n    reversed_string = ''\n    consonant_index = 0\n    for char in string:\n        if char.lower() not in vowels and char.isalpha():\n            reversed_string += consonants[consonant_index]\n            consonant_index += 1\n        else:\n            reversed_string += char\n    return reversed_string"
      ],
      [
        0.9226611852645874,
        "    vowels = ['a', 'e', 'i', 'o', 'u']\n    result = ''\n    for char in text:\n        if char.lower() in vowels:\n            result += char.lower()\n    return result[::-1]"
      ],
      [
        0.9215604662895203,
        "    for char in reversed(string):\n        if char not in vowels:\n            reverse_string += char"
      ]
    ],
    "MBPP/121": [
      [
        0.9010260105133057,
        "    if not tup:\n        return 'Error: Tuple is empty.'"
      ],
      [
        0.8996692299842834,
        "    if not tup:\n        return 'Error: Tuple is empty'"
      ],
      [
        0.8980015516281128,
        "    if not input_tuple:\n        return 'Error: input is NULL or empty.'\n    str_list = []\n    for element in input_tuple:\n        if not isinstance(element, float):\n            return 'Error: all elements in the tuple should be floats.'\n        str_list.append(str(element))\n    result = '; '.join(str_list)\n    return result"
      ],
      [
        0.8968623876571655,
        "    if tup == ():\n        return 'Error: Tuple is empty'"
      ],
      [
        0.896592378616333,
        "    if not my_tuple:\n        return 'Error: Tuple is empty!'"
      ],
      [
        0.8953713178634644,
        "    if not tup:\n        return 'Error: Input tuple is empty'"
      ],
      [
        0.8953713178634644,
        "    if not tup:\n        return 'Error: Input tuple is empty'"
      ],
      [
        0.8943520188331604,
        "    if type(tup) != tuple:\n        return 'Error: Not a tuple.'"
      ],
      [
        0.8878452181816101,
        "    if len(tup) == 0:\n        return 'Error: Empty tuple'"
      ],
      [
        0.8874856233596802,
        "    string = ','.join(map(str, lst))\n    return string"
      ]
    ],
    "MBPP/122": [
      [
        0.9149158000946045,
        "    negative_nums = [num for num in numbers if num < 0]\n    return (len(negative_nums), sum(negative_nums))"
      ],
      [
        0.8992920517921448,
        "    neg_lst = []\n    for num in lst:\n        if num < 0:\n            neg_lst.append(num)\n    return neg_lst"
      ],
      [
        0.8971871733665466,
        "    total = 0\n    negative_count = 0\n    for number in list_of_numbers:\n        total += int(number)\n        if number < 0:\n            negative_count += 1\n    return f'Result: {round(total)}, Negative numbers: {negative_count}'"
      ],
      [
        0.8957844376564026,
        "    negative_elements = []\n    for x in my_list:\n        if x < 0:\n            negative_elements.append(x)\n    return negative_elements"
      ],
      [
        0.8925778865814209,
        "    input_list = [1, -2, 3, -4, 5]\n    expected_output = [-2, -4]\n    assert negative(input_list) == expected_output"
      ],
      [
        0.8903428316116333,
        "    square_list = negative_even_squares(lst)\n    return sum(square_list)"
      ],
      [
        0.8897733688354492,
        "    for number in list_of_numbers:\n        total += int(number)\n        if number < 0:\n            negative_count += 1"
      ],
      [
        0.8892818689346313,
        "    if isinstance(numbers[0], list):\n        return [[num for num in sublist if num < 0] for sublist in numbers]\n    else:\n        return [num for num in numbers if num < 0]"
      ],
      [
        0.8892818689346313,
        "    if isinstance(numbers[0], list):\n        return [[num for num in sublist if num < 0] for sublist in numbers]\n    else:\n        return [num for num in numbers if num < 0]"
      ],
      [
        0.8890563249588013,
        "    elif numbers[0] < 0:\n        return sum_positive_numbers(numbers[1:])\n    else:\n        return numbers[0] + sum_positive_numbers(numbers[1:])"
      ]
    ],
    "MBPP/123": [
      [
        0.8867087364196777,
        "    num_elements = len(arr)\n    if num_elements % 2 == 0:\n        print('The array has an even number of elements.')\n    else:\n        print('The array has an odd number of elements.')"
      ],
      [
        0.8805287480354309,
        "    if result != -1:\n        return arr[result] % 2 != 0\n    else:\n        print('Number not found in the array')\n        return False"
      ],
      [
        0.8786710500717163,
        "    odd_count, even_count = (0, 0)\n    for i in arr:\n        if i % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    print('Odd count : ', odd_count, 'Even count : ', even_count)"
      ],
      [
        0.8785127401351929,
        "    if last_digit % 2 == 0:\n        return 'Even'\n    else:\n        return 'Odd'"
      ],
      [
        0.8784864544868469,
        "    if not isinstance(large_number, str):\n        return 'Error: Input should be a string of digits'\n    if not large_number.isdigit():\n        return 'Error: Input should be all digits'\n    last_digit = int(large_number[-1])\n    if last_digit % 2 == 0:\n        return 'Even'\n    else:\n        return 'Odd'"
      ],
      [
        0.8773033618927002,
        "    for num in arr:\n        if num % 2 == 0:\n            count_even += 1\n        else:\n            break"
      ],
      [
        0.8771135807037354,
        "    result = binary_search(arr, num)\n    if result != -1:\n        return arr[result] % 2 != 0\n    else:\n        print('Number not found in the array')\n        return False"
      ],
      [
        0.8770992755889893,
        "    odd_elements = [x for x in array if x % 2 == 1]\n    return (len(odd_elements) % 2 == 1, len(odd_elements), sum(odd_elements))"
      ],
      [
        0.8753480911254883,
        "    odd_count = 0\n    for num in lst:\n        if num % 2 != 0:\n            odd_count += 1\n    return (odd_count, odd_count % 2 != 0)"
      ]
    ],
    "MBPP/124": [
      [
        0.9147540926933289,
        "    while True:\n        hexagonal = n * (2 * n - 1)\n        if isPentagonal(hexagonal):\n            return hexagonal\n        n += 1"
      ],
      [
        0.9034406542778015,
        "    n = 144\n    while True:\n        hexagonal = n * (2 * n - 1)\n        if isPentagonal(hexagonal):\n            return hexagonal\n        n += 1\n    return None"
      ],
      [
        0.9014877676963806,
        "        if isPentagonal(hexagonal):\n            return hexagonal"
      ],
      [
        0.9000658392906189,
        "        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4"
      ],
      [
        0.9000391960144043,
        "        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4"
      ],
      [
        0.8954226970672607,
        "    if type(n) != int or n < 0:\n        return 'ERROR: Invalid Input'\n    if n > 5000:\n        return 'ERROR: Input number too large'\n    if n in computed:\n        return computed[n]\n    computed[n] = n * (5 * n - 3) / 2 + heptagonal(n - 1)\n    return computed[n]"
      ],
      [
        0.8870831727981567,
        "    try:\n        assert isinstance(n, (int, float))\n        assert n >= 0\n        assert n == int(n)\n        return hex(int(n))\n    except AssertionError:\n        return 'Error: Invalid input. Please enter a non-negative integer.'"
      ],
      [
        0.8870831727981567,
        "    try:\n        assert isinstance(n, (int, float))\n        assert n >= 0\n        assert n == int(n)\n        return hex(int(n))\n    except AssertionError:\n        return 'Error: Invalid input. Please enter a non-negative integer.'"
      ],
      [
        0.8853275775909424,
        "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"
      ],
      [
        0.8853275775909424,
        "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"
      ]
    ],
    "MBPP/125": [
      [
        0.9243404865264893,
        "    rate = 0.15\n    bill = kw_usage * rate\n    return bill"
      ],
      [
        0.9217908382415771,
        "    bill = rate * consumption\n    print('Your total electricity bill is Rs. {}'.format(bill))"
      ],
      [
        0.8981921672821045,
        "    one_off_fee = one_off\n    night_rate_fee = night_rate * total_kwh\n    standard_rate_fee = standard_rate * total_kwh\n    return one_off_fee + night_rate_fee + standard_rate_fee"
      ],
      [
        0.8748081922531128,
        "    if 7 <= hour <= 10 or 16 <= hour <= 20:\n        basic_cost *= 1.15"
      ],
      [
        0.8725548982620239,
        "    cost_per_minute = 0.35\n    total_cost = cost_per_minute * call_duration\n    return total_cost"
      ],
      [
        0.8708776235580444,
        "    ELECTRICITY_EMISSIONS = 0.0005\n    GAS_EMISSIONS = 0.0053\n    VEHICLE_EMISSIONS = 0.00012\n    electricity_emissions = ELECTRICITY_EMISSIONS * electricity_consumption\n    gas_emissions = GAS_EMISSIONS * gas_consumption\n    vehicle_emissions = VEHICLE_EMISSIONS * mileage\n    total_emissions = (electricity_emissions + gas_emissions + vehicle_emissions) * 12 * num_people\n    total_emissions = total_emissions / 1000\n    return total_emissions"
      ],
      [
        0.8708698153495789,
        "    ELECTRICITY_EMISSIONS = 0.0005\n    GAS_EMISSIONS = 0.0053\n    VEHICLE_EMISSIONS = 0.00012\n    electricity_emissions = ELECTRICITY_EMISSIONS * electricity_consumption\n    gas_emissions = GAS_EMISSIONS * gas_consumption\n    vehicle_emissions = VEHICLE_EMISSIONS * mileage\n    total_emissions = (electricity_emissions + gas_emissions + vehicle_emissions) * 12 * num_people\n    total_emissions = total_emissions / 1000\n    return total_emissions"
      ],
      [
        0.8699816465377808,
        "    total_consumption = 0\n    for record in data:\n        total_consumption += record\n    average_consumption = total_consumption / len(data)\n    return average_consumption"
      ],
      [
        0.8695898056030273,
        "    if order_total < 50:\n        return 'Order total does not meet the minimum amount required to avail of discounts.'\n    total_bill = order_total\n    if num_customers <= 5:\n        total_bill *= 0.95\n    elif num_customers <= 10:\n        total_bill *= 0.9\n    else:\n        total_bill *= 0.85\n    return round(total_bill, 2)"
      ],
      [
        0.8682438731193542,
        "    elif num_customers <= 10:\n        total_bill *= 0.9\n    else:\n        total_bill *= 0.85"
      ]
    ],
    "MBPP/126": [
      [
        0.9053391218185425,
        "    count = 0\n    for num in list:\n        if num == 0:\n            count += 1\n    return count"
      ],
      [
        0.8973792195320129,
        "    for num in list:\n        if num == 0:\n            count += 1"
      ],
      [
        0.8919491171836853,
        "    binary = str(bin(n)[2:])\n    zeroes = binary.count('0')\n    ones = binary.count('1')\n    if ones == 0:\n        print('Cannot calculate the ratio with zero ones')\n        return None\n    return zeroes / ones"
      ],
      [
        0.8908119797706604,
        "    count = 0\n    for i in arr:\n        if i != 0:\n            count += 1\n    return count"
      ],
      [
        0.8885155916213989,
        "    nums = [n for n in nums if n > 0]\n    if len(nums) == 0:\n        return 0\n    total = 0\n    for num in nums:\n        total += 1 / num\n    return len(nums) / total"
      ],
      [
        0.8883742690086365,
        "    for i in arr:\n        if i != 0:\n            count += 1"
      ],
      [
        0.8871414661407471,
        "    if len(arr) == 0:\n        return 0\n    num_positive = 0\n    for num in arr:\n        if num > 0:\n            num_positive += 1\n    return num_positive / len(arr)"
      ],
      [
        0.8865721821784973,
        "    if ones == 0:\n        print('Cannot calculate the ratio with zero ones')\n        return None"
      ],
      [
        0.8838329315185547,
        "    arr.sort(reverse=True)\n    positive_count = 0\n    negative_count = 0\n    zero_count = 0\n    for number in arr:\n        category = classify_number(number)\n        if category == 'positive':\n            positive_count += 1\n        elif category == 'negative':\n            negative_count += 1\n        else:\n            zero_count += 1\n    print('Positive numbers: ', positive_count)\n    print('Negative numbers: ', negative_count)\n    print('Zeroes: ', zero_count)"
      ],
      [
        0.8833995461463928,
        "    zero_count = 0\n    for row in matrix:\n        for num in row:\n            if strict_zero:\n                if num == 0:\n                    zero_count += 1\n            elif num == 0 or num == '' or num == '0' or (num == '-0') or (num == False):\n                zero_count += 1\n    return zero_count"
      ]
    ],
    "MBPP/127": [
      [
        0.9027656316757202,
        "    if num == 0:\n        print('False')\n    elif num == 1:\n        print('True')\n    else:\n        series = ''\n        while num > 0:\n            if num & 1:\n                series = 'True ' + series\n            else:\n                series = 'False ' + series\n            num = int(num / 2)\n        print(series)"
      ],
      [
        0.9027656316757202,
        "    if num == 0:\n        print('False')\n    elif num == 1:\n        print('True')\n    else:\n        series = ''\n        while num > 0:\n            if num & 1:\n                series = 'True ' + series\n            else:\n                series = 'False ' + series\n            num = int(num / 2)\n        print(series)"
      ],
      [
        0.9015612006187439,
        "    elif num == 1:\n        print('True')\n    else:\n        series = ''\n        while num > 0:\n            if num & 1:\n                series = 'True ' + series\n            else:\n                series = 'False ' + series\n            num = int(num / 2)\n        print(series)"
      ],
      [
        0.9010086059570312,
        "    i = 1\n    while 2 ** i <= n:\n        if 2 ** i == n:\n            return True\n        i += 1\n    return False"
      ],
      [
        0.8988006711006165,
        "    if num == 1:\n        return True\n    elif num < 1:\n        return False\n    else:\n        while num % 2 == 0:\n            num /= 2\n        return num == 1"
      ],
      [
        0.8988006711006165,
        "    if num == 1:\n        return True\n    elif num < 1:\n        return False\n    else:\n        while num % 2 == 0:\n            num /= 2\n        return num == 1"
      ],
      [
        0.8985408544540405,
        "    while num != 1:\n        if num % 2 != 0:\n            return False\n        num = num // 2"
      ],
      [
        0.8985105752944946,
        "    while number > 1:\n        if number % 2 != 0:\n            return False\n        number //= 2"
      ],
      [
        0.8977659940719604,
        "    if num == 0:\n        return False\n    while num != 1:\n        if num % 2 != 0:\n            return False\n        num = num // 2\n    return True"
      ],
      [
        0.8977534770965576,
        "    return sorted(str(n)) in [sorted(str(1 << i)) for i in range(31)]"
      ]
    ],
    "MBPP/128": [
      [
        0.9331883192062378,
        "    circumference = 2 * 3.14 * radius\n    return circumference"
      ],
      [
        0.9226394891738892,
        "    circumference = 3.14 * diameter\n    return circumference"
      ],
      [
        0.9219996929168701,
        "    approximation_pi = 3.14\n    circumference = 2 * approximation_pi * radius\n    return circumference"
      ],
      [
        0.9178048968315125,
        "    radius = ''.join(filter(str.isdigit, radius))\n    radius = float(radius)\n    circumference = 2 * math.pi * radius\n    return circumference"
      ],
      [
        0.9116281867027283,
        "    radius = ''.join(filter(str.isdigit, radius))\n    if not radius.isdigit():\n        return 'Error: Invalid radius input'\n    radius = float(radius)\n    circumference = 2 * math.pi * radius\n    return circumference"
      ],
      [
        0.9112057685852051,
        "    pi = 3.14\n    circumference = 2 * pi * r\n    area = pi * r ** 2\n    return (circumference, area)"
      ],
      [
        0.9111831188201904,
        "    pi = 3.14\n    circumference = 2 * pi * r\n    area = pi * r ** 2\n    return (circumference, area)"
      ],
      [
        0.9089893698692322,
        "    circ = 2 * 3.14 * radius\n    return circ"
      ]
    ],
    "MBPP/129": [
      [
        0.8925157189369202,
        "    singleton_list = []\n    for i in arr:\n        if arr.count(i) == 1:\n            singleton_list.append(i)\n    return singleton_list"
      ],
      [
        0.8911830186843872,
        "    dic = {}\n    for el in lst:\n        if el in dic:\n            dic[el] += 1\n        else:\n            dic[el] = 1\n    return [k for k, v in dic.items() if v == 1]"
      ],
      [
        0.8888763189315796,
        "    unpaired_element = []\n    for i in my_list:\n        if my_list.count(i) == 1:\n            unpaired_element.append(i)\n    return unpaired_element"
      ],
      [
        0.8848763108253479,
        "    flattened = [item for sublist in array for item in sublist]\n    counter = Counter(flattened)\n    uniques = {k: v for k, v in counter.items() if v == 1}\n    return uniques"
      ],
      [
        0.8837956786155701,
        "    for i in arr:\n        if arr.count(i) == 1:\n            singleton_list.append(i)"
      ],
      [
        0.883663535118103,
        "        if e in element_counts and element_counts[e] == 1:\n            output.append(e)\n            del element_counts[e]"
      ],
      [
        0.883639931678772,
        "        if e in element_counts and element_counts[e] == 1:\n            output.append(e)\n            del element_counts[e]"
      ],
      [
        0.8830064535140991,
        "    extracted = []\n    unique_elements = set()\n    for element in lst:\n        if element not in unique_elements:\n            extracted.append(element)\n            unique_elements.add(element)\n        if len(extracted) == 3:\n            break\n    return extracted"
      ],
      [
        0.8815646171569824,
        "    for element, count in counter.items():\n        if count == 1:\n            result.append(element)"
      ],
      [
        0.8799132108688354,
        "    for i in my_list:\n        if my_list.count(i) == 1:\n            unpaired_element.append(i)"
      ]
    ],
    "MBPP/130": [],
    "MBPP/131": [
      [
        0.9106860160827637,
        "    countA = Counter(groupA)\n    countB = Counter(groupB)\n    countC = Counter(groupC)\n    common = {}\n    for element in countA:\n        if element in countB and element in countC:\n            common[element] = (countA[element], countB[element], countC[element])\n    return common"
      ],
      [
        0.9084304571151733,
        "    common_elements = []\n    for i in list1:\n        exists_list_2 = False\n        exists_list_3 = False\n        for j in list2:\n            if i == j:\n                exists_list_2 = True\n                break\n        if exists_list_2:\n            for k in list3:\n                if i == k:\n                    exists_list_3 = True\n                    break\n        if exists_list_2 and exists_list_3 and (i not in common_elements):\n            common_elements.append(i)\n    return common_elements"
      ],
      [
        0.9061894416809082,
        "    for element in countA:\n        if element in countB and element in countC:\n            common[element] = (countA[element], countB[element], countC[element])"
      ],
      [
        0.9045130014419556,
        "    common = []\n    for a, b, c in zip(l1, l2, l3):\n        if a == b == c:\n            common.append(a)\n    return common"
      ],
      [
        0.9021159410476685,
        "    for i in list1:\n        exists_list_2 = False\n        exists_list_3 = False\n        for j in list2:\n            if i == j:\n                exists_list_2 = True\n                break\n        if exists_list_2:\n            for k in list3:\n                if i == k:\n                    exists_list_3 = True\n                    break\n        if exists_list_2 and exists_list_3 and (i not in common_elements):\n            common_elements.append(i)"
      ],
      [
        0.8982482552528381,
        "    return (len(set(s1)), len(set(s2)), len(set(s3)))"
      ],
      [
        0.8969337940216064,
        "    count = 0\n    for elem in list1:\n        if elem in list2:\n            count += list2.count(elem)\n    return count"
      ],
      [
        0.8964918255805969,
        "    if len(list1) == len(list2) == len(list3):\n        merged_list = []\n        results = []\n        for i in range(len(list1)):\n            tuple_elem = (list1[i], list2[i], list3[i])\n            merged_list.append(tuple_elem)\n            results.append(len(list1[i]) * list2[i])\n        return (merged_list, results)\n    else:\n        raise ValueError('Lists do not have equal lengths.')"
      ],
      [
        0.8964918255805969,
        "    if len(list1) == len(list2) == len(list3):\n        merged_list = []\n        results = []\n        for i in range(len(list1)):\n            tuple_elem = (list1[i], list2[i], list3[i])\n            merged_list.append(tuple_elem)\n            results.append(len(list1[i]) * list2[i])\n        return (merged_list, results)\n    else:\n        raise ValueError('Lists do not have equal lengths.')"
      ],
      [
        0.8961509466171265,
        "    index1 = index2 = index3 = 0\n    common_elements = []\n    while index1 < len(list1) and index2 < len(list2) and (index3 < len(list3)):\n        if list1[index1] == list2[index2] == list3[index3]:\n            common_elements.append(list1[index1])\n            index1 += 1\n            index2 += 1\n            index3 += 1\n        else:\n            min_value = min(list1[index1], list2[index2], list3[index3])\n            if list1[index1] == min_value:\n                index1 += 1\n            if list2[index2] == min_value:\n                index2 += 1\n            if list3[index3] == min_value:\n                index3 += 1\n    return common_elements"
      ]
    ],
    "MBPP/132": [
      [
        0.8973737955093384,
        "    unique_lists = {}\n    for lst in lists:\n        if len(set(lst)) == 1 and len(lst) != 0:\n            frozen = frozenset(lst)\n            if frozen in unique_lists:\n                unique_lists[frozen] += 1\n            else:\n                unique_lists[frozen] = 1\n    return sum(unique_lists.values())"
      ],
      [
        0.8955939412117004,
        "    count = 0\n    for _ in lst:\n        count += 1\n    return count"
      ],
      [
        0.8955812454223633,
        "    count = 0\n    for _ in lst:\n        count += 1\n    return count"
      ],
      [
        0.894436240196228,
        "    count = 0\n    for elem in lst:\n        count += 1\n    return count"
      ],
      [
        0.8919609189033508,
        "    count = 0\n    for element in lst:\n        count = count + 1\n    return count"
      ],
      [
        0.8914488554000854,
        "    count = 0\n    for element in lst:\n        count += 1\n    return count"
      ],
      [
        0.8908356428146362,
        "    count = 0\n    for item in lst:\n        count += 1\n    return count"
      ],
      [
        0.8904765844345093,
        "    count = 0\n    for element in nested_list:\n        if type(element) == list:\n            count += count_elements(element)\n        else:\n            count += 1\n    return count"
      ],
      [
        0.8903590440750122,
        "    count = 0\n    for element in nested_list:\n        if type(element) is list:\n            count += count_elements(element)\n        else:\n            count += 1\n    return count"
      ],
      [
        0.8902847766876221,
        "    lst = flatten(lst)\n    counts = dict()\n    for sublist in lst:\n        if isinstance(sublist, list):\n            sublist = tuple(flatten(sublist))\n        if isinstance(sublist, tuple):\n            counts[sublist] = counts.get(sublist, 0) + 1\n    return counts"
      ]
    ],
    "MBPP/133": [
      [
        0.9059621691703796,
        "    n = len(ints)\n    sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum += abs(ints[i] - ints[j])\n    return sum"
      ],
      [
        0.9043521881103516,
        "    total = 0\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            total += abs(arr[i] - arr[j])\n    return total"
      ],
      [
        0.9026889801025391,
        "    abs_diff_sum = 0\n    for i in range(len(arr) - 1):\n        abs_diff_sum += abs(arr[i] - arr[i + 1])\n    return abs_diff_sum"
      ],
      [
        0.9003070592880249,
        "    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            total += abs(arr[i] - arr[j])"
      ],
      [
        0.8961650729179382,
        "    for i in range(n):\n        for j in range(i + 1, n):\n            sum += abs(ints[i] - ints[j])"
      ],
      [
        0.8946145176887512,
        "    for i in range(len(arr) - 1):\n        abs_diff_sum += abs(arr[i] - arr[i + 1])"
      ],
      [
        0.8939578533172607,
        "        for j in range(i + 1, len(arr)):\n            total += abs(arr[i] - arr[j])"
      ],
      [
        0.8917484879493713,
        "    n = len(a)\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += a[i] - a[j]\n    return ans"
      ],
      [
        0.8911859393119812,
        "    sum_list1 = sum(list1)\n    sum_list2 = sum(list2)\n    return abs(sum_list1 - sum_list2)"
      ],
      [
        0.8902713656425476,
        "        for j in range(i + 1, n):\n            sum += abs(ints[i] - ints[j])"
      ]
    ],
    "MBPP/134": [
      [
        0.9294489622116089,
        "    max_difference = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            diff = abs(arr[i] - arr[j])\n            if diff > max_difference:\n                max_difference = diff\n    return max_difference"
      ],
      [
        0.9290218353271484,
        "    max_difference = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] - arr[i] > max_difference:\n                max_difference = arr[j] - arr[i]\n    return max_difference"
      ],
      [
        0.9270819425582886,
        "    maxDifference = 0\n    for i in range(len(elementList)):\n        for j in range(i + 1, len(elementList)):\n            if elementList[j] - elementList[i] > maxDifference:\n                maxDifference = elementList[j] - elementList[i]\n    return maxDifference"
      ],
      [
        0.9255038499832153,
        "    max_diff = 0\n    for i in range(0, len(arr)):\n        for j in range(i + 1, len(arr)):\n            diff = arr[j] - arr[i]\n            if diff > max_diff:\n                max_diff = diff\n    return max_diff"
      ],
      [
        0.9254050850868225,
        "    max_difference = -float('inf')\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            diff = abs(arr[i] - arr[j])\n            if diff > max_difference:\n                max_difference = diff\n    return max_difference"
      ],
      [
        0.9254024624824524,
        "    if len(arr) < 2:\n        return 0\n    min_value = arr[0]\n    max_value = arr[0]\n    max_diff = 0\n    for i in range(1, len(arr)):\n        if arr[i] < min_value:\n            min_value = arr[i]\n        elif arr[i] > max_value:\n            max_value = arr[i]\n        diff = max_value - min_value\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff"
      ],
      [
        0.9227374196052551,
        "    max_diff = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            diff = abs(arr[i] - arr[j])\n            if diff > max_diff:\n                max_diff = diff\n    return max_diff"
      ],
      [
        0.9226309061050415,
        "    maxDifference = 0\n    maxDifferencePair = ()\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            difference = abs(arr[i] - arr[j])\n            if difference > maxDifference:\n                maxDifference = difference\n                maxDifferencePair = (arr[i], arr[j])\n    return maxDifferencePair"
      ],
      [
        0.9224757552146912,
        "    min_value = arr[0]\n    max_value = arr[0]\n    max_diff = 0\n    for num in arr:\n        if num < min_value:\n            min_value = num\n        if num > max_value:\n            max_value = num\n        if max_value - min_value > max_diff:\n            max_diff = max_value - min_value\n    return max_diff"
      ],
      [
        0.9221924543380737,
        "    max_diff = 0\n    for i in range(0, len(arr) - 1):\n        diff = arr[i + 1] - arr[i]\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff"
      ]
    ],
    "MBPP/135": [
      [
        0.9438853859901428,
        "    total = 0\n    for char in string:\n        total += ord(char)\n    return total"
      ],
      [
        0.9438703060150146,
        "    total = 0\n    for char in string:\n        total += ord(char)\n    return total"
      ],
      [
        0.9393199682235718,
        "        for character in string:\n            total_ascii_value += ord(character)"
      ],
      [
        0.9393161535263062,
        "        for character in string:\n            total_ascii_value += ord(character)"
      ],
      [
        0.9391916990280151,
        "    sum_ascii = 0\n    for char in string:\n        sum_ascii += ord(char)\n    return sum_ascii"
      ],
      [
        0.9315598011016846,
        "    ascii_sum = 0\n    for char in string:\n        if char.isalpha():\n            ascii_sum += ord(char)\n    return ascii_sum"
      ],
      [
        0.931370735168457,
        "        for i in s:\n            ascii_val = ord(i)\n            print(f'ASCII value of {i} is {ascii_val}')\n            total_sum += ascii_val"
      ],
      [
        0.9307945966720581,
        "    total_ascii_value = 0\n    for string in string_list:\n        for character in string:\n            total_ascii_value += ord(character)\n    return total_ascii_value"
      ],
      [
        0.9307920932769775,
        "    total_ascii_value = 0\n    for string in string_list:\n        for character in string:\n            total_ascii_value += ord(character)\n    return total_ascii_value"
      ],
      [
        0.9301753044128418,
        "    total_sum = 0\n    for s in strings:\n        for i in s:\n            ascii_val = ord(i)\n            print(f'ASCII value of {i} is {ascii_val}')\n            total_sum += ascii_val\n    return total_sum"
      ]
    ],
    "MBPP/136": [
      [
        0.9145236015319824,
        "    n = len(triangle)\n    for i in range(n - 2, -1, -1):\n        for j in range(i + 1):\n            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n    return triangle[0][0]"
      ],
      [
        0.9084618091583252,
        "    size_triangle = range(len(triangle) - 1, -1, -1)\n    for i in size_triangle:\n        for j in range(i):\n            if triangle[i][j] > triangle[i][j + 1]:\n                triangle[i - 1][j] += triangle[i][j]\n            else:\n                triangle[i - 1][j] += triangle[i][j + 1]\n    return triangle[0][0]"
      ],
      [
        0.9070276021957397,
        "        for j in range(i + 1):\n            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])"
      ],
      [
        0.8987568616867065,
        "    for i in range(n - 2, -1, -1):\n        for j in range(i + 1):\n            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])"
      ],
      [
        0.8960947394371033,
        "            if triangle[i][j] > triangle[i][j + 1]:\n                triangle[i - 1][j] += triangle[i][j]\n            else:\n                triangle[i - 1][j] += triangle[i][j + 1]"
      ],
      [
        0.8937019109725952,
        "    sum_list = [sum(row) for row in arr]\n    max_element = max(sum_list)\n    return max_element"
      ],
      [
        0.8928487300872803,
        "    rows = len(grid)\n    cols = len(grid[0])\n    max_sum = [[0] * cols for _ in range(rows)]\n    max_sum[0][0] = grid[0][0]\n    for j in range(1, cols):\n        max_sum[0][j] = max_sum[0][j - 1] + grid[0][j]\n    for i in range(1, rows):\n        max_sum[i][0] = max_sum[i - 1][0] + grid[i][0]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            max_sum[i][j] = max(max_sum[i - 1][j], max_sum[i][j - 1]) + grid[i][j]\n    return max_sum[rows - 1][cols - 1]"
      ],
      [
        0.8913647532463074,
        "    if not triangle:\n        return\n    res = triangle[-1]\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            res[j] = min(res[j], res[j + 1]) + triangle[i][j]\n    return res[0]"
      ],
      [
        0.8908165693283081,
        "    if index >= len(arr):\n        return 0\n    if index == 2:\n        return max(arr[index] + arr[index - 1] + arr[index - 2], 0)\n    return arr[index] + sum_of_first_three(arr, index + 1)"
      ],
      [
        0.8905106782913208,
        "        for j in range(i):\n            if triangle[i][j] > triangle[i][j + 1]:\n                triangle[i - 1][j] += triangle[i][j]\n            else:\n                triangle[i - 1][j] += triangle[i][j + 1]"
      ]
    ],
    "MBPP/137": [
      [
        0.8963073492050171,
        "    return [num // 2, num % 2]"
      ],
      [
        0.89063560962677,
        "    nums.sort()\n    n = len(nums)\n    first_part = []\n    second_part = []\n    sum_first_part = 0\n    sum_second_part = 0\n    for i in range(n - 1, -1, -1):\n        if sum_first_part >= 2 * sum_second_part:\n            second_part.append(nums[i])\n            sum_second_part += nums[i]\n        else:\n            first_part.append(nums[i])\n            sum_first_part += nums[i]\n    return (first_part, second_part)"
      ],
      [
        0.8905006647109985,
        "    result = [[], []]\n    total = sum(list)\n    half = total // 2\n    count = 0\n    while half > 0:\n        if half >= list[count]:\n            result[0].append(list[count])\n            half -= list[count]\n        else:\n            result[1].append(list[count])\n        count += 1\n    return result"
      ],
      [
        0.89002525806427,
        "    l.sort()\n    i = 0\n    j = len(l) - 1\n    left_sum = l[i]\n    right_sum = l[j]\n    while i < j:\n        if left_sum < right_sum:\n            i += 1\n            left_sum += l[i]\n        else:\n            j -= 1\n            right_sum += l[j]\n    return (l[:i + 1], l[i + 1:])"
      ],
      [
        0.8875942230224609,
        "    while half > 0:\n        if half >= list[count]:\n            result[0].append(list[count])\n            half -= list[count]\n        else:\n            result[1].append(list[count])\n        count += 1"
      ],
      [
        0.8872085809707642,
        "    numbers = [int(n) for n in inputString.split(',')]\n    total = sum(numbers)\n    if total % 2 != 0:\n        return 'The sum of these numbers is not even, so partition is not possible.'\n    else:\n        half = total // 2\n        partition1, partition2 = ([], [])\n        for number in sorted(numbers, reverse=True):\n            if sum(partition1) + number <= half:\n                partition1.append(number)\n            else:\n                partition2.append(number)\n        return (partition1, partition2)"
      ],
      [
        0.8870041370391846,
        "    sum_arr = sum(arr)\n    half_sum = sum_arr // 2\n    current_sum = 0\n    left_index = 0\n    for index, value in enumerate(arr):\n        current_sum += value\n        if current_sum >= half_sum:\n            left_index = index\n            break\n    left_arr = arr[:left_index + 1]\n    right_arr = arr[left_index + 1:]\n    return (left_arr, right_arr)"
      ],
      [
        0.8865015506744385,
        "    if total % 2 != 0:\n        return 'The sum of these numbers is not even, so partition is not possible.'\n    else:\n        half = total // 2\n        partition1, partition2 = ([], [])\n        for number in sorted(numbers, reverse=True):\n            if sum(partition1) + number <= half:\n                partition1.append(number)\n            else:\n                partition2.append(number)\n        return (partition1, partition2)"
      ],
      [
        0.8849446773529053,
        "    first_half = arr[:len(arr) // 2]\n    second_half = arr[len(arr) // 2:]\n    return [first_half, second_half]"
      ],
      [
        0.8840380907058716,
        "    length = len(numbers)\n    mid = length // 2\n    list_a = numbers[:mid]\n    list_b = numbers[mid:]\n    return (list_a, list_b)"
      ]
    ],
    "MBPP/138": [
      [
        0.9189908504486084,
        "    current_subsequence = [arr[0]]\n    longest_subsequence = [arr[0]]\n    for i in range(1, len(arr)):\n        if arr[i] == arr[i - 1] + 1:\n            current_subsequence.append(arr[i])\n        else:\n            if len(current_subsequence) > len(longest_subsequence):\n                longest_subsequence = current_subsequence\n            current_subsequence = [arr[i]]\n    if len(current_subsequence) > len(longest_subsequence):\n        longest_subsequence = current_subsequence\n    return longest_subsequence"
      ],
      [
        0.9163687825202942,
        "    longest_start = longest_end = prev_start = 0\n    for i in range(1, len(arr)):\n        if arr[i - 1] - arr[i] != 1:\n            if i - prev_start > longest_end - longest_start:\n                longest_start, longest_end = (prev_start, i)\n            prev_start = i\n    if len(arr) - prev_start > longest_end - longest_start:\n        longest_start, longest_end = (prev_start, len(arr))\n    return arr[longest_start:longest_end]"
      ],
      [
        0.9163607358932495,
        "    longest_start = longest_end = prev_start = 0\n    for i in range(1, len(arr)):\n        if arr[i - 1] - arr[i] != 1:\n            if i - prev_start > longest_end - longest_start:\n                longest_start, longest_end = (prev_start, i)\n            prev_start = i\n    if len(arr) - prev_start > longest_end - longest_start:\n        longest_start, longest_end = (prev_start, len(arr))\n    return arr[longest_start:longest_end]"
      ],
      [
        0.9137048721313477,
        "    for i in range(len(arr)):\n        currentLength = 1\n        for j in range(i + 1, len(arr)):\n            if arr[j] - arr[j - 1] == 1:\n                currentLength += 1\n            else:\n                break\n        if currentLength > maxLength:\n            maxLength = currentLength"
      ],
      [
        0.9121592044830322,
        "    for i in range(1, len(arr)):\n        if arr[i] == arr[i - 1] + 1:\n            current_subsequence.append(arr[i])\n        else:\n            if len(current_subsequence) > len(longest_subsequence):\n                longest_subsequence = current_subsequence\n            current_subsequence = [arr[i]]"
      ],
      [
        0.9117479920387268,
        "    for i in range(len(arr) - 1):\n        if arr[i + 1] == arr[i] + 1:\n            length += 1\n        else:\n            max_length = max(max_length, length)\n            length = 0"
      ],
      [
        0.9117177724838257,
        "    max_length = 0\n    cur_length = 1\n    for i in range(len(arr) - 1):\n        if arr[i] + 1 == arr[i + 1]:\n            cur_length += 1\n        else:\n            if cur_length > max_length:\n                max_length = cur_length\n            cur_length = 1\n    if cur_length > max_length:\n        max_length = cur_length\n    return max_length"
      ],
      [
        0.9093934297561646,
        "        if arr[i] == arr[i - 1] + 1:\n            current_subsequence.append(arr[i])\n        else:\n            if len(current_subsequence) > len(longest_subsequence):\n                longest_subsequence = current_subsequence\n            current_subsequence = [arr[i]]"
      ],
      [
        0.9089694619178772,
        "    arr_set = set(arr)\n    max_length = 0\n    max_subsequence = []\n    for num in arr:\n        if num - 1 not in arr_set:\n            current_length = 0\n            current_subsequence = []\n            while num in arr_set:\n                current_length += 1\n                current_subsequence.append(num)\n                num += 1\n            if current_length > max_length and len(current_subsequence) > 1:\n                max_length = current_length\n                max_subsequence = current_subsequence\n    return (max_length, max_subsequence)"
      ],
      [
        0.908937931060791,
        "    longest_sequence = []\n    current_sequence = []\n    current_num = None\n    for num in sorted(arr):\n        if current_num is None or num == current_num + 1:\n            current_sequence.append(num)\n            current_num = num\n        else:\n            if len(current_sequence) > len(longest_sequence) or (len(current_sequence) == len(longest_sequence) and current_sequence[0] < longest_sequence[0]):\n                longest_sequence = current_sequence\n            current_sequence = [num]\n            current_num = num\n    if len(current_sequence) > len(longest_sequence) or (len(current_sequence) == len(longest_sequence) and current_sequence[0] < longest_sequence[0]):\n        longest_sequence = current_sequence\n    return longest_sequence"
      ]
    ],
    "MBPP/139": [
      [
        0.9099154472351074,
        "    fib_sequence = fibonacci(num)\n    return num in fib_sequence"
      ],
      [
        0.9072612524032593,
        "    i = 0\n    while True:\n        fib = fibonacci(i)\n        if fib > n:\n            return False\n        if fib == n:\n            return True\n        i += 1"
      ],
      [
        0.9054486751556396,
        "    fib_seq = fibonacci(n)\n    return num in fib_seq"
      ],
      [
        0.9048270583152771,
        "    a, b = (0, 1)\n    while b < my_number:\n        a, b = (b, a + b)\n    return b == my_number"
      ],
      [
        0.9022553563117981,
        "    while True:\n        fib = fibonacci(i)\n        if fib > n:\n            return False\n        if fib == n:\n            return True\n        i += 1"
      ],
      [
        0.9012467265129089,
        "    if n == 0:\n        return False\n    else:\n        while y < n:\n            z = x + y\n            x = y\n            y = z\n        if y == n:\n            return True\n        else:\n            return False"
      ],
      [
        0.9008376598358154,
        "    a, b = (0, 1)\n    while a <= n:\n        if a == n:\n            return True\n        a, b = (b, a + b)\n    return False"
      ],
      [
        0.9001076221466064,
        "    a, b = (0, 1)\n    while b <= n:\n        if b == n:\n            return True\n        a, b = (b, a + b)\n    return False"
      ],
      [
        0.9000237584114075,
        "    while True:\n        fib = x + y\n        if fib > n:\n            return False\n        if fib == n:\n            return True\n        x = y\n        y = fib"
      ],
      [
        0.9000113606452942,
        "    while True:\n        fib = x + y\n        if fib > n:\n            return False\n        if fib == n:\n            return True\n        x = y\n        y = fib"
      ]
    ],
    "MBPP/140": [
      [
        0.9103204011917114,
        "    if type(num1) != int or type(num2) != int:\n        raise TypeError('Both inputs must be integers')\n    if num1 < 0 or num2 < 0:\n        raise ValueError('Both integers must be positive')\n    if num2 == 0:\n        raise ValueError('The second integer cannot be zero')\n    if num1 % num2 == 0:\n        return True\n    if num1 <= 1:\n        raise ValueError('The first integer cannot be a prime number')\n    sqrt_num1 = math.isqrt(num1)\n    for i in range(2, sqrt_num1 + 1):\n        if num1 % i == 0:\n            raise ValueError('The first integer cannot be a prime number')\n    return False"
      ],
      [
        0.9083164930343628,
        "    if math.gcd(a, b) == 1:\n        print(f'{a} and {b} are co-prime numbers.')\n    else:\n        print(f'{a} and {b} are not co-prime numbers.')"
      ],
      [
        0.9083164930343628,
        "    if math.gcd(a, b) == 1:\n        print(f'{a} and {b} are co-prime numbers.')\n    else:\n        print(f'{a} and {b} are not co-prime numbers.')"
      ],
      [
        0.9074428677558899,
        "    if a % b == 0 or b % a == 0:\n        return False"
      ],
      [
        0.9073474407196045,
        "    a = float(a)\n    b = float(b)\n    if a < 2 or b < 2:\n        return False\n    for i in range(2, int(max(a, b)) + 1):\n        if a % i == 0 or b % i == 0:\n            return False\n    return True"
      ],
      [
        0.9068929553031921,
        "    prime_check = range(2, n)\n    for i in prime_check:\n        if n % i == 0:\n            return False\n    return True"
      ],
      [
        0.9053330421447754,
        "    array_length = len(arr)\n    if is_prime(array_length):\n        return 'Prime'\n    else:\n        return 'Composite'"
      ],
      [
        0.9035671949386597,
        "    if n < 2:\n        return (False, 0)\n    else:\n        factors = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                factors += 1\n        if factors == 2:\n            return (True, factors)\n        else:\n            return (False, factors)"
      ],
      [
        0.9035671949386597,
        "    if n < 2:\n        return (False, 0)\n    else:\n        factors = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                factors += 1\n        if factors == 2:\n            return (True, factors)\n        else:\n            return (False, factors)"
      ],
      [
        0.903214156627655,
        "    assert is_prime(4) == 'no'\n    assert is_prime(3) == 'yes'\n    assert is_prime(8) == 'no'"
      ]
    ],
    "MBPP/141": [],
    "MBPP/142": [
      [
        0.8795247077941895,
        "        if fa * fc < 0:\n            b = (a + b) / 2\n        elif fc * fb < 0:\n            a = (a + b) / 2\n        else:\n            raise Exception('Trisection algorithm failed to converge.')"
      ],
      [
        0.8790855407714844,
        "    elif det == 0:\n        return [(-b + det) / (2 * a)]\n    elif det > 0:\n        return [(-b + det) / (2 * a), (-b - det) / (2 * a)]"
      ],
      [
        0.8777413368225098,
        "        elif fc * fb < 0:\n            a = (a + b) / 2\n        else:\n            raise Exception('Trisection algorithm failed to converge.')"
      ],
      [
        0.8774886131286621,
        "    while b - a >= 0.01:\n        c = (a + b) / 2\n        if equation(c) == 0.0:\n            break\n        elif equation(c) * equation(a) < 0:\n            b = c\n        else:\n            a = c"
      ],
      [
        0.8762322664260864,
        "    parabola_distance, error = integrate.quad(parabolic_distance, -4, 0, args=a)\n    straight_distance = sqrt(4 ** 2 + 3 ** 2)\n    return parabola_distance + straight_distance"
      ],
      [
        0.8760577440261841,
        "    max_iterations = 1000\n    iteration = 0\n    while abs(b - a) > epsilon and iteration < max_iterations:\n        fa = f(a)\n        fc = f((a + b) / 2)\n        fb = f(b)\n        if abs(fa) < epsilon:\n            return a\n        if abs(fc) < epsilon:\n            return (a + b) / 2\n        if abs(fb) < epsilon:\n            return b\n        if fa * fc < 0:\n            b = (a + b) / 2\n        elif fc * fb < 0:\n            a = (a + b) / 2\n        else:\n            raise Exception('Trisection algorithm failed to converge.')\n        iteration += 1\n    return (a + b) / 2"
      ],
      [
        0.8748914003372192,
        "    if equation(a) * equation(b) >= 0:\n        print('Invalid interval. The signs of the equation results for a and b should be opposite.')\n        return\n    c = a\n    while b - a >= 0.01:\n        c = (a + b) / 2\n        if equation(c) == 0.0:\n            break\n        elif equation(c) * equation(a) < 0:\n            b = c\n        else:\n            a = c\n    print('The value of root is : ', '%.4f' % c)"
      ],
      [
        0.8746674060821533,
        "    discriminant = (b ** 2 - 4 * a * c) ** 0.5\n    x1 = (-b + discriminant) / (2 * a)\n    x2 = (-b - discriminant) / (2 * a)\n    return (x1, x2)"
      ],
      [
        0.8739153146743774,
        "    x1 = (-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)\n    x2 = (-b - (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)\n    return (x1, x2)"
      ],
      [
        0.873586893081665,
        "    if d >= 0:\n        sqrt_d = sqrt(d)\n        x1 = (-b + sqrt_d) / (2 * a)\n        x2 = (-b - sqrt_d) / (2 * a)\n        if x1 < x2:\n            return x1\n        else:\n            return x2\n    else:\n        return None"
      ]
    ],
    "MBPP/143": [
      [
        0.8952887058258057,
        "    extracted_elements = []\n    for i in range(3):\n        extracted_elements.append(lst[i])\n    return extracted_elements"
      ],
      [
        0.8930913805961609,
        "    indices = []\n    for i in range(len(array)):\n        for j in range(len(array[i])):\n            if array[i][j] == element:\n                indices.append((i, j))\n    return indices"
      ],
      [
        0.8846510052680969,
        "    for i in range(3):\n        extracted_elements.append(lst[i])"
      ],
      [
        0.8840104341506958,
        "    flattened_list = []\n    for row in input_list:\n        for column in row:\n            flattened_list.append(column)\n    return flattened_list"
      ],
      [
        0.8838620185852051,
        "    if len(my_list) < n:\n        return 'Error: List contains less than n elements'\n    elif isinstance(my_list[0], list):\n        return [x[2] for x in my_list if len(x) >= 3]\n    else:\n        return my_list[2]"
      ],
      [
        0.8838620185852051,
        "    if len(my_list) < n:\n        return 'Error: List contains less than n elements'\n    elif isinstance(my_list[0], list):\n        return [x[2] for x in my_list if len(x) >= 3]\n    else:\n        return my_list[2]"
      ],
      [
        0.8837563991546631,
        "    combined_list = []\n    for lst in list_data:\n        combined_list.append(lst[1])\n    return combined_list"
      ],
      [
        0.8827648758888245,
        "    locations = []\n    for row_idx, row in enumerate(multi_dim_array):\n        for col_idx, col in enumerate(row):\n            if col == element:\n                locations.append((row_idx, col_idx))\n    return locations"
      ],
      [
        0.8819323182106018,
        "    result = []\n    for i in list1:\n        if i in tuple1:\n            result.append(i)\n    return result"
      ],
      [
        0.8817703723907471,
        "    column_index = t[1]\n    column_values = [row[column_index] for row in grid]\n    return column_values"
      ]
    ],
    "MBPP/144": [
      [
        0.8916226625442505,
        "    while n & mask:\n        n ^= mask\n        mask <<= 1"
      ],
      [
        0.8858827352523804,
        "    while n:\n        parity ^= n & 1\n        n >>= 1"
      ],
      [
        0.8858059048652649,
        "    parity = 0\n    while n:\n        parity ^= n & 1\n        n >>= 1\n    return parity"
      ],
      [
        0.885300874710083,
        "    for num in a:\n        binary_num = bin(num)[2:]\n        transformed_num = num ^ num << 1 ^ num & num << 1 ^ num & num << 1 & num << 2\n        result.append(transformed_num)"
      ],
      [
        0.8852225542068481,
        "    if n == 0:\n        return 0\n    else:\n        return n & 1 ^ check_parity(n >> 1)"
      ],
      [
        0.8852225542068481,
        "    if n == 0:\n        return 0\n    else:\n        return n & 1 ^ check_parity(n >> 1)"
      ],
      [
        0.8852190375328064,
        "    if n == 0:\n        return 0\n    else:\n        return n & 1 ^ check_parity(n >> 1)"
      ],
      [
        0.8852190375328064,
        "    if n == 0:\n        return 0\n    else:\n        return n & 1 ^ check_parity(n >> 1)"
      ],
      [
        0.8841120004653931,
        "        if num & 1 == 0:\n            even.append(num)\n        else:\n            odd.append(num)"
      ],
      [
        0.8831467032432556,
        "    mask = 1\n    while n & mask:\n        n ^= mask\n        mask <<= 1\n    n ^= mask\n    return n"
      ]
    ],
    "MBPP/145": [
      [
        0.90758216381073,
        "    return [int(string) for string in strings]"
      ],
      [
        0.9013752937316895,
        "    list_of_integers = []\n    for string in list_of_strings:\n        list_of_integers.append(int(string))\n    return list_of_integers"
      ],
      [
        0.8999233841896057,
        "    return [int(i) for i in string_list]"
      ],
      [
        0.895456075668335,
        "    return [str_to_int[val] for val in str_values.split(', ')]"
      ],
      [
        0.8928995728492737,
        "    return [int(s, 0) for s in str_list]"
      ],
      [
        0.8906060457229614,
        "    string_list = input_string.split()\n    return [int(item) for item in string_list]"
      ],
      [
        0.889095664024353,
        "    return [int(x) for x in string.split(',')]"
      ]
    ],
    "MBPP/146": [
      [
        0.9112828969955444,
        "    if not list_to_encode:\n        return []\n    else:\n        tmp = []\n        tmp.append(list_to_encode[0])\n        tmp.append(1)\n        i = 1\n        while i < len(list_to_encode) and list_to_encode[i] == tmp[0]:\n            tmp[1] += 1\n            i += 1\n        return tmp + encodeList(list_to_encode[i:])"
      ],
      [
        0.9112828969955444,
        "    if not list_to_encode:\n        return []\n    else:\n        tmp = []\n        tmp.append(list_to_encode[0])\n        tmp.append(1)\n        i = 1\n        while i < len(list_to_encode) and list_to_encode[i] == tmp[0]:\n            tmp[1] += 1\n            i += 1\n        return tmp + encodeList(list_to_encode[i:])"
      ],
      [
        0.8976408243179321,
        "    compressed_list = []\n    count = 1\n    for index in range(1, len(original_list)):\n        if original_list[index] == original_list[index - 1]:\n            count += 1\n        else:\n            compressed_list.append(str(original_list[index - 1]) + 'x' + str(count))\n            count = 1\n    compressed_list.append(str(original_list[index]) + 'x' + str(count))\n    return compressed_list"
      ],
      [
        0.8973993062973022,
        "    rle_arr = []\n    for word in arr:\n        encoded = ''\n        i = 0\n        while i < len(word):\n            count = 1\n            while i + 1 < len(word) and word[i] == word[i + 1]:\n                i += 1\n                count += 1\n            encoded += '{}{}'.format(word[i], count)\n            i += 1\n        rle_arr.append(encoded)\n    return rle_arr"
      ],
      [
        0.895163357257843,
        "    for index in range(1, len(original_list)):\n        if original_list[index] == original_list[index - 1]:\n            count += 1\n        else:\n            compressed_list.append(str(original_list[index - 1]) + 'x' + str(count))\n            count = 1"
      ],
      [
        0.8930303454399109,
        "        if original_list[index] == original_list[index - 1]:\n            count += 1\n        else:\n            compressed_list.append(str(original_list[index - 1]) + 'x' + str(count))\n            count = 1"
      ],
      [
        0.8928057551383972,
        "    for word in arr:\n        encoded = ''\n        i = 0\n        while i < len(word):\n            count = 1\n            while i + 1 < len(word) and word[i] == word[i + 1]:\n                i += 1\n                count += 1\n            encoded += '{}{}'.format(word[i], count)\n            i += 1\n        rle_arr.append(encoded)"
      ],
      [
        0.8904695510864258,
        "    compressed = []\n    count = 1\n    for i in range(1, len(string)):\n        if string[i] == string[i - 1]:\n            count += 1\n        else:\n            compressed.append((string[i - 1], count))\n            count = 1\n    compressed.append((string[-1], count))\n    return compressed"
      ],
      [
        0.89016193151474,
        "    encoded_sequence = []\n    prev = None\n    count = 0\n    for num in sequence:\n        if prev is None:\n            prev = num\n            count = 1\n        elif num == prev:\n            count += 1\n        else:\n            encoded_sequence.append((prev, count))\n            prev = num\n            count = 1\n    encoded_sequence.append((prev, count))\n    return encoded_sequence"
      ],
      [
        0.889673113822937,
        "        while i < len(list_to_encode) and list_to_encode[i] == tmp[0]:\n            tmp[1] += 1\n            i += 1"
      ]
    ],
    "MBPP/147": [
      [
        0.8977447748184204,
        "    count = {}\n    operations = 0\n    for num in nums:\n        if count.get(k - num, 0) > 0:\n            count[k - num] -= 1\n            operations += 1\n        else:\n            count[num] = count.get(num, 0) + 1\n    return operations"
      ],
      [
        0.8977121114730835,
        "    count = {}\n    operations = 0\n    for num in nums:\n        if count.get(k - num, 0) > 0:\n            count[k - num] -= 1\n            operations += 1\n        else:\n            count[num] = count.get(num, 0) + 1\n    return operations"
      ],
      [
        0.895022451877594,
        "    for query in queries:\n        operations = 0\n        for num in nums:\n            operations += abs(num - query)\n        answer.append(operations)"
      ],
      [
        0.8938882350921631,
        "    answer = []\n    for query in queries:\n        operations = 0\n        for num in nums:\n            operations += abs(num - query)\n        answer.append(operations)\n    return answer"
      ],
      [
        0.8914061784744263,
        "    min_step = 0\n    min_val = min(arr)\n    for i in range(len(arr)):\n        min_step += arr[i] - min_val\n    return min_step"
      ],
      [
        0.8895947933197021,
        "        for num in nums:\n            operations += abs(num - query)"
      ],
      [
        0.8879860639572144,
        "    frequency = {}\n    for char in string:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    max_frequency = max(frequency.values())\n    operations = 0\n    for char, count in frequency.items():\n        operations += abs(count - max_frequency)\n    return operations"
      ],
      [
        0.8879366517066956,
        "    for num in nums:\n        if count.get(k - num, 0) > 0:\n            count[k - num] -= 1\n            operations += 1\n        else:\n            count[num] = count.get(num, 0) + 1"
      ],
      [
        0.8878717422485352,
        "    for num in nums:\n        if count.get(k - num, 0) > 0:\n            count[k - num] -= 1\n            operations += 1\n        else:\n            count[num] = count.get(num, 0) + 1"
      ],
      [
        0.8873194456100464,
        "    operations = 0\n    freq = {}\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n    max_freq = max(freq.values())\n    for char in freq:\n        operations += abs(freq[char] - max_freq)\n    return operations"
      ]
    ],
    "MBPP/148": [
      [
        0.889618456363678,
        "    if day < 1 or day > 31:\n        return 'Error: Invalid day'"
      ],
      [
        0.8879398703575134,
        "        elif day > 28:\n            return 'Error: Invalid day'"
      ],
      [
        0.886737585067749,
        "    if month < 1 or month > 12:\n        return 'No'"
      ],
      [
        0.8859918117523193,
        "            if day > 29:\n                return 'Error: Invalid day'"
      ],
      [
        0.885560154914856,
        "    if day < 1 or day > 31:\n        return 'No'"
      ],
      [
        0.8848350644111633,
        "        if day > 365:\n            if year % 400 == 0 or (year % 4 == 0 and year % 100 != 0):\n                pass\n            else:\n                return 'Invalid Input: This year is not a leap year.'"
      ],
      [
        0.8837194442749023,
        "        if day > 30:\n            return 'Invalid day'"
      ],
      [
        0.8836448192596436,
        "        elif day > 28:\n            return 'No'"
      ],
      [
        0.8834383487701416,
        "    year, month, day = date_string.split('-')\n    year = int(year)\n    month = int(month)\n    day = int(day)\n    if is_leap_year(year):\n        print('The year is a leap year.')\n    else:\n        print('The year is not a leap year.')"
      ],
      [
        0.8823197484016418,
        "        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            if month == 2 and day > 29:\n                return 'Error: Invalid date for a leap year'\n            print(\"It's a leap year.\")\n        elif month == 2 and day > 28:\n            return 'Error: Invalid date for a non-leap year'"
      ]
    ],
    "MBPP/149": [
      [
        0.895685076713562,
        "    coefficients = equation.split()\n    x_coeff = int(coefficients[0][:-1])\n    y_coeff = int(coefficients[2][:-1])\n    value = int(coefficients[4])\n    if x_coeff == 0 and y_coeff == 0:\n        raise ValueError('Invalid equation!')\n    elif x_coeff == 0:\n        return [None, value // y_coeff]\n    elif y_coeff == 0:\n        return [value // x_coeff, None]\n    x = value * y_coeff // (x_coeff * y_coeff + y_coeff * y_coeff)\n    y = (value - x_coeff * x) // y_coeff\n    return [x, y]"
      ],
      [
        0.8941934108734131,
        "    x = (c - b * y) / a\n    y = (c - a * x) / b\n    return (x, y)"
      ],
      [
        0.8936694860458374,
        "    n1 = abs(n1)\n    n2 = abs(n2)\n    if n2 == 0:\n        return n1\n    while n2 != 0:\n        n1, n2 = (n2, n1 % n2)\n    _, x, y = gcd_extended(n1, n2)\n    if n1 == abs(n1):\n        x *= 1\n    else:\n        x *= -1\n    if n2 == abs(n2):\n        y *= 1\n    else:\n        y *= -1\n    return (n1, x, y)"
      ],
      [
        0.8923079371452332,
        "    if n == 1:\n        return (a, b)"
      ],
      [
        0.8911423087120056,
        "    if n2 == 0:\n        return (n1, 1, 0)\n    gcd, x1, y1 = gcd_extended(n2, n1 % n2)\n    x = y1\n    y = x1 - n1 // n2 * y1\n    return (gcd, x, y)"
      ],
      [
        0.8892459869384766,
        "    y = N * Q / (P + Q)\n    x = N - y\n    return (int(x), int(y))"
      ],
      [
        0.8887238502502441,
        "    m = 10 ** 14\n    if a > m or a == 0:\n        return\n    if not x or y % x == 0:\n        if m >= a * a and b >= 0:\n            c = a * a\n            if c not in grp:\n                grp[c] = []\n            grp[c].append([b, 1])\n    gen(s, n, x * s + y * a * n, x * a * n + y * s, x * m2 + a, y * m2)"
      ],
      [
        0.8862934112548828,
        "    if x_coeff == 0 and y_coeff == 0:\n        raise ValueError('Invalid equation!')\n    elif x_coeff == 0:\n        return [None, value // y_coeff]\n    elif y_coeff == 0:\n        return [value // x_coeff, None]"
      ],
      [
        0.8851673007011414,
        "    return (n * d + n, d)"
      ],
      [
        0.8841900825500488,
        "    x = (e * d - b * f) / (a * d - b * c)\n    y = (a * f - e * c) / (a * d - b * c)\n    return (x, y)"
      ]
    ],
    "MBPP/150": [
      [
        0.9278622269630432,
        "    for item in list2:\n        if item in list1:\n            list1.remove(item)\n    return list1"
      ],
      [
        0.9273253083229065,
        "    for i in list2:\n        list1.remove(i)\n    return list1"
      ],
      [
        0.9242030382156372,
        "    for i in list2:\n        list1.remove(i)"
      ],
      [
        0.9226995706558228,
        "    for item in list2:\n        if item in list1:\n            list1.remove(item)"
      ],
      [
        0.9137451648712158,
        "    for item in list1:\n        if item in list_copy:\n            list_copy.remove(item)"
      ],
      [
        0.912886381149292,
        "    return [value for value in list1 if value not in list2]"
      ],
      [
        0.9118809700012207,
        "    common_elements = set()\n    for element in A:\n        if element in B:\n            common_elements.add(element)\n    for element in common_elements:\n        A.remove(element)\n    return A"
      ],
      [
        0.91057288646698,
        "    new_list = []\n    for el in y:\n        if el != x:\n            new_list.append(el)\n    return new_list"
      ],
      [
        0.9101628065109253,
        "    return [x for x in list_a if x not in list_b]"
      ],
      [
        0.9099850654602051,
        "    temp = []\n    for i in list1:\n        if i not in list2:\n            temp.append(i)\n    return temp"
      ]
    ],
    "MBPP/151": [
      [
        0.914009690284729,
        "    if n % 2 == 0:\n        return n + sum_of_even_numbers(n - 2)"
      ],
      [
        0.9128215312957764,
        "    return sum(range(1, 2 * n, 2))"
      ],
      [
        0.9110780358314514,
        "    total = 0\n    x = 0\n    while x < n:\n        if x % 2 == 1:\n            total += x\n        x += 1\n    return total"
      ],
      [
        0.9104390144348145,
        "    if x < 0:\n        return 'Invalid input'\n    else:\n        return x * (x + 4) + 5"
      ],
      [
        0.9104390144348145,
        "    if x < 0:\n        return 'Invalid input'\n    else:\n        return x * (x + 4) + 5"
      ],
      [
        0.9097909927368164,
        "    return sum(range(2, 2 * n + 1, 2))"
      ],
      [
        0.9094822406768799,
        "    if n <= 0:\n        return 0\n    if n % 2 == 0:\n        return n + sum_of_even_numbers(n - 2)\n    return sum_of_even_numbers(n - 1)"
      ],
      [
        0.90938401222229,
        "    total = 0\n    while n > 0:\n        total += n\n        n -= 1\n        if total > 10000:\n            print('The sum exceeded the limit!')\n            break\n    return total"
      ],
      [
        0.9083687663078308,
        "    sum = 0\n    for i in range(0, n + 1, 2):\n        sum += i\n    return sum"
      ],
      [
        0.9082404971122742,
        "    elif n % 2 == 0:\n        return sum_of_odd_numbers(n - 1)\n    else:\n        return n + sum_of_odd_numbers(n - 2)"
      ]
    ],
    "MBPP/152": [
      [
        0.9108258485794067,
        "    area = no_sides * length ** 2 / (4 * math.tan(math.pi / no_sides))\n    return area"
      ],
      [
        0.9101088643074036,
        "    area = n * (math.pow(n, 2) - math.pow(n - 1, 2)) / 4 * math.pow(math.pi, 2)\n    return area"
      ],
      [
        0.9090440273284912,
        "    if len(vertices) < 3:\n        raise InvalidRegularPolygonException('A polygon must have at least 3 vertices.')\n    n = len(vertices)\n    side_lengths = []\n    for i in range(n):\n        x1, y1 = vertices[i]\n        x2, y2 = vertices[(i + 1) % n]\n        side_length = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n        side_lengths.append(side_length)\n    if len(set(side_lengths)) > 1:\n        raise InvalidRegularPolygonException('Not all sides of the polygon are equal in length.')\n    s = side_lengths[0]\n    area = n * s ** 2 / (4 * math.tan(math.pi / n))\n    return area"
      ],
      [
        0.9080967307090759,
        "    area = n * side ** 2 / (4 * math.tan(math.pi / n))\n    return area"
      ],
      [
        0.9040303230285645,
        "    area = n * s ** 2 / (4 * math.tan(math.pi / n))\n    return area"
      ],
      [
        0.9040258526802063,
        "    area = n * s ** 2 / (4 * math.tan(math.pi / n))\n    return area"
      ],
      [
        0.9022042751312256,
        "    angle = 2 * math.pi / n\n    area = r ** 2 * math.sin(angle) / 2\n    return area"
      ],
      [
        0.8974622488021851,
        "    return n_sides * side ** 2 / (4 * math.tan(math.pi / n_sides))"
      ],
      [
        0.8962174654006958,
        "    side = 2 * radius * math.sin(math.pi / 5)\n    area = 5 / 4 * math.tan(math.pi / 5) * side ** 2\n    return area"
      ],
      [
        0.890841007232666,
        "    l = math.sqrt((s / (2 * math.tan(math.pi / n))) ** 2 + h ** 2)\n    P = n * s\n    A = P * s / (4 * math.tan(math.pi / n))\n    surface_area = P * l / 2 + A\n    return surface_area"
      ]
    ],
    "MBPP/153": [
      [
        0.9196459054946899,
        "    if divisors_sum == n:\n        return True\n    else:\n        return False"
      ],
      [
        0.9195737242698669,
        "    if divisor_sum == n:\n        return True\n    else:\n        return False"
      ],
      [
        0.9167428016662598,
        "    if sum(divisors) == n:\n        return True\n    else:\n        return False"
      ],
      [
        0.9131140112876892,
        "    divisors = []\n    for i in range(1, n):\n        if n % i == 0:\n            divisors.append(i)\n    if sum(divisors) == n:\n        return True\n    else:\n        return False"
      ],
      [
        0.912571907043457,
        "    divisors_sum = 0\n    for i in range(1, n):\n        if n % i == 0:\n            divisors_sum += i\n    if divisors_sum == n:\n        return True\n    else:\n        return False"
      ],
      [
        0.9123154282569885,
        "    if num == sum(divs):\n        return True\n    else:\n        return False"
      ],
      [
        0.9101111888885498,
        "    sum_a = sum_of_proper_divisors(a)\n    sum_b = sum_of_proper_divisors(b)\n    if a == sum_b and b == sum_a:\n        return True\n    return False"
      ],
      [
        0.9086025953292847,
        "    if num <= 1:\n        return False\n    divisors_sum = 1\n    sqrt_num = int(math.sqrt(num))\n    for i in range(2, sqrt_num + 1):\n        if num % i == 0:\n            divisors_sum += i\n            quotient = num // i\n            if quotient != i:\n                divisors_sum += quotient\n    return divisors_sum == num"
      ],
      [
        0.9079660177230835,
        "    if num <= 0:\n        return False\n    divisor_sum = 0\n    for i in range(1, num):\n        if num % i == 0:\n            divisor_sum += i\n    return divisor_sum == num"
      ],
      [
        0.9073898196220398,
        "    if num <= 0:\n        return False\n    divisors_sum = 0\n    for i in range(1, num):\n        if num % i == 0:\n            divisors_sum += i\n    return divisors_sum == num"
      ]
    ],
    "MBPP/154": [
      [
        0.9155515432357788,
        "    count = 0\n    for char in string:\n        if ord(char) >= 65 and ord(char) <= 90:\n            count += 1\n    return count"
      ],
      [
        0.9155226945877075,
        "    count = 0\n    for char in string:\n        if ord(char) >= 65 and ord(char) <= 90:\n            count += 1\n    return count"
      ],
      [
        0.9151763319969177,
        "    for char in string:\n        if ord(char) >= 65 and ord(char) <= 90:\n            count += 1"
      ],
      [
        0.9151574969291687,
        "    for char in string:\n        if ord(char) >= 65 and ord(char) <= 90:\n            count += 1"
      ],
      [
        0.9148004055023193,
        "    alphabet = string.ascii_lowercase\n    count = {}\n    for char in input_string:\n        if char.isalpha():\n            char = char.lower()\n            if char in count:\n                count[char] += 1\n            else:\n                count[char] = 1\n    return count"
      ],
      [
        0.9135607481002808,
        "    uppercase_counts = {}\n    for char in text:\n        if char.isupper():\n            if char in uppercase_counts:\n                uppercase_counts[char] += 1\n            else:\n                uppercase_counts[char] = 1\n    return uppercase_counts"
      ],
      [
        0.9129291772842407,
        "    dict_upper = {}\n    dict_lower = {}\n    for char in text:\n        if char.isalpha():\n            if char.isupper():\n                dict_upper[char] = dict_upper.get(char, 0) + 1\n            else:\n                dict_lower[char] = dict_lower.get(char, 0) + 1\n    return (dict_upper, dict_lower)"
      ],
      [
        0.9127464294433594,
        "    if not character.isalpha():\n        return 'Error: Character must be an alphabet.'\n    count = 0\n    for char in string:\n        if char == character:\n            count += 1\n        elif char.lower() == character.lower():\n            count += 1\n    return count"
      ],
      [
        0.9124030470848083,
        "    count_dict = {}\n    for char in input_string:\n        if char.isalpha():\n            char = char.lower()\n            if char in count_dict:\n                count_dict[char] += 1\n            else:\n                count_dict[char] = 1\n    return count_dict"
      ],
      [
        0.9122942686080933,
        "        if char.isalpha():\n            if char.islower():\n                counts[ord(char) - ord('a')] += 1\n            else:\n                counts[ord(char) - ord('A')] += 1\n        else:\n            special_chars += char"
      ]
    ],
    "MBPP/155": [
      [
        0.9086575508117676,
        "    odd_pairs = []\n    pair_count = 0\n    for i in range(len(lst) - 1):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) & 1:\n                pair_count += 1\n                odd_pairs.append((lst[i], lst[j]))\n    return (pair_count, odd_pairs)"
      ],
      [
        0.9086395502090454,
        "    odd_pairs = []\n    pair_count = 0\n    for i in range(len(lst) - 1):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) & 1:\n                pair_count += 1\n                odd_pairs.append((lst[i], lst[j]))\n    return (pair_count, odd_pairs)"
      ],
      [
        0.9071584939956665,
        "    while xor:\n        count += xor & 1\n        xor >>= 1"
      ],
      [
        0.9056244492530823,
        "        if x % 2 == 0:\n            count += 1"
      ],
      [
        0.9011112451553345,
        "    while xor_result:\n        count += xor_result & 1\n        xor_result >>= 1"
      ],
      [
        0.9007209539413452,
        "        if bitwise_and & 1:\n            count += 1"
      ],
      [
        0.8975623846054077,
        "            if c % 2 == 0:\n                count += 1"
      ],
      [
        0.8975623846054077,
        "            if c % 2 == 0:\n                count += 1"
      ],
      [
        0.8975566625595093,
        "    count = 0\n    for x in arr:\n        if x % 2 == 0:\n            count += 1\n    return count"
      ]
    ],
    "MBPP/156": [
      [
        0.9266853332519531,
        "    return 2 ** int(np.ceil(np.log2(num)))"
      ],
      [
        0.9158002138137817,
        "    while power <= n:\n        power *= 2"
      ],
      [
        0.9120490550994873,
        "    p = 0\n    while 1 << p + 1 <= n:\n        p += 1\n    return p"
      ],
      [
        0.9111161231994629,
        "    powers_of_two = [1]\n    current_power = 2\n    while current_power <= n:\n        powers_of_two.append(current_power)\n        current_power *= 2\n    return powers_of_two"
      ],
      [
        0.9055273532867432,
        "    x = 1\n    while n > x:\n        x = x * 2 + 1\n    return x - n"
      ],
      [
        0.9048742651939392,
        "    return math.ceil(math.log2(n))"
      ],
      [
        0.9045950174331665,
        "    return math.log2(n) + 1"
      ],
      [
        0.9039928913116455,
        "    log = 0\n    while n > 1:\n        n = n >> 1\n        log += 1\n    return log"
      ],
      [
        0.9038912057876587,
        "    while current_power <= n:\n        powers_of_two.append(current_power)\n        current_power *= 2"
      ],
      [
        0.9033330678939819,
        "    while p <= num:\n        p *= 2"
      ]
    ],
    "MBPP/157": [
      [
        0.9216140508651733,
        "    count = 0\n    for num in arr:\n        if num == given_number:\n            count += 1\n    return count"
      ],
      [
        0.9198337197303772,
        "    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    if num in freq:\n        return freq[num]\n    else:\n        return 0"
      ],
      [
        0.9189248085021973,
        "    count = 0\n    for n in arr:\n        if n == num:\n            count += 1\n    return count"
      ],
      [
        0.9188922047615051,
        "    count = 0\n    for element in arr:\n        if element == num:\n            count += 1\n    return count"
      ],
      [
        0.9187608361244202,
        "    count = 0\n    n = len(arr)\n    for i in range(0, n):\n        if x == arr[i]:\n            count += 1\n    return count"
      ],
      [
        0.9183273315429688,
        "    count = 0\n    for n in inputArray:\n        if n == number:\n            count += 1\n    return count"
      ],
      [
        0.918102502822876,
        "    count = 0\n    for i in range(len(arr)):\n        if x == arr[i]:\n            count = count + 1\n    return count"
      ],
      [
        0.9177398085594177,
        "    count = 0\n    for num in arr:\n        if num == n:\n            count += 1\n    return count"
      ],
      [
        0.9154573082923889,
        "    count_dict = {}\n    for i in arr:\n        if i in count_dict:\n            count_dict[i] += 1\n        else:\n            count_dict[i] = 1\n    print(f'The number {num} occurs {count_dict[num]} times')\n    return count_dict"
      ],
      [
        0.9152041673660278,
        "    for num in arr:\n        if num == given_number:\n            count += 1"
      ]
    ],
    "MBPP/158": [
      [
        0.9290260076522827,
        "    if n not in pell_dict:\n        pell_dict[n] = 2 * pell(n - 1) + pell(n - 2)"
      ],
      [
        0.9269787073135376,
        "    if n not in pell_dict:\n        pell_dict[n] = 2 * pell(n - 1) + pell(n - 2)\n    return pell_dict[n]"
      ],
      [
        0.9249625205993652,
        "    for i in range(2, n + 1):\n        pell_numbers.append(2 * pell_numbers[i - 1] + pell_numbers[i - 2])"
      ],
      [
        0.9249482750892639,
        "    for i in range(2, n + 1):\n        pell_numbers.append(2 * pell_numbers[i - 1] + pell_numbers[i - 2])"
      ],
      [
        0.9009565711021423,
        "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n)"
      ],
      [
        0.9009565711021423,
        "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n)"
      ],
      [
        0.8978692293167114,
        "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n) + nth_prime(n)"
      ],
      [
        0.8978692293167114,
        "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n) + nth_prime(n)"
      ],
      [
        0.8970115780830383,
        "    if n < 1:\n        return 'Input must be a positive integer.'\n    if not ds_type in ['list', 'tuple', 'dictionary']:\n        return 'Invalid data structure type. Please choose list, tuple, or dictionary.'\n    pell_numbers = [0, 1]\n    for i in range(2, n + 1):\n        pell_numbers.append(2 * pell_numbers[i - 1] + pell_numbers[i - 2])\n    if ds_type == 'list':\n        return pell_numbers[:n + 1]\n    elif ds_type == 'tuple':\n        return tuple(pell_numbers[:n + 1])\n    elif ds_type == 'dictionary':\n        return {i: v for i, v in enumerate(pell_numbers[:n + 1])}"
      ],
      [
        0.8969901204109192,
        "    if n < 1:\n        return 'Input must be a positive integer.'\n    if not ds_type in ['list', 'tuple', 'dictionary']:\n        return 'Invalid data structure type. Please choose list, tuple, or dictionary.'\n    pell_numbers = [0, 1]\n    for i in range(2, n + 1):\n        pell_numbers.append(2 * pell_numbers[i - 1] + pell_numbers[i - 2])\n    if ds_type == 'list':\n        return pell_numbers[:n + 1]\n    elif ds_type == 'tuple':\n        return tuple(pell_numbers[:n + 1])\n    elif ds_type == 'dictionary':\n        return {i: v for i, v in enumerate(pell_numbers[:n + 1])}"
      ]
    ],
    "MBPP/159": [
      [
        0.8953484296798706,
        "    try:\n        return sum(array[start:end + 1])\n    except IndexError:\n        print('Index out of range')\n    except TypeError:\n        print('Invalid input')\n    except Exception as e:\n        print('Error:', e)"
      ],
      [
        0.8953484296798706,
        "    try:\n        return sum(array[start:end + 1])\n    except IndexError:\n        print('Index out of range')\n    except TypeError:\n        print('Invalid input')\n    except Exception as e:\n        print('Error:', e)"
      ],
      [
        0.895315408706665,
        "    try:\n        return sum(array[start:end + 1])\n    except IndexError:\n        print('Index out of range')\n    except TypeError:\n        print('Invalid input')\n    except Exception as e:\n        print('Error:', e)"
      ],
      [
        0.895315408706665,
        "    try:\n        return sum(array[start:end + 1])\n    except IndexError:\n        print('Index out of range')\n    except TypeError:\n        print('Invalid input')\n    except Exception as e:\n        print('Error:', e)"
      ],
      [
        0.8933449983596802,
        "    if isinstance(start, int) and isinstance(end, int):\n        num_list = []\n        for num in range(start, end + 1):\n            num_list.append(num)\n        return sum(num_list)\n    else:\n        return 'Input values must be integers'"
      ],
      [
        0.8933449983596802,
        "    if isinstance(start, int) and isinstance(end, int):\n        num_list = []\n        for num in range(start, end + 1):\n            num_list.append(num)\n        return sum(num_list)\n    else:\n        return 'Input values must be integers'"
      ],
      [
        0.8928914666175842,
        "    sum = sum(range(num1, num2 + 1))\n    return sum"
      ],
      [
        0.8923788070678711,
        "    sum = 0\n    for i in range(start, end + 1):\n        sum = sum + i\n    return sum"
      ],
      [
        0.8895972967147827,
        "    sum = 0\n    for i in range(start, end + 1):\n        sum += i\n    return sum"
      ],
      [
        0.8895923495292664,
        "    sum = 0\n    for i in range(start, end + 1):\n        sum += i\n    return sum"
      ]
    ],
    "MBPP/160": [
      [
        0.9000008702278137,
        "    if x < 7 or x > 15:\n        return 'Error: Input value is out of range.'\n    else:\n        perimeter = 5 * x\n        return perimeter"
      ],
      [
        0.9000008702278137,
        "    if x < 7 or x > 15:\n        return 'Error: Input value is out of range.'\n    else:\n        perimeter = 5 * x\n        return perimeter"
      ],
      [
        0.8985764980316162,
        "    if len(sides) != 5:\n        return 'Not a Pentagon'\n    else:\n        return sum(sides)"
      ],
      [
        0.8985764980316162,
        "    if len(sides) != 5:\n        return 'Not a Pentagon'\n    else:\n        return sum(sides)"
      ],
      [
        0.8766022324562073,
        "        if isPentagonal(hexagonal):\n            return hexagonal"
      ],
      [
        0.8755061626434326,
        "    perimeter = 2 * math.pi * radius\n    return perimeter"
      ],
      [
        0.871109664440155,
        "    while True:\n        hexagonal = n * (2 * n - 1)\n        if isPentagonal(hexagonal):\n            return hexagonal\n        n += 1"
      ],
      [
        0.870651364326477,
        "    total_angles_octagon = 1080\n    sum_given_angles = angle1 + angle2 + angle3 + angle4 + angle5\n    return total_angles_octagon - sum_given_angles"
      ],
      [
        0.8702915906906128,
        "    if not isinstance(side, (float, int)):\n        raise ValueError('The input should be a number')\n    return side / (2 * sin(pi / 5))"
      ]
    ],
    "MBPP/161": [
      [
        0.9073923826217651,
        "    count = 0\n    for item in lst:\n        if item == string:\n            count += 1\n    return count"
      ],
      [
        0.9069690704345703,
        "    for item in lst:\n        if item == string:\n            count += 1"
      ],
      [
        0.9054012894630432,
        "    occurrences = [0] * len(character_to_find)\n    inside_quotes = False\n    for char in given_string:\n        if char == '\"':\n            inside_quotes = not inside_quotes\n            continue\n        if not inside_quotes and char in character_to_find:\n            index = character_to_find.index(char)\n            occurrences[index] += 1\n    return occurrences"
      ],
      [
        0.9045649766921997,
        "    for ch in string:\n        if ch == x:\n            count += 1"
      ],
      [
        0.904428243637085,
        "    count = 0\n    for i in my_list:\n        if i == char:\n            count += 1\n    return count"
      ],
      [
        0.9039754867553711,
        "    count = 0\n    for ch in string:\n        if ch == x:\n            count += 1\n    return count"
      ],
      [
        0.903429388999939,
        "    for i in range(len(lst)):\n        if lst[i] == strr:\n            if first_occurrence == -1:\n                first_occurrence = i\n            last_occurrence = i"
      ],
      [
        0.9030880928039551,
        "    for string in lst:\n        if target.lower() in string.lower():\n            print(string)\n            count += string.lower().count(target.lower())"
      ],
      [
        0.902509868144989,
        "    for char in given_string:\n        if char == '\"':\n            inside_quotes = not inside_quotes\n            continue\n        if not inside_quotes and char in character_to_find:\n            index = character_to_find.index(char)\n            occurrences[index] += 1"
      ],
      [
        0.9022717475891113,
        "    for i in my_list:\n        if i == char:\n            count += 1"
      ]
    ],
    "MBPP/162": [
      [
        0.9411763548851013,
        "    new_string = []\n    for char in string:\n        if char.isalnum() or char == ' ':\n            new_string.append(char)\n    return ''.join(new_string)"
      ],
      [
        0.939583420753479,
        "    result = ''\n    for char in string:\n        if char.isalnum():\n            result += char\n    return result"
      ],
      [
        0.9387665390968323,
        "    cleanedString = ''\n    for c in string:\n        if c.isalnum():\n            cleanedString += c\n    return cleanedString"
      ],
      [
        0.9379321336746216,
        "    new_string = ''\n    for char in text:\n        if char.isalnum():\n            new_string += char\n    return new_string"
      ],
      [
        0.9374183416366577,
        "    alphanumeric = ''\n    for character in str:\n        if character.isalnum():\n            alphanumeric += character\n    return alphanumeric"
      ],
      [
        0.9352468252182007,
        "    special_characters = '!@#$%^&*()_-+={}[]|\\\\/:;\"\\'<>?,.~`'\n    new_string = ''\n    for char in string:\n        if char.isalnum():\n            new_string += char\n    return new_string"
      ],
      [
        0.935107946395874,
        "    result = ''\n    for c in string:\n        if c.isalnum() or c == ' ':\n            result += c\n    return result"
      ],
      [
        0.9343364834785461,
        "    alphanumeric = ''\n    for char in text:\n        if char.isalnum():\n            alphanumeric += char\n    return alphanumeric"
      ],
      [
        0.9334827065467834,
        "    output_str = ''.join((char for char in input_str if char.isalnum() or char.isspace()))\n    return output_str"
      ],
      [
        0.9330509901046753,
        "    for character in s:\n        if not character.isalnum():\n            s = s.replace(character, '')\n    return s"
      ]
    ],
    "MBPP/163": [
      [
        0.8952623605728149,
        "    for key, value in lst:\n        if key in dictionary:\n            dictionary[key].append(value)\n        else:\n            dictionary[key] = [value]"
      ],
      [
        0.8872911334037781,
        "    out_dict = {}\n    for key, value in input_list:\n        if key in out_dict:\n            out_dict[key].append(value)\n        else:\n            out_dict[key] = [value]\n    return out_dict"
      ],
      [
        0.8872718214988708,
        "    out_dict = {}\n    for key, value in input_list:\n        if key in out_dict:\n            out_dict[key].append(value)\n        else:\n            out_dict[key] = [value]\n    return out_dict"
      ],
      [
        0.8844001293182373,
        "    groups = {}\n    for dictionary in lst:\n        if dictionary['name'] in groups:\n            groups[dictionary['name']].append(dictionary)\n        else:\n            groups[dictionary['name']] = [dictionary]\n    return groups"
      ],
      [
        0.8820249438285828,
        "    for tup in list_of_tuples:\n        x, y = tup\n        if x not in result:\n            result[x] = [y]\n        else:\n            result[x].append(y)"
      ],
      [
        0.8807780742645264,
        "    dictionary = {}\n    for key, value in lst:\n        if key in dictionary:\n            dictionary[key].append(value)\n        else:\n            dictionary[key] = [value]\n    dictionary = dict(sorted(dictionary.items(), key=lambda item: sum(item[1]), reverse=True))\n    return dictionary"
      ],
      [
        0.8795404434204102,
        "    for key, value in input_list:\n        if key in out_dict:\n            out_dict[key].append(value)\n        else:\n            out_dict[key] = [value]"
      ],
      [
        0.8795080184936523,
        "    for key, value in input_list:\n        if key in out_dict:\n            out_dict[key].append(value)\n        else:\n            out_dict[key] = [value]"
      ],
      [
        0.8783106207847595,
        "    result = {}\n    for tup in list_of_tuples:\n        x, y = tup\n        if x not in result:\n            result[x] = [y]\n        else:\n            result[x].append(y)\n    return result"
      ],
      [
        0.8730562925338745,
        "    for d in lst:\n        key = d[key1]\n        if key not in groups:\n            groups[key] = []\n        groups[key].append(d)"
      ]
    ],
    "MBPP/164": [
      [
        0.9279939532279968,
        "    stack = []\n    for char in parentheses:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0"
      ],
      [
        0.9252262115478516,
        "    balance = 0\n    for char in string:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0"
      ],
      [
        0.9242774248123169,
        "    stack = []\n    for char in string:\n        if char == '(':\n            stack.append('(')\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return stack == []"
      ],
      [
        0.9231415390968323,
        "    stack = []\n    for char in input_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0"
      ],
      [
        0.9229155778884888,
        "    stack = []\n    for char in input_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0"
      ],
      [
        0.922761857509613,
        "    stack = []\n    for char in input_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack"
      ],
      [
        0.9219396710395813,
        "    stack = []\n    for c in string:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0"
      ],
      [
        0.9215385913848877,
        "    stack = []\n    for ch in input_string:\n        if ch == '(':\n            stack.append(ch)\n        elif ch == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack"
      ],
      [
        0.9212367534637451,
        "    stack = []\n    for ch in string:\n        if ch == '(':\n            stack.append(ch)\n        elif ch == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                return False\n    return len(stack) == 0"
      ],
      [
        0.9211243987083435,
        "    for char in string:\n        if char in parentheses.keys():\n            stack.append(char)\n        elif char in parentheses.values():\n            if len(stack) == 0 or parentheses[stack.pop()] != char:\n                return False"
      ]
    ],
    "MBPP/165": [
      [
        0.9182949662208557,
        "    perimeter = side1 + side2 + side3\n    return perimeter"
      ],
      [
        0.9177484512329102,
        "    perimeter = l1 + l2 + l3\n    return perimeter"
      ],
      [
        0.910682737827301,
        "    if side1 + side2 <= side3 or side1 + side3 <= side2 or side2 + side3 <= side1:\n        raise InvalidTriangleException('The lengths provided do not form a valid triangle.')\n    else:\n        perimeter = side1 + side2 + side3\n        return perimeter"
      ],
      [
        0.910682737827301,
        "    if side1 + side2 <= side3 or side1 + side3 <= side2 or side2 + side3 <= side1:\n        raise InvalidTriangleException('The lengths provided do not form a valid triangle.')\n    else:\n        perimeter = side1 + side2 + side3\n        return perimeter"
      ],
      [
        0.9069977402687073,
        "    perimeter = side1 + side2 + side3\n    perimeter = round(perimeter, 2)\n    return perimeter"
      ],
      [
        0.9011543989181519,
        "    if side1 <= 0 or side2 <= 0 or side3 <= 0:\n        return 'Side lengths must be greater than 0.'\n    perimeter = side1 + side2 + side3\n    return perimeter"
      ],
      [
        0.8933212757110596,
        "    if a + b <= c or a + c <= b or b + c <= a:\n        raise InvalidTriangleError('Invalid triangle: lengths do not form a valid triangle')\n    perimeter = a + b + c\n    s = perimeter / 2\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    return (perimeter, area)"
      ],
      [
        0.8895595073699951,
        "    if side1 <= 0 or side2 <= 0 or side3 <= 0:\n        return -1\n    if side1 + side2 <= side3 or side2 + side3 <= side1 or side1 + side3 <= side2:\n        return -1\n    perimeter = side1 + side2 + side3\n    if side1 == side2 and side2 == side3:\n        triangle_type = 'equilateral'\n    elif side1 == side2 or side2 == side3 or side1 == side3:\n        triangle_type = 'isosceles'\n    else:\n        triangle_type = 'scalene'\n    return (triangle_type, perimeter)"
      ],
      [
        0.889333188533783,
        "    if side1 == side2 or side2 == side3 or side1 == side3:\n        print('Isosceles triangle')\n        perimeter = side1 + side2 + side3\n        print('Perimeter:', perimeter)\n        return"
      ],
      [
        0.8873046040534973,
        "    if a <= 0 or b <= 0 or c <= 0 or (a + b <= c) or (a + c <= b) or (b + c <= a):\n        raise ValueError('Invalid side lengths. They do not form a valid triangle.')\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    perimeter = a + b + c\n    is_right_angled = a ** 2 + b ** 2 == c ** 2 or a ** 2 + c ** 2 == b ** 2 or b ** 2 + c ** 2 == a ** 2\n    return (area, perimeter, is_right_angled)"
      ]
    ],
    "MBPP/166": [
      [
        0.8941998481750488,
        "    gcd_value = math.gcd(a, b)\n    lcm_value = abs(a * b) / gcd_value\n    return (gcd_value, lcm_value)"
      ],
      [
        0.8931942582130432,
        "    num_list = [i for i in range(x, y + 1) if i % z == 0 and i % w == 0 and (i % 2 == 0)]\n    if not num_list:\n        return (-1, -1)\n    num_list.sort()\n    try:\n        return (num_list[-m], num_list[n - 1])\n    except IndexError:\n        return (-1, -1)"
      ],
      [
        0.8921366930007935,
        "    lcm = math.lcm(a, b)\n    gcd = math.gcd(a, b)\n    return (lcm, gcd)"
      ],
      [
        0.890631914138794,
        "    gcd = math.gcd(a, b)\n    lcm = abs(a * b) // gcd\n    return (lcm, gcd)"
      ],
      [
        0.8883483409881592,
        "    largest_prime = -1\n    smallest_square = -1\n    for i in range(b, a - 1, -1):\n        if i % e == 0 and is_prime(i):\n            largest_prime = i\n            break\n    for i in range(c, f + 1):\n        if i % b == 0 and is_perfect_square(i):\n            smallest_square = i\n            break\n    return (largest_prime, smallest_square)"
      ],
      [
        0.888211727142334,
        "    if a > b:\n        small = b\n    else:\n        small = a\n    for i in range(1, small + 1):\n        if a % i == 0 and b % i == 0:\n            gcd = i\n    lcm = int(a * b) / int(gcd)\n    return (gcd, lcm)"
      ],
      [
        0.8876478672027588,
        "    min_val = float('inf')\n    max_val = float('-inf')\n    for num in lst:\n        if num >= rng[0] and num <= rng[1]:\n            if num < min_val and num % 3 == 0:\n                min_val = num\n            if num > max_val and is_prime(num):\n                max_val = num\n    return max_val if max_val > min_val else None"
      ],
      [
        0.8831688761711121,
        "    gcd = math.gcd(a, b)\n    lcm = a * b // gcd\n    return lcm"
      ],
      [
        0.882668137550354,
        "    if highest % lowest == 0:\n        return (highest, lowest)"
      ],
      [
        0.8826587200164795,
        "    if highest % lowest == 0:\n        return (highest, lowest)"
      ]
    ],
    "MBPP/167": [
      [
        0.9034456014633179,
        "    for string in lst:\n        if target.lower() in string.lower():\n            print(string)\n            count += 1"
      ],
      [
        0.9024444818496704,
        "    found = False\n    if str1.find(str2) != -1:\n        found = True\n    return found"
      ],
      [
        0.9024286866188049,
        "    for string in lst:\n        if target.lower() in string.lower():\n            print(string)\n            count += string.lower().count(target.lower())"
      ],
      [
        0.9024115204811096,
        "    if search in string:\n        return True\n    else:\n        return False"
      ],
      [
        0.9024115204811096,
        "    if search in string:\n        return True\n    else:\n        return False"
      ],
      [
        0.9018763303756714,
        "    for string in strings:\n        if target in string:\n            print(string)"
      ],
      [
        0.9018763303756714,
        "    for string in strings:\n        if target in string:\n            print(string)"
      ],
      [
        0.901218593120575,
        "    count = 0\n    for string in lst:\n        if target.lower() in string.lower():\n            print(string)\n            count += 1\n    return count"
      ],
      [
        0.9001145362854004,
        "    for string in strings:\n        if search == string:\n            return True\n    return False"
      ],
      [
        0.8997582793235779,
        "    for string in strings:\n        if search == string:\n            return True"
      ]
    ],
    "MBPP/168": [
      [
        0.8825111985206604,
        "    num = str(num)\n    digits = [int(x) for x in num]\n    return sum(digits) == 1"
      ],
      [
        0.8824671506881714,
        "    sqrt = int(math.sqrt(num))\n    return sqrt * sqrt == num"
      ],
      [
        0.8824599385261536,
        "    sqrt = int(math.sqrt(num))\n    return sqrt * sqrt == num"
      ],
      [
        0.8824596405029297,
        "    sqrt = int(math.sqrt(num))\n    return sqrt * sqrt == num"
      ],
      [
        0.8824478387832642,
        "    sqrt = int(math.sqrt(num))\n    return sqrt * sqrt == num"
      ],
      [
        0.8821195960044861,
        "    if not isinstance(number, (int, float)) or number < 0:\n        return False\n    if number % 5 != 0:\n        return False\n    digits_sum = sum((int(digit) for digit in str(number) if digit.isdigit()))\n    if digits_sum % 3 != 0:\n        return False\n    number_str = str(number)\n    if number_str == number_str[::-1]:\n        return True\n    if isinstance(number, float):\n        decimal_part = number - int(number)\n        if decimal_part % 2 == 0:\n            return True\n    return False"
      ],
      [
        0.8817116022109985,
        "    powersOfThree = [1, 3, 9, 27, 81, 243, 729, 2187, 6561, 19683, 59049, 177147, 531441, 1594323, 4782969, 14348907, 43046721, 129140163, 387420489, 1162261467]\n    return n in powersOfThree"
      ],
      [
        0.8797844648361206,
        "    root = math.sqrt(num)\n    if int(root + 0.5) ** 2 == num:\n        return True\n    else:\n        return False"
      ],
      [
        0.879473090171814,
        "    count = 0\n    while num != 0:\n        num //= 10\n        count += 1\n    return is_prime(count)"
      ],
      [
        0.8792668581008911,
        "        if num >= 2 and num <= 6 and (num % 3 == 0):\n            return True\n        else:\n            return False"
      ]
    ],
    "MBPP/169": [
      [
        0.9179123640060425,
        "    degrees_to_radians = math.pi / 180.0\n    phi1 = (90.0 - lat1) * degrees_to_radians\n    phi2 = (90.0 - lat2) * degrees_to_radians\n    theta1 = long1 * degrees_to_radians\n    theta2 = long2 * degrees_to_radians\n    cos = math.sin(phi1) * math.sin(phi2) * math.cos(theta1 - theta2) + math.cos(phi1) * math.cos(phi2)\n    arc = math.acos(cos)\n    earth_radius_km = 6371\n    distance = arc * earth_radius_km\n    return distance"
      ],
      [
        0.9178856611251831,
        "    R = 6373.0\n    lat1 = radians(lat1)\n    long1 = radians(long1)\n    lat2 = radians(lat2)\n    long2 = radians(long2)\n    dlon = long2 - long1\n    dlat = lat2 - lat1\n    a = sin(dlat / 2) ** 2 + cos(lat1) * cos(lat2) * sin(dlon / 2) ** 2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = R * c\n    return distance"
      ],
      [
        0.9159469604492188,
        "    R = 6371\n    lat1_rad = math.radians(lat1)\n    long1_rad = math.radians(long1)\n    lat2_rad = math.radians(lat2)\n    long2_rad = math.radians(long2)\n    delta_lat = lat2_rad - lat1_rad\n    delta_long = long2_rad - long1_rad\n    a = math.sin(delta_lat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(delta_long / 2) ** 2\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n    distance = R * c\n    return round(distance, 2)"
      ],
      [
        0.9140498042106628,
        "    R = 6371\n    dLat = math.radians(lat2 - lat1)\n    dLon = math.radians(lon2 - lon1)\n    lat1 = math.radians(lat1)\n    lat2 = math.radians(lat2)\n    a = math.sin(dLat / 2) * math.sin(dLat / 2) + math.sin(dLon / 2) * math.sin(dLon / 2) * math.cos(lat1) * math.cos(lat2)\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n    distance = R * c\n    return distance"
      ],
      [
        0.9140160083770752,
        "    R = 6371\n    dLat = math.radians(lat2 - lat1)\n    dLon = math.radians(lon2 - lon1)\n    lat1 = math.radians(lat1)\n    lat2 = math.radians(lat2)\n    a = math.sin(dLat / 2) * math.sin(dLat / 2) + math.sin(dLon / 2) * math.sin(dLon / 2) * math.cos(lat1) * math.cos(lat2)\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n    distance = R * c\n    return distance"
      ],
      [
        0.9131121635437012,
        "    R = 6373.0\n    lat1 = radians(lat1)\n    lon1 = radians(lon1)\n    lat2 = radians(lat2)\n    lon2 = radians(lon2)\n    dlon = lon2 - lon1\n    dlat = lat2 - lat1\n    a = sin(dlat / 2) ** 2 + cos(lat1) * cos(lat2) * sin(dlon / 2) ** 2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = R * c\n    return distance"
      ],
      [
        0.9129574298858643,
        "    R = 6371\n    lat1_rad = math.radians(lat1)\n    lon1_rad = math.radians(lon1)\n    lat2_rad = math.radians(lat2)\n    lon2_rad = math.radians(lon2)\n    dlat = lat2_rad - lat1_rad\n    dlon = lon2_rad - lon1_rad\n    a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n    distance = R * c\n    return distance"
      ],
      [
        0.9129302501678467,
        "    R = 6371.0\n    lat1_rad = math.radians(lat1)\n    lon1_rad = math.radians(lon1)\n    lat2_rad = math.radians(lat2)\n    lon2_rad = math.radians(lon2)\n    dlat = lat2_rad - lat1_rad\n    dlon = lon2_rad - lon1_rad\n    a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n    distance = R * c\n    return distance"
      ],
      [
        0.9127559661865234,
        "    R = 6371.0\n    lat_rad1 = math.radians(lat1)\n    lon_rad1 = math.radians(lon1)\n    lat_rad2 = math.radians(lat2)\n    lon_rad2 = math.radians(lon2)\n    delta_lat = lat_rad2 - lat_rad1\n    delta_lon = lon_rad2 - lon_rad1\n    a = math.sin(delta_lat / 2) ** 2 + math.cos(lat_rad1) * math.cos(lat_rad2) * math.sin(delta_lon / 2) ** 2\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n    distance = R * c\n    return distance"
      ],
      [
        0.9127269983291626,
        "    lat1, lon1 = p1\n    lat2, lon2 = p2\n    lat1 = math.radians(lat1)\n    lon1 = math.radians(lon1)\n    lat2 = math.radians(lat2)\n    lon2 = math.radians(lon2)\n    dlon = lon2 - lon1\n    dlat = lat2 - lat1\n    a = math.sin(dlat / 2) ** 2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2) ** 2\n    c = 2 * math.asin(math.sqrt(a))\n    r = 6371\n    return c * r"
      ]
    ],
    "MBPP/170": [
      [
        0.9348723888397217,
        "    prefix = strings[0]\n    for string in strings:\n        while not string.startswith(prefix):\n            if not prefix:\n                return ''\n            prefix = prefix[0:-1]\n    return prefix"
      ],
      [
        0.9316796064376831,
        "    first_str = strings[0]\n    longest_prefix = ''\n    for i in range(len(first_str)):\n        current_prefix = first_str[:i]\n        flag = True\n        for string in strings[1:]:\n            if not string.startswith(current_prefix):\n                flag = False\n                break\n        if flag:\n            longest_prefix = current_prefix\n    return longest_prefix"
      ],
      [
        0.9309231638908386,
        "    if len(strings) == 0:\n        return ''\n    longest_prefix = ''\n    first_string = strings[0]\n    for i in range(len(first_string)):\n        current_char = first_string[i]\n        for string in strings[1:]:\n            if i >= len(string) or string[i] != current_char:\n                return longest_prefix\n        longest_prefix += current_char\n    return longest_prefix"
      ],
      [
        0.9306079149246216,
        "    if not strings:\n        return ''\n    prefix = strings[0]\n    for string in strings[1:]:\n        while string.startswith(prefix) is False:\n            prefix = prefix[:-1]\n        if prefix == '':\n            return ''\n    return prefix"
      ],
      [
        0.9304405450820923,
        "    if not strings:\n        return ''\n    prefix = strings[0]\n    for i in range(1, len(strings)):\n        while strings[i].find(prefix) != 0:\n            prefix = prefix[:-1]\n            if not prefix:\n                return ''\n    return prefix"
      ],
      [
        0.9304333329200745,
        "    if not strings:\n        return ''\n    prefix = strings[0]\n    for i in range(1, len(strings)):\n        while strings[i].find(prefix) != 0:\n            prefix = prefix[:-1]\n            if not prefix:\n                return ''\n    return prefix"
      ],
      [
        0.9287176132202148,
        "    if len(strings) == 0:\n        return ''\n    prefix = strings[0]\n    for s in strings:\n        i = 0\n        while i < len(prefix) and i < len(s) and (s[i] == prefix[i]):\n            i += 1\n        prefix = prefix[:i]\n    return prefix"
      ],
      [
        0.9275519251823425,
        "    LCprefix = ''\n    s1 = string_set[0]\n    s2 = string_set[1]\n    n1 = len(s1)\n    n2 = len(s2)\n    minimum = min(n1, n2)\n    for i in range(minimum):\n        if s1[i] == s2[i]:\n            LCprefix += s1[i]\n        else:\n            break\n    for j in range(2, len(string_set)):\n        curr_string = string_set[j]\n        curr_length = len(curr_string)\n        if LCprefix == '':\n            break\n        for k in range(len(LCprefix)):\n            if k == curr_length or LCprefix[k] != curr_string[k]:\n                LCprefix = LCprefix[:k]\n                break\n    return LCprefix"
      ],
      [
        0.927394449710846,
        "    if len(strings) == 0:\n        return ''\n    prefix = strings[0]\n    for i in range(1, len(strings)):\n        j = 0\n        while j < len(prefix) and j < len(strings[i]) and (strings[i][j] == prefix[j]):\n            j += 1\n        prefix = prefix[:j]\n    return prefix"
      ],
      [
        0.9229365587234497,
        "    prefix = ''\n    min_length = min([len(s) for s in strings])\n    for i in range(min_length):\n        current_char = strings[0][i]\n        for s in strings:\n            if s[i] != current_char:\n                return prefix\n        prefix += current_char\n    return prefix"
      ]
    ],
    "MBPP/171": [
      [
        0.9288910627365112,
        "    upper_count = 0\n    lower_count = 0\n    num_count = 0\n    special_count = 0\n    for char in string:\n        if char.isupper():\n            upper_count += 1\n        elif char.islower():\n            lower_count += 1\n        elif char.isnumeric():\n            num_count += 1\n        else:\n            special_count += 1\n    return (upper_count, lower_count, num_count, special_count)"
      ],
      [
        0.9227678179740906,
        "    upper_case = 0\n    digits = 0\n    special_characters = 0\n    for character in string:\n        if character.isupper():\n            upper_case += 1\n        elif character.isdigit():\n            digits += 1\n        elif character.isalpha() or character.isspace():\n            continue\n        else:\n            special_characters += 1\n    return (upper_case, digits, special_characters)"
      ],
      [
        0.9170250296592712,
        "    alpha = 0\n    num = 0\n    special = 0\n    upper = 0\n    for ch in string:\n        if ch.isalpha():\n            alpha += 1\n            if ch.isupper():\n                upper += 1\n        elif ch.isdigit():\n            num += 1\n        else:\n            special += 1\n    print('Number of alphabets :', alpha)\n    print('Number of numerical digits :', num)\n    print('Number of special characters :', special)\n    print('Number of uppercase letters :', upper)"
      ],
      [
        0.9152882695198059,
        "    for char in string:\n        if char.isupper():\n            upper_count += 1\n        elif char.islower():\n            lower_count += 1\n        elif char.isnumeric():\n            num_count += 1\n        else:\n            special_count += 1"
      ],
      [
        0.9137067794799805,
        "        elif char.islower():\n            lowercase += 1\n        elif char.isdigit():\n            numbers += 1\n        else:\n            special += 1"
      ],
      [
        0.9129194021224976,
        "        if char.isupper():\n            uppercase += 1\n        elif char.islower():\n            lowercase += 1\n        elif char.isdigit():\n            numbers += 1\n        else:\n            special += 1"
      ],
      [
        0.9124069213867188,
        "    elif not re.search('[a-zA-Z]', s):\n        return 'String does not have any alphabetical letter'\n    elif not re.search('[0-9]', s):\n        return 'String does not have any numerical digit'\n    elif not re.search('[!@#$%^&*(),.?\":{}|<>]', s):\n        return 'String does not have any special character'\n    else:\n        return 'Input meets all the conditions'"
      ],
      [
        0.9119866490364075,
        "    uppercase = 0\n    digits = 0\n    for character in string:\n        if character.isupper():\n            uppercase += 1\n        elif character.isdigit():\n            digits += 1\n    results = {'Uppercase': uppercase, 'Digits': digits}\n    return results"
      ],
      [
        0.9114462733268738,
        "        if char.isupper():\n            upper_count += 1\n        elif char.islower():\n            lower_count += 1\n        elif char.isnumeric():\n            num_count += 1\n        else:\n            special_count += 1"
      ],
      [
        0.9111514091491699,
        "        if char.isupper():\n            uppercase_count += 1\n        elif char.islower():\n            lowercase_count += 1\n        elif char.isdigit():\n            digit_count += 1\n        elif char in '!@#$%^&*':\n            special_char_count += 1"
      ]
    ],
    "MBPP/172": [
      [
        0.9276938438415527,
        "    for num in arr:\n        diff = k - num\n        if diff in pairs:\n            pairs[diff, num] = 1\n        else:\n            pairs[num] = 1"
      ],
      [
        0.9239600896835327,
        "    pairs = {}\n    for num in arr:\n        diff = k - num\n        if diff in pairs:\n            pairs[diff, num] = 1\n        else:\n            pairs[num] = 1\n    return pairs.keys()"
      ],
      [
        0.9134511947631836,
        "    count = 0\n    for i in range(len(array)):\n        for j in range(i + 1, len(array)):\n            if (array[i] + array[j]) % k == 0:\n                count += 1\n    return count"
      ],
      [
        0.9132266640663147,
        "    hashmap = dict()\n    count = 0\n    for i in range(0, len(arr)):\n        if arr[i] in hashmap:\n            count += 1\n        hashmap[arr[i] + k] = arr[i]\n    return count"
      ],
      [
        0.9131980538368225,
        "    count = 0\n    for i in range(len(A)):\n        for j in range(len(A)):\n            if i == j:\n                continue\n            if A[i] + A[j] == k:\n                count += 1\n    return count"
      ],
      [
        0.9123936295509338,
        "    pairs = []\n    dic = {}\n    for i in range(len(array)):\n        complement = k - array[i]\n        if complement in dic:\n            pairs.append([array[i], complement])\n        else:\n            dic[array[i]] = k - array[i]\n    return pairs"
      ],
      [
        0.9123156070709229,
        "    seen = set()\n    pairs = []\n    for num in arr:\n        target = k - num\n        if target in seen:\n            pairs.append([num, target])\n        else:\n            seen.add(num)\n    return pairs"
      ],
      [
        0.9116362929344177,
        "    freq_map = {}\n    count = 0\n    for num in nums:\n        count += freq_map.get(num - k, 0) + freq_map.get(num + k, 0)\n        freq_map[num] = freq_map.get(num, 0) + 1\n    return count"
      ],
      [
        0.911630392074585,
        "    freq_map = {}\n    count = 0\n    for num in nums:\n        count += freq_map.get(num - k, 0) + freq_map.get(num + k, 0)\n        freq_map[num] = freq_map.get(num, 0) + 1\n    return count"
      ],
      [
        0.9100845456123352,
        "    nums.sort()\n    count = 0\n    left, right = (0, 1)\n    while right < len(nums):\n        if nums[right] - nums[left] == k:\n            count += 1\n            left += 1\n            right += 1\n        elif nums[right] - nums[left] > k:\n            left += 1\n        else:\n            right += 1\n    return count"
      ]
    ],
    "MBPP/173": [
      [
        0.92888343334198,
        "    greater_than_num = []\n    for i in list_numbers:\n        if i > num:\n            greater_than_num.append(i)\n    return greater_than_num"
      ],
      [
        0.9216736555099487,
        "    for i in list_numbers:\n        if i > num:\n            greater_than_num.append(i)"
      ],
      [
        0.9191250801086426,
        "    res = []\n    for i in lst:\n        if i > num:\n            res.append(i)\n    return res"
      ],
      [
        0.9171081185340881,
        "    result = []\n    for element in array:\n        if element >= number:\n            result.append(element)\n    return result"
      ],
      [
        0.9132124781608582,
        "    result = []\n    for el in arr:\n        if el > threshold:\n            result.append(el)\n    return result"
      ],
      [
        0.9128434658050537,
        "    return [n for n in lst if n > num]"
      ],
      [
        0.9126511216163635,
        "    output_list = []\n    for element in input_list:\n        if element > input_target:\n            output_list.append(element)\n    output_list.sort()\n    return output_list"
      ],
      [
        0.9126436710357666,
        "    res = []\n    for item in list_in:\n        if item >= given_num:\n            res.append(item)\n    return res"
      ],
      [
        0.9124795198440552,
        "    return [x for x in arr if x > num]"
      ],
      [
        0.9111655950546265,
        "    return [num for num in arr if num > x]"
      ]
    ],
    "MBPP/174": [
      [
        0.8687382936477661,
        "    parabola_distance, error = integrate.quad(parabolic_distance, -4, 0, args=a)\n    straight_distance = sqrt(4 ** 2 + 3 ** 2)\n    return parabola_distance + straight_distance"
      ],
      [
        0.8686052560806274,
        "        if fa * fc < 0:\n            b = (a + b) / 2\n        elif fc * fb < 0:\n            a = (a + b) / 2\n        else:\n            raise Exception('Trisection algorithm failed to converge.')"
      ],
      [
        0.8670088052749634,
        "    x = (c - b) / (a - b)\n    y = (5 - a * x) / b\n    return (x, y)"
      ],
      [
        0.8668419122695923,
        "    elif det == 0:\n        return [(-b + det) / (2 * a)]\n    elif det > 0:\n        return [(-b + det) / (2 * a), (-b - det) / (2 * a)]"
      ],
      [
        0.8664939403533936,
        "    a, b, c, d, e = coefficients\n    y = (-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)\n    return [-y + (y ** 2 - d / a) ** 0.5, -y - (y ** 2 - d / a) ** 0.5]"
      ],
      [
        0.8661195635795593,
        "        elif fc * fb < 0:\n            a = (a + b) / 2\n        else:\n            raise Exception('Trisection algorithm failed to converge.')"
      ],
      [
        0.8660566210746765,
        "    y_derivative = 5 - 2 * y\n    y_optimal = 5 / 2\n    x_optimal = (y_optimal ** 2 + 5 * y_optimal) / 6\n    y_optimal = 5 * x / 6\n    return (x_optimal, y_optimal)"
      ],
      [
        0.8647657632827759,
        "    a = 1\n    b = -1\n    c = -2 * area\n    x = (-b + sqrt(b ** 2 - 4 * a * c)) / (2 * a)\n    return (round(x, 2), round(2 * x, 2))"
      ],
      [
        0.8643580675125122,
        "    x = eq.split('=')[0]\n    constant = eq.split('=')[1]\n    coeff = x.split('+')[0]\n    if coeff[0] == '-':\n        coeff = -float(coeff[1:])\n    else:\n        coeff = float(coeff)\n    x_value = (float(constant) - float(coeff)) / (2 * coeff)\n    return x_value"
      ],
      [
        0.8641891479492188,
        "    x = (e * d - b * f) / (a * d - b * c)\n    y = (a * f - e * c) / (a * d - b * c)\n    return (x, y)"
      ]
    ],
    "MBPP/175": [
      [
        0.9112012982368469,
        "    return re.search(word, string)"
      ],
      [
        0.9048604965209961,
        "    pattern = 'hello.*world'\n    match = re.search(pattern, string, re.IGNORECASE)\n    if match:\n        return True\n    else:\n        return False"
      ],
      [
        0.9039621353149414,
        "    pattern = '(?=.*hello)(?=.*world)'\n    return bool(re.search(pattern, string))"
      ],
      [
        0.9023972749710083,
        "    pattern = '(?=.*hello)(?=.*world)'\n    if re.search(pattern, text):\n        return True\n    return False"
      ],
      [
        0.900422215461731,
        "    pattern = '   \\' \\' \\' \\' \\'\\n /\\\\,/\"`\"`\"\\\\`\\\\ /\\\\,'\n    if pattern in input_string:\n        print(pattern)\n    else:\n        print('Pattern not found')"
      ],
      [
        0.8998622298240662,
        "    pattern = '\\\\bhello\\\\b.*\\\\bworld\\\\b'\n    if re.search(pattern, input_string):\n        return True\n    else:\n        return False"
      ],
      [
        0.8983629941940308,
        "    for string in string_array:\n        if re.search(query, string):\n            print(string)"
      ],
      [
        0.8983629941940308,
        "    for string in string_array:\n        if re.search(query, string):\n            print(string)"
      ],
      [
        0.8982324600219727,
        "    pattern = re.compile(substring, re.IGNORECASE)\n    match = re.search(pattern, string)\n    if match:\n        print('Found the substring at index', match.start())\n    else:\n        print('The substring was not found')"
      ],
      [
        0.8967561721801758,
        "    pattern = '.*oo'\n    if re.search(pattern, text):\n        print('The pattern was found in the text!')\n    else:\n        print('The pattern was not found in the text!')"
      ]
    ],
    "MBPP/176": [],
    "MBPP/177": [
      [
        0.9151316285133362,
        "    root = int(sqrt(n))\n    return n == root * root"
      ],
      [
        0.9130526781082153,
        "    square_root = int(num ** 0.5)\n    return square_root * square_root == num"
      ],
      [
        0.9127031564712524,
        "    root = int(n ** 0.5)\n    return n == root * root"
      ],
      [
        0.9127001762390137,
        "    root = int(n ** 0.5)\n    return n == root * root"
      ],
      [
        0.9120903015136719,
        "    square_root = math.sqrt(n)\n    return square_root.is_integer()"
      ],
      [
        0.9119380712509155,
        "    return n == isqrt(n) ** 2"
      ],
      [
        0.911934494972229,
        "    return n == isqrt(n) ** 2"
      ],
      [
        0.9113731384277344,
        "    root = int(num ** 0.5)\n    return root ** 2 == num"
      ],
      [
        0.9113380908966064,
        "    root = int(num ** 0.5)\n    return root ** 2 == num"
      ],
      [
        0.9112712144851685,
        "    if num < 0:\n        return False\n    sqrt_num = math.sqrt(num)\n    return sqrt_num.is_integer()"
      ]
    ],
    "MBPP/178": [
      [
        0.9217358231544495,
        "    arr.sort()\n    smallest_missing = None\n    for i in range(len(arr)):\n        if arr[i] > 0:\n            if arr[i] != i + 1:\n                smallest_missing = i + 1\n                break\n    if smallest_missing is None:\n        smallest_missing = len(arr) + 1\n    return smallest_missing"
      ],
      [
        0.918319821357727,
        "    sorted_arr = sorted(arr)\n    curr = sorted_arr[0]\n    for element in sorted_arr[1:]:\n        if element != curr + 1:\n            return curr + 1\n        else:\n            curr = element\n    return missing"
      ],
      [
        0.9177628755569458,
        "    n = len(nums)\n    present = [False] * (n + 1)\n    for i in range(n):\n        if nums[i] > 0 and nums[i] <= n:\n            present[nums[i]] = True\n    for i in range(1, n + 1):\n        if not present[i]:\n            return i\n    return 'No positive number was found'"
      ]
    ],
    "MBPP/179": [
      [
        0.8911893367767334,
        "                if left <= point[0] <= right and down <= point[1] <= up:\n                    count += 1"
      ],
      [
        0.8867088556289673,
        "            for point in points:\n                if left <= point[0] <= right and down <= point[1] <= up:\n                    count += 1"
      ],
      [
        0.882758617401123,
        "    count = 0\n    startnum = complex(startnum)\n    endnum = complex(endnum)\n    re = startnum.real\n    while re <= endnum.real:\n        im = startnum.imag\n        while im <= endnum.imag:\n            num = complex(re, im)\n            if perfect_square(digit_sum(num.real)) and perfect_square(digit_sum(num.imag)):\n                count += 1\n            im += 1\n        re += 1\n    return count"
      ],
      [
        0.8770949840545654,
        "        if x * x + y * y < 1.0:\n            inside += 1"
      ],
      [
        0.8768942356109619,
        "    points = set()\n    for rectangle in coordinates:\n        for x in range(rectangle[0], rectangle[2]):\n            for y in range(rectangle[1], rectangle[3]):\n                points.add((x, y))\n    return len(points)"
      ],
      [
        0.8752080202102661,
        "            if dx * dx + dy * dy <= query[2] * query[2]:\n                inside += 1"
      ],
      [
        0.8751837611198425,
        "            if dx * dx + dy * dy <= query[2] * query[2]:\n                inside += 1"
      ],
      [
        0.8749985694885254,
        "    count = 0\n    for i in range(start, end + 1):\n        if int(i ** 0.5) ** 2 == i:\n            count += 1\n    return count"
      ],
      [
        0.8747801780700684,
        "    c = i = 0\n    while True:\n        i, sq = (i + 1, i ** n)\n        if sq in range(min_val, max_val + 1):\n            c += 1\n        if sq > max_val:\n            break\n    return c"
      ],
      [
        0.8742026686668396,
        "    if r > l and b > t:\n        return (r - l) * (b - t)\n    else:\n        return 0"
      ]
    ],
    "MBPP/180": [
      [
        0.9089168906211853,
        "    elif month == 'April' or month == 'June' or month == 'September' or (month == 'November'):\n        return '30 days'\n    elif month == 'February':\n        return '28 or 29 days'\n    else:\n        return 'Invalid input'"
      ],
      [
        0.9070520401000977,
        "    thirty_days_months = [4, 6, 9, 11]\n    if month in thirty_days_months:\n        return True\n    elif month == 2:\n        if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            return False\n        else:\n            return True\n    else:\n        return False"
      ],
      [
        0.904664158821106,
        "    if month in thirty_days_months:\n        return True\n    elif month == 2:\n        if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            return False\n        else:\n            return True\n    else:\n        return False"
      ],
      [
        0.9035012722015381,
        "    if month == 'January' or month == 'March' or month == 'May' or (month == 'July') or (month == 'August') or (month == 'October') or (month == 'December'):\n        return '31 days'\n    elif month == 'April' or month == 'June' or month == 'September' or (month == 'November'):\n        return '30 days'\n    elif month == 'February':\n        return '28 or 29 days'\n    else:\n        return 'Invalid input'"
      ],
      [
        0.9035012722015381,
        "    if month == 'January' or month == 'March' or month == 'May' or (month == 'July') or (month == 'August') or (month == 'October') or (month == 'December'):\n        return '31 days'\n    elif month == 'April' or month == 'June' or month == 'September' or (month == 'November'):\n        return '30 days'\n    elif month == 'February':\n        return '28 or 29 days'\n    else:\n        return 'Invalid input'"
      ],
      [
        0.8920319676399231,
        "    if month < 1 or month > 12:\n        return 'No'"
      ],
      [
        0.8920059204101562,
        "    elif month == 'February':\n        return '28 or 29 days'\n    else:\n        return 'Invalid input'"
      ],
      [
        0.8913607597351074,
        "    month_name = month_name.strip().lower()\n    if month_name == 'january':\n        print('Valid month name')\n    elif month_name == 'february':\n        print('Valid month name')\n    elif month_name == 'march':\n        print('Valid month name')\n    elif month_name == 'april':\n        print('Valid month name')\n    elif month_name == 'may':\n        print('Valid month name')\n    elif month_name == 'june':\n        print('Valid month name')\n    elif month_name == 'july':\n        print('Valid month name')\n    elif month_name == 'august':\n        print('Valid month name')\n    elif month_name == 'september':\n        print('Valid month name')\n    elif month_name == 'october':\n        print('Valid month name')\n    elif month_name == 'november':\n        print('Valid month name')\n    elif month_name == 'december':\n        print('Valid month name')\n    elif month_name == 'ramadan':\n        print('Valid month name')\n    elif month_name == 'tishrei':\n        print('Valid month name')\n    else:\n        print('Invalid month name')"
      ],
      [
        0.8896359205245972,
        "    elif month_name == 'december':\n        print('Valid month name')\n    elif month_name == 'ramadan':\n        print('Valid month name')\n    elif month_name == 'tishrei':\n        print('Valid month name')\n    else:\n        print('Invalid month name')"
      ],
      [
        0.8893728852272034,
        "    elif month_name == 'february':\n        print('Valid month name')\n    elif month_name == 'march':\n        print('Valid month name')\n    elif month_name == 'april':\n        print('Valid month name')\n    elif month_name == 'may':\n        print('Valid month name')\n    elif month_name == 'june':\n        print('Valid month name')\n    elif month_name == 'july':\n        print('Valid month name')\n    elif month_name == 'august':\n        print('Valid month name')\n    elif month_name == 'september':\n        print('Valid month name')\n    elif month_name == 'october':\n        print('Valid month name')\n    elif month_name == 'november':\n        print('Valid month name')\n    elif month_name == 'december':\n        print('Valid month name')\n    elif month_name == 'ramadan':\n        print('Valid month name')\n    elif month_name == 'tishrei':\n        print('Valid month name')\n    else:\n        print('Invalid month name')"
      ]
    ],
    "MBPP/181": [
      [
        0.9231870174407959,
        "    has_number = False\n    has_character = False\n    for ch in password:\n        if ch.isdigit():\n            has_number = True\n        elif ch.isalpha():\n            has_character = True\n    if has_character and has_number:\n        return True\n    else:\n        return False"
      ],
      [
        0.9184505343437195,
        "    has_alphabet = False\n    has_number = False\n    for char in str:\n        if char.isalpha():\n            has_alphabet = True\n            if has_number:\n                return False\n        elif char.isnumeric():\n            has_number = True\n            if not has_alphabet:\n                return False\n    return has_alphabet and has_number"
      ],
      [
        0.9099796414375305,
        "    elif not any((x.isdigit() for x in password)):\n        print('Password must contain at least 1 number')\n        return False"
      ],
      [
        0.9099440574645996,
        "        elif char.isnumeric():\n            has_number = True\n            if not has_alphabet:\n                return False"
      ],
      [
        0.909787118434906,
        "        if char.isalpha():\n            has_alphabet = True\n            if has_number:\n                return False\n        elif char.isnumeric():\n            has_number = True\n            if not has_alphabet:\n                return False"
      ],
      [
        0.9080495238304138,
        "    if has_character and has_number:\n        return True\n    else:\n        return False"
      ],
      [
        0.907291054725647,
        "    pattern = '\\\\ba.*\\\\d.*\\\\W\\\\b'\n    if re.search(pattern, s):\n        return True\n    else:\n        return False"
      ],
      [
        0.9070485830307007,
        "    return any((letter.isdigit() for letter in password))"
      ],
      [
        0.9066845774650574,
        "    for char in str:\n        if char.isalpha():\n            has_alphabet = True\n            if has_number:\n                return False\n        elif char.isnumeric():\n            has_number = True\n            if not has_alphabet:\n                return False"
      ],
      [
        0.9060444831848145,
        "    for ch in password:\n        if ch.isdigit():\n            has_number = True\n        elif ch.isalpha():\n            has_character = True"
      ]
    ],
    "MBPP/182": [
      [
        0.9133357405662537,
        "    final_list = []\n    for num in input_list:\n        if num not in final_list:\n            final_list.append(num)\n    return tuple(final_list)"
      ],
      [
        0.9067736864089966,
        "    result_set = set(input_tuple)\n    result_tuple = tuple(result_set)\n    return result_tuple"
      ],
      [
        0.9012144207954407,
        "    seen = set()\n    duplicates = set()\n    for item in input_tuple:\n        if item in seen:\n            duplicates.add(item)\n        seen.add(item)\n    return (len(duplicates) > 0, duplicates)"
      ],
      [
        0.9001868367195129,
        "    new_tuple = []\n    for i in value_in_tuple:\n        if i not in new_tuple:\n            new_tuple.append(i)\n    return tuple(new_tuple)"
      ]
    ],
    "MBPP/183": [
      [
        0.9256635904312134,
        "    decimal = 0\n    base = 1\n    while octal:\n        last_digit = octal % 10\n        octal = int(octal / 10)\n        decimal += last_digit * base\n        base = base * 8\n    return decimal"
      ],
      [
        0.9255750775337219,
        "    octal_number = oct(decimal_number).replace('0o', '')\n    return octal_number"
      ],
      [
        0.9238491058349609,
        "    decimal = int(octal_num, 8)\n    binary = bin(decimal).replace('0b', '')\n    return binary"
      ],
      [
        0.9238311648368835,
        "    decimal = int(octal_num, 8)\n    binary = bin(decimal).replace('0b', '')\n    return binary"
      ],
      [
        0.9236109852790833,
        "    binary_num = str(binary_num)\n    decimal = int(binary_num, 2)\n    octal_num = oct(decimal).replace('0o', '')\n    return octal_num"
      ],
      [
        0.9146581888198853,
        "    octal, i = (0, 0)\n    while binary != 0:\n        octal += binary % 10 * pow(2, i)\n        binary //= 10\n        i += 1\n    return octal"
      ],
      [
        0.9144826531410217,
        "    if octal == 0:\n        return 0\n    else:\n        last_digit = octal % 10\n        decimal = last_digit * 8 ** 0\n        binary = decimal_to_binary(decimal)\n        return binary + 10 * octal_to_binary(octal // 10)"
      ],
      [
        0.9144826531410217,
        "    if octal == 0:\n        return 0\n    else:\n        last_digit = octal % 10\n        decimal = last_digit * 8 ** 0\n        binary = decimal_to_binary(decimal)\n        return binary + 10 * octal_to_binary(octal // 10)"
      ],
      [
        0.9139244556427002,
        "    oct_num = oct(num)\n    print('The octal form of {} is {}'.format(num, oct_num))"
      ],
      [
        0.9129446744918823,
        "    decimal = int(bin_str, 2)\n    octal_str = oct(decimal)[2:]\n    return octal_str"
      ]
    ],
    "MBPP/184": [
      [
        0.9191969633102417,
        "    if arr != sorted(arr):\n        raise ValueError('Array must be sorted')\n    start = 0\n    end = len(arr) - 1\n    while start <= end:\n        mid = (start + end) // 2\n        if arr[mid] == k:\n            return mid\n        elif k < arr[mid]:\n            end = mid - 1\n        else:\n            start = mid + 1\n    return None"
      ],
      [
        0.9166233539581299,
        "    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            return i\n        elif arr[i] > x:\n            return -1\n    return -1"
      ],
      [
        0.9154950976371765,
        "    low = 0\n    high = len(sorted_array) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if sorted_array[mid] < value:\n            low = mid + 1\n        elif sorted_array[mid] > value:\n            high = mid - 1\n        else:\n            return mid\n    return -1"
      ],
      [
        0.9154828190803528,
        "    low = 0\n    high = len(sorted_array) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if sorted_array[mid] < value:\n            low = mid + 1\n        elif sorted_array[mid] > value:\n            high = mid - 1\n        else:\n            return mid\n    return -1"
      ],
      [
        0.9152753353118896,
        "    list.sort()\n    first = 0\n    last = len(list) - 1\n    while first <= last:\n        mid = (first + last) // 2\n        if list[mid] == num:\n            while mid > 0 and list[mid - 1] == num:\n                mid -= 1\n            return mid\n        elif num < list[mid]:\n            last = mid - 1\n        else:\n            first = mid + 1\n    return 'Not found'"
      ],
      [
        0.915206253528595,
        "    lower, upper = (0, len(array))\n    while lower < upper:\n        mid = lower + (upper - lower) // 2\n        if array[mid] <= target:\n            lower = mid + 1\n        else:\n            upper = mid\n    if lower - 1 >= 0 and array[lower - 1] == target:\n        return lower - 1\n    else:\n        return 'The element does not exist in the array'"
      ],
      [
        0.9147289991378784,
        "    n = len(arr)\n    arr.sort()\n    for i in range(n):\n        print(arr[i], end=' ')\n    start = 0\n    end = n - 1\n    while start <= end:\n        mid = (start + end) // 2\n        if x == arr[mid]:\n            return mid\n        elif x > arr[mid]:\n            start = mid + 1\n        else:\n            end = mid - 1\n    return -1"
      ],
      [
        0.9142650365829468,
        "    for i in range(0, n):\n        if sorted_ary[i] == target:\n            return i"
      ],
      [
        0.9139108657836914,
        "    sorted_arr = sort_array(arr)\n    return binary_search(sorted_arr, 0, len(arr) - 1, x)"
      ],
      [
        0.9136996865272522,
        "    first = 0\n    last = len(arr) - 1\n    found = False\n    while first <= last and (not found):\n        mid = (first + last) // 2\n        if arr[mid] == item:\n            found = True\n        elif item < arr[mid]:\n            last = mid - 1\n        else:\n            first = mid + 1\n    return found"
      ]
    ],
    "MBPP/185": [
      [
        0.8826910853385925,
        "    elif k < 1:\n        return input_list\n    else:\n        return input_list[:k - 1] + input_list[k:]"
      ],
      [
        0.8798800706863403,
        "            if condition(i):\n                continue\n            else:\n                result.append(remove_tuples(i, condition))"
      ],
      [
        0.8785513639450073,
        "    words = re.findall('\\\\b\\\\w+\\\\b', s)\n    result = [word for word in words if len(word) != k]\n    return ' '.join(result)"
      ],
      [
        0.8781931400299072,
        "    new_tup = []\n    for elem in initial_tup:\n        if elem != tup_to_expunge:\n            new_tup.append(elem)\n    return tuple(new_tup)"
      ],
      [
        0.8778737783432007,
        "                if not condition(item):\n                    result.append(remove_tuples(item, condition))"
      ],
      [
        0.8778470754623413,
        "                if not condition(item):\n                    result.append(remove_tuples(item, condition))"
      ],
      [
        0.8772312998771667,
        "    if k > len(tup_list):\n        return 'K is greater than the size of list. Returning all records.'"
      ],
      [
        0.8760429620742798,
        "    for elem in initial_tup:\n        if elem != tup_to_expunge:\n            new_tup.append(elem)"
      ],
      [
        0.8748827576637268,
        "    result = []\n    for item in t:\n        if isinstance(item, tuple):\n            try:\n                if not condition(item):\n                    result.append(remove_tuples(item, condition))\n            except Exception as e:\n                print(f'An error occurred: {str(e)}')\n        elif isinstance(item, list):\n            new_list = [i for i in item if not (isinstance(i, tuple) and condition(i))]\n            result.append(new_list)\n        elif isinstance(item, set):\n            new_set = {i for i in item if not (isinstance(i, tuple) and condition(i))}\n            result.append(new_set)\n        elif isinstance(item, dict):\n            new_dict = {k: v for k, v in item.items() if not (isinstance(v, tuple) and condition(v))}\n            result.append(new_dict)\n        else:\n            result.append(item)\n    return tuple(result)"
      ],
      [
        0.8748722076416016,
        "    result = []\n    for item in t:\n        if isinstance(item, tuple):\n            try:\n                if not condition(item):\n                    result.append(remove_tuples(item, condition))\n            except Exception as e:\n                print(f'An error occurred: {str(e)}')\n        elif isinstance(item, list):\n            new_list = [i for i in item if not (isinstance(i, tuple) and condition(i))]\n            result.append(new_list)\n        elif isinstance(item, set):\n            new_set = {i for i in item if not (isinstance(i, tuple) and condition(i))}\n            result.append(new_set)\n        elif isinstance(item, dict):\n            new_dict = {k: v for k, v in item.items() if not (isinstance(v, tuple) and condition(v))}\n            result.append(new_dict)\n        else:\n            result.append(item)\n    return tuple(result)"
      ]
    ],
    "MBPP/186": [
      [
        0.9069257378578186,
        "    if not isinstance(t1, tuple) or not isinstance(t2, tuple):\n        return 'Error: Input is not a tuple!'\n    if len(t1) != len(t2):\n        return 'Error: Tuples are of different sizes!'\n    try:\n        t1 = tuple(map(float, t1))\n        t2 = tuple(map(float, t2))\n    except:\n        return 'Error: Tuple elements are not real numbers!'\n    if any((ele < 0 for ele in t2)):\n        return 'Error: Second Tuple contains negative values!'\n    return tuple(map(pow, t1, t2))"
      ],
      [
        0.9069181680679321,
        "    if not isinstance(t1, tuple) or not isinstance(t2, tuple):\n        return 'Error: Input is not a tuple!'\n    if len(t1) != len(t2):\n        return 'Error: Tuples are of different sizes!'\n    try:\n        t1 = tuple(map(float, t1))\n        t2 = tuple(map(float, t2))\n    except:\n        return 'Error: Tuple elements are not real numbers!'\n    if any((ele < 0 for ele in t2)):\n        return 'Error: Second Tuple contains negative values!'\n    return tuple(map(pow, t1, t2))"
      ],
      [
        0.8965576887130737,
        "        for x, y in zip(tuple1, tuple2):\n            if not isinstance(x, (int, float, complex, str, bool, tuple, list, type(None))) or not isinstance(y, (int, float, complex, str, bool, tuple, list, type(None))):\n                raise ValueError('Invalid input type')\n            numeric_x = convert_to_numeric(x)\n            numeric_y = convert_to_numeric(y)\n            if isinstance(numeric_y, (complex, tuple, list)) or numeric_y < 0:\n                raise ValueError('Exponent cannot be negative or complex')\n            if isinstance(numeric_x, tuple) or isinstance(numeric_y, tuple):\n                result_tuple.append(element_wise_exponentiation(numeric_x, numeric_y))\n            else:\n                result_tuple.append(numeric_x ** numeric_y)"
      ],
      [
        0.8965511918067932,
        "        for x, y in zip(tuple1, tuple2):\n            if not isinstance(x, (int, float, complex, str, bool, tuple, list, type(None))) or not isinstance(y, (int, float, complex, str, bool, tuple, list, type(None))):\n                raise ValueError('Invalid input type')\n            numeric_x = convert_to_numeric(x)\n            numeric_y = convert_to_numeric(y)\n            if isinstance(numeric_y, (complex, tuple, list)) or numeric_y < 0:\n                raise ValueError('Exponent cannot be negative or complex')\n            if isinstance(numeric_x, tuple) or isinstance(numeric_y, tuple):\n                result_tuple.append(element_wise_exponentiation(numeric_x, numeric_y))\n            else:\n                result_tuple.append(numeric_x ** numeric_y)"
      ],
      [
        0.8948987126350403,
        "            if isinstance(numeric_x, tuple) or isinstance(numeric_y, tuple):\n                result_tuple.append(element_wise_exponentiation(numeric_x, numeric_y))\n            else:\n                result_tuple.append(numeric_x ** numeric_y)"
      ],
      [
        0.8948930501937866,
        "            if isinstance(numeric_x, tuple) or isinstance(numeric_y, tuple):\n                result_tuple.append(element_wise_exponentiation(numeric_x, numeric_y))\n            else:\n                result_tuple.append(numeric_x ** numeric_y)"
      ],
      [
        0.8938877582550049,
        "    if len(list1) != len(list2):\n        raise ValueError('Input lists must have equal length')\n    result = []\n    for tuple1, tuple2 in zip(list1, list2):\n        if len(tuple1) != len(tuple2):\n            raise ValueError('Tuples in the same position must have equal length')\n        result_tuple = []\n        for x, y in zip(tuple1, tuple2):\n            if not isinstance(x, (int, float, complex, str, bool, tuple, list, type(None))) or not isinstance(y, (int, float, complex, str, bool, tuple, list, type(None))):\n                raise ValueError('Invalid input type')\n            numeric_x = convert_to_numeric(x)\n            numeric_y = convert_to_numeric(y)\n            if isinstance(numeric_y, (complex, tuple, list)) or numeric_y < 0:\n                raise ValueError('Exponent cannot be negative or complex')\n            if isinstance(numeric_x, tuple) or isinstance(numeric_y, tuple):\n                result_tuple.append(element_wise_exponentiation(numeric_x, numeric_y))\n            else:\n                result_tuple.append(numeric_x ** numeric_y)\n        result.append(tuple(result_tuple))\n    return result"
      ],
      [
        0.8938555717468262,
        "    if len(list1) != len(list2):\n        raise ValueError('Input lists must have equal length')\n    result = []\n    for tuple1, tuple2 in zip(list1, list2):\n        if len(tuple1) != len(tuple2):\n            raise ValueError('Tuples in the same position must have equal length')\n        result_tuple = []\n        for x, y in zip(tuple1, tuple2):\n            if not isinstance(x, (int, float, complex, str, bool, tuple, list, type(None))) or not isinstance(y, (int, float, complex, str, bool, tuple, list, type(None))):\n                raise ValueError('Invalid input type')\n            numeric_x = convert_to_numeric(x)\n            numeric_y = convert_to_numeric(y)\n            if isinstance(numeric_y, (complex, tuple, list)) or numeric_y < 0:\n                raise ValueError('Exponent cannot be negative or complex')\n            if isinstance(numeric_x, tuple) or isinstance(numeric_y, tuple):\n                result_tuple.append(element_wise_exponentiation(numeric_x, numeric_y))\n            else:\n                result_tuple.append(numeric_x ** numeric_y)\n        result.append(tuple(result_tuple))\n    return result"
      ],
      [
        0.8937057852745056,
        "    for tuple1, tuple2 in zip(list1, list2):\n        if len(tuple1) != len(tuple2):\n            raise ValueError('Tuples in the same position must have equal length')\n        result_tuple = []\n        for x, y in zip(tuple1, tuple2):\n            if not isinstance(x, (int, float, complex, str, bool, tuple, list, type(None))) or not isinstance(y, (int, float, complex, str, bool, tuple, list, type(None))):\n                raise ValueError('Invalid input type')\n            numeric_x = convert_to_numeric(x)\n            numeric_y = convert_to_numeric(y)\n            if isinstance(numeric_y, (complex, tuple, list)) or numeric_y < 0:\n                raise ValueError('Exponent cannot be negative or complex')\n            if isinstance(numeric_x, tuple) or isinstance(numeric_y, tuple):\n                result_tuple.append(element_wise_exponentiation(numeric_x, numeric_y))\n            else:\n                result_tuple.append(numeric_x ** numeric_y)\n        result.append(tuple(result_tuple))"
      ],
      [
        0.8936902284622192,
        "    for tuple1, tuple2 in zip(list1, list2):\n        if len(tuple1) != len(tuple2):\n            raise ValueError('Tuples in the same position must have equal length')\n        result_tuple = []\n        for x, y in zip(tuple1, tuple2):\n            if not isinstance(x, (int, float, complex, str, bool, tuple, list, type(None))) or not isinstance(y, (int, float, complex, str, bool, tuple, list, type(None))):\n                raise ValueError('Invalid input type')\n            numeric_x = convert_to_numeric(x)\n            numeric_y = convert_to_numeric(y)\n            if isinstance(numeric_y, (complex, tuple, list)) or numeric_y < 0:\n                raise ValueError('Exponent cannot be negative or complex')\n            if isinstance(numeric_x, tuple) or isinstance(numeric_y, tuple):\n                result_tuple.append(element_wise_exponentiation(numeric_x, numeric_y))\n            else:\n                result_tuple.append(numeric_x ** numeric_y)\n        result.append(tuple(result_tuple))"
      ]
    ],
    "MBPP/187": [
      [
        0.8820161819458008,
        "    angle_C = math.radians(angle_C)\n    cos_C = math.cos(angle_C)\n    c = math.sqrt(a ** 2 + b ** 2 - 2 * a * b * cos_C)\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return area"
      ],
      [
        0.8776544332504272,
        "    s = area / 3 ** 0.5\n    a = (4 * area / s) ** 0.5\n    b = s - a\n    return (a, b, s)"
      ],
      [
        0.876303493976593,
        "    maximum_area = 0\n    max_triangle = None\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            for k in range(j + 1, len(points)):\n                area = calculate_area(points[i], points[j], points[k])\n                if area > maximum_area:\n                    maximum_area = area\n                    max_triangle = (points[i], points[j], points[k])\n    return max_triangle"
      ],
      [
        0.8740177154541016,
        "                if area > maximum_area:\n                    maximum_area = area\n                    max_triangle = (points[i], points[j], points[k])"
      ],
      [
        0.872928261756897,
        "    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            for k in range(j + 1, len(points)):\n                area = calculate_area(points[i], points[j], points[k])\n                if area > maximum_area:\n                    maximum_area = area\n                    max_triangle = (points[i], points[j], points[k])"
      ],
      [
        0.8697078824043274,
        "            for k in range(j + 1, len(points)):\n                area = calculate_area(points[i], points[j], points[k])\n                if area > maximum_area:\n                    maximum_area = area\n                    max_triangle = (points[i], points[j], points[k])"
      ],
      [
        0.8689854145050049,
        "    n = 1\n    while True:\n        l_section_area = n - math.pi / 4\n        triangle_area = 1 / 2 * 1 * (1 / n)\n        if triangle_area / l_section_area < 0.001:\n            return n\n        n += 1"
      ],
      [
        0.8688182830810547,
        "    while True:\n        l_section_area = n - math.pi / 4\n        triangle_area = 1 / 2 * 1 * (1 / n)\n        if triangle_area / l_section_area < 0.001:\n            return n\n        n += 1"
      ]
    ],
    "MBPP/188": [
      [
        0.9149442911148071,
        "    p = 0\n    while 1 << p + 1 <= n:\n        p += 1\n    return p"
      ],
      [
        0.9089426398277283,
        "    while power <= n:\n        power *= 2"
      ],
      [
        0.9077281951904297,
        "    log = 0\n    while n > 1:\n        n = n >> 1\n        log += 1\n    return log"
      ],
      [
        0.9070688486099243,
        "    if math.log2(n).is_integer():\n        return math.log2(n)\n    else:\n        return 'The number is not an exponent of two.'"
      ],
      [
        0.9056826829910278,
        "    if not isinstance(n, int):\n        raise ValueError('Input must be an integer')\n    if math.log2(n).is_integer():\n        return math.log2(n)\n    else:\n        return 'The number is not an exponent of two.'"
      ],
      [
        0.905211329460144,
        "    if N <= 1:\n        return 'N should be more than 1'\n    height = math.log(N, 2)\n    return int(height) + 1"
      ],
      [
        0.9039895534515381,
        "    x = 1\n    while n > x:\n        x = x * 2 + 1\n    return x - n"
      ],
      [
        0.9031598567962646,
        "    return 2 ** int(np.ceil(np.log2(num)))"
      ],
      [
        0.9025833606719971,
        "    while p <= num:\n        p *= 2"
      ],
      [
        0.9025511741638184,
        "    while p <= num:\n        p *= 2"
      ]
    ],
    "MBPP/189": [
      [
        0.9224262237548828,
        "    max_val = lst[0]\n    indices = []\n    for i in range(len(lst)):\n        if lst[i] > max_val:\n            max_val = lst[i]\n            indices = []\n        if lst[i] == max_val:\n            indices.append(i)\n    return indices"
      ],
      [
        0.915312647819519,
        "    max_val = max(lst)\n    indices = [i for i, val in enumerate(lst) if val == max_val]\n    print('The greatest number is {} and its indices are {}'.format(max_val, indices))"
      ],
      [
        0.9145034551620483,
        "    if len(num_list) == 0:\n        return []\n    max_val = num_list[0]\n    max_indices = [0]\n    for i in range(1, len(num_list)):\n        if num_list[i] > max_val:\n            max_val = num_list[i]\n            max_indices = [i]\n        elif num_list[i] == max_val:\n            max_indices.append(i)\n    return [(max_val, index) for index in max_indices]"
      ],
      [
        0.9103996753692627,
        "    max_num = float('-inf')\n    max_indices = []\n    for i in range(len(arr)):\n        if arr[i] > max_num:\n            max_num = arr[i]\n            max_indices = [i]\n        elif arr[i] == max_num:\n            max_indices.append(i)\n    return max_indices"
      ],
      [
        0.9077543616294861,
        "    if not nums:\n        return []\n    max_num = max(nums)\n    indices = [i for i, num in enumerate(nums) if num == max_num]\n    return indices"
      ],
      [
        0.9043885469436646,
        "    max_num = lst[0]\n    max_index = [0]\n    for i in range(1, len(lst)):\n        if lst[i] > max_num:\n            max_num = lst[i]\n            max_index = [i]\n        elif lst[i] == max_num:\n            max_index.append(i)\n    return (max_num, max_index)"
      ],
      [
        0.9036402702331543,
        "    if not array:\n        return 'Cannot find max value and indices in an empty array'\n    max_value = array[0]\n    indices = [0]\n    for i in range(1, len(array)):\n        if array[i] > max_value:\n            max_value = array[i]\n            indices = [i]\n        elif array[i] == max_value:\n            indices.append(i)\n    return (max_value, indices)"
      ],
      [
        0.9023469686508179,
        "    for i in range(len(lst)):\n        if lst[i] > max_val:\n            max_val = lst[i]\n            indices = []\n        if lst[i] == max_val:\n            indices.append(i)"
      ],
      [
        0.9006330966949463,
        "            if lst[i] > max_val:\n                max_val = lst[i]\n                max_idxs = [i]\n            elif lst[i] == max_val:\n                max_idxs.append(i)"
      ],
      [
        0.9001829624176025,
        "        elif lst[i] > max_value:\n            max_value = lst[i]\n            max_indices = [i]\n        elif lst[i] == max_value:\n            max_indices.append(i)"
      ]
    ],
    "MBPP/190": [
      [
        0.921807050704956,
        "    first_elem = arr[0]\n    is_equal = True\n    for elem in arr:\n        if elem != first_elem:\n            is_equal = False\n            break\n    return is_equal"
      ],
      [
        0.92140793800354,
        "    if not lst:\n        return True\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True"
      ],
      [
        0.9205561876296997,
        "    for i in range(len(my_list)):\n        for j in range(i + 1, len(my_list)):\n            if my_list[i] != my_list[j]:\n                return False\n    return True"
      ],
      [
        0.9194902181625366,
        "    if len(lst) == 0:\n        return False\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True"
      ],
      [
        0.917996883392334,
        "    if len(lst) == 0:\n        return True\n    first_element = lst[0]\n    for i in range(1, len(lst)):\n        if lst[i] != first_element:\n            return False\n    return True"
      ],
      [
        0.9154915809631348,
        "    if len(set(list_of_elements)) == 1:\n        return True\n    else:\n        return False"
      ],
      [
        0.9154915809631348,
        "    if len(set(list_of_elements)) == 1:\n        return True\n    else:\n        return False"
      ],
      [
        0.9098378419876099,
        "    if len(arr) == 0:\n        return False\n    return all((arr[0] == x for x in arr))"
      ],
      [
        0.9078000783920288,
        "    for element in lst:\n        if element != first_element:\n            return False"
      ],
      [
        0.9077636003494263,
        "    for element in lst:\n        if element != first_element:\n            return False"
      ]
    ],
    "MBPP/191": [
      [
        0.9170167446136475,
        "    new_str = ''\n    for ch in str:\n        if ord(ch) % 2 == 0:\n            new_str += ch\n    return new_str"
      ],
      [
        0.9159996509552002,
        "    odd_position = ''\n    for i in range(len(string)):\n        if i % 2 == 0:\n            odd_position += string[i]\n    return odd_position"
      ],
      [
        0.9085018634796143,
        "    result_string = ''\n    for i in range(0, len(string)):\n        if i % 2 == 0:\n            result_string += string[i]\n    return result_string"
      ],
      [
        0.9077202081680298,
        "    result = ''\n    for i in range(len(string)):\n        if i % 2 == 0:\n            result += string[i]\n    return result"
      ],
      [
        0.9067381620407104,
        "    words = sentence.split(' ')\n    even_index_words = [words[i] for i in range(len(words)) if i % 2 == 0]\n    return ' '.join(even_index_words)"
      ]
    ],
    "MBPP/192": [
      [
        0.9037507176399231,
        "    xorResult = x ^ y\n    dist = 0\n    while xorResult:\n        dist += xorResult & 1\n        xorResult >>= 1\n    return dist"
      ],
      [
        0.9022668600082397,
        "    return bin(x ^ y).count('1')"
      ],
      [
        0.9019761085510254,
        "    if len(string1) != len(string2):\n        return 'Error: The two binaries are of different length.'\n    count = 0\n    for i in range(len(string1)):\n        if string1[i] != string2[i]:\n            count += 1\n    return count"
      ],
      [
        0.8996706008911133,
        "    count = 0\n    z = x ^ y\n    while z:\n        count += z & 1\n        z >>= 1\n    return count"
      ],
      [
        0.8996378183364868,
        "    hammingDistance = 0\n    for i in range(len(s1)):\n        if s1[i] != s2[i]:\n            hammingDistance += 1\n    return hammingDistance"
      ],
      [
        0.8980016112327576,
        "    distance = 0\n    for bit1, bit2 in zip(str1, str2):\n        if bit1 != bit2:\n            distance += 1\n    return distance"
      ],
      [
        0.8976696133613586,
        "    if len(string1) != len(string2):\n        return 'The binary strings are not of equal length.'\n    diff_str = ''\n    for i in range(len(string1)):\n        if string1[i] != string2[i]:\n            diff_str += '1'\n        else:\n            diff_str += '0'\n    return (diff_str, int(diff_str, 2))"
      ],
      [
        0.8974423408508301,
        "    xor_result = a ^ b\n    count = 0\n    while xor_result:\n        count += xor_result & 1\n        xor_result >>= 1\n    return count"
      ]
    ],
    "MBPP/193": [
      [
        0.9347700476646423,
        "    count = 0\n    for ch in string:\n        if ch == char:\n            count += 1\n    return count"
      ],
      [
        0.9347653985023499,
        "    count = 0\n    for ch in string:\n        if ch == char:\n            count += 1\n    return count"
      ],
      [
        0.9347640872001648,
        "    count = 0\n    for ch in string:\n        if ch == char:\n            count += 1\n    return count"
      ],
      [
        0.9342246055603027,
        "    count = 0\n    for c in string:\n        if c == char:\n            count += 1\n    return count"
      ],
      [
        0.9342195987701416,
        "    count = 0\n    for c in string:\n        if c == char:\n            count += 1\n    return count"
      ],
      [
        0.9342179298400879,
        "    count = 0\n    for c in string:\n        if c == char:\n            count += 1\n    return count"
      ],
      [
        0.9342175126075745,
        "    count = 0\n    for c in string:\n        if c == char:\n            count += 1\n    return count"
      ],
      [
        0.9342132806777954,
        "    count = 0\n    for c in string:\n        if c == char:\n            count += 1\n    return count"
      ],
      [
        0.9342131614685059,
        "    count = 0\n    for c in string:\n        if c == char:\n            count += 1\n    return count"
      ],
      [
        0.9342123866081238,
        "    count = 0\n    for c in string:\n        if c == char:\n            count += 1\n    return count"
      ]
    ],
    "MBPP/194": [
      [
        0.884289026260376,
        "    inverted_array = list(reversed(input_array))\n    inversion_count = 0\n    for i in range(len(input_array)):\n        for j in range(i + 1, len(input_array)):\n            if input_array[i] > input_array[j]:\n                inversion_count += 1\n    return (inverted_array, inversion_count)"
      ],
      [
        0.8842392563819885,
        "    if len(arr) <= 1:\n        return (arr, 0)\n    else:\n        middle = len(arr) // 2\n        left, left_inversions = count_inversions(arr[:middle])\n        right, right_inversions = count_inversions(arr[middle:])\n        result, split_inversions = merge_and_count_inversions(left, right)\n        return (result, left_inversions + right_inversions + split_inversions)"
      ],
      [
        0.8842392563819885,
        "    if len(arr) <= 1:\n        return (arr, 0)\n    else:\n        middle = len(arr) // 2\n        left, left_inversions = count_inversions(arr[:middle])\n        right, right_inversions = count_inversions(arr[middle:])\n        result, split_inversions = merge_and_count_inversions(left, right)\n        return (result, left_inversions + right_inversions + split_inversions)"
      ],
      [
        0.8769542574882507,
        "    inversion_count = 0\n    for i in range(0, len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inversion_count += 1\n    return inversion_count"
      ],
      [
        0.8768625855445862,
        "    inversions = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inversions += 1\n    return inversions"
      ],
      [
        0.8740116953849792,
        "    inversion_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inversion_count += 1\n    return inversion_count"
      ],
      [
        0.8707958459854126,
        "    positions = [i for i, x in enumerate(input_tuple) if x == factor]\n    inverted_positions = positions[::-1]\n    output_list = list(input_tuple)\n    for pos, inverted_pos in zip(positions, inverted_positions):\n        output_list[inverted_pos] = output_list[pos]\n    return tuple(output_list)"
      ],
      [
        0.8688803911209106,
        "    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inversions += 1"
      ],
      [
        0.8684424161911011,
        "    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] < arr[i]:\n                inversions += 1"
      ]
    ],
    "MBPP/195": [
      [
        0.8919780254364014,
        "    merged = ()\n    length = min(len(t1), len(t2))\n    for i in range(length):\n        merged += (t1[i],)\n        merged += (t2[i],)\n    return merged + t1[length:] + t2[length:]"
      ],
      [
        0.890863299369812,
        "    result = []\n    for inner_list in lst:\n        first = inner_list[0]\n        last = inner_list[-1]\n        result.append((first + last, first + last))\n    return result"
      ],
      [
        0.8906599283218384,
        "    result = []\n    for tup in tuples:\n        value_sum = sum(tup)\n        if value_sum % 2 == 0:\n            result.append((tup[0] + 1, tup[1] + 1))\n        else:\n            result.append((tup[0] * 2, tup[1] * 2))\n    return result"
      ],
      [
        0.8871270418167114,
        "    elif len(lst) == 2:\n        return [lst[0] + lst[1]]\n    else:\n        return [lst[0] + lst[1]] + lst[2:]"
      ],
      [
        0.8860898017883301,
        "    if len(lst) == 1:\n        return lst\n    elif len(lst) == 2:\n        return [lst[0] + lst[1]]\n    else:\n        return [lst[0] + lst[1]] + lst[2:]"
      ],
      [
        0.8852452039718628,
        "    return sorted(tuples, key=lambda x: len(x[0] + x[1]))"
      ],
      [
        0.882056474685669,
        "    for a, b in tpl1:\n        for c, d in tpl2:\n            return (a + c, b + d)"
      ],
      [
        0.882056474685669,
        "    for a, b in tpl1:\n        for c, d in tpl2:\n            return (a + c, b + d)"
      ],
      [
        0.8819459676742554,
        "    for tup in tuples:\n        value_sum = sum(tup)\n        if value_sum % 2 == 0:\n            result.append((tup[0] + 1, tup[1] + 1))\n        else:\n            result.append((tup[0] * 2, tup[1] * 2))"
      ],
      [
        0.881827712059021,
        "    transposed_lists = [j for i in zip(list1, list2) for j in i]\n    res = ' '.join(transposed_lists)\n    return res"
      ]
    ],
    "MBPP/196": [],
    "MBPP/197": [
      [
        0.8953464031219482,
        "        if '{:.2f}'.format(dec) == str_num:\n            return True"
      ],
      [
        0.891939640045166,
        "    s = ''.join(re.findall('\\\\d+\\\\.?\\\\d*', s.strip()))\n    try:\n        num = float(s)\n        if not ('.' in s and len(s) - s.index('.') - 1 == 2):\n            return False\n        else:\n            return 0 < num < 1000 and num % 10 != 0\n    except ValueError:\n        return False"
      ],
      [
        0.8862907886505127,
        "    try:\n        num = float(s)\n        if not ('.' in s and len(s) - s.index('.') - 1 == 2):\n            return False\n        else:\n            return 0 < num < 1000 and num % 10 != 0\n    except ValueError:\n        return False"
      ],
      [
        0.8839421272277832,
        "    try:\n        number = float(s)\n        if number <= 0 or number >= 1000:\n            return False\n        if s.count('.') == 1:\n            if len(s[s.index('.'):]) < 3:\n                return False\n        elif s.count('.') > 1:\n            return False\n        if not s.replace('.', '', 1).isdigit():\n            return False\n        return True\n    except ValueError:\n        return False"
      ],
      [
        0.8839421272277832,
        "    try:\n        number = float(s)\n        if number <= 0 or number >= 1000:\n            return False\n        if s.count('.') == 1:\n            if len(s[s.index('.'):]) < 3:\n                return False\n        elif s.count('.') > 1:\n            return False\n        if not s.replace('.', '', 1).isdigit():\n            return False\n        return True\n    except ValueError:\n        return False"
      ],
      [
        0.8839203119277954,
        "    if len(decimal_part) > 4:\n        return False"
      ],
      [
        0.8839089870452881,
        "    try:\n        number = float(s)\n        if number <= 0 or number >= 1000:\n            return False\n        if s.count('.') == 1:\n            if len(s[s.index('.'):]) < 3:\n                return False\n        elif s.count('.') > 1:\n            return False\n        if not s.replace('.', '', 1).isdigit():\n            return False\n        return True\n    except ValueError:\n        return False"
      ],
      [
        0.8839089870452881,
        "    try:\n        number = float(s)\n        if number <= 0 or number >= 1000:\n            return False\n        if s.count('.') == 1:\n            if len(s[s.index('.'):]) < 3:\n                return False\n        elif s.count('.') > 1:\n            return False\n        if not s.replace('.', '', 1).isdigit():\n            return False\n        return True\n    except ValueError:\n        return False"
      ],
      [
        0.8837836980819702,
        "    str_num = '{:.2f}'.format(number)\n    for dec in decimals:\n        if '{:.2f}'.format(dec) == str_num:\n            return True\n    return False"
      ],
      [
        0.8827961683273315,
        "    for dec in decimals:\n        if '{:.2f}'.format(dec) == str_num:\n            return True"
      ]
    ],
    "MBPP/198": [
      [
        0.8839859962463379,
        "    if len(heap) < 2:\n        raise ValueError('Heap needs to contain at least two elements.')\n    heap[-2] = new_value\n    i = len(heap) - 2\n    while i > 0 and heap[i] > heap[(i - 1) // 2]:\n        heap[i], heap[(i - 1) // 2] = (heap[(i - 1) // 2], heap[i])\n        i = (i - 1) // 2"
      ],
      [
        0.8824151754379272,
        "    heap.append(item)\n    _siftup(heap, len(heap) - 1)"
      ],
      [
        0.8806896209716797,
        "    element_index = arr.index(element)\n    arr[element_index], arr[len(arr) - 1] = (arr[len(arr) - 1], arr[element_index])\n    arr.pop()\n    min_heapify_down(arr, 0, len(arr))"
      ],
      [
        0.8727225661277771,
        "    if left < n and heap[left] < heap[smallest]:\n        smallest = left"
      ],
      [
        0.8724514245986938,
        "    if left < heap_size and array[left] < array[smallest]:\n        smallest = left"
      ],
      [
        0.8724226951599121,
        "    if left < heap_size and array[left] < array[smallest]:\n        smallest = left"
      ]
    ],
    "MBPP/199": [
      [
        0.9121395945549011,
        "    pattern = '^[a-z]*$'\n    if re.match(pattern, string):\n        return True\n    else:\n        return False"
      ],
      [
        0.912091076374054,
        "    pattern = '^[a-z]*$'\n    if re.match(pattern, string):\n        return True\n    else:\n        return False"
      ],
      [
        0.9096029996871948,
        "    valid = True\n    for char in input_string:\n        if char.islower() or char.isdigit():\n            continue\n        else:\n            valid = False\n            break\n    return valid"
      ],
      [
        0.9092162847518921,
        "    regex = re.compile('[a-zA-Z0-9]')\n    for c in input_string:\n        if not regex.match(c):\n            return False\n    return True"
      ],
      [
        0.9050393104553223,
        "    pattern = '^[a-z]*$'\n    if re.fullmatch(pattern, text):\n        return True\n    else:\n        return False"
      ],
      [
        0.9023756980895996,
        "    pattern = '^[a-zA-Z]+$'\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False"
      ],
      [
        0.9023540019989014,
        "    pattern = '^[a-zA-Z]+$'\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False"
      ],
      [
        0.9018173217773438,
        "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    if set(string.lower()) >= set(alphabet):\n        return True\n    else:\n        return False"
      ],
      [
        0.9017292261123657,
        "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    for char in alphabet:\n        if char not in input_str.lower():\n            return False\n    return True"
      ],
      [
        0.9009010791778564,
        "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    for char in alphabet:\n        if char not in string.lower():\n            return False\n    return True"
      ]
    ],
    "MBPP/200": [
      [
        0.9054456949234009,
        "    c1 = n.count('1')\n    c0 = n.count('0')\n    return [c1, c0]"
      ],
      [
        0.9053494334220886,
        "    while bitwise_and > 0:\n        if bitwise_and & 1:\n            count += 1\n        bitwise_and = bitwise_and >> 1"
      ],
      [
        0.9037184715270996,
        "        if bitwise_and & 1:\n            count += 1"
      ],
      [
        0.9006763100624084,
        "        if n & 1 == 1:\n            if bit_place % 2 == 0:\n                result += 1"
      ],
      [
        0.8980874419212341,
        "            if num & mask:\n                sum += 1"
      ],
      [
        0.8973680734634399,
        "        for j in range(0, n):\n            if array[j] & 1 << i:\n                cnt += 1"
      ],
      [
        0.896820068359375,
        "    result = []\n    result.append(x & y)\n    result.append(x | y)\n    result.append(x ^ y)\n    count_x = bin(x).count('1')\n    count_y = bin(y).count('1')\n    if count_x > count_y:\n        result.append('x has more set bits')\n    elif count_y > count_x:\n        result.append('y has more set bits')\n    return result"
      ],
      [
        0.8963356614112854,
        "    return bin(x ^ y).count('1')"
      ],
      [
        0.8959742188453674,
        "        if bit == '1':\n            count += 1"
      ],
      [
        0.8954064249992371,
        "    count = 0\n    for i in range(left, right + 1):\n        bits = bin(i).count('1')\n        if is_prime(bits):\n            count += 1\n    return count"
      ]
    ],
    "MBPP/201": [
      [
        0.9258561134338379,
        "    if n <= 0:\n        return 'Invalid input! n should be a positive integer.'\n    else:\n        series_sum = sum([i ** 4 for i in range(1, n + 1)])\n        return series_sum"
      ],
      [
        0.9258561134338379,
        "    if n <= 0:\n        return 'Invalid input! n should be a positive integer.'\n    else:\n        series_sum = sum([i ** 4 for i in range(1, n + 1)])\n        return series_sum"
      ],
      [
        0.9157467484474182,
        "    for i in range(start, n + 1):\n        fourth_power = i ** 4\n        result += fourth_power\n        print(f'Adding {fourth_power}, Running Sum: {result}')"
      ],
      [
        0.9149415493011475,
        "    if not isinstance(n, int) or n < 1:\n        return 'n should be a positive integer'\n    if not isinstance(start, int) or start > n:\n        return 'start should be an integer between 1 and n'\n    result = 0\n    for i in range(start, n + 1):\n        fourth_power = i ** 4\n        result += fourth_power\n        print(f'Adding {fourth_power}, Running Sum: {result}')\n    return result"
      ],
      [
        0.9040007591247559,
        "    if n == 1:\n        return 1\n    else:\n        return (2 * n - 1) ** 4 + sum_of_fourth_power_of_odds(n - 1)"
      ],
      [
        0.9040007591247559,
        "    if n == 1:\n        return 1\n    else:\n        return (2 * n - 1) ** 4 + sum_of_fourth_power_of_odds(n - 1)"
      ],
      [
        0.8981248140335083,
        "    sum = 0\n    for i in range(1, n + 1):\n        sum += i ** 3\n    return sum"
      ],
      [
        0.8981162309646606,
        "    sum = 0\n    for i in range(1, n + 1):\n        sum += i ** 3\n    return sum"
      ],
      [
        0.8981099128723145,
        "    sum = 0\n    for i in range(1, n + 1):\n        sum += i ** 3\n    return sum"
      ],
      [
        0.8969637155532837,
        "    for num in range(1, n + 1):\n        sum += num ** 3"
      ]
    ],
    "MBPP/202": [],
    "MBPP/203": [
      [
        0.9342823028564453,
        "    radians = degrees * (3.14159 / 180)\n    return radians"
      ],
      [
        0.9314454793930054,
        "    radians = degrees * math.pi / 180\n    return radians"
      ],
      [
        0.9305425882339478,
        "    pi = 3.14159\n    radians = degrees * pi / 180\n    return radians"
      ],
      [
        0.9221442937850952,
        "    degrees = math.degrees(radian)\n    return degrees"
      ],
      [
        0.9159969687461853,
        "    radians = degree * math.pi / 180\n    return round(radians, 6)"
      ],
      [
        0.9131208658218384,
        "    return degrees * (math.pi / 180)"
      ],
      [
        0.9131108522415161,
        "    return degrees * (math.pi / 180)"
      ],
      [
        0.9090397357940674,
        "    degrees = gradians * 0.9\n    return degrees"
      ],
      [
        0.8995916247367859,
        "    degrees = arc_minutes / 60.0\n    radians = degrees * (math.pi / 180.0)\n    return radians"
      ],
      [
        0.8994482159614563,
        "    return deg * (3.14 / 180)"
      ]
    ],
    "MBPP/204": [
      [
        0.8937097787857056,
        "    decoded_string = ''\n    repeat_count = 0\n    for char in encoded_string:\n        if char.isdigit():\n            repeat_count = repeat_count * 10 + int(char)\n        elif repeat_count == 0:\n            decoded_string += char\n        else:\n            decoded_string += char * repeat_count\n            repeat_count = 0\n    return decoded_string"
      ],
      [
        0.8860042095184326,
        "    for char in encoded_string:\n        if char.isdigit():\n            repeat_count = repeat_count * 10 + int(char)\n        elif repeat_count == 0:\n            decoded_string += char\n        else:\n            decoded_string += char * repeat_count\n            repeat_count = 0"
      ],
      [
        0.8841612339019775,
        "    if not list_to_encode:\n        return []\n    else:\n        tmp = []\n        tmp.append(list_to_encode[0])\n        tmp.append(1)\n        i = 1\n        while i < len(list_to_encode) and list_to_encode[i] == tmp[0]:\n            tmp[1] += 1\n            i += 1\n        return tmp + encodeList(list_to_encode[i:])"
      ],
      [
        0.8841612339019775,
        "    if not list_to_encode:\n        return []\n    else:\n        tmp = []\n        tmp.append(list_to_encode[0])\n        tmp.append(1)\n        i = 1\n        while i < len(list_to_encode) and list_to_encode[i] == tmp[0]:\n            tmp[1] += 1\n            i += 1\n        return tmp + encodeList(list_to_encode[i:])"
      ],
      [
        0.8836823105812073,
        "        if char.isdigit():\n            repeat_count = repeat_count * 10 + int(char)\n        elif repeat_count == 0:\n            decoded_string += char\n        else:\n            decoded_string += char * repeat_count\n            repeat_count = 0"
      ],
      [
        0.8764582872390747,
        "    rle_arr = []\n    for word in arr:\n        encoded = ''\n        i = 0\n        while i < len(word):\n            count = 1\n            while i + 1 < len(word) and word[i] == word[i + 1]:\n                i += 1\n                count += 1\n            encoded += '{}{}'.format(word[i], count)\n            i += 1\n        rle_arr.append(encoded)\n    return rle_arr"
      ],
      [
        0.8729104995727539,
        "        elif repeat_count == 0:\n            decoded_string += char\n        else:\n            decoded_string += char * repeat_count\n            repeat_count = 0"
      ],
      [
        0.8723968267440796,
        "    for word in arr:\n        encoded = ''\n        i = 0\n        while i < len(word):\n            count = 1\n            while i + 1 < len(word) and word[i] == word[i + 1]:\n                i += 1\n                count += 1\n            encoded += '{}{}'.format(word[i], count)\n            i += 1\n        rle_arr.append(encoded)"
      ],
      [
        0.8721544742584229,
        "        if i.isdigit():\n            count = i + count\n        else:\n            decoded += i * int(count)\n            count = ''"
      ],
      [
        0.8721371293067932,
        "    compressed_list = []\n    count = 1\n    for index in range(1, len(original_list)):\n        if original_list[index] == original_list[index - 1]:\n            count += 1\n        else:\n            compressed_list.append(str(original_list[index - 1]) + 'x' + str(count))\n            count = 1\n    compressed_list.append(str(original_list[index]) + 'x' + str(count))\n    return compressed_list"
      ]
    ],
    "MBPP/205": [
      [
        0.9089339971542358,
        "    return set(list1).issubset(set(list2))"
      ],
      [
        0.9005025029182434,
        "    return all((i in main_list for i in potential_sublist))"
      ],
      [
        0.8992447853088379,
        "    str_lst = ''.join(map(str, lst))\n    str_sublist = ''.join(map(str, sublist))\n    return str_sublist in str_lst"
      ],
      [
        0.8979660868644714,
        "    if isinstance(sublist, list):\n        if sublist == []:\n            return True\n        elif sublist == main_list:\n            return True\n        elif len(sublist) > len(main_list):\n            return False\n        else:\n            for i in range(len(main_list)):\n                if main_list[i] == sublist[0]:\n                    return is_sublist(main_list[i + 1:], sublist[1:])\n            return False\n    else:\n        return sublist in main_list"
      ],
      [
        0.8979660868644714,
        "    if isinstance(sublist, list):\n        if sublist == []:\n            return True\n        elif sublist == main_list:\n            return True\n        elif len(sublist) > len(main_list):\n            return False\n        else:\n            for i in range(len(main_list)):\n                if main_list[i] == sublist[0]:\n                    return is_sublist(main_list[i + 1:], sublist[1:])\n            return False\n    else:\n        return sublist in main_list"
      ],
      [
        0.897607684135437,
        "    return all((item in mainList for item in subList))"
      ],
      [
        0.8953961133956909,
        "    sorted_list1 = sort_nested_list(list1)\n    sorted_list2 = sort_nested_list(list2)\n    return sorted_list1 == sorted_list2"
      ],
      [
        0.8951948285102844,
        "    return set(set1).issubset(set(set2))"
      ],
      [
        0.894730269908905,
        "    if len(list2) > len(list1):\n        return False\n    for item in list1:\n        if item not in list2:\n            return False\n    return True"
      ],
      [
        0.8938250541687012,
        "        if sublist == []:\n            return True\n        elif sublist == main_list:\n            return True\n        elif len(sublist) > len(main_list):\n            return False\n        else:\n            for i in range(len(main_list)):\n                if main_list[i] == sublist[0]:\n                    return is_sublist(main_list[i + 1:], sublist[1:])\n            return False"
      ]
    ],
    "MBPP/206": [
      [
        0.9278151988983154,
        "    char_count = {}\n    for char in input_string:\n        if char in char_count:\n            return char\n        else:\n            char_count[char] = 1\n    return 'No duplicates found'"
      ],
      [
        0.9239374995231628,
        "    for i, letter in enumerate(string):\n        if letter in letter_count:\n            return ('Index:', i)\n        else:\n            letter_count[letter] = 1"
      ],
      [
        0.9230350255966187,
        "    letter_count = {}\n    for i, letter in enumerate(string):\n        if letter in letter_count:\n            return ('Index:', i)\n        else:\n            letter_count[letter] = 1\n    return ('Index:', -1)"
      ],
      [
        0.9215813875198364,
        "    count_dict = {}\n    for i in range(len(input_str)):\n        if input_str[i] in count_dict:\n            count_dict[input_str[i]] += 1\n        else:\n            count_dict[input_str[i]] = 1\n    for key, value in count_dict.items():\n        if value == 1:\n            return (key, input_str.index(key))\n    return ('All characters are repeating', None)"
      ],
      [
        0.9194490909576416,
        "    for char in s:\n        if s.count(char) > 1:\n            return char"
      ],
      [
        0.9191107749938965,
        "    s = s[::-1]\n    for char in s:\n        if s.count(char) > 1:\n            return char\n    return 'None'"
      ],
      [
        0.9189450740814209,
        "    seen_characters = set()\n    for c in s:\n        if c not in seen_characters:\n            seen_characters.add(c)\n        else:\n            return c\n    return None"
      ],
      [
        0.9178426265716553,
        "    char_set = set()\n    for c in s:\n        if c in char_set:\n            return c\n        char_set.add(c)\n    return None"
      ],
      [
        0.9176840782165527,
        "    char_freq = {}\n    for i in range(len(string)):\n        if string[i] in char_freq:\n            char_freq[string[i]] += 1\n        else:\n            char_freq[string[i]] = 1\n    for i in range(len(string)):\n        if char_freq[string[i]] == 1:\n            return (string[i], i)\n    return (None, -1)"
      ],
      [
        0.9176840782165527,
        "    char_freq = {}\n    for i in range(len(string)):\n        if string[i] in char_freq:\n            char_freq[string[i]] += 1\n        else:\n            char_freq[string[i]] = 1\n    for i in range(len(string)):\n        if char_freq[string[i]] == 1:\n            return (string[i], i)\n    return (None, -1)"
      ]
    ],
    "MBPP/207": [
      [
        0.8935064077377319,
        "    operations = 0\n    current_bit = '0'\n    for bit in target:\n        if bit != current_bit:\n            operations += 1\n            current_bit = bit\n    return operations"
      ],
      [
        0.893482506275177,
        "    operations = 0\n    current_bit = '0'\n    for bit in target:\n        if bit != current_bit:\n            operations += 1\n            current_bit = bit\n    return operations"
      ],
      [
        0.8899919986724854,
        "    sum1, sum2 = (sum(nums1), sum(nums2))\n    if sum1 == sum2:\n        return 0\n    if sum1 < sum2:\n        nums1, nums2 = (nums2, nums1)\n    nums1.sort(reverse=True)\n    nums2.sort()\n    diff, operations, i, j = (abs(sum1 - sum2), 0, 0, 0)\n    while diff > 0 and (i < len(nums1) or j < len(nums2)):\n        option1 = nums1[i] - 1 if i < len(nums1) else 0\n        option2 = 6 - nums2[j] if j < len(nums2) else 0\n        if option1 > option2:\n            diff -= option1\n            i += 1\n        else:\n            diff -= option2\n            j += 1\n        operations += 1\n    return operations if diff == 0 else -1"
      ],
      [
        0.8889824151992798,
        "        for num in nums:\n            operations += abs(num - query)"
      ],
      [
        0.888308048248291,
        "    xor_value = start ^ goal\n    flips = 0\n    while xor_value:\n        flips += xor_value & 1\n        xor_value >>= 1\n    return flips"
      ],
      [
        0.8881949782371521,
        "    elif diff < 0:\n        return b\n    else:\n        return 'Both numbers are equal.'"
      ],
      [
        0.8872079253196716,
        "    if x == target:\n        return 0"
      ],
      [
        0.8868248462677002,
        "    operations = 0\n    while target > startValue:\n        target = target // 2 if target % 2 == 0 else target + 1\n        operations += 1\n    return operations + startValue - target"
      ],
      [
        0.883730947971344,
        "    for query in queries:\n        operations = 0\n        for num in nums:\n            operations += abs(num - query)\n        answer.append(operations)"
      ],
      [
        0.8833310008049011,
        "    if isinstance(num1, (int, float)) and isinstance(num2, (int, float)):\n        if num1 < 0 and num2 < 0:\n            return max(abs(num1), abs(num2))\n        elif num1 % 2 == 0 and num2 % 2 == 0:\n            return max(num1 / 2, num2 / 2)\n        elif num1 % 2 != 0 and num2 % 2 != 0:\n            return max(num1 * 3 + 1, num2 * 3 + 1)\n        else:\n            return max(num1, num2) - min(num1, num2)\n    else:\n        return 'Error: Inputs must be numbers.'"
      ]
    ],
    "MBPP/208": [
      [
        0.8939972519874573,
        "    minValue = arr[0]\n    maxValue = arr[0]\n    for i in range(k):\n        if arr[i] > maxValue:\n            maxValue = arr[i]\n        if arr[i] < minValue:\n            minValue = arr[i]\n    return (minValue, maxValue)"
      ],
      [
        0.8827095031738281,
        "    if len(tup_list) == 0:\n        return 'The tuple list is empty.'\n    if k > len(tup_list):\n        return 'K is greater than the size of list. Returning all records.'\n    tup_list.sort(key=lambda x: x[0])\n    return tup_list[:k]"
      ],
      [
        0.8752431273460388,
        "    max_values = []\n    for tup in list_of_tuples:\n        max_values.append(max(tup))\n    return max_values"
      ],
      [
        0.8744155168533325,
        "    max = list[0]\n    min = list[0]\n    for i in range(1, len(list)):\n        if list[i] > max:\n            max = list[i]\n        if list[i] < min:\n            min = list[i]\n    return (max, min)"
      ],
      [
        0.8743972182273865,
        "    max = list[0]\n    min = list[0]\n    for i in range(1, len(list)):\n        if list[i] > max:\n            max = list[i]\n        if list[i] < min:\n            min = list[i]\n    return (max, min)"
      ],
      [
        0.8731159567832947,
        "    min_ = my_list[0]\n    max_ = my_list[0]\n    for element in my_list:\n        if element < min_:\n            min_ = element\n        elif element > max_:\n            max_ = element\n    return (min_, max_)"
      ],
      [
        0.8730686902999878,
        "    min_num = lst[0]\n    max_num = lst[0]\n    for num in lst[1:]:\n        if num < min_num:\n            min_num = num\n        if num > max_num:\n            max_num = num\n    return (min_num, max_num)"
      ],
      [
        0.8728500604629517,
        "    max_element = lst[0]\n    min_element = lst[0]\n    for i in range(len(lst)):\n        if max_element < lst[i]:\n            max_element = lst[i]\n        if min_element > lst[i]:\n            min_element = lst[i]\n    return (max_element, min_element)"
      ],
      [
        0.8727710247039795,
        "    max = list[0]\n    min = list[0]\n    for i in range(len(list)):\n        if list[i] > max:\n            max = list[i]\n        if list[i] < min:\n            min = list[i]\n    return (max, min)"
      ],
      [
        0.8726423978805542,
        "    min_num = numbers[0]\n    max_num = numbers[0]\n    for num in numbers:\n        if num < min_num:\n            min_num = num\n        if num > max_num:\n            max_num = num\n    return (min_num, max_num)"
      ]
    ],
    "MBPP/209": [
      [
        0.9000027775764465,
        "    replacements = 0\n    new_line = []\n    for char in line:\n        if char in [' ', ',', '.']:\n            new_line.append(':')\n            replacements += 1\n        else:\n            new_line.append(char)\n    return (''.join(new_line), replacements)"
      ],
      [
        0.8894240856170654,
        "    for char in line:\n        if char in [' ', ',', '.']:\n            new_line.append(':')\n            replacements += 1\n        else:\n            new_line.append(char)"
      ],
      [
        0.8873562216758728,
        "        if char in [' ', ',', '.']:\n            new_line.append(':')\n            replacements += 1\n        else:\n            new_line.append(char)"
      ],
      [
        0.8841404914855957,
        "    if len(parts) > n:\n        return substring.join(parts[:-1]) + replacement + substring.join(parts[-1:])"
      ],
      [
        0.8819694519042969,
        "    return text.replace(' ', ':').replace(',', ':').replace('.', ':')"
      ],
      [
        0.8818114995956421,
        "    words = string.split()\n    last_index = -1\n    capitalized_word = word.capitalize()\n    for i in range(len(words) - 1, -1, -1):\n        if words[i].lower() == word.lower() and words[i + 1] == ',':\n            words[i] = capitalized_word\n            last_index = i\n            break\n    if last_index != -1:\n        replaced_string = ' '.join(words)\n        return replaced_string\n    return string"
      ],
      [
        0.876558244228363,
        "    output = ''\n    for char in string:\n        if char == ',':\n            output += char + ' '\n        else:\n            output += char\n    return output"
      ],
      [
        0.8762739896774292,
        "    parts = original_string.split(substring, n)\n    if len(parts) > n:\n        return substring.join(parts[:-1]) + replacement + substring.join(parts[-1:])\n    return original_string"
      ],
      [
        0.8736897706985474,
        "    try:\n        float_n = float(n)\n        if '.' in n:\n            int_part, dec_part = n.split('.')\n            return '{:,}'.format(int(float_n)) + '.' + dec_part\n        else:\n            return '{:,}'.format(int(n))\n    except ValueError:\n        return 'Invalid Input'"
      ],
      [
        0.8736897706985474,
        "    try:\n        float_n = float(n)\n        if '.' in n:\n            int_part, dec_part = n.split('.')\n            return '{:,}'.format(int(float_n)) + '.' + dec_part\n        else:\n            return '{:,}'.format(int(n))\n    except ValueError:\n        return 'Invalid Input'"
      ]
    ],
    "MBPP/210": [
      [
        0.9249582290649414,
        "    evens = []\n    for i in list:\n        if i % 2 == 0:\n            evens.append(i)\n    if not evens:\n        return 'There are no even numbers in the list.'\n    else:\n        return min(evens)"
      ],
      [
        0.9212262630462646,
        "    even_numbers = [number for number in input_list if number % 2 == 0]\n    return min(even_numbers) if even_numbers else None"
      ],
      [
        0.9210383892059326,
        "    even_numbers = [num for num in lst if num % 2 == 0]\n    if even_numbers:\n        return min(even_numbers)\n    else:\n        return 'Element does not exist'"
      ],
      [
        0.918404757976532,
        "    if type(lst) is not list:\n        return 'Error: The provided input is not a list!'\n    smallest_even = float('inf')\n    smallest_even_indices = []\n    for i in range(len(lst)):\n        if type(lst[i]) is not int:\n            return 'Error: List contains non-integer values!'\n        if lst[i] % 2 == 0 and lst[i] < smallest_even:\n            smallest_even = lst[i]\n            smallest_even_indices = [i]\n        elif lst[i] == smallest_even:\n            smallest_even_indices.append(i)\n    if smallest_even == float('inf'):\n        return 'No even number found!'\n    else:\n        return (smallest_even, smallest_even_indices)"
      ],
      [
        0.9155980348587036,
        "    even_list = [num for num in lst if num % 2 == 0]\n    return min(even_list) if even_list else None"
      ],
      [
        0.9142711758613586,
        "    if not evens:\n        return 'There are no even numbers in the list.'\n    else:\n        return min(evens)"
      ],
      [
        0.9139925241470337,
        "    if even_numbers:\n        return min(even_numbers)\n    else:\n        return 'Element does not exist'"
      ],
      [
        0.9138413071632385,
        "    even_numbers = sorted([num for num in numbers if num % 2 == 0])\n    if even_numbers:\n        return even_numbers[0]\n    else:\n        return None"
      ],
      [
        0.9136892557144165,
        "    even_numbers = list(filter(lambda x: x % 2 == 0, numbers))\n    if not even_numbers:\n        print('There are no even numbers in the list.')\n        return None\n    return min(even_numbers)"
      ],
      [
        0.9114737510681152,
        "    count_even = 0\n    for num in arr:\n        if num % 2 == 0:\n            count_even += 1\n        else:\n            break\n    return count_even"
      ]
    ],
    "MBPP/211": [
      [
        0.9053579568862915,
        "    for element in new_elements:\n        if type(element) != type(old_tuple[0]):\n            return False\n    return True"
      ],
      [
        0.9041476845741272,
        "    types_set = set()\n    for item in input_list:\n        types_set.add(type(item))\n    return len(types_set) == len(input_list)"
      ],
      [
        0.8989526629447937,
        "    if len(lst) == 0:\n        return True\n    first_type = type(lst[0])\n    return all((isinstance(i, first_type) for i in lst))"
      ],
      [
        0.8987243175506592,
        "    for element in new_elements:\n        if type(element) != type(old_tuple[0]):\n            return False"
      ],
      [
        0.8921175599098206,
        "    if len(lst) < 2:\n        return True\n    first_type = type(lst[0])\n    if first_type == list or first_type == dict:\n        first_type = check_same_data_type(lst[0])\n    for item in lst[1:]:\n        item_type = type(item)\n        if item_type == list or item_type == dict:\n            item_type = check_same_data_type(item)\n        if item_type != first_type:\n            return False\n    return True"
      ],
      [
        0.8910931944847107,
        "        if type(element) != type(old_tuple[0]):\n            return False"
      ],
      [
        0.8890680074691772,
        "    return all((isinstance(element, type) for element in elements))"
      ],
      [
        0.8861453533172607,
        "    for item in lst[1:]:\n        item_type = type(item)\n        if item_type == list or item_type == dict:\n            item_type = check_same_data_type(item)\n        if item_type != first_type:\n            return False"
      ],
      [
        0.8849244117736816,
        "    if not lst:\n        return True\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True"
      ],
      [
        0.8836731910705566,
        "    if len(lst) == 0:\n        return False\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True"
      ]
    ],
    "MBPP/212": [
      [
        0.9086649417877197,
        "    for num in arr:\n        if count == 0:\n            majority = num\n            count = 1\n        elif num == majority:\n            count += 1\n        else:\n            count -= 1"
      ],
      [
        0.9065130949020386,
        "    count = 0\n    majority = None\n    for num in arr:\n        if count == 0:\n            majority = num\n            count = 1\n        elif num == majority:\n            count += 1\n        else:\n            count -= 1\n    return majority"
      ],
      [
        0.9025843143463135,
        "    length = len(arr)\n    count = {}\n    for i in arr:\n        if i not in count:\n            count[i] = 1\n        else:\n            count[i] += 1\n    max_count = max(count.values())\n    if max_count > length // 2:\n        majority_element = [key for key in count.keys() if count[key] == max_count]\n        return majority_element[0]\n    else:\n        return -1"
      ],
      [
        0.9011974334716797,
        "        if count == 0:\n            majority = num\n            count = 1\n        elif num == majority:\n            count += 1\n        else:\n            count -= 1"
      ],
      [
        0.8999193906784058,
        "    elem_count = {}\n    for elem in arr:\n        if elem not in elem_count:\n            elem_count[elem] = 0\n        elem_count[elem] += 1\n    max_count = 0\n    majority_element = None\n    for elem, freq in elem_count.items():\n        if freq > max_count:\n            max_count = freq\n            majority_element = elem\n    return majority_element"
      ],
      [
        0.8992560505867004,
        "    maj_index = 0\n    count = 1\n    for i in range(1, len(arr)):\n        if arr[i] == arr[maj_index]:\n            count += 1\n        else:\n            count -= 1\n        if count == 0:\n            maj_index = i\n            count = 1\n    if count > len(arr) // 2:\n        return arr[maj_index]\n    else:\n        return None"
      ],
      [
        0.8989195823669434,
        "        elif num == majority:\n            count += 1\n        else:\n            count -= 1"
      ],
      [
        0.8970448970794678,
        "    sorted_lst = sorted(lst)\n    median = sorted_lst[len(sorted_lst) // 2]\n    if element >= median and element in lst:\n        return True\n    else:\n        return False"
      ],
      [
        0.8964405655860901,
        "    for i in arr:\n        if i != majority:\n            return i"
      ],
      [
        0.8951907157897949,
        "    if max_count > length // 2:\n        majority_element = [key for key in count.keys() if count[key] == max_count]\n        return majority_element[0]\n    else:\n        return -1"
      ]
    ],
    "MBPP/213": [
      [
        0.9172120690345764,
        "    count = 0\n    while number > 0:\n        if number & 1:\n            count += 1\n        number >>= 1\n    return count"
      ],
      [
        0.9161561727523804,
        "    count = 0\n    while n != 0:\n        count += n & 1\n        n >>= 1\n    return count"
      ],
      [
        0.9148305654525757,
        "    return bin(n).count('1')"
      ],
      [
        0.9143856167793274,
        "    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"
      ],
      [
        0.9143756628036499,
        "    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"
      ],
      [
        0.9143679738044739,
        "    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"
      ],
      [
        0.9142752885818481,
        "    count = 0\n    while n > 0:\n        if n & 1:\n            count += 1\n        n >>= 1\n    return count"
      ],
      [
        0.9119019508361816,
        "    while n != 0:\n        count += n & 1\n        n >>= 1"
      ],
      [
        0.9097832441329956,
        "    while number > 0:\n        if number & 1:\n            count += 1\n        number >>= 1"
      ],
      [
        0.9086279273033142,
        "    count = 0\n    while n:\n        count ^= n & 1\n        n >>= 1\n    return count"
      ]
    ],
    "MBPP/214": [
      [
        0.9026049375534058,
        "    if len(arr) == 0:\n        return None\n    if len(arr) == 1:\n        return arr[0]\n    mid = len(arr) // 2\n    if mid > 0 and arr[mid - 1] > arr[mid]:\n        return arr[mid]\n    elif arr[mid + 1] < arr[mid]:\n        return arr[mid + 1]\n    elif arr[mid] > arr[0]:\n        return find_min_element(arr[0:mid])\n    else:\n        return find_min_element(arr[mid + 1:len(arr) - 1])"
      ],
      [
        0.902469277381897,
        "    if len(arr) == 1:\n        return arr[0]\n    elif len(arr) == 2:\n        return min(arr[0], arr[1])\n    mid = len(arr) // 2\n    left_min = find_minimum(arr[:mid])\n    right_min = find_minimum(arr[mid:])\n    return min(left_min, right_min)"
      ],
      [
        0.9018639326095581,
        "    elif arr[mid] > arr[0]:\n        return find_min_element(arr[0:mid])\n    else:\n        return find_min_element(arr[mid + 1:len(arr) - 1])"
      ],
      [
        0.9010086059570312,
        "    n = len(arr)\n    if n == 1:\n        return arr[0]\n    mid = n // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    min_left = find_min(left_half)\n    min_right = find_min(right_half)\n    return min(min_left, min_right)"
      ],
      [
        0.8992480039596558,
        "    left, right = (0, len(rotated) - 1)\n    while left < right:\n        mid = left + (right - left) // 2\n        if rotated[mid] > rotated[right]:\n            left = mid + 1\n        else:\n            right = mid\n    return rotated[left]"
      ],
      [
        0.8979260325431824,
        "    if len(arr) == 1:\n        return arr[0]\n    if arr[0] < arr[-1]:\n        return arr[0]\n    mid = len(arr) // 2\n    if arr[mid] < arr[-1]:\n        return find_smallest_element(arr[:mid + 1])\n    return find_smallest_element(arr[mid + 1:])"
      ],
      [
        0.8969062566757202,
        "    elif arr[mid + 1] < arr[mid]:\n        return arr[mid + 1]\n    elif arr[mid] > arr[0]:\n        return find_min_element(arr[0:mid])\n    else:\n        return find_min_element(arr[mid + 1:len(arr) - 1])"
      ],
      [
        0.8968856334686279,
        "    while left < right:\n        mid = left + (right - left) // 2\n        if rotated[mid] > rotated[right]:\n            left = mid + 1\n        else:\n            right = mid"
      ],
      [
        0.8968470692634583,
        "    minimum = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < minimum:\n            minimum = arr[i]\n    return minimum"
      ],
      [
        0.8959910869598389,
        "        if rotated[mid] > rotated[right]:\n            left = mid + 1\n        else:\n            right = mid"
      ]
    ],
    "MBPP/215": [
      [
        0.9377486109733582,
        "    odd_position = ''\n    for i in range(len(string)):\n        if i % 2 == 0:\n            odd_position += string[i]\n    return odd_position"
      ],
      [
        0.9261994361877441,
        "    new_str = ''\n    for ch in str:\n        if ord(ch) % 2 == 0:\n            new_str += ch\n    return new_str"
      ],
      [
        0.92252516746521,
        "    result_string = ''\n    for i in range(0, len(string)):\n        if i % 2 == 0:\n            result_string += string[i]\n    return result_string"
      ],
      [
        0.9222906231880188,
        "    result = ''\n    for i in range(len(string)):\n        if i % 2 == 0:\n            result += string[i]\n    return result"
      ],
      [
        0.9213665723800659,
        "    result = ''\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result += str[i]\n    return result"
      ],
      [
        0.9188176989555359,
        "    output = ''\n    for i in range(len(s)):\n        if i % 2 != 0:\n            pass\n        else:\n            output += s[i]\n    return output"
      ],
      [
        0.917171835899353,
        "    words = sentence.split(' ')\n    even_index_words = [words[i] for i in range(len(words)) if i % 2 == 0]\n    return ' '.join(even_index_words)"
      ],
      [
        0.9162158966064453,
        "    result = ''\n    for i in range(len(string)):\n        if i % 2 == 0:\n            result = result + string[i]\n    return result"
      ],
      [
        0.9142429828643799,
        "    result = ''\n    for i in range(len(string)):\n        if i % 2 != 0:\n            result += string[i]\n    return result"
      ],
      [
        0.9141232967376709,
        "    word_list = in_string.split()\n    out_list = []\n    for i in range(len(word_list)):\n        if i % 2 == 0:\n            out_list.append(word_list[i])\n    return out_list"
      ]
    ],
    "MBPP/216": [
      [
        0.9351513385772705,
        "    return min(num1, num2, num3)"
      ],
      [
        0.9306831955909729,
        "    min_number = min(a, b, c)\n    return min_number"
      ],
      [
        0.9229660630226135,
        "    min_value = a\n    if b < min_value:\n        min_value = b\n    if c < min_value:\n        min_value = c\n    return min_value"
      ],
      [
        0.9226977229118347,
        "    return min(a, b, c)"
      ],
      [
        0.9226962327957153,
        "    return min(a, b, c)"
      ],
      [
        0.9226893186569214,
        "    return min(a, b, c)"
      ],
      [
        0.922686755657196,
        "    return min(a, b, c)"
      ],
      [
        0.922686755657196,
        "    return min(a, b, c)"
      ],
      [
        0.916199803352356,
        "    smallest = num1\n    if smallest > num2:\n        smallest = num2\n    if smallest > num3:\n        smallest = num3\n    return smallest"
      ],
      [
        0.9144186973571777,
        "    if a < b and a < c:\n        return min(b, c)\n    elif b < a and b < c:\n        return min(a, c)\n    return min(a, b)"
      ]
    ],
    "MBPP/217": [
      [
        0.8772255778312683,
        "    for flag in subset:\n        if not bitmask & flag:\n            return False\n    return True"
      ],
      [
        0.8760645389556885,
        "    for num in my_list:\n        if num & mask != 0:\n            print(num)"
      ],
      [
        0.8710764050483704,
        "    for flag in subset:\n        if not bitmask & flag:\n            return False"
      ],
      [
        0.8704241514205933,
        "    return all((num == 0 for num in int_list))"
      ],
      [
        0.8656423687934875,
        "    if int in range(...):\n        return not bool"
      ],
      [
        0.8656423687934875,
        "    if int in range(...):\n        return not bool"
      ],
      [
        0.8655660152435303,
        "    result = []\n    result.append(x & y)\n    result.append(x | y)\n    result.append(x ^ y)\n    count_x = bin(x).count('1')\n    count_y = bin(y).count('1')\n    if count_x > count_y:\n        result.append('x has more set bits')\n    elif count_y > count_x:\n        result.append('y has more set bits')\n    return result"
      ],
      [
        0.8647620677947998,
        "    while mask & result == 0:\n        mask = mask << 1"
      ],
      [
        0.8638074398040771,
        "        elif not (byte & mask1 and (not byte & mask2)):\n            return False"
      ],
      [
        0.8635165095329285,
        "    sum = -(-num1 - num2)\n    within_range = sum - start & end - sum >> 31\n    return bool(within_range)"
      ]
    ],
    "MBPP/218": [
      [
        0.9379390478134155,
        "    negative_index = 0\n    for num in arr:\n        if num < 0:\n            temp = arr[negative_index]\n            arr[negative_index] = num\n            arr[arr.index(num)] = temp\n            negative_index += 1\n    return arr"
      ],
      [
        0.937507152557373,
        "    negative_nums = []\n    positive_nums = []\n    for num in array:\n        if num < 0:\n            negative_nums.append(num)\n        else:\n            positive_nums.append(num)\n    return negative_nums + positive_nums"
      ],
      [
        0.9352561235427856,
        "    positives = []\n    negatives = []\n    for x in arr:\n        if x < 0:\n            negatives.append(x)\n        else:\n            positives.append(x)\n    return positives + negatives"
      ],
      [
        0.931486964225769,
        "    for num in arr:\n        if num < 0:\n            temp = arr[negative_index]\n            arr[negative_index] = num\n            arr[arr.index(num)] = temp\n            negative_index += 1"
      ],
      [
        0.9267987012863159,
        "    negative = [i for i in array if i < 0]\n    positive = [i for i in array if i >= 0]\n    quickSort(negative, 0, len(negative) - 1)\n    quickSort(positive, 0, len(positive) - 1)\n    return negative[::-1] + positive"
      ],
      [
        0.9260299205780029,
        "    j = -1\n    for i in range(len(arr)):\n        if arr[i] < 0:\n            j += 1\n            arr[i], arr[j] = (arr[j], arr[i])\n    return arr"
      ],
      [
        0.9256386160850525,
        "    arr.sort()\n    newArr = []\n    start = 0\n    end = len(arr) - 1\n    while start <= end:\n        if arr[start] < 0:\n            newArr.append(arr[start])\n            start += 1\n        else:\n            newArr.append(arr[end])\n            end -= 1\n    return newArr"
      ],
      [
        0.9222574830055237,
        "    positive_list = []\n    negative_list = []\n    for num in numbers:\n        if num < 0:\n            negative_list.append(num)\n        else:\n            positive_list.append(num)\n    return positive_list + negative_list"
      ],
      [
        0.9208520650863647,
        "        if num < 0:\n            temp = arr[negative_index]\n            arr[negative_index] = num\n            arr[arr.index(num)] = temp\n            negative_index += 1"
      ],
      [
        0.9193507432937622,
        "    n = len(arr)\n    left = 0\n    right = n - 1\n    while left < right:\n        while arr[left] < 0 and left < right:\n            left += 1\n        while arr[right] >= 0 and left < right:\n            right -= 1\n        if left < right:\n            arr[left], arr[right] = (arr[right], arr[left])\n            left += 1\n            right -= 1\n    return arr"
      ]
    ],
    "MBPP/219": [
      [
        0.9162598848342896,
        "    return string.replace(' ', character)"
      ],
      [
        0.9162452220916748,
        "    return string.replace(' ', character)"
      ],
      [
        0.9162402749061584,
        "    return string.replace(' ', character)"
      ],
      [
        0.916231632232666,
        "    return string.replace(' ', character)"
      ],
      [
        0.9110650420188904,
        "    result = ''\n    for char in string:\n        if char == ' ':\n            result += character\n        else:\n            result += char\n    return result"
      ],
      [
        0.9051140546798706,
        "    outputString = ''\n    for c in inputString:\n        if c == character:\n            outputString += '_'\n        else:\n            outputString += c\n    return outputString"
      ],
      [
        0.9007976055145264,
        "    new_string = ''\n    for char in input_string:\n        if char == ' ':\n            new_string += '*'\n        else:\n            new_string += char\n    return new_string"
      ],
      [
        0.8999205827713013,
        "    new_str = ''\n    for c in str:\n        if c == char_to_be_replaced:\n            c = replacement_char\n        new_str += c\n    return new_str"
      ],
      [
        0.8985050320625305,
        "    for char in string:\n        if char == ' ':\n            result += character\n        else:\n            result += char"
      ],
      [
        0.8983389139175415,
        "    for c in inputString:\n        if c == character:\n            outputString += '_'\n        else:\n            outputString += c"
      ]
    ],
    "MBPP/220": [
      [
        0.8919818997383118,
        "    sum_list = [sum(row) for row in arr]\n    max_element = max(sum_list)\n    return max_element"
      ],
      [
        0.8861929178237915,
        "    for i in range(len(arr)):\n        row_sum = sum(arr[i])\n        print('Sum of elements in row', i, ':', row_sum)\n    max_row = find_row_with_highest_sum(arr)\n    print('Row with highest sum:', max_row)"
      ],
      [
        0.883316695690155,
        "    if right_sum > max_value:\n        max_value = right_sum"
      ]
    ],
    "MBPP/221": [
      [
        0.9070794582366943,
        "    sorted_dataset = sorted(dataset, key=lambda item: item['cost'], reverse=True)\n    return sorted_dataset[:n]"
      ],
      [
        0.9070514440536499,
        "    sorted_dataset = sorted(dataset, key=lambda item: item['cost'], reverse=True)\n    return sorted_dataset[:n]"
      ],
      [
        0.9029162526130676,
        "    if num > len(data):\n        print('The number of elements to be selected is greater than the number of elements in the list.')\n        return\n    result = sorted([(i, val) for i, val in enumerate(data)], key=lambda x: x[1], reverse=True)\n    return sorted(result[:num], key=lambda x: x[1], reverse=True)"
      ],
      [
        0.902910590171814,
        "    if num > len(data):\n        print('The number of elements to be selected is greater than the number of elements in the list.')\n        return\n    result = sorted([(i, val) for i, val in enumerate(data)], key=lambda x: x[1], reverse=True)\n    return sorted(result[:num], key=lambda x: x[1], reverse=True)"
      ],
      [
        0.9006518125534058,
        "    highest = heapq.nlargest(5, dataset)\n    lowest = heapq.nsmallest(5, dataset)\n    return (highest, lowest)"
      ],
      [
        0.8980869054794312,
        "    B = sorted(A, reverse=True)\n    return B[:n]"
      ],
      [
        0.8972790241241455,
        "    counts = {}\n    for element in data:\n        if element in counts:\n            counts[element] += 1\n        else:\n            counts[element] = 1\n    sorted_counts = sorted(counts.items(), key=lambda x: x[1])\n    return sorted_counts[-n][0]"
      ],
      [
        0.8959881067276001,
        "    arr.sort()\n    top_n = arr[:n]\n    return top_n"
      ],
      [
        0.8932051658630371,
        "    items = list(dict.values())[-n:]\n    items.reverse()\n    return items"
      ],
      [
        0.8920648694038391,
        "    if n > len(lst):\n        return 'Error: n is larger than the number of elements in the list.'\n    else:\n        bubble_sort_desc(lst)\n        return lst[n - 1]"
      ]
    ],
    "MBPP/222": [
      [
        0.9011034965515137,
        "    if r1 < 0 or r2 < 0 or s < 0:\n        return 'Error: the radii and height must be positive numbers.'\n    lateral_surface_area = math.pi * (r1 + r2) * math.sqrt((r1 - r2) ** 2 + s ** 2)\n    return lateral_surface_area"
      ],
      [
        0.8980379700660706,
        "    surface_area = 4 * 3.14159 * radius ** 2\n    return round(surface_area, 2)"
      ],
      [
        0.8940110206604004,
        "    surface_area = 4 * math.pi * radius * radius\n    return surface_area"
      ],
      [
        0.8910816311836243,
        "    return math.pi * cylinder['radius'] ** 2 * cylinder['height']"
      ],
      [
        0.8909937143325806,
        "    result = []\n    for frustum in list_of_frustums:\n        r1, r2, l = frustum\n        if r1 < 0 or r2 < 0 or l < 0:\n            raise ValueError('Invalid values. Radii and height must be non-negative.')\n        else:\n            lateral_surface_area = math.pi * (r1 + r2) * math.sqrt((r2 - r1) ** 2 + l ** 2)\n            result.append(lateral_surface_area)\n    return result"
      ],
      [
        0.8892340064048767,
        "        if r1 < 0 or r2 < 0 or l < 0:\n            raise ValueError('Invalid values. Radii and height must be non-negative.')\n        else:\n            lateral_surface_area = math.pi * (r1 + r2) * math.sqrt((r2 - r1) ** 2 + l ** 2)\n            result.append(lateral_surface_area)"
      ],
      [
        0.8891229629516602,
        "    lateral_surface_area = 2 * l * h + b * h\n    total_surface_area = lateral_surface_area + 2 * l * b\n    return (lateral_surface_area, total_surface_area)"
      ],
      [
        0.8885666131973267,
        "    r1 = frustum['r1']\n    r2 = frustum['r2']\n    h = frustum['h']\n    lateral_area = pi * (r1 + r2) * h\n    return round(lateral_area, 15)"
      ],
      [
        0.8885608315467834,
        "    r1 = frustum['r1']\n    r2 = frustum['r2']\n    h = frustum['h']\n    lateral_area = pi * (r1 + r2) * h\n    return round(lateral_area, 15)"
      ],
      [
        0.8885279893875122,
        "    r1 = frustum['r1']\n    r2 = frustum['r2']\n    h = frustum['h']\n    lateral_area = pi * (r1 + r2) * h\n    return round(lateral_area, 15)"
      ]
    ],
    "MBPP/223": [
      [
        0.8981045484542847,
        "    volume = side_length ** 3\n    return volume"
      ],
      [
        0.8973275423049927,
        "    volume_one_cuboid = length * breadth * height\n    combined_volume = volume_one_cuboid * number_of_cuboids\n    return combined_volume"
      ],
      [
        0.8972886800765991,
        "    cube_radius = pow(r, 3)\n    volume = 4 / 3 * math.pi * cube_radius\n    return volume"
      ],
      [
        0.8970690965652466,
        "    volume = length ** 3\n    return volume"
      ]
    ],
    "MBPP/224": [
      [
        0.8977289795875549,
        "    even_set = set()\n    for num in numbers:\n        if num % 2 == 0:\n            even_set.add(num)\n    return even_set"
      ],
      [
        0.8902865052223206,
        "    unique_even_numbers = set()\n    for num in numbers:\n        if num % 2 == 0:\n            unique_even_numbers.add(num)\n    return unique_even_numbers"
      ],
      [
        0.8896710276603699,
        "        if arr[i] % 2 == 0:\n            arr[i] = 0"
      ],
      [
        0.8896523118019104,
        "        if arr[i] % 2 == 0:\n            arr[i] = 0"
      ],
      [
        0.8882796168327332,
        "    for i in range(len(arr)):\n        if arr[i] % 2 == 0:\n            arr[i] = 0"
      ],
      [
        0.8882683515548706,
        "    for i in range(len(arr)):\n        if arr[i] % 2 == 0:\n            arr[i] = 0"
      ],
      [
        0.8870211839675903,
        "    for i in range(len(arr)):\n        if arr[i] % 2 == 0:\n            arr[i] = 0\n    return arr"
      ],
      [
        0.8870202898979187,
        "    for i in range(len(arr)):\n        if arr[i] % 2 == 0:\n            arr[i] = 0\n    return arr"
      ],
      [
        0.8866353631019592,
        "        if num & 1 == 0:\n            even.append(num)\n        else:\n            odd.append(num)"
      ],
      [
        0.8860903382301331,
        "    even_nums = []\n    for num in nums:\n        if num % 2 == 0:\n            even_nums.append(num)\n    return even_nums"
      ]
    ],
    "MBPP/225": [
      [
        0.8844745755195618,
        "    count = 0\n    for triangle in triangles:\n        if len(set(triangle)) == 1 and triangle.count(triangle[0]) >= 2:\n            count += 1\n    return count"
      ],
      [
        0.8840988278388977,
        "    count = 0\n    m = B // 6\n    for i in range(m - 1, m + 2):\n        L = math.sqrt(3 * math.pow(i, 2) - 3 * i + 1)\n        count += 1 if L <= max_distance else 0\n    return count"
      ],
      [
        0.8821601867675781,
        "        for x, count in enumerate(triangles):\n            if count == exactly:\n                return x"
      ],
      [
        0.8795377016067505,
        "    for triangle in triangles:\n        if len(set(triangle)) == 1 and triangle.count(triangle[0]) >= 2:\n            count += 1"
      ],
      [
        0.8778606653213501,
        "    return (a + b + c - max(a, b, c)) // 2"
      ],
      [
        0.8771082162857056,
        "    return math.floor(n / math.sqrt(3))"
      ],
      [
        0.8770555257797241,
        "    y_limit = exactly * 2\n    while True:\n        triangles = count_triples(y_limit)\n        for x, count in enumerate(triangles):\n            if count == exactly:\n                return x\n        y_limit += exactly"
      ],
      [
        0.8760205507278442,
        "        if len(set(triangle)) == 1 and triangle.count(triangle[0]) >= 2:\n            count += 1"
      ],
      [
        0.8755345940589905,
        "    for i in range(m - 1, m + 2):\n        L = math.sqrt(3 * math.pow(i, 2) - 3 * i + 1)\n        count += 1 if L <= max_distance else 0"
      ],
      [
        0.875342071056366,
        "    while True:\n        triangles = count_triples(y_limit)\n        for x, count in enumerate(triangles):\n            if count == exactly:\n                return x\n        y_limit += exactly"
      ]
    ],
    "MBPP/226": [
      [
        0.8928461074829102,
        "    flattened_tuple1 = flatten(tuple1)\n    flattened_tuple2 = flatten(tuple2)\n    count_dict1 = {i: flattened_tuple1.count(i) for i in flattened_tuple1}\n    count_dict2 = {i: flattened_tuple2.count(i) for i in flattened_tuple2}\n    all_keys = set(list(count_dict1.keys()) + list(count_dict2.keys()))\n    dicts = {'tuple1': count_dict1, 'tuple2': count_dict2}\n    result = identify(all_keys, dicts)\n    return result"
      ],
      [
        0.8917708396911621,
        "    result = {}\n    for i, element in enumerate(input_tuple):\n        if input_tuple.count(element) > 1:\n            if element not in result:\n                result[element] = {'first_index': input_tuple.index(element), 'last_index': len(input_tuple) - 1 - input_tuple[::-1].index(element)}\n    return result"
      ],
      [
        0.8914268016815186,
        "    flatted_tuple1 = flatten(tuple1)\n    flatted_tuple2 = flatten(tuple2)\n    count_dict1 = {i: flatted_tuple1.count(i) for i in flatted_tuple1}\n    count_dict2 = {i: flatted_tuple2.count(i) for i in flatted_tuple2}\n    all_keys = set(list(count_dict1.keys()) + list(count_dict2.keys()))\n    dicts = {'tuple1': count_dict1, 'tuple2': count_dict2}\n    result = identify(all_keys, dicts)\n    return result"
      ],
      [
        0.8909373879432678,
        "    for item, count in unique_t1.items():\n        result_dict[item] = (count, 'tuple1')"
      ],
      [
        0.8899388313293457,
        "    for item, count in unique_t2.items():\n        result_dict[item] = (count, 'tuple2')"
      ],
      [
        0.8883282542228699,
        "    counts = {x: example_list.count(x) for x in example_list}\n    count = 0\n    for key, value in counts.items():\n        if value > 1:\n            count += 1\n    return count"
      ],
      [
        0.8873628973960876,
        "    seen = set()\n    duplicates = set()\n    for item in input_tuple:\n        if item in seen:\n            duplicates.add(item)\n        seen.add(item)\n    return (len(duplicates) > 0, duplicates)"
      ],
      [
        0.8870044350624084,
        "    flat_t1 = flatten(t1)\n    flat_t2 = flatten(t2)\n    counter_t1 = Counter(flat_t1)\n    counter_t2 = Counter(flat_t2)\n    unique_t1 = counter_t1 - counter_t2\n    unique_t2 = counter_t2 - counter_t1\n    common = counter_t1 & counter_t2\n    result_dict = {}\n    for item, count in unique_t1.items():\n        result_dict[item] = (count, 'tuple1')\n    for item, count in unique_t2.items():\n        result_dict[item] = (count, 'tuple2')\n    for item, count in common.items():\n        result_dict[item] = ([(count, counter_t2[item])], 'both')\n    return result_dict"
      ],
      [
        0.8861669898033142,
        "    count = {}\n    for i in t:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n    duplicates = {k: v for k, v in count.items() if v > 1}\n    return duplicates"
      ],
      [
        0.886145293712616,
        "        if input_tuple.count(element) > 1:\n            if element not in result:\n                result[element] = {'first_index': input_tuple.index(element), 'last_index': len(input_tuple) - 1 - input_tuple[::-1].index(element)}"
      ]
    ],
    "MBPP/227": [
      [
        0.9085758328437805,
        "    substrings = set()\n    n = len(string)\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substrings.add(string[i:j])\n    return len(substrings)"
      ],
      [
        0.9074306488037109,
        "    substrings = set()\n    for i in range(len(string)):\n        for j in range(i + 1, len(string) + 1):\n            substrings.add(string[i:j])\n    return len(substrings)"
      ]
    ],
    "MBPP/228": [
      [
        0.9029790163040161,
        "    eps = 1e-10\n    dp = [[0] * 110 for _ in range(110)]\n    cnt = [[0] * 110 for _ in range(110)]\n    dp[1][1] = 1\n    dp[2][1] = 2\n    dp[2][2] = 1\n    cnt[1][1] = 1\n    cnt[2][1] = 2\n    cnt[2][2] = 1\n    for i in range(3, 101):\n        dp[i][1] = i\n        cnt[i][1] = i\n        dp[i][2] = i - 1\n        cnt[i][2] = cnt[i - 1][2]\n        for j in range(3, min(i + 1, m + 1)):\n            for k in range(j, i + 1):\n                dp[i][j] += ((dp[k - 1][j - 1] + cnt[k - 1][j - 1]) * 2.0 + dp[i - 1][j] + cnt[i - 1][j]) / (i - j + 3) + 1e-10\n                cnt[i][j] += (cnt[k - 1][j - 1] + cnt[i - 1][j]) / (i - j + 3)\n    return dp[100][m]"
      ],
      [
        0.8927455544471741,
        "        for k in range((n + 1) // 2, n):\n            T += comb(n, n // k) * comb(k - 2, 2)\n            T %= m"
      ],
      [
        0.8913999795913696,
        "    for i in range(3, n + 1):\n        cache[i] = 2 * cache[i - 1] + cache[i - 2]\n        if m:\n            cache[i] %= m"
      ],
      [
        0.8913949131965637,
        "    for i in range(3, n + 1):\n        cache[i] = 2 * cache[i - 1] + cache[i - 2]\n        if m:\n            cache[i] %= m"
      ],
      [
        0.8911169171333313,
        "    for i in range(3, 101):\n        dp[i][1] = i\n        cnt[i][1] = i\n        dp[i][2] = i - 1\n        cnt[i][2] = cnt[i - 1][2]\n        for j in range(3, min(i + 1, m + 1)):\n            for k in range(j, i + 1):\n                dp[i][j] += ((dp[k - 1][j - 1] + cnt[k - 1][j - 1]) * 2.0 + dp[i - 1][j] + cnt[i - 1][j]) / (i - j + 3) + 1e-10\n                cnt[i][j] += (cnt[k - 1][j - 1] + cnt[i - 1][j]) / (i - j + 3)"
      ],
      [
        0.8905423879623413,
        "    if m % 2 == 0:\n        return half ** 2 % MOD\n    else:\n        return half ** 2 * n % MOD"
      ],
      [
        0.8898879289627075,
        "    memo = {}\n    total = 0\n    for n in range(0, N + 1):\n        for m in range(0, n + 1):\n            total = (total + h(m, n - m, memo)) % mod\n    return total"
      ],
      [
        0.8897804617881775,
        "    mod = 1000000007\n    a, b, c, d = (6, 6, 3, 3)\n    while n > 1:\n        n -= 1\n        temp_a = a\n        temp_c = c\n        a = (a * 3 + b * 2) % mod\n        b = (temp_a * 2 + b * 2) % mod\n        c = (c * 3 + d * 2) % mod\n        d = (temp_c * 2 + d * 2) % mod\n    return b if m == 1 else (a + c) % mod"
      ],
      [
        0.8891397714614868,
        "    fib = [0, 1]\n    for i in range(2, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2])\n    modulo_sequence = [x % m for x in fib]\n    return modulo_sequence"
      ],
      [
        0.8878198266029358,
        "    dp = [[0] * n for _ in range(m)]\n    for i in range(m):\n        dp[i][0] = dp[i][1] = 0\n    for i in range(2, n):\n        dp[0][i] = dp[1][i] = 0\n    dp[2][0] = dp[2][1] = 1\n    for j in range(2, n):\n        dp[0][j] = dp[1][j] = 1\n    for i in range(2, m):\n        for j in range(2, n):\n            dp[i][j] = dp[i - 1][j - 2] + dp[i - 2][j - 1]\n            dp[i][j] += dp[i - 2][j - 2]\n    return dp[m - 1][n - 1]"
      ]
    ],
    "MBPP/229": [
      [
        0.9032500982284546,
        "    my_list[-1] = new_value\n    return my_list"
      ],
      [
        0.9032223224639893,
        "    list1[-1:] = list2\n    return list1"
      ],
      [
        0.8857401609420776,
        "    last3 = list[-3:]\n    del list[-3:]\n    list = last3 + list\n    return list"
      ],
      [
        0.881003737449646,
        "    last_elements = []\n    for string in str_list:\n        last_elements.append(string[-1])\n    return last_elements"
      ],
      [
        0.8807501792907715,
        "    lst[index] = new_element"
      ],
      [
        0.8802359104156494,
        "    my_array[-1] = new_element\n    return my_array"
      ],
      [
        0.8800912499427795,
        "    if not lst:\n        raise ValueError('List is empty, cannot remove last item')\n    lst.pop()\n    return lst"
      ],
      [
        0.8797735571861267,
        "    original_list.append(new_element)\n    return original_list"
      ],
      [
        0.8783474564552307,
        "        for item in lst:\n            new_lst.append(replace_element(item, old_element, new_element))"
      ],
      [
        0.878273606300354,
        "    if len(lst) == 0:\n        print('Error: List is empty')\n        return\n    if len(lst) < 3:\n        print('Error: List does not have a third element')\n        return\n    if isinstance(lst[2], list):\n        if len(lst[2]) >= 3:\n            lst[2].pop(2)\n        else:\n            lst.pop(2)\n    else:\n        lst.pop(2)\n    print(lst)"
      ]
    ],
    "MBPP/230": [
      [
        0.8990818858146667,
        "    threeD = [[[0 for x in range(l)] for y in range(n)] for z in range(m)]\n    return threeD"
      ],
      [
        0.8878787755966187,
        "    matrix = [[[0 for k in range(z)] for j in range(y)] for i in range(x)]\n    for i in range(x):\n        for j in range(y):\n            for k in range(z):\n                matrix[i][j][k] = random.randint(0, 100)\n    return matrix"
      ],
      [
        0.8826615810394287,
        "    matrix = [[0 for x in range(3)] for y in range(3)]\n    return matrix"
      ],
      [
        0.8820550441741943,
        "    for i in range(x):\n        for j in range(y):\n            for k in range(z):\n                matrix[i][j][k] = random.randint(0, 100)"
      ],
      [
        0.8799110054969788,
        "    for row in range(5):\n        for col in range(5):\n            if row == 3 or col == 3:\n                print('*', end='')\n            else:\n                print(' ', end='')\n        print()"
      ],
      [
        0.8799110054969788,
        "    for row in range(5):\n        for col in range(5):\n            if row == 3 or col == 3:\n                print('*', end='')\n            else:\n                print(' ', end='')\n        print()"
      ],
      [
        0.8795843124389648,
        "            if row == 3 or col == 3:\n                print('*', end='')\n            else:\n                print(' ', end='')"
      ],
      [
        0.8777943849563599,
        "    board = []\n    for _ in range(3):\n        row = []\n        for _ in range(3):\n            row.append(' ')\n        board.append(row)\n    return board"
      ],
      [
        0.8776223659515381,
        "    array = [[[random.randint(-50, 50) for _ in range(z)] for _ in range(y)] for _ in range(x)]\n    for i in range(x):\n        for j in range(y):\n            for k in range(z):\n                if is_prime(array[i][j][k]) and array[i][j][k] > 0:\n                    array[i][j][k] *= -1\n    return array"
      ],
      [
        0.8766086101531982,
        "    return [[L(i * j) for j in range(Y)] for i in range(X)]"
      ]
    ],
    "MBPP/231": [
      [
        0.9334859848022461,
        "    count = 0\n    for char in string:\n        count += 1\n    return count"
      ],
      [
        0.9334847927093506,
        "    count = 0\n    for char in string:\n        count += 1\n    return count"
      ],
      [
        0.9334838390350342,
        "    count = 0\n    for char in string:\n        count += 1\n    return count"
      ],
      [
        0.9334826469421387,
        "    count = 0\n    for char in string:\n        count += 1\n    return count"
      ],
      [
        0.9334813952445984,
        "    count = 0\n    for char in string:\n        count += 1\n    return count"
      ],
      [
        0.9334801435470581,
        "    count = 0\n    for char in string:\n        count += 1\n    return count"
      ],
      [
        0.9334733486175537,
        "    count = 0\n    for char in string:\n        count += 1\n    return count"
      ],
      [
        0.9334732294082642,
        "    count = 0\n    for char in string:\n        count += 1\n    return count"
      ],
      [
        0.9334689378738403,
        "    count = 0\n    for char in string:\n        count += 1\n    return count"
      ],
      [
        0.9334643483161926,
        "    count = 0\n    for char in string:\n        count += 1\n    return count"
      ]
    ],
    "MBPP/232": [],
    "MBPP/233": [
      [
        0.9220438599586487,
        "    if is_perfect_square(n):\n        root = math.sqrt(n)\n        next_square = (root + 1) ** 2\n        return int(next_square)\n    else:\n        return 'Number is not a perfect square'"
      ],
      [
        0.9220438599586487,
        "    if is_perfect_square(n):\n        root = math.sqrt(n)\n        next_square = (root + 1) ** 2\n        return int(next_square)\n    else:\n        return 'Number is not a perfect square'"
      ],
      [
        0.904050350189209,
        "    i = n + 1\n    while True:\n        if (i ** 0.5).is_integer():\n            return i\n        i += 1"
      ],
      [
        0.8987727165222168,
        "    while True:\n        if (i ** 0.5).is_integer():\n            return i\n        i += 1"
      ],
      [
        0.8977842330932617,
        "    while True:\n        if is_prime(x):\n            return x\n        x += 1"
      ],
      [
        0.8973555564880371,
        "    if n * n < x:\n        n += 1"
      ],
      [
        0.8970049619674683,
        "    if n <= 1:\n        return 4\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    i = n + 1\n    while True:\n        if i not in primes:\n            return i\n        i += 1"
      ],
      [
        0.8969919681549072,
        "    if n <= 1:\n        return 4\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    i = n + 1\n    while True:\n        if i not in primes:\n            return i\n        i += 1"
      ],
      [
        0.8969498872756958,
        "    next_num = number + 1\n    while True:\n        if is_prime(next_num):\n            return next_num\n        next_num += 1"
      ],
      [
        0.8966305255889893,
        "    x = N + 1\n    while True:\n        if is_prime(x):\n            return x\n        x += 1"
      ]
    ],
    "MBPP/234": [],
    "MBPP/235": [
      [
        0.9095678925514221,
        "    if abs(guess * guess - x) < 1e-06:\n        return guess\n    else:\n        return sqrt(x, guess if guess != 0.0 else 1.0)"
      ],
      [
        0.9091467261314392,
        "    if n < 0:\n        raise Exception('Invalid input! Cannot compute square root of a negative number.')\n    elif n == 0 or n == 1:\n        return n\n    guess = n / 2.0\n    for _ in range(100000):\n        better_guess = (guess + n / guess) / 2.0\n        if abs(guess - better_guess) < 1e-08:\n            return round(better_guess, 8)\n        guess = better_guess\n    return guess"
      ],
      [
        0.9062095284461975,
        "    if not isinstance(n, (int, float)):\n        return 'Error: Invalid input'\n    if n < 0:\n        return 'Error: Cannot calculate square root of a negative number'\n    if n == 0:\n        return 0\n    low, high = (0, n)\n    while low <= high:\n        mid = (low + high) / 2\n        square = mid * mid\n        if abs(square - n) < 0.0001:\n            return mid\n        elif square > n:\n            high = mid\n        else:\n            low = mid\n    return 'Error: Unable to calculate square root'"
      ],
      [
        0.9041049480438232,
        "    if n < 0:\n        raise Exception('Invalid input! Cannot compute square root of a negative number.')\n    elif n == 0 or n == 1:\n        return n"
      ],
      [
        0.9040594100952148,
        "    if abs(guess * guess - n) < 1e-05:\n        return guess\n    else:\n        better_guess = (guess + n / guess) / 2.0\n        return sqrt(n, better_guess)"
      ],
      [
        0.9040594100952148,
        "    if abs(guess * guess - n) < 1e-05:\n        return guess\n    else:\n        better_guess = (guess + n / guess) / 2.0\n        return sqrt(n, better_guess)"
      ],
      [
        0.9032343029975891,
        "    if x < 0:\n        raise ValueError('Cannot calculate square root of a negative number')\n    if x == 0:\n        return 0\n    y_n = x / 2\n    while True:\n        y_next = 0.5 * (y_n + x / y_n)\n        if abs(y_next - y_n) < precision:\n            return y_next\n        y_n = y_next"
      ],
      [
        0.9027118682861328,
        "    if x < 0:\n        return sqrt(-x) + 'i'\n    if abs(guess * guess - x) < 1e-06:\n        return guess\n    else:\n        return sqrt(x, guess if guess != 0.0 else 1.0)"
      ]
    ],
    "MBPP/236": [],
    "MBPP/237": [
      [
        0.9371569156646729,
        "    if n < 2:\n        return 1\n    else:\n        return 1 / n + harmonic_sum(n - 1)"
      ],
      [
        0.9371569156646729,
        "    if n < 2:\n        return 1\n    else:\n        return 1 / n + harmonic_sum(n - 1)"
      ],
      [
        0.9328620433807373,
        "    if n < 1:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return harmonic(n - 1) + 1 / n"
      ],
      [
        0.9328620433807373,
        "    if n < 1:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return harmonic(n - 1) + 1 / n"
      ],
      [
        0.927391529083252,
        "    elif n == 1:\n        return 1\n    else:\n        return harmonic(n - 1) + 1 / n"
      ],
      [
        0.9046999216079712,
        "    elif n == 1:\n        return 1\n    else:\n        return harmonic(n - 1, m) + 1 / n ** m"
      ],
      [
        0.9004483222961426,
        "    return sum([1 / i for i in range(1, n + 1)])"
      ],
      [
        0.8980658054351807,
        "    elif m < 0:\n        raise ValueError('m must be greater than or equal to 0')\n    elif n == 1:\n        return 1\n    else:\n        return harmonic(n - 1, m) + 1 / n ** m"
      ],
      [
        0.8970105051994324,
        "    seriesSum = 0\n    for num in range(1, n + 1):\n        seriesSum += 1 / num\n    return round(seriesSum, 2)"
      ],
      [
        0.8944053649902344,
        "    if n <= 0:\n        raise ValueError('n must be greater than 0')\n    elif m < 0:\n        raise ValueError('m must be greater than or equal to 0')\n    elif n == 1:\n        return 1\n    else:\n        return harmonic(n - 1, m) + 1 / n ** m"
      ]
    ],
    "MBPP/238": [
      [
        0.9208112955093384,
        "    intersection = []\n    for num in array1:\n        if num in array2 and num not in intersection:\n            intersection.append(num)\n    return intersection"
      ],
      [
        0.9199520349502563,
        "    set1 = set(array1)\n    set2 = set(array2)\n    intersection = []\n    for num in set1:\n        if num in set2:\n            intersection.append(num)\n    return intersection"
      ],
      [
        0.9198405146598816,
        "    intersection = []\n    for element in arr1:\n        if element in arr2:\n            intersection.append(element)\n    return intersection"
      ],
      [
        0.9188664555549622,
        "    intersection = []\n    for elem in arr1:\n        if elem in arr2:\n            intersection.append(elem)\n    return intersection"
      ],
      [
        0.9172005653381348,
        "    intersection = [value for value in arr1 if value in arr2]\n    return intersection"
      ],
      [
        0.9162406921386719,
        "    intersection = list(set(arr1) & set(arr2))\n    return sorted(intersection)"
      ],
      [
        0.9150955677032471,
        "    intersection_arr = []\n    for item in arr1:\n        if item in arr2:\n            intersection_arr.append(item)\n    return intersection_arr"
      ],
      [
        0.9149776101112366,
        "    arr1 = set(arr1)\n    arr2 = set(arr2)\n    intersection = list(arr1.intersection(arr2))\n    return intersection"
      ],
      [
        0.9149653911590576,
        "    intersection = []\n    for item in arr1:\n        if item in arr2 and item not in intersection:\n            intersection.append(item)\n    return intersection"
      ],
      [
        0.9140522480010986,
        "    set1 = set(arr1)\n    set2 = set(arr2)\n    intersection = set1 & set2\n    return list(intersection)"
      ]
    ],
    "MBPP/239": [
      [
        0.9259656667709351,
        "    count = 0\n    for i in tuple_input:\n        if isinstance(i, tuple):\n            count += count_occurrences(element, i)\n        elif i == element:\n            count += 1\n    return count"
      ],
      [
        0.9183135032653809,
        "    count = 0\n    for item in lst:\n        if item == element:\n            count += 1\n    return count"
      ],
      [
        0.9180148839950562,
        "    for i in tuple_input:\n        if isinstance(i, tuple):\n            count += count_occurrences(element, i)\n        elif i == element:\n            count += 1"
      ],
      [
        0.9177379012107849,
        "    count = 0\n    for i in lst:\n        if i == element:\n            count += 1\n    return count"
      ],
      [
        0.9173232316970825,
        "    count = 0\n    for element in lst:\n        if element == ele:\n            count += 1\n    return count"
      ],
      [
        0.9161816835403442,
        "    count = 0\n    for i in input_list:\n        if i == element:\n            count += 1\n    return count"
      ],
      [
        0.9140453934669495,
        "    count = 0\n    for element in lst:\n        if element == target:\n            count += 1\n    return count"
      ],
      [
        0.9140329360961914,
        "    count = 0\n    for element in lst:\n        if element == target:\n            count += 1\n    return count"
      ],
      [
        0.9119289517402649,
        "    count = 0\n    for i in arr:\n        if i == element:\n            count += 1\n    return count"
      ],
      [
        0.9119173288345337,
        "    count = 0\n    for i in arr:\n        if i == element:\n            count += 1\n    return count"
      ]
    ],
    "MBPP/240": [
      [
        0.9018115997314453,
        "    lst.insert(0, element)\n    return lst"
      ],
      [
        0.8902522325515747,
        "    list.insert(index, element)\n    return list"
      ],
      [
        0.8886281251907349,
        "    lst.insert(2, element)\n    return lst"
      ],
      [
        0.8877114057540894,
        "    result = [item for sublist in zip(lst[:-1], [element] * len(lst[:-1])) for item in sublist]\n    result.append(lst[-1])\n    return result"
      ],
      [
        0.8868293762207031,
        "    arr.insert(0, element)\n    return arr"
      ],
      [
        0.8856891989707947,
        "    list.insert(index, element)"
      ],
      [
        0.8848106861114502,
        "    new_list = original_list[:]\n    new_list.insert(index, element)\n    return new_list"
      ],
      [
        0.8845707178115845,
        "    if new_element in my_list:\n        raise ValueError('Element already exists.')\n    else:\n        my_list.insert(0, new_element)\n        return my_list"
      ],
      [
        0.8845707178115845,
        "    if new_element in my_list:\n        raise ValueError('Element already exists.')\n    else:\n        my_list.insert(0, new_element)\n        return my_list"
      ],
      [
        0.884566605091095,
        "    newArray = [None] * (len(array) + 1)\n    newArray[0] = newElement\n    for i in range(len(array)):\n        newArray[i + 1] = array[i]\n    return newArray"
      ]
    ],
    "MBPP/241": [
      [
        0.8854057788848877,
        "    polar_coordinates = []\n    for point in points:\n        x, y = point\n        radius = math.sqrt(x ** 2 + y ** 2)\n        angle = math.atan2(y, x)\n        polar_coordinates.append((radius, angle))\n    return polar_coordinates"
      ],
      [
        0.8797130584716797,
        "    for point in points:\n        x, y = point\n        radius = math.sqrt(x ** 2 + y ** 2)\n        angle = math.atan2(y, x)\n        polar_coordinates.append((radius, angle))"
      ],
      [
        0.8782651424407959,
        "    if isinstance(c, complex):\n        return (c.real, c.imag)"
      ],
      [
        0.8777827024459839,
        "    rectangular_coordinates = []\n    for coord in polar_coordinates:\n        try:\n            if type(coord[0]) != int and type(coord[0]) != float:\n                raise ValueError('Radius value must be a number!')\n            if type(coord[1]) != int and type(coord[1]) != float:\n                raise ValueError('Angle value must be a number!')\n            if coord[0] < 0:\n                raise Exception('Radius value cannot be negative!')\n            x = coord[0] * math.cos(coord[1])\n            y = coord[0] * math.sin(coord[1])\n            rectangular_coordinates.append((x, y))\n        except Exception as e:\n            rectangular_coordinates.append(str(e))\n    return rectangular_coordinates"
      ],
      [
        0.8775005340576172,
        "    if isinstance(c, complex):\n        return (c.real, c.imag)\n    return (c, 0)"
      ],
      [
        0.8773822784423828,
        "    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    return (r, theta)"
      ],
      [
        0.8772130012512207,
        "    rectangular_coords = []\n    for polar_coord in polar_coords:\n        try:\n            r, theta = polar_coord\n            if r < 0:\n                raise ValueError('Radius cannot be negative')\n            theta = math.radians(theta)\n            x = r * math.cos(theta)\n            y = r * math.sin(theta)\n            rectangular_coords.append((x, y))\n        except (ValueError, TypeError):\n            print(f'Inappropriate input: {polar_coord}. It should be (radius, angle) with radius >= 0.')\n    return rectangular_coords"
      ],
      [
        0.8771995306015015,
        "    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    if x < 0:\n        theta += math.pi\n    return (r, theta)"
      ],
      [
        0.8759313225746155,
        "    return complex(numbers[0], numbers[1])"
      ],
      [
        0.8745381832122803,
        "    for coord in polar_coordinates:\n        try:\n            if type(coord[0]) != int and type(coord[0]) != float:\n                raise ValueError('Radius value must be a number!')\n            if type(coord[1]) != int and type(coord[1]) != float:\n                raise ValueError('Angle value must be a number!')\n            if coord[0] < 0:\n                raise Exception('Radius value cannot be negative!')\n            x = coord[0] * math.cos(coord[1])\n            y = coord[0] * math.sin(coord[1])\n            rectangular_coordinates.append((x, y))\n        except Exception as e:\n            rectangular_coordinates.append(str(e))"
      ]
    ],
    "MBPP/242": [
      [
        0.9096596240997314,
        "    if lst is None:\n        return 'Input is null'\n    freq_dict = {}\n    for i in lst:\n        if type(i) == int:\n            if i in freq_dict:\n                freq_dict[i] += 1\n            else:\n                freq_dict[i] = 1\n        else:\n            return 'Non-integer input detected.'\n    return freq_dict"
      ],
      [
        0.9075377583503723,
        "    for ele in my_list:\n        count = 0\n        for e in my_list:\n            if ele == e:\n                count += 1\n        counts[ele] = count"
      ],
      [
        0.9070431590080261,
        "    dict = {}\n    for val in myList:\n        if val in dict:\n            dict[val] += 1\n        else:\n            dict[val] = 1\n    return dict"
      ],
      [
        0.904691219329834,
        "    counts = {}\n    for num in lst:\n        if num <= 0:\n            continue\n        counts[num] = counts.get(num, 0) + 1\n    return counts"
      ],
      [
        0.904360830783844,
        "    count = 0\n    for num in lst:\n        if num == given_num:\n            count += 1\n    return count"
      ],
      [
        0.9042684435844421,
        "    for i in lst:\n        if type(i) == int:\n            if i in freq_dict:\n                freq_dict[i] += 1\n            else:\n                freq_dict[i] = 1\n        else:\n            return 'Non-integer input detected.'"
      ],
      [
        0.9040209054946899,
        "    for val in myList:\n        if val in dict:\n            dict[val] += 1\n        else:\n            dict[val] = 1"
      ],
      [
        0.9035214185714722,
        "    counts = dict()\n    for item in lst:\n        if item in counts:\n            counts[item] += 1\n        else:\n            counts[item] = 1\n    return counts"
      ],
      [
        0.9033882021903992,
        "    count = {}\n    for i in lst:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n    return count"
      ],
      [
        0.9028307199478149,
        "    count_dict = {}\n    unique_nums = set()\n    for num in lst:\n        if num <= 0:\n            continue\n        if num not in unique_nums:\n            if num in count_dict:\n                count_dict[num] += 1\n            else:\n                count_dict[num] = 1\n            unique_nums.add(num)\n    return count_dict"
      ]
    ],
    "MBPP/243": [
      [
        0.9108384251594543,
        "    result = []\n    for string in array:\n        if string[0] == 'a' and string[-1] == 'e':\n            result.append(string)\n    return result if result else []"
      ],
      [
        0.9097294211387634,
        "    output = []\n    for word in words:\n        if word[0] == 'a':\n            output.append(word)\n    return output"
      ],
      [
        0.909494161605835,
        "    a_words = []\n    for word in words:\n        if word[0] == 'a':\n            a_words.append(word)\n    return a_words"
      ],
      [
        0.9082584381103516,
        "    found_words = []\n    for word in words:\n        if 'a' in word:\n            found_words.append(word)\n    return found_words"
      ],
      [
        0.90799880027771,
        "    for string in array:\n        if string[0] == 'a' and string[-1] == 'e':\n            result.append(string)"
      ],
      [
        0.9045609831809998,
        "    for word in words:\n        if word[0] == 'a':\n            output.append(word)"
      ],
      [
        0.9036945700645447,
        "    for word in words:\n        if word[0] == 'a':\n            a_words.append(word)"
      ],
      [
        0.903549075126648,
        "        if string[0] == 'a' and string[-1] == 'e':\n            result.append(string)"
      ],
      [
        0.9033178687095642,
        "    for word in words:\n        if 'a' in word:\n            found_words.append(word)"
      ],
      [
        0.9015417695045471,
        "    result = []\n    for string in strings:\n        if string.startswith('a'):\n            result.append(string)\n    if len(result) == 0:\n        return []\n    return result"
      ]
    ],
    "MBPP/244": [
      [
        0.8970463275909424,
        "    combinations = []\n    for i in range(int1):\n        for j in range(int2):\n            for k in range(int3):\n                combinations.append([i, j, k])\n    return combinations"
      ],
      [
        0.8884900808334351,
        "    for i in range(int1):\n        for j in range(int2):\n            for k in range(int3):\n                combinations.append([i, j, k])"
      ],
      [
        0.8837122321128845,
        "            for k in range(int3):\n                combinations.append([i, j, k])"
      ],
      [
        0.8831455707550049,
        "                for c4 in colors:\n                    combination = [c1, c2, c3, c4]\n                    if combination not in result:\n                        result.append(combination)"
      ],
      [
        0.8822849988937378,
        "        for j in range(int2):\n            for k in range(int3):\n                combinations.append([i, j, k])"
      ],
      [
        0.8802798986434937,
        "    if len(prefix) == n:\n        print(prefix)\n        return\n    if a < 2:\n        generate_strings(n, prefix + 'A', a + 1, b, c)\n    if b < 2:\n        generate_strings(n, prefix + 'B', a, b + 1, c)\n    if c < 2:\n        generate_strings(n, prefix + 'C', a, b, c + 1)"
      ],
      [
        0.8790096640586853,
        "    combinations = list(itertools.combinations(numbers, 3))\n    permutations = [list(itertools.permutations(comb)) for comb in combinations]\n    return (combinations, permutations)"
      ],
      [
        0.8763453960418701,
        "            for c3 in colors:\n                for c4 in colors:\n                    combination = [c1, c2, c3, c4]\n                    if combination not in result:\n                        result.append(combination)"
      ],
      [
        0.8758497834205627,
        "    result = []\n    for i in range(len(a)):\n        for j in range(len(b)):\n            for k in range(len(c)):\n                result.append([a[i], b[j], c[k]])\n    return result"
      ],
      [
        0.8756663799285889,
        "    letters = ['A', 'B', 'C']\n    length = 3\n    combinations = []\n    generate_combinations('', letters, length, combinations)\n    return combinations"
      ]
    ],
    "MBPP/245": [
      [
        0.9235280752182007,
        "    count = 0\n    for i in range(1, n + 1):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n        if is_prime:\n            count = count + 1\n    return count"
      ],
      [
        0.9216600656509399,
        "    count = 0\n    if n > 2:\n        count += 1\n    for i in range(3, n + 1, 2):\n        prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            count += 1\n    return count"
      ],
      [
        0.9215517640113831,
        "    count = 0\n    for m in range(2, num):\n        if check_primes(m) == True:\n            count += 1\n    return count"
      ]
    ],
    "MBPP/246": [
      [
        0.9103308916091919,
        "    first_num = int(input('Enter the first number: '))\n    second_num = int(input('Enter the second number: '))\n    first_num, second_num = (second_num, first_num)\n    print(first_num, second_num)"
      ]
    ],
    "MBPP/247": [
      [
        0.9093067049980164,
        "    count = 0\n    for num in lst:\n        if num % 2 != 0:\n            count += 1\n    return count"
      ],
      [
        0.9080244898796082,
        "    count = 0\n    for i in lst:\n        if i % 2 != 0:\n            count += 1\n    return count"
      ],
      [
        0.9068640470504761,
        "    even_count = 0\n    for num in list:\n        if num % 2 == 0:\n            even_count += 1\n    return even_count"
      ],
      [
        0.9028475284576416,
        "    odd_list = []\n    for num in my_list:\n        if num % 2 != 0:\n            odd_list.append(num)\n    return odd_list"
      ],
      [
        0.9012941718101501,
        "    count = 0\n    for num in lst:\n        if num % 2 == 0:\n            count += 1\n    return count"
      ],
      [
        0.900352954864502,
        "    odd_list = []\n    for number in original_list:\n        if number % 2 != 0:\n            odd_list.append(number)\n    return odd_list"
      ],
      [
        0.8998689651489258,
        "    count = 0\n    for num in number_list:\n        if num % 2 == 0:\n            count += 1\n    return count"
      ],
      [
        0.8996005058288574,
        "    count = 0\n    for num in input_list:\n        if num % 2 == 0:\n            count += 1\n    return count"
      ],
      [
        0.8967082500457764,
        "    count = 0\n    for i in range(len(arr)):\n        if arr[i] % 2 != 0:\n            count = count + 1\n    return count"
      ],
      [
        0.8964639902114868,
        "    odd_sum = 0\n    odd_count = 0\n    odd_numbers = []\n    for num in args:\n        if num > 0 and num % 2 != 0:\n            odd_sum += num\n            odd_count += 1\n            odd_numbers.append(num)\n    return (odd_sum, odd_count, odd_numbers)"
      ]
    ],
    "MBPP/248": [
      [
        0.8892108201980591,
        "    max_values = []\n    for tup in list_of_tuples:\n        max_values.append(max(tup))\n    return max_values"
      ],
      [
        0.8865551352500916,
        "    return (max(list1), max(list2)) if max(list1) != max(list2) else (sorted(list1)[-2], max(list2)) if max(list1) == max(list2) else (max(list1), sorted(list2)[-2])"
      ],
      [
        0.8864699602127075,
        "    return (max(num1, num2), min(num1, num2))"
      ],
      [
        0.8859754800796509,
        "    if max1 > max2:\n        return max1\n    else:\n        return max2"
      ],
      [
        0.8859539031982422,
        "    return max(num1, num2)"
      ],
      [
        0.8859539031982422,
        "    return max(num1, num2)"
      ],
      [
        0.8859534859657288,
        "    return max(num1, num2)"
      ],
      [
        0.8859385848045349,
        "    return max(num1, num2)"
      ],
      [
        0.8858762383460999,
        "    elif len(my_list) == 2:\n        return max(my_list[0], my_list[1])"
      ],
      [
        0.8845216035842896,
        "    return max(num_1, num_2)"
      ]
    ],
    "MBPP/249": [
      [
        0.8919532895088196,
        "    if n <= 2:\n        return prime_list[n - 1]"
      ]
    ],
    "MBPP/250": [
      [
        0.9000197649002075,
        "    for pair1, pair2 in zip(tuples1, tuples2):\n        if len(pair1) != len(pair2):\n            return 'Error: Corresponding tuples should be of same length.'\n        temp = []\n        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)\n        result.append(tuple(temp))"
      ],
      [
        0.9000146389007568,
        "    for pair1, pair2 in zip(tuples1, tuples2):\n        if len(pair1) != len(pair2):\n            return 'Error: Corresponding tuples should be of same length.'\n        temp = []\n        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)\n        result.append(tuple(temp))"
      ],
      [
        0.8965746164321899,
        "    result = []\n    for pair in pair_list:\n        try:\n            result.append(pair[0] / pair[1])\n        except ZeroDivisionError:\n            result.append('Error: Division by Zero')\n    return result"
      ],
      [
        0.8965680003166199,
        "    result = []\n    for pair in pair_list:\n        try:\n            result.append(pair[0] / pair[1])\n        except ZeroDivisionError:\n            result.append('Error: Division by Zero')\n    return result"
      ],
      [
        0.8945704698562622,
        "    if len(t1) != len(t2):\n        return 'Error: tuples are not the same size'\n    else:\n        result = []\n        for i in range(len(t1)):\n            if t2[i] == 0:\n                return f'Error: division by zero in position {i}'\n            else:\n                result.append(t1[i] % t2[i])\n        return tuple(result)"
      ],
      [
        0.8945704698562622,
        "    if len(t1) != len(t2):\n        return 'Error: tuples are not the same size'\n    else:\n        result = []\n        for i in range(len(t1)):\n            if t2[i] == 0:\n                return f'Error: division by zero in position {i}'\n            else:\n                result.append(t1[i] % t2[i])\n        return tuple(result)"
      ],
      [
        0.894566535949707,
        "    if len(t1) != len(t2):\n        return 'Error: tuples are not the same size'\n    else:\n        result = []\n        for i in range(len(t1)):\n            if t2[i] == 0:\n                return f'Error: division by zero in position {i}'\n            else:\n                result.append(t1[i] % t2[i])\n        return tuple(result)"
      ],
      [
        0.894566535949707,
        "    if len(t1) != len(t2):\n        return 'Error: tuples are not the same size'\n    else:\n        result = []\n        for i in range(len(t1)):\n            if t2[i] == 0:\n                return f'Error: division by zero in position {i}'\n            else:\n                result.append(t1[i] % t2[i])\n        return tuple(result)"
      ],
      [
        0.8920450210571289,
        "    for pair in pair_list:\n        try:\n            result.append(pair[0] / pair[1])\n        except ZeroDivisionError:\n            result.append('Error: Division by Zero')"
      ],
      [
        0.8920421600341797,
        "    for pair in pair_list:\n        try:\n            result.append(pair[0] / pair[1])\n        except ZeroDivisionError:\n            result.append('Error: Division by Zero')"
      ]
    ],
    "MBPP/251": [
      [
        0.9071854948997498,
        "    part1 = lst[:size]\n    part2 = lst[size:]\n    return (part1, part2)"
      ],
      [
        0.8958134055137634,
        "    length = len(lst)\n    mid = length // 2\n    first_half = lst[:mid]\n    second_half = lst[mid:]\n    return (first_half, second_half)"
      ],
      [
        0.8895401954650879,
        "    size = len(lst)\n    split_index = size // 2\n    return (lst[:split_index], lst[split_index:])"
      ],
      [
        0.8868935108184814,
        "    half = len(lst) // 2\n    return (lst[:half], lst[half:])"
      ],
      [
        0.8868851661682129,
        "    half = len(lst) // 2\n    return (lst[:half], lst[half:])"
      ],
      [
        0.8868235349655151,
        "    new_list1 = []\n    new_list2 = []\n    if type(k) == float:\n        k = round(k)\n    length1 = len(list1)\n    length2 = len(list2)\n    if not list1 and (not list2):\n        return [k]\n    elif k >= length1 or k >= length2:\n        new_list1 = list1[::-1]\n        new_list2 = list2[::-1]\n    elif k < 0:\n        new_list1 = list1[:k] + list1[k + 1:]\n        new_list2 = list2[:k] + list2[k + 1:]\n    elif k == 0:\n        new_list1 = list1\n        new_list2 = list2\n    else:\n        new_list1 = list1[:k] + list1[k + 1:]\n        new_list2 = list2[:k] + list2[k + 1:]\n    return (new_list1, new_list2)"
      ],
      [
        0.8848313689231873,
        "    length = len(data)\n    midpoint = length // 2\n    first_half = data[:midpoint]\n    second_half = data[midpoint:]\n    return (first_half, second_half)"
      ],
      [
        0.8846242427825928,
        "    mid = len(my_list) // 2\n    left_half = my_list[:mid]\n    right_half = my_list[mid:]\n    return (left_half, right_half)"
      ],
      [
        0.8842469453811646,
        "    length = len(numbers)\n    mid = length // 2\n    list_a = numbers[:mid]\n    list_b = numbers[mid:]\n    return (list_a, list_b)"
      ]
    ],
    "MBPP/252": [],
    "MBPP/253": [
      [
        0.9030285477638245,
        "    years = days / 365\n    return years"
      ],
      [
        0.89225834608078,
        "    return years * 365"
      ],
      [
        0.8915209174156189,
        "    currentYear = datetime.datetime.now().year\n    if birthYear < 1900 or birthYear > currentYear:\n        return 'Invalid birth year'\n    days_in_year = 365.25\n    age_in_days = (currentYear - birthYear) * days_in_year\n    return age_in_days"
      ],
      [
        0.891497015953064,
        "        elif age_split[1] == 'years':\n            converted_age = int(age_split[0])\n        elif age_split[1] == 'weeks':\n            converted_age = int(age_split[0]) / 52\n        elif age_split[1] == 'days':\n            converted_age = int(age_split[0]) / 365"
      ],
      [
        0.8895629644393921,
        "        if age_split[1] == 'months':\n            converted_age = int(age_split[0]) / 12\n        elif age_split[1] == 'years':\n            converted_age = int(age_split[0])\n        elif age_split[1] == 'weeks':\n            converted_age = int(age_split[0]) / 52\n        elif age_split[1] == 'days':\n            converted_age = int(age_split[0]) / 365"
      ],
      [
        0.8880550861358643,
        "        elif age_split[1] == 'weeks':\n            converted_age = int(age_split[0]) / 52\n        elif age_split[1] == 'days':\n            converted_age = int(age_split[0]) / 365"
      ],
      [
        0.8878421187400818,
        "            if age < 0:\n                raise ValueError(\"Age can't be a negative number. Please enter a valid age.\")"
      ],
      [
        0.8876283168792725,
        "    return 15.9 - 0.983 * age"
      ],
      [
        0.8874281644821167,
        "    converted_ages = []\n    for age in ages:\n        age_split = age.split(' ')\n        if age_split[1] == 'months':\n            converted_age = int(age_split[0]) / 12\n        elif age_split[1] == 'years':\n            converted_age = int(age_split[0])\n        elif age_split[1] == 'weeks':\n            converted_age = int(age_split[0]) / 52\n        elif age_split[1] == 'days':\n            converted_age = int(age_split[0]) / 365\n        converted_ages.append(converted_age)\n    return converted_ages"
      ],
      [
        0.8870894908905029,
        "    for age in ages:\n        age_split = age.split(' ')\n        if age_split[1] == 'months':\n            converted_age = int(age_split[0]) / 12\n        elif age_split[1] == 'years':\n            converted_age = int(age_split[0])\n        elif age_split[1] == 'weeks':\n            converted_age = int(age_split[0]) / 52\n        elif age_split[1] == 'days':\n            converted_age = int(age_split[0]) / 365\n        converted_ages.append(converted_age)"
      ]
    ],
    "MBPP/254": [
      [
        0.9106076955795288,
        "    newlist = []\n    indices = list(range(0, len(mylist), n))\n    for start in indices:\n        end = start + n\n        newlist.append(mylist[start:end])\n    return newlist"
      ],
      [
        0.9018875360488892,
        "    list_of_lists = [my_list[i * n:(i + 1) * n] for i in range((len(my_list) + n - 1) // n)]\n    return list_of_lists"
      ],
      [
        0.8978022336959839,
        "    sub_lsts = []\n    for item in lst:\n        sub_lsts.append([item[i:i + n] for i in range(0, len(item), n)])\n    return sub_lsts"
      ],
      [
        0.8963726758956909,
        "    for start in indices:\n        end = start + n\n        newlist.append(mylist[start:end])"
      ],
      [
        0.8939786553382874,
        "    return [lst[i:i + n] for i in range(0, len(lst), n)]"
      ],
      [
        0.8939608931541443,
        "    return [lst[i:i + n] for i in range(0, len(lst), n)]"
      ],
      [
        0.8939602971076965,
        "    return [lst[i:i + n] for i in range(0, len(lst), n)]"
      ],
      [
        0.8924298286437988,
        "    return [l[i:i + n] for i in range(0, len(l), n)]"
      ],
      [
        0.8913612961769104,
        "    for idx, i in enumerate(lst):\n        if idx % n != 0:\n            lst[idx] = l[idx]"
      ],
      [
        0.8911393880844116,
        "    length = len(text) // n\n    return [text[i:i + length] for i in range(0, len(text), length)]"
      ]
    ],
    "MBPP/255": [
      [
        0.8968866467475891,
        "    lateral_surface_area = 2 * l * h + b * h\n    total_surface_area = lateral_surface_area + 2 * l * b\n    return (lateral_surface_area, total_surface_area)"
      ],
      [
        0.8905869722366333,
        "    surface_area = 6 * length ** 2\n    volume = length ** 3\n    return (surface_area, volume)"
      ],
      [
        0.8903260231018066,
        "    surface_area = 2 * l * w + 2 * l * h + 2 * w * h\n    return surface_area"
      ],
      [
        0.8896922469139099,
        "    surface_area = 6 * edge_length ** 2\n    return surface_area"
      ],
      [
        0.8869248032569885,
        "    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area"
      ],
      [
        0.8869073987007141,
        "    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area"
      ]
    ],
    "MBPP/256": [
      [
        0.9249922037124634,
        "    odd_numbers = [2 * i + 1 for i in range(n)]\n    squared_odd_numbers = [x ** 2 for x in odd_numbers]\n    total_sum = sum(squared_odd_numbers)\n    return total_sum"
      ]
    ],
    "MBPP/257": [
      [
        0.8863199949264526,
        "    return findNthPolite(n)"
      ],
      [
        0.8863160610198975,
        "    return findNthPolite(n)"
      ],
      [
        0.8857041001319885,
        "    if n > 0 and n <= len(sequence):\n        return sequence[n - 1]\n    else:\n        return 'Invalid input for n.'"
      ],
      [
        0.8857041001319885,
        "    if n > 0 and n <= len(sequence):\n        return sequence[n - 1]\n    else:\n        return 'Invalid input for n.'"
      ],
      [
        0.8850569725036621,
        "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n)"
      ],
      [
        0.8850569725036621,
        "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n)"
      ],
      [
        0.88226318359375,
        "    for i in range(n):\n        row = ['*'] * stars_per_row\n        print(' '.join(row))"
      ],
      [
        0.8816499710083008,
        "    if nth < 1:\n        return 'Error: input should be a positive integer'"
      ],
      [
        0.881319522857666,
        "    elif n == 2:\n        return 2\n    else:\n        return 2 * nth_value(n - 1)"
      ],
      [
        0.8801995515823364,
        "    for i in range(n):\n        num_consecutive_stars = min(i + 1, n - i, num_stars)\n        for j in range(num_consecutive_stars):\n            print('*', end=' ')\n        print()"
      ]
    ],
    "MBPP/258": [
      [
        0.932205319404602,
        "    char = input('Enter a character: ')\n    ascii_value = ord(char)\n    print(f\"The ASCII value of '{char}' is {ascii_value}\")"
      ],
      [
        0.9260550737380981,
        "    ascii_code = ord(character)\n    return ascii_code"
      ],
      [
        0.9120573997497559,
        "    return ord(char)"
      ],
      [
        0.9120404720306396,
        "    return ord(char)"
      ],
      [
        0.9120267033576965,
        "    return ord(char)"
      ],
      [
        0.91200190782547,
        "    return ord(char)"
      ],
      [
        0.9077188968658447,
        "    return ord(character)"
      ],
      [
        0.907706618309021,
        "    return ord(character)"
      ],
      [
        0.9074543714523315,
        "    return ord(char) - ord('a')"
      ],
      [
        0.903347373008728,
        "    character = chr(ascii_code)\n    return character"
      ]
    ],
    "MBPP/259": [],
    "MBPP/260": [],
    "MBPP/261": [
      [
        0.8832985162734985,
        "    extracted_elements = []\n    for i in range(3):\n        extracted_elements.append(lst[i])\n    return extracted_elements"
      ],
      [
        0.8758921027183533,
        "    if len(tup_list) == 0:\n        return 'The tuple list is empty.'\n    if k > len(tup_list):\n        return 'K is greater than the size of list. Returning all records.'\n    tup_list.sort(key=lambda x: x[0])\n    return tup_list[:k]"
      ],
      [
        0.8740485906600952,
        "    for i in range(3):\n        extracted_elements.append(lst[i])"
      ],
      [
        0.8719848990440369,
        "    if not isinstance(input_list, list):\n        return 'Error: Input must be a list.'\n    elif not input_list:\n        return 'Error: Input list is empty.'\n    else:\n        last_element = input_list[-1]\n        mutated_list = input_list[:-1]\n        return (mutated_list, last_element)"
      ],
      [
        0.8719848990440369,
        "    if not isinstance(input_list, list):\n        return 'Error: Input must be a list.'\n    elif not input_list:\n        return 'Error: Input list is empty.'\n    else:\n        last_element = input_list[-1]\n        mutated_list = input_list[:-1]\n        return (mutated_list, last_element)"
      ],
      [
        0.870297908782959,
        "        if element not in tuple1:\n            tuple1.insert(0, element)"
      ],
      [
        0.8684549331665039,
        "    elif not input_list:\n        return 'Error: Input list is empty.'\n    else:\n        last_element = input_list[-1]\n        mutated_list = input_list[:-1]\n        return (mutated_list, last_element)"
      ],
      [
        0.8678683042526245,
        "    if n > len(lst):\n        return 'invalid'\n    elif n == 0:\n        return []\n    else:\n        return lst[-n:]"
      ],
      [
        0.8678683042526245,
        "    if n > len(lst):\n        return 'invalid'\n    elif n == 0:\n        return []\n    else:\n        return lst[-n:]"
      ],
      [
        0.8671479225158691,
        "    new_lst = []\n    for i in range(len(lst) - 1, -1, -1):\n        new_lst.append(lst[i])\n    return tuple(new_lst)"
      ]
    ],
    "MBPP/262": [
      [
        0.8910036087036133,
        "    return np.subtract(x, y)"
      ],
      [
        0.8898276090621948,
        "        elif t1 <= t2:\n            yield (t1 - t2)\n        else:\n            raise ValueError('Element in first tuple is less than corresponding element in second tuple')"
      ],
      [
        0.8887817859649658,
        "        elif t1 >= t2:\n            yield (t1 - t2)\n        else:\n            raise ValueError('Element in first tuple is less than corresponding element in second tuple')"
      ],
      [
        0.8822159767150879,
        "    paired_elements = zip(List1, List2)\n    List3 = []\n    for pair in paired_elements:\n        List3.append(pair[0] - pair[1])\n    return List3"
      ],
      [
        0.8818223476409912,
        "    if len(arr_a) != len(arr_b):\n        return 'Arrays are of unequal lengths.'\n    else:\n        return [a - b for a, b in zip(arr_a, arr_b)]"
      ],
      [
        0.8818223476409912,
        "    if len(arr_a) != len(arr_b):\n        return 'Arrays are of unequal lengths.'\n    else:\n        return [a - b for a, b in zip(arr_a, arr_b)]"
      ],
      [
        0.8818029761314392,
        "    if len(arr_a) != len(arr_b):\n        return 'Arrays are of unequal lengths.'\n    else:\n        return [a - b for a, b in zip(arr_a, arr_b)]"
      ],
      [
        0.8818029761314392,
        "    if len(arr_a) != len(arr_b):\n        return 'Arrays are of unequal lengths.'\n    else:\n        return [a - b for a, b in zip(arr_a, arr_b)]"
      ],
      [
        0.8817217350006104,
        "    entry = []\n    for i in range(len(v1)):\n        entry.append(v1[i] - v2[i])\n    return entry"
      ],
      [
        0.8810002207756042,
        "    validate_inputs(*args)\n    result = args[0]\n    for num in args[1:]:\n        result -= num\n    return result"
      ]
    ],
    "MBPP/263": [],
    "MBPP/264": [
      [
        0.9037023782730103,
        "    if index != -1:\n        arr.pop(index)\n        return arr\n    else:\n        return -1"
      ],
      [
        0.9007002115249634,
        "    last_instance = None\n    for i in range(len(array)):\n        if array[i] == element:\n            last_instance = i\n    if last_instance is None:\n        return 'Element not found in the array'\n    else:\n        return last_instance"
      ],
      [
        0.8994283676147461,
        "    last_index = -1\n    for i in range(len(arr)):\n        if arr[i] == num:\n            last_index = i\n    return last_index"
      ],
      [
        0.897632896900177,
        "    index = -1\n    for i in range(len(arr)):\n        if arr[i] == element:\n            index = i\n            break\n    if index != -1:\n        arr.pop(index)\n        return arr\n    else:\n        return -1"
      ],
      [
        0.8961472511291504,
        "    idx = arr.index(element)\n    arr.pop(idx)\n    return arr"
      ],
      [
        0.8959569931030273,
        "    last_index = -1\n    for idx, elem in enumerate(arr):\n        if elem == number:\n            last_index = idx\n    return last_index"
      ],
      [
        0.894050657749176,
        "    n = len(arr)\n    last_occurrence = -1\n    for i in range(n):\n        if arr[i] == target:\n            last_occurrence = i\n    return last_occurrence"
      ],
      [
        0.8933663368225098,
        "    for i in range(len(arr) - 1, -1, -1):\n        if arr[i] == item:\n            return i\n    return -1"
      ],
      [
        0.8933612704277039,
        "    for i in range(len(arr) - 1, -1, -1):\n        if arr[i] == item:\n            return i\n    return -1"
      ],
      [
        0.8933597803115845,
        "    for i in range(len(array)):\n        if array[i] == element:\n            last_instance = i"
      ]
    ],
    "MBPP/265": [
      [
        0.9098232984542847,
        "    volume = math.pi * radius ** 2 * height\n    return volume"
      ],
      [
        0.9035979509353638,
        "    return math.pi * cylinder['radius'] ** 2 * cylinder['height']"
      ],
      [
        0.9003052711486816,
        "    volume = 4 / 3 * 3.142 * radius ** 3\n    return round(volume, 2)"
      ],
      [
        0.8999472856521606,
        "    pi = 3.14\n    return pi * radius ** 2 * height"
      ],
      [
        0.8997466564178467,
        "    volume = math.pi * R ** 2 * L\n    return volume"
      ],
      [
        0.899258553981781,
        "    total_volume = 0\n    for cylinder in cylinders:\n        radius = cylinder['radius']\n        height = cylinder['height']\n        volume = math.pi * radius ** 2 * height\n        total_volume += volume\n    return total_volume"
      ],
      [
        0.8992551565170288,
        "    pi = 3.14159\n    volume = 4 / 3 * pi * radius ** 3\n    return volume"
      ],
      [
        0.899254560470581,
        "    total_volume = 0\n    for cylinder in cylinders:\n        radius = cylinder['radius']\n        height = cylinder['height']\n        volume = math.pi * radius ** 2 * height\n        total_volume += volume\n    return total_volume"
      ],
      [
        0.8983006477355957,
        "    if r <= 0 or h <= 0:\n        return 'Radius and Height must be greater than zero.'\n    l = math.sqrt(r ** 2 + h ** 2)\n    return math.pi * r * l"
      ],
      [
        0.8982836008071899,
        "    if r <= 0 or h <= 0:\n        return 'Radius and Height must be greater than zero.'\n    l = math.sqrt(r ** 2 + h ** 2)\n    return math.pi * r * l"
      ]
    ],
    "MBPP/266": [
      [
        0.9115277528762817,
        "    filtered_dict = {}\n    if filter_by == 'keys':\n        for key in keys_or_values:\n            if key in dict_to_filter.keys():\n                filtered_dict[key] = dict_to_filter[key]\n    elif filter_by == 'values':\n        for key, value in dict_to_filter.items():\n            if value in keys_or_values:\n                filtered_dict[key] = value\n    else:\n        print('The filter_by input is invalid.')\n    return filtered_dict"
      ],
      [
        0.9099503755569458,
        "    elif filter_by == 'values':\n        for key, value in dict_to_filter.items():\n            if value in keys_or_values:\n                filtered_dict[key] = value\n    else:\n        print('The filter_by input is invalid.')"
      ],
      [
        0.9040811061859131,
        "    if filter_by == 'keys':\n        for key in keys_or_values:\n            if key in dict_to_filter.keys():\n                filtered_dict[key] = dict_to_filter[key]\n    elif filter_by == 'values':\n        for key, value in dict_to_filter.items():\n            if value in keys_or_values:\n                filtered_dict[key] = value\n    else:\n        print('The filter_by input is invalid.')"
      ],
      [
        0.9031630158424377,
        "    filtered_values = [value for value in dictionary.values() if 5 < value < 9]\n    sorted_values = sorted(filtered_values)\n    return sorted_values"
      ],
      [
        0.8996064066886902,
        "            if value in keys_or_values:\n                filtered_dict[key] = value"
      ],
      [
        0.896740734577179,
        "    filtered_dict = {}\n    for key, value in dictionary.items():\n        if key in criteria:\n            filtered_dict[key] = value\n    return filtered_dict"
      ],
      [
        0.8946236968040466,
        "        for key, value in dict_to_filter.items():\n            if value in keys_or_values:\n                filtered_dict[key] = value"
      ],
      [
        0.894199550151825,
        "        for key in keys_or_values:\n            if key in dict_to_filter.keys():\n                filtered_dict[key] = dict_to_filter[key]"
      ],
      [
        0.8941418528556824,
        "    filtered_dict = {key: value for key, value in input_dict.items() if value.startswith('g')}\n    return filtered_dict"
      ],
      [
        0.8934551477432251,
        "            if key in dict_to_filter.keys():\n                filtered_dict[key] = dict_to_filter[key]"
      ]
    ],
    "MBPP/267": [
      [
        0.8841193318367004,
        "    count = 0\n    for i in tuple_input:\n        if isinstance(i, tuple):\n            count += count_occurrences(element, i)\n        elif i == element:\n            count += 1\n    return count"
      ],
      [
        0.8815112113952637,
        "    for i in tuple_input:\n        if isinstance(i, tuple):\n            count += count_occurrences(element, i)\n        elif i == element:\n            count += 1"
      ],
      [
        0.879615068435669,
        "    if count == 0:\n        return (-1, count)\n    else:\n        index = lst.index(item)\n        return (index, count)"
      ],
      [
        0.8788689970970154,
        "    count = 0\n    for item in lst:\n        if item > number:\n            count += 1\n    return count"
      ],
      [
        0.8786522150039673,
        "    count = 0\n    for element in list:\n        if element > x:\n            count += 1\n    return count"
      ],
      [
        0.8785920143127441,
        "    position = T.find(q)\n    count = T.count(q)\n    return (position, count)"
      ],
      [
        0.8785139918327332,
        "    for element in list:\n        if element > x:\n            count += 1"
      ],
      [
        0.8781731724739075,
        "    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count"
      ],
      [
        0.8780033588409424,
        "    count = 0\n    for element in arr:\n        if element > target:\n            count += 1\n    return count"
      ],
      [
        0.8777231574058533,
        "    count = 0\n    for num in lst:\n        if num > value:\n            count += 1\n    return count"
      ]
    ],
    "MBPP/268": [
      [
        0.8948100805282593,
        "        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4"
      ],
      [
        0.8947908282279968,
        "        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4"
      ],
      [
        0.8862782120704651,
        "    if n in memory:\n        return memory[n]\n    if n < 1 or n > 1000 or (not isinstance(n, int)):\n        return 'Invalid input'\n    elif n == 1:\n        return 1\n    else:\n        memory[n] = n * (7 * n - 5) // 2\n        return nonagonal(n - 1, memory)"
      ],
      [
        0.8862671852111816,
        "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"
      ],
      [
        0.8862671852111816,
        "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"
      ],
      [
        0.8862640857696533,
        "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"
      ],
      [
        0.8862640857696533,
        "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"
      ],
      [
        0.8856913447380066,
        "    if not isinstance(n, int) or n <= 0:\n        return 'Invalid Input'\n    if n > 1000:\n        return 'Cannot calculate for numbers > 1000'\n    if n == 1:\n        if sequence:\n            return [1]\n        else:\n            return 1\n    else:\n        previous_seq = nonagonal_calc(n - 1, sequence=True)\n        current_value = n * (7 * n - 5) // 2\n        if sequence:\n            return previous_seq + [current_value]\n        else:\n            return current_value"
      ],
      [
        0.8846306800842285,
        "    if n < 1 or n > 1000 or (not isinstance(n, int)):\n        return 'Invalid input'\n    elif n == 1:\n        return 1\n    else:\n        memory[n] = n * (7 * n - 5) // 2\n        return nonagonal(n - 1, memory)"
      ],
      [
        0.884617030620575,
        "    if type(n) != int or n < 0:\n        return 'ERROR: Invalid Input'\n    if n > 5000:\n        return 'ERROR: Input number too large'\n    if n in computed:\n        return computed[n]\n    computed[n] = n * (5 * n - 3) / 2 + heptagonal(n - 1)\n    return computed[n]"
      ]
    ],
    "MBPP/269": [
      [
        0.9066569805145264,
        "    if result != -1:\n        print('Element is present at index', str(result))\n    else:\n        print('Element is not present in array')"
      ],
      [
        0.9046139717102051,
        "    for i in range(len(array)):\n        if array[i] == search_element:\n            return i\n    return -1"
      ]
    ],
    "MBPP/270": [
      [
        0.9367316365242004,
        "    unique_list = []\n    for i in my_list:\n        if i not in unique_list:\n            unique_list.append(i)\n    if len(unique_list) == len(my_list):\n        return True\n    else:\n        return False"
      ],
      [
        0.9336757659912109,
        "    unique_list = []\n    for elem in lst:\n        if elem not in unique_list:\n            unique_list.append(elem)\n    if len(lst) == len(unique_list):\n        return True\n    else:\n        return False"
      ],
      [
        0.9249272346496582,
        "    if len(unique_list) == len(my_list):\n        return True\n    else:\n        return False"
      ],
      [
        0.9234593510627747,
        "    unique_list = list(dict.fromkeys(list))\n    return len(list) == len(unique_list)"
      ],
      [
        0.9221532940864563,
        "    if len(lst) == len(unique_list):\n        return True\n    else:\n        return False"
      ],
      [
        0.921165943145752,
        "    unique_set = set()\n    for i in li:\n        if i not in unique_set:\n            unique_set.add(i)\n        else:\n            return True\n    return False"
      ],
      [
        0.9204325079917908,
        "    seen = set()\n    for element in my_list:\n        if element in seen:\n            return False\n        seen.add(element)\n    return True"
      ],
      [
        0.9177873730659485,
        "    n = len(lst)\n    unique_elements = set()\n    for i in range(n):\n        if lst[i] in unique_elements:\n            return False\n        unique_elements.add(lst[i])\n    return True"
      ],
      [
        0.913994550704956,
        "    if len(input_list) == len(set(input_list)):\n        return 'The list is characterized by uniqueness, there are no duplicate values.'\n    else:\n        return 'The list contains repetitive elements.'"
      ],
      [
        0.913994550704956,
        "    if len(input_list) == len(set(input_list)):\n        return 'The list is characterized by uniqueness, there are no duplicate values.'\n    else:\n        return 'The list contains repetitive elements.'"
      ]
    ],
    "MBPP/271": [
      [
        0.9013996124267578,
        "    try:\n        return [a - b for a, b in zip(list1, list2)]\n    except Exception as e:\n        print('An error occurred:', e)"
      ],
      [
        0.9013996124267578,
        "    try:\n        return [a - b for a, b in zip(list1, list2)]\n    except Exception as e:\n        print('An error occurred:', e)"
      ],
      [
        0.9010075330734253,
        "    try:\n        result = [a - b for a, b in zip(list1, list2)]\n    except TypeError as err:\n        return f'Error: Lists must contain only numbers. {err}'"
      ],
      [
        0.8991479277610779,
        "    if len(list1) != len(list2):\n        return 'Error: Lists are not of the same length.'\n    try:\n        result = [a - b for a, b in zip(list1, list2)]\n    except TypeError as err:\n        return f'Error: Lists must contain only numbers. {err}'\n    return result"
      ],
      [
        0.8983710408210754,
        "    paired_elements = zip(List1, List2)\n    List3 = []\n    for pair in paired_elements:\n        List3.append(pair[0] - pair[1])\n    return List3"
      ],
      [
        0.89823317527771,
        "    result = [a + b for a, b in zip(list1, list2)]\n    return result"
      ],
      [
        0.898220419883728,
        "    result = [a + b for a, b in zip(list1, list2)]\n    return result"
      ],
      [
        0.8980156183242798,
        "    return [multiply(x, y) for x, y in zip(list1, list2)]"
      ],
      [
        0.8966836929321289,
        "    return [a + b for a, b in zip(list1, list2)]"
      ],
      [
        0.8966687917709351,
        "    return [a + b for a, b in zip(list1, list2)]"
      ]
    ],
    "MBPP/272": [
      [
        0.8908730745315552,
        "    for i in range(1, 10):\n        if count[i] > 0 and count[i] == count[i - 1]:\n            return True"
      ],
      [
        0.890342116355896,
        "    digital_roots = [digital_root(num) for num in lst]\n    return all((digital_roots[i] <= digital_roots[i + 1] for i in range(len(digital_roots) - 1)))"
      ],
      [
        0.8871026039123535,
        "    if distinct_digits < 2:\n        return False"
      ],
      [
        0.8866664171218872,
        "    count = string.count(char)\n    if count == digit:\n        return True\n    else:\n        return False"
      ],
      [
        0.8848637342453003,
        "        if sorted(digits) == list(range(min(digits), max(digits) + 1)):\n            return True"
      ],
      [
        0.884585976600647,
        "    count = [0] * 10\n    for c in s:\n        count[int(c)] += 1\n    for i in range(1, 10):\n        if count[i] > 0 and count[i] == count[i - 1]:\n            return True\n    return False"
      ],
      [
        0.8841819763183594,
        "    if count == digit:\n        return True\n    else:\n        return False"
      ],
      [
        0.8825011253356934,
        "    for c in num:\n        if not c.isdigit():\n            raise ValueError('Non-numeric character found.')\n    for i in range(len(num) - 1):\n        if num[i] > num[i + 1]:\n            return False\n    return True"
      ],
      [
        0.8817811012268066,
        "        if digit in unique_digits:\n            return False"
      ],
      [
        0.8815326690673828,
        "    for value in frequency_counter.values():\n        if value > 3:\n            return False"
      ]
    ],
    "MBPP/273": [
      [
        0.9033188819885254,
        "    string_length = len(string_list[0])\n    for string in string_list:\n        if len(string) != string_length:\n            return False\n    return True"
      ],
      [
        0.8995363712310791,
        "    if not list_of_strings:\n        print('The list is empty.')\n    else:\n        string_length = len(list_of_strings[0])\n        all_equal_length = all((len(string) == string_length for string in list_of_strings))\n        if all_equal_length:\n            print('All strings in the list are of equal length.')\n        else:\n            print('Not all strings in the list are of equal length.')"
      ],
      [
        0.8995363712310791,
        "    if not list_of_strings:\n        print('The list is empty.')\n    else:\n        string_length = len(list_of_strings[0])\n        all_equal_length = all((len(string) == string_length for string in list_of_strings))\n        if all_equal_length:\n            print('All strings in the list are of equal length.')\n        else:\n            print('Not all strings in the list are of equal length.')"
      ],
      [
        0.8895975947380066,
        "    if not lst:\n        return True\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True"
      ],
      [
        0.8886514902114868,
        "    if len(lst) == 0:\n        return False\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True"
      ],
      [
        0.8886175751686096,
        "        if all_equal_length:\n            print('All strings in the list are of equal length.')\n        else:\n            print('Not all strings in the list are of equal length.')"
      ],
      [
        0.885779857635498,
        "    for s in str_list:\n        if s.lower() != s:\n            return False\n    return True"
      ],
      [
        0.8855278491973877,
        "    if len(lst) == 0:\n        return True\n    first_element = lst[0]\n    for i in range(1, len(lst)):\n        if lst[i] != first_element:\n            return False\n    return True"
      ],
      [
        0.8852776288986206,
        "    for i in range(len(my_list)):\n        for j in range(i + 1, len(my_list)):\n            if my_list[i] != my_list[j]:\n                return False\n    return True"
      ],
      [
        0.885048508644104,
        "    for string in string_list:\n        if len(string) != string_length:\n            return False"
      ]
    ],
    "MBPP/274": [
      [
        0.9024074077606201,
        "    if re.search(pattern, s):\n        return True\n    else:\n        return \"Error: The string does not contain 'a' followed by any characters, ending in 'b'.\""
      ],
      [
        0.894310474395752,
        "    if string.count('a') < 2:\n        return False\n    if 'b' not in string or 'c' not in string:\n        return False\n    if string.index('b') > string.index('c'):\n        return False\n    return True"
      ],
      [
        0.8910571932792664,
        "    pattern = 'Ab?c'\n    return re.match(pattern, s) is not None"
      ],
      [
        0.8908705711364746,
        "    if not isinstance(s, str):\n        return 'Error: Input is not a string.'\n    pattern = 'a.*b$'\n    if re.search(pattern, s):\n        return True\n    else:\n        return \"Error: The string does not contain 'a' followed by any characters, ending in 'b'.\""
      ],
      [
        0.8883770108222961,
        "    pattern = '^.*a{2}.*$'\n    if re.match(pattern, string):\n        return True\n    else:\n        return False"
      ],
      [
        0.888206422328949,
        "    regex = '^.*a.*b.*c.*$'\n    match = re.search(regex, s)\n    if match:\n        return True\n    return False"
      ],
      [
        0.8870445489883423,
        "    if string.count('a') < 2:\n        return False\n    if string.count('b') != 1:\n        return False\n    if string.count('c') == 0 or string.count('d') == 0:\n        return False\n    if 'bd' in string:\n        return False\n    if string.index('c') > string.index('d'):\n        return False\n    return True"
      ],
      [
        0.8865867853164673,
        "    if input_string[0] == 'a' and input_string[-1] == 'b':\n        return True\n    else:\n        return False"
      ],
      [
        0.8865867853164673,
        "    if input_string[0] == 'a' and input_string[-1] == 'b':\n        return True\n    else:\n        return False"
      ],
      [
        0.8848963379859924,
        "    matches = re.findall('abbb', input_str)\n    return len(matches) > 0"
      ]
    ],
    "MBPP/275": [
      [
        0.9156724214553833,
        "    for i in range(len(arr) * min(2, k)):\n        max_ending_here = max(arr[i % len(arr)], max_ending_here + arr[i % len(arr)])\n        max_sum = max(max_sum, max_ending_here)"
      ],
      [
        0.9140724539756775,
        "    max_sum = 0\n    start, end = (0, k - 1)\n    while end < len(array):\n        sub_array = array[start:end + 1]\n        new_sum = sum(sub_array)\n        if new_sum > max_sum:\n            max_sum = new_sum\n        start += 1\n        end += 1\n    return max_sum"
      ],
      [
        0.9087518453598022,
        "    mod = 10 ** 9 + 7\n    n = len(arr)\n    max_sum, max_left, max_right = (0, 0, 0)\n    total_sum = sum(arr)\n    temp_sum = 0\n    for i in range(n):\n        temp_sum += arr[i]\n        max_sum = max(max_sum, temp_sum)\n        temp_sum = max(0, temp_sum)\n        max_left = max(max_left, temp_sum)\n    temp = total_sum\n    for i in range(n - 1, -1, -1):\n        temp -= arr[i]\n        max_right = max(max_right, temp)\n    ans = max(max_sum, max_left + max_right + total_sum * (k - 2), 0)\n    return ans % mod"
      ],
      [
        0.9087285995483398,
        "    if len(arr) < k:\n        return 0\n    max_sum = 0\n    sum = 0\n    for i in range(k):\n        sum += arr[i]\n    max_sum = sum\n    i = 0\n    j = k\n    while j < len(arr):\n        sum = sum - arr[i] + arr[j]\n        if sum > max_sum:\n            max_sum = sum\n        i += 1\n        j += 1\n    return max_sum"
      ],
      [
        0.9084204435348511,
        "    for i in range(0, k):\n        max_sum += arr[i]"
      ],
      [
        0.9076988697052002,
        "            if sum(arr[i:i + m]) * k > sum(max_m) * k or (sum(arr[i:i + m]) * k == sum(max_m) * k and arr[i - m:i] > max_m):\n                max_m = arr[i:i + m]"
      ],
      [
        0.9071744084358215,
        "    while i < len(arr) - m * k + 1:\n        if all((arr[i + j] == arr[i + j + m] for j in range(m * (k - 1)))):\n            if sum(arr[i:i + m]) * k > sum(max_m) * k or (sum(arr[i:i + m]) * k == sum(max_m) * k and arr[i - m:i] > max_m):\n                max_m = arr[i:i + m]\n            i += m * k - 1\n        i += 1"
      ],
      [
        0.9064028263092041,
        "    max_m = [-1] * m\n    i = 0\n    while i < len(arr) - m * k + 1:\n        if all((arr[i + j] == arr[i + j + m] for j in range(m * (k - 1)))):\n            if sum(arr[i:i + m]) * k > sum(max_m) * k or (sum(arr[i:i + m]) * k == sum(max_m) * k and arr[i - m:i] > max_m):\n                max_m = arr[i:i + m]\n            i += m * k - 1\n        i += 1\n    return (sum(max_m) > -1, max_m)"
      ],
      [
        0.9062168598175049,
        "    for i in range(len(arr) - k + 1):\n        curr_sum = 0\n        for j in range(i, i + k):\n            curr_sum += arr[j]\n        max_sum = max(max_sum, curr_sum)"
      ],
      [
        0.9061333537101746,
        "    max_sum = 0\n    current_sum = 0\n    for i in range(k):\n        current_sum += arr[i]\n    max_sum = current_sum\n    for i in range(k, len(arr)):\n        current_sum = current_sum - arr[i - k] + arr[i]\n        max_sum = max(max_sum, current_sum)\n    return max_sum"
      ]
    ],
    "MBPP/276": [],
    "MBPP/277": [
      [
        0.8938065767288208,
        "    count = 0\n    for i in arr:\n        if i >= 0 and is_prime(i) and (i == num):\n            count += 1\n    return count"
      ],
      [
        0.8853530287742615,
        "    A = [(modPow(2, i, N + 1), i) for i in range(1, N + 1)]\n    A.sort()\n    inv = 0\n    bit = [0] * (N + 1)\n    for _, i in A:\n        x = i\n        while x > 0:\n            inv += bit[x]\n            x -= x & -x\n        x = i\n        while x <= N:\n            bit[x] += 1\n            x += x & -x\n    return inv"
      ],
      [
        0.8838062286376953,
        "    for i in arr:\n        if i >= 0 and is_prime(i) and (i == num):\n            count += 1"
      ],
      [
        0.882923424243927,
        "            while q <= n:\n                primePowerCount[q] += 1\n                q *= p"
      ],
      [
        0.8794403076171875,
        "    count = 0\n    for x in arr:\n        is_prime = True\n        for i in range(2, x):\n            if x % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            count += 1\n    return count"
      ],
      [
        0.8791124820709229,
        "    lcm = 1\n    for prime, freq in zip(primes, freqs):\n        lcm = lcm * pow(prime, freq, MOD) % MOD\n    result = lcm * modInv(x) % MOD\n    return result"
      ],
      [
        0.877967894077301,
        "    for num in arr:\n        if num < 0:\n            num = abs(num)\n        if is_prime(num):\n            count += 1"
      ],
      [
        0.8769206404685974,
        "    count = 0\n    for num in arr:\n        if is_prime(num):\n            count += 1\n    return count"
      ],
      [
        0.8769165873527527,
        "    count = 0\n    for num in arr:\n        if is_prime(num):\n            count += 1\n    return count"
      ],
      [
        0.8769161105155945,
        "    count = 0\n    for num in arr:\n        if is_prime(num):\n            count += 1\n    return count"
      ]
    ],
    "MBPP/278": [
      [
        0.9020766019821167,
        "    count = 0\n    while year > 0:\n        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            count += 1\n        year -= 1\n    return count"
      ],
      [
        0.901099681854248,
        "    if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n        return 366\n    else:\n        return 365"
      ],
      [
        0.901099681854248,
        "    if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n        return 366\n    else:\n        return 365"
      ],
      [
        0.8983266949653625,
        "        if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            count += 1"
      ],
      [
        0.898200273513794,
        "        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            count += 1"
      ],
      [
        0.8957658410072327,
        "        elif year % 100 == 0:\n            return 28\n        elif year % 4 == 0:\n            return 29\n        else:\n            return 28"
      ],
      [
        0.8957074880599976,
        "    from datetime import date\n    start_date = date(year, 1, 1)\n    today = date.today()\n    numofdays = (today - start_date).days\n    return 365 - numofdays"
      ],
      [
        0.8955879211425781,
        "    leap_years = 0\n    for y in range(1582, year + 1):\n        if y % 4 == 0 and y % 100 != 0 or y % 400 == 0:\n            leap_years += 1\n    return leap_years"
      ],
      [
        0.894985556602478,
        "        if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            totalDays += 1"
      ],
      [
        0.8932164311408997,
        "    while year > 0:\n        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            count += 1\n        year -= 1"
      ]
    ],
    "MBPP/279": [
      [
        0.9170675873756409,
        "    for sublist in list:\n        maxLength = max(maxLength, len(sublist))"
      ],
      [
        0.9140346646308899,
        "    max_count = 0\n    result = []\n    for item in lst:\n        length_item = len(item)\n        if length_item > max_count:\n            max_count = length_item\n            result = [item]\n        elif length_item == max_count:\n            result.append(item)\n    return result"
      ],
      [
        0.9128992557525635,
        "    max_sum = None\n    max_list = None\n    for lst in list_of_lists:\n        if max_sum is None or sum(lst) > max_sum:\n            max_sum = sum(lst)\n            max_list = lst\n    return max_list"
      ],
      [
        0.9123244285583496,
        "    max_length = -1\n    index = -1\n    for i in range(len(lst)):\n        if len(lst[i]) > max_length:\n            max_length = len(lst[i])\n            index = i\n    return (max_length, index)"
      ],
      [
        0.9103139638900757,
        "    for lst in [list1, list2, list3]:\n        cur_num_elm = max([len(s) for s in lst])\n        if cur_num_elm > max_num_elm:\n            max_num_elm = cur_num_elm"
      ],
      [
        0.9083154201507568,
        "    max_length = max((len(sublist) for sublist in lst))\n    index_of_longest = next((i for i, sublist in enumerate(lst) if len(sublist) == max_length))\n    return (max_length, index_of_longest)"
      ],
      [
        0.9076851606369019,
        "    for item in lst:\n        length_item = len(item)\n        if length_item > max_count:\n            max_count = length_item\n            result = [item]\n        elif length_item == max_count:\n            result.append(item)"
      ],
      [
        0.9072137475013733,
        "    max_unique = 0\n    max_list = []\n    for l in nested_list:\n        if len(set(l)) > max_unique:\n            max_unique = len(set(l))\n            max_list = l\n    return max_list"
      ],
      [
        0.9053839445114136,
        "    for lst in list_of_lists:\n        if max_sum is None or sum(lst) > max_sum:\n            max_sum = sum(lst)\n            max_list = lst"
      ],
      [
        0.9053548574447632,
        "    return max(list1, key=len)"
      ]
    ],
    "MBPP/280": [
      [
        0.8940953016281128,
        "    colors = [2, 3, 4]\n    sums = [1] + [0] * n\n    for color in colors:\n        for j in range(color, n + 1):\n            sums[j] += sums[j - color]\n    return sums[n] - 1"
      ],
      [
        0.8864284157752991,
        "    if n == 0:\n        return 0\n    elif n == 1:\n        return k\n    else:\n        same = [0] * n\n        diff = [0] * n\n        same[0] = k\n        same[1] = k\n        diff[0] = k\n        diff[1] = (k - 1) * k\n        for i in range(2, n):\n            same[i] = diff[i - 1]\n            diff[i] = (k - 1) * (same[i - 1] + diff[i - 1])\n        return same[n - 1] + diff[n - 1]"
      ],
      [
        0.8864284157752991,
        "    if n == 0:\n        return 0\n    elif n == 1:\n        return k\n    else:\n        same = [0] * n\n        diff = [0] * n\n        same[0] = k\n        same[1] = k\n        diff[0] = k\n        diff[1] = (k - 1) * k\n        for i in range(2, n):\n            same[i] = diff[i - 1]\n            diff[i] = (k - 1) * (same[i - 1] + diff[i - 1])\n        return same[n - 1] + diff[n - 1]"
      ],
      [
        0.8838192224502563,
        "    if n <= 1:\n        return 1\n    else:\n        return math.factorial(2 * n) // (math.factorial(n + 1) * math.factorial(n))"
      ],
      [
        0.8838192224502563,
        "    if n <= 1:\n        return 1\n    else:\n        return math.factorial(2 * n) // (math.factorial(n + 1) * math.factorial(n))"
      ],
      [
        0.883818507194519,
        "    if n <= 1:\n        return 1\n    else:\n        return math.factorial(2 * n) // (math.factorial(n + 1) * math.factorial(n))"
      ],
      [
        0.883818507194519,
        "    if n <= 1:\n        return 1\n    else:\n        return math.factorial(2 * n) // (math.factorial(n + 1) * math.factorial(n))"
      ],
      [
        0.8830320835113525,
        "    if k < n or k < 0:\n        return 0\n    return fact[n] * invfact[k] * invfact[n - k] % MOD"
      ],
      [
        0.8825972676277161,
        "    elif n == 1:\n        return k\n    else:\n        same = [0] * n\n        diff = [0] * n\n        same[0] = k\n        same[1] = k\n        diff[0] = k\n        diff[1] = (k - 1) * k\n        for i in range(2, n):\n            same[i] = diff[i - 1]\n            diff[i] = (k - 1) * (same[i - 1] + diff[i - 1])\n        return same[n - 1] + diff[n - 1]"
      ],
      [
        0.8825619220733643,
        "    ways_to_paint_rows = 2 ** num_rows\n    ways_to_paint_columns = 2 ** num_columns\n    total_ways = ways_to_paint_rows * ways_to_paint_columns\n    return total_ways"
      ]
    ],
    "MBPP/281": [
      [
        0.917977511882782,
        "    quotient = num1 / num2\n    remainder = num1 % num2\n    print('The quotient is:', quotient)\n    print('The remainder is:', remainder)\n    return quotient"
      ],
      [
        0.908411979675293,
        "    quotient = num1 // num2\n    remainder = num1 % num2\n    return (quotient, remainder)"
      ],
      [
        0.9083957672119141,
        "    quotient = num1 // num2\n    remainder = num1 % num2\n    return (quotient, remainder)"
      ],
      [
        0.9066479206085205,
        "    quotient = a // b\n    remainder = a % b\n    print('Quotient:', quotient)\n    print('Remainder:', remainder)"
      ],
      [
        0.9044547080993652,
        "    quotient = num1 // num2\n    remainder = num1 % num2\n    print(f'{num1} divided by {num2} is {quotient} with a remainder of {remainder}')\n    return quotient"
      ],
      [
        0.904443085193634,
        "    quotient = num1 // num2\n    remainder = num1 % num2\n    print(f'{num1} divided by {num2} is {quotient} with a remainder of {remainder}')\n    return quotient"
      ],
      [
        0.9036740064620972,
        "    quotient = num1 // num2\n    remainder = num1 % num2\n    print('The answer is {} with a remainder of {}.'.format(quotient, remainder))"
      ],
      [
        0.9025429487228394,
        "    quotient = x / y\n    remainder = x % y\n    return (quotient, remainder)"
      ],
      [
        0.9024113416671753,
        "    if b == 0:\n        return 'undefined'\n    quotient = 0\n    while a >= b:\n        a -= b\n        quotient += 1\n    return quotient"
      ],
      [
        0.9024025797843933,
        "    if b == 0:\n        return 'undefined'\n    quotient = 0\n    while a >= b:\n        a -= b\n        quotient += 1\n    return quotient"
      ]
    ],
    "MBPP/282": [
      [
        0.8919987678527832,
        "    if side1 + side2 <= side3 or side2 + side3 <= side1 or side1 + side3 <= side2:\n        raise ValueError('Invalid triangle: sum of any two sides is not greater than the third side')\n    if side1 <= 0 or side2 <= 0 or side3 <= 0:\n        raise ValueError('Invalid triangle: sides cannot be zero or negative')\n    if side1 == 0:\n        missing_side = math.sqrt(side3 ** 2 - side2 ** 2)\n    elif side2 == 0:\n        missing_side = math.sqrt(side3 ** 2 - side1 ** 2)\n    else:\n        missing_side = math.sqrt(side1 ** 2 + side2 ** 2)\n    return round(missing_side)"
      ],
      [
        0.8915107250213623,
        "    sides = [side1, side2, side3]\n    sides.sort()\n    if sides[0] + sides[1] <= sides[2]:\n        raise ValueError('Invalid triangle')\n    if sides[0] ** 2 + sides[1] ** 2 != sides[2] ** 2:\n        raise ValueError('Not a right triangle')\n    missing_side = (sides[0] ** 2 + sides[1] ** 2) ** 0.5\n    return missing_side"
      ],
      [
        0.8858010768890381,
        "    elif side1 + side2 <= side1 or side1 + side2 <= side2 or side1 + side1 <= side2:\n        print('Invalid input. These sides do not form a valid triangle')\n        return None\n    else:\n        height = side2 * math.sin(math.radians(angle))\n        return height"
      ],
      [
        0.8826761841773987,
        "    elif side2 == 0:\n        missing_side = math.sqrt(side3 ** 2 - side1 ** 2)\n    else:\n        missing_side = math.sqrt(side1 ** 2 + side2 ** 2)"
      ],
      [
        0.8823167681694031,
        "    angle_radians = math.radians(angle)\n    height = opposite_side_length * math.sin(angle_radians)\n    return height"
      ],
      [
        0.8822988271713257,
        "    elif side_b ** 2 + side_c ** 2 == side_a ** 2:\n        return math.sqrt(side_b ** 2 + side_c ** 2)\n    else:\n        raise ValueError('The given sides do not satisfy the Pythagorean theorem')"
      ],
      [
        0.8809611797332764,
        "    if side1 == side2:\n        raise InvalidTriangleException('The given sides do not form a right triangle.')"
      ],
      [
        0.8807372450828552,
        "    if angle <= 0 or angle >= 180:\n        print('Invalid input. Please enter a valid angle')\n        return None\n    elif side1 <= 0 or side2 <= 0:\n        print('Invalid input. Please enter valid sides')\n        return None\n    elif side1 + side2 <= side1 or side1 + side2 <= side2 or side1 + side1 <= side2:\n        print('Invalid input. These sides do not form a valid triangle')\n        return None\n    else:\n        height = side2 * math.sin(math.radians(angle))\n        return height"
      ],
      [
        0.8807372450828552,
        "    if angle <= 0 or angle >= 180:\n        print('Invalid input. Please enter a valid angle')\n        return None\n    elif side1 <= 0 or side2 <= 0:\n        print('Invalid input. Please enter valid sides')\n        return None\n    elif side1 + side2 <= side1 or side1 + side2 <= side2 or side1 + side1 <= side2:\n        print('Invalid input. These sides do not form a valid triangle')\n        return None\n    else:\n        height = side2 * math.sin(math.radians(angle))\n        return height"
      ],
      [
        0.8797630667686462,
        "    elif side_a ** 2 + side_c ** 2 == side_b ** 2:\n        return math.sqrt(side_a ** 2 + side_c ** 2)\n    elif side_b ** 2 + side_c ** 2 == side_a ** 2:\n        return math.sqrt(side_b ** 2 + side_c ** 2)\n    else:\n        raise ValueError('The given sides do not satisfy the Pythagorean theorem')"
      ]
    ],
    "MBPP/283": [
      [
        0.9102327823638916,
        "    max_value = input_list[0]\n    for value in input_list:\n        if value > max_value:\n            max_value = value\n    return max_value"
      ],
      [
        0.9102317690849304,
        "    max_value = input_list[0]\n    for value in input_list:\n        if value > max_value:\n            max_value = value\n    return max_value"
      ],
      [
        0.9102190732955933,
        "    max_value = input_list[0]\n    for value in input_list:\n        if value > max_value:\n            max_value = value\n    return max_value"
      ],
      [
        0.9097464084625244,
        "    max_value = 0\n    for element in list:\n        if element > max_value:\n            max_value = element\n    return max_value"
      ],
      [
        0.9088153839111328,
        "    max_value = None\n    no_numeric_values = True\n    for el in arr:\n        if type(el) == int or type(el) == float:\n            no_numeric_values = False\n            if max_value is None or el > max_value:\n                max_value = el\n    if no_numeric_values:\n        return 'No numerical values found.'\n    else:\n        return max_value"
      ],
      [
        0.9087114334106445,
        "    maximum = 0\n    for num in list:\n        if num > maximum:\n            maximum = num\n    return maximum"
      ],
      [
        0.9085575342178345,
        "    max_item = list[0]\n    for item in list:\n        if item > max_item:\n            max_item = item\n    return max_item"
      ],
      [
        0.9083346128463745,
        "        for value in lst:\n            try:\n                if not maximum:\n                    maximum = value\n                elif value > maximum:\n                    maximum = value\n            except TypeError:\n                return 'Error: List contains non-comparable types.'"
      ],
      [
        0.9077091217041016,
        "    max_value = l[0]\n    for n in l:\n        if n > max_value:\n            max_value = n\n    return max_value"
      ],
      [
        0.9071829319000244,
        "    max = list[0]\n    for a in list:\n        if a > max:\n            max = a\n    return max"
      ]
    ],
    "MBPP/284": [
      [
        0.9269799590110779,
        "    divisors = [i for i in range(1, num) if num % i == 0]\n    return sum(divisors)"
      ],
      [
        0.9211775660514832,
        "    divisors = []\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisors.append(i)\n    return sum(divisors)"
      ],
      [
        0.9145058989524841,
        "    divisor_sum = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisor_sum += i\n    return divisor_sum"
      ],
      [
        0.9134545922279358,
        "    if n <= 1:\n        return 0\n    sum_divisors = 1\n    for i in range(2, int(n / 2) + 1):\n        if n % i == 0:\n            sum_divisors += i\n    return sum_divisors"
      ],
      [
        0.9118098020553589,
        "    divisors_sum = 0\n    for i in range(1, num):\n        if num % i == 0:\n            divisors_sum += i\n    return divisors_sum"
      ],
      [
        0.911483883857727,
        "    divisors = [i for i in range(1, n + 1) if n % i == 0]\n    return divisors"
      ],
      [
        0.911480724811554,
        "    divisors = [i for i in range(1, n + 1) if n % i == 0]\n    return divisors"
      ],
      [
        0.9092029333114624,
        "    sum_divisors = 0\n    for i in range(1, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if i != num and (not is_prime(i)):\n                sum_divisors += i\n            if i != num and i != num // i and (not is_prime(num // i)):\n                sum_divisors += num // i\n    return sum_divisors"
      ]
    ],
    "MBPP/285": [
      [
        0.9263496398925781,
        "    inversions = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inversions += 1\n    return inversions"
      ],
      [
        0.9253156185150146,
        "    inversion_count = 0\n    for i in range(0, len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inversion_count += 1\n    return inversion_count"
      ],
      [
        0.9231417179107666,
        "    inversion_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inversion_count += 1\n    return inversion_count"
      ],
      [
        0.9153294563293457,
        "    if len(arr) <= 1:\n        return (arr, 0)\n    else:\n        middle = len(arr) // 2\n        left, left_inversions = count_inversions(arr[:middle])\n        right, right_inversions = count_inversions(arr[middle:])\n        result, split_inversions = merge_and_count_inversions(left, right)\n        return (result, left_inversions + right_inversions + split_inversions)"
      ],
      [
        0.9153294563293457,
        "    if len(arr) <= 1:\n        return (arr, 0)\n    else:\n        middle = len(arr) // 2\n        left, left_inversions = count_inversions(arr[:middle])\n        right, right_inversions = count_inversions(arr[middle:])\n        result, split_inversions = merge_and_count_inversions(left, right)\n        return (result, left_inversions + right_inversions + split_inversions)"
      ],
      [
        0.9122133255004883,
        "    inverted_array = list(reversed(input_array))\n    inversion_count = 0\n    for i in range(len(input_array)):\n        for j in range(i + 1, len(input_array)):\n            if input_array[i] > input_array[j]:\n                inversion_count += 1\n    return (inverted_array, inversion_count)"
      ],
      [
        0.9102210402488708,
        "    if start >= end:\n        return 0\n    mid = (start + end) // 2\n    inversions = merge_sort(nums, start, mid, temp) + merge_sort(nums, mid + 1, end, temp)\n    i, j = (start, mid + 1)\n    while i <= mid and j <= end:\n        if nums[i] <= nums[j]:\n            i += 1\n        else:\n            inversions += mid - i + 1\n            j += 1\n    merge(nums, start, mid, end, temp)\n    return inversions"
      ],
      [
        0.9102131128311157,
        "    if start >= end:\n        return 0\n    mid = (start + end) // 2\n    inversions = merge_sort(nums, start, mid, temp) + merge_sort(nums, mid + 1, end, temp)\n    i, j = (start, mid + 1)\n    while i <= mid and j <= end:\n        if nums[i] <= nums[j]:\n            i += 1\n        else:\n            inversions += mid - i + 1\n            j += 1\n    merge(nums, start, mid, end, temp)\n    return inversions"
      ],
      [
        0.9088349342346191,
        "    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count"
      ],
      [
        0.9078990817070007,
        "    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] < arr[i]:\n                inversions += 1"
      ]
    ],
    "MBPP/286": [
      [
        0.918831467628479,
        "    flattened_list = []\n    for item in nested_list:\n        if type(item) == list:\n            flattened_list += item\n        else:\n            flattened_list.append(item)\n    return flattened_list"
      ],
      [
        0.9169492125511169,
        "    if not nested_list:\n        return []\n    first_list, remaining_lists = (nested_list[0], nested_list[1:])\n    flat_list = []\n    for element in first_list:\n        flat_list.append(element)\n    return flat_list + flatten_list(remaining_lists)"
      ],
      [
        0.9168915152549744,
        "    if not nested_list:\n        return []\n    first_list, remaining_lists = (nested_list[0], nested_list[1:])\n    flat_list = []\n    for element in first_list:\n        flat_list.append(element)\n    return flat_list + flatten_list(remaining_lists)"
      ],
      [
        0.916506290435791,
        "    flattened_list = []\n    for sublist in nested_list:\n        for item in sublist:\n            flattened_list.append(item)\n    return flattened_list"
      ],
      [
        0.9165045619010925,
        "    flattened_list = []\n    for sublist in nested_list:\n        for item in sublist:\n            flattened_list.append(item)\n    return flattened_list"
      ],
      [
        0.9155434370040894,
        "    flat_list = []\n    for sublist in nested_list:\n        for item in sublist:\n            flat_list.append(item)\n    return flat_list"
      ],
      [
        0.9150062799453735,
        "    output = []\n    for i in nested_list:\n        if isinstance(i, list):\n            output.extend(flattenList(i))\n        else:\n            output.append(i)\n    return output"
      ],
      [
        0.915000319480896,
        "    output = []\n    for i in nested_list:\n        if isinstance(i, list):\n            output.extend(flattenList(i))\n        else:\n            output.append(i)\n    return output"
      ]
    ],
    "MBPP/287": [
      [
        0.9161186218261719,
        "    for item in list1:\n        if item in list2:\n            result.append(item)\n        if isinstance(item, list):\n            nested_result = find_overlapping_elements(item, list2)\n            result.extend(nested_result)"
      ],
      [
        0.9151726961135864,
        "    result = []\n    for item in list1:\n        if item in list2:\n            result.append(item)\n        if isinstance(item, list):\n            nested_result = find_overlapping_elements(item, list2)\n            result.extend(nested_result)\n    return result"
      ],
      [
        0.9145150184631348,
        "    count = 0\n    for sub_list in nested_list:\n        for elem in sub_list:\n            if elem == item:\n                count += 1\n    return count"
      ],
      [
        0.9113320112228394,
        "    found = False\n    for i in range(len(nested_list)):\n        for j in range(len(nested_list[i])):\n            if nested_list[i][j] == target:\n                found = True\n                return (target, i, j)\n    if not found:\n        return 'Value not found'"
      ],
      [
        0.9110997915267944,
        "    for i in range(len(nested_list)):\n        for j in range(len(nested_list[i])):\n            if nested_list[i][j] == target:\n                found = True\n                return (target, i, j)"
      ],
      [
        0.9097486734390259,
        "    for sub_list in nested_list:\n        for elem in sub_list:\n            if elem == item:\n                count += 1"
      ],
      [
        0.9097052812576294,
        "    list3 = [value for value in list1 if value in list2]\n    return list3"
      ],
      [
        0.9093407988548279,
        "    flat_list1 = flatten(list_one)\n    flat_list2 = flatten(list_two)\n    common_list = [value for value in flat_list1 if value in flat_list2]\n    return common_list"
      ],
      [
        0.9087589979171753,
        "    lst3 = [value for value in lst1 if value in lst2]\n    return lst3"
      ],
      [
        0.9085926413536072,
        "    temp_list = []\n    for element in list1:\n        if element in list2:\n            temp_list.append(element)\n    return temp_list"
      ]
    ],
    "MBPP/288": [
      [
        0.9038277864456177,
        "    max_values = []\n    for tup in list_of_tuples:\n        max_values.append(max(tup))\n    return max_values"
      ],
      [
        0.8954051733016968,
        "    for tup in list_of_tuples:\n        max_values.append(max(tup))"
      ],
      [
        0.883834183216095,
        "    max_values = {}\n    for item in input_list:\n        group = item['group']\n        value = item['value']\n        if group not in max_values or value > max_values[group]:\n            max_values[group] = value\n    output_list = [{'group': group, 'max_value': value} for group, value in max_values.items()]\n    return output_list"
      ],
      [
        0.8824976682662964,
        "    if isinstance(args[0], tuple):\n        return [max(t) for t in args]\n    else:\n        return max(args)"
      ],
      [
        0.8824868202209473,
        "    if isinstance(args[0], tuple):\n        return [max(t) for t in args]\n    else:\n        return max(args)"
      ],
      [
        0.8789302110671997,
        "    max_value = 0\n    for element in list:\n        if element > max_value:\n            max_value = element\n    return max_value"
      ],
      [
        0.8781439065933228,
        "    maximum = 0\n    for num in list:\n        if num > maximum:\n            maximum = num\n    return maximum"
      ],
      [
        0.8777869343757629,
        "    if len(list) == 0:\n        return None\n    max = list[0]\n    for i in range(1, len(list)):\n        if list[i] > max:\n            max = list[i]\n    return max"
      ],
      [
        0.8770224452018738,
        "    max = list[0]\n    for a in list:\n        if a > max:\n            max = a\n    return max"
      ],
      [
        0.8766415119171143,
        "    max = list[0]\n    for i in list:\n        if i > max:\n            max = i\n    return max"
      ]
    ],
    "MBPP/289": [
      [
        0.9089908599853516,
        "    sum = 0\n    for i in range(1, n + 1):\n        term = math.pow(2, i) / math.factorial(i)\n        sum += term\n    return sum"
      ],
      [
        0.9063689112663269,
        "    if n <= 1:\n        return 1\n    else:\n        return math.factorial(2 * n) // (math.factorial(n + 1) * math.factorial(n))"
      ],
      [
        0.9063689112663269,
        "    if n <= 1:\n        return 1\n    else:\n        return math.factorial(2 * n) // (math.factorial(n + 1) * math.factorial(n))"
      ],
      [
        0.9063622951507568,
        "    if n <= 1:\n        return 1\n    else:\n        return math.factorial(2 * n) // (math.factorial(n + 1) * math.factorial(n))"
      ],
      [
        0.9063622951507568,
        "    if n <= 1:\n        return 1\n    else:\n        return math.factorial(2 * n) // (math.factorial(n + 1) * math.factorial(n))"
      ],
      [
        0.9059543609619141,
        "    dp = [[0] * 1024 for _ in range(11)]\n    dp[0][0] = 1\n    for i in range(10):\n        mask = 1 << i\n        for j in range(n + 1):\n            for f in range(1024):\n                if dp[j][f] == 0:\n                    continue\n                for k in range(10):\n                    if f & 1 << k != 0:\n                        continue\n                    if i * 2 == j and k == 0:\n                        continue\n                    nf = f | 1 << k\n                    dp[j + 1 if k % 2 == 0 else j][nf] += dp[j][f]\n    return sum((dp[i][1023] for i in range(n // 2 * 2 + 1, n + 1)))"
      ],
      [
        0.9056851863861084,
        "    for i in range(1, n + 1):\n        term = math.pow(2, i) / math.factorial(i)\n        sum += term"
      ],
      [
        0.9048875570297241,
        "    for i in range(n):\n        count += countBinaryTrees(i) * countBinaryTrees(n - i - 1)"
      ],
      [
        0.9048705101013184,
        "    for i in range(1, n + 1):\n        for j in range(2 * n + 1):\n            if j - 1 >= 0:\n                dp[i][j] += dp[i - 1][j - 1]\n            if j + 1 <= 2 * n:\n                dp[i][j] += dp[i - 1][j + 1]"
      ],
      [
        0.9041309356689453,
        "    sum = 0\n    fact = math.factorial(n)\n    for i in range(n + 1):\n        if i % 2 == 0:\n            sum += fact / math.factorial(i)\n        else:\n            sum -= fact / math.factorial(i)\n    return int(sum)"
      ]
    ],
    "MBPP/290": [
      [
        0.9230877757072449,
        "    for value in dictionary.values():\n        depth = 1 + find_max_depth(value)\n        max_depth = max(max_depth, depth)"
      ],
      [
        0.9201183915138245,
        "    if not isinstance(dictionary, dict):\n        return 0\n    max_depth = 0\n    for value in dictionary.values():\n        depth = 1 + find_max_depth(value)\n        max_depth = max(max_depth, depth)\n    return max_depth"
      ],
      [
        0.9150459170341492,
        "    if isinstance(d, dict):\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)"
      ],
      [
        0.914048969745636,
        "    if isinstance(d, dict):\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\n    return 0"
      ],
      [
        0.9038162231445312,
        "    for k, v in dictionary.items():\n        if isinstance(v, dict):\n            new_path = f'{path}/{k}'\n            new_level, max_level, max_path = max_depth(v, new_path, level + 1, max_level, max_path)\n            if new_level > max_level:\n                max_level = new_level\n                max_path = new_path\n        elif level > max_level:\n            max_level = level\n            max_path = path\n    return (level, max_level, max_path)"
      ],
      [
        0.9007081389427185,
        "    keys = len(d)\n    for k, v in d.items():\n        if isinstance(v, dict):\n            keys += count_keys(v, depth + 1)\n    return keys"
      ],
      [
        0.9006878137588501,
        "    keys = len(d)\n    for k, v in d.items():\n        if isinstance(v, dict):\n            keys += count_keys(v, depth + 1)\n    return keys"
      ],
      [
        0.8984403610229492,
        "    for k, v in dictionary.items():\n        if isinstance(v, dict):\n            new_path = f'{path}/{k}'\n            new_level, max_level, max_path = max_depth(v, new_path, level + 1, max_level, max_path)\n            if new_level > max_level:\n                max_level = new_level\n                max_path = new_path\n        elif level > max_level:\n            max_level = level\n            max_path = path"
      ],
      [
        0.8971502184867859,
        "    if not isinstance(d, dict):\n        return (depth, 0, [])\n    depth += 1\n    key_count = len(d)\n    value_types = set((type(v) for v in d.values()))\n    inner_depth, inner_key_count, inner_value_types = (0, 0, set())\n    for v in d.values():\n        if isinstance(v, dict):\n            id, ikc, ivt = analyze_dict(v, depth)\n            inner_depth = max(inner_depth, id)\n            inner_key_count += ikc\n            inner_value_types = inner_value_types.union(ivt)\n        elif isinstance(v, list):\n            for item in v:\n                if isinstance(item, dict):\n                    id, ikc, ivt = analyze_dict(item, depth)\n                    inner_depth = max(inner_depth, id)\n                    inner_key_count += ikc\n                    inner_value_types = inner_value_types.union(ivt)\n    value_types = value_types.union(inner_value_types)\n    return (max(depth, inner_depth), key_count + inner_key_count, value_types)"
      ],
      [
        0.8971405029296875,
        "    if not isinstance(d, dict):\n        return (depth, 0, [])\n    depth += 1\n    key_count = len(d)\n    value_types = set((type(v) for v in d.values()))\n    inner_depth, inner_key_count, inner_value_types = (0, 0, set())\n    for v in d.values():\n        if isinstance(v, dict):\n            id, ikc, ivt = analyze_dict(v, depth)\n            inner_depth = max(inner_depth, id)\n            inner_key_count += ikc\n            inner_value_types = inner_value_types.union(ivt)\n        elif isinstance(v, list):\n            for item in v:\n                if isinstance(item, dict):\n                    id, ikc, ivt = analyze_dict(item, depth)\n                    inner_depth = max(inner_depth, id)\n                    inner_key_count += ikc\n                    inner_value_types = inner_value_types.union(ivt)\n    value_types = value_types.union(inner_value_types)\n    return (max(depth, inner_depth), key_count + inner_key_count, value_types)"
      ]
    ],
    "MBPP/291": [
      [
        0.9006671905517578,
        "    binary = bin(n)[2:]\n    return len(binary) - binary.find('1')"
      ],
      [
        0.8937824964523315,
        "    return number.bit_length() - 1"
      ],
      [
        0.8921354413032532,
        "        if not bit_vector & 1 << i:\n            return i + 1"
      ],
      [
        0.8909868001937866,
        "    binary = bin(num)[2:]\n    count = 0\n    for bit in reversed(binary):\n        if bit == '0':\n            count += 1\n        else:\n            break\n    return count"
      ],
      [
        0.8902969360351562,
        "    binary = bin(n)[2:]\n    index_of_last_one = -1\n    max_gap = 0\n    for i in range(len(binary)):\n        if binary[i] == '1':\n            if index_of_last_one >= 0:\n                gap = i - index_of_last_one - 1\n                max_gap = max(max_gap, gap)\n            index_of_last_one = i\n    return max_gap"
      ],
      [
        0.8902767896652222,
        "    binary = bin(n)[2:]\n    index_of_last_one = -1\n    max_gap = 0\n    for i in range(len(binary)):\n        if binary[i] == '1':\n            if index_of_last_one >= 0:\n                gap = i - index_of_last_one - 1\n                max_gap = max(max_gap, gap)\n            index_of_last_one = i\n    return max_gap"
      ],
      [
        0.887858510017395,
        "    return bin(n).count('1')"
      ],
      [
        0.886387288570404,
        "    for count in highest_bit:\n        result = max(result, count)"
      ],
      [
        0.8859133720397949,
        "    p = 0\n    while 1 << p + 1 <= n:\n        p += 1\n    return p"
      ],
      [
        0.8855503797531128,
        "    result = 0\n    highest_bit = [0] * 32\n    for num in nums:\n        for j in range(32):\n            if num & 1 << j:\n                highest_bit[j] += 1\n    for count in highest_bit:\n        result = max(result, count)\n    return result + 31"
      ]
    ],
    "MBPP/292": [
      [
        0.8840997219085693,
        "    if count1 == count2:\n        return True\n    else:\n        return False"
      ],
      [
        0.8823354840278625,
        "    if s1_count == s2_count:\n        return True\n    else:\n        return False"
      ],
      [
        0.8796061277389526,
        "    if str1_count == str2_count:\n        return True\n    else:\n        return False"
      ],
      [
        0.8786142468452454,
        "    if count_dict1 != count_dict2:\n        return False"
      ],
      [
        0.876702606678009,
        "    return Counter(list1) == Counter(list2)"
      ],
      [
        0.8756668567657471,
        "    return Counter(lst1) == Counter(lst2)"
      ],
      [
        0.8756529092788696,
        "    return Counter(lst1) == Counter(lst2)"
      ],
      [
        0.8751487731933594,
        "    equal_count = 0\n    equal_positions = []\n    if len(arr1) != len(arr2):\n        return (False, equal_count)\n    for i in range(len(arr1)):\n        if arr1[i] == arr2[i]:\n            equal_count += 1\n            equal_positions.append(i)\n    return (False if equal_count != len(arr1) else True, equal_count, equal_positions)"
      ],
      [
        0.8743799924850464,
        "    if count1 == count2:\n        return True"
      ],
      [
        0.8740088939666748,
        "    try:\n        g1type = next(iter(group1))\n        for item in group1:\n            if type(item) != type(g1type):\n                raise ValueError('All elements in each group must be the same type')\n        for item in group2:\n            if type(item) != type(g1type):\n                raise ValueError('All elements in each group must be the same type')\n        if len(set(group1)) != len(group1):\n            raise ValueError('Group1 contains repeated items')\n        for item in group1:\n            if item not in group2:\n                return False\n        return True\n    except ValueError as ve:\n        print('An exception occurred: ', ve)\n    except Exception as e:\n        print('An exception occurred: ', e)"
      ]
    ],
    "MBPP/293": [
      [
        0.9071388840675354,
        "    for i in range(N):\n        rotated_list.append(given_list[(i + K) % len_given_lst])"
      ],
      [
        0.903816819190979,
        "    num_of_rotations = k % len(arr)\n    arr = arr[num_of_rotations:] + arr[:num_of_rotations]\n    return arr"
      ],
      [
        0.9027888774871826,
        "    n = len(arr)\n    d = d % n\n    rotated_arr = arr[-d:] + arr[:-d]\n    return rotated_arr"
      ],
      [
        0.900787353515625,
        "    if rotation == 0:\n        return arr\n    rotation = -rotation % len(arr)\n    return array_rotate(arr, rotation)"
      ],
      [
        0.8997993469238281,
        "    if not arr or rotation == 0:\n        return arr\n    rotation = rotation % len(arr)\n    if rotation < 0:\n        rotation += len(arr)\n    arr[:rotation], arr[rotation:] = (arr[-rotation:], arr[:-rotation])\n    return arr"
      ],
      [
        0.8991291522979736,
        "    if rotation < 0:\n        rotation += len(arr)"
      ],
      [
        0.8989643454551697,
        "    if not given_list:\n        return []\n    rotated_list = []\n    len_given_lst = len(given_list)\n    for i in range(N):\n        rotated_list.append(given_list[(i + K) % len_given_lst])\n    return rotated_list"
      ],
      [
        0.8978017568588257,
        "    if k > 1:\n        rotate(arr, k - 1)"
      ],
      [
        0.8966304659843445,
        "    length = len(arr)\n    rotation = k % length\n    rotated_arr = []\n    for i in range(length):\n        new_pos = (i + rotation) % length\n        if not wrap and new_pos >= length:\n            continue\n        rotated_arr.append(arr[new_pos])\n    return rotated_arr"
      ],
      [
        0.8963457942008972,
        "    for i in range(k):\n        rotated_list = [rotated_list[-1]] + rotated_list[:-1]"
      ]
    ],
    "MBPP/294": [
      [
        0.8925397396087646,
        "    matching_words = [word for word in words_list if query in word]\n    return matching_words"
      ],
      [
        0.8923183679580688,
        "    for word in words:\n        if pattern.search(word):\n            matched_words.append(word)"
      ],
      [
        0.8923114538192749,
        "    for word in words:\n        if pattern.search(word):\n            matched_words.append(word)"
      ],
      [
        0.8892611265182495,
        "    return [item for item in word_list if word1 in item and word2 in item]"
      ],
      [
        0.8887100219726562,
        "    words = words.strip()\n    word_list = words.split()\n    if len(word_list) < 3:\n        return 'Input string must contain at least three words'\n    last_word = word_list[-1]\n    second_last_word = word_list[-2]\n    return (second_last_word, last_word)"
      ],
      [
        0.8877663016319275,
        "    for word in words:\n        if word[0] == letter:\n            matches.append(word)"
      ],
      [
        0.8858890533447266,
        "    words = open('words.txt').read().splitlines()\n    if word in words:\n        return word\n    else:\n        suggestions = []\n        for w in words:\n            if re.search(word[0], w):\n                if re.search(word[1], w):\n                    if re.search(word[2], w):\n                        suggestions.append(w)\n        return suggestions"
      ],
      [
        0.8851797580718994,
        "    extracted_words = []\n    for word in word_list:\n        if word[0] == given_letter:\n            extracted_words.append(word)\n    return extracted_words"
      ],
      [
        0.885050892829895,
        "    for word in words:\n        if word[0] == char and word[-1] == char:\n            print(word)\n            print(word.upper())"
      ],
      [
        0.8845800161361694,
        "    found_words = []\n    for word in words:\n        if 'a' in word:\n            found_words.append(word)\n    return found_words"
      ]
    ],
    "MBPP/295": [
      [
        0.9029334783554077,
        "            if arr[i] > arr[j] and max_sum[i] < max_sum[j] + arr[i]:\n                max_sum[i] = max_sum[j] + arr[i]"
      ],
      [
        0.8990116119384766,
        "        if max_sum_ending_here > max_sum:\n            max_sum = max_sum_ending_here"
      ],
      [
        0.8985146880149841,
        "        if max_so_far < max_till_here:\n            max_so_far = max_till_here"
      ],
      [
        0.8981460332870483,
        "    if i == len(arr):\n        return 0\n    sum_of_largest = findSum(arr, i + 1)\n    if i == 0 or arr[i] > sum_of_largest:\n        return arr[i] + sum_of_largest\n    else:\n        return sum_of_largest"
      ],
      [
        0.8979414701461792,
        "    for i in range(n):\n        max_sum[i] = arr[i]"
      ],
      [
        0.8966784477233887,
        "        if max_ending_so_far < max_ending_here:\n            max_ending_so_far = max_ending_here\n            end = i"
      ],
      [
        0.8965380191802979,
        "    for i in range(1, len(arr)):\n        temp = max_sum_incl\n        max_sum_incl = max(max_sum_excl + arr[i], max_sum_incl)\n        max_sum_excl = temp"
      ],
      [
        0.8964583277702332,
        "    if i == 0 or arr[i] > sum_of_largest:\n        return arr[i] + sum_of_largest\n    else:\n        return sum_of_largest"
      ],
      [
        0.8959110975265503,
        "        for j in range(i, n):\n            max_ending_here += arr[j]\n            if max_sum_so_far < max_ending_here:\n                max_sum_so_far = max_ending_here"
      ],
      [
        0.8955981135368347,
        "        for j in range(i, n):\n            curr_sum = curr_sum + arr[j]\n            max_sum = max(max_sum, curr_sum)"
      ]
    ],
    "MBPP/296": [
      [
        0.8699681758880615,
        "    return tuple[-4:-2]"
      ],
      [
        0.8645063638687134,
        "    if type(tup) != tuple:\n        return 'Error: Not a tuple.'"
      ],
      [
        0.8643205165863037,
        "    if not tup:\n        return 'Error: Tuple is empty.'"
      ]
    ],
    "MBPP/297": [
      [
        0.8975734114646912,
        "    max_product = float('-inf')\n    max_lists = []\n    for lst in list_of_lists:\n        if len(lst) != 0:\n            product = 1\n            for num in lst:\n                product *= num\n            product = round(product, 2)\n            if product == max_product:\n                max_lists.append(lst)\n            elif product > max_product:\n                max_lists = [lst]\n                max_product = product\n    return (max_product, max_lists)"
      ],
      [
        0.8968391418457031,
        "    products_list = []\n    for lst in list_of_lists:\n        product = 1\n        for num in lst:\n            product *= num\n        products_list.append(round(product, 2))\n    max_product = max(products_list)\n    max_lists = [list_of_lists[i] for i in range(len(list_of_lists)) if products_list[i] == max_product]\n    return (max_lists, max_product)"
      ],
      [
        0.8960877060890198,
        "    max_product = float('-inf')\n    max_lists = []\n    for lst in list_of_lists:\n        product = 1\n        for num in lst:\n            product *= num\n        if product > max_product:\n            max_product = product\n            max_lists = [lst]\n        elif product == max_product:\n            max_lists.append(lst)\n    return (max_product, max_lists)"
      ],
      [
        0.8957583904266357,
        "    max_product = float('-inf')\n    max_lists = []\n    for lst in list_of_lists:\n        flat_list = list(flatten(lst))\n        if flat_list:\n            temp_product = float(product(flat_list))\n            if temp_product > max_product:\n                max_product = temp_product\n                max_lists = [flat_list]\n            elif temp_product == max_product:\n                max_lists.append(flat_list)\n    return (max_product, max_lists)"
      ],
      [
        0.8934485912322998,
        "    for lst in list_of_lists:\n        product = 1\n        for num in lst:\n            product *= num\n        if product > max_product:\n            max_product = product\n            max_list = lst"
      ],
      [
        0.8934305310249329,
        "    for lst in list_of_lists:\n        product = 1\n        for num in lst:\n            product *= num\n        if product > max_product:\n            max_product = product\n            max_list = lst"
      ]
    ],
    "MBPP/298": [
      [
        0.9238356351852417,
        "    if a > b:\n        max = a\n    else:\n        max = b\n    return max"
      ],
      [
        0.9213209748268127,
        "    return max(num1, num2)"
      ],
      [
        0.9213182926177979,
        "    return max(num1, num2)"
      ],
      [
        0.9213182926177979,
        "    return max(num1, num2)"
      ],
      [
        0.921317458152771,
        "    return max(num1, num2)"
      ],
      [
        0.9201641082763672,
        "    max_val = num1 if num1 > num2 else num2\n    return max_val"
      ],
      [
        0.9184246063232422,
        "    if a > b:\n        max = a\n    else:\n        max = b"
      ],
      [
        0.9175087809562683,
        "    return max(num_1, num_2)"
      ]
    ],
    "MBPP/299": [
      [
        0.8945112824440002,
        "    return ast.literal_eval(tup_string)"
      ],
      [
        0.8907776474952698,
        "    l = data.split(',')\n    return tuple([int(c) for c in l])"
      ],
      [
        0.8852329254150391,
        "    decoded_substrings = encoded_string.split('_')\n    return tuple(decoded_substrings)"
      ],
      [
        0.8842546343803406,
        "    result_tuple = (input_string, input_list)\n    return result_tuple"
      ],
      [
        0.8837692737579346,
        "    if type(tup) != tuple:\n        return 'Error: Not a tuple.'"
      ],
      [
        0.8833184242248535,
        "    if not my_tuple:\n        return 'Error: Tuple is empty!'"
      ],
      [
        0.8818891048431396,
        "        if tuple is None:\n            return 'Error: Input is NULL'"
      ],
      [
        0.8804237842559814,
        "    givenstring = givenstring[1:-1]\n    a = givenstring.split('),(')\n    result = []\n    for i in a:\n        b = list(map(int, i.split(',')))\n        result.append((b[0], b[-1]))\n    return result"
      ],
      [
        0.8798706531524658,
        "    if not input_tuple:\n        return 'Error: input is NULL or empty.'\n    str_list = []\n    for element in input_tuple:\n        if not isinstance(element, float):\n            return 'Error: all elements in the tuple should be floats.'\n        str_list.append(str(element))\n    result = '; '.join(str_list)\n    return result"
      ],
      [
        0.8780602216720581,
        "    if not tup:\n        return 'Error: Input tuple is empty'"
      ]
    ],
    "MBPP/300": [
      [
        0.894234836101532,
        "    least_bit = num & -num\n    small_num = num + least_bit\n    num = num ^ small_num\n    num = num >> 2\n    small_num = small_num | num\n    return small_num"
      ],
      [
        0.8854205012321472,
        "    for i in range(32):\n        if set_count <= 0:\n            break\n        if num2 & 1 << i:\n            x |= 1 << i\n            set_count -= 1"
      ],
      [
        0.8848912715911865,
        "    while num > mask:\n        mask = mask << 1 | 1"
      ],
      [
        0.8844310641288757,
        "            if carry == 0:\n                result |= 1 << i\n            else:\n                carry = 1"
      ],
      [
        0.8836376667022705,
        "            if carry == 1:\n                result |= 1 << i\n            else:\n                carry = 1"
      ],
      [
        0.8824334144592285,
        "    binary = bin(num)\n    binary = binary[2:]\n    reversed_binary = binary[::-1]\n    return reversed_binary + '1'"
      ],
      [
        0.8822283148765564,
        "        if not bit_vector & 1 << i:\n            return i + 1"
      ],
      [
        0.8806533813476562,
        "    mask = 1\n    while num > mask:\n        mask = mask << 1 | 1\n    return num ^ mask"
      ],
      [
        0.8798533082008362,
        "    return integer & ~(integer - 1)"
      ],
      [
        0.8798494338989258,
        "    set_count = bin(num2).count('1')\n    x = 0\n    for i in range(32):\n        if set_count <= 0:\n            break\n        if num2 & 1 << i:\n            x |= 1 << i\n            set_count -= 1\n    return x ^ num1"
      ]
    ],
    "MBPP/301": [
      [
        0.8953503370285034,
        "    volume = math.pi * radius ** 2 * height\n    return volume"
      ],
      [
        0.8932390809059143,
        "    return 1 / 3 * math.pi * cone['radius'] ** 2 * cone['height']"
      ],
      [
        0.8888678550720215,
        "    base_area = math.pi * base_radius ** 2\n    top_area = math.pi * top_radius ** 2\n    average_radius = (base_radius + top_radius) / 2\n    volume = 1 / 3 * math.pi * height * (base_area + top_area + math.sqrt(base_area * top_area))\n    return volume"
      ],
      [
        0.8849292993545532,
        "    for cone in cones:\n        cone = fix_dict(cone)\n        cone['volume'] = calc_cone_volume(cone)"
      ],
      [
        0.8823152780532837,
        "    step = 0.001\n    volume = 0\n    for x in range(int(radius * 1000)):\n        height = math.sqrt(radius ** 2 - (x / 1000) ** 2)\n        area = math.pi * (x / 1000) ** 2\n        volume += area * step\n    return round(volume)"
      ],
      [
        0.8808399438858032,
        "    volume = 4 / 3 * 3.142 * radius ** 3\n    return round(volume, 2)"
      ],
      [
        0.8806363344192505,
        "    if r <= 0 or h <= 0:\n        return 'Invalid input: Radius and height must be greater than zero.'\n    l = math.sqrt(math.pow(r, 2) + math.pow(h, 2))\n    lsa = math.pi * r * l\n    volume = 1 / 3 * math.pi * math.pow(r, 2) * h\n    return (round(lsa, 2), round(volume, 2))"
      ]
    ],
    "MBPP/302": [
      [
        0.9239857196807861,
        "    positive_nums = []\n    for n in lst:\n        if n > 0:\n            positive_nums.append(n)\n    return positive_nums"
      ],
      [
        0.9216195940971375,
        "    positive_integers = []\n    for num in input_list:\n        if num > 0:\n            positive_integers.append(num)\n    return positive_integers"
      ],
      [
        0.9195581674575806,
        "    positive_list = []\n    for num in input_list:\n        if num > 0:\n            positive_list.append(num)\n    positive_list.sort()\n    return positive_list"
      ],
      [
        0.9181566834449768,
        "    positive_arr = [i for i in arr if i > 0]\n    return positive_arr"
      ],
      [
        0.9151839017868042,
        "    count = 0\n    for num in nums:\n        if num > 0:\n            count += 1\n    print('Number of positive numbers:', count)"
      ],
      [
        0.9146947860717773,
        "    positive_nums = []\n    for num in nums:\n        if num > 0:\n            positive_nums.append(num)\n    return positive_nums"
      ],
      [
        0.9130035638809204,
        "    for num in input_list:\n        if num > 0:\n            positive_list.append(num)"
      ],
      [
        0.9107552170753479,
        "        if num > 0:\n            positive_list.append(num)"
      ],
      [
        0.910711407661438,
        "    input_list = [1, -2, 3, -4, 5]\n    expected_output = [1, 3, 5]\n    assert positive(input_list) == expected_output"
      ],
      [
        0.9091719388961792,
        "    result = []\n    for num in lst:\n        if num > 0:\n            result.append(num)\n    return result"
      ]
    ],
    "MBPP/303": [
      [
        0.9043250679969788,
        "    if len(arr) == 0:\n        return 0\n    return max(arr[0] + max_no_adjacent_sum(arr[2:]), max_no_adjacent_sum(arr[1:]))"
      ],
      [
        0.9035758972167969,
        "    if len(arr) == 0:\n        return 0\n    elif len(arr) == 1:\n        return arr[0]\n    else:\n        return max(arr[0] + max_non_adjacent_sum(arr[2:]), max_non_adjacent_sum(arr[1:]))"
      ],
      [
        0.9035758972167969,
        "    if len(arr) == 0:\n        return 0\n    elif len(arr) == 1:\n        return arr[0]\n    else:\n        return max(arr[0] + max_non_adjacent_sum(arr[2:]), max_non_adjacent_sum(arr[1:]))"
      ],
      [
        0.901362955570221,
        "    elif len(arr) == 1:\n        return arr[0]\n    else:\n        return max(arr[0] + max_non_adjacent_sum(arr[2:]), max_non_adjacent_sum(arr[1:]))"
      ],
      [
        0.8941925764083862,
        "    rows = len(test_array)\n    cols = len(test_array[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = test_array[0][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + test_array[0][j]\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + test_array[i][0]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + test_array[i][j]\n    max_sum = float('-inf')\n    for i in range(rows):\n        for j in range(cols):\n            if dp[i][j] > max_sum and test_array[i][j] % 2 != 0 and (dp[i][j] % 2 == 0):\n                max_sum = dp[i][j]\n    return max_sum"
      ],
      [
        0.8914965391159058,
        "    solutions = []\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            solutions.append(numbers[i] + numbers[j])\n    return max(solutions)"
      ]
    ],
    "MBPP/304": [
      [
        0.9094440937042236,
        "    max_length = 0\n    result = []\n    for word in words:\n        if len(word) % 2 == 0:\n            if len(word) > max_length:\n                max_length = len(word)\n                result = [word]\n            elif len(word) == max_length:\n                result.append(word)\n    return result"
      ],
      [
        0.9069963693618774,
        "    for word in words:\n        if len(word) % 2 == 0:\n            if len(word) > max_length:\n                max_length = len(word)\n                result = [word]\n            elif len(word) == max_length:\n                result.append(word)"
      ],
      [
        0.9065079689025879,
        "        if len(word) % 2 == 0:\n            if len(word) > max_length:\n                max_length = len(word)\n                result = [word]\n            elif len(word) == max_length:\n                result.append(word)"
      ],
      [
        0.9027483463287354,
        "    even_word_list = [word for word in word_list if len(word) % 2 == 0]\n    even_word_list.sort(key=lambda x: (-len(x), x))\n    return even_word_list"
      ]
    ],
    "MBPP/305": [
      [
        0.9235326051712036,
        "    last_index = -1\n    for idx, elem in enumerate(arr):\n        if elem == number:\n            last_index = idx\n    return last_index"
      ],
      [
        0.9194340109825134,
        "    n = len(arr)\n    last_occurrence = -1\n    for i in range(n):\n        if arr[i] == target:\n            last_occurrence = i\n    return last_occurrence"
      ],
      [
        0.9186785221099854,
        "    i = n\n    while i >= 0:\n        if x == arr[i]:\n            return i\n        i -= 1\n    return -1"
      ],
      [
        0.9183606505393982,
        "    last_index = -1\n    for i in range(len(arr)):\n        if arr[i] == num:\n            last_index = i\n    return last_index"
      ],
      [
        0.918204128742218,
        "    for i in range(len(arr) - 1, -1, -1):\n        if arr[i] == num:\n            return i\n    return -1"
      ],
      [
        0.9178721904754639,
        "    for i in range(len(arr) - 1, -1, -1):\n        if arr[i] == num:\n            return i"
      ],
      [
        0.9176520109176636,
        "    left, right = (0, len(nums) - 1)\n    last_occurrence = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            last_occurrence = mid\n            left = mid + 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return last_occurrence"
      ],
      [
        0.917064368724823,
        "    n = len(arr)\n    arr.sort()\n    for i in range(n):\n        print(arr[i], end=' ')\n    start = 0\n    end = n - 1\n    while start <= end:\n        mid = (start + end) // 2\n        if x == arr[mid]:\n            return mid\n        elif x > arr[mid]:\n            start = mid + 1\n        else:\n            end = mid - 1\n    return -1"
      ],
      [
        0.9170512557029724,
        "    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            return i\n        elif arr[i] > x:\n            return -1\n    return -1"
      ],
      [
        0.91658616065979,
        "    lower_bound = 0\n    upper_bound = len(array) - 1\n    index = -1\n    while lower_bound <= upper_bound:\n        midpoint = (lower_bound + upper_bound) // 2\n        if array[midpoint] < x:\n            lower_bound = midpoint + 1\n        elif array[midpoint] > x:\n            upper_bound = midpoint - 1\n        else:\n            index = midpoint\n            break\n    return index"
      ]
    ],
    "MBPP/306": [
      [
        0.9111336469650269,
        "    if not list_to_encode:\n        return []\n    else:\n        tmp = []\n        tmp.append(list_to_encode[0])\n        tmp.append(1)\n        i = 1\n        while i < len(list_to_encode) and list_to_encode[i] == tmp[0]:\n            tmp[1] += 1\n            i += 1\n        return tmp + encodeList(list_to_encode[i:])"
      ],
      [
        0.9111336469650269,
        "    if not list_to_encode:\n        return []\n    else:\n        tmp = []\n        tmp.append(list_to_encode[0])\n        tmp.append(1)\n        i = 1\n        while i < len(list_to_encode) and list_to_encode[i] == tmp[0]:\n            tmp[1] += 1\n            i += 1\n        return tmp + encodeList(list_to_encode[i:])"
      ],
      [
        0.8987751007080078,
        "    rle_arr = []\n    for word in arr:\n        encoded = ''\n        i = 0\n        while i < len(word):\n            count = 1\n            while i + 1 < len(word) and word[i] == word[i + 1]:\n                i += 1\n                count += 1\n            encoded += '{}{}'.format(word[i], count)\n            i += 1\n        rle_arr.append(encoded)\n    return rle_arr"
      ],
      [
        0.8985769748687744,
        "    compressed_list = []\n    count = 1\n    for index in range(1, len(original_list)):\n        if original_list[index] == original_list[index - 1]:\n            count += 1\n        else:\n            compressed_list.append(str(original_list[index - 1]) + 'x' + str(count))\n            count = 1\n    compressed_list.append(str(original_list[index]) + 'x' + str(count))\n    return compressed_list"
      ],
      [
        0.8961231112480164,
        "    encoded_sequence = []\n    prev = None\n    count = 0\n    for num in sequence:\n        if prev is None:\n            prev = num\n            count = 1\n        elif num == prev:\n            count += 1\n        else:\n            encoded_sequence.append((prev, count))\n            prev = num\n            count = 1\n    encoded_sequence.append((prev, count))\n    return encoded_sequence"
      ],
      [
        0.8947285413742065,
        "    for index in range(1, len(original_list)):\n        if original_list[index] == original_list[index - 1]:\n            count += 1\n        else:\n            compressed_list.append(str(original_list[index - 1]) + 'x' + str(count))\n            count = 1"
      ],
      [
        0.8937875032424927,
        "        while i < len(list_to_encode) and list_to_encode[i] == tmp[0]:\n            tmp[1] += 1\n            i += 1"
      ],
      [
        0.8927516341209412,
        "        elif num == prev:\n            count += 1\n        else:\n            encoded_sequence.append((prev, count))\n            prev = num\n            count = 1"
      ],
      [
        0.8927125930786133,
        "        if original_list[index] == original_list[index - 1]:\n            count += 1\n        else:\n            compressed_list.append(str(original_list[index - 1]) + 'x' + str(count))\n            count = 1"
      ],
      [
        0.8926655054092407,
        "    for word in arr:\n        encoded = ''\n        i = 0\n        while i < len(word):\n            count = 1\n            while i + 1 < len(word) and word[i] == word[i + 1]:\n                i += 1\n                count += 1\n            encoded += '{}{}'.format(word[i], count)\n            i += 1\n        rle_arr.append(encoded)"
      ]
    ],
    "MBPP/307": [
      [
        0.8892291784286499,
        "    for cuboid in cuboids:\n        cuboid.sort()\n    cuboids.sort(reverse=True)\n    dp = [0] * len(cuboids)\n    for i in range(len(cuboids)):\n        dp[i] = cuboids[i][2]\n        for j in range(i):\n            if cuboids[i][0] <= cuboids[j][0] and cuboids[i][1] <= cuboids[j][1] and (cuboids[i][2] <= cuboids[j][2]):\n                dp[i] = max(dp[i], dp[j] + cuboids[i][2])\n    return max(dp)"
      ],
      [
        0.887913703918457,
        "    cuboids = [sorted(cuboid) for cuboid in cuboids]\n    cuboids.sort()\n    n = len(cuboids)\n    dp = [0] * n\n    ans = 0\n    for i, cuboid in enumerate(cuboids):\n        dp[i] = cuboid[2]\n        for j in range(i):\n            if all((cuboids[j][k] <= cuboid[k] for k in range(3))):\n                dp[i] = max(dp[i], dp[j] + cuboid[2])\n        ans = max(ans, dp[i])\n    return ans"
      ],
      [
        0.8879114389419556,
        "    cuboids = [sorted(cuboid) for cuboid in cuboids]\n    cuboids.sort()\n    n = len(cuboids)\n    dp = [0] * n\n    ans = 0\n    for i, cuboid in enumerate(cuboids):\n        dp[i] = cuboid[2]\n        for j in range(i):\n            if all((cuboids[j][k] <= cuboid[k] for k in range(3))):\n                dp[i] = max(dp[i], dp[j] + cuboid[2])\n        ans = max(ans, dp[i])\n    return ans"
      ],
      [
        0.8819690346717834,
        "    volume_one_cuboid = length * breadth * height\n    combined_volume = volume_one_cuboid * number_of_cuboids\n    return combined_volume"
      ],
      [
        0.8819513320922852,
        "    volume = side ** 2 * height / 3\n    return volume"
      ],
      [
        0.8810411691665649,
        "        for j in range(i, num_of_cubes):\n            curr_area = i * j\n            max_area = max(max_area, curr_area)"
      ],
      [
        0.8797812461853027,
        "    max_sum = -np.inf\n    for i in range(arr.shape[0]):\n        for j in range(arr.shape[1]):\n            for k in range(arr.shape[2]):\n                for x in range(i, arr.shape[0]):\n                    for y in range(j, arr.shape[1]):\n                        for z in range(k, arr.shape[2]):\n                            subarray = arr[i:x + 1, j:y + 1, k:z + 1]\n                            curr_sum = np.sum(subarray)\n                            max_sum = max(max_sum, curr_sum)\n    return max_sum"
      ],
      [
        0.8795156478881836,
        "    for i in range(len(cuboids)):\n        dp[i] = cuboids[i][2]\n        for j in range(i):\n            if cuboids[i][0] <= cuboids[j][0] and cuboids[i][1] <= cuboids[j][1] and (cuboids[i][2] <= cuboids[j][2]):\n                dp[i] = max(dp[i], dp[j] + cuboids[i][2])"
      ]
    ],
    "MBPP/308": [
      [
        0.9219121932983398,
        "    if not isinstance(input_string, str):\n        raise TypeError('Input should be of string type.')\n    five_letter_substrings = re.findall('\\\\b[a-z]{5}\\\\b', input_string)\n    return five_letter_substrings"
      ],
      [
        0.9179354310035706,
        "    words = sentence.split()\n    output_words = []\n    for word in words:\n        if len(word) == 5:\n            output_words.append(word)\n    return output_words"
      ],
      [
        0.9155082702636719,
        "    words = text.split()\n    five_letter_words = [word for word in words if len(word) == 5]\n    unique_words = list(set(five_letter_words))\n    return unique_words"
      ],
      [
        0.9154930114746094,
        "    words = text.split()\n    five_letter_words = [word for word in words if len(word) == 5]\n    unique_words = list(set(five_letter_words))\n    return unique_words"
      ],
      [
        0.915280818939209,
        "    counter = 0\n    for word in sentence.split():\n        if len(word) == 5:\n            counter += 1\n    return counter"
      ],
      [
        0.9134427309036255,
        "    new_words = []\n    for word in words:\n        if len(word) == 5:\n            new_words.append(word)\n    return new_words"
      ],
      [
        0.9085899591445923,
        "    for word in sentence.split():\n        if len(word) == 5:\n            counter += 1"
      ],
      [
        0.9084779620170593,
        "    for word in words:\n        if len(word) == 5:\n            new_words.append(word)"
      ],
      [
        0.907443642616272,
        "    words = input_string.split()\n    result = [word for word in words if len(word) >= 5]\n    return result"
      ],
      [
        0.9060120582580566,
        "        if len(word) == 5:\n            counter += 1"
      ]
    ],
    "MBPP/309": [
      [
        0.9374189376831055,
        "    sum_of_squares = sum((i ** 2 for i in range(1, n + 1)))\n    square_of_sum = sum(range(1, n + 1)) ** 2\n    return square_of_sum - sum_of_squares"
      ],
      [
        0.9318081140518188,
        "    sum_of_squares = 0\n    square_of_sum = 0\n    for i in range(1, n + 1):\n        sum_of_squares += i * i\n    for i in range(1, n + 1):\n        square_of_sum += i\n    square_of_sum *= square_of_sum\n    return square_of_sum - sum_of_squares"
      ],
      [
        0.9202255010604858,
        "    sum_squares = 0\n    for i in range(1, n + 1):\n        sum_squares += i ** 2\n    return sum_squares"
      ],
      [
        0.9180890321731567,
        "    squares = [i * i for i in range(1, n + 1)]\n    return sum(squares)"
      ],
      [
        0.9159029722213745,
        "    return sum([i ** 2 for i in range(n)])"
      ],
      [
        0.9142385721206665,
        "    return sum([i ** 2 for i in range(1, n + 1)])"
      ],
      [
        0.9142077565193176,
        "    return sum([i ** 2 for i in range(1, n + 1)])"
      ],
      [
        0.9133290648460388,
        "    if not isinstance(n, int) or n < 1:\n        return 'Error: Input should be a natural number.'\n    sum_of_cubes = sum([i ** 3 for i in range(1, n + 1)])\n    sum_of_numbers = sum([i for i in range(1, n + 1)])\n    return sum_of_cubes - sum_of_numbers"
      ],
      [
        0.9128888249397278,
        "    s = 0\n    for i in range(1, n + 1):\n        s += i ** 2\n    return s"
      ],
      [
        0.9122418165206909,
        "    sum = 0\n    for i in range(1, n + 1):\n        sum += i ** 2\n    return sum"
      ]
    ],
    "MBPP/310": [
      [
        0.8743110299110413,
        "    binary_number = []\n    while decimal_number > 0:\n        binary_number.append(decimal_number % 2)\n        decimal_number = decimal_number // 2\n    binary_list = binary_number[::-1]\n    binary = int(''.join(map(str, binary_list)))\n    print(binary)"
      ],
      [
        0.8731635808944702,
        "    if n in memo:\n        num = memo[n]\n        return (num, 'Even' if num % 10 % 2 == 0 else 'Odd')"
      ],
      [
        0.8720459938049316,
        "    number_py = '{}'.format(number)\n    print('The Python equivalent of {} is {}'.format(number, number_py))"
      ],
      [
        0.8717199563980103,
        "    if number == 0 or number == 1:\n        return number"
      ],
      [
        0.8710536360740662,
        "    index = math.ceil((math.sqrt(8 * math.pow(10, n - 1) + 1) - 1) / 2)\n    triang_num = index * (index + 1) // 2\n    return (index, triang_num)"
      ],
      [
        0.8705670833587646,
        "    elif 9 <= number < 20:\n        return number * 2\n    else:\n        return number / 2"
      ],
      [
        0.8704663515090942,
        "    if num < 4:\n        return num\n    else:\n        return remainder(num - 4)"
      ],
      [
        0.8704663515090942,
        "    if num < 4:\n        return num\n    else:\n        return remainder(num - 4)"
      ],
      [
        0.8693276643753052,
        "    return findNthPolite(n)"
      ],
      [
        0.8692986369132996,
        "    return number % 10"
      ]
    ],
    "MBPP/311": [
      [
        0.9151965975761414,
        "    smallest_value = min(valores)\n    indices = [index for index, value in enumerate(valores) if value == smallest_value]\n    return indices"
      ],
      [
        0.9112508296966553,
        "    smallest_number = array[0]\n    smallest_indices = []\n    for i in range(len(array)):\n        if array[i] < smallest_number:\n            smallest_number = array[i]\n            smallest_indices = [i]\n        elif array[i] == smallest_number:\n            smallest_indices.append(i)\n    return smallest_indices"
      ],
      [
        0.904434323310852,
        "    min_num = lst[0]\n    min_index = [0]\n    for i in range(1, len(lst)):\n        if lst[i] < min_num:\n            min_num = lst[i]\n            min_index = [i]\n        elif lst[i] == min_num:\n            min_index.append(i)\n    return (min_num, min_index)"
      ],
      [
        0.9044251441955566,
        "    min_num = lst[0]\n    min_index = [0]\n    for i in range(1, len(lst)):\n        if lst[i] < min_num:\n            min_num = lst[i]\n            min_index = [i]\n        elif lst[i] == min_num:\n            min_index.append(i)\n    return (min_num, min_index)"
      ],
      [
        0.901186466217041,
        "    minimum = min(list_of_nums)\n    return list_of_nums.index(minimum)"
      ],
      [
        0.8967891335487366,
        "            if arr:\n                return arr.index(min(arr))\n            else:\n                return -1"
      ],
      [
        0.8955212831497192,
        "    if len(arr) == 0:\n        return (None, [])\n    min_element = arr[0]\n    indices = [0]\n    for i in range(1, len(arr)):\n        if arr[i] < min_element:\n            min_element = arr[i]\n            indices = [i]\n        elif arr[i] == min_element:\n            indices.append(i)\n    return (min_element, indices)"
      ],
      [
        0.8941119909286499,
        "    min_index = 0\n    for index, num in enumerate(lst):\n        if num < lst[min_index]:\n            min_index = index\n    return min_index"
      ],
      [
        0.8939988613128662,
        "    for i in range(1, len(lst)):\n        if lst[i] < min_num:\n            min_num = lst[i]\n            min_index = [i]\n        elif lst[i] == min_num:\n            min_index.append(i)"
      ],
      [
        0.8939705491065979,
        "    for i in range(1, len(lst)):\n        if lst[i] < min_num:\n            min_num = lst[i]\n            min_index = [i]\n        elif lst[i] == min_num:\n            min_index.append(i)"
      ]
    ],
    "MBPP/312": [
      [
        0.9162280559539795,
        "    positives = []\n    negatives = []\n    for x in arr:\n        if x < 0:\n            negatives.append(x)\n        else:\n            positives.append(x)\n    return positives + negatives"
      ],
      [
        0.9143736362457275,
        "    negative_nums = []\n    positive_nums = []\n    for num in array:\n        if num < 0:\n            negative_nums.append(num)\n        else:\n            positive_nums.append(num)\n    return negative_nums + positive_nums"
      ],
      [
        0.9102942943572998,
        "    negative_index = 0\n    for num in arr:\n        if num < 0:\n            temp = arr[negative_index]\n            arr[negative_index] = num\n            arr[arr.index(num)] = temp\n            negative_index += 1\n    return arr"
      ],
      [
        0.9096435904502869,
        "    n = len(input_array)\n    positive_array = []\n    negative_array = []\n    for i in range(n):\n        if input_array[i] < 0:\n            negative_array.append(input_array[i])\n        else:\n            positive_array.append(input_array[i])\n    negative_array = sorted(negative_array)[::-1]\n    positive_array = sorted(positive_array)\n    output_array = []\n    for i in range(len(positive_array)):\n        output_array.append(negative_array[i])\n        output_array.append(positive_array[i])\n    return output_array"
      ],
      [
        0.9089261293411255,
        "    arr.sort()\n    newArr = []\n    start = 0\n    end = len(arr) - 1\n    while start <= end:\n        if arr[start] < 0:\n            newArr.append(arr[start])\n            start += 1\n        else:\n            newArr.append(arr[end])\n            end -= 1\n    return newArr"
      ],
      [
        0.9085788726806641,
        "    positive = []\n    negative = []\n    for num in arr:\n        if num >= 0:\n            positive.append(num)\n        else:\n            negative.append(num)\n    reordered_array = negative + positive\n    difference = sum(positive) - sum(list(map(abs, negative)))\n    return (reordered_array, difference)"
      ],
      [
        0.9045096039772034,
        "    for num in arr:\n        if num < 0:\n            temp = arr[negative_index]\n            arr[negative_index] = num\n            arr[arr.index(num)] = temp\n            negative_index += 1"
      ],
      [
        0.9042820930480957,
        "    negs_and_zeros = [x for x in arr if x <= 0]\n    positives = [x for x in arr if x > 0]\n    if not positives:\n        return 'Cannot reverse the order of the given integers'\n    pos_counter = len(positives) - 1\n    output_arr = []\n    for x in arr:\n        if x > 0:\n            output_arr.append(positives[pos_counter])\n            pos_counter -= 1\n        else:\n            output_arr.append(x)\n    return output_arr"
      ],
      [
        0.9034132957458496,
        "    positive_list = []\n    negative_list = []\n    for num in numbers:\n        if num < 0:\n            negative_list.append(num)\n        else:\n            positive_list.append(num)\n    return positive_list + negative_list"
      ],
      [
        0.9025518894195557,
        "    j = -1\n    for i in range(len(arr)):\n        if arr[i] < 0:\n            j += 1\n            arr[i], arr[j] = (arr[j], arr[i])\n    return arr"
      ]
    ],
    "MBPP/313": [
      [
        0.8961158394813538,
        "    odd_indices_elements = tpl[1::2]\n    even_elements = list(filter(lambda x: x % 2 == 0, odd_indices_elements))\n    return sum(even_elements)"
      ],
      [
        0.8882273435592651,
        "    total = 0\n    for i in tuples:\n        if isinstance(i, tuple):\n            total += cumul_sum(i)\n        elif isinstance(i, (int, float)):\n            total += i\n        elif isinstance(i, complex):\n            total += i.real\n    return total"
      ],
      [
        0.8852452039718628,
        "    total = 0\n    for t in tuples:\n        total += sum(t)\n    return total"
      ],
      [
        0.8847355842590332,
        "    total_sum = 0\n    for lst in args:\n        if not isinstance(lst, list):\n            return 'Error: Input is not a list'\n        if len(lst) % 2 == 0:\n            return 'Error: List length is not odd'\n        for i in range(1, len(lst), 2):\n            total_sum += lst[i]\n    return total_sum"
      ],
      [
        0.8847249746322632,
        "    if isinstance(tup, tuple):\n        return sum(tup)"
      ],
      [
        0.8847112655639648,
        "    if isinstance(tup, tuple):\n        return sum(tup)\n    return tup"
      ],
      [
        0.8841356039047241,
        "    for i in tuples:\n        if isinstance(i, tuple):\n            total += cumul_sum(i)\n        elif isinstance(i, (int, float)):\n            total += i\n        elif isinstance(i, complex):\n            total += i.real"
      ],
      [
        0.8837227821350098,
        "    total = 0\n    for item in tuples:\n        if isinstance(item, tuple):\n            total += cumulative_sum(item)\n        elif isinstance(item, (int, float)):\n            total += item\n    return total"
      ],
      [
        0.8837196230888367,
        "    total = 0\n    for item in tuples:\n        if isinstance(item, tuple):\n            total += cumulative_sum(item)\n        elif isinstance(item, (int, float)):\n            total += item\n    return total"
      ],
      [
        0.8809247016906738,
        "    uniques = set()\n    for pair in lst:\n        uniques.update(pair)\n    total_sum = sum(uniques)\n    return total_sum"
      ]
    ],
    "MBPP/314": [
      [
        0.8979538679122925,
        "    import math\n    if n <= 0:\n        return 0\n    x = int(math.sqrt(n))\n    return 0 if x * x < n else x"
      ],
      [
        0.8979423642158508,
        "    import math\n    if n <= 0:\n        return 0\n    x = int(math.sqrt(n))\n    return 0 if x * x < n else x"
      ],
      [
        0.8968091607093811,
        "    low = 0\n    high = number\n    while low <= high:\n        mid = low + (high - low) // 2\n        mid_square = mid ** 2\n        if mid_square == number:\n            return mid\n        elif mid_square < number:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return low"
      ],
      [
        0.8953293561935425,
        "    left, right = (0, x)\n    while left <= right:\n        mid = (left + right) // 2\n        square = mid * mid\n        if square <= x:\n            left = mid + 1\n        elif square > x:\n            right = mid - 1\n    return left - 1"
      ],
      [
        0.894295334815979,
        "    root = math.sqrt(N)\n    if int(root + 0.5) ** 2 == N:\n        return int(root)\n    else:\n        return 'Error: The provided number is not a perfect square'"
      ],
      [
        0.8931659460067749,
        "        elif square > n:\n            high = mid\n        else:\n            low = mid"
      ],
      [
        0.8926758766174316,
        "    low = 0\n    high = number\n    while low <= high:\n        mid = int((low + high) / 2)\n        guess = mid * mid\n        if guess > number:\n            high = mid - 1\n        elif guess < number:\n            low = mid + 1\n        else:\n            return mid\n    return 'Square root of the number is not an integer.'"
      ],
      [
        0.8922221660614014,
        "    left = 0\n    right = number\n    epsilon = 1e-05\n    while right - left > epsilon:\n        mid = (left + right) / 2\n        if mid * mid < number:\n            left = mid\n        else:\n            right = mid\n    return left"
      ],
      [
        0.8921483159065247,
        "    squares = []\n    for i in range(int(math.sqrt(target))):\n        squares.append(i * i)\n    return squares"
      ],
      [
        0.8919885158538818,
        "    low = 0\n    high = number\n    while low <= high:\n        mid = (low + high) // 2\n        mid_squared = mid * mid\n        if mid_squared == number:\n            return mid\n        elif mid_squared < number:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False"
      ]
    ],
    "MBPP/315": [
      [
        0.9399528503417969,
        "    counts = {}\n    max_count = 0\n    most_common = ''\n    for string in strings:\n        if string in counts:\n            counts[string] += 1\n        else:\n            counts[string] = 1\n        if counts[string] > max_count:\n            max_count = counts[string]\n            most_common = string\n    return most_common"
      ],
      [
        0.9344704151153564,
        "    str_freq_map = defaultdict(int)\n    for string in strings:\n        str_freq_map[string] += 1\n    max_count = 0\n    for key, value in str_freq_map.items():\n        if value > max_count:\n            max_count = value\n    max_strings = []\n    for key, value in str_freq_map.items():\n        if value == max_count:\n            max_strings.append(key)\n    return max_strings"
      ],
      [
        0.9338503479957581,
        "    frequency = {}\n    for string in strings:\n        string = string.strip().lower()\n        frequency[string] = frequency.get(string, 0) + 1\n    max_frequency = max(frequency.values())\n    most_frequent = [string for string, freq in frequency.items() if freq == max_frequency]\n    return most_frequent"
      ],
      [
        0.929656982421875,
        "    string_list = string.split()\n    word_dict = {}\n    for word in string_list:\n        word_dict[word] = word_dict.get(word, 0) + 1\n    max_count = 0\n    most_common_word = None\n    for word, count in word_dict.items():\n        if count > max_count:\n            max_count = count\n            most_common_word = word\n    return most_common_word"
      ],
      [
        0.9296181797981262,
        "    count_map = {}\n    for word in word_list:\n        if word in count_map:\n            count_map[word] += 1\n        else:\n            count_map[word] = 1\n    most_common = None\n    max_count = 0\n    for word, count in count_map.items():\n        if count > max_count:\n            most_common = word\n            max_count = count\n    return most_common"
      ],
      [
        0.9288218021392822,
        "    occur_dict = {}\n    for word in array:\n        if word in occur_dict:\n            occur_dict[word] += 1\n        else:\n            occur_dict[word] = 1\n    most_frequent = max(occur_dict, key=lambda key: occur_dict[key])\n    return most_frequent"
      ],
      [
        0.928709864616394,
        "    char_count = {}\n    max_char = ''\n    max_count = 0\n    for string in strings:\n        for char in string:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n            if char_count[char] > max_count:\n                max_count = char_count[char]\n                max_char = char\n    return max_char"
      ],
      [
        0.9281851053237915,
        "    frequency_counter = Counter(strings)\n    max_frequency = max(frequency_counter.values())\n    most_frequent_strings = [string for string, frequency in frequency_counter.items() if frequency == max_frequency]\n    return most_frequent_strings"
      ],
      [
        0.9281601309776306,
        "    max_count = 0\n    frequent_string = ''\n    for i in my_list:\n        if my_list.count(i) > max_count:\n            max_count = my_list.count(i)\n            frequent_string = i\n    return frequent_string"
      ],
      [
        0.9279617667198181,
        "    word_count = {}\n    for word in words:\n        if word in word_count:\n            word_count[word] += 1\n        else:\n            word_count[word] = 1\n    most_common_word = ''\n    most_common_word_count = 0\n    for word, count in word_count.items():\n        if count > most_common_word_count:\n            most_common_word_count = count\n            most_common_word = word\n    return most_common_word"
      ]
    ],
    "MBPP/316": [
      [
        0.9217894077301025,
        "    if side1 == side2 or side1 == side3 or side2 == side3:\n        print('Isosceles triangle')\n        return"
      ],
      [
        0.9141618013381958,
        "        elif a == b or b == c or c == a:\n            triangle_type = 'Isosceles'\n        else:\n            triangle_type = 'Scalene'"
      ],
      [
        0.9136861562728882,
        "    if side1 == side2 or side2 == side3 or side1 == side3:\n        print('Isosceles triangle')\n        perimeter = side1 + side2 + side3\n        print('Perimeter:', perimeter)\n        return"
      ],
      [
        0.9128994941711426,
        "    if a == b == c:\n        triangle_type = 'Equilateral'\n    elif a != b and b != c and (a != c):\n        triangle_type = 'Scalene'\n    else:\n        triangle_type = 'Isosceles'"
      ],
      [
        0.9116708636283875,
        "    elif a == b or b == c or a == c:\n        return 'Isosceles triangle'\n    else:\n        return 'Scalene triangle'"
      ],
      [
        0.9113380908966064,
        "    elif a != b and b != c and (a != c):\n        triangle_type = 'Scalene'\n    else:\n        triangle_type = 'Isosceles'"
      ],
      [
        0.9113006591796875,
        "        elif a != b != c != a:\n            return 'Scalene triangle'\n        else:\n            return 'Isosceles triangle'"
      ],
      [
        0.9096251130104065,
        "    elif A == B or B == C or A == C:\n        return 'Isosceles Triangle'\n    else:\n        return 'Scalene Triangle'"
      ],
      [
        0.9094160199165344,
        "    elif x == y or y == z or x == z:\n        return 'Isosceles Triangle'\n    else:\n        return 'Scalene Triangle'"
      ],
      [
        0.9066342115402222,
        "    elif side1 == side2 or side2 == side3 or side1 == side3:\n        triangle_type = 'isosceles'\n    else:\n        triangle_type = 'scalene'"
      ]
    ],
    "MBPP/317": [
      [
        0.9152937531471252,
        "    d = deque(l)\n    d.rotate(n)\n    return list(d)"
      ],
      [
        0.9145890474319458,
        "    d = deque(l)\n    d.rotate(-n)\n    return list(d)"
      ],
      [
        0.9047300815582275,
        "    rotated_list = my_list[n:] + my_list[:n]\n    return rotated_list"
      ]
    ],
    "MBPP/318": [
      [
        0.907742977142334,
        "    negative_nums = [num for num in numbers if num < 0]\n    return (len(negative_nums), sum(negative_nums))"
      ],
      [
        0.9048395156860352,
        "    negative_elements = []\n    for x in my_list:\n        if x < 0:\n            negative_elements.append(x)\n    return negative_elements"
      ],
      [
        0.9048157930374146,
        "    neg_lst = []\n    for num in lst:\n        if num < 0:\n            neg_lst.append(num)\n    return neg_lst"
      ],
      [
        0.9015836715698242,
        "    return [num for num in int_list if num < 0]"
      ],
      [
        0.900581955909729,
        "    for number in list_of_numbers:\n        total += int(number)\n        if number < 0:\n            negative_count += 1"
      ],
      [
        0.9005563259124756,
        "    for x in my_list:\n        if x < 0:\n            negative_elements.append(x)"
      ],
      [
        0.8995165824890137,
        "    counter = 0\n    for row in arr:\n        for val in row:\n            if val < 0:\n                counter += 1\n    return counter"
      ],
      [
        0.8964903354644775,
        "    input_list = [1, -2, 3, -4, 5]\n    expected_output = [-2, -4]\n    assert negative(input_list) == expected_output"
      ],
      [
        0.8961271047592163,
        "    count = 0\n    for num in nums:\n        if num > 0:\n            count += 1\n    print('Number of positive numbers:', count)"
      ],
      [
        0.8948377370834351,
        "    count = 0\n    for num in list:\n        if num == 0:\n            count += 1\n    return count"
      ]
    ],
    "MBPP/319": [
      [
        0.9069947600364685,
        "    three_letter_words = []\n    for word in words:\n        if len(word) == 3:\n            three_letter_words.append(word)\n    return three_letter_words"
      ],
      [
        0.9043104648590088,
        "    count = 0\n    for word in words:\n        if len(word) == 3:\n            count += 1\n    print(count)"
      ],
      [
        0.9024871587753296,
        "    words = sentence.split()\n    four_char_words = [word for word in words if len(word) == 4]\n    return four_char_words"
      ],
      [
        0.8995828032493591,
        "    if not isinstance(input_string, str):\n        raise TypeError('Input should be of string type.')\n    five_letter_substrings = re.findall('\\\\b[a-z]{5}\\\\b', input_string)\n    return five_letter_substrings"
      ],
      [
        0.8994929790496826,
        "    for word in list_of_words:\n        if len(word) == 3:\n            return word"
      ],
      [
        0.8991397619247437,
        "    for word in words:\n        if len(word) == 3:\n            count += 1"
      ],
      [
        0.8991326093673706,
        "    for word in words:\n        if len(word) == 3:\n            count += 1"
      ],
      [
        0.898695707321167,
        "    words = s.split()\n    four_letter_words = []\n    for word in words:\n        if len(word) == 4:\n            four_letter_words.append(word)\n    return four_letter_words"
      ],
      [
        0.8981306552886963,
        "    words = sentence.split(' ')\n    count = 0\n    for word in words:\n        if len(word) == 3:\n            count += 1\n    return count"
      ],
      [
        0.8979859352111816,
        "    words = text.split(' ')\n    result = []\n    for w in words:\n        if len(w) == 3:\n            result.append(w)\n    return result"
      ]
    ],
    "MBPP/320": [
      [
        0.9142201542854309,
        "    binary = bin(num)[2:]\n    count = 0\n    for bit in reversed(binary):\n        if bit == '0':\n            count += 1\n        else:\n            break\n    return count"
      ],
      [
        0.913561224937439,
        "    return bin(n).count('1')"
      ],
      [
        0.9083808064460754,
        "    count = 0\n    while number > 0:\n        if number & 1:\n            count += 1\n        number >>= 1\n    return count"
      ],
      [
        0.9079480767250061,
        "    count = 0\n    while n != 0:\n        count += n & 1\n        n >>= 1\n    return count"
      ],
      [
        0.9070040583610535,
        "    count = 0\n    while n > 0:\n        if n & 1:\n            count += 1\n        n >>= 1\n    return count"
      ],
      [
        0.9058170318603516,
        "    count = 0\n    while x != 0:\n        x &= x - 1\n        count += 1\n    return count"
      ],
      [
        0.9056382179260254,
        "    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"
      ],
      [
        0.9056257009506226,
        "    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"
      ],
      [
        0.9056229591369629,
        "    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"
      ],
      [
        0.9055025577545166,
        "    count = 0\n    while n:\n        count ^= n & 1\n        n >>= 1\n    return count"
      ]
    ],
    "MBPP/321": [
      [
        0.939676821231842,
        "    frequency = {}\n    for character in string:\n        if character in frequency.keys():\n            frequency[character] += 1\n        else:\n            frequency[character] = 1\n    return frequency"
      ],
      [
        0.9390703439712524,
        "    frequency = {}\n    for character in string:\n        if character in frequency:\n            frequency[character] += 1\n        else:\n            frequency[character] = 1\n    return frequency"
      ],
      [
        0.9358752965927124,
        "    frequency = {}\n    for char in string:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency"
      ],
      [
        0.9358750581741333,
        "    frequency = {}\n    for char in string:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency"
      ],
      [
        0.935870885848999,
        "    frequency = {}\n    for char in string:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency"
      ],
      [
        0.935869574546814,
        "    frequency = {}\n    for char in string:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency"
      ],
      [
        0.9339723587036133,
        "    charCount = {}\n    for character in string:\n        if character in charCount.keys():\n            charCount[character] += 1\n        else:\n            charCount[character] = 1\n    print(charCount)"
      ],
      [
        0.9338772296905518,
        "    character_count = {}\n    for char in string:\n        if char in character_count:\n            character_count[char] += 1\n        else:\n            character_count[char] = 1\n    return character_count"
      ],
      [
        0.9338714480400085,
        "    count = {}\n    for char in string:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n    return count"
      ],
      [
        0.9338630437850952,
        "    character_count = {}\n    for char in string:\n        if char in character_count:\n            character_count[char] += 1\n        else:\n            character_count[char] = 1\n    return character_count"
      ]
    ],
    "MBPP/322": [
      [
        0.9096310138702393,
        "    sorted_list = []\n    for sub_list in three_d_list:\n        sorted_sub_list = sorted(sub_list, key=itemgetter(2))\n        sorted_list.append(sorted_sub_list)\n    return sorted_list"
      ],
      [
        0.9068228006362915,
        "    for sublist in arr:\n        sublist.sort(key=criterion)"
      ],
      [
        0.9060438275337219,
        "    for sub_list in three_d_list:\n        sorted_sub_list = sorted(sub_list, key=itemgetter(2))\n        sorted_list.append(sorted_sub_list)"
      ],
      [
        0.9058963656425476,
        "    for sublist in lists:\n        sublist.sort()"
      ],
      [
        0.9055600166320801,
        "    for sublist in lists:\n        sublist.sort()\n    lists.sort(key=lambda x: x[0])\n    return lists"
      ],
      [
        0.901868462562561,
        "    for i in range(len(sublist)):\n        for j in range(i + 1, len(sublist)):\n            if sublist[i] < sublist[j]:\n                sublist[i], sublist[j] = (sublist[j], sublist[i])"
      ],
      [
        0.8998138904571533,
        "    for sublist in arr:\n        bubble_sort(sublist)\n    arr.sort(key=lambda x: x[0])"
      ],
      [
        0.8994925618171692,
        "    myList.sort(key=lambda x: x[1])\n    print('The sorted list in ascending order is:')\n    for i in range(len(myList)):\n        print(myList[i])"
      ],
      [
        0.8987829089164734,
        "            if sublist[i] < sublist[j]:\n                sublist[i], sublist[j] = (sublist[j], sublist[i])"
      ],
      [
        0.8976512551307678,
        "    for i in range(len(sublist) - 1):\n        for j in range(len(sublist) - 1 - i):\n            if sublist[j] < sublist[j + 1]:\n                sublist[j], sublist[j + 1] = (sublist[j + 1], sublist[j])"
      ]
    ],
    "MBPP/323": [
      [
        0.9082813858985901,
        "    if a + b <= c or a + c <= b or b + c <= a:\n        return 'Not a valid triangle'\n    if a == b and b == c:\n        return 'Equilateral triangle'\n    if a != b and b != c and (a != c):\n        return 'Scalene triangle'\n    return 'Isosceles triangle'"
      ],
      [
        0.907282829284668,
        "    if a + b <= c or a + c <= b or b + c <= a:\n        return 'Not a valid triangle'"
      ],
      [
        0.9072633981704712,
        "    if a + b <= c or a + c <= b or b + c <= a:\n        return 'Not a valid triangle'"
      ],
      [
        0.9072525501251221,
        "    if a + b <= c or a + c <= b or b + c <= a:\n        return 'Not a valid triangle'"
      ],
      [
        0.9072473645210266,
        "    if a + b <= c or a + c <= b or b + c <= a:\n        return 'Not a valid triangle'"
      ],
      [
        0.9065604209899902,
        "    if side1 + side2 > side3 and side1 + side3 > side2 and (side2 + side3 > side1):\n        return True\n    else:\n        return False"
      ],
      [
        0.9065604209899902,
        "    if side1 + side2 > side3 and side1 + side3 > side2 and (side2 + side3 > side1):\n        return True\n    else:\n        return False"
      ],
      [
        0.9062168598175049,
        "    if side1 + side2 <= side3 or side1 + side3 <= side2 or side2 + side3 <= side1:\n        return 'Invalid triangle. The given sides do not satisfy the triangle inequality theorem.'"
      ],
      [
        0.905632734298706,
        "    if a + b <= c or a + c <= b or b + c <= a:\n        return 'Invalid triangle: sum of any two sides must be greater than the third side'"
      ],
      [
        0.9047684669494629,
        "    a = side1 + side2\n    b = side1 + side3\n    c = side2 + side3\n    if a > side3 and b > side2 and (c > side1):\n        return True\n    else:\n        return False"
      ]
    ],
    "MBPP/324": [
      [
        0.887149453163147,
        "    first_term = sum / (ratio ** terms - 1)\n    progression = [first_term * ratio ** n for n in range(terms)]\n    return progression"
      ],
      [
        0.8870410919189453,
        "    sum = a * (1 - r ** n) / (1 - r)\n    if 300 <= sum <= 1200:\n        print(f'The sum of the geometric progression is: {sum}.')\n        print('Terms of the geometric progression:')\n        for i in range(n):\n            term = a * r ** i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of the geometric progression is not within the valid range, but {sum}.')"
      ],
      [
        0.8860856294631958,
        "    sum = a * (1 - r ** n) / (1 - r)\n    if 300 <= sum <= 1200:\n        print(f'Sum of geometric progression: {sum}.')\n        print('Terms of geometric progression:')\n        for i in range(n):\n            term = a * r ** i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of geometric progression is not within valid range, but {sum}.')"
      ],
      [
        0.8798912763595581,
        "    sum = n * (n + 1) / 2\n    return sum"
      ],
      [
        0.8795408606529236,
        "    if 300 <= sum <= 1200:\n        print(f'Sum of geometric progression: {sum}.')\n        print('Terms of geometric progression:')\n        for i in range(n):\n            term = a * r ** i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of geometric progression is not within valid range, but {sum}.')"
      ],
      [
        0.8792863488197327,
        "    sum = n * (n + 1) // 2\n    return sum"
      ],
      [
        0.8792717456817627,
        "    sum = n * (n + 1) // 2\n    return sum"
      ],
      [
        0.8790835738182068,
        "    if 300 <= sum <= 1200:\n        print(f'The sum of the geometric progression is: {sum}.')\n        print('Terms of the geometric progression:')\n        for i in range(n):\n            term = a * r ** i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of the geometric progression is not within the valid range, but {sum}.')"
      ]
    ],
    "MBPP/325": [
      [
        0.9054312109947205,
        "        elif day > 28:\n            return 'No'"
      ],
      [
        0.901270866394043,
        "    elif month == 'April' or month == 'June' or month == 'September' or (month == 'November'):\n        return '30 days'\n    elif month == 'February':\n        return '28 or 29 days'\n    else:\n        return 'Invalid input'"
      ],
      [
        0.900823712348938,
        "    elif month == 'February':\n        return '28 or 29 days'\n    else:\n        return 'Invalid input'"
      ],
      [
        0.8989176750183105,
        "    if month < 1 or month > 12:\n        return 'No'"
      ],
      [
        0.8982325792312622,
        "    if month == 'January' or month == 'March' or month == 'May' or (month == 'July') or (month == 'August') or (month == 'October') or (month == 'December'):\n        return '31 days'\n    elif month == 'April' or month == 'June' or month == 'September' or (month == 'November'):\n        return '30 days'\n    elif month == 'February':\n        return '28 or 29 days'\n    else:\n        return 'Invalid input'"
      ],
      [
        0.8982325792312622,
        "    if month == 'January' or month == 'March' or month == 'May' or (month == 'July') or (month == 'August') or (month == 'October') or (month == 'December'):\n        return '31 days'\n    elif month == 'April' or month == 'June' or month == 'September' or (month == 'November'):\n        return '30 days'\n    elif month == 'February':\n        return '28 or 29 days'\n    else:\n        return 'Invalid input'"
      ],
      [
        0.8966712951660156,
        "    thirty_days_months = [4, 6, 9, 11]\n    if month in thirty_days_months:\n        return True\n    elif month == 2:\n        if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            return False\n        else:\n            return True\n    else:\n        return False"
      ],
      [
        0.8950591087341309,
        "    if month in thirty_days_months:\n        return True\n    elif month == 2:\n        if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            return False\n        else:\n            return True\n    else:\n        return False"
      ],
      [
        0.8950203657150269,
        "    elif month_name == 'february':\n        print('Valid month name')\n    elif month_name == 'march':\n        print('Valid month name')\n    elif month_name == 'april':\n        print('Valid month name')\n    elif month_name == 'may':\n        print('Valid month name')\n    elif month_name == 'june':\n        print('Valid month name')\n    elif month_name == 'july':\n        print('Valid month name')\n    elif month_name == 'august':\n        print('Valid month name')\n    elif month_name == 'september':\n        print('Valid month name')\n    elif month_name == 'october':\n        print('Valid month name')\n    elif month_name == 'november':\n        print('Valid month name')\n    elif month_name == 'december':\n        print('Valid month name')\n    elif month_name == 'ramadan':\n        print('Valid month name')\n    elif month_name == 'tishrei':\n        print('Valid month name')\n    else:\n        print('Invalid month name')"
      ],
      [
        0.8948881030082703,
        "    elif month_name == 'december':\n        print('Valid month name')\n    elif month_name == 'ramadan':\n        print('Valid month name')\n    elif month_name == 'tishrei':\n        print('Valid month name')\n    else:\n        print('Invalid month name')"
      ]
    ],
    "MBPP/326": [
      [
        0.8962345719337463,
        "    return word.endswith(letter)"
      ],
      [
        0.8931328058242798,
        "    for char in string.punctuation:\n        if word.endswith(char):\n            word = word[:-1]\n            punct_end = char"
      ],
      [
        0.8907458782196045,
        "    if s.endswith('. ' + word[::-1]):\n        s = s[:len(s) - (len(word) + 2)] + '. ' + word[0].upper() + word[1:len(word)][::-1]"
      ],
      [
        0.890393853187561,
        "        if word.endswith(char):\n            word = word[:-1]\n            punct_end = char"
      ],
      [
        0.8857123255729675,
        "    words = sentence.split()\n    last_word = words[-1]\n    return last_word"
      ],
      [
        0.8855892419815063,
        "    text = text.replace(' ', '')\n    lexical_units = re.findall('\\\\w+|[^\\\\w\\\\s]', text)\n    last_three_units = lexical_units[-3:]\n    end_pattern = ''.join(last_three_units)\n    return end_pattern"
      ],
      [
        0.8846853971481323,
        "            if specific_endings.fullmatch(word):\n                specific_end.append(word)"
      ],
      [
        0.8834476470947266,
        "        if not word[-1].isalpha():\n            punc = word[-1]\n            word = word[:-1]"
      ],
      [
        0.8834319710731506,
        "        if word[-1] in '!.?,;:':\n            punctuation = word[-1]\n            word = word[:-1]"
      ],
      [
        0.8829079270362854,
        "    words = sentence.split()\n    return words[-1]"
      ]
    ],
    "MBPP/327": [
      [
        0.9106730222702026,
        "            if substr[0] == substr[-1]:\n                count += 1"
      ],
      [
        0.9092268943786621,
        "    count = 0\n    for s in lst:\n        if len(s) >= 2 and s[0] == s[-1]:\n            count += 1\n    return count"
      ],
      [
        0.9068357348442078,
        "    for s in lst:\n        if len(s) >= 2 and s[0] == s[-1]:\n            count += 1"
      ],
      [
        0.9063618183135986,
        "    count = 0\n    for i in range(len(input_str)):\n        for j in range(i + 1, len(input_str) + 1):\n            substr = input_str[i:j]\n            if substr[0] == substr[-1]:\n                count += 1\n    return count"
      ],
      [
        0.9037280678749084,
        "    for i in range(len(input_str)):\n        for j in range(i + 1, len(input_str) + 1):\n            substr = input_str[i:j]\n            if substr[0] == substr[-1]:\n                count += 1"
      ]
    ],
    "MBPP/328": [
      [
        0.891208827495575,
        "    max_num = arr[0]\n    n = len(arr)\n    for i in range(1, n):\n        if arr[i] > max_num:\n            max_num = arr[i]\n    div_num = 1\n    for i in range(2, max_num + 1):\n        div_flag = True\n        for j in range(n):\n            if arr[j] % i != 0:\n                div_flag = False\n        if div_flag:\n            div_num = i\n    return div_num"
      ],
      [
        0.8903428316116333,
        "    n = len(nums)\n    if n < 2:\n        return nums[0]\n    max_div = 0\n    for i in range(n - 1):\n        num = nums[i]\n        for j in range(i + 1, n):\n            if num % nums[j] == 0 and nums[j] > max_div:\n                max_div = nums[j]\n                break\n    return max_div"
      ]
    ],
    "MBPP/329": [
      [
        0.911083459854126,
        "    if len(arr) < 3:\n        return sum(arr)\n    smallest_nums = [float('inf')] * 3\n    for num in arr:\n        if num < smallest_nums[2]:\n            smallest_nums = sorted(smallest_nums[:-1] + [num])\n    return sum(smallest_nums)"
      ],
      [
        0.9083112478256226,
        "    numbers.sort(reverse=True)\n    return sum(numbers[:3])"
      ],
      [
        0.9019894599914551,
        "    unique_numbers = set()\n    counts = {}\n    for num in lst:\n        if num not in unique_numbers:\n            unique_numbers.add(num)\n            counts[num] = 1\n        else:\n            counts[num] += 1\n    sum = 0\n    count = 0\n    for num in lst:\n        if num in unique_numbers and counts[num] > 0:\n            sum += num\n            counts[num] -= 1\n            count += 1\n            if count == 3:\n                break\n    return sum"
      ],
      [
        0.9010679721832275,
        "        if sum(three_smallest) < min_sum:\n            min_sum = sum(three_smallest)\n            min_elements = three_smallest\n            min_list = lst"
      ],
      [
        0.9007588028907776,
        "    for lst in lsts:\n        three_smallest = find_three_smallest(lst)\n        if sum(three_smallest) < min_sum:\n            min_sum = sum(three_smallest)\n            min_elements = three_smallest\n            min_list = lst"
      ],
      [
        0.8999713063240051,
        "    sequence.sort(reverse=True)\n    sum_of_largest = sum(sequence[:3])\n    return sum_of_largest"
      ],
      [
        0.8987894058227539,
        "    numbers = [num for num in numbers if num >= 0]\n    numbers.sort(reverse=True)\n    largest_sum = 0\n    largest_numbers = []\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            for k in range(j + 1, len(numbers)):\n                current_sum = numbers[i] + numbers[j] + numbers[k]\n                if current_sum > largest_sum:\n                    largest_sum = current_sum\n                    largest_numbers = [numbers[i], numbers[j], numbers[k]]\n    return largest_numbers"
      ],
      [
        0.8985854387283325,
        "    prime_numbers = []\n    for num in lst:\n        if is_prime(num):\n            prime_numbers.append(num)\n            if len(prime_numbers) == 3:\n                break\n    return sum(prime_numbers)"
      ],
      [
        0.8984644412994385,
        "    lowest_sum = numbers[0] + numbers[1]\n    for i in range(len(numbers) - 1):\n        for j in range(i + 1, len(numbers)):\n            current_sum = numbers[i] + numbers[j]\n            if current_sum < lowest_sum:\n                lowest_sum = current_sum\n    return lowest_sum"
      ],
      [
        0.8959980607032776,
        "    min_list = []\n    min_values = [float('inf')] * 3\n    for n1, n2, n3 in zip(numbers1, numbers2, numbers3):\n        min_values[0] = min(min_values[0], n1)\n        min_values[1] = min(min_values[1], n2)\n        min_values[2] = min(min_values[2], n3)\n        min_list.append(min(min_values))\n    return min_list"
      ]
    ],
    "MBPP/330": [
      [
        0.8885668516159058,
        "    tuple_order = sorted(tuples, key=lambda x: x[1])\n    return tuple_order"
      ]
    ],
    "MBPP/331": [
      [
        0.9049253463745117,
        "    sets = [set(arr) for arr in arrays]\n    common_elements = set.intersection(*sets)\n    return sorted(common_elements)"
      ],
      [
        0.9025726914405823,
        "    if not arrays:\n        return []\n    intersection = set(arrays[0])\n    for arr in arrays[1:]:\n        intersection = intersection.intersection(set(arr))\n    return list(intersection)"
      ],
      [
        0.899342954158783,
        "    arr3 = arr1 + arr2\n    arr4 = []\n    for i in range(min(arr3), max(arr3) + 1):\n        if i in arr3:\n            arr4.append(i)\n    return arr4"
      ],
      [
        0.897758960723877,
        "    common_elements = set(list_of_arrays[0])\n    for array in list_of_arrays:\n        common_elements.intersection_update(array)\n    return list(common_elements)"
      ],
      [
        0.8976299166679382,
        "    for arr in arrays[1:]:\n        intersection = intersection.intersection(set(arr))"
      ],
      [
        0.896993100643158,
        "    common_elements = set(list1).intersection(list2)\n    return [element for element in common_elements if range_values[0] <= element <= range_values[1]]"
      ],
      [
        0.8967557549476624,
        "    result = set()\n    for array in arrays:\n        result = result.symmetric_difference(set(array))\n    return list(result)"
      ],
      [
        0.8964403867721558,
        "    result = []\n    i, j = (0, 0)\n    while i < len(firstList) and j < len(secondList):\n        start = max(firstList[i][0], secondList[j][0])\n        end = min(firstList[i][1], secondList[j][1])\n        if start <= end:\n            result.append([start, end])\n        if firstList[i][1] < secondList[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result"
      ],
      [
        0.8959094882011414,
        "    return [min(array) for array in arrays]"
      ],
      [
        0.8948372006416321,
        "    for array in list_of_arrays:\n        common_elements.intersection_update(array)"
      ]
    ],
    "MBPP/332": [
      [
        0.9129759073257446,
        "    uppercase = 0\n    digits = 0\n    for character in string:\n        if character.isupper():\n            uppercase += 1\n        elif character.isdigit():\n            digits += 1\n    results = {'Uppercase': uppercase, 'Digits': digits}\n    return results"
      ],
      [
        0.906787097454071,
        "    for character in string:\n        if character.isupper():\n            uppercase += 1\n        elif character.isdigit():\n            digits += 1"
      ],
      [
        0.9027115106582642,
        "    digit = 0\n    letters = 0\n    space = 0\n    other = 0\n    for i in x:\n        if i.isalpha():\n            letters += 1\n        elif i.isdigit():\n            digit += 1\n        elif i.isspace():\n            space += 1\n        else:\n            other += 1\n    return (digit, letters, space, other)"
      ],
      [
        0.9010061025619507,
        "    upper_case = 0\n    digits = 0\n    special_characters = 0\n    for character in string:\n        if character.isupper():\n            upper_case += 1\n        elif character.isdigit():\n            digits += 1\n        elif character.isalpha() or character.isspace():\n            continue\n        else:\n            special_characters += 1\n    return (upper_case, digits, special_characters)"
      ],
      [
        0.900554895401001,
        "    num_letter = 0\n    num_digit = 0\n    num_other = 0\n    for c in s:\n        if c.isalpha():\n            num_letter += 1\n        elif c.isdigit():\n            num_digit += 1\n        else:\n            num_other += 1\n    return (num_letter, num_digit, num_other)"
      ],
      [
        0.8990458846092224,
        "    count = 0\n    for c in string:\n        if c.isalpha():\n            count += 1\n    return count"
      ],
      [
        0.8977795839309692,
        "    for i in x:\n        if i.isalpha():\n            letters += 1\n        elif i.isdigit():\n            digit += 1\n        elif i.isspace():\n            space += 1\n        else:\n            other += 1"
      ],
      [
        0.8977285623550415,
        "        elif c.islower():\n            counts['lower'] += 1\n        elif c.isdigit():\n            counts['digits'] += 1\n        else:\n            counts['others'] += 1"
      ],
      [
        0.8967324495315552,
        "    alphabetic_count = 0\n    numeric_count = 0\n    special_character_count = 0\n    for ch in s:\n        if ch.isalpha():\n            alphabetic_count += 1\n        elif ch.isdigit():\n            numeric_count += 1\n        elif ch.isspace() == False:\n            special_character_count += 1\n    return (alphabetic_count, numeric_count, special_character_count)"
      ],
      [
        0.8960608243942261,
        "        if c.isalpha():\n            num_letter += 1\n        elif c.isdigit():\n            num_digit += 1\n        else:\n            num_other += 1"
      ]
    ],
    "MBPP/333": [
      [
        0.9063969850540161,
        "    if (end - start) % 2 == 0 and start % 2 == 0 and (end % 2 == 0):\n        print('Warning: The given range does not contain any odd numbers.')\n        return"
      ],
      [
        0.90202796459198,
        "    odd_list = []\n    for i in range(x, y):\n        if i % 2 != 0:\n            odd_list.append(i)\n    return odd_list"
      ],
      [
        0.897747278213501,
        "    for i in range(start, end + 1):\n        if i % 2 == 1:\n            count += 1\n            total += i"
      ],
      [
        0.897638201713562,
        "    count = 0\n    for i in range(m, n + 1):\n        if i % 2 == 0:\n            count += 1\n    return count"
      ],
      [
        0.8950865268707275,
        "    count = 0\n    for i in range(2, max, 2):\n        count += 1\n    return count"
      ]
    ],
    "MBPP/334": [
      [
        0.9281967282295227,
        "    unique_numbers = list(set(numbers))\n    unique_numbers.sort()\n    if len(unique_numbers) < 2:\n        print('Error - at least two unique numbers are required')\n        return\n    difference = unique_numbers[-2] - unique_numbers[1]\n    return difference"
      ],
      [
        0.9281955361366272,
        "    unique_numbers = list(set(numbers))\n    unique_numbers.sort()\n    if len(unique_numbers) < 2:\n        print('Error - at least two unique numbers are required')\n        return\n    difference = unique_numbers[-2] - unique_numbers[1]\n    return difference"
      ],
      [
        0.9163123965263367,
        "    for i in range(len(my_list)):\n        for j in range(i + 1, len(my_list)):\n            current_diff = my_list[j] - my_list[i]\n            if current_diff < min_diff:\n                min_diff = current_diff"
      ],
      [
        0.9154350757598877,
        "    maxDifference = 0\n    for i in range(len(elementList)):\n        for j in range(i + 1, len(elementList)):\n            if elementList[j] - elementList[i] > maxDifference:\n                maxDifference = elementList[j] - elementList[i]\n    return maxDifference"
      ],
      [
        0.9103949069976807,
        "    if len(lst) < 2:\n        return 'The list must contain at least two elements'\n    else:\n        return lst[0] - lst[1]"
      ],
      [
        0.9103949069976807,
        "    if len(lst) < 2:\n        return 'The list must contain at least two elements'\n    else:\n        return lst[0] - lst[1]"
      ],
      [
        0.9083720445632935,
        "    try:\n        differences = [array[i + 1] - array[i] for i in range(len(array) - 1)]\n        return differences\n    except (TypeError, IndexError):\n        return 'The list should contain only integers.'"
      ],
      [
        0.9076511263847351,
        "    max_difference = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] - arr[i] > max_difference:\n                max_difference = arr[j] - arr[i]\n    return max_difference"
      ],
      [
        0.9072052240371704,
        "    if not isinstance(array, list):\n        return 'Invalid data type, should be list.'\n    try:\n        differences = [array[i + 1] - array[i] for i in range(len(array) - 1)]\n        return differences\n    except (TypeError, IndexError):\n        return 'The list should contain only integers.'"
      ],
      [
        0.9067050218582153,
        "        for j in range(i + 1, len(my_list)):\n            current_diff = my_list[j] - my_list[i]\n            if current_diff < min_diff:\n                min_diff = current_diff"
      ]
    ],
    "MBPP/335": [
      [
        0.9011739492416382,
        "    e = 0\n    for i in range(n):\n        e += 1 / math.factorial(i)\n    return e"
      ],
      [
        0.9011700749397278,
        "    e = 0\n    for i in range(n):\n        e += 1 / math.factorial(i)\n    return e"
      ],
      [
        0.9011697769165039,
        "    e = 0\n    for i in range(n):\n        e += 1 / math.factorial(i)\n    return e"
      ],
      [
        0.8988808393478394,
        "    for i in range(n):\n        e += 1 / math.factorial(i)"
      ],
      [
        0.8988775014877319,
        "    for i in range(n):\n        e += 1 / math.factorial(i)"
      ],
      [
        0.898867666721344,
        "    for i in range(n):\n        e += 1 / math.factorial(i)"
      ],
      [
        0.8897983431816101,
        "    E = 0\n    for d in range(day, 0, -1):\n        E = 1 + E * d / (d + 1)\n    return E"
      ],
      [
        0.8897509574890137,
        "    if k > n:\n        return 0"
      ],
      [
        0.8897470235824585,
        "    if k > n:\n        return 0"
      ],
      [
        0.8888038396835327,
        "    e = 1\n    factorial = 1\n    term = 1\n    n = 1\n    while abs(term - e) > 0.0001:\n        term *= n\n        factorial *= n\n        e += term / factorial\n        n += 1\n    return round(e, 4)"
      ]
    ],
    "MBPP/336": [
      [
        0.9050391912460327,
        "    x1, y1, x2, y2 = map(int, rect.split())\n    return (x2 - x1) * (y2 - y1)"
      ],
      [
        0.887770414352417,
        "    width = abs(x2 - x1)\n    height = abs(y2 - y1)\n    return width * height"
      ],
      [
        0.8871716260910034,
        "    length = abs(x2 - x1)\n    width = abs(y2 - y1)\n    return length * width"
      ],
      [
        0.8850581645965576,
        "    return [length * width for length, width in rectangle_pairs]"
      ],
      [
        0.8850499391555786,
        "    return [length * width for length, width in rectangle_pairs]"
      ],
      [
        0.8850207328796387,
        "    points = set()\n    for rectangle in coordinates:\n        for x in range(rectangle[0], rectangle[2]):\n            for y in range(rectangle[1], rectangle[3]):\n                points.add((x, y))\n    return len(points)"
      ],
      [
        0.8846858739852905,
        "    if r > l and b > t:\n        return (r - l) * (b - t)\n    else:\n        return 0"
      ],
      [
        0.8836591243743896,
        "    x1, y1 = rectangle[0]\n    x2, y2 = rectangle[1]\n    x3, y3 = rectangle[2]\n    x4, y4 = rectangle[3]\n    length = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    width = math.sqrt((x3 - x2) ** 2 + (y3 - y2) ** 2)\n    area = length * width\n    perimeter = 2 * (length + width)\n    return (area, perimeter)"
      ],
      [
        0.8827654719352722,
        "    area_sum = 0\n    for rectangle in rectangles:\n        area_sum += rectangle['length'] * rectangle['width']\n    return area_sum"
      ],
      [
        0.8809770345687866,
        "    squares = group.split()\n    total_area = sum((int(side) ** 2 for side in squares))\n    return total_area"
      ]
    ],
    "MBPP/337": [
      [
        0.8874465823173523,
        "            if vals[i - 1] <= j:\n                include = 1 + dp[i - 1][j - vals[i - 1]]\n                exclude = dp[i - 1][j]\n                if include < exclude:\n                    dp[i][j] = include\n                    count[i][j] = count[i - 1][j - vals[i - 1]]\n                elif include == exclude:\n                    dp[i][j] = include\n                    count[i][j] = count[i - 1][j] + count[i - 1][j - vals[i - 1]]\n                else:\n                    dp[i][j] = exclude\n                    count[i][j] = count[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n                count[i][j] = count[i - 1][j]"
      ],
      [
        0.886070728302002,
        "    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if vals[i - 1] <= j:\n                include = 1 + dp[i - 1][j - vals[i - 1]]\n                exclude = dp[i - 1][j]\n                if include < exclude:\n                    dp[i][j] = include\n                    count[i][j] = count[i - 1][j - vals[i - 1]]\n                elif include == exclude:\n                    dp[i][j] = include\n                    count[i][j] = count[i - 1][j] + count[i - 1][j - vals[i - 1]]\n                else:\n                    dp[i][j] = exclude\n                    count[i][j] = count[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n                count[i][j] = count[i - 1][j]"
      ],
      [
        0.8837681412696838,
        "        for j in range(1, target + 1):\n            if vals[i - 1] <= j:\n                include = 1 + dp[i - 1][j - vals[i - 1]]\n                exclude = dp[i - 1][j]\n                if include < exclude:\n                    dp[i][j] = include\n                    count[i][j] = count[i - 1][j - vals[i - 1]]\n                elif include == exclude:\n                    dp[i][j] = include\n                    count[i][j] = count[i - 1][j] + count[i - 1][j - vals[i - 1]]\n                else:\n                    dp[i][j] = exclude\n                    count[i][j] = count[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n                count[i][j] = count[i - 1][j]"
      ]
    ],
    "MBPP/338": [
      [
        0.9071922898292542,
        "    if set(binary_string) == {'0'} or set(binary_string) == {'1'}:\n        return True\n    else:\n        return False"
      ],
      [
        0.9071922898292542,
        "    if set(binary_string) == {'0'} or set(binary_string) == {'1'}:\n        return True\n    else:\n        return False"
      ],
      [
        0.9033008217811584,
        "    if not set(binary).issubset({'0', '1'}):\n        return 'Error: Input is not a valid binary number'"
      ],
      [
        0.9033005237579346,
        "    if not set(binary).issubset({'0', '1'}):\n        return 'Error: Input is not a valid binary number'"
      ],
      [
        0.902240514755249,
        "    for char in input_string:\n        if char not in '01':\n            return False\n    return True"
      ],
      [
        0.9014414548873901,
        "    if not binary_string or not all((char in ('0', '1') for char in binary_string)):\n        return 'Invalid binary string'"
      ],
      [
        0.8994331955909729,
        "    return all([digit in '01' for digit in binary])"
      ],
      [
        0.8990226984024048,
        "    binary = str(binary)\n    if set(binary) == {'0', '1'} or set(binary) == {'0'} or set(binary) == {'1'}:\n        return int(binary, 2)\n    else:\n        return 'Error: Invalid binary number. A binary number consists only of 0s and 1s.'"
      ],
      [
        0.8990123271942139,
        "    binary = str(binary)\n    if set(binary) == {'0', '1'} or set(binary) == {'0'} or set(binary) == {'1'}:\n        return int(binary, 2)\n    else:\n        return 'Error: Invalid binary number. A binary number consists only of 0s and 1s.'"
      ],
      [
        0.8979071974754333,
        "    if set(binary) == {'0', '1'} or set(binary) == {'0'} or set(binary) == {'1'}:\n        return int(binary, 2)\n    else:\n        return 'Error: Invalid binary number. A binary number consists only of 0s and 1s.'"
      ]
    ],
    "MBPP/339": [
      [
        0.8992804288864136,
        "    char_counts = {}\n    for char in string:\n        if char in char_counts:\n            char_counts[char] += 1\n        else:\n            char_counts[char] = 1\n    max_occurrence = max(char_counts.values())\n    min_operations = len(string) - max_occurrence\n    return min_operations"
      ],
      [
        0.8959312438964844,
        "    res = ''\n    for ch in string:\n        if string.count(ch) < 2:\n            res += ch\n    return res"
      ],
      [
        0.8958011865615845,
        "    final_string = ''\n    last_char = ''\n    for char in string:\n        if char != last_char:\n            final_string += char\n            last_char = char\n    return final_string"
      ],
      [
        0.8958011865615845,
        "    final_string = ''\n    last_char = ''\n    for char in string:\n        if char != last_char:\n            final_string += char\n            last_char = char\n    return final_string"
      ],
      [
        0.893768846988678,
        "    s_new = ''\n    for letter in s:\n        if letter != char:\n            s_new += letter\n    return s_new"
      ],
      [
        0.8933515548706055,
        "    result = ''\n    last_seen = None\n    for char in string:\n        if char != last_seen:\n            result += char\n            last_seen = char\n    return result"
      ],
      [
        0.892844557762146,
        "    modified_string = string[0]\n    removed_dict = collections.defaultdict(int)\n    for i in range(1, len(string)):\n        if string[i] != string[i - 1]:\n            modified_string += string[i]\n        else:\n            removed_dict[string[i]] += 1\n    freq_map = collections.Counter(modified_string)\n    modified_string = ''.join([char for char, _ in freq_map.most_common()])\n    return (modified_string, removed_dict)"
      ],
      [
        0.8920766711235046,
        "    lowercase_letters = [char for char in string if char.islower()]\n    result = ''\n    for char in string:\n        if char.islower() and lowercase_letters.count(char) > 1:\n            lowercase_letters.remove(char)\n            if lowercase_letters.count(char) > 1:\n                lowercase_letters.remove(char)\n                result += char\n        else:\n            result += char\n    return result"
      ],
      [
        0.8919939994812012,
        "    longest_string = ''\n    temp_string = ''\n    for c in input_string:\n        if c == temp_string[-1:]:\n            temp_string += c\n        else:\n            if len(temp_string) > len(longest_string):\n                longest_string = temp_string\n            temp_string = c\n        if len(temp_string) > len(longest_string):\n            longest_string = temp_string\n    return input_string.replace(longest_string, '')"
      ],
      [
        0.8917051553726196,
        "    result = ''\n    previous = None\n    for c in s:\n        if c != previous:\n            result += c\n        previous = c\n    return result"
      ]
    ],
    "MBPP/340": [
      [
        0.9171279072761536,
        "    if k > len(arr):\n        return 'k is greater than the number of unique elements'\n    else:\n        return arr[k - 1]"
      ],
      [
        0.9147320985794067,
        "        if counter != k:\n            i += 1\n            counter += 1\n        else:\n            return arr1[i]"
      ],
      [
        0.9107274413108826,
        "    while i < len(arr1):\n        if counter != k:\n            i += 1\n            counter += 1\n        else:\n            return arr1[i]"
      ],
      [
        0.9091753959655762,
        "    while j < len(arr2):\n        if counter != k:\n            j += 1\n            counter += 1\n        else:\n            return arr2[j]"
      ],
      [
        0.9082303047180176,
        "        if counter != k:\n            j += 1\n            counter += 1\n        else:\n            return arr2[j]"
      ],
      [
        0.9055565595626831,
        "    max_value = max(arr)\n    primes = sieve_of_eratosthenes(max_value)\n    count = 0\n    for num in arr:\n        if num in primes:\n            count += 1\n            if count == k:\n                return num\n    return None"
      ],
      [
        0.9054495096206665,
        "    freq = {}\n    for el in arr:\n        if el in freq:\n            freq[el] += 1\n        else:\n            freq[el] = 1\n    sorted_freq = sorted(freq.items(), key=lambda kv: kv[1], reverse=True)\n    return sorted_freq[k - 1][0]"
      ],
      [
        0.9051671624183655,
        "    unique_elements = purge_and_sort(arr)\n    if len(unique_elements) < k:\n        return None\n    else:\n        return unique_elements[k - 1]"
      ],
      [
        0.9039590358734131,
        "    sorted_arr = sorted(arr)\n    return sorted_arr[k - 1]"
      ],
      [
        0.9031983017921448,
        "    frequencies = {}\n    for element in array:\n        if element not in frequencies:\n            frequencies[element] = 1\n        else:\n            frequencies[element] += 1\n    frequencies_list = list(frequencies.keys())\n    frequencies_list.sort(reverse=True, key=lambda x: frequencies[x])\n    return frequencies_list[k - 1]"
      ]
    ],
    "MBPP/341": [
      [
        0.9298058152198792,
        "    s = set()\n    for character in string:\n        if character in s:\n            return False\n        else:\n            s.add(character)\n    return True"
      ],
      [
        0.9288877844810486,
        "    unique_chars = set()\n    for char in input_str:\n        if char in unique_chars:\n            return False\n        else:\n            unique_chars.add(char)\n    return True"
      ],
      [
        0.9280253648757935,
        "    unique_set = set()\n    for char in string:\n        unique_set.add(char)\n        if len(unique_set) != len(string):\n            return False\n    return True"
      ],
      [
        0.9274674654006958,
        "    characters = set()\n    for char in string:\n        if char in characters:\n            return False\n        characters.add(char)\n    return True"
      ],
      [
        0.9272761940956116,
        "    unique_chars = set()\n    for char in string:\n        if char in unique_chars:\n            return False\n        unique_chars.add(char)\n    return True"
      ],
      [
        0.9272613525390625,
        "    unique_chars = set()\n    for char in string:\n        if char in unique_chars:\n            return False\n        unique_chars.add(char)\n    return True"
      ],
      [
        0.9267724752426147,
        "    chars = set()\n    for char in string:\n        if char in chars:\n            return False\n        else:\n            chars.add(char)\n    return True"
      ],
      [
        0.9267706871032715,
        "    chars = set()\n    for char in string:\n        if char in chars:\n            return False\n        else:\n            chars.add(char)\n    return True"
      ],
      [
        0.9267686605453491,
        "    chars = set()\n    for char in string:\n        if char in chars:\n            return False\n        else:\n            chars.add(char)\n    return True"
      ],
      [
        0.9264460802078247,
        "    char_set = set()\n    for char in string:\n        if char in char_set:\n            return False\n        else:\n            char_set.add(char)\n    return True"
      ]
    ],
    "MBPP/342": [
      [
        0.8834726214408875,
        "    result = []\n    for i in nested_list:\n        if type(i) is list:\n            i = remove_element(i, target)\n            if i:\n                result.append(i)\n        elif i != target:\n            result.append(i)\n    return result"
      ],
      [
        0.8823752403259277,
        "    return [i[:column] + i[column + 1:] for i in L]"
      ],
      [
        0.8792706727981567,
        "    count = 0\n    new_list = []\n    for sublist in nested_list:\n        if isinstance(sublist, list):\n            count += remove_number(sublist, num)\n        elif sublist == num:\n            count += 1\n        else:\n            new_list.append(sublist)\n    nested_list.clear()\n    nested_list.extend(new_list)\n    return count"
      ],
      [
        0.8785142302513123,
        "    result = []\n    for item in nested_list:\n        if isinstance(item, list):\n            new_list = remove_string(item, target)\n            if new_list:\n                result.append(new_list)\n        elif item != target:\n            result.append(item)\n    return result"
      ],
      [
        0.8784527778625488,
        "                for r in range(len(matrix)):\n                    del matrix[r][col]"
      ],
      [
        0.8767305612564087,
        "    for i in nested_list:\n        if type(i) is list:\n            i = remove_element(i, target)\n            if i:\n                result.append(i)\n        elif i != target:\n            result.append(i)"
      ],
      [
        0.8755645751953125,
        "    col = 0\n    while col < len(matrix[0]):\n        for row in matrix:\n            if type(row[col]) is data_type:\n                for r in range(len(matrix)):\n                    del matrix[r][col]\n                break\n        col += 1\n    return matrix"
      ],
      [
        0.8735175132751465,
        "    if not arr:\n        return arr\n    num_rows = len(arr)\n    num_cols = len(arr[0])\n    if index[0] < 0 or index[0] >= num_rows or index[1] < 0 or (index[1] >= num_cols):\n        return arr\n    del arr[index[0]][index[1]]\n    for row in arr:\n        if len(row) > num_cols:\n            row.pop()\n    for i in range(num_rows):\n        if len(arr[i]) > index[1]:\n            del arr[i][index[1]]\n    return arr"
      ],
      [
        0.8726242184638977,
        "    for item in nested_list:\n        if isinstance(item, list):\n            new_list = remove_string(item, target)\n            if new_list:\n                result.append(new_list)\n        elif item != target:\n            result.append(item)"
      ],
      [
        0.8722707629203796,
        "    del my_list[index]\n    return my_list"
      ]
    ],
    "MBPP/343": [
      [
        0.8867039680480957,
        "    return first_term + (n - 1) * common_difference"
      ],
      [
        0.885954737663269,
        "        if arr[1] - arr[0] > 0:\n            return 'Array is sorted in ascending order and forms an arithmetic progression'\n        else:\n            return 'Array is sorted in descending order and forms an arithmetic progression'"
      ],
      [
        0.8829948306083679,
        "    first_term = sum / (ratio ** terms - 1)\n    progression = [first_term * ratio ** n for n in range(terms)]\n    return progression"
      ],
      [
        0.8825080394744873,
        "    if len(arr) < 2:\n        return 'The array should have at least two numbers for finding a sequence.'\n    else:\n        diff = arr[1] - arr[0]\n        for i in range(2, len(arr)):\n            if arr[i] - arr[i - 1] != diff:\n                return 'The given input does not form an arithmetic sequence.'\n        return 'The difference of the arithmetic sequence is: ' + str(diff)"
      ],
      [
        0.8825080394744873,
        "    if len(arr) < 2:\n        return 'The array should have at least two numbers for finding a sequence.'\n    else:\n        diff = arr[1] - arr[0]\n        for i in range(2, len(arr)):\n            if arr[i] - arr[i - 1] != diff:\n                return 'The given input does not form an arithmetic sequence.'\n        return 'The difference of the arithmetic sequence is: ' + str(diff)"
      ],
      [
        0.878061830997467,
        "    if is_arithmetic:\n        if arr[1] - arr[0] > 0:\n            return 'Array is sorted in ascending order and forms an arithmetic progression'\n        else:\n            return 'Array is sorted in descending order and forms an arithmetic progression'"
      ],
      [
        0.8775228261947632,
        "    words = sentence.split()\n    if len(words) < 3:\n        return 'Not enough terms to determine the sequence type.'\n    diff = int(words[1]) - int(words[0])\n    is_arithmetic = True\n    for i in range(2, len(words)):\n        if int(words[i]) - int(words[i - 1]) != diff:\n            is_arithmetic = False\n            break\n    if is_arithmetic:\n        return 'The given sequence is an arithmetic sequence.'\n    return 'The given sequence does not match any known sequence type.'"
      ],
      [
        0.8773363828659058,
        "    geometric_sequence = [first_term]\n    for _ in range(1, total_terms):\n        next_term = geometric_sequence[-1] * common_ratio\n        geometric_sequence.append(next_term)\n    return geometric_sequence"
      ],
      [
        0.8773350119590759,
        "            if arr[i] - arr[i - 1] != diff:\n                return 'The given input does not form an arithmetic sequence.'"
      ],
      [
        0.8773090839385986,
        "    geometric_sequence = [first_term]\n    for _ in range(1, total_terms):\n        next_term = geometric_sequence[-1] * common_ratio\n        geometric_sequence.append(next_term)\n    return geometric_sequence"
      ]
    ],
    "MBPP/344": [
      [
        0.8915395736694336,
        "    return math.pi * r ** 2"
      ],
      [
        0.8907272219657898,
        "    if r < 0:\n        raise ValueError('Radius cannot be negative. Please provide a non-negative input.')\n    PI = 3.14159\n    return PI * r ** 2"
      ],
      [
        0.8896843194961548,
        "    num_points = 2 * r + 1\n    return num_points ** 2"
      ],
      [
        0.8889362215995789,
        "    return 3.14 * r * r"
      ],
      [
        0.8884133696556091,
        "    PI = 3.1415\n    area = PI * r ** 2\n    return area"
      ],
      [
        0.886036217212677,
        "    PI = 3.14159\n    return 2 * PI * r"
      ],
      [
        0.885539174079895,
        "    for perimeter in range(4, limit + 1):\n        count += perimeter // 4 - 1"
      ],
      [
        0.8853281736373901,
        "    integer_part = int(radius)\n    decimal_part = radius - integer_part\n    area_integer_part = 3.14159 * integer_part * integer_part\n    area_decimal_part = 3.14159 * decimal_part * decimal_part\n    return area_integer_part + area_decimal_part"
      ],
      [
        0.8848083019256592,
        "    angle = 2 * math.pi / n\n    area = r ** 2 * math.sin(angle) / 2\n    return area"
      ],
      [
        0.8846059441566467,
        "    if r < 1:\n        return 0"
      ]
    ],
    "MBPP/345": [
      [
        0.888831615447998,
        "    angle = math.acos((b ** 2 + c ** 2 - a ** 2) / (2 * b * c))\n    return math.degrees(angle)"
      ],
      [
        0.8881014585494995,
        "    if side1 + side2 <= side3 or side2 + side3 <= side1 or side3 + side1 <= side2:\n        return 'Error: Invalid triangle'\n    numerator = side1 ** 2 + side2 ** 2 - side3 ** 2\n    denominator = 2 * side1 * side2\n    angle_rad = math.acos(numerator / denominator)\n    angle_deg = math.degrees(angle_rad)\n    return angle_deg"
      ],
      [
        0.8776828050613403,
        "    if a + b <= angle_C or a + angle_C <= b or b + angle_C <= a:\n        return 'Error: Invalid triangle'\n    angle_C_rad = math.radians(angle_C)\n    area = 0.5 * a * b * math.sin(angle_C_rad)\n    return area"
      ],
      [
        0.8773301839828491,
        "    if a + b <= angle_C or a + angle_C <= b or b + angle_C <= a:\n        return 'Error: Invalid triangle'"
      ],
      [
        0.8763822913169861,
        "    x1, _, _ = point1\n    x2, _, _ = point2\n    distance = calculate_distance(point1, point2)\n    angle = math.acos((x2 - x1) / distance) * (180 / math.pi)\n    return round(angle, 2)"
      ],
      [
        0.8757878541946411,
        "    if angle <= 0 or angle >= 180:\n        print('Invalid input. Please enter a valid angle')\n        return None\n    elif side1 <= 0 or side2 <= 0:\n        print('Invalid input. Please enter valid sides')\n        return None\n    elif side1 + side2 <= side1 or side1 + side2 <= side2 or side1 + side1 <= side2:\n        print('Invalid input. These sides do not form a valid triangle')\n        return None\n    else:\n        height = side2 * math.sin(math.radians(angle))\n        return height"
      ],
      [
        0.8757878541946411,
        "    if angle <= 0 or angle >= 180:\n        print('Invalid input. Please enter a valid angle')\n        return None\n    elif side1 <= 0 or side2 <= 0:\n        print('Invalid input. Please enter valid sides')\n        return None\n    elif side1 + side2 <= side1 or side1 + side2 <= side2 or side1 + side1 <= side2:\n        print('Invalid input. These sides do not form a valid triangle')\n        return None\n    else:\n        height = side2 * math.sin(math.radians(angle))\n        return height"
      ],
      [
        0.8753628730773926,
        "    elif side1 + side2 <= side1 or side1 + side2 <= side2 or side1 + side1 <= side2:\n        print('Invalid input. These sides do not form a valid triangle')\n        return None\n    else:\n        height = side2 * math.sin(math.radians(angle))\n        return height"
      ],
      [
        0.8744105100631714,
        "    elif angle > 90 and angle < 180:\n        return 'Obtuse angle'\n    elif angle == 180:\n        return 'Straight angle'"
      ],
      [
        0.873150110244751,
        "    elif angle == 90:\n        return 'Right angle'\n    elif angle > 90 and angle < 180:\n        return 'Obtuse angle'\n    elif angle == 180:\n        return 'Straight angle'"
      ]
    ],
    "MBPP/346": [
      [
        0.9015679955482483,
        "    max_values = []\n    for tup in list_of_tuples:\n        max_values.append(max(tup))\n    return max_values"
      ],
      [
        0.8920714855194092,
        "    for tup in list_of_tuples:\n        max_values.append(max(tup))"
      ],
      [
        0.8915171027183533,
        "    if isinstance(args[0], tuple):\n        return [max(t) for t in args]\n    else:\n        return max(args)"
      ],
      [
        0.891493558883667,
        "    if isinstance(args[0], tuple):\n        return [max(t) for t in args]\n    else:\n        return max(args)"
      ],
      [
        0.8821685314178467,
        "    max_elmt = l[0]\n    for x in l:\n        if x > max_elmt:\n            max_elmt = x\n    return max_elmt"
      ],
      [
        0.8808093070983887,
        "    max_val = data[0]\n    for num in data:\n        if num > max_val:\n            max_val = num\n    return max_val"
      ],
      [
        0.8802366852760315,
        "    max = lst[0]\n    for i in range(1, len(lst)):\n        if lst[i] > max:\n            max = lst[i]\n    return max"
      ],
      [
        0.8799280524253845,
        "    max_val = float('-inf')\n    for element in elements:\n        if element > max_val:\n            max_val = element\n    return max_val"
      ],
      [
        0.8793745040893555,
        "    max = lst[0]\n    for i in range(1, len(lst)):\n        if max < lst[i]:\n            max = lst[i]\n    return max"
      ],
      [
        0.8793474435806274,
        "    max = list1[0]\n    for item in list1:\n        if item > max:\n            max = item\n    return max"
      ]
    ],
    "MBPP/347": [
      [
        0.8973081111907959,
        "    if not isinstance(tuples1, list) or not isinstance(tuples2, list):\n        return 'Error: Both inputs should be lists.'\n    if len(tuples1) != len(tuples2):\n        return 'Error: Both lists should be of same length.'\n    for t in tuples1 + tuples2:\n        if not isinstance(t, tuple):\n            return 'Error: All elements of input lists should be tuples.'\n        if not all((isinstance(i, int) for i in t)):\n            return 'Error: All elements of the tuples should be integers.'\n    result = []\n    for pair1, pair2 in zip(tuples1, tuples2):\n        if len(pair1) != len(pair2):\n            return 'Error: Corresponding tuples should be of same length.'\n        temp = []\n        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)\n        result.append(tuple(temp))\n    return result"
      ],
      [
        0.8972752094268799,
        "    if not isinstance(tuples1, list) or not isinstance(tuples2, list):\n        return 'Error: Both inputs should be lists.'\n    if len(tuples1) != len(tuples2):\n        return 'Error: Both lists should be of same length.'\n    for t in tuples1 + tuples2:\n        if not isinstance(t, tuple):\n            return 'Error: All elements of input lists should be tuples.'\n        if not all((isinstance(i, int) for i in t)):\n            return 'Error: All elements of the tuples should be integers.'\n    result = []\n    for pair1, pair2 in zip(tuples1, tuples2):\n        if len(pair1) != len(pair2):\n            return 'Error: Corresponding tuples should be of same length.'\n        temp = []\n        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)\n        result.append(tuple(temp))\n    return result"
      ],
      [
        0.8966490030288696,
        "        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)"
      ],
      [
        0.8966314792633057,
        "        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)"
      ],
      [
        0.8964904546737671,
        "    for pair1, pair2 in zip(tuples1, tuples2):\n        if len(pair1) != len(pair2):\n            return 'Error: Corresponding tuples should be of same length.'\n        temp = []\n        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)\n        result.append(tuple(temp))"
      ],
      [
        0.896453857421875,
        "    for pair1, pair2 in zip(tuples1, tuples2):\n        if len(pair1) != len(pair2):\n            return 'Error: Corresponding tuples should be of same length.'\n        temp = []\n        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)\n        result.append(tuple(temp))"
      ],
      [
        0.8964347243309021,
        "    if len(list1) != len(list2):\n        return 'Error: Lists are not of the same length.'\n    result = []\n    for tup1, tup2 in zip(list1, list2):\n        if not isinstance(tup1, tuple) or not isinstance(tup2, tuple):\n            return 'Error: One or more elements is not a tuple.'\n        if len(tup1) != len(tup2):\n            return 'Error: Tuples are of different lengths.'\n        temp_result = []\n        for num1, num2 in zip(tup1, tup2):\n            if not isinstance(num1, int) or not isinstance(num2, int):\n                return 'Error: one or more elements is not an integer.'\n            if num2 == 0:\n                return 'Error: Cannot divide by zero.'\n            temp_result.append(num1 % num2)\n        result.append(tuple(temp_result))\n    return result"
      ],
      [
        0.8959391713142395,
        "    results = []\n    for pair in pairs:\n        try:\n            result = pair[0] % pair[1]\n            results.append(result)\n        except ZeroDivisionError:\n            results.append('Error: Division by 0')\n        except Exception as e:\n            results.append('Error: ' + str(e))\n    return results"
      ],
      [
        0.895575761795044,
        "    if len(list1) != len(list2):\n        return 'Error: Lists are of different lengths.'\n    result = []\n    for tup1, tup2 in zip(list1, list2):\n        if not isinstance(tup1, tuple) or not isinstance(tup2, tuple):\n            return 'Error: One or more elements is not a tuple.'\n        if len(tup1) != len(tup2):\n            return 'Error: Tuples are of different lengths.'\n        temp_result = []\n        for num1, num2 in zip(tup1, tup2):\n            if not isinstance(num1, int) or not isinstance(num2, int):\n                return 'Error: One or more elements is not an integer.'\n            if num2 == 0:\n                return 'Error: Cannot divide by zero.'\n            temp_result.append(num1 % num2)\n        result.append(tuple(temp_result))\n    return result"
      ],
      [
        0.8941052556037903,
        "    sum1 = sum(list1)\n    sum2 = sum(list2)\n    sum3 = sum(list3)\n    return [sum1 % sum3, sum2 % sum3]"
      ]
    ],
    "MBPP/348": [
      [
        0.9032968282699585,
        "    if math.isqrt(discriminant) ** 2 == discriminant:\n        if (math.isqrt(discriminant) - 1) % 2 == 0:\n            return True"
      ],
      [
        0.8957987427711487,
        "    elif discriminant == 0:\n        root = -b / (2 * a)\n        return root\n    else:\n        return 'No real roots exist.'"
      ],
      [
        0.8951984643936157,
        "        if (math.isqrt(discriminant) - 1) % 2 == 0:\n            return True"
      ],
      [
        0.8941447734832764,
        "    elif discriminant == 0:\n        root = -b / (2 * a)\n        return root\n    else:\n        return 'No real roots'"
      ],
      [
        0.8937087059020996,
        "    elif discriminant == 0:\n        root = -b / (2 * a)\n        return root\n    else:\n        return 'No real solutions'"
      ],
      [
        0.8925884962081909,
        "    elif d == 0:\n        root = -b / (2 * a)\n        return root\n    else:\n        return 'No real roots found'"
      ],
      [
        0.8923331499099731,
        "    elif discriminant == 0:\n        return -b / (2 * a)\n    else:\n        return 'No real roots'"
      ],
      [
        0.8920682668685913,
        "    elif discriminant == 0:\n        root = -b / (2 * a)\n        return (root,)\n    else:\n        return 'No real roots'"
      ],
      [
        0.8914880752563477,
        "    elif discriminant == 0:\n        nature = 'One real root (a perfect square)'\n        x = -b / (2 * a)\n        return (x, discriminant, nature)\n    else:\n        nature = 'No real roots (two complex roots)'\n        return (None, None, discriminant, nature)"
      ],
      [
        0.8911606669425964,
        "    elif d == 0:\n        return (-b / (2 * a), -b / (2 * a))\n    else:\n        x1 = (-b + d ** 0.5) / (2 * a)\n        x2 = (-b - d ** 0.5) / (2 * a)\n        return (x1, x2)"
      ]
    ],
    "MBPP/349": [
      [
        0.8876668810844421,
        "    elif n == 2:\n        return 2\n    else:\n        return 2 * nth_value(n - 1)"
      ],
      [
        0.8871955871582031,
        "    if n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return 2 * nth_value(n - 1)"
      ],
      [
        0.8871955871582031,
        "    if n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return 2 * nth_value(n - 1)"
      ],
      [
        0.8869332075119019,
        "    for i in range(2, n):\n        lucas_numbers.append(lucas_numbers[i - 1] + lucas_numbers[i - 2])"
      ],
      [
        0.8869186639785767,
        "    for i in range(2, n):\n        lucas_numbers.append(lucas_numbers[i - 1] + lucas_numbers[i - 2])"
      ],
      [
        0.8862873315811157,
        "    return findNthPolite(n)"
      ],
      [
        0.8862812519073486,
        "    return findNthPolite(n)"
      ],
      [
        0.8856824636459351,
        "    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"
      ],
      [
        0.8856819868087769,
        "    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"
      ],
      [
        0.8856805562973022,
        "    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"
      ]
    ],
    "MBPP/350": [
      [
        0.9174323081970215,
        "    if not isinstance(l, list):\n        return l\n    else:\n        return [x for x in filter(None, map(remove_empty_lists, l))]"
      ],
      [
        0.9174323081970215,
        "    if not isinstance(l, list):\n        return l\n    else:\n        return [x for x in filter(None, map(remove_empty_lists, l))]"
      ],
      [
        0.8957036137580872,
        "    for lst in lists:\n        result.append([item for item in lst if item not in items_to_remove])"
      ],
      [
        0.8954580426216125,
        "    new_lst = []\n    for li in lst:\n        if li:\n            new_lst.append(li)\n    return new_lst"
      ],
      [
        0.8922361135482788,
        "    return [s for s in list_of_strings if s != '']"
      ],
      [
        0.8861379623413086,
        "    if not list_of_lists:\n        return []"
      ],
      [
        0.8859582543373108,
        "    result = []\n    for string in lst:\n        if string:\n            result.append(string)\n    return result"
      ],
      [
        0.885840117931366,
        "            for item in lst:\n                is_empty, count_empty = check_empty_lists(item, already_checked)\n                empty_list_count += count_empty\n                all_empty = all_empty and is_empty"
      ],
      [
        0.8858386278152466,
        "            for item in lst:\n                is_empty, count_empty = check_empty_lists(item, already_checked)\n                empty_list_count += count_empty\n                all_empty = all_empty and is_empty"
      ],
      [
        0.8855952024459839,
        "    i = 0\n    while i < len(lst):\n        if lst[i] == '':\n            lst.pop(i)\n        else:\n            i += 1\n    return lst"
      ]
    ],
    "MBPP/351": [
      [
        0.9432665109634399,
        "    max_count = 0\n    max_item = None\n    dict = {}\n    for item in list:\n        if item in dict:\n            dict[item] += 1\n        else:\n            dict[item] = 1\n    for key, value in dict.items():\n        if value > max_count:\n            max_count = value\n            max_item = key\n    return max_item"
      ],
      [
        0.9393873810768127,
        "    max_count = -1\n    max_item = None\n    count = {}\n    for item in lst:\n        if item in count:\n            count[item] += 1\n        else:\n            count[item] = 1\n        if count[item] > max_count:\n            max_count = count[item]\n            max_item = item\n    return max_item"
      ],
      [
        0.9393411874771118,
        "    counts = {}\n    for item in my_list:\n        if item in counts:\n            counts[item] += 1\n        else:\n            counts[item] = 1\n    max_frequency = 0\n    max_item = None\n    for item in counts:\n        if counts[item] > max_frequency:\n            max_frequency = counts[item]\n            max_item = item\n    return max_item"
      ],
      [
        0.9384042024612427,
        "    freq_dict = {}\n    for item in lst:\n        freq_dict[item] = freq_dict.get(item, 0) + 1\n    max_count = 0\n    max_item = lst[0]\n    for key, value in freq_dict.items():\n        if value > max_count:\n            max_count = value\n            max_item = key\n    return max_item"
      ],
      [
        0.9377303719520569,
        "    count = {}\n    for item in input_list:\n        if item in count:\n            count[item] += 1\n        else:\n            count[item] = 1\n    maxCount = 0\n    maxItem = None\n    for item in count:\n        if count[item] > maxCount:\n            maxCount = count[item]\n            maxItem = item\n    return maxItem"
      ],
      [
        0.9370357990264893,
        "    max_count = 0\n    max_ele = list[0]\n    for i in list:\n        freq = list.count(i)\n        if freq > max_count:\n            max_count = freq\n            max_ele = i\n    return max_ele"
      ],
      [
        0.9367878437042236,
        "    max_count = -1\n    max_item = None\n    counts = {}\n    for item in lst:\n        if item not in counts:\n            counts[item] = 0\n        counts[item] += 1\n        if counts[item] > max_count:\n            max_count = counts[item]\n            max_item = item\n    return max_item"
      ],
      [
        0.9365628361701965,
        "    max_count = 0\n    max_item = lst[0]\n    for i in lst:\n        count = 1\n        for j in lst:\n            if j == i:\n                count += 1\n        if count >= max_count:\n            max_count = count\n            max_item = i\n    return max_item"
      ],
      [
        0.935855507850647,
        "    frequency_dict = {}\n    max_count = 0\n    max_item = None\n    for item in input_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n        if frequency_dict[item] > max_count:\n            max_count = frequency_dict[item]\n            max_item = item\n    return (max_item, max_count)"
      ],
      [
        0.9352418184280396,
        "    count = 0\n    max_element = 0\n    for element in lst:\n        curr_count = lst.count(element)\n        if curr_count > count:\n            count = curr_count\n            max_element = element\n    return max_element"
      ]
    ],
    "MBPP/352": [
      [
        0.8957962989807129,
        "    for i in range(len(arr)):\n        arr[i] = arr[i] + k\n    return arr"
      ],
      [
        0.8918623924255371,
        "    for i in range(len(arr)):\n        arr[i] = arr[i] + k"
      ],
      [
        0.8830235004425049,
        "    return [element * k for element in myList]"
      ],
      [
        0.8811910152435303,
        "        for c, d in tpl2:\n            return (a + c, b + d)"
      ],
      [
        0.8798644542694092,
        "    new_tuple = (element,) + old_tuple\n    return new_tuple"
      ],
      [
        0.879858136177063,
        "    new_tuple = (element,) + old_tuple\n    return new_tuple"
      ],
      [
        0.8743429183959961,
        "    for i in lst:\n        add = add + i"
      ],
      [
        0.8740453124046326,
        "    for a, b in tpl1:\n        for c, d in tpl2:\n            return (a + c, b + d)"
      ],
      [
        0.8740453124046326,
        "    for a, b in tpl1:\n        for c, d in tpl2:\n            return (a + c, b + d)"
      ],
      [
        0.8740138411521912,
        "    filtered_elements = [x for x in a if x < b]\n    multiplied_elements = [x * fact for x in filtered_elements]\n    return tuple(multiplied_elements)"
      ]
    ],
    "MBPP/353": [
      [
        0.9150879979133606,
        "    n = len(S)\n    no_of_zeros = S.count('0')\n    no_of_ones = n - no_of_zeros\n    dp = [0] * (n + 1)\n    min_flips = no_of_zeros\n    ones_left = 0\n    zeros_left = no_of_zeros\n    for i in range(1, n + 1):\n        if S[i - 1] == '0':\n            zeros_left -= 1\n        else:\n            ones_left += 1\n        dp[i] = min(ones_left + zeros_left, dp[i - 1] + (1 if S[i - 1] == '1' else 0))\n        if dp[i] < min_flips:\n            min_flips = dp[i]\n    return min_flips"
      ],
      [
        0.9137851595878601,
        "    flipCount, oneCount = (0, 0)\n    for c in s:\n        if c == '1':\n            oneCount += 1\n        else:\n            flipCount = min(flipCount + 1, oneCount)\n    return flipCount"
      ],
      [
        0.9137313365936279,
        "    flips = 0\n    prev = '0'\n    for bulb in target:\n        if bulb != prev:\n            flips += 1\n            prev = bulb\n    return flips"
      ],
      [
        0.9092686176300049,
        "    zeroCount = s.count('0')\n    oneCount = len(s) - zeroCount\n    if abs(zeroCount - oneCount) > 1:\n        return -1\n    swaps1 = swaps2 = 0\n    for i, c in enumerate(s):\n        if i % 2 == 0 and c != '0':\n            swaps1 += 1\n        if i % 2 == 1 and c != '1':\n            swaps1 += 1\n    swaps1 = swaps1 // 2\n    for i, c in enumerate(s):\n        if i % 2 == 0 and c != '1':\n            swaps2 += 1\n        if i % 2 == 1 and c != '0':\n            swaps2 += 1\n    swaps2 = swaps2 // 2\n    if zeroCount == oneCount:\n        return min(swaps1, swaps2)\n    return swaps2 if zeroCount > oneCount else swaps1"
      ],
      [
        0.9092422127723694,
        "    zeroCount = s.count('0')\n    oneCount = len(s) - zeroCount\n    if abs(zeroCount - oneCount) > 1:\n        return -1\n    swaps1 = swaps2 = 0\n    for i, c in enumerate(s):\n        if i % 2 == 0 and c != '0':\n            swaps1 += 1\n        if i % 2 == 1 and c != '1':\n            swaps1 += 1\n    swaps1 = swaps1 // 2\n    for i, c in enumerate(s):\n        if i % 2 == 0 and c != '1':\n            swaps2 += 1\n        if i % 2 == 1 and c != '0':\n            swaps2 += 1\n    swaps2 = swaps2 // 2\n    if zeroCount == oneCount:\n        return min(swaps1, swaps2)\n    return swaps2 if zeroCount > oneCount else swaps1"
      ],
      [
        0.9070776700973511,
        "    for c in s:\n        if c == '1':\n            oneCount += 1\n        else:\n            flipCount = min(flipCount + 1, oneCount)"
      ],
      [
        0.905449390411377,
        "    count_a, count_b = (0, 0)\n    for i, c in enumerate(s):\n        if i % 2 == 0:\n            if c == '0':\n                count_a += 1\n            else:\n                count_b += 1\n        elif c == '0':\n            count_b += 1\n        else:\n            count_a += 1\n    return min(count_a, count_b)"
      ],
      [
        0.9044026136398315,
        "    for i in range(1, n + 1):\n        if S[i - 1] == '0':\n            zeros_left -= 1\n        else:\n            ones_left += 1\n        dp[i] = min(ones_left + zeros_left, dp[i - 1] + (1 if S[i - 1] == '1' else 0))\n        if dp[i] < min_flips:\n            min_flips = dp[i]"
      ],
      [
        0.9039394855499268,
        "        if c == '1':\n            oneCount += 1\n        else:\n            flipCount = min(flipCount + 1, oneCount)"
      ],
      [
        0.9030253887176514,
        "    for i, c in enumerate(s):\n        if i % 2 == 0 and c != '0':\n            swaps1 += 1\n        if i % 2 == 1 and c != '1':\n            swaps1 += 1"
      ]
    ],
    "MBPP/354": [
      [
        0.925600528717041,
        "    while digits != 0:\n        digits //= 10\n        count += 1"
      ],
      [
        0.9255355596542358,
        "    count = 0\n    while number > 0:\n        number = number // 10\n        count = count + 1\n    return count"
      ],
      [
        0.922988772392273,
        "    count = 0\n    while number != 0:\n        number = number // 10\n        count += 1\n    return count"
      ],
      [
        0.9224833250045776,
        "    count = 0\n    while number != 0:\n        count = count + 1\n        number = number // 10\n    return count"
      ],
      [
        0.922024130821228,
        "    count = 0\n    while n > 0:\n        n = n // 10\n        count += 1\n    return count"
      ],
      [
        0.9215047359466553,
        "    count = 0\n    while n != 0:\n        n //= 10\n        count += 1\n    return count"
      ],
      [
        0.9214829802513123,
        "    while number > 0:\n        number = number // 10\n        count = count + 1"
      ],
      [
        0.9213654398918152,
        "    if type(num) != int:\n        return 'Error: Invalid input'\n    if num < 0:\n        num = -num\n    if num == 0:\n        return 1\n    count = 0\n    while num > 0:\n        num //= 10\n        count += 1\n    return count"
      ],
      [
        0.9203535318374634,
        "    while number != 0:\n        count = count + 1\n        number = number // 10"
      ],
      [
        0.9193726778030396,
        "    number = abs(number)\n    num_digits = len(str(number))\n    return num_digits"
      ]
    ],
    "MBPP/355": [
      [
        0.9313703775405884,
        "    max_product = float('-inf')\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] * lst[j] > max_product:\n                max_product = lst[i] * lst[j]\n                pair = (lst[i], lst[j])\n    return pair"
      ],
      [
        0.9281654953956604,
        "    if len(lst) < 2:\n        return None\n    max_product = float('-inf')\n    max_pair = None\n    for pair in combinations(lst, 2):\n        product = pair[0] * pair[1]\n        if product > max_product:\n            max_product = product\n            max_pair = pair\n    return list(max_pair)"
      ],
      [
        0.9255377054214478,
        "    max_product = 0\n    max_elems = [0, 0]\n    for i in range(len(arr)):\n        left_elem = arr[i]\n        for j in range(i + 1, len(arr)):\n            right_elem = arr[j]\n            product = left_elem * right_elem\n            if product > max_product:\n                max_product = product\n                max_elems = [left_elem, right_elem]\n    return (max_product, max_elems)"
      ],
      [
        0.9253742694854736,
        "    for pair in combinations(lst, 2):\n        product = pair[0] * pair[1]\n        if product > max_product:\n            max_product = product\n            max_pair = pair"
      ],
      [
        0.9242330193519592,
        "    if len(array) < 2:\n        return None\n    max_product = array[0] * array[1]\n    max_pair = (array[0], array[1])\n    for i in range(len(array)):\n        for j in range(i + 1, len(array)):\n            product = array[i] * array[j]\n            if product > max_product:\n                max_product = product\n                max_pair = (array[i], array[j])\n    return list(max_pair)"
      ],
      [
        0.9187819957733154,
        "    if not lst:\n        return []\n    possible_pairs = [[lst[i], lst[j]] for i in range(len(lst)) for j in range(i + 1, len(lst))]\n    products = [pair[0] * pair[1] for pair in possible_pairs]\n    max_product = max(products)\n    return [possible_pairs[i] for i in range(len(products)) if products[i] == max_product]"
      ],
      [
        0.9173946380615234,
        "    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] * lst[j] > max_product:\n                max_product = lst[i] * lst[j]\n                pair = (lst[i], lst[j])"
      ],
      [
        0.9152670502662659,
        "    max_product = float('-inf')\n    for i in range(len(array) - 1):\n        for j in range(i + 1, len(array)):\n            if array[i] * array[j] > max_product:\n                max_product = array[i] * array[j]\n    return max_product"
      ],
      [
        0.9147515296936035,
        "    n = len(arr)\n    max_product = float('-inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            product = arr[i] * arr[j]\n            if product > max_product:\n                max_product = product\n    return max_product"
      ],
      [
        0.9146967530250549,
        "            if lst[i] * lst[j] > max_product:\n                max_product = lst[i] * lst[j]\n                pair = (lst[i], lst[j])"
      ]
    ],
    "MBPP/356": [
      [
        0.926216185092926,
        "    if not root:\n        return True\n    lh = get_height(root.left)\n    rh = get_height(root.right)\n    if abs(lh - rh) <= 1 and is_balanced(root.left) is True and (is_balanced(root.right) is True):\n        return True\n    return False"
      ],
      [
        0.9256664514541626,
        "    is_balanced = True\n    if root is None:\n        is_balanced = True\n    elif abs(get_height(root.left) - get_height(root.right)) > 1:\n        is_balanced = False\n    else:\n        is_balanced = is_balanced_tree(root.left) and is_balanced_tree(root.right)\n    return is_balanced"
      ],
      [
        0.9247052669525146,
        "    if node is None:\n        return True\n    lh = tree_height(node.left) - 1\n    rh = tree_height(node.right) - 1\n    if abs(lh - rh) >= 2:\n        return False\n    return is_balanced(node.left) and is_balanced(node.right)"
      ],
      [
        0.9235826730728149,
        "    if root is None:\n        return True\n    lh = height(root.left)\n    rh = height(root.right)\n    if abs(lh - rh) <= 1 and isBalanced(root.left) and isBalanced(root.right):\n        return True\n    return False"
      ],
      [
        0.9232327938079834,
        "    lh = height(root.left)\n    rh = height(root.right)\n    if abs(lh - rh) <= 1 and isBalanced(root.left) and isBalanced(root.right):\n        return True\n    return False"
      ],
      [
        0.9227253794670105,
        "    if root is None:\n        return True\n    left_height = is_balanced(root.left)\n    right_height = is_balanced(root.right)\n    if abs(left_height - right_height) <= 1 and is_balanced(root.left) and is_balanced(root.right):\n        return True\n    return False"
      ],
      [
        0.9220752716064453,
        "    if root is None:\n        is_balanced = True\n    elif abs(get_height(root.left) - get_height(root.right)) > 1:\n        is_balanced = False\n    else:\n        is_balanced = is_balanced_tree(root.left) and is_balanced_tree(root.right)"
      ],
      [
        0.9220166206359863,
        "    if root is None:\n        return True\n    lh = height(root.left)\n    rh = height(root.right)\n    if abs(lh - rh) <= 1 and isBalanced(root.left) is True and (isBalanced(root.right) is True):\n        return True\n    return False"
      ],
      [
        0.9215182065963745,
        "    if root == None:\n        return True\n    leftHeight = height(root.left)\n    rightHeight = height(root.right)\n    if abs(leftHeight - rightHeight) < 2 and is_balanced(root.left) is True and (is_balanced(root.right) is True):\n        return True\n    return False"
      ],
      [
        0.9212579727172852,
        "    elif abs(get_height(root.left) - get_height(root.right)) > 1:\n        is_balanced = False\n    else:\n        is_balanced = is_balanced_tree(root.left) and is_balanced_tree(root.right)"
      ]
    ],
    "MBPP/357": [],
    "MBPP/358": [
      [
        0.9163185954093933,
        "    lateral_surface_area = 2 * l * h + b * h\n    total_surface_area = lateral_surface_area + 2 * l * b\n    return (lateral_surface_area, total_surface_area)"
      ],
      [
        0.9079416990280151,
        "    surface_area = 2 * l * w + 2 * l * h + 2 * w * h\n    return surface_area"
      ],
      [
        0.903471827507019,
        "    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area"
      ],
      [
        0.9034465551376343,
        "    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area"
      ],
      [
        0.8953275680541992,
        "    triangular_faces = 2 * 0.5 * b * h\n    rectangular_faces = 2 * b * L + h * L\n    total_surface_area = triangular_faces + rectangular_faces\n    return total_surface_area"
      ],
      [
        0.8949223756790161,
        "    surface_area = 2 * (height * width + width * depth + height * depth)\n    return surface_area"
      ],
      [
        0.8946269750595093,
        "    surface_area = 6 * length ** 2\n    volume = length ** 3\n    return (surface_area, volume)"
      ],
      [
        0.8943910598754883,
        "    try:\n        if len(cuboid) != 3:\n            raise ValueError('Input list must contain exactly three elements.')\n        l, b, h = cuboid\n        if not all((isinstance(val, (int, float)) for val in cuboid)):\n            raise ValueError('All elements in the input list must be numeric.')\n        aggregate_surface = 2 * (l * b + b * h + l * h)\n        return aggregate_surface\n    except ValueError as error:\n        print(str(error))\n        return None"
      ],
      [
        0.8943910598754883,
        "    try:\n        if len(cuboid) != 3:\n            raise ValueError('Input list must contain exactly three elements.')\n        l, b, h = cuboid\n        if not all((isinstance(val, (int, float)) for val in cuboid)):\n            raise ValueError('All elements in the input list must be numeric.')\n        aggregate_surface = 2 * (l * b + b * h + l * h)\n        return aggregate_surface\n    except ValueError as error:\n        print(str(error))\n        return None"
      ],
      [
        0.8930947780609131,
        "    if r1 < 0 or r2 < 0 or s < 0:\n        return 'Error: the radii and height must be positive numbers.'\n    lateral_surface_area = math.pi * (r1 + r2) * math.sqrt((r1 - r2) ** 2 + s ** 2)\n    return lateral_surface_area"
      ]
    ],
    "MBPP/359": [],
    "MBPP/360": [
      [
        0.9342241287231445,
        "    sorted_arr = sorted(arr)\n    curr = sorted_arr[0]\n    for element in sorted_arr[1:]:\n        if element != curr + 1:\n            return curr + 1\n        else:\n            curr = element\n    return missing"
      ],
      [
        0.9288812875747681,
        "    arr.sort()\n    smallest_missing = None\n    for i in range(len(arr)):\n        if arr[i] > 0:\n            if arr[i] != i + 1:\n                smallest_missing = i + 1\n                break\n    if smallest_missing is None:\n        smallest_missing = len(arr) + 1\n    return smallest_missing"
      ],
      [
        0.9219193458557129,
        "    arr.sort()\n    for i in range(len(arr)):\n        if arr[i] != i + 1:\n            return i + 1\n    return arr[-1] + 1"
      ],
      [
        0.9184635877609253,
        "    n = len(arr)\n    max_val = arr[0]\n    max_index = 0\n    for i in range(1, n):\n        if arr[i] > max_val:\n            max_val = arr[i]\n            max_index = i\n    expected = list(range(max_val + 1))\n    for num in expected:\n        if num not in arr:\n            return num\n    return expected[max_index + 1]"
      ],
      [
        0.9182337522506714,
        "    for element in sorted_arr[1:]:\n        if element != curr + 1:\n            return curr + 1\n        else:\n            curr = element"
      ],
      [
        0.9166531562805176,
        "    arr.sort()\n    for i in range(len(arr) - 1):\n        if arr[i + 1] - arr[i] != 1:\n            return arr[i] + 1"
      ],
      [
        0.9162753820419312,
        "    for i in range(n - 1):\n        expected_num = arr[i] + 1\n        if arr[i + 1] != expected_num:\n            return expected_num"
      ],
      [
        0.9161456823348999,
        "    s = set()\n    for i in arr:\n        s.add(i)\n    for i in range(1, len(arr) + 1):\n        if i not in s:\n            return i\n    return len(arr) + 1"
      ],
      [
        0.9159139394760132,
        "    arr.sort()\n    for i in range(len(arr)):\n        if arr[i + 1] - arr[i] != 1:\n            return arr[i] + 1"
      ]
    ],
    "MBPP/361": [],
    "MBPP/362": [
      [
        0.9170449376106262,
        "    volume_one_cuboid = length * breadth * height\n    combined_volume = volume_one_cuboid * number_of_cuboids\n    return combined_volume"
      ],
      [
        0.9009014368057251,
        "    volume = length * breadth * height\n    return volume"
      ],
      [
        0.9008681774139404,
        "    volume = length * breadth * height\n    return volume"
      ],
      [
        0.9001426100730896,
        "    volume = side_length ** 3\n    return volume"
      ],
      [
        0.899128794670105,
        "    area = 2 * (length * width + length * height + width * height)\n    volume = length * width * height\n    return (area, volume)"
      ],
      [
        0.8960750102996826,
        "    volume = 4 / 3 * math.pi * math.pow(radius, 3)\n    return volume"
      ],
      [
        0.8953557014465332,
        "    if length <= 0 or width <= 0 or height <= 0:\n        raise ValueError('All the dimensions should be non-zero positive numbers.')\n    else:\n        return length * width * height"
      ],
      [
        0.8953557014465332,
        "    if length <= 0 or width <= 0 or height <= 0:\n        raise ValueError('All the dimensions should be non-zero positive numbers.')\n    else:\n        return length * width * height"
      ],
      [
        0.8947422504425049,
        "    cube_radius = pow(r, 3)\n    volume = 4 / 3 * math.pi * cube_radius\n    return volume"
      ],
      [
        0.8940451741218567,
        "    box_x = box_coordinates[0].split()\n    box_y = box_coordinates[1].split()\n    box_z = box_coordinates[2].split()\n    length = abs(float(box_x[1]) - float(box_x[0]))\n    width = abs(float(box_y[1]) - float(box_y[0]))\n    height = abs(float(box_z[1]) - float(box_z[0]))\n    volume = length * width * height\n    return volume"
      ]
    ],
    "MBPP/363": [
      [
        0.9333562254905701,
        "    string = ''.join(set(string))\n    for perm in permutations(string):\n        print(''.join(perm))"
      ],
      [
        0.9327049255371094,
        "        for i, char in enumerate(string):\n            for perm in print_permutations(string[:i] + string[i + 1:]):\n                print(char + perm)"
      ],
      [
        0.9258118867874146,
        "    if len(string) == 1:\n        print(string)\n    else:\n        for i, char in enumerate(string):\n            for perm in print_permutations(string[:i] + string[i + 1:]):\n                print(char + perm)"
      ],
      [
        0.9258118867874146,
        "    if len(string) == 1:\n        print(string)\n    else:\n        for i, char in enumerate(string):\n            for perm in print_permutations(string[:i] + string[i + 1:]):\n                print(char + perm)"
      ],
      [
        0.9250695705413818,
        "    for perm in permutations(string):\n        print(''.join(perm))"
      ],
      [
        0.9239763617515564,
        "    perms = itertools.permutations(string)\n    for p in perms:\n        print(''.join(p))"
      ],
      [
        0.9239472150802612,
        "            for perm in print_permutations(string[:i] + string[i + 1:]):\n                print(char + perm)"
      ],
      [
        0.9229736924171448,
        "    _print_permutations_helper('', s)"
      ],
      [
        0.9216327667236328,
        "    length = len(string)\n    stack = ['']\n    visited = [False] * length\n    while stack:\n        current = stack.pop()\n        if len(current) == length:\n            print(current)\n        else:\n            for i in range(length):\n                if not visited[i]:\n                    visited[i] = True\n                    stack.append(current + string[i])\n                    visited[i] = False"
      ],
      [
        0.920768141746521,
        "        for char in string:\n            for perm in permutations(string.replace(char, '')):\n                perm_list.append(char + perm)"
      ]
    ],
    "MBPP/364": [
      [
        0.908858597278595,
        "    return round(n / 5) * 5"
      ],
      [
        0.9071648120880127,
        "    return round(num / 10) * 10"
      ],
      [
        0.8967028856277466,
        "    scaled_number = number * factor\n    rounded_number = int(scaled_number * 10 + 0.5) // 10\n    return rounded_number"
      ],
      [
        0.8958010673522949,
        "    return int(math.ceil(n / 5)) * 5"
      ],
      [
        0.8919054269790649,
        "    if round_down:\n        return int(number // 1)\n    else:\n        return int(number // 1) + 1 if number % 1 != 0 else int(number)"
      ],
      [
        0.8915045261383057,
        "        if round_down:\n            return int(number // 1)\n        else:\n            return round(number)"
      ],
      [
        0.891381025314331,
        "    if round_down:\n        return int(number)\n    elif number < 0:\n        return int(number) if number == int(number) else int(number) - 1\n    else:\n        return int(number) if number == int(number) else int(number) + 1"
      ],
      [
        0.891381025314331,
        "    if round_down:\n        return int(number)\n    elif number < 0:\n        return int(number) if number == int(number) else int(number) - 1\n    else:\n        return int(number) if number == int(number) else int(number) + 1"
      ],
      [
        0.8910702466964722,
        "    correction = 0.5 if n >= 0 else -0.5\n    return int(n / precision + correction) * precision"
      ],
      [
        0.8899271488189697,
        "    return int(math.ceil(x / 10.0)) * 10"
      ]
    ],
    "MBPP/365": [
      [
        0.9037469625473022,
        "    seen = set()\n    duplicates = set()\n    for item in input_tuple:\n        if item in seen:\n            duplicates.add(item)\n        seen.add(item)\n    return (len(duplicates) > 0, duplicates)"
      ],
      [
        0.897684633731842,
        "    new_tuple = []\n    for i in value_in_tuple:\n        if i not in new_tuple:\n            new_tuple.append(i)\n    return tuple(new_tuple)"
      ],
      [
        0.89742112159729,
        "    final_list = []\n    for num in input_list:\n        if num not in final_list:\n            final_list.append(num)\n    return tuple(final_list)"
      ],
      [
        0.8933796882629395,
        "    seen = set()\n    result = []\n    for tup in tups:\n        if tup not in seen:\n            result.append(tup)\n            seen.add(tup)\n    return result"
      ],
      [
        0.8933761119842529,
        "    result_set = set(input_tuple)\n    result_tuple = tuple(result_set)\n    return result_tuple"
      ],
      [
        0.8903636336326599,
        "    max_val = max(lst)\n    seen = set()\n    for i in range(len(lst)):\n        if lst[i] in seen:\n            lst[i] = max_val\n        else:\n            seen.add(lst[i])\n    return lst"
      ],
      [
        0.8899749517440796,
        "    for item in input_tuple:\n        if item in seen:\n            duplicates.add(item)\n        seen.add(item)"
      ],
      [
        0.8887690305709839,
        "    list_ = list(tup)\n    if item in list_:\n        list_.remove(item)\n    return tuple(list_)"
      ],
      [
        0.8882445693016052,
        "    seen = set()\n    for dic in lst:\n        dic_copy = dic.copy()\n        for key, value in dic.items():\n            if value in seen:\n                del dic_copy[key]\n            else:\n                seen.add(value)\n        dic.clear()\n        dic.update(dic_copy)\n    return lst"
      ],
      [
        0.8881539106369019,
        "    new_tup = []\n    for elem in initial_tup:\n        if elem != tup_to_expunge:\n            new_tup.append(elem)\n    return tuple(new_tup)"
      ]
    ],
    "MBPP/366": [
      [
        0.9238282442092896,
        "    result = ''\n    for c in string:\n        if c != char:\n            result += c\n    return result"
      ],
      [
        0.9234418869018555,
        "    new_string = ''\n    for char in input_string:\n        if char != character_to_remove:\n            new_string += char\n    return new_string"
      ],
      [
        0.9228833317756653,
        "    newString = ''\n    for ch in s:\n        if ch != character:\n            newString += ch\n    return newString"
      ],
      [
        0.9211516976356506,
        "    res = ''\n    for i in range(len(string)):\n        if string[i] != char:\n            res += string[i]\n    return res"
      ],
      [
        0.9201617240905762,
        "    new_string = given_string.replace(character, '')\n    return new_string"
      ],
      [
        0.9188644289970398,
        "    new_string = string.replace(char, '')\n    return new_string"
      ],
      [
        0.9188631176948547,
        "    new_string = ''\n    for char in string:\n        if char != remove_char:\n            new_string += char\n    return new_string"
      ],
      [
        0.9179937839508057,
        "    modified_string = ''\n    for c in input_string:\n        if c != char:\n            modified_string += c\n    return modified_string"
      ],
      [
        0.9160890579223633,
        "    output = ''\n    for c in sentence:\n        if c != char:\n            output += c\n    return output"
      ],
      [
        0.9154477119445801,
        "    string_list = list(string)\n    for i in string_list:\n        if i == char:\n            string_list.remove(i)\n    string = ''.join(string_list)\n    return string"
      ]
    ],
    "MBPP/367": [
      [
        0.9130551815032959,
        "    first_element = arr[0]\n    for i in range(len(arr) - 1):\n        arr[i] = arr[i + 1]\n    arr[len(arr) - 1] = first_element"
      ],
      [
        0.9107397198677063,
        "    first = arr[0]\n    for i in range(len(arr) - 1):\n        arr[i] = arr[i + 1]\n    arr[len(arr) - 1] = first"
      ],
      [
        0.9100664854049683,
        "    if not lst:\n        return lst\n    last_element = lst.pop()\n    lst.insert(0, last_element)\n    return lst"
      ],
      [
        0.908858060836792,
        "    temp = arr[0]\n    for i in range(len(arr) - 1):\n        arr[i] = arr[i + 1]\n    arr[-1] = temp\n    return arr"
      ],
      [
        0.9088411331176758,
        "    temp = arr[0]\n    for i in range(len(arr) - 1):\n        arr[i] = arr[i + 1]\n    arr[-1] = temp\n    return arr"
      ],
      [
        0.9088402390480042,
        "    temp = arr[0]\n    for i in range(len(arr) - 1):\n        arr[i] = arr[i + 1]\n    arr[-1] = temp\n    return arr"
      ],
      [
        0.9087079167366028,
        "    if len(lst) < 2:\n        return lst\n    second_last = lst[-2]\n    for i in range(len(lst) - 2, 0, -1):\n        lst[i] = lst[i - 1]\n    lst[0] = second_last\n    return lst"
      ],
      [
        0.90638267993927,
        "    temp = arr[0]\n    for i in range(len(arr) - 1):\n        arr[i] = arr[i + 1]\n    arr[len(arr) - 1] = temp"
      ],
      [
        0.9057836532592773,
        "    temp = arr[0]\n    for i in range(len(arr) - 1):\n        arr[i] = arr[i + 1]\n    arr[len(arr) - 1] = temp\n    return arr"
      ],
      [
        0.9038094878196716,
        "    if len(lst) < 2:\n        return lst\n    second_to_last = lst[-2]\n    for i in range(len(lst) - 1, 0, -1):\n        lst[i] = lst[i - 1]\n    lst[0] = second_to_last\n    return lst"
      ]
    ],
    "MBPP/368": [
      [
        0.9170222282409668,
        "    surface_area = 2 * l * w + 2 * l * h + 2 * w * h\n    return surface_area"
      ],
      [
        0.914268970489502,
        "    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area"
      ],
      [
        0.9142458438873291,
        "    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area"
      ],
      [
        0.912955641746521,
        "    surface_area = 2 * (height * width + width * depth + height * depth)\n    return surface_area"
      ],
      [
        0.9064940810203552,
        "    surface_area = 6 * length ** 2\n    volume = length ** 3\n    return (surface_area, volume)"
      ],
      [
        0.9052767157554626,
        "    surface_area = 6 * edge_length ** 2\n    return surface_area"
      ]
    ],
    "MBPP/369": [],
    "MBPP/370": [],
    "MBPP/371": [
      [
        0.8795488476753235,
        "    if rotation_angle == 0:\n        return 'Rotation angle cannot be zero'\n    if target_angle == 0:\n        return 0\n    return (target_angle + rotation_angle - 1) // rotation_angle"
      ],
      [
        0.87885582447052,
        "    if arr == arr[::-1]:\n        return 0"
      ],
      [
        0.8784613609313965,
        "        elif A[i] != x:\n            rotations_a += 1\n        elif B[i] != x:\n            rotations_b += 1"
      ],
      [
        0.8759481906890869,
        "    for j in range(len(arr)):\n        new_arr = arr[j:] + arr[:j]\n        if is_sorted(new_arr):\n            return j"
      ],
      [
        0.8756191730499268,
        "    if rotation == 0:\n        return arr\n    rotation = -rotation % len(arr)\n    return array_rotate(arr, rotation)"
      ],
      [
        0.874979555606842,
        "    n = len(arr)\n    minimum = n\n    for i in range(n):\n        diff = 0\n        for j in range(n):\n            if arr[(i + j) % n] != arr[j]:\n                diff += 1\n        minimum = min(diff, minimum)\n    return minimum"
      ],
      [
        0.8745362758636475,
        "    for i in range(len(nums)):\n        if nums[i] > nums[(i + 1) % len(nums)]:\n            count += 1"
      ],
      [
        0.8736210465431213,
        "    if arr[0] <= arr[n - 1]:\n        return 0"
      ],
      [
        0.8734915256500244,
        "        elif B[i] != x:\n            rotations_b += 1"
      ],
      [
        0.8728507161140442,
        "    rotations_a = rotations_b = 0\n    for i in range(n):\n        if A[i] != x and B[i] != x:\n            return -1\n        elif A[i] != x:\n            rotations_a += 1\n        elif B[i] != x:\n            rotations_b += 1\n    return min(rotations_a, rotations_b)"
      ]
    ],
    "MBPP/372": [
      [
        0.8929789662361145,
        "    while n & mask:\n        n ^= mask\n        mask <<= 1"
      ],
      [
        0.8903815746307373,
        "    mask = 1\n    while num > mask:\n        mask = mask << 1 | 1\n    return num ^ mask"
      ],
      [
        0.8885180950164795,
        "    odd_list = []\n    for number in original_list:\n        if number % 2 != 0:\n            odd_list.append(number)\n    return odd_list"
      ],
      [
        0.8883726596832275,
        "    while n:\n        parity ^= n & 1\n        n >>= 1"
      ],
      [
        0.8878854513168335,
        "    odd_nums = []\n    for num in nums:\n        if num % 2 != 0:\n            odd_nums.append(num)\n    return odd_nums"
      ],
      [
        0.8868136405944824,
        "    odd_nums = [num for num in arr if num % 2 == 1]\n    return odd_nums"
      ],
      [
        0.8868030309677124,
        "    parity = 0\n    while n:\n        parity ^= n & 1\n        n >>= 1\n    return parity"
      ],
      [
        0.8865936398506165,
        "    for num in a:\n        binary_num = bin(num)[2:]\n        transformed_num = num ^ num << 1 ^ num & num << 1 ^ num & num << 1 & num << 2\n        result.append(transformed_num)"
      ],
      [
        0.8859759569168091,
        "    sum = 0\n    for num in numbers:\n        sum += num & 1 ^ 1 and num\n    return sum"
      ],
      [
        0.8858523964881897,
        "    mask = 1\n    while n & mask:\n        n ^= mask\n        mask <<= 1\n    n ^= mask\n    return n"
      ]
    ],
    "MBPP/373": [
      [
        0.9126608371734619,
        "    frequency = {}\n    for item in array:\n        frequency[item] = frequency.get(item, 0) + 1\n    least_frequent_number = min(frequency, key=frequency.get)\n    return least_frequent_number"
      ],
      [
        0.909953236579895,
        "    freq = dict()\n    for element in arr:\n        if element not in freq:\n            freq[element] = 0\n        freq[element] += 1\n    min_element = None\n    min_count = float('inf')\n    for element, count in freq.items():\n        if count < min_count:\n            min_element = element\n            min_count = count\n    return min_element"
      ],
      [
        0.9076372385025024,
        "    frequency = Counter(arr)\n    min_freq = min(frequency.values())\n    min_freq_nums = [num for num, freq in frequency.items() if freq == min_freq]\n    return min_freq_nums"
      ],
      [
        0.905138373374939,
        "    count_table = {el: lst.count(el) for el in lst}\n    min_freq = min(count_table.values())\n    min_freq_elements = [k for k, v in count_table.items() if v == min_freq]\n    return min_freq_elements[0]"
      ],
      [
        0.904748260974884,
        "    freq_num = Counter(arr).most_common(1)[0][0]\n    return freq_num"
      ],
      [
        0.9041352868080139,
        "        if i < min_val:\n            min_val = i\n            frequency[min_val] = lst.count(min_val)"
      ],
      [
        0.9022012948989868,
        "    count = Counter(lst)\n    return min(count.items(), key=lambda x: x[1])[0]"
      ],
      [
        0.9017931222915649,
        "    counter = Counter(array)\n    freq = counter.most_common(1)[0]\n    return freq[0]"
      ],
      [
        0.9001501798629761,
        "    counter = collections.Counter(lst)\n    return min(counter, key=counter.get)"
      ],
      [
        0.8995397090911865,
        "    element_count = {}\n    for element in arr:\n        if element in element_count:\n            element_count[element] += 1\n        else:\n            element_count[element] = 1\n    least_common_element = None\n    least_common_count = float('inf')\n    for element, count in element_count.items():\n        if count < least_common_count:\n            least_common_element = element\n            least_common_count = count\n    return least_common_element"
      ]
    ],
    "MBPP/374": [
      [
        0.892249584197998,
        "    elif n == 2:\n        return 2\n    else:\n        return 2 * nth_value(n - 1)"
      ],
      [
        0.8913031220436096,
        "    if n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return 2 * nth_value(n - 1)"
      ],
      [
        0.8913031220436096,
        "    if n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return 2 * nth_value(n - 1)"
      ],
      [
        0.8902877569198608,
        "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n)"
      ],
      [
        0.8902877569198608,
        "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n)"
      ],
      [
        0.8893864750862122,
        "    if n not in pell_dict:\n        pell_dict[n] = 2 * pell(n - 1) + pell(n - 2)"
      ],
      [
        0.8889271020889282,
        "    if n not in pell_dict:\n        pell_dict[n] = 2 * pell(n - 1) + pell(n - 2)\n    return pell_dict[n]"
      ],
      [
        0.8885908126831055,
        "    if n < 4:\n        return padovan[:n]\n    else:\n        for i in range(3, n):\n            next_val = padovan[i - 2] + padovan[i - 3]\n            padovan.append(next_val)\n        return padovan"
      ],
      [
        0.8877418637275696,
        "    elif n == 2:\n        return 1\n    else:\n        return fibonacci_number(n - 1) + fibonacci_number(n - 2)"
      ],
      [
        0.8874779939651489,
        "    if n == 1:\n        return 1\n    else:\n        return nth_lucas(n - 1) + nth_lucas(n - 2)"
      ]
    ],
    "MBPP/375": [
      [
        0.9130901098251343,
        "    open_brackets = 0\n    swaps = 0\n    for c in s:\n        if c == '[':\n            open_brackets += 1\n        elif open_brackets == 0:\n            swaps += 1\n            open_brackets += 1\n        else:\n            open_brackets -= 1\n    return swaps"
      ],
      [
        0.9086722731590271,
        "    for c in s:\n        if c == '[':\n            open_brackets += 1\n        elif open_brackets == 0:\n            swaps += 1\n            open_brackets += 1\n        else:\n            open_brackets -= 1"
      ],
      [
        0.9018416404724121,
        "        if c == '[':\n            open_brackets += 1\n        elif open_brackets == 0:\n            swaps += 1\n            open_brackets += 1\n        else:\n            open_brackets -= 1"
      ],
      [
        0.897976279258728,
        "        elif open_brackets == 0:\n            swaps += 1\n            open_brackets += 1\n        else:\n            open_brackets -= 1"
      ],
      [
        0.8947635889053345,
        "    count_round = count_curly = count_square = 0\n    stack = []\n    for bracket in string:\n        stack.append(bracket)\n        if len(stack) < 2:\n            continue\n        if stack[-2] == '(' and stack[-1] == ')':\n            count_round += 1\n            stack = stack[:-2]\n        elif stack[-2] == '[' and stack[-1] == ']':\n            count_square += 1\n            stack = stack[:-2]\n        elif stack[-2] == '{' and stack[-1] == '}':\n            count_curly += 1\n            stack = stack[:-2]\n    return (count_round, count_square, count_curly)"
      ],
      [
        0.8946185111999512,
        "    ending_brackets = 0\n    for i in string:\n        if i == ')':\n            ending_brackets += 1\n    return ending_brackets"
      ],
      [
        0.8911243677139282,
        "    stack = []\n    invalid_count = 0\n    for char in string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                invalid_count += 1\n    invalid_count += len(stack)\n    return invalid_count"
      ],
      [
        0.8884943723678589,
        "    count = 0\n    stack = []\n    for c in string:\n        if c == '(' or c == '{':\n            stack.append(c)\n        elif c == ')' or c == '}':\n            if stack:\n                stack.pop()\n        elif not stack and c == char:\n            count += 1\n    return count"
      ],
      [
        0.8847668766975403,
        "    count = 0\n    stack = []\n    for c in input_string:\n        if c == '(':\n            stack.append(c)\n        elif c == ')' and stack:\n            stack.pop()\n        elif c == char and len(stack) == 1:\n            count += 1\n    return count"
      ],
      [
        0.8845423460006714,
        "    stack = []\n    count = 0\n    for p in s:\n        if p == '(':\n            stack.append(p)\n        elif p == ')':\n            if stack:\n                stack.pop()\n            else:\n                count += 1\n    count += len(stack)\n    return count"
      ]
    ],
    "MBPP/376": [
      [
        0.939914345741272,
        "    decimal_number = int(hex_number, 16)\n    if decimal_number % 2 == 0:\n        print(f'The hex number {hex_number} is Even.')\n    else:\n        print(f'The hex number {hex_number} is Odd.')"
      ],
      [
        0.9399102926254272,
        "    decimal_number = int(hex_number, 16)\n    if decimal_number % 2 == 0:\n        print(f'The hex number {hex_number} is Even.')\n    else:\n        print(f'The hex number {hex_number} is Odd.')"
      ],
      [
        0.9355310201644897,
        "    if decimal_number % 2 == 0:\n        print(f'The hex number {hex_number} is Even.')\n    else:\n        print(f'The hex number {hex_number} is Odd.')"
      ],
      [
        0.9354998469352722,
        "    if decimal_number % 2 == 0:\n        print(f'The hex number {hex_number} is Even.')\n    else:\n        print(f'The hex number {hex_number} is Odd.')"
      ],
      [
        0.9292422533035278,
        "    decimal_num = int(num, 16)\n    if decimal_num % 2 == 0:\n        return 'Even'\n    else:\n        return 'Odd'"
      ],
      [
        0.9167020916938782,
        "    hex_to_dec_map = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15, 'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 'f': 15}\n    last_hex_digit = hex_string[-1]\n    last_dec_digit = hex_to_dec_map[last_hex_digit]\n    odd_or_even = 'EVEN' if last_dec_digit % 2 == 0 else 'ODD'\n    return (odd_or_even, last_dec_digit)"
      ],
      [
        0.9091389179229736,
        "    if len(string) % 2 == 0:\n        print('The string is even.')\n    else:\n        print('The string is odd.')"
      ],
      [
        0.9091389179229736,
        "    if len(string) % 2 == 0:\n        print('The string is even.')\n    else:\n        print('The string is odd.')"
      ],
      [
        0.9031129479408264,
        "    elif int(num) & 1 == 0:\n        return 'Even'\n    else:\n        return 'Odd'"
      ]
    ],
    "MBPP/377": [
      [
        0.9246453046798706,
        "    p = 0\n    while 1 << p + 1 <= n:\n        p += 1\n    return p"
      ],
      [
        0.9171430468559265,
        "    while power <= n:\n        power *= 2"
      ],
      [
        0.9170946478843689,
        "    return math.ceil(math.log2(n))"
      ],
      [
        0.9167031049728394,
        "    if math.log2(n).is_integer():\n        return math.log2(n)\n    else:\n        return 'The number is not an exponent of two.'"
      ],
      [
        0.9162672758102417,
        "    log = 0\n    while n > 1:\n        n = n >> 1\n        log += 1\n    return log"
      ],
      [
        0.9161534905433655,
        "    if not isinstance(n, int):\n        raise ValueError('Input must be an integer')\n    if math.log2(n).is_integer():\n        return math.log2(n)\n    else:\n        return 'The number is not an exponent of two.'"
      ],
      [
        0.9150974154472351,
        "    while n % 2 == 0:\n        n //= 2"
      ],
      [
        0.9150974154472351,
        "    while n % 2 == 0:\n        n //= 2"
      ],
      [
        0.9146157503128052,
        "    return math.log2(n) + 1"
      ],
      [
        0.9132301211357117,
        "    x = 1\n    while n > x:\n        x = x * 2 + 1\n    return x - n"
      ]
    ],
    "MBPP/378": [
      [
        0.9490318894386292,
        "    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"
      ],
      [
        0.9490318894386292,
        "    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"
      ],
      [
        0.9490266442298889,
        "    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"
      ],
      [
        0.9490266442298889,
        "    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"
      ],
      [
        0.949022650718689,
        "    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"
      ],
      [
        0.949022650718689,
        "    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"
      ],
      [
        0.9490146040916443,
        "    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"
      ],
      [
        0.9490146040916443,
        "    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"
      ],
      [
        0.9490138292312622,
        "    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"
      ],
      [
        0.9490138292312622,
        "    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"
      ]
    ],
    "MBPP/379": [
      [
        0.8939078450202942,
        "    output_string = []\n    words = input_string.split()\n    for word in words:\n        output_string.append(prefix + word)\n    return ' '.join(output_string)"
      ],
      [
        0.8924462795257568,
        "    if not isinstance(prepend_str, str) or not isinstance(end_str, str):\n        raise ValueError('First and third arguments must be strings.')\n    if not isinstance(l, list):\n        raise ValueError('Second argument must be a list.')\n    result = []\n    for i in l:\n        if isinstance(i, str):\n            result.append(prepend_str + i + end_str)\n        else:\n            raise ValueError('Elements in the list must be strings.')\n    return result"
      ],
      [
        0.8917300701141357,
        "    new_list_of_strings = []\n    for string in list_of_strings:\n        new_string = string + string[0]\n        new_list_of_strings.append(new_string)\n    return new_list_of_strings"
      ],
      [
        0.890588104724884,
        "    modified_list = []\n    for item in lst:\n        modified_list.append(str(num) + item)\n    return modified_list"
      ],
      [
        0.8885721564292908,
        "    lst.insert(0, element)\n    return lst"
      ],
      [
        0.8853902816772461,
        "    new_list = [add_string + str(item) for item in list(list_string)]\n    return new_list"
      ],
      [
        0.885117769241333,
        "    return [x + string for x in my_list]"
      ],
      [
        0.8841792941093445,
        "    return [x + char for x in my_list]"
      ],
      [
        0.8841226100921631,
        "    words = string.split(' ')\n    result = []\n    for word in words:\n        result.append(prefix + word)\n    return ' '.join(result)"
      ],
      [
        0.8827763199806213,
        "    if new_element in my_list:\n        raise ValueError('Element already exists.')\n    else:\n        my_list.insert(0, new_element)\n        return my_list"
      ]
    ],
    "MBPP/380": [
      [
        0.9198483228683472,
        "    nested_dict = {}\n    for l1, l2, l3 in zip(list1, list2, list3):\n        if isinstance(l3, (list, tuple)) and (not isinstance(l3, str)):\n            l3 = {i: v for i, v in enumerate(l3)}\n        nested_dict[l1] = {l2: l3}\n    return nested_dict"
      ],
      [
        0.912442147731781,
        "    for l1, l2, l3 in zip(list1, list2, list3):\n        if isinstance(l3, (list, tuple)) and (not isinstance(l3, str)):\n            l3 = {i: v for i, v in enumerate(l3)}\n        nested_dict[l1] = {l2: l3}"
      ],
      [
        0.9120149612426758,
        "                for j in range(len(list_one[i])):\n                    nested_dict[j] = (list_one[i][j], list_two[i][j])"
      ],
      [
        0.9120149612426758,
        "                for j in range(len(list_one[i])):\n                    nested_dict[j] = (list_one[i][j], list_two[i][j])"
      ],
      [
        0.9115512371063232,
        "    nested_dict = {}\n    for item in lst:\n        key, value, inner_item = item\n        nested_dict[key] = {value: {inner_item[0]: inner_item[1]}}\n    return nested_dict"
      ],
      [
        0.9091472625732422,
        "                for j in range(min(len(list_one[i]), len(list_two[i]))):\n                    nested_dict[j] = (list_one[i][j], list_two[i][j])"
      ],
      [
        0.9082778692245483,
        "    for key, value in nested_dict.items():\n        if isinstance(value, list):\n            nested_dict[key] = convert_nested_list_to_dict(value)\n    return nested_dict"
      ],
      [
        0.9061629176139832,
        "    nested_dict = {}\n    for item in nested_list:\n        key = item[0]\n        value = item[1]\n        if isinstance(value, dict):\n            nested_dict[key] = convert_nested_dict(value)\n        else:\n            nested_dict[key] = value\n    return nested_dict"
      ],
      [
        0.9057766795158386,
        "    if len(keys) != len(values):\n        return 'Error: Inconsistent lengths of keys or values.'\n    nested_dict = {k[0]: {k[1]: v[1]} for k, v in zip(keys, values)}\n    return nested_dict"
      ],
      [
        0.9057608842849731,
        "    if len(keys) != len(values):\n        return 'Error: Inconsistent lengths of keys or values.'\n    nested_dict = {k[0]: {k[1]: v[1]} for k, v in zip(keys, values)}\n    return nested_dict"
      ]
    ],
    "MBPP/381": [
      [
        0.8997747898101807,
        "        if sum % 5 == 0:\n            return sum"
      ],
      [
        0.8954272270202637,
        "    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    fib_n_minus_1 = fibonacci_sum(n - 1)\n    fib_n_minus_2 = fibonacci_sum(n - 2)\n    current_fib = fib_n_minus_1 + fib_n_minus_2\n    if current_fib % 5 == 0:\n        return fib_n_minus_1 + fib_n_minus_2\n    else:\n        return current_fib + fib_n_minus_1 + fib_n_minus_2"
      ],
      [
        0.8941035866737366,
        "    power_of_x = [x ** (i + 1) for i in range(5)]\n    return sum(power_of_x)"
      ],
      [
        0.8926419019699097,
        "    elif n % 2 == 0:\n        b = 2 ** (n.bit_length() - 1)\n        return 3 * A(n // 2) + 5 * A(n - b)\n    else:\n        return A(n // 2)"
      ],
      [
        0.8919816613197327,
        "    max_sum = current_sum = 0\n    max_sum = max(max_sum, current_sum)\n    max_sum = max(max_sum, current_sum)\n    max_sum = max(max_sum, current_sum)\n    max_sum = max(max_sum, current_sum)\n    max_sum = max(max_sum, current_sum)\n    max_sum = max(max_sum, current_sum)\n    return max_sum"
      ],
      [
        0.8898497223854065,
        "    if n == 0:\n        return 0\n    nums = [0] * (n + 1)\n    nums[1] = 1\n    for i in range(2, n + 1):\n        nums[i] = nums[i // 2] if i % 2 == 0 else nums[i // 2] + nums[i // 2 + 1]\n    return max(nums)"
      ],
      [
        0.888695240020752,
        "        if num % 5 == 0:\n            return num"
      ],
      [
        0.8886136412620544,
        "    while n >= 5:\n        n //= 5\n        count += n"
      ],
      [
        0.8885824680328369,
        "    while n >= 5:\n        n //= 5\n        count += n"
      ],
      [
        0.8885804414749146,
        "    while n >= 5:\n        n //= 5\n        count += n"
      ]
    ],
    "MBPP/382": [
      [
        0.9074091911315918,
        "    max_len = 0\n    longest_string = ''\n    for string in list:\n        if len(string) > max_len:\n            max_len = len(string)\n            longest_string = string\n    print(longest_string)"
      ],
      [
        0.9047771692276001,
        "    return max(list, key=len)"
      ],
      [
        0.9020928144454956,
        "    longest_string = ''\n    for word in list1:\n        if len(word) > len(longest_string):\n            longest_string = word\n    return longest_string"
      ],
      [
        0.9003983736038208,
        "    max_length = -1\n    index = -1\n    for i in range(len(lst)):\n        if len(lst[i]) > max_length:\n            max_length = len(lst[i])\n            index = i\n    return (max_length, index)"
      ],
      [
        0.8998948931694031,
        "    if not names:\n        return ([], 'The list is empty.')\n    lengths = [len(name) for name in names]\n    max_length = max(lengths)\n    longest_names = [name for name in names if len(name) == max_length]\n    if len(longest_names) > 1:\n        result = 'The longest names are ' + ', '.join(longest_names) + ' with a length of ' + str(max_length) + '.'\n    else:\n        result = 'The longest name is ' + longest_names[0] + ' with a length of ' + str(max_length) + '.'\n    return (lengths, result)"
      ],
      [
        0.8991974592208862,
        "    max_sum = None\n    max_list = None\n    for lst in list_of_lists:\n        if max_sum is None or sum(lst) > max_sum:\n            max_sum = sum(lst)\n            max_list = lst\n    return max_list"
      ],
      [
        0.8991069197654724,
        "    return max(list1, key=len)"
      ],
      [
        0.8988555669784546,
        "    for sublist in list:\n        maxLength = max(maxLength, len(sublist))"
      ],
      [
        0.8983852863311768,
        "    longest = max(input_list, key=len)\n    return longest"
      ],
      [
        0.8983702659606934,
        "    longest = max(input_list, key=len)\n    return longest"
      ]
    ],
    "MBPP/383": [
      [
        0.8926525115966797,
        "    distinct_elements = []\n    for element in collection:\n        if isinstance(element, tuple):\n            if element not in distinct_elements:\n                distinct_elements.append(element)\n    return distinct_elements"
      ],
      [
        0.8894618153572083,
        "    for element in collection:\n        if isinstance(element, tuple):\n            if element not in distinct_elements:\n                distinct_elements.append(element)"
      ],
      [
        0.8892388939857483,
        "    seen = set()\n    duplicates = set()\n    for item in input_tuple:\n        if item in seen:\n            duplicates.add(item)\n        seen.add(item)\n    return (len(duplicates) > 0, duplicates)"
      ],
      [
        0.8886123895645142,
        "        if isinstance(element, tuple):\n            if element not in distinct_elements:\n                distinct_elements.append(element)"
      ],
      [
        0.8882184028625488,
        "        if is_distinct(i):\n            count += 1"
      ],
      [
        0.8856731653213501,
        "    distinct_list = []\n    for item in lst:\n        if item not in distinct_list:\n            distinct_list.append(item)\n    return distinct_list"
      ],
      [
        0.8855116367340088,
        "        if element not in distinct_list:\n            distinct_list.append(element)"
      ],
      [
        0.885132908821106,
        "    for i in my_list:\n        if i not in distinct_list:\n            distinct_list.append(i)"
      ],
      [
        0.8847313523292542,
        "    if len(tup) == len(set(tup)):\n        return False\n    else:\n        return True"
      ],
      [
        0.8847313523292542,
        "    if len(tup) == len(set(tup)):\n        return False\n    else:\n        return True"
      ]
    ],
    "MBPP/384": [
      [
        0.935464084148407,
        "    d = {}\n    for ch in s:\n        if ch in d:\n            d[ch] += 1\n        else:\n            d[ch] = 1\n    for ch in s:\n        if d[ch] == 1:\n            return ch\n    return 'All characters are repeating'"
      ],
      [
        0.9346743822097778,
        "    char_count = {}\n    for char in reversed(input_string):\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in reversed(input_string):\n        if char_count[char] == 1:\n            return char\n    return 'All are Repeated'"
      ]
    ],
    "MBPP/385": [
      [
        0.923841118812561,
        "    if len(string) < 2:\n        return False\n    return string[0] == string[-1]"
      ],
      [
        0.9086869955062866,
        "    output_list = []\n    for string in input_list:\n        if string[0] == string[-1]:\n            output_list.append(string)\n    return output_list"
      ],
      [
        0.9086869955062866,
        "    output_list = []\n    for string in input_list:\n        if string[0] == string[-1]:\n            output_list.append(string)\n    return output_list"
      ],
      [
        0.9033020734786987,
        "    word_list = my_string.split()\n    for word in word_list:\n        if word[0] != word[-1]:\n            return False\n    return True"
      ],
      [
        0.9031336307525635,
        "    my_string = ''.join((char for char in input_str if char not in string.punctuation))\n    words = my_string.split()\n    count = 0\n    for word in words:\n        if word[0].lower() == word[-1].lower():\n            count += 1\n    return (count == len(words), count)"
      ],
      [
        0.9028763771057129,
        "    input_string = input_string.lower()\n    start = 0\n    end = len(input_string) - 1\n    while start < end:\n        while not input_string[start].isalnum():\n            start += 1\n            if start >= end:\n                break\n        while not input_string[end].isalnum():\n            end -= 1\n            if start >= end:\n                break\n        if input_string[start] != input_string[end]:\n            return False\n        start += 1\n        end -= 1\n    return True"
      ],
      [
        0.9028581380844116,
        "    exclude_chars = set(exclude_chars) if exclude_chars else set()\n    for word in input_string.split():\n        if any((ch in exclude_chars for ch in word)):\n            continue\n        if word[0] != word[-1]:\n            return False\n    return True"
      ],
      [
        0.9018889665603638,
        "    for string in input_list:\n        if string[0] == string[-1]:\n            output_list.append(string)"
      ],
      [
        0.9018620848655701,
        "    for string in input_list:\n        if string[0] == string[-1]:\n            output_list.append(string)"
      ],
      [
        0.9018408060073853,
        "    cleaned_arr = [str(elem).lower() for elem in arr if str(elem).isalnum()]\n    length = len(cleaned_arr)\n    if length % 2 == 1:\n        middle_index = length // 2\n        left = cleaned_arr[:middle_index]\n        right = cleaned_arr[middle_index + 1:]\n    else:\n        left = cleaned_arr[:length // 2]\n        right = cleaned_arr[length // 2:]\n    if left and all((elem == left[0] for elem in left)) and all((elem == right[0] for elem in right)):\n        return True\n    return False"
      ]
    ],
    "MBPP/386": [
      [
        0.9354052543640137,
        "    elif num3 > num2:\n        median = num2\n    elif num3 > num1:\n        median = num3\n    else:\n        median = num1"
      ],
      [
        0.9337091445922852,
        "    elif num3 > num1:\n        median = num3\n    else:\n        median = num1"
      ],
      [
        0.931890070438385,
        "        if num3 > num1:\n            median = num1\n        elif num3 > num2:\n            median = num3\n        else:\n            median = num2"
      ],
      [
        0.9298149347305298,
        "    numbers = [a, b, c]\n    numbers.sort()\n    median_index = len(numbers) // 2\n    return numbers[median_index]"
      ],
      [
        0.9275199174880981,
        "    if num1 > num2:\n        if num3 > num1:\n            median = num1\n        elif num3 > num2:\n            median = num3\n        else:\n            median = num2\n    elif num3 > num2:\n        median = num2\n    elif num3 > num1:\n        median = num3\n    else:\n        median = num1"
      ],
      [
        0.9274661540985107,
        "        elif num3 > num2:\n            median = num3\n        else:\n            median = num2"
      ],
      [
        0.926321268081665,
        "    if num1 > num2:\n        if num3 > num1:\n            median = num1\n        elif num3 > num2:\n            median = num3\n        else:\n            median = num2\n    elif num3 > num2:\n        median = num2\n    elif num3 > num1:\n        median = num3\n    else:\n        median = num1\n    return median"
      ],
      [
        0.9215506315231323,
        "    elif b <= a <= c or c <= a <= b:\n        median = a\n    else:\n        median = c"
      ],
      [
        0.9214219450950623,
        "    if a <= b <= c or c <= b <= a:\n        median = b\n    elif b <= a <= c or c <= a <= b:\n        median = a\n    else:\n        median = c\n    return median"
      ],
      [
        0.9211783409118652,
        "    if a <= b <= c or c <= b <= a:\n        median = b\n    elif b <= a <= c or c <= a <= b:\n        median = a\n    else:\n        median = c"
      ]
    ],
    "MBPP/387": [],
    "MBPP/388": [
      [
        0.8992046117782593,
        "    xor_result = boolean1 ^ boolean2\n    binary_representation = format(int(xor_result), '01b')\n    return (xor_result, binary_representation)"
      ],
      [
        0.8945474624633789,
        "    result = []\n    for i in range(len(a)):\n        result.append(a[i] ^ b[i])\n    return result"
      ],
      [
        0.8945187330245972,
        "    a_int = int(a, 2)\n    b_int = int(b, 2)\n    xor_result = a_int ^ b_int\n    return format(xor_result, 'b')"
      ],
      [
        0.8904866576194763,
        "    a = int(a, 2)\n    b = int(b, 2)\n    result = a ^ b\n    return format(result, 'b')"
      ],
      [
        0.8895264267921448,
        "    for i in range(len(a)):\n        result.append(a[i] ^ b[i])"
      ],
      [
        0.8888170719146729,
        "    xor_result = int(a, 2) ^ int(b, 2)\n    xor_result_str = format(xor_result, 'b').zfill(len(a))\n    return xor_result_str"
      ],
      [
        0.8886802792549133,
        "    n = max(len(num1), len(num2))\n    num1 = num1.zfill(n)\n    num2 = num2.zfill(n)\n    num1 = int(num1, 2)\n    num2 = int(num2, 2)\n    xor_result = num1 ^ num2\n    xor_binary = bin(xor_result)[2:].zfill(n)\n    xor_list = [int(bit) for bit in xor_binary]\n    return xor_list"
      ],
      [
        0.8881639242172241,
        "    result = []\n    for i in range(len(a)):\n        bit_a = int(a[i])\n        bit_b = int(b[i])\n        xor_result = bit_a ^ bit_b\n        result.append(str(xor_result))\n    return result"
      ],
      [
        0.8876113295555115,
        "    bitwise_and = a & b\n    bitwise_or = a | b\n    bitwise_xor = a ^ b\n    return [bitwise_and, bitwise_or, bitwise_xor]"
      ],
      [
        0.8835170865058899,
        "    bin1 = bin(int(num1, 16))[2:].zfill(4)\n    bin2 = bin(int(num2, 16))[2:].zfill(4)\n    aggregate = 0\n    for b1, b2 in zip(bin1, bin2):\n        xorResult = int(b1) ^ int(b2)\n        aggregate += xorResult\n    return aggregate"
      ]
    ],
    "MBPP/389": [
      [
        0.9134389162063599,
        "    frequency_list = []\n    for item in my_list:\n        if item not in frequency_list:\n            frequency_list.append(item)\n    for i in range(0, len(frequency_list)):\n        frequency_list[i] = (frequency_list[i], my_list.count(frequency_list[i]))\n    return frequency_list"
      ],
      [
        0.9047050476074219,
        "    counter = Counter(input_list)\n    unique_elements = list(OrderedDict.fromkeys(input_list))\n    output_list = [(element, counter[element]) for element in unique_elements]\n    return output_list"
      ],
      [
        0.9044874310493469,
        "    freq_dict = {}\n    for item in list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict"
      ],
      [
        0.9039968252182007,
        "    unique_elements = []\n    element_frequency = {}\n    for num in list_of_nums:\n        if num not in unique_elements:\n            unique_elements.append(num)\n            element_frequency[num] = 1\n        else:\n            element_frequency[num] += 1\n    return (unique_elements, element_frequency)"
      ],
      [
        0.9036407470703125,
        "    for i in range(0, len(frequency_list)):\n        frequency_list[i] = (frequency_list[i], my_list.count(frequency_list[i]))"
      ],
      [
        0.9026572704315186,
        "    frequency = {}\n    for item in my_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency"
      ],
      [
        0.9025712013244629,
        "    lst = flatten(lst)\n    counts = dict()\n    for sublist in lst:\n        if isinstance(sublist, list):\n            sublist = tuple(flatten(sublist))\n        if isinstance(sublist, tuple):\n            counts[sublist] = counts.get(sublist, 0) + 1\n    return counts"
      ],
      [
        0.9018157124519348,
        "    count_obj = Counter(input_tuple)\n    my_dict = dict(count_obj)\n    unique_dict = {key: 1 for key in my_dict.keys()}\n    return (unique_dict, my_dict)"
      ],
      [
        0.9017921686172485,
        "    count_obj = Counter(input_tuple)\n    my_dict = dict(count_obj)\n    unique_dict = {key: 1 for key in my_dict.keys()}\n    return (unique_dict, my_dict)"
      ],
      [
        0.90166175365448,
        "    lst = [tuple(flatten(sublist)) for sublist in lst if isinstance(sublist, list)]\n    return {t: lst.count(t) for t in set(lst)}"
      ]
    ],
    "MBPP/390": [
      [
        0.8935002684593201,
        "    for a, b in tpl1:\n        for c, d in tpl2:\n            return (a + c, b + d)"
      ],
      [
        0.8935002684593201,
        "    for a, b in tpl1:\n        for c, d in tpl2:\n            return (a + c, b + d)"
      ],
      [
        0.8911552429199219,
        "    additions = []\n    for i in range(len(list1)):\n        additions.append(list1[i] + list2[i])\n    return additions"
      ],
      [
        0.8900386095046997,
        "        for c, d in tpl2:\n            return (a + c, b + d)"
      ],
      [
        0.8887782096862793,
        "    sum = 0\n    for sub_list in nested_list:\n        for element in sub_list:\n            sum += element\n    return sum"
      ],
      [
        0.8887152671813965,
        "    result = [x + y for x, y in zip(arr1, arr2)]\n    return result"
      ],
      [
        0.8885400295257568,
        "    for i in tuples:\n        if isinstance(i, tuple):\n            cum_sum = recursive_sum(i, cum_sum)\n        elif isinstance(i, (int, float)):\n            cum_sum += i\n    return cum_sum"
      ],
      [
        0.88801109790802,
        "    result = []\n    for i in range(len(arr1)):\n        result.append([])\n        for j in range(len(arr1[0])):\n            result[i].append(arr1[i][j] + arr2[i][j])\n    return result"
      ],
      [
        0.8879587650299072,
        "    result = []\n    for row1, row2 in zip(matrix1, matrix2):\n        result_row = []\n        for element1, element2 in zip(row1, row2):\n            result_row.append(element1 + element2)\n        result.append(result_row)\n    return result"
      ],
      [
        0.8867958784103394,
        "    total = 0\n    for sublist in nested_list:\n        for item in sublist:\n            total += item\n    return total"
      ]
    ],
    "MBPP/391": [
      [
        0.8920645713806152,
        "    while r > 0:\n        num = num % p * (n % p) % p\n        n -= 1\n        r -= 1"
      ],
      [
        0.8919825553894043,
        "    num = 1\n    while r > 0:\n        num = num % p * (n % p) % p\n        n -= 1\n        r -= 1\n    den = 1\n    r = 7\n    while r > 0:\n        den = den % p * (r % p) % p\n        r -= 1\n    den_inv = modInverse(den, p)\n    return num * den_inv % p"
      ],
      [
        0.8900355696678162,
        "    elif n == 1:\n        return 1 % m"
      ],
      [
        0.890030026435852,
        "    elif n == 1:\n        return 1 % m"
      ],
      [
        0.8894479274749756,
        "    return power(n, p - 2, p)"
      ],
      [
        0.8871378898620605,
        "    for i in range(k):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p"
      ],
      [
        0.8838740587234497,
        "    dp = [0] * (p + 1)\n    dp[0] = 1\n    for i in range(1, p + 1):\n        dp[i] = dp[i - 1] * i % q\n    return dp[p]"
      ],
      [
        0.883350133895874,
        "    if r == 0:\n        return int(n == 0)"
      ],
      [
        0.883350133895874,
        "    if r == 0:\n        return int(n == 0)"
      ],
      [
        0.8831297159194946,
        "    while r > 0:\n        den = den % p * (r % p) % p\n        r -= 1"
      ]
    ],
    "MBPP/392": [
      [
        0.9374516010284424,
        "    pattern = re.compile('http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\\\\\\\(\\\\\\\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+')\n    match = re.match(pattern, url)\n    if match:\n        print('The URL is valid.')\n    else:\n        print('The URL is invalid.')"
      ],
      [
        0.9341697692871094,
        "    if re.match(regex, raw_url) is None:\n        print('Invalid URL')\n    else:\n        print('Valid URL')"
      ],
      [
        0.9341510534286499,
        "    if re.match(regex, raw_url) is None:\n        print('Invalid URL')\n    else:\n        print('Valid URL')"
      ],
      [
        0.9338212013244629,
        "    if pattern.match(url):\n        print('URL is valid')\n    else:\n        print('URL is invalid')"
      ],
      [
        0.9331731796264648,
        "    pattern = re.compile(\"https://www\\\\.[a-z0-9.-]+\\\\.com(/[a-z0-9-._~:/?#@[\\\\\\\\\\\\]!$&\\\\'()*+,;=.]+)*\")\n    if pattern.match(url):\n        print('URL is valid')\n    else:\n        print('URL is invalid')"
      ],
      [
        0.9321190118789673,
        "    if match:\n        print('The URL is valid.')\n    else:\n        print('The URL is invalid.')"
      ],
      [
        0.9298532605171204,
        "    if is_valid_url(url):\n        print('URL is valid.')\n    else:\n        print('URL is not valid.')"
      ],
      [
        0.9298514127731323,
        "    if is_valid_url(url):\n        print('URL is valid.')\n    else:\n        print('URL is not valid.')"
      ],
      [
        0.9279637336730957,
        "    regex = '(?i)\\\\b((?:[a-z][\\\\w-]+:(?:/{1,3}|[a-z0-9%])|www\\\\d{0,3}[.]|[a-z0-9.\\\\-]+[.][a-z]{2,4}/)(?:[^\\\\s()<>]+|\\\\(([^\\\\s()<>]+|(\\\\([^\\\\s()<>]+\\\\)))*\\\\))+(?:\\\\(([^\\\\s()<>]+|(\\\\([^\\\\s()<>]+\\\\)))*\\\\)|[^\\\\s`!()\\\\[\\\\]{};:\\'\\\\\".,<>?\u00ab\u00bb\u201c\u201d\u2018\u2019]))'\n    if re.search(regex, url):\n        return True\n    else:\n        return False"
      ],
      [
        0.9268497228622437,
        "    if not regex.match(url):\n        return (False, 'Invalid URL format.')"
      ]
    ],
    "MBPP/393": [
      [
        0.9251693487167358,
        "    return min(num1, num2)"
      ],
      [
        0.9067959785461426,
        "    min_number = min(a, b, c)\n    return min_number"
      ],
      [
        0.9067547917366028,
        "    if num1 < num2:\n        return num1\n    else:\n        return num2"
      ],
      [
        0.9067547917366028,
        "    if num1 < num2:\n        return num1\n    else:\n        return num2"
      ],
      [
        0.9067513346672058,
        "    if num1 < num2:\n        return num1\n    else:\n        return num2"
      ],
      [
        0.9067513346672058,
        "    if num1 < num2:\n        return num1\n    else:\n        return num2"
      ],
      [
        0.906746506690979,
        "    if num1 < num2:\n        return num1\n    else:\n        return num2"
      ],
      [
        0.906746506690979,
        "    if num1 < num2:\n        return num1\n    else:\n        return num2"
      ],
      [
        0.9067151546478271,
        "    return min(a, b)"
      ],
      [
        0.9067145586013794,
        "    return min(a, b)"
      ]
    ],
    "MBPP/394": [
      [
        0.9079071283340454,
        "    if check_presence:\n        return element in my_tuple\n    else:\n        return element not in my_tuple"
      ],
      [
        0.9079071283340454,
        "    if check_presence:\n        return element in my_tuple\n    else:\n        return element not in my_tuple"
      ],
      [
        0.9026461839675903,
        "    if not lst:\n        return False\n    for num in lst:\n        if num == element:\n            return True\n    return False"
      ],
      [
        0.9009613394737244,
        "    if element in lst:\n        return True\n    else:\n        return False"
      ],
      [
        0.9009613394737244,
        "    if element in lst:\n        return True\n    else:\n        return False"
      ],
      [
        0.8992576599121094,
        "    if element in lst:\n        return 'Exists'\n    else:\n        return 'Does not exist'"
      ],
      [
        0.8992576599121094,
        "    if element in lst:\n        return 'Exists'\n    else:\n        return 'Does not exist'"
      ],
      [
        0.89921635389328,
        "    if element in lst:\n        return 'Exists'\n    else:\n        return 'Does not exist'"
      ],
      [
        0.89921635389328,
        "    if element in lst:\n        return 'Exists'\n    else:\n        return 'Does not exist'"
      ],
      [
        0.898626446723938,
        "    if element in mylist:\n        return True\n    return False"
      ]
    ],
    "MBPP/395": [
      [
        0.913273811340332,
        "    parity = 0\n    while n:\n        parity ^= n & 1\n        n >>= 1\n    return parity"
      ],
      [
        0.9110813736915588,
        "    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    power = 1\n    while power <= n:\n        power *= 2\n    power /= 2\n    return 1 - parity(n - power)"
      ],
      [
        0.9100512266159058,
        "    if n == 0:\n        return 0\n    else:\n        return n & 1 ^ check_parity(n >> 1)"
      ],
      [
        0.9100512266159058,
        "    if n == 0:\n        return 0\n    else:\n        return n & 1 ^ check_parity(n >> 1)"
      ],
      [
        0.9100314378738403,
        "    if n == 0:\n        return 0\n    else:\n        return n & 1 ^ check_parity(n >> 1)"
      ],
      [
        0.9100314378738403,
        "    if n == 0:\n        return 0\n    else:\n        return n & 1 ^ check_parity(n >> 1)"
      ],
      [
        0.9097632169723511,
        "    while n:\n        parity ^= n & 1\n        n >>= 1"
      ],
      [
        0.9064509272575378,
        "    num = abs(num)\n    if num - int(num) != 0:\n        return 'Number is not an integer'\n    elif int(num) & 1 == 0:\n        return 'Even'\n    else:\n        return 'Odd'"
      ],
      [
        0.9064494371414185,
        "    num = abs(num)\n    if num - int(num) != 0:\n        return 'Number is not an integer'\n    elif int(num) & 1 == 0:\n        return 'Even'\n    else:\n        return 'Odd'"
      ],
      [
        0.9028930068016052,
        "    elif int(num) & 1 == 0:\n        return 'Even'\n    else:\n        return 'Odd'"
      ]
    ],
    "MBPP/396": [
      [
        0.9104344844818115,
        "    num_str = str(n)\n    num_permutations = sorted(set((int(''.join(p)) for p in permutations(num_str))))\n    index = num_permutations.index(n)\n    if index + 1 < len(num_permutations) and num_permutations[index + 1] <= 2 ** 31 - 1:\n        return num_permutations[index + 1]\n    return -1"
      ],
      [
        0.901959240436554,
        "    n = len(num)\n    first_half = num[:(n + 1) // 2]\n    candidates = sorted(set((int(''.join(p)) for p in permutations(first_half))))\n    for c in candidates:\n        c_str = str(c)\n        second_half = c_str[::-1]\n        if n % 2 == 1:\n            second_half = second_half[1:]\n        candidate_str = c_str + second_half\n        if candidate_str > num:\n            return candidate_str\n    return ''"
      ],
      [
        0.9019523859024048,
        "    n = len(num)\n    first_half = num[:(n + 1) // 2]\n    candidates = sorted(set((int(''.join(p)) for p in permutations(first_half))))\n    for c in candidates:\n        c_str = str(c)\n        second_half = c_str[::-1]\n        if n % 2 == 1:\n            second_half = second_half[1:]\n        candidate_str = c_str + second_half\n        if candidate_str > num:\n            return candidate_str\n    return ''"
      ],
      [
        0.8988716006278992,
        "    num_str = str(number)\n    sorted_digits = sorted(num_str, reverse=True)\n    max_num = int(''.join(sorted_digits))\n    return max_num"
      ],
      [
        0.8980096578598022,
        "    n_str = [c for c in str(n)]\n    i = len(n_str) - 1\n    while i > 0:\n        if n_str[i] < n_str[i - 1]:\n            n_str[i - 1] = chr(ord(n_str[i - 1]) - 1)\n            for j in range(i, len(n_str)):\n                n_str[j] = '9'\n        i -= 1\n    return int(''.join(n_str))"
      ],
      [
        0.8965716361999512,
        "    digits = [int(d) for d in str(n)]\n    perm_digits = list(permutations(digits))\n    perm_numbers = sorted([int(''.join(map(str, perm))) for perm in perm_digits])\n    cnt = 0\n    for x in perm_numbers:\n        if x > n and x <= 2 ** 31 - 1:\n            if cnt == 0:\n                smallest_greater = x\n            cnt += 1\n    if cnt == 0:\n        return (-1, 0)\n    else:\n        permutation_cnt = factorial(len(digits)) // (2 * factorial(len(digits) - 2)) - 1\n        return (smallest_greater, min(permutation_cnt, cnt - 1))"
      ],
      [
        0.8965632915496826,
        "    digits = [int(d) for d in str(n)]\n    perm_digits = list(permutations(digits))\n    perm_numbers = sorted([int(''.join(map(str, perm))) for perm in perm_digits])\n    cnt = 0\n    for x in perm_numbers:\n        if x > n and x <= 2 ** 31 - 1:\n            if cnt == 0:\n                smallest_greater = x\n            cnt += 1\n    if cnt == 0:\n        return (-1, 0)\n    else:\n        permutation_cnt = factorial(len(digits)) // (2 * factorial(len(digits) - 2)) - 1\n        return (smallest_greater, min(permutation_cnt, cnt - 1))"
      ],
      [
        0.8946132659912109,
        "    digits = [int(i) for i in str(num)]\n    digits.sort(reverse=True)\n    largest = 0\n    for i in digits:\n        largest = largest * 10 + i\n    return largest"
      ],
      [
        0.8939120769500732,
        "    num_str = list(str(num))\n    last = {int(v): i for i, v in enumerate(num_str)}\n    for i, v in enumerate(num_str):\n        for d in range(9, int(v), -1):\n            if last.get(d, -1) > i:\n                num_str[i], num_str[last[d]] = (num_str[last[d]], num_str[i])\n                return int(''.join(num_str))\n    return num"
      ],
      [
        0.8906576633453369,
        "    for i, v in enumerate(num_str):\n        for d in range(9, int(v), -1):\n            if last.get(d, -1) > i:\n                num_str[i], num_str[last[d]] = (num_str[last[d]], num_str[i])\n                return int(''.join(num_str))"
      ]
    ],
    "MBPP/397": [
      [
        0.9012144804000854,
        "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for n1 in nums1:\n        for n2 in nums2:\n            if len(heap) < k:\n                heapq.heappush(heap, (-n1 - n2, [n1, n2]))\n            elif n1 + n2 < -heap[0][0]:\n                heapq.heappop(heap)\n                heapq.heappush(heap, (-n1 - n2, [n1, n2]))\n    return [pair for _, pair in heap]"
      ],
      [
        0.8998153805732727,
        "    i = 0\n    j = 0\n    counter = 1\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j] and counter != k:\n            i += 1\n            counter += 1\n        elif arr2[j] < arr1[i] and counter != k:\n            j += 1\n            counter += 1\n        else:\n            return min(arr1[i], arr2[j])\n    while i < len(arr1):\n        if counter != k:\n            i += 1\n            counter += 1\n        else:\n            return arr1[i]\n    while j < len(arr2):\n        if counter != k:\n            j += 1\n            counter += 1\n        else:\n            return arr2[j]"
      ],
      [
        0.8979055285453796,
        "        elif arr2[j] < arr1[i] and counter != k:\n            j += 1\n            counter += 1\n        else:\n            return min(arr1[i], arr2[j])"
      ],
      [
        0.8979001045227051,
        "    pairs = []\n    list1.sort()\n    list2.sort()\n    i = 0\n    j = len(list2) - 1\n    while i < len(list1) and j >= 0:\n        num1 = list1[i]\n        num2 = list2[j]\n        current_sum = num1 + num2\n        if current_sum == k:\n            if abs(num1 - num2) >= threshold:\n                pairs.append((num1, num2))\n            i += 1\n            j -= 1\n        elif current_sum < k:\n            i += 1\n        else:\n            j -= 1\n    return sorted(pairs, key=lambda x: sum(x))"
      ],
      [
        0.8973088264465332,
        "    pairs = []\n    for num1 in list1:\n        for num2 in list2:\n            if num1 != num2 and abs(num1 - num2) >= threshold and (num1 + num2 == k):\n                pairs.append((num1, num2))\n    return pairs"
      ],
      [
        0.8951384425163269,
        "        if arr1[i] < arr2[j] and counter != k:\n            i += 1\n            counter += 1\n        elif arr2[j] < arr1[i] and counter != k:\n            j += 1\n            counter += 1\n        else:\n            return min(arr1[i], arr2[j])"
      ],
      [
        0.8938764333724976,
        "    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j] and counter != k:\n            i += 1\n            counter += 1\n        elif arr2[j] < arr1[i] and counter != k:\n            j += 1\n            counter += 1\n        else:\n            return min(arr1[i], arr2[j])"
      ],
      [
        0.8937983512878418,
        "    for num1 in list1:\n        for num2 in list2:\n            if num1 != num2 and abs(num1 - num2) >= threshold and (num1 + num2 == k):\n                pairs.append((num1, num2))"
      ],
      [
        0.8937508463859558,
        "    merged_array = sorted(A + B)\n    return merged_array[k - 1]"
      ],
      [
        0.8926255702972412,
        "    if not nums1 or not nums2:\n        return []\n    heap = [(nums1[i] + nums2[0], i, 0) for i in range(min(k, len(nums1)))]\n    heapq.heapify(heap)\n    result = []\n    while k > 0 and heap:\n        s, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n        k -= 1\n    return result"
      ]
    ],
    "MBPP/398": [
      [
        0.8975342512130737,
        "    pair_product = []\n    for i in range(len(arr) - 1):\n        pair_product.append(((arr[i], arr[i + 1]), arr[i] * arr[i + 1]))\n    min_product = min(pair_product, key=lambda x: x[1])\n    return min_product"
      ],
      [
        0.8954095840454102,
        "    products = []\n    for pair in pairs:\n        product = pair[0] * pair[1]\n        products.append(product)\n    return products"
      ],
      [
        0.891959547996521,
        "        if product < min_product:\n            min_product = product"
      ],
      [
        0.8907710909843445,
        "    if len(lst) < 2:\n        return None\n    max_product = float('-inf')\n    max_pair = None\n    for pair in combinations(lst, 2):\n        product = pair[0] * pair[1]\n        if product > max_product:\n            max_product = product\n            max_pair = pair\n    return list(max_pair)"
      ],
      [
        0.889107346534729,
        "    max_product = float('-inf')\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] * lst[j] > max_product:\n                max_product = lst[i] * lst[j]\n                pair = (lst[i], lst[j])\n    return pair"
      ],
      [
        0.8876655101776123,
        "    for pair in combinations(lst, 2):\n        product = pair[0] * pair[1]\n        if product > max_product:\n            max_product = product\n            max_pair = pair"
      ]
    ],
    "MBPP/399": [
      [
        0.9059010744094849,
        "    min_value = lst[0]\n    for value in lst:\n        if value < min_value:\n            min_value = value\n    return min_value"
      ],
      [
        0.9047254920005798,
        "    minValue = list[0]\n    for i in range(1, len(list)):\n        if list[i] < minValue:\n            minValue = list[i]\n    return minValue"
      ],
      [
        0.9045851230621338,
        "    min_value = float('inf')\n    for arg in args:\n        if arg < min_value:\n            min_value = arg\n    return min_value"
      ],
      [
        0.9020658135414124,
        "    min_val = list[0]\n    for num in list:\n        if num < min_val:\n            min_val = num\n    return min_val"
      ],
      [
        0.9020485281944275,
        "    min_val = list[0]\n    for num in list:\n        if num < min_val:\n            min_val = num\n    return min_val"
      ],
      [
        0.9010846614837646,
        "    try:\n        nums = [abs(num) for num in test_list if type(num) == float or type(num) == int]\n        if len(nums) == 0:\n            return None\n        else:\n            return min(nums)\n    except ValueError:\n        print('Error: List contains invalid values.')\n    except Exception as e:\n        print(f'An error occurred: {e}')"
      ],
      [
        0.9010846614837646,
        "    try:\n        nums = [abs(num) for num in test_list if type(num) == float or type(num) == int]\n        if len(nums) == 0:\n            return None\n        else:\n            return min(nums)\n    except ValueError:\n        print('Error: List contains invalid values.')\n    except Exception as e:\n        print(f'An error occurred: {e}')"
      ],
      [
        0.9009236097335815,
        "    integers = []\n    for arg in args:\n        if isinstance(arg, int):\n            integers.append(arg)\n    if len(integers) == 0:\n        raise Exception('No integers were provided')\n    else:\n        return min(integers)"
      ],
      [
        0.9009088277816772,
        "    integers = []\n    for arg in args:\n        if isinstance(arg, int):\n            integers.append(arg)\n    if len(integers) == 0:\n        raise Exception('No integers were provided')\n    else:\n        return min(integers)"
      ],
      [
        0.8998000621795654,
        "    min_val = input_list[0]\n    for i in range(1, len(input_list)):\n        if input_list[i] < min_val:\n            min_val = input_list[i]\n    return min_val"
      ]
    ],
    "MBPP/400": [
      [
        0.9128379821777344,
        "    camel_case = ''\n    for word in str.split():\n        camel_case += word.capitalize()\n    return camel_case"
      ],
      [
        0.9124648571014404,
        "    words = snake_case.split('_')\n    camel_case = words[0]\n    for word in words[1:]:\n        camel_case += word.capitalize()\n    return camel_case"
      ]
    ],
    "MBPP/401": [
      [
        0.9250654578208923,
        "    odd_list = []\n    for num in my_list:\n        if num % 2 != 0:\n            odd_list.append(num)\n    return odd_list"
      ],
      [
        0.9242225885391235,
        "    odd_list = []\n    for number in original_list:\n        if number % 2 != 0:\n            odd_list.append(number)\n    return odd_list"
      ],
      [
        0.9222505688667297,
        "    if not input_list:\n        return 'Input list is empty.'\n    odd_numbers = []\n    for num in input_list:\n        if num % 2 != 0:\n            odd_numbers.append(num)\n    return odd_numbers"
      ],
      [
        0.9191235899925232,
        "    odd_numbers = [num for num in arr if num % 2 != 0]\n    return odd_numbers"
      ],
      [
        0.9169495105743408,
        "    odd_nums = []\n    for num in lst:\n        if num % 2 != 0:\n            odd_nums.append(num)\n    print(odd_nums)"
      ],
      [
        0.9162485003471375,
        "    odd_set = set()\n    for num in lst:\n        if num % 2 != 0:\n            odd_set.add(num)\n    return list(odd_set)"
      ],
      [
        0.9156351089477539,
        "    new_list = []\n    for num in lst:\n        if num % 2 == 0:\n            new_list.append(num)\n    return new_list"
      ],
      [
        0.9154279232025146,
        "    output_list = []\n    for num in input_list:\n        if num % 2 != 0:\n            output_list.append(num)\n    return output_list"
      ]
    ],
    "MBPP/402": [
      [
        0.8945306539535522,
        "    return [item[n] for item in list_of_lists]"
      ],
      [
        0.8762083053588867,
        "    output_list = []\n    for element in input_list:\n        try:\n            output_list.append(element[index])\n        except IndexError:\n            output_list.append('')\n    return output_list"
      ],
      [
        0.8759928941726685,
        "    elif len(lst) < 5:\n        return 'Error: The list does not have a fifth element.'\n    else:\n        return str(lst[4])"
      ],
      [
        0.8745317459106445,
        "    if len(lst) == 0:\n        return 'Error: The list is empty.'\n    elif len(lst) < 5:\n        return 'Error: The list does not have a fifth element.'\n    else:\n        return str(lst[4])"
      ],
      [
        0.8745317459106445,
        "    if len(lst) == 0:\n        return 'Error: The list is empty.'\n    elif len(lst) < 5:\n        return 'Error: The list does not have a fifth element.'\n    else:\n        return str(lst[4])"
      ],
      [
        0.8733774423599243,
        "    count = 0\n    for i in lst:\n        if isinstance(i, tuple):\n            for j in i:\n                check_number(j)\n                count += 1\n                if count == pos:\n                    return j\n        else:\n            check_number(i)\n            count += 1\n            if count == pos:\n                return i\n    raise ValueError('Position out of range')"
      ],
      [
        0.8726248145103455,
        "    if n > len(lst):\n        return 'Error: n is larger than the number of elements in the list.'\n    else:\n        bubble_sort_desc(lst)\n        return lst[n - 1]"
      ],
      [
        0.8726248145103455,
        "    if n > len(lst):\n        return 'Error: n is larger than the number of elements in the list.'\n    else:\n        bubble_sort_desc(lst)\n        return lst[n - 1]"
      ],
      [
        0.8720104098320007,
        "    if not all((isinstance(t, tuple) for t in tuples)):\n        raise TypeError('All input items must be of type tuple.')\n    elif not isinstance(k, int):\n        raise TypeError('The search key must be an integer.')\n    indices = [i for i, t in enumerate(tuples) if k in t]\n    if not indices:\n        return f\"The integer '{k}' was not found in any tuple.\"\n    else:\n        return indices"
      ],
      [
        0.8719978332519531,
        "    if not all((isinstance(t, tuple) for t in tuples)):\n        raise TypeError('All input items must be of type tuple.')\n    elif not isinstance(k, int):\n        raise TypeError('The search key must be an integer.')\n    indices = [i for i, t in enumerate(tuples) if k in t]\n    if not indices:\n        return f\"The integer '{k}' was not found in any tuple.\"\n    else:\n        return indices"
      ]
    ],
    "MBPP/403": [
      [
        0.9187721014022827,
        "    for i in lst:\n        if i == value:\n            print('Value is found!')\n            return True\n    print('Value is not found!')\n    return False"
      ],
      [
        0.911652147769928,
        "    for i in lst:\n        if i == value:\n            print('Value is found!')\n            return True"
      ],
      [
        0.9113297462463379,
        "    for elem in arr:\n        if elem == value:\n            return True\n    return False"
      ],
      [
        0.9112720489501953,
        "    for num in arr:\n        if num == value:\n            return True\n    return False"
      ],
      [
        0.9106285572052002,
        "    for i in arr:\n        if i == value:\n            return True\n    return False"
      ],
      [
        0.9101925492286682,
        "    for i in arr:\n        if i == value:\n            return True"
      ],
      [
        0.9096227884292603,
        "    for value in arr:\n        if value == search:\n            return True\n    return False"
      ],
      [
        0.9085280895233154,
        "    for elem in arr:\n        if elem == value:\n            return True"
      ],
      [
        0.908448338508606,
        "    for item in lst:\n        if item == value:\n            return True\n    return False"
      ],
      [
        0.9084229469299316,
        "    found = False\n    for i in range(len(array)):\n        if array[i] == value:\n            found = True\n            break\n    return found"
      ]
    ],
    "MBPP/404": [
      [
        0.9311325550079346,
        "    max_product = float('-inf')\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] * lst[j] > max_product:\n                max_product = lst[i] * lst[j]\n                pair = (lst[i], lst[j])\n    return pair"
      ],
      [
        0.9272819757461548,
        "    max_product = 0\n    max_elems = [0, 0]\n    for i in range(len(arr)):\n        left_elem = arr[i]\n        for j in range(i + 1, len(arr)):\n            right_elem = arr[j]\n            product = left_elem * right_elem\n            if product > max_product:\n                max_product = product\n                max_elems = [left_elem, right_elem]\n    return (max_product, max_elems)"
      ],
      [
        0.9254513382911682,
        "    if len(array) < 2:\n        return None\n    max_product = array[0] * array[1]\n    max_pair = (array[0], array[1])\n    for i in range(len(array)):\n        for j in range(i + 1, len(array)):\n            product = array[i] * array[j]\n            if product > max_product:\n                max_product = product\n                max_pair = (array[i], array[j])\n    return list(max_pair)"
      ],
      [
        0.921266496181488,
        "    if len(lst) < 2:\n        return None\n    max_product = float('-inf')\n    max_pair = None\n    for pair in combinations(lst, 2):\n        product = pair[0] * pair[1]\n        if product > max_product:\n            max_product = product\n            max_pair = pair\n    return list(max_pair)"
      ],
      [
        0.9198688268661499,
        "    nums.sort(reverse=True)\n    max_product = 0\n    result_pair = ()\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n                result_pair = (min(nums[i], nums[j]), max(nums[i], nums[j]))\n    return result_pair"
      ],
      [
        0.917944073677063,
        "    for pair in combinations(lst, 2):\n        product = pair[0] * pair[1]\n        if product > max_product:\n            max_product = product\n            max_pair = pair"
      ],
      [
        0.9177537560462952,
        "    for i in range(len(array)):\n        for j in range(i + 1, len(array)):\n            product = array[i] * array[j]\n            if product > max_product:\n                max_product = product\n                max_pair = (array[i], array[j])"
      ],
      [
        0.9167314767837524,
        "    lst.sort()\n    product_1 = lst[0] * lst[1]\n    product_2 = lst[-1] * lst[-2]\n    if product_1 > product_2:\n        return [lst[0], lst[1]]\n    else:\n        return [lst[-1], lst[-2]]"
      ],
      [
        0.9163618087768555,
        "    max_prod = None\n    result = None\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if max_prod is None or nums[i] * nums[j] > max_prod:\n                max_prod = nums[i] * nums[j]\n                result = [nums[i], nums[j]]\n    return result"
      ],
      [
        0.9163587093353271,
        "    max_prod = None\n    result = None\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if max_prod is None or nums[i] * nums[j] > max_prod:\n                max_prod = nums[i] * nums[j]\n                result = [nums[i], nums[j]]\n    return result"
      ]
    ],
    "MBPP/405": [
      [
        0.8996219635009766,
        "    if index >= len(arr):\n        return 0\n    if index == 2:\n        return max(arr[index] + arr[index - 1] + arr[index - 2], 0)\n    return arr[index] + sum_of_first_three(arr, index + 1)"
      ],
      [
        0.8988720178604126,
        "    for num in nums:\n        dp = [max(dp[i], num + dp[(i - num) % 3]) for i in range(3)]"
      ],
      [
        0.8963720202445984,
        "    max1 = max(a, b)\n    max2 = max(b, c)\n    if max1 > max2:\n        return max1 + max2\n    else:\n        return max2 + max(max2, a)"
      ],
      [
        0.8962657451629639,
        "    dp = [0, float('-inf'), float('-inf')]\n    for num in nums:\n        dp = [max(dp[i], num + dp[(i - num) % 3]) for i in range(3)]\n    return dp[0]"
      ],
      [
        0.8949109315872192,
        "    lst.sort()\n    running_sum = 0\n    for i in range(len(lst)):\n        running_sum += lst[i]\n    if running_sum % 3 == 0:\n        return running_sum\n    return largestMultipleOf3(lst[:-1])"
      ],
      [
        0.894342303276062,
        "    if len(arr) == 0:\n        return 0\n    return max(arr[0] + max_no_adjacent_sum(arr[2:]), max_no_adjacent_sum(arr[1:]))"
      ],
      [
        0.8937054872512817,
        "    dp = [0, 0, 0]\n    for num in nums:\n        temp = dp[:]\n        for s in temp:\n            dp[(s + num) % 3] = max(dp[(s + num) % 3], s + num)\n    return dp[0]"
      ],
      [
        0.8936946392059326,
        "    dp = [0, 0, 0]\n    for num in nums:\n        temp = dp[:]\n        for s in temp:\n            dp[(s + num) % 3] = max(dp[(s + num) % 3], s + num)\n    return dp[0]"
      ],
      [
        0.8933225870132446,
        "    total_sum = 0\n    for i in range(len(array)):\n        if array[i] % 3 == 0:\n            for j in range(i + 1, len(array) + 1):\n                current_sum = sum(array[i:j])\n                if current_sum <= limit:\n                    total_sum = max(total_sum, current_sum)\n                else:\n                    break\n    return total_sum"
      ],
      [
        0.8932834267616272,
        "    elements = []\n    for i in range(len(lst) - 2):\n        for j in range(i + 1, len(lst) - 1):\n            for k in range(j + 1, len(lst)):\n                elements.append(lst[i] + lst[j] + lst[k])\n    return max(elements)"
      ]
    ],
    "MBPP/406": [
      [
        0.8976683616638184,
        "    list_of_sets = [set(lst) for lst in list_of_lists]\n    common_set = set.intersection(*list_of_sets)\n    common_list = list(common_set)\n    return common_list"
      ],
      [
        0.8955215215682983,
        "    if not lists:\n        return []\n    common_elements = lists[0]\n    for lst in lists[1:]:\n        common_elements = [elem for elem in common_elements if elem in lst]\n    return common_elements"
      ],
      [
        0.8947149515151978,
        "    minimum_length = min([len(array) for array in arrays])\n    common_elements = []\n    for i in range(minimum_length):\n        element = arrays[0][i]\n        if all((array[i] == element for array in arrays)):\n            common_elements.append(element)\n    return common_elements"
      ],
      [
        0.8930193781852722,
        "    result = []\n    for i in list1:\n        if i in tuple1:\n            result.append(i)\n    return result"
      ],
      [
        0.8923964500427246,
        "    try:\n        result = []\n        for sub_list in lists:\n            if sub_list:\n                first = sub_list[0]\n                if all((elem == first for elem in sub_list)):\n                    result.append(first)\n                else:\n                    result.append(None)\n            else:\n                result.append(None)\n        return result\n    except TypeError:\n        return 'Error: The list elements should be of the same data types.'"
      ],
      [
        0.8923964500427246,
        "    try:\n        result = []\n        for sub_list in lists:\n            if sub_list:\n                first = sub_list[0]\n                if all((elem == first for elem in sub_list)):\n                    result.append(first)\n                else:\n                    result.append(None)\n            else:\n                result.append(None)\n        return result\n    except TypeError:\n        return 'Error: The list elements should be of the same data types.'"
      ],
      [
        0.8917306661605835,
        "    if len(lists) < 2:\n        return []\n    common_elements = set(lists[0])\n    for lst in lists[1:]:\n        common_elements.intersection_update(lst)\n    return list(common_elements)"
      ],
      [
        0.8914738893508911,
        "    common = []\n    for i in lst1:\n        for j in lst2:\n            if i == j:\n                common.append(i)\n                break\n    return common"
      ],
      [
        0.8914262652397156,
        "    common_elements = set(list_of_arrays[0])\n    for array in list_of_arrays:\n        common_elements.intersection_update(array)\n    return list(common_elements)"
      ],
      [
        0.8913644552230835,
        "    commons = []\n    for i in range(len(list_of_lists)):\n        commons = list(set(commons).intersection(list_of_lists[i]))\n    return commons"
      ]
    ],
    "MBPP/407": [
      [
        0.9076236486434937,
        "    for sublist in list:\n        maxLength = max(maxLength, len(sublist))"
      ],
      [
        0.9056767821311951,
        "            elif end - start + 1 == max_length:\n                max_sublists.append((start, end))"
      ],
      [
        0.9031011462211609,
        "            if sub_length > max_length:\n                max_length = sub_length\n                max_string = sub_string"
      ],
      [
        0.9007863998413086,
        "                if len(sublist) > len(longest):\n                    longest = sublist"
      ],
      [
        0.9005072712898254,
        "    distinct_numbers = set(sequence)\n    count_flag = 0\n    max_seq_len = 0\n    max_seq_number = 0\n    for number in distinct_numbers:\n        current_count_flag = 0\n        current_seq_len = 0\n        for num in sequence:\n            if number == num:\n                current_count_flag += 1\n                current_seq_len += 1\n                if current_count_flag > count_flag:\n                    count_flag = current_count_flag\n                    max_seq_len = current_seq_len\n                    max_seq_number = number\n    return (max_seq_len, max_seq_number)"
      ],
      [
        0.8998709321022034,
        "    max_length = max((len(sublist) for sublist in lst))\n    index_of_longest = next((i for i, sublist in enumerate(lst) if len(sublist) == max_length))\n    return (max_length, index_of_longest)"
      ]
    ],
    "MBPP/408": [
      [
        0.9055952429771423,
        "    rounded_list = [round(x, 2) for x in my_list]\n    return rounded_list"
      ],
      [
        0.9054630994796753,
        "    total = 0\n    count = 0\n    for num in lst:\n        total += num\n        count += 1\n    average = total / count\n    decimal_part = average - int(average)\n    if decimal_part < 0.5:\n        rounded_average = int(average)\n    else:\n        rounded_average = int(average) + 1\n    return rounded_average"
      ],
      [
        0.899018406867981,
        "    total_sum = 0\n    for number in numbers:\n        total_sum += number\n    mean = total_sum / len(numbers)\n    mean_rounded = round(mean, 2)\n    return mean_rounded"
      ],
      [
        0.8989114761352539,
        "    sum = 0\n    for x in list:\n        sum += x\n    return sum"
      ],
      [
        0.8988152742385864,
        "    total = 0\n    for num in lst:\n        total += num\n    return round(total / len(lst), 2)"
      ],
      [
        0.898614764213562,
        "    for num in numbers:\n        if not isinstance(num, int) or num < 0:\n            raise ValueError('All numbers must be positive integers')\n    sum_result = sum(numbers)\n    rounded_sum = round(sum_result)\n    return rounded_sum"
      ],
      [
        0.8984681963920593,
        "    return sum([num * 2 for num in myList])"
      ],
      [
        0.8977084755897522,
        "    rounded_array = []\n    for num in arr:\n        rounded_num = int(num)\n        if num - rounded_num > 0.5:\n            rounded_num += 1\n        rounded_array.append(rounded_num)\n    return rounded_array"
      ],
      [
        0.8965084552764893,
        "    result = 0\n    for num in myList:\n        result += num ** 2\n    return result"
      ],
      [
        0.896458625793457,
        "    total = sum(args)\n    average = total / len(args)\n    return average * len(args)"
      ]
    ],
    "MBPP/409": [],
    "MBPP/410": [
      [
        0.9028024673461914,
        "    result = []\n    for i in numbers:\n        result.append(i)\n        result.append(delimiter)\n    return result[:-1]"
      ],
      [
        0.9012223482131958,
        "    result = []\n    for i in range(len(numbers)):\n        result.append(numbers[i])\n        if i != len(numbers) - 1:\n            result.append(delimiter)\n    return result"
      ],
      [
        0.9012015461921692,
        "    result = []\n    for i in range(len(numbers)):\n        result.append(numbers[i])\n        if i != len(numbers) - 1:\n            result.append(delimiter)\n    return result"
      ],
      [
        0.9011498689651489,
        "    result = []\n    for i in numbers:\n        result.append(i)\n        result.append(delimeter)\n    return result[:-1]"
      ],
      [
        0.9008184671401978,
        "    return delimiter.join(strings)"
      ],
      [
        0.900645911693573,
        "    return delimiter.join(string_list)"
      ],
      [
        0.9001262784004211,
        "    return delimiter.join(list_of_strings)"
      ],
      [
        0.8995329141616821,
        "    result = []\n    for i in numbers:\n        result += [i, delimeter]\n    return result[:-1]"
      ],
      [
        0.8993621468544006,
        "    return delimiter.join(list_str)"
      ],
      [
        0.898192286491394,
        "    result = []\n    for i, num in enumerate(numbers):\n        if i > 0:\n            result.append(delimeter)\n        result.append(num)\n    return result"
      ]
    ],
    "MBPP/411": [
      [
        0.9013606309890747,
        "    natural_numbers = [i for i in range(1, n + 1)]\n    sum_numbers = sum(natural_numbers)\n    average = sum_numbers / n\n    squares = [(i - average) ** 2 for i in natural_numbers]\n    std_dev = math.sqrt(sum(squares) / n)\n    return (sum_numbers, average, std_dev)"
      ],
      [
        0.9004225134849548,
        "    if not isinstance(n, int) or n < 1:\n        return 'Error: Input should be a natural number.'\n    sum_of_cubes = sum([i ** 3 for i in range(1, n + 1)])\n    sum_of_numbers = sum([i for i in range(1, n + 1)])\n    return sum_of_cubes - sum_of_numbers"
      ],
      [
        0.9004167318344116,
        "    if not isinstance(n, int) or n < 1:\n        return 'Error: Input should be a natural number.'\n    sum_of_cubes = sum([i ** 3 for i in range(1, n + 1)])\n    sum_of_numbers = sum([i for i in range(1, n + 1)])\n    return sum_of_cubes - sum_of_numbers"
      ],
      [
        0.8981722593307495,
        "    primes = []\n    for i in range(1, n + 1):\n        if is_prime(i):\n            primes.append(i)\n    sum_of_cubes = sum([prime ** 3 for prime in primes])\n    return sum_of_cubes"
      ],
      [
        0.8966090679168701,
        "    cubes_array = []\n    for i in range(1, n + 1):\n        cubes_array.append(i ** 3)\n    return cubes_array"
      ],
      [
        0.8955418467521667,
        "    if n <= 0:\n        return 'n must be a positive integer.'\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if is_prime(num):\n            primes.append(num)\n        num += 1\n    sum_of_cubes = sum([prime ** 3 for prime in primes])\n    return sum_of_cubes"
      ],
      [
        0.8952248096466064,
        "    sum = 0\n    for i in range(len(arr)):\n        arr[i] = arr[i] ** 3\n        sum += arr[i]\n    average = round(sum / len(arr))\n    return average"
      ],
      [
        0.8943583965301514,
        "    if not isinstance(n, int) or n < 0:\n        raise ValueError('Input must be a positive integer')\n    sum_of_cubes = 0\n    for num in range(2, n + 1, 2):\n        sum_of_cubes += num ** 3\n    return sum_of_cubes"
      ],
      [
        0.8927483558654785,
        "    if n < 0:\n        raise ValueError('Input cannot be a negative number.')\n    if n == 0:\n        return 0\n    else:\n        return n ** 3 + sum_cubes(n - 1)"
      ],
      [
        0.8920141458511353,
        "    if n == 0:\n        return 0\n    else:\n        return n ** 3 + sum_cubes(n - 1)"
      ]
    ],
    "MBPP/412": [
      [
        0.919744610786438,
        "    rows, cols = (len(mine), len(mine[0]))\n    dp = [[[-1 for _ in range(cols)] for _ in range(cols)] for _ in range(rows)]\n    return maxGold(mine, dp, 0, 0, cols - 1)"
      ],
      [
        0.9190274477005005,
        "    rows, cols = (len(mine), len(mine[0]))\n    dp = [[[-1 for _ in range(cols)] for __ in range(cols)] for ___ in range(rows)]\n    return maxGold(mine, dp, 0, 0, cols - 1)"
      ],
      [
        0.8842380046844482,
        "    x2 = x1 + y2 - y1\n    cols = len(m[0])\n    if y1 < 0 or y1 >= cols or y2 < 0 or (y2 >= cols):\n        return float('-inf')\n    if dp[x1][y1][y2] != -1:\n        return dp[x1][y1][y2]\n    if x1 == len(m) - 1:\n        return m[x1][y1] + (y1 != y2) * m[x2][y2]\n    ans = float('-inf')\n    for new_y1 in [y1 - 1, y1, y1 + 1]:\n        for new_y2 in [y2 - 1, y2, y2 + 1]:\n            ans = max(ans, maxGold(m, dp, x1 + 1, new_y1, new_y2))\n    dp[x1][y1][y2] = ans + m[x1][y1] + (y1 != y2) * m[x2][y2]\n    return dp[x1][y1][y2]"
      ],
      [
        0.8842297792434692,
        "    x2 = x1 + y2 - y1\n    cols = len(m[0])\n    if y1 < 0 or y1 >= cols or y2 < 0 or (y2 >= cols):\n        return float('-inf')\n    if dp[x1][y1][y2] != -1:\n        return dp[x1][y1][y2]\n    if x1 == len(m) - 1:\n        return m[x1][y1] + (y1 != y2) * m[x2][y2]\n    ans = float('-inf')\n    for new_y1 in [y1 - 1, y1, y1 + 1]:\n        for new_y2 in [y2 - 1, y2, y2 + 1]:\n            ans = max(ans, maxGold(m, dp, x1 + 1, new_y1, new_y2))\n    dp[x1][y1][y2] = ans + m[x1][y1] + (y1 != y2) * m[x2][y2]\n    return dp[x1][y1][y2]"
      ],
      [
        0.8821479678153992,
        "        for new_y2 in [y2 - 1, y2, y2 + 1]:\n            ans = max(ans, maxGold(m, dp, x1 + 1, new_y1, new_y2))"
      ],
      [
        0.882144570350647,
        "        for new_y2 in [y2 - 1, y2, y2 + 1]:\n            ans = max(ans, maxGold(m, dp, x1 + 1, new_y1, new_y2))"
      ],
      [
        0.8810227513313293,
        "            if collected_treasures == sum((row.count('T') for row in grid)):\n                return (collected_treasures, True)"
      ],
      [
        0.8805058002471924,
        "    for new_y1 in [y1 - 1, y1, y1 + 1]:\n        for new_y2 in [y2 - 1, y2, y2 + 1]:\n            ans = max(ans, maxGold(m, dp, x1 + 1, new_y1, new_y2))"
      ],
      [
        0.8804555535316467,
        "    for new_y1 in [y1 - 1, y1, y1 + 1]:\n        for new_y2 in [y2 - 1, y2, y2 + 1]:\n            ans = max(ans, maxGold(m, dp, x1 + 1, new_y1, new_y2))"
      ],
      [
        0.8748303651809692,
        "        if grid[y][x] == 'T':\n            treasure_count -= 1\n        elif grid[y][x] == 'X':\n            return False"
      ]
    ],
    "MBPP/413": [
      [
        0.8838933706283569,
        "    last_elements = []\n    for string in str_list:\n        last_elements.append(string[-1])\n    return last_elements"
      ],
      [
        0.8806674480438232,
        "    last_chars = []\n    for string in strings:\n        last_char = string[len(string) - 1]\n        last_chars.append(last_char)\n    return last_chars"
      ],
      [
        0.8770732879638672,
        "    third_chars = ''\n    for word in lst:\n        third_chars += word[2]\n    return third_chars"
      ],
      [
        0.8769996166229248,
        "    error_free_list = [w for w in tup if isinstance(w, str) and len(w) > 1]\n    sorted_tuple = tuple(sorted(error_free_list, key=lambda x: x[-2:]))\n    if error_free_list == list(sorted_tuple):\n        print('List is sorted.')\n    else:\n        print('List was not sorted, but is now sorted.')\n    return sorted_tuple"
      ],
      [
        0.8768606185913086,
        "    return tuple[-4:-2]"
      ],
      [
        0.8750303387641907,
        "    try:\n        print(colors[-3])\n    except IndexError:\n        print('Tuple is too small to have a third last item')"
      ],
      [
        0.8750303387641907,
        "    try:\n        print(colors[-3])\n    except IndexError:\n        print('Tuple is too small to have a third last item')"
      ],
      [
        0.8732538819313049,
        "    words = words.strip()\n    word_list = words.split()\n    if len(word_list) < 3:\n        return 'Input string must contain at least three words'\n    last_word = word_list[-1]\n    second_last_word = word_list[-2]\n    return (second_last_word, last_word)"
      ],
      [
        0.8724638819694519,
        "    extracted_elements = []\n    for i in range(3):\n        extracted_elements.append(lst[i])\n    return extracted_elements"
      ],
      [
        0.8719297051429749,
        "    result = []\n    for string in arr:\n        string = string.strip()\n        words = string.split()\n        if len(words) == 0:\n            result.append(('', ''))\n        elif len(words) == 1:\n            result.append((words[0], words[0]))\n        else:\n            result.append((words[0], words[-1]))\n    return result"
      ]
    ],
    "MBPP/414": [
      [
        0.9258114099502563,
        "    count = 0\n    for sub_list in nested_list:\n        for elem in sub_list:\n            if elem == item:\n                count += 1\n    return count"
      ],
      [
        0.9201257824897766,
        "    for sub_list in nested_list:\n        for elem in sub_list:\n            if elem == item:\n                count += 1"
      ],
      [
        0.9194061756134033,
        "    item_count = 0\n    sublist_count = 0\n    for i in lst:\n        if isinstance(i, list):\n            sublist_item_count, sublist_sublist_count = count_item_and_sublists(i, item)\n            item_count += sublist_item_count\n            if sublist_item_count > 0:\n                sublist_count += 1\n        elif i == item:\n            item_count += 1\n    return (item_count, sublist_count)"
      ],
      [
        0.9193915724754333,
        "    item_count = 0\n    sublist_count = 0\n    for i in lst:\n        if isinstance(i, list):\n            sublist_item_count, sublist_sublist_count = count_item_and_sublists(i, item)\n            item_count += sublist_item_count\n            if sublist_item_count > 0:\n                sublist_count += 1\n        elif i == item:\n            item_count += 1\n    return (item_count, sublist_count)"
      ],
      [
        0.9186366200447083,
        "    count = 0\n    for element in lst:\n        if element == ele:\n            count += 1\n    return count"
      ],
      [
        0.9178998470306396,
        "    count = 0\n    for i in lst:\n        if i == element:\n            count += 1\n    return count"
      ],
      [
        0.9176596403121948,
        "    count = 0\n    for item in lst:\n        if item == element:\n            count += 1\n    return count"
      ],
      [
        0.9171748757362366,
        "    count = 0\n    for i in input_list:\n        if i == element:\n            count += 1\n    return count"
      ],
      [
        0.9166999459266663,
        "    count = 0\n    for element in lst:\n        if element == target:\n            count += 1\n    return count"
      ],
      [
        0.9166976809501648,
        "    count = 0\n    for element in lst:\n        if element == target:\n            count += 1\n    return count"
      ]
    ],
    "MBPP/415": [],
    "MBPP/416": [
      [
        0.9228528141975403,
        "    splitted_date = date.split('-')\n    reformatted_date = splitted_date[::-1]\n    return '-'.join(reformatted_date)"
      ],
      [
        0.9180665016174316,
        "    dateList = inputDate.split('-')\n    newFormat = dateList[1] + '-' + dateList[0] + '-' + dateList[2]\n    return newFormat"
      ],
      [
        0.9086997509002686,
        "    date_list = date.split('/')\n    new_date = date_list[2] + '-' + date_list[0] + '-' + date_list[1]\n    return new_date"
      ],
      [
        0.907657265663147,
        "    date_list = date.split('/')\n    return date_list[2] + '/' + date_list[0] + '/' + date_list[1]"
      ],
      [
        0.9023263454437256,
        "    date_list = date.split('/')\n    date_list.reverse()\n    return '-'.join(date_list)"
      ],
      [
        0.9017375111579895,
        "    datetime_obj = datetime.strptime(input_date, '%Y-%m-%d')\n    reformatted_date = datetime_obj.strftime(desired_format)\n    return reformatted_date"
      ],
      [
        0.9013948440551758,
        "    date = datetime.strptime(date_string, '%m/%d/%Y')\n    converted_date = date.strftime('%d-%m-%Y')\n    return converted_date"
      ],
      [
        0.8993747234344482,
        "    try:\n        date_object = datetime.strptime(date_string, '%m-%d-%Y')\n        formatted_date = date_object.strftime('%d/%m/%Y')\n        return formatted_date\n    except ValueError:\n        return \"Invalid Date Format. Please provide the date in 'mm-dd-yyyy' format.\""
      ],
      [
        0.8993747234344482,
        "    try:\n        date_object = datetime.strptime(date_string, '%m-%d-%Y')\n        formatted_date = date_object.strftime('%d/%m/%Y')\n        return formatted_date\n    except ValueError:\n        return \"Invalid Date Format. Please provide the date in 'mm-dd-yyyy' format.\""
      ],
      [
        0.8987125158309937,
        "    datetime_object = datetime.strptime(date, '%Y-%m-%d')\n    formatted_date = datetime_object.strftime(format)\n    return formatted_date"
      ]
    ],
    "MBPP/417": [],
    "MBPP/418": [
      [
        0.8881223201751709,
        "    for a, b in tpl1:\n        for c, d in tpl2:\n            return (a + c, b + d)"
      ],
      [
        0.8881223201751709,
        "    for a, b in tpl1:\n        for c, d in tpl2:\n            return (a + c, b + d)"
      ],
      [
        0.8826452493667603,
        "    for pair1, pair2 in zip(tuples1, tuples2):\n        if len(pair1) != len(pair2):\n            return 'Error: Corresponding tuples should be of same length.'\n        temp = []\n        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)\n        result.append(tuple(temp))"
      ],
      [
        0.8826451301574707,
        "    for pair1, pair2 in zip(tuples1, tuples2):\n        if len(pair1) != len(pair2):\n            return 'Error: Corresponding tuples should be of same length.'\n        temp = []\n        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)\n        result.append(tuple(temp))"
      ],
      [
        0.8825404644012451,
        "    filtered_elements = [x for x in a if x < b]\n    multiplied_elements = [x * fact for x in filtered_elements]\n    return tuple(multiplied_elements)"
      ],
      [
        0.8801529407501221,
        "    if not isinstance(tuples1, list) or not isinstance(tuples2, list):\n        return 'Error: Both inputs should be lists.'\n    if len(tuples1) != len(tuples2):\n        return 'Error: Both lists should be of same length.'\n    for t in tuples1 + tuples2:\n        if not isinstance(t, tuple):\n            return 'Error: All elements of input lists should be tuples.'\n        if not all((isinstance(i, int) for i in t)):\n            return 'Error: All elements of the tuples should be integers.'\n    result = []\n    for pair1, pair2 in zip(tuples1, tuples2):\n        if len(pair1) != len(pair2):\n            return 'Error: Corresponding tuples should be of same length.'\n        temp = []\n        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)\n        result.append(tuple(temp))\n    return result"
      ],
      [
        0.8801481127738953,
        "    if not isinstance(tuples1, list) or not isinstance(tuples2, list):\n        return 'Error: Both inputs should be lists.'\n    if len(tuples1) != len(tuples2):\n        return 'Error: Both lists should be of same length.'\n    for t in tuples1 + tuples2:\n        if not isinstance(t, tuple):\n            return 'Error: All elements of input lists should be tuples.'\n        if not all((isinstance(i, int) for i in t)):\n            return 'Error: All elements of the tuples should be integers.'\n    result = []\n    for pair1, pair2 in zip(tuples1, tuples2):\n        if len(pair1) != len(pair2):\n            return 'Error: Corresponding tuples should be of same length.'\n        temp = []\n        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)\n        result.append(tuple(temp))\n    return result"
      ],
      [
        0.8799483776092529,
        "    if len(t1) != len(t2):\n        return 'Error: tuples are not the same size'\n    else:\n        result = []\n        for i in range(len(t1)):\n            if t2[i] == 0:\n                return f'Error: division by zero in position {i}'\n            else:\n                result.append(t1[i] % t2[i])\n        return tuple(result)"
      ],
      [
        0.8799483776092529,
        "    if len(t1) != len(t2):\n        return 'Error: tuples are not the same size'\n    else:\n        result = []\n        for i in range(len(t1)):\n            if t2[i] == 0:\n                return f'Error: division by zero in position {i}'\n            else:\n                result.append(t1[i] % t2[i])\n        return tuple(result)"
      ],
      [
        0.8799260258674622,
        "    if len(t1) != len(t2):\n        return 'Error: tuples are not the same size'\n    else:\n        result = []\n        for i in range(len(t1)):\n            if t2[i] == 0:\n                return f'Error: division by zero in position {i}'\n            else:\n                result.append(t1[i] % t2[i])\n        return tuple(result)"
      ]
    ],
    "MBPP/419": [
      [
        0.8768070340156555,
        "    parabola_distance, error = integrate.quad(parabolic_distance, -4, 0, args=a)\n    straight_distance = sqrt(4 ** 2 + 3 ** 2)\n    return parabola_distance + straight_distance"
      ],
      [
        0.8742564916610718,
        "    discriminant = (b ** 2 - 4 * a * c) ** 0.5\n    x1 = (-b + discriminant) / (2 * a)\n    x2 = (-b - discriminant) / (2 * a)\n    return (x1, x2)"
      ],
      [
        0.8733948469161987,
        "    discriminant = b ** 2 - 4 * a * c\n    sqrt_discriminant = math.sqrt(discriminant)\n    x_c = (-b + sqrt_discriminant) / (2 * a)\n    x_d = (-b - sqrt_discriminant) / (2 * a)\n    return (x_c, x_d)"
      ],
      [
        0.8733106255531311,
        "    discriminant = b ** 2 - 4 * a * c\n    x1 = 2 * c / (-b + discriminant ** 0.5)\n    x2 = (-b - discriminant ** 0.5) / (2 * a)\n    return (x1, x2)"
      ],
      [
        0.8730329871177673,
        "    x = eq.split('=')[0]\n    constant = eq.split('=')[1]\n    coeff = x.split('+')[0]\n    if coeff[0] == '-':\n        coeff = -float(coeff[1:])\n    else:\n        coeff = float(coeff)\n    x_value = (float(constant) - float(coeff)) / (2 * coeff)\n    return x_value"
      ],
      [
        0.8723846673965454,
        "    d = b * b - 4 * a * c\n    sol1 = (-b - math.sqrt(d)) / (2 * a)\n    sol2 = (-b + math.sqrt(d)) / (2 * a)\n    return (sol1, sol2)"
      ],
      [
        0.8719675540924072,
        "    d = b ** 2 - 4 * a * c\n    if d >= 0:\n        sqrt_d = sqrt(d)\n        x1 = (-b + sqrt_d) / (2 * a)\n        x2 = (-b - sqrt_d) / (2 * a)\n        if x1 < x2:\n            return x1\n        else:\n            return x2\n    else:\n        return None"
      ],
      [
        0.8716009855270386,
        "    if d >= 0:\n        sqrt_d = sqrt(d)\n        x1 = (-b + sqrt_d) / (2 * a)\n        x2 = (-b - sqrt_d) / (2 * a)\n        if x1 < x2:\n            return x1\n        else:\n            return x2\n    else:\n        return None"
      ],
      [
        0.8713162541389465,
        "    discriminant = b ** 2 - 4 * a * c\n    d = math.sqrt(discriminant)\n    x1 = (-b + d) / (2 * a)\n    x2 = (-b - d) / (2 * a)\n    return (x1, x2)"
      ],
      [
        0.8711724281311035,
        "    x1 = (-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)\n    x2 = (-b - (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)\n    return (x1, x2)"
      ]
    ],
    "MBPP/420": [
      [
        0.9336414337158203,
        "    for element in list1:\n        if element in list2:\n            return True"
      ],
      [
        0.9336302280426025,
        "    for element in list1:\n        if element in list2:\n            return True"
      ],
      [
        0.9322137832641602,
        "    for element in list1:\n        if element in list2:\n            return True\n    return False"
      ],
      [
        0.9322114586830139,
        "    for element in list1:\n        if element in list2:\n            return True\n    return False"
      ],
      [
        0.9292051792144775,
        "    result = False\n    for x in list1:\n        for y in list2:\n            if x == y:\n                result = True\n                return result\n    return result"
      ],
      [
        0.9276831150054932,
        "    set1 = set(flatten(list1))\n    set2 = set(flatten(list2))\n    if set1.intersection(set2):\n        return True\n    else:\n        return False"
      ],
      [
        0.9276036024093628,
        "    for x in list1:\n        for y in list2:\n            if x == y:\n                result = True\n                return result"
      ],
      [
        0.9233754873275757,
        "    return len(set(a).intersection(set(b))) > 0"
      ],
      [
        0.9198169708251953,
        "    for x in list2:\n        if x not in list1:\n            return False"
      ],
      [
        0.9191113710403442,
        "    set_L = set(L)\n    set_M = set(M)\n    return len(set_L.intersection(set_M)) > 0"
      ]
    ],
    "MBPP/421": [],
    "MBPP/422": [
      [
        0.906704306602478,
        "    greater_than_num = []\n    for i in list_numbers:\n        if i > num:\n            greater_than_num.append(i)\n    return greater_than_num"
      ],
      [
        0.9041910171508789,
        "    for i in list_numbers:\n        if i > num:\n            greater_than_num.append(i)"
      ],
      [
        0.8942075967788696,
        "    result = []\n    for element in array:\n        if element >= number:\n            result.append(element)\n    return result"
      ],
      [
        0.8931131362915039,
        "    for element in array:\n        if element >= number:\n            result.append(element)"
      ],
      [
        0.8902426958084106,
        "        if len(greater_than_six) == 0:\n            return 'There are no elements greater than 6 in the array.'"
      ],
      [
        0.8899906277656555,
        "    for i in range(len(input_array)):\n        if input_array[i] == num:\n            return True\n    return False"
      ],
      [
        0.8895407319068909,
        "        if i > num:\n            greater_than_num.append(i)"
      ],
      [
        0.8894605040550232,
        "    for i in range(len(input_array)):\n        if input_array[i] == num:\n            return True"
      ],
      [
        0.8892250061035156,
        "    for element in array:\n        if element == number:\n            return True\n    return False"
      ],
      [
        0.8884693384170532,
        "    if isinstance(num1, int) and isinstance(num2, int):\n        if num1 > num2:\n            return True\n        else:\n            return False\n    else:\n        raise ValueError('Error: Invalid input. Please provide two integers as input.')"
      ]
    ],
    "MBPP/423": [
      [
        0.9043151140213013,
        "    if re.search(pattern, s):\n        return True\n    else:\n        return \"Error: The string does not contain 'a' followed by any characters, ending in 'b'.\""
      ],
      [
        0.9014219045639038,
        "    if not isinstance(s, str):\n        return 'Error: Input is not a string.'\n    pattern = 'a.*b$'\n    if re.search(pattern, s):\n        return True\n    else:\n        return \"Error: The string does not contain 'a' followed by any characters, ending in 'b'.\""
      ],
      [
        0.8924802541732788,
        "    state = 0\n    a_count = 0\n    b_count = 0\n    for c in input_string:\n        if c == 'a':\n            a_count += 1\n            if state == 0:\n                state = 1\n        if c == 'b':\n            b_count += 1\n            if state == 1 and b_count < a_count + 1:\n                state = 2\n            elif state == 1 and b_count == a_count + 1:\n                state = 3\n    if state == 2:\n        return True\n    else:\n        return False"
      ],
      [
        0.8902738690376282,
        "    pattern = 'Ab?c'\n    return re.match(pattern, s) is not None"
      ],
      [
        0.8877813816070557,
        "    return re.fullmatch('(a{1}b{2})*', s) is not None"
      ],
      [
        0.8874160051345825,
        "    if input_string[0] == 'a' and input_string[-1] == 'b':\n        return True\n    else:\n        return False"
      ],
      [
        0.8874160051345825,
        "    if input_string[0] == 'a' and input_string[-1] == 'b':\n        return True\n    else:\n        return False"
      ],
      [
        0.8873597979545593,
        "    if string[0] == 'a':\n        return True\n    else:\n        return False"
      ],
      [
        0.8873597979545593,
        "    if string[0] == 'a':\n        return True\n    else:\n        return False"
      ],
      [
        0.886468231678009,
        "        if len(string) > 1 and string[1] == 'a':\n            return True"
      ]
    ],
    "MBPP/424": [
      [
        0.9163995385169983,
        "    if not isinstance(n, int):\n        raise ValueError('Input must be an integer.')\n    if n < 0:\n        n = -n\n    least_digit = n % 10\n    print('The least significant digit of', n, 'is', least_digit)\n    return least_digit"
      ],
      [
        0.908065676689148,
        "    return number % 10"
      ],
      [
        0.9080569744110107,
        "    return number % 10"
      ],
      [
        0.8955068588256836,
        "    size = 1\n    length = 9\n    start = 1\n    while n > length * size:\n        n -= length * size\n        size += 1\n        length *= 10\n        start *= 10\n    start += (n - 1) // size\n    s = str(start)\n    return int(s[(n - 1) % size])"
      ],
      [
        0.8943317532539368,
        "    last_two_digits = int(str(number)[-2:])\n    return last_two_digits"
      ],
      [
        0.8939772248268127,
        "    last_five_string = str(num)[-5:]\n    return int(last_five_string)"
      ],
      [
        0.8932912349700928,
        "    str_num = str(num)\n    dot_position = str_num.index('.')\n    digit = int(str_num[dot_position - 1])\n    return digit"
      ],
      [
        0.8875688314437866,
        "    last_digit_a = abs(a) % 10\n    last_digit_b = abs(b) % 10\n    return last_digit_a * last_digit_b"
      ],
      [
        0.8859934210777283,
        "    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n        while factorial % 10 == 0:\n            factorial //= 10\n        factorial %= 1000000000\n    return factorial % 10"
      ],
      [
        0.8859586715698242,
        "    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n        while factorial % 10 == 0:\n            factorial //= 10\n        factorial %= 1000000000\n    return factorial % 10"
      ]
    ],
    "MBPP/425": [
      [
        0.9230663180351257,
        "    neg_lst = []\n    for num in lst:\n        if num < 0:\n            neg_lst.append(num)\n    return neg_lst"
      ],
      [
        0.9136425852775574,
        "    negative_elements = []\n    for x in my_list:\n        if x < 0:\n            negative_elements.append(x)\n    return negative_elements"
      ],
      [
        0.9093806743621826,
        "    for num in lst:\n        if num < 0:\n            neg_lst.append(num)"
      ],
      [
        0.9081904888153076,
        "    for x in my_list:\n        if x < 0:\n            negative_elements.append(x)"
      ],
      [
        0.9077621102333069,
        "    return [num for num in int_list if num < 0]"
      ],
      [
        0.9075359106063843,
        "    for num in reversed(negative_numbers):\n        print(num)"
      ],
      [
        0.905633270740509,
        "    return [num for num in numbers if num < 0]"
      ],
      [
        0.905633270740509,
        "    return [num for num in numbers if num < 0]"
      ],
      [
        0.9056185483932495,
        "    return [num for num in numbers if num < 0]"
      ],
      [
        0.9039652943611145,
        "    input_list = [1, -2, 3, -4, 5]\n    expected_output = [-2, -4]\n    assert negative(input_list) == expected_output"
      ]
    ],
    "MBPP/426": [
      [
        0.9163827896118164,
        "    new_str = ''\n    for ch in str:\n        if ord(ch) % 2 == 0:\n            new_str += ch\n    return new_str"
      ],
      [
        0.9142084121704102,
        "    odd_position = ''\n    for i in range(len(string)):\n        if i % 2 == 0:\n            odd_position += string[i]\n    return odd_position"
      ],
      [
        0.9049525260925293,
        "    for ch in str:\n        if ord(ch) % 2 == 0:\n            new_str += ch"
      ],
      [
        0.9017974138259888,
        "    string = string.strip()\n    string = string.translate(str.maketrans('', '', string.punctuation))\n    modified_string = ''\n    for index, char in enumerate(string):\n        if index % 2 == 0:\n            modified_string += char\n    return modified_string"
      ],
      [
        0.900408148765564,
        "    result = ''\n    for i in range(len(string)):\n        if i % 2 == 0:\n            result += string[i]\n    return result"
      ],
      [
        0.8999687433242798,
        "    result_string = ''\n    for i in range(0, len(string)):\n        if i % 2 == 0:\n            result_string += string[i]\n    return result_string"
      ],
      [
        0.8999316692352295,
        "    result = ''\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result += str[i]\n    return result"
      ],
      [
        0.8991248607635498,
        "        if ord(ch) % 2 == 0:\n            new_str += ch"
      ],
      [
        0.8959899544715881,
        "    punctuations = string.punctuation\n    modified_string = ''\n    for i, char in enumerate(s):\n        if char in punctuations:\n            continue\n        if i % 2 == 0:\n            modified_string += char\n    return modified_string"
      ]
    ],
    "MBPP/427": [
      [
        0.891808032989502,
        "    for item, count in unique_t2.items():\n        result_dict[item] = (count, 'tuple2')"
      ]
    ],
    "MBPP/428": [
      [
        0.9190174341201782,
        "    number = 0\n    for integer in list_of_ints:\n        number = number * 10 + integer\n    return number"
      ],
      [
        0.9088359475135803,
        "    my_integer = int(''.join(map(str, my_list)))\n    return my_integer"
      ],
      [
        0.904827892780304,
        "    for integer in list_of_ints:\n        number = number * 10 + integer"
      ],
      [
        0.9019628763198853,
        "    return int(''.join((str(e) for e in int_list)))"
      ],
      [
        0.9007604718208313,
        "    final_int = 0\n    concat_numbers = ''\n    for num in numbers:\n        concat_numbers = concat_numbers + str(num)\n    if int(concat_numbers) > 2 ** 32:\n        return False\n    else:\n        final_int = int(concat_numbers)\n    return final_int"
      ],
      [
        0.8992285132408142,
        "    sum = 0\n    for num in integers:\n        sum += num\n    return sum"
      ],
      [
        0.8985792398452759,
        "    return sum(int_list)"
      ],
      [
        0.8984619379043579,
        "    result = 0\n    multiplier = 1\n    for i in range(len(my_list) - 1, -1, -1):\n        result += my_list[i] * multiplier\n        multiplier *= 10\n    return result"
      ],
      [
        0.8963093757629395,
        "    number = 0\n    for i in range(len(lst)):\n        number = number * 10 + lst[i]\n    return number"
      ],
      [
        0.8961597681045532,
        "    list_of_integers = []\n    for string in list_of_strings:\n        list_of_integers.append(int(string))\n    return list_of_integers"
      ]
    ],
    "MBPP/429": [
      [
        0.8897740840911865,
        "    adjectives = []\n    for word in text.split():\n        if word.endswith('ly') or word.endswith('ful'):\n            adjectives.append(word)\n    return adjectives"
      ],
      [
        0.881717324256897,
        "            elif speech1_words[i] == 'Adjective':\n                categories['Adjectives'].append(word)"
      ],
      [
        0.881627082824707,
        "            if re.search('\\\\bfrantically\\\\b', sentence):\n                context = 'adverb'\n            elif re.search('\\\\bfrantic\\\\b', sentence) and re.search('\\\\bnoun\\\\b', sentence):\n                context = 'noun'\n            else:\n                context = 'adjective'"
      ],
      [
        0.8806859254837036,
        "    for word in text.split():\n        if word.endswith('ly') or word.endswith('ful'):\n            adjectives.append(word)"
      ],
      [
        0.8794457912445068,
        "    words = word_tokenize(sentence)\n    pos_tags = pos_tag(words)\n    return pos_tags"
      ],
      [
        0.8777009844779968,
        "    nouns = []\n    verbs = []\n    for word in words:\n        if word.endswith('ing'):\n            verbs.append(word)\n        else:\n            nouns.append(word)\n    return (nouns, verbs)"
      ],
      [
        0.8773678541183472,
        "            elif speech1_words[i] == 'Verb':\n                categories['Verbs'].append(word)\n            elif speech1_words[i] == 'Adjective':\n                categories['Adjectives'].append(word)"
      ],
      [
        0.8772282600402832,
        "    words = []\n    for sentence in sentences:\n        words += word_tokenize(sentence)\n    pos_tags = pos_tag(words)\n    return pos_tags"
      ],
      [
        0.8769931793212891,
        "    positions = {}\n    for word in words:\n        matches = re.finditer('\\\\b' + word + '\\\\b', s)\n        positions[word] = [match.start() for match in matches]\n    return positions"
      ],
      [
        0.8769848346710205,
        "    positions = {}\n    for word in words:\n        matches = re.finditer('\\\\b' + word + '\\\\b', s)\n        positions[word] = [match.start() for match in matches]\n    return positions"
      ]
    ],
    "MBPP/430": [
      [
        0.9021205902099609,
        "    surface_area = 6 * edge_length ** 2\n    return surface_area"
      ],
      [
        0.8992398977279663,
        "    surface_area = 2 * l * w + 2 * l * h + 2 * w * h\n    return surface_area"
      ],
      [
        0.8990668058395386,
        "    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area"
      ],
      [
        0.8990501165390015,
        "    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area"
      ],
      [
        0.898038923740387,
        "    surface_area = 6 * length ** 2\n    volume = length ** 3\n    return (surface_area, volume)"
      ],
      [
        0.8977260589599609,
        "    surface_area = 2 * (height * width + width * depth + height * depth)\n    return surface_area"
      ]
    ],
    "MBPP/431": [
      [
        0.8987486362457275,
        "    if not positive_numbers:\n        return 0\n    else:\n        return sum(positive_numbers) / len(positive_numbers)"
      ],
      [
        0.8981221914291382,
        "    if len(poss) == 0:\n        return 'N/A - No positive numbers'\n    elif 0 in lst:\n        return 'Infinite'\n    else:\n        return len(poss) / sum([1 / x for x in poss])"
      ],
      [
        0.8979179859161377,
        "    poss = [x for x in lst if x > 0]\n    if len(poss) == 0:\n        return 'N/A - No positive numbers'\n    elif 0 in lst:\n        return 'Infinite'\n    else:\n        return len(poss) / sum([1 / x for x in poss])"
      ],
      [
        0.89738529920578,
        "    if len(arr) == 0:\n        return 0\n    num_positive = 0\n    for num in arr:\n        if num > 0:\n            num_positive += 1\n    return num_positive / len(arr)"
      ],
      [
        0.8969530463218689,
        "    size = len(numbers)\n    sum = 0\n    for index in range(size):\n        sum = sum + 1 / numbers[index]\n    return size / sum"
      ],
      [
        0.896763026714325,
        "    for num in nums:\n        if num <= 0:\n            print('A non-positive number', num, 'ignored.')\n            continue\n        sum += 1 / num\n        n += 1"
      ],
      [
        0.8964741230010986,
        "    positive_count = 0\n    sum_of_positives = 0\n    max_positive = float('-inf')\n    min_positive = float('inf')\n    for number in numbers:\n        if number > 0:\n            positive_count += 1\n            sum_of_positives += number\n            max_positive = max(max_positive, number)\n            min_positive = min(min_positive, number)\n    if positive_count > 0:\n        average_of_positives = sum_of_positives / positive_count\n    else:\n        average_of_positives = 0\n    return (positive_count, average_of_positives, max_positive, min_positive)"
      ],
      [
        0.8959785103797913,
        "    positive_numbers = [num for num in numbers if num > 0]\n    if not positive_numbers:\n        return 0\n    return sum(positive_numbers) / len(positive_numbers)"
      ],
      [
        0.895946204662323,
        "    positive_numbers = [num for num in numbers if num > 0]\n    if not positive_numbers:\n        return 0\n    return sum(positive_numbers) / len(positive_numbers)"
      ],
      [
        0.8952301740646362,
        "    positive_numbers = [num for num in numbers if num > 0]\n    if not positive_numbers:\n        return 0\n    else:\n        return sum(positive_numbers) / len(positive_numbers)"
      ]
    ],
    "MBPP/432": [
      [
        0.9302290081977844,
        "    if len(arr) == 0:\n        return 'Array is empty.'\n    largest_negative = float('-inf')\n    for num in arr:\n        if num < 0 and num > largest_negative:\n            largest_negative = num\n    if largest_negative == float('-inf'):\n        return 'No negative numbers found.'\n    else:\n        return largest_negative"
      ],
      [
        0.9187099933624268,
        "    if largest_negative == float('-inf'):\n        return 'No negative numbers found.'\n    else:\n        return largest_negative"
      ],
      [
        0.9185189008712769,
        "    n = float('-inf')\n    for num in array:\n        if num < 0 and num > n:\n            n = num\n    return n"
      ],
      [
        0.9058876633644104,
        "    for num in arr:\n        if num < 0 and num > largest_negative:\n            largest_negative = num"
      ],
      [
        0.9045251607894897,
        "    if not lst:\n        return 'Error: List cannot be empty.'\n    lst = [int(num) for num in lst if num >= 0]\n    if not lst:\n        return 'Error: Negative numbers are not allowed.'\n    largest_num = max(lst)\n    return largest_num"
      ],
      [
        0.8985317945480347,
        "    for i in range(len(numbers)):\n        if numbers[i] < 0:\n            return (numbers[i], i)\n    return 'No negative numbers found'"
      ],
      [
        0.8983945846557617,
        "    neg_lst = []\n    for num in lst:\n        if num < 0:\n            neg_lst.append(num)\n    return neg_lst"
      ],
      [
        0.8970557451248169,
        "    max_num = 0\n    for num in arr:\n        if num < 0:\n            return 'Error: Negative numbers are not allowed.'\n        if num > max_num:\n            max_num = num\n    return max_num"
      ],
      [
        0.8959384560585022,
        "    for num in lst:\n        if num < 0:\n            neg_lst.append(num)"
      ],
      [
        0.8951942920684814,
        "        if num < 0 and num > largest_negative:\n            largest_negative = num"
      ]
    ],
    "MBPP/433": [
      [
        0.871926486492157,
        "    elif k < 1:\n        return input_list\n    else:\n        return input_list[:k - 1] + input_list[k:]"
      ],
      [
        0.8672958612442017,
        "    words = s.split()\n    return ' '.join(words[:k])"
      ],
      [
        0.8672958612442017,
        "    words = s.split()\n    return ' '.join(words[:k])"
      ],
      [
        0.8659970760345459,
        "    for k, trim in queries:\n        trimmed_indices = [(i, int(n[-trim:])) for i, n in enumerate(nums)]\n        trimmed_indices.sort(key=lambda x: (x[1], x[0]))\n        answer.append(trimmed_indices[k - 1][0])"
      ],
      [
        0.8648576140403748,
        "            if condition(i):\n                continue\n            else:\n                result.append(remove_tuples(i, condition))"
      ],
      [
        0.8648388385772705,
        "            if condition(i):\n                continue\n            else:\n                result.append(remove_tuples(i, condition))"
      ],
      [
        0.8648022413253784,
        "    answer = []\n    indices = list(enumerate(map(int, nums)))\n    indices.sort(key=lambda x: (x[1], x[0]))\n    for k, trim in queries:\n        trimmed_indices = [(i, int(n[-trim:])) for i, n in enumerate(nums)]\n        trimmed_indices.sort(key=lambda x: (x[1], x[0]))\n        answer.append(trimmed_indices[k - 1][0])\n    return answer"
      ],
      [
        0.861985445022583,
        "    filtered_tuples = filter(func, tuples)\n    for tuple in filtered_tuples:\n        print(tuple)"
      ],
      [
        0.8612033128738403,
        "    arr.sort()\n    return arr[:-k]"
      ],
      [
        0.8598513603210449,
        "    filtered_elements = [x for x in a if x < b]\n    multiplied_elements = [x * fact for x in filtered_elements]\n    return tuple(multiplied_elements)"
      ]
    ],
    "MBPP/434": [
      [
        0.9073447585105896,
        "    if not isinstance(num_tuple, tuple):\n        return 'Error: The input must be a tuple.'\n    result = []\n    for i in range(len(num_tuple) - 1):\n        result.append(num_tuple[i] * num_tuple[i + 1])\n    return tuple(result)"
      ],
      [
        0.905329167842865,
        "    if not isinstance(t, tuple):\n        return 'Error: Input must be a tuple'\n    res = []\n    for i in range(len(t) - 1):\n        res.append(t[i] * t[i + 1])\n    return tuple(res)"
      ],
      [
        0.9053083658218384,
        "    if not isinstance(t, tuple):\n        return 'Error: Input must be a tuple'\n    res = []\n    for i in range(len(t) - 1):\n        res.append(t[i] * t[i + 1])\n    return tuple(res)"
      ],
      [
        0.9009976387023926,
        "    list3 = [x * y for x, y in zip(list1, list2)]\n    return list3"
      ],
      [
        0.9008083343505859,
        "    if not isinstance(input_tuple, tuple):\n        return 'Error: Input is not a tuple'\n    return tuple((input_tuple[i] * input_tuple[i + 1] for i in range(len(input_tuple) - 1)))"
      ],
      [
        0.900806188583374,
        "    if not isinstance(input_tuple, tuple):\n        return 'Error: Input is not a tuple'\n    return tuple((input_tuple[i] * input_tuple[i + 1] for i in range(len(input_tuple) - 1)))"
      ],
      [
        0.9007627964019775,
        "    if not isinstance(input_tuple, tuple):\n        return 'Error: Input is not a tuple'\n    if len(input_tuple) < 2:\n        return ()\n    return tuple((input_tuple[i] * input_tuple[i + 1] for i in range(len(input_tuple) - 1)))"
      ],
      [
        0.9007625579833984,
        "    if not isinstance(input_tuple, tuple):\n        return 'Error: Input is not a tuple'\n    if len(input_tuple) < 2:\n        return ()\n    return tuple((input_tuple[i] * input_tuple[i + 1] for i in range(len(input_tuple) - 1)))"
      ],
      [
        0.9005312919616699,
        "    multiply_list = []\n    for i in list1:\n        for j in list2:\n            multiply_list.append(i * j)\n    return multiply_list"
      ],
      [
        0.8997116088867188,
        "    if len(arr1) != len(arr2):\n        return 'Arrays are not of the same length! Cannot perform operation.'\n    result = [i * j for i, j in zip(arr1, arr2)]\n    return result"
      ]
    ],
    "MBPP/435": [
      [
        0.9118024110794067,
        "    output_dict = {}\n    for item in input_tuple:\n        output_dict[item] = output_dict.get(item, 0) + 1\n    return output_dict"
      ],
      [
        0.9101438522338867,
        "    count_dict = {element: 0 for element in elements}\n    for ele in lst:\n        if ele in count_dict:\n            count_dict[ele] += 1\n    return count_dict"
      ],
      [
        0.9090218544006348,
        "    elements = {}\n    for element in lst:\n        if element in elements:\n            elements[element] += 1\n        else:\n            elements[element] = 1\n    return elements"
      ],
      [
        0.9064193964004517,
        "    count_obj = Counter(input_tuple)\n    my_dict = dict(count_obj)\n    unique_dict = {key: 1 for key in my_dict.keys()}\n    return (unique_dict, my_dict)"
      ],
      [
        0.9064175486564636,
        "    count_obj = Counter(input_tuple)\n    my_dict = dict(count_obj)\n    unique_dict = {key: 1 for key in my_dict.keys()}\n    return (unique_dict, my_dict)"
      ],
      [
        0.90436851978302,
        "    lst = [tuple(flatten(sublist)) for sublist in lst if isinstance(sublist, list)]\n    return {t: lst.count(t) for t in set(lst)}"
      ],
      [
        0.9036709070205688,
        "    count_dict = {}\n    count_occurrences(nested_list, count_dict)\n    return count_dict"
      ],
      [
        0.9032517671585083,
        "    count = {}\n    for i in lst:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n    return count"
      ],
      [
        0.9032120108604431,
        "    counts = dict()\n    for item in lst:\n        if item in counts:\n            counts[item] += 1\n        else:\n            counts[item] = 1\n    return counts"
      ],
      [
        0.9028807282447815,
        "    count = 0\n    for i in tuple_input:\n        if isinstance(i, tuple):\n            count += count_occurrences(element, i)\n        elif i == element:\n            count += 1\n    return count"
      ]
    ],
    "MBPP/436": [
      [
        0.9254691004753113,
        "    cubes = []\n    for num in numbers:\n        cubes.append(num ** 3)\n    return cubes"
      ],
      [
        0.919926106929779,
        "    cube_numbers = []\n    for num in numbers:\n        cube = num ** 3\n        cube_numbers.append(cube)\n    return cube_numbers"
      ],
      [
        0.9177121520042419,
        "    output_list = []\n    for num in input_list:\n        output_list.append(num ** 3)\n    return output_list"
      ],
      [
        0.9149312973022461,
        "    output_list = []\n    for i in input_list:\n        output_list.append(i ** 3)\n    return output_list"
      ],
      [
        0.9113405346870422,
        "    for num in numbers:\n        cubes.append(num ** 3)"
      ],
      [
        0.909206748008728,
        "    return [i ** 3 for i in lst]"
      ],
      [
        0.9079571962356567,
        "    for num in numbers:\n        cube = num ** 3\n        cube_numbers.append(cube)"
      ],
      [
        0.907659113407135,
        "    result = []\n    for n in numbers:\n        result.append(n ** 3)\n    return result"
      ],
      [
        0.9071755409240723,
        "    new_lst = []\n    for item in lst:\n        if not isinstance(item, int):\n            continue\n        elif item < 0:\n            continue\n        else:\n            new_lst.append(item ** 3)\n    return new_lst"
      ],
      [
        0.9056129455566406,
        "    unique_numbers = list(set(numbers))\n    cubes = [num ** 3 for num in unique_numbers]\n    return cubes"
      ]
    ],
    "MBPP/437": [
      [
        0.8895450234413147,
        "    return sum(primes)"
      ],
      [
        0.8895249366760254,
        "    return sum(primes)"
      ]
    ],
    "MBPP/438": [
      [
        0.904704749584198,
        "    if point1 == point2 or point1 == point3 or point2 == point3:\n        return False"
      ],
      [
        0.9026561379432678,
        "    if point1 == point2 or point1 == point3 or point2 == point3:\n        return False\n    vector1 = [point2[i] - point1[i] for i in range(3)]\n    vector2 = [point3[i] - point1[i] for i in range(3)]\n    cross_product = [vector1[(i + 1) % 3] * vector2[(i + 2) % 3] - vector1[(i + 2) % 3] * vector2[(i + 1) % 3] for i in range(3)]\n    if all((c == 0 for c in cross_product)):\n        return False\n    return True"
      ],
      [
        0.8962662816047668,
        "    for i in range(len(points) - 2):\n        for j in range(i + 1, len(points) - 1):\n            for k in range(j + 1, len(points)):\n                side1 = calculate_distance(points[i], points[j])\n                side2 = calculate_distance(points[j], points[k])\n                side3 = calculate_distance(points[k], points[i])\n                if is_triangle(side1, side2, side3):\n                    return True\n    return False"
      ],
      [
        0.8958702087402344,
        "    x1, y1 = Point1\n    x2, y2 = Point2\n    x3, y3 = Point3\n    area = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2)\n    return area"
      ],
      [
        0.8948938846588135,
        "    p1, p2, p3 = points\n    if p1 == [0, 0] or p2 == [0, 0] or p3 == [0, 0]:\n        return (False, 0)\n    if (p2[0] - p1[0]) * (p3[1] - p1[1]) == (p3[0] - p1[0]) * (p2[1] - p1[1]):\n        return (False, 0)\n    else:\n        d12 = math.sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2)\n        d23 = math.sqrt((p3[0] - p2[0]) ** 2 + (p3[1] - p2[1]) ** 2)\n        return (True, round(d12 + d23, 2))"
      ],
      [
        0.8944434523582458,
        "    if a + b <= c or a + c <= b or b + c <= a:\n        return 'Not a valid triangle'\n    if a == b and b == c:\n        return 'Equilateral triangle'\n    if a != b and b != c and (a != c):\n        return 'Scalene triangle'\n    return 'Isosceles triangle'"
      ],
      [
        0.8929462432861328,
        "    if a + b > c and a + c > b and (b + c > a):\n        return True"
      ],
      [
        0.8929151296615601,
        "    if a + b > c and a + c > b and (b + c > a):\n        return True"
      ],
      [
        0.8926610946655273,
        "                if is_triangle(side1, side2, side3):\n                    return True"
      ],
      [
        0.8925926089286804,
        "    if a + b <= c or a + c <= b or b + c <= a:\n        return False\n    if a + b > c and a + c > b and (b + c > a):\n        return True\n    return False"
      ]
    ],
    "MBPP/439": [
      [
        0.885992169380188,
        "    result = []\n    for string in strings:\n        if len(string) >= length:\n            result.append(string)\n    return result"
      ],
      [
        0.8841390013694763,
        "    if size > len(string):\n        return 'Error: substring size is greater than string length.'"
      ],
      [
        0.8824304938316345,
        "    for count in range(1, size):\n        current = ''\n        for x in random.sample(alpha, random.randint(min_length, max_length)):\n            current += x\n        strings.append(current)"
      ],
      [
        0.8824125528335571,
        "    return [s for s in strings if len(s) > n]"
      ],
      [
        0.8817259669303894,
        "    alpha = 'abcdefghijklmnopqrstuvwxyz'\n    min_length = 3\n    max_length = 8\n    strings = []\n    for count in range(1, size):\n        current = ''\n        for x in random.sample(alpha, random.randint(min_length, max_length)):\n            current += x\n        strings.append(current)\n    return strings"
      ],
      [
        0.8816459774971008,
        "    for string in strings:\n        if len(string) >= length:\n            result.append(string)"
      ],
      [
        0.8815313577651978,
        "    return [string for string in strings if len(string) == length]"
      ],
      [
        0.8802922964096069,
        "    extracted_elements = []\n    for i in range(3):\n        extracted_elements.append(lst[i])\n    return extracted_elements"
      ],
      [
        0.8796381950378418,
        "    split_list = []\n    for i in range(0, len(string), sz):\n        split_list.append(string[i:i + sz])\n    return split_list"
      ],
      [
        0.8790945410728455,
        "    desiredStringList = []\n    for string in stringList:\n        if len(string) > desiredLength:\n            desiredStringList.append(string)\n    return desiredStringList"
      ]
    ],
    "MBPP/440": [
      [
        0.912913978099823,
        "    result = []\n    for character in string:\n        if character != ' ':\n            result.append(character)\n    return ''.join(result)"
      ],
      [
        0.9103294014930725,
        "    new_string = ''\n    for char in string:\n        if char != ' ':\n            new_string += char\n    return new_string"
      ],
      [
        0.9102904796600342,
        "    new_string = ''\n    for char in string:\n        if char != ' ':\n            new_string += char\n    return new_string"
      ],
      [
        0.9099464416503906,
        "    result = ''\n    for char in given_string:\n        if char != ' ':\n            result += char\n    return result"
      ],
      [
        0.9095306992530823,
        "    new_str = ''\n    for char in str:\n        if char != ' ':\n            new_str += char\n    return new_str"
      ],
      [
        0.9089391231536865,
        "    new_str = ''\n    for letter in str:\n        if letter != ' ':\n            new_str = new_str + letter\n    return new_str"
      ]
    ],
    "MBPP/441": [
      [
        0.8845697641372681,
        "    loss_percentage = (expenses - revenue) / revenue * 100\n    return round(loss_percentage, 2)"
      ],
      [
        0.8807976245880127,
        "    if amount == 0:\n        return 0"
      ],
      [
        0.8807945251464844,
        "    if amount == 0:\n        return 0"
      ],
      [
        0.8807939291000366,
        "    if amount == 0:\n        return 0"
      ],
      [
        0.8807799816131592,
        "    if amount == 0:\n        return 0"
      ],
      [
        0.8754151463508606,
        "    if cost == 0 and profit > 0:\n        return profit"
      ],
      [
        0.8732509613037109,
        "    if total > target_number:\n        return 'win'\n    else:\n        return 'loss'"
      ],
      [
        0.87313312292099,
        "            if amount < 0:\n                return 'Invalid operation encountered.'"
      ],
      [
        0.8700846433639526,
        "    return amount / total * 100"
      ],
      [
        0.8699232935905457,
        "    if total_amount < 0:\n        print('Invalid total amount!')\n        return None"
      ]
    ],
    "MBPP/442": [],
    "MBPP/443": [
      [
        0.8885781764984131,
        "    pattern = re.compile('a.*Z')\n    return pattern.findall(text)"
      ],
      [
        0.8863974213600159,
        "    regexp = 'ba[r|z|d]'\n    if re.search(regexp, word):\n        return True\n    return False"
      ],
      [
        0.8853644132614136,
        "    locations = [m.start() for m in re.finditer('zy{2,}', input_string.lower())]\n    if not locations:\n        return \"Sequence 'z' followed by minimum two 'y's does not appear in the text.\"\n    else:\n        return locations"
      ],
      [
        0.8834999203681946,
        "    pattern = '^a[A-Za-z0-9]*Z$'\n    match = re.match(pattern, s)\n    if match:\n        print(f'The string {s} matches the pattern')\n    else:\n        print(f'The string {s} does not match the pattern')"
      ],
      [
        0.881903886795044,
        "    match = re.search('z[yY]{2,}', s, re.IGNORECASE)\n    if match:\n        return match.start()\n    else:\n        return -1"
      ],
      [
        0.8818187117576599,
        "    if not locations:\n        return \"Sequence 'z' followed by minimum two 'y's does not appear in the text.\"\n    else:\n        return locations"
      ],
      [
        0.8815743923187256,
        "    pattern = 'a.*[0-9].*Z'\n    matches = re.findall(pattern, text)\n    return matches"
      ],
      [
        0.8812440037727356,
        "    if match:\n        print('Valid word')\n    else:\n        print('Invalid word')"
      ],
      [
        0.8812144994735718,
        "    return re.search(word, string)"
      ],
      [
        0.8791967034339905,
        "    pattern = '^abc.*xyz$'\n    if re.match(pattern, string):\n        return True\n    return False"
      ]
    ],
    "MBPP/444": [
      [
        0.9050912261009216,
        "    thirty_days_months = [4, 6, 9, 11]\n    if month in thirty_days_months:\n        return True\n    elif month == 2:\n        if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            return False\n        else:\n            return True\n    else:\n        return False"
      ],
      [
        0.9014586210250854,
        "    if month in thirty_days_months:\n        return True\n    elif month == 2:\n        if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            return False\n        else:\n            return True\n    else:\n        return False"
      ],
      [
        0.8948206305503845,
        "    if month < 1 or month > 12:\n        return 'No'"
      ],
      [
        0.8908665180206299,
        "    if month == 'January' or month == 'March' or month == 'May' or (month == 'July') or (month == 'August') or (month == 'October') or (month == 'December'):\n        return '31 days'\n    elif month == 'April' or month == 'June' or month == 'September' or (month == 'November'):\n        return '30 days'\n    elif month == 'February':\n        return '28 or 29 days'\n    else:\n        return 'Invalid input'"
      ],
      [
        0.8908665180206299,
        "    if month == 'January' or month == 'March' or month == 'May' or (month == 'July') or (month == 'August') or (month == 'October') or (month == 'December'):\n        return '31 days'\n    elif month == 'April' or month == 'June' or month == 'September' or (month == 'November'):\n        return '30 days'\n    elif month == 'February':\n        return '28 or 29 days'\n    else:\n        return 'Invalid input'"
      ],
      [
        0.8869708776473999,
        "    elif month == 'April' or month == 'June' or month == 'September' or (month == 'November'):\n        return '30 days'\n    elif month == 'February':\n        return '28 or 29 days'\n    else:\n        return 'Invalid input'"
      ],
      [
        0.8859248757362366,
        "    if day < 1 or day > 31:\n        return 'No'"
      ],
      [
        0.8841612935066223,
        "    if day < 1 or day > 31:\n        return False"
      ],
      [
        0.8832229971885681,
        "    if month in [2, 4, 6, 9, 11]:\n        return 30"
      ],
      [
        0.8823087811470032,
        "    if month in [4, 6, 9, 11]:\n        return 30"
      ]
    ],
    "MBPP/445": [
      [
        0.9245067834854126,
        "    reversed_list = []\n    for string in list_of_strings:\n        reversed_list.append(string[::-1])\n    return reversed_list"
      ],
      [
        0.9218053817749023,
        "    revList = []\n    for string in list:\n        revList.append(string[::-1])\n    return revList"
      ],
      [
        0.9216699004173279,
        "    return [s[::-1] for s in list_of_strings]"
      ],
      [
        0.9198617935180664,
        "    reversed_strings = []\n    for string in strings:\n        reversed_strings.append(string[::-1])\n    return reversed_strings"
      ],
      [
        0.9194384813308716,
        "    reversed_strings = []\n    for string in strings:\n        reversed_string = string[::-1]\n        reversed_strings.append(reversed_string)\n    reversed_list = reversed(reversed_strings)\n    return list(reversed_list)"
      ],
      [
        0.9171274900436401,
        "    for string in list_of_strings:\n        reversed_list.append(string[::-1])"
      ],
      [
        0.9161072969436646,
        "    reversed_list = []\n    for string in input_list:\n        reversed_string = string[::-1]\n        reversed_list.append(reversed_string)\n    return reversed_list"
      ],
      [
        0.9146242141723633,
        "    if len(strings) == 0:\n        return\n    strings[0] = strings[0][::-1]\n    reverse_strings(strings[1:])"
      ],
      [
        0.9124729037284851,
        "    for string in strings:\n        print(string[::-1])"
      ],
      [
        0.9124729037284851,
        "    for string in strings:\n        print(string[::-1])"
      ]
    ],
    "MBPP/446": [
      [
        0.897953450679779,
        "            if subsequence_length < min_length:\n                min_length = subsequence_length"
      ],
      [
        0.8953614234924316,
        "                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring"
      ],
      [
        0.8945786952972412,
        "    if minlength == n + 1:\n        print('Not Possible')\n    else:\n        print('Minimum length of subarray is: %d' % minlength)"
      ],
      [
        0.8930480480194092,
        "    min_value = min(list1)\n    return min_value"
      ],
      [
        0.8881316781044006,
        "    input_list = list(set(input_list))\n    return find_min(input_list)"
      ],
      [
        0.8879355192184448,
        "    shortest_words = []\n    min_length = len(words_list[0])\n    for word in words_list:\n        if len(word) < min_length:\n            min_length = len(word)\n            shortest_words = [word]\n        elif len(word) == min_length:\n            shortest_words.append(word)\n    return shortest_words"
      ]
    ],
    "MBPP/447": [
      [
        0.9093777537345886,
        "    area = length * width\n    return area"
      ],
      [
        0.9093619585037231,
        "    area = length * width\n    return area"
      ],
      [
        0.9086649417877197,
        "    area = width * height\n    return area"
      ]
    ],
    "MBPP/448": [
      [
        0.9096239805221558,
        "    uppercase_letters = []\n    for char in string:\n        if char.isupper():\n            uppercase_letters.append(char.lower())\n    return uppercase_letters"
      ],
      [
        0.9065970778465271,
        "    return ''.join([char for char in my_string if char.isupper()])"
      ],
      [
        0.9064533710479736,
        "    return ''.join([c for c in string if not c.isupper()])"
      ],
      [
        0.9022455215454102,
        "    pattern = '[aeiouAEIOU]'\n    result = re.sub(pattern, '', string)\n    return result"
      ],
      [
        0.9017557501792908,
        "    newStr = ''\n    for i in range(len(my_string)):\n        if my_string[i] != 'c' and my_string[i] != 'C':\n            newStr += my_string[i]\n    return newStr"
      ],
      [
        0.900752604007721,
        "    char = char.lower()\n    modified_string = ''\n    i = 0\n    while i < len(string):\n        current_char = string[i].lower()\n        if current_char == char:\n            i += 1\n        else:\n            modified_string += string[i]\n            i += 1\n    return modified_string"
      ],
      [
        0.9007343649864197,
        "    new_string = ''\n    for char in original_string:\n        if char.isupper():\n            new_string += char\n    if len(new_string) > 5 and any((char in string.punctuation for char in new_string)):\n        return new_string\n    return 'No such string exists'"
      ],
      [
        0.8988962173461914,
        "    words = sentence.split()\n    new_words = []\n    for word in words:\n        if len(word) > 4:\n            new_words.append(re.sub('(?!^)[A-Za-z]', '', word))\n        else:\n            new_words.append(word)\n    return ' '.join(new_words)"
      ],
      [
        0.898874044418335,
        "    output = ''\n    for char in input:\n        output += char.upper()\n    return output"
      ],
      [
        0.8984107971191406,
        "    result = ''\n    for char in string:\n        result += chr(ord(char) - 32)\n    return result"
      ]
    ],
    "MBPP/449": [
      [
        0.8925334215164185,
        "    if not x:\n        return 'List is empty, cannot access first element.'\n    else:\n        return x[0]"
      ],
      [
        0.8925334215164185,
        "    if not x:\n        return 'List is empty, cannot access first element.'\n    else:\n        return x[0]"
      ],
      [
        0.8911629915237427,
        "                if all((elem == first for elem in sub_list)):\n                    result.append(first)\n                else:\n                    result.append(None)"
      ],
      [
        0.8892512917518616,
        "    if not nested_list:\n        return []\n    first_list, remaining_lists = (nested_list[0], nested_list[1:])\n    flat_list = []\n    for element in first_list:\n        flat_list.append(element)\n    return flat_list + flatten_list(remaining_lists)"
      ],
      [
        0.8892464637756348,
        "    if not nested_list:\n        return []\n    first_list, remaining_lists = (nested_list[0], nested_list[1:])\n    flat_list = []\n    for element in first_list:\n        flat_list.append(element)\n    return flat_list + flatten_list(remaining_lists)"
      ],
      [
        0.8881439566612244,
        "        for sub_list in lists:\n            if sub_list:\n                first = sub_list[0]\n                if all((elem == first for elem in sub_list)):\n                    result.append(first)\n                else:\n                    result.append(None)\n            else:\n                result.append(None)"
      ],
      [
        0.887656569480896,
        "    elif len(lst) == 0:\n        return 'Error: The list is empty.'\n    else:\n        return lst[0]"
      ],
      [
        0.8875497579574585,
        "    for element in first_list:\n        flat_list.append(element)"
      ],
      [
        0.8875055313110352,
        "    for element in first_list:\n        flat_list.append(element)"
      ],
      [
        0.884954571723938,
        "    last_elements = []\n    for string in str_list:\n        last_elements.append(string[-1])\n    return last_elements"
      ]
    ],
    "MBPP/450": [
      [
        0.9476606845855713,
        "    count = 0\n    for c in string:\n        if c.isupper():\n            count += 1\n    return count"
      ],
      [
        0.9471309185028076,
        "    count = 0\n    for char in string:\n        if char.isupper():\n            count += 1\n    return count"
      ],
      [
        0.9471287727355957,
        "    count = 0\n    for char in string:\n        if char.isupper():\n            count += 1\n    return count"
      ],
      [
        0.9447680115699768,
        "    count = 0\n    for i in range(len(string)):\n        if string[i].isupper():\n            count += 1\n    return count"
      ],
      [
        0.9397033452987671,
        "    uppercase_count = 0\n    for char in my_str:\n        if char.isupper():\n            uppercase_count += 1\n    return uppercase_count"
      ],
      [
        0.9368977546691895,
        "    chars = [c for c in string if c.isupper()]\n    return len(chars)"
      ],
      [
        0.9361090660095215,
        "    uppercase_chars = [char for char in string if char.isupper()]\n    return len(uppercase_chars)"
      ],
      [
        0.9356614351272583,
        "    count = 0\n    for letter in sentence:\n        if letter.isupper():\n            count += 1\n    return count"
      ],
      [
        0.9356536865234375,
        "    uppercaseCount = 0\n    for l in myStr:\n        if l.isupper():\n            uppercaseCount += 1\n    return uppercaseCount"
      ],
      [
        0.932588517665863,
        "    for char in string:\n        if char.isupper():\n            count += 1"
      ]
    ],
    "MBPP/451": [
      [
        0.9189703464508057,
        "    all_combinations = []\n    for r in range(1, len(elements) + 1):\n        all_combinations.extend(list(combinations(elements, r)))\n    return [list(comb) for comb in all_combinations]"
      ],
      [
        0.9175745844841003,
        "    combinations = []\n    for r in range(1, len(input_list) + 1):\n        for subset in itertools.combinations(input_list, r):\n            combinations.append(list(subset))\n    return combinations"
      ],
      [
        0.9157172441482544,
        "    for combination in all_combinations(list_of_numbers[1:]):\n        combinations.append(combination)\n        combinations.append([list_of_numbers[0]] + combination)"
      ],
      [
        0.9155226945877075,
        "    result = []\n    for r in range(1, len(input_list) + 1):\n        combinations = [list(comb) for comb in itertools.combinations(input_list, r)]\n        result.extend(combinations)\n    return result"
      ],
      [
        0.9139996767044067,
        "    result = []\n    for i in range(len(items)):\n        for comb in combinations(items[i + 1:]):\n            result.append([items[i]] + comb)\n    if result == []:\n        result = [items]\n    return result"
      ],
      [
        0.9132816195487976,
        "    unique_lst = list(set(lst))\n    combinations = []\n    for r in range(1, len(unique_lst) + 1):\n        combinations.extend(list(itertools.combinations(unique_lst, r)))\n    return combinations"
      ],
      [
        0.9132431745529175,
        "    comb_list = []\n    for subset in itertools.combinations(input_list, len(input_list)):\n        comb_list.append(subset)\n    return comb_list"
      ],
      [
        0.9131875038146973,
        "    return [comb for r in range(len(lst) + 1) for comb in itertools.combinations(lst, r)]"
      ],
      [
        0.9130813479423523,
        "        for subset in itertools.combinations(input_list, r):\n            combinations.append(list(subset))"
      ],
      [
        0.9125500917434692,
        "    if len(list_of_numbers) == 0:\n        return []\n    if len(list_of_numbers) == 1:\n        return [list_of_numbers]\n    combinations = []\n    for combination in all_combinations(list_of_numbers[1:]):\n        combinations.append(combination)\n        combinations.append([list_of_numbers[0]] + combination)\n    return combinations"
      ]
    ],
    "MBPP/452": [
      [
        0.9195914268493652,
        "    arr = np.array(arr).flatten().tolist()\n    max_product = 0\n    max_subset = None\n    for L in range(0, len(arr) + 1):\n        for subset in itertools.combinations(arr, L):\n            product = find_product(list(subset))\n            if product > max_product:\n                max_product = product\n                max_subset = subset\n    return (max_product, max_subset)"
      ]
    ],
    "MBPP/453": [
      [
        0.897168755531311,
        "    if len(arr) == 0:\n        return False\n    return all((arr[0] == x for x in arr))"
      ],
      [
        0.8898068070411682,
        "    first_elem = arr[0]\n    is_equal = True\n    for elem in arr:\n        if elem != first_elem:\n            is_equal = False\n            break\n    return is_equal"
      ],
      [
        0.8881235122680664,
        "    elif all((x == arr[0] for x in arr)):\n        return True\n    else:\n        return False"
      ],
      [
        0.8881117105484009,
        "    for i in dictionary.values():\n        if i != 0:\n            return False"
      ],
      [
        0.884279727935791,
        "    if not lst:\n        return True\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True"
      ],
      [
        0.8838211297988892,
        "    if len(lst) == 0:\n        return False\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True"
      ],
      [
        0.8826813697814941,
        "    for i in range(len(my_list)):\n        for j in range(i + 1, len(my_list)):\n            if my_list[i] != my_list[j]:\n                return False\n    return True"
      ],
      [
        0.8819684982299805,
        "    if all((value == 0 for value in dict1.values())):\n        return True"
      ],
      [
        0.8813706636428833,
        "    for key, value in dict1.items():\n        if key not in dict2 or dict2[key] != value:\n            return False\n    return True"
      ],
      [
        0.8800814151763916,
        "    if len(lst) == 0:\n        return True\n    first_element = lst[0]\n    for i in range(1, len(lst)):\n        if lst[i] != first_element:\n            return False\n    return True"
      ]
    ],
    "MBPP/454": [
      [
        0.8968591690063477,
        "            if isinstance(item, dict) and (not item):\n                dictionary.remove(item)\n            elif isinstance(item, list) and (not any(item)):\n                dictionary.remove(item)"
      ],
      [
        0.8914474844932556,
        "            elif isinstance(item, list) and (not any(item)):\n                dictionary.remove(item)"
      ],
      [
        0.8887366056442261,
        "            if isinstance(item, dict) and (not item):\n                nested_dict.remove(item)"
      ],
      [
        0.886551022529602,
        "    return {k: v for k, v in my_dict.items() if v}"
      ],
      [
        0.8831729292869568,
        "        for key, value in dictionary.items():\n            if isinstance(value, dict):\n                if check_empty_dict(value) == False:\n                    return False\n            else:\n                return False"
      ],
      [
        0.8831636905670166,
        "        for key, value in dictionary.items():\n            if isinstance(value, dict):\n                if check_empty_dict(value) == False:\n                    return False\n            else:\n                return False"
      ],
      [
        0.8831562995910645,
        "    new_dict = {}\n    for k, v in dictionary.items():\n        if k == key:\n            continue\n        else:\n            new_dict[k] = v\n    return new_dict"
      ],
      [
        0.8831527233123779,
        "    if key in dictionary:\n        del dictionary[key]\n    return dictionary"
      ],
      [
        0.882783055305481,
        "    for key, value in theDict.items():\n        if not value:\n            print(f'The list {key} is empty.')\n            continue\n        stuff = []\n        for d in value:\n            if d != ' ':\n                stuff.append(d)\n                print(d)\n                theDict[key] = stuff\n    return theDict"
      ],
      [
        0.882696270942688,
        "            if isinstance(dictionary[key], dict) and (not dictionary[key]):\n                del dictionary[key]\n            elif isinstance(dictionary[key], list) and (not any(dictionary[key])):\n                del dictionary[key]"
      ]
    ],
    "MBPP/455": [
      [
        0.9345149993896484,
        "    n = len(arr)\n    if n == 1:\n        return arr[0]\n    mid = n // 2\n    if arr[mid] > arr[mid - 1] and arr[mid] > arr[mid + 1]:\n        return arr[mid]\n    elif arr[mid - 1] > arr[mid]:\n        return find_peak(arr[:mid])\n    else:\n        return find_peak(arr[mid + 1:])"
      ],
      [
        0.9260571002960205,
        "    if arr[mid] > arr[mid - 1] and arr[mid] > arr[mid + 1]:\n        return arr[mid]\n    elif arr[mid - 1] > arr[mid]:\n        return find_peak(arr[:mid])\n    else:\n        return find_peak(arr[mid + 1:])"
      ],
      [
        0.9255742430686951,
        "    elif arr[mid - 1] > arr[mid]:\n        return find_peak(arr[:mid])\n    else:\n        return find_peak(arr[mid + 1:])"
      ],
      [
        0.9200321435928345,
        "    highest_peak = arr[0]\n    for i in range(1, len(arr)):\n        highest_peak = max(highest_peak, arr[i])\n    return highest_peak"
      ],
      [
        0.90463787317276,
        "    if len(arr) == 1:\n        return arr[0]\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    max_left = find_max(left_half)\n    max_right = find_max(right_half)\n    return max(max_left, max_right)"
      ],
      [
        0.9035400748252869,
        "    highest_peak = elevations[0]\n    highest_peak_index = 0\n    for i in range(1, len(elevations)):\n        if elevations[i] >= highest_peak:\n            highest_peak = elevations[i]\n            highest_peak_index = i\n    return highest_peak_index"
      ],
      [
        0.9034762382507324,
        "    return find_max(arr, 0, len(arr) - 1)"
      ],
      [
        0.9026440382003784,
        "    peak_indices = []\n    for i in range(1, len(lst) - 1):\n        if lst[i] > lst[i - 1] and lst[i] > lst[i + 1]:\n            peak_indices.append(i)\n    num_peaks = len(peak_indices)\n    return (num_peaks, peak_indices)"
      ],
      [
        0.9021828174591064,
        "    supreme = array[0]\n    for i in array:\n        if i > supreme:\n            supreme = i\n    return supreme"
      ],
      [
        0.9020195603370667,
        "    highest_peak_index = 0\n    highest_peak_height = elevations[0]\n    for i in range(1, len(elevations)):\n        if elevations[i] > highest_peak_height:\n            highest_peak_index = i\n            highest_peak_height = elevations[i]\n        elif elevations[i] == highest_peak_height:\n            highest_peak_index = i\n    return highest_peak_index"
      ]
    ],
    "MBPP/456": [
      [
        0.9353828430175781,
        "    octal_number = oct(decimal_number).replace('0o', '')\n    return octal_number"
      ],
      [
        0.9271662831306458,
        "    binary_num = str(binary_num)\n    decimal = int(binary_num, 2)\n    octal_num = oct(decimal).replace('0o', '')\n    return octal_num"
      ],
      [
        0.9231677055358887,
        "    decimal = int(octal_num, 8)\n    binary = bin(decimal).replace('0b', '')\n    return binary"
      ],
      [
        0.9231560230255127,
        "    decimal = int(octal_num, 8)\n    binary = bin(decimal).replace('0b', '')\n    return binary"
      ],
      [
        0.9230923652648926,
        "    oct_num = oct(num)\n    print('The octal form of {} is {}'.format(num, oct_num))"
      ],
      [
        0.9153474569320679,
        "    decimal = int(binary_num, 2)\n    return oct(decimal)[2:]"
      ],
      [
        0.915035605430603,
        "    decimal = 0\n    base = 1\n    while octal:\n        last_digit = octal % 10\n        octal = int(octal / 10)\n        decimal += last_digit * base\n        base = base * 8\n    return decimal"
      ],
      [
        0.9147788286209106,
        "    decimal = int(bin_str, 2)\n    octal_str = oct(decimal)[2:]\n    return octal_str"
      ],
      [
        0.9132139086723328,
        "    if octal == 0:\n        return 0\n    else:\n        last_digit = octal % 10\n        decimal = last_digit * 8 ** 0\n        binary = decimal_to_binary(decimal)\n        return binary + 10 * octal_to_binary(octal // 10)"
      ],
      [
        0.9132139086723328,
        "    if octal == 0:\n        return 0\n    else:\n        last_digit = octal % 10\n        decimal = last_digit * 8 ** 0\n        binary = decimal_to_binary(decimal)\n        return binary + 10 * octal_to_binary(octal // 10)"
      ]
    ],
    "MBPP/457": [
      [
        0.9069518446922302,
        "    max_product = float('-inf')\n    for window_start in range(len(arr)):\n        prod = 1\n        for window_end in range(window_start, len(arr)):\n            prod *= arr[window_end]\n            max_product = max(prod, max_product)\n    return max_product"
      ],
      [
        0.9046496152877808,
        "    for num in max_sublist:\n        product *= num"
      ],
      [
        0.9046326875686646,
        "    for num in max_sublist:\n        product *= num"
      ],
      [
        0.9035239219665527,
        "    for window_start in range(len(arr)):\n        prod = 1\n        for window_end in range(window_start, len(arr)):\n            prod *= arr[window_end]\n            max_product = max(prod, max_product)"
      ],
      [
        0.9033311009407043,
        "    max_product = float('-inf')\n    max_positive = float('-inf')\n    max_negative = 0\n    for num in arr:\n        if num >= max_positive:\n            max_product = num * max_positive\n        elif num < max_negative:\n            max_product = num * max_negative\n        if num < 0 and abs(num) > abs(max_negative):\n            max_negative = num\n        elif num > 0 and num <= max_positive:\n            max_positive = num\n    return max_product"
      ],
      [
        0.9024168252944946,
        "    for num in arr:\n        if num >= max_positive:\n            max_product = num * max_positive\n        elif num < max_negative:\n            max_product = num * max_negative\n        if num < 0 and abs(num) > abs(max_negative):\n            max_negative = num\n        elif num > 0 and num <= max_positive:\n            max_positive = num"
      ],
      [
        0.9023601412773132,
        "    n = len(arr)\n    max_end = [0] * n\n    seq = [''] * n\n    max_end[0] = arr[0]\n    seq[0] = str(arr[0])\n    max_product_so_far = float('-inf')\n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                if max_end[j] * arr[i] > max_end[i]:\n                    max_end[i] = max_end[j] * arr[i]\n                    seq[i] = seq[j] + ' ' + str(arr[i])\n        max_product_so_far = max(max_product_so_far, max_end[i]) if max_end[i] else max_product_so_far\n    idx = max_end.index(max_product_so_far)\n    print('The maximum product is ' + str(max_product_so_far))\n    print('The sequence is ' + str(seq[idx]))"
      ],
      [
        0.9019322991371155,
        "    max_combo = []\n    value = 1\n    for x in arr:\n        value = value * x\n        max_combo.append(value)\n    return max_combo"
      ]
    ],
    "MBPP/458": [],
    "MBPP/459": [
      [
        0.9097073078155518,
        "    for a, b in tpl1:\n        for c, d in tpl2:\n            return (a + c, b + d)"
      ],
      [
        0.9097073078155518,
        "    for a, b in tpl1:\n        for c, d in tpl2:\n            return (a + c, b + d)"
      ],
      [
        0.8991755247116089,
        "        for c, d in tpl2:\n            return (a + c, b + d)"
      ],
      [
        0.8974776268005371,
        "    results = []\n    for n1 in list1:\n        for n2 in list2:\n            results.append(n1 + n2)\n    return results"
      ],
      [
        0.8974767923355103,
        "    results = []\n    for n1 in list1:\n        for n2 in list2:\n            results.append(n1 + n2)\n    return results"
      ],
      [
        0.8954542279243469,
        "    for i in tuples:\n        if isinstance(i, tuple):\n            cum_sum = recursive_sum(i, cum_sum)\n        elif isinstance(i, (int, float)):\n            cum_sum += i\n    return cum_sum"
      ],
      [
        0.8946802616119385,
        "    additions = []\n    for i in range(len(list1)):\n        additions.append(list1[i] + list2[i])\n    return additions"
      ],
      [
        0.8931264281272888,
        "    result = []\n    for tup in tuples:\n        value_sum = sum(tup)\n        if value_sum % 2 == 0:\n            result.append((tup[0] + 1, tup[1] + 1))\n        else:\n            result.append((tup[0] * 2, tup[1] * 2))\n    return result"
      ],
      [
        0.8924336433410645,
        "    total = 0\n    for t in tuples:\n        total += sum(t)\n    return total"
      ],
      [
        0.8912053108215332,
        "    total = 0\n    for i in tuples:\n        if isinstance(i, tuple):\n            total += cumul_sum(i)\n        elif isinstance(i, (int, float)):\n            total += i\n        elif isinstance(i, complex):\n            total += i.real\n    return total"
      ]
    ],
    "MBPP/460": [
      [
        0.8980403542518616,
        "    if n == 0:\n        return \"Error: 'n' must not be zero.\"\n    else:\n        return sum(set((x for x in array if x % n == 0)))"
      ],
      [
        0.8980403542518616,
        "    if n == 0:\n        return \"Error: 'n' must not be zero.\"\n    else:\n        return sum(set((x for x in array if x % n == 0)))"
      ],
      [
        0.8979998230934143,
        "    if n == 0:\n        return \"Error: 'n' must not be zero.\"\n    else:\n        return sum(set((x for x in array if x % n == 0)))"
      ],
      [
        0.8979998230934143,
        "    if n == 0:\n        return \"Error: 'n' must not be zero.\"\n    else:\n        return sum(set((x for x in array if x % n == 0)))"
      ],
      [
        0.8943204879760742,
        "    quotient = n1 // n2\n    remainder = n1 - n2 * quotient\n    return remainder"
      ],
      [
        0.8930365443229675,
        "    number_list = []\n    for i in range(len(arr)):\n        if arr[i] % n == 0:\n            number_list.append(arr[i])\n    return number_list"
      ],
      [
        0.8913953304290771,
        "    result = 0\n    i = 0\n    while i < len(array):\n        result += array[i]\n        i += n\n    return result"
      ],
      [
        0.8903977870941162,
        "    for num in array:\n        result = result * num % mod"
      ],
      [
        0.8903887867927551,
        "    for num in array:\n        result = result * num % mod"
      ],
      [
        0.8897864818572998,
        "        for i in range(len(arr)):\n            arr[i] += quotient\n            if remainder > 0:\n                arr[i] += 1\n                remainder -= 1"
      ]
    ],
    "MBPP/461": [
      [
        0.9053342342376709,
        "    arr.sort()\n    for i in range(len(arr) - 1):\n        if arr[i + 1] - arr[i] == 1:\n            return True\n    return False"
      ],
      [
        0.9030659198760986,
        "    if len(input_list) <= 1:\n        return True\n    for index, item in enumerate(input_list[1:]):\n        if item - input_list[index] != 1:\n            return False\n    return True"
      ],
      [
        0.9028716087341309,
        "    count = 0\n    for i in range(0, len(arr)):\n        if i + 1 < len(arr) and arr[i] + 1 == arr[i + 1]:\n            count += 1\n    if count > 0:\n        return True\n    else:\n        return False"
      ],
      [
        0.9017377495765686,
        "    for i in range(len(arr) - 1):\n        if arr[i] + 1 == arr[i + 1]:\n            return True\n    return False"
      ],
      [
        0.9017150402069092,
        "    for i in range(len(arr) - 1):\n        if arr[i] + 1 == arr[i + 1]:\n            return True"
      ],
      [
        0.9008446931838989,
        "    for i in range(len(arr) - 1):\n        if arr[i + 1] - arr[i] == 1:\n            return True"
      ],
      [
        0.9000803232192993,
        "    if len(arr) == 0:\n        return True\n    arr.sort()\n    for i in range(len(arr) - 1):\n        if arr[i] + 1 != arr[i + 1]:\n            return False\n    return True"
      ],
      [
        0.8969259262084961,
        "    diff = lst[1] - lst[0]\n    for index in range(len(lst) - 1):\n        if not lst[index + 1] - lst[index] == diff:\n            return False\n    return True"
      ],
      [
        0.8967772126197815,
        "    if not nums:\n        return False\n    nums.sort()\n    for i in range(1, len(nums)):\n        if nums[i] != nums[i - 1] + 1:\n            return False\n    return True"
      ],
      [
        0.8964623808860779,
        "    arr.sort()\n    for i in range(len(arr) - 1):\n        if arr[i + 1] - arr[i] != 1:\n            return False\n    return True"
      ]
    ],
    "MBPP/462": [
      [
        0.9018163681030273,
        "    sets = map(set, lists)\n    intersection = reduce(set.intersection, sets)\n    return sorted(intersection)"
      ],
      [
        0.9009712338447571,
        "    list_of_sets = [set(lst) for lst in list_of_lists]\n    common_set = set.intersection(*list_of_sets)\n    common_list = list(common_set)\n    return common_list"
      ],
      [
        0.8990825414657593,
        "    common_elements = set(list_of_arrays[0])\n    for array in list_of_arrays:\n        common_elements.intersection_update(array)\n    return list(common_elements)"
      ],
      [
        0.8980200290679932,
        "    intersection_list = []\n    for elem1 in my_list1:\n        for elem2 in my_list2:\n            if isinstance(elem1, (list, tuple)) and isinstance(elem2, (list, tuple)):\n                if intersection(elem1, elem2, cmp_func):\n                    intersection_list.append(elem1)\n                    break\n            elif not isinstance(elem1, (list, tuple)) and (not isinstance(elem2, (list, tuple))):\n                if cmp_func(elem1, elem2) == 0:\n                    intersection_list.append(elem1)\n                    break\n    return intersection_list"
      ],
      [
        0.8975239992141724,
        "    intersection_list = list(set(list1) & set(list2))\n    return intersection_list"
      ],
      [
        0.8971045017242432,
        "    result = []\n    for i in list1:\n        if i in tuple1:\n            result.append(i)\n    return result"
      ],
      [
        0.8966907858848572,
        "    intersection = list(set(list1) & set(list2))\n    return intersection"
      ],
      [
        0.8966842293739319,
        "    intersection = list(set(list1) & set(list2))\n    return intersection"
      ],
      [
        0.895997166633606,
        "    set1 = set(input_list1)\n    set2 = set(input_list2)\n    return list(set1.intersection(set2))"
      ],
      [
        0.895891547203064,
        "    common_items = set1.intersection(set2)\n    intersection_list = [item for item in set1 if item in common_items]\n    return intersection_list"
      ]
    ],
    "MBPP/463": [
      [
        0.9183146953582764,
        "    modified_string = input_string.replace(char_to_replace, replacement_char)\n    return modified_string"
      ],
      [
        0.9163460731506348,
        "    new_string = ''\n    for char in string:\n        if char == c1:\n            new_string += c2\n        else:\n            new_string += char\n    return new_string"
      ],
      [
        0.9147973656654358,
        "    new_string = ''\n    for char in string:\n        if char == old_char:\n            new_string += new_char\n        else:\n            new_string += char\n    return new_string"
      ]
    ],
    "MBPP/464": [
      [
        0.8978530168533325,
        "    sorted_dict = {}\n    for key, value in sorted(dictionary.items(), key=lambda item: item[1]):\n        sorted_dict[key] = value\n    return sorted_dict"
      ],
      [
        0.8978281021118164,
        "    sorted_dict = {}\n    for key, value in sorted(dictionary.items(), key=lambda item: item[1]):\n        sorted_dict[key] = value\n    return sorted_dict"
      ],
      [
        0.897257387638092,
        "    inv_dict = {v: k for k, v in my_dict.items()}\n    sorted_dict = dict(sorted(inv_dict.items(), key=lambda item: item[1], reverse=True))\n    return sorted_dict"
      ],
      [
        0.897246778011322,
        "    inv_dict = {v: k for k, v in my_dict.items()}\n    sorted_dict = dict(sorted(inv_dict.items(), key=lambda item: item[1], reverse=True))\n    return sorted_dict"
      ],
      [
        0.8970383405685425,
        "    sorted_dict = {key: value for key, value in sorted(dic.items(), key=lambda x: x[1], reverse=True)}\n    return sorted_dict"
      ],
      [
        0.8969306945800781,
        "    sorted_count = {}\n    sorted_keys = sorted(word_count, key=word_count.get, reverse=True)\n    for key in sorted_keys:\n        sorted_count[key] = word_count[key]\n    return sorted_count"
      ],
      [
        0.8964529633522034,
        "    return {k: v for k, v in sorted(in_dict.items(), key=lambda item: item[1])}"
      ],
      [
        0.8956137895584106,
        "    list_of_tuples = []\n    for key, value in d.items():\n        list_of_tuples.append((key, value))\n    sorted_list = sorted(list_of_tuples, key=lambda x: x[1], reverse=True)\n    sorted_dict = {}\n    for tup in sorted_list:\n        sorted_dict[tup[0]] = tup[1]\n    return sorted_dict"
      ],
      [
        0.8954296112060547,
        "    for key, value in sorted(dictionary.items(), key=lambda item: item[1]):\n        sorted_dict[key] = value"
      ],
      [
        0.8954163789749146,
        "    for key, value in sorted(dictionary.items(), key=lambda item: item[1]):\n        sorted_dict[key] = value"
      ]
    ],
    "MBPP/465": [
      [
        0.9189164638519287,
        "    min_val = min(lst)\n    max_val = max(lst)\n    summation = min_val + max_val\n    return summation"
      ],
      [
        0.9136742949485779,
        "    smallest_number = min(arr)\n    largest_number = max(arr)\n    return (smallest_number, largest_number)"
      ],
      [
        0.9105253219604492,
        "    smallest = array[0]\n    largest = array[0]\n    for element in array:\n        if element > largest:\n            largest = element\n        elif element < smallest:\n            smallest = element\n    return (smallest, largest)"
      ],
      [
        0.9098802804946899,
        "    largest = array[0]\n    smallest = array[0]\n    for num in array:\n        if num > largest:\n            largest = num\n        if num < smallest:\n            smallest = num\n    return (largest, smallest)"
      ],
      [
        0.9086695313453674,
        "    arr.sort()\n    smallest = arr[0]\n    largest = arr[-1]\n    return (smallest, largest)"
      ],
      [
        0.9086560010910034,
        "    arr.sort()\n    smallest = arr[0]\n    largest = arr[-1]\n    return (smallest, largest)"
      ],
      [
        0.9066898822784424,
        "    max_value = max(array)\n    min_value = min(array)\n    return (max_value, min_value)"
      ],
      [
        0.9059833288192749,
        "    maximum = array[0]\n    minimum = array[0]\n    for i in range(1, len(array)):\n        if array[i] > maximum:\n            maximum = array[i]\n        if array[i] < minimum:\n            minimum = array[i]\n    return (maximum, minimum)"
      ],
      [
        0.90562903881073,
        "    min_value = array[0]\n    max_value = array[0]\n    for num in array:\n        if num < min_value:\n            min_value = num\n        if num > max_value:\n            max_value = num\n    return (min_value, max_value)"
      ],
      [
        0.9055924415588379,
        "    max_val = array[0]\n    min_val = array[0]\n    for i in range(1, len(array)):\n        if array[i] > max_val:\n            max_val = array[i]\n        elif array[i] < min_val:\n            min_val = array[i]\n    return (max_val, min_val)"
      ]
    ],
    "MBPP/466": [
      [
        0.9230091571807861,
        "    new_string = ''\n    for letter in string:\n        new_string += letter.lower()\n    return new_string"
      ],
      [
        0.9211143255233765,
        "    lowercase_string = ''\n    for char in string:\n        lowercase_string += char.lower()\n    return lowercase_string"
      ],
      [
        0.9210901260375977,
        "    lowercase_string = ''\n    for char in string:\n        lowercase_string += char.lower()\n    return lowercase_string"
      ],
      [
        0.9196560382843018,
        "    result = []\n    for char in string:\n        result.append(char.lower())\n    return result"
      ],
      [
        0.9107272624969482,
        "    new_string = ''\n    for char in string:\n        if char.isalpha():\n            new_string += char.lower()\n        else:\n            new_string += char\n    return new_string"
      ],
      [
        0.9105239510536194,
        "    for char in string:\n        lowercase_string += char.lower()"
      ],
      [
        0.9105066061019897,
        "    for char in string:\n        lowercase_string += char.lower()"
      ],
      [
        0.9073437452316284,
        "    char_list = list(s)\n    lower_char_list = [char.lower() for char in char_list]\n    result = ''.join(lower_char_list)\n    return result"
      ],
      [
        0.9060888290405273,
        "    for letter in string:\n        new_string += letter.lower()"
      ],
      [
        0.9054855108261108,
        "    new_string = ''\n    for char in string:\n        if char.islower():\n            new_string += char\n    return new_string"
      ]
    ],
    "MBPP/467": [
      [
        0.9142673015594482,
        "    lower_string_to_remove = string_to_remove.lower()\n    lower_string_to_modify = string_to_modify.lower()\n    words = string_to_modify.split()\n    modified_words = [word for word in words if word.lower() != lower_string_to_remove]\n    modified_string = ' '.join(modified_words)\n    return modified_string"
      ],
      [
        0.9134592413902283,
        "    char = char.lower()\n    modified_string = ''\n    i = 0\n    while i < len(string):\n        current_char = string[i].lower()\n        if current_char == char:\n            i += 1\n        else:\n            modified_string += string[i]\n            i += 1\n    return modified_string"
      ],
      [
        0.9118690490722656,
        "    lowercase_remove = string_to_remove.lower()\n    lowercase_modify = string_to_modify.lower()\n    words = lowercase_modify.split()\n    modified_words = [word.replace(lowercase_remove, '') if lowercase_remove in word else word for word in words]\n    modified_string = ' '.join(modified_words)\n    return modified_string"
      ],
      [
        0.9114977121353149,
        "    newStr = ''\n    for i in range(len(my_string)):\n        if my_string[i] != 'c' and my_string[i] != 'C':\n            newStr += my_string[i]\n    return newStr"
      ],
      [
        0.9095652103424072,
        "    modified_string = ''\n    character = character.lower()\n    for char in string:\n        char = char.lower()\n        if char != character:\n            modified_string += char\n    return modified_string"
      ],
      [
        0.9088517427444458,
        "    new_string = ''\n    for char in string:\n        if char.lower() != letter.lower():\n            new_string += char\n    return new_string"
      ],
      [
        0.9079815149307251,
        "    if not string:\n        return ''\n    chars = set(chars.lower())\n    return ''.join((char for char in string if char.lower() not in chars))"
      ],
      [
        0.907717227935791,
        "    new_string = ''\n    for char in string:\n        if char.islower():\n            new_string += char\n    return new_string"
      ],
      [
        0.9073032140731812,
        "    words = string.split()\n    words_without_target = []\n    for word in words:\n        if word.lower() != target.lower():\n            words_without_target.append(word)\n    return ' '.join(words_without_target)"
      ],
      [
        0.9017653465270996,
        "    modified_string = ''\n    prev_char = ''\n    for char in input_string:\n        if char.lower() != prev_char.lower():\n            modified_string += char\n        prev_char = char\n    return modified_string"
      ]
    ],
    "MBPP/468": [
      [
        0.9074149131774902,
        "    if not isinstance(n, int):\n        raise ValueError('Input must be an integer.')\n    if n < 0:\n        n = -n\n    least_digit = n % 10\n    print('The least significant digit of', n, 'is', least_digit)\n    return least_digit"
      ],
      [
        0.8998205065727234,
        "    str_num = str(num)\n    dot_position = str_num.index('.')\n    digit = int(str_num[dot_position - 1])\n    return digit"
      ],
      [
        0.8947345018386841,
        "    return number % 10"
      ],
      [
        0.8947299718856812,
        "    return number % 10"
      ],
      [
        0.8927299976348877,
        "    size = 1\n    length = 9\n    start = 1\n    while n > length * size:\n        n -= length * size\n        size += 1\n        length *= 10\n        start *= 10\n    start += (n - 1) // size\n    s = str(start)\n    return int(s[(n - 1) % size])"
      ],
      [
        0.8922419548034668,
        "    if number < 10:\n        return number\n    else:\n        sum = 0\n        for digit in str(number):\n            sum += int(digit)\n        return digital_root(sum)"
      ],
      [
        0.8922419548034668,
        "    if number < 10:\n        return number\n    else:\n        sum = 0\n        for digit in str(number):\n            sum += int(digit)\n        return digital_root(sum)"
      ],
      [
        0.8914586305618286,
        "    result = round(int(n))\n    result = abs(result)\n    digit_sum = 0\n    while result != 0:\n        digit_sum += result % 10\n        result //= 10\n    return digit_sum"
      ],
      [
        0.8910597562789917,
        "    x = max(min(x, 1000), 1)\n    return x % 10"
      ],
      [
        0.8883470296859741,
        "    while number > 0:\n        number = number // 10\n        count = count + 1"
      ]
    ],
    "MBPP/469": [
      [
        0.9414565563201904,
        "    max_char = ''\n    max_count = 0\n    for char in string:\n        if string.count(char) > max_count:\n            max_char = char\n            max_count = string.count(char)\n    return max_char"
      ],
      [
        0.9371678829193115,
        "    counts = dict()\n    max = -1\n    character = ''\n    for char in string:\n        if char in counts:\n            counts[char] += 1\n        else:\n            counts[char] = 1\n        if counts[char] > max:\n            max = counts[char]\n            character = char\n    return character"
      ],
      [
        0.9369763731956482,
        "    char_dict = {char: 0 for char in string}\n    for char in string:\n        char_dict[char] += 1\n    max_char = max(char_dict, key=lambda x: char_dict[x])\n    return max_char"
      ],
      [
        0.935565173625946,
        "    charDict = dict()\n    for char in string:\n        if char in charDict:\n            charDict[char] += 1\n        else:\n            charDict[char] = 1\n    maximumOccurChar = max(charDict, key=charDict.get)\n    return maximumOccurChar"
      ],
      [
        0.9335705637931824,
        "    char_counter = {}\n    for char in string:\n        if char in char_counter:\n            char_counter[char] += 1\n        else:\n            char_counter[char] = 1\n    max_char = ''\n    max_appearance = 0\n    for char, count in char_counter.items():\n        if count > max_appearance:\n            max_appearance = count\n            max_char = char\n    return max_char"
      ],
      [
        0.933295726776123,
        "    character_dict = {}\n    for char in string:\n        if char not in character_dict:\n            character_dict[char] = 1\n        else:\n            character_dict[char] += 1\n    max_frequency = 0\n    max_frequency_char = ''\n    for char in character_dict:\n        if character_dict[char] > max_frequency:\n            max_frequency = character_dict[char]\n            max_frequency_char = char\n    return max_frequency_char"
      ],
      [
        0.9331784248352051,
        "    frequencies = {}\n    for char in string:\n        if char in frequencies:\n            frequencies[char] += 1\n        else:\n            frequencies[char] = 1\n    max_frequency = 0\n    max_char = ''\n    for key, value in frequencies.items():\n        if value > max_frequency:\n            max_frequency = value\n            max_char = key\n    return max_char"
      ],
      [
        0.9326947927474976,
        "    char_freq = {}\n    for char in string:\n        if char in char_freq.keys():\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n    max_freq = 0\n    max_char = None\n    for char, freq in char_freq.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_char = char\n    return max_char"
      ],
      [
        0.9326860904693604,
        "    for char in string:\n        if string.count(char) > max_count:\n            max_char = char\n            max_count = string.count(char)"
      ],
      [
        0.9323473572731018,
        "    frequency = {}\n    max_count = 0\n    max_char = ''\n    for char in input_str:\n        if char in frequency:\n            frequency[char] += 1\n            if frequency[char] > max_count:\n                max_count = frequency[char]\n                max_char = char\n        else:\n            frequency[char] = 1\n    return max_char"
      ]
    ],
    "MBPP/470": [
      [
        0.9218895435333252,
        "        if sum(subset) == target:\n            return True"
      ],
      [
        0.9205999970436096,
        "    elements = set(arr)\n    for elem in arr:\n        if sum_val - elem in elements:\n            return True\n    return False"
      ],
      [
        0.9201769828796387,
        "    subset = [[False for i in range(sum + 1)] for i in range(n + 1)]\n    for i in range(n + 1):\n        subset[i][0] = True\n    for i in range(1, sum + 1):\n        subset[0][i] = False\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            if j < set[i - 1]:\n                subset[i][j] = subset[i - 1][j]\n            if j >= set[i - 1]:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - set[i - 1]]\n    return subset[n][sum]"
      ],
      [
        0.9163861870765686,
        "    if sum == 0:\n        return True\n    if len(nums) == 0:\n        return False\n    if nums[0] > sum:\n        return isSubsetSum(nums[1:], sum)\n    return isSubsetSum(nums[1:], sum - nums[0]) or isSubsetSum(nums[1:], sum)"
      ],
      [
        0.9162642955780029,
        "    hash_map = dict()\n    for i in arr:\n        if sum - i in hash_map:\n            return True\n        hash_map[i] = True\n    return False"
      ],
      [
        0.9161450266838074,
        "    s = sum(partial)\n    if s == target:\n        return True\n    if s > target:\n        return False\n    for i, n in enumerate(numbers):\n        remaining = numbers[i + 1:]\n        if subset_sum(remaining, target, partial + [n]):\n            return True\n    return False"
      ],
      [
        0.9158010482788086,
        "    n = len(arr)\n    for i in range(1 << n):\n        summation = 0\n        for j in range(n):\n            if i & 1 << j > 0:\n                summation += arr[j]\n        if summation == x:\n            return True\n    return False"
      ],
      [
        0.915441632270813,
        "    if target_sum == 0:\n        return True\n    if target_sum != 0 and len(arr) == 0:\n        return False\n    if arr[-1] > target_sum:\n        return subset_sum(arr[:-1], target_sum)\n    return subset_sum(arr[:-1], target_sum) or subset_sum(arr[:-1], target_sum - arr[-1])"
      ],
      [
        0.915367841720581,
        "        if sum(sublist) == target:\n            return True"
      ],
      [
        0.9146016836166382,
        "            if sum(sublist) == target:\n                return True"
      ]
    ],
    "MBPP/471": [
      [
        0.8995695114135742,
        "    word_list = re.findall('\\\\b\\\\w+\\\\b', s)\n    uppercase_words = []\n    for word in word_list:\n        if word.isupper():\n            uppercase_words.append(word)\n    return uppercase_words"
      ],
      [
        0.8977210521697998,
        "    return re.findall('[A-Z][^A-Z]*', s)"
      ],
      [
        0.8976884484291077,
        "    reg_ex = '\\\\b(?!([A-Z])\\\\1{2})[A-Z]{3}[a-z]{2}\\\\b'\n    matches = re.findall(reg_ex, input_text)\n    return matches if matches else 'No Match Found'"
      ],
      [
        0.8956635594367981,
        "    uppercase_letters = []\n    for i in range(len(string) - 1):\n        if string[i].isupper() and string[i + 1].islower():\n            uppercase_letters.append(string[i])\n    lowercase_letters = set(string.lower()) - set(string.upper())\n    lowercase_letters = sorted(lowercase_letters, reverse=True)\n    for lowercase in lowercase_letters:\n        for uppercase in uppercase_letters:\n            if lowercase in string and lowercase in uppercase.lower():\n                print(uppercase)"
      ],
      [
        0.8951238393783569,
        "    pattern = re.compile('a.*Z')\n    return pattern.findall(text)"
      ],
      [
        0.8942325115203857,
        "    pattern = '[A-Z][a-z]*\\\\s[A-Z][a-z]*'\n    matches = re.findall(pattern, s)\n    return matches"
      ],
      [
        0.8939275741577148,
        "    pattern_ab = '\\\\b(?:[A-Z][^A-Z]*){4}\\\\b'\n    matches_ab = re.findall(pattern_ab, text)\n    pattern_cd = '\\\\b(?:[C][D]){4}\\\\b'\n    matches_cd = re.findall(pattern_cd, text)\n    return matches_ab + matches_cd"
      ],
      [
        0.8939201831817627,
        "    pattern_ab = '\\\\b(?:[A-Z][^A-Z]*){4}\\\\b'\n    matches_ab = re.findall(pattern_ab, text)\n    pattern_cd = '\\\\b(?:[C][D]){4}\\\\b'\n    matches_cd = re.findall(pattern_cd, text)\n    return matches_ab + matches_cd"
      ],
      [
        0.8932271003723145,
        "    regex = '\\\\b[aA]\\\\w*\\\\b'\n    matches = re.findall(regex, s)\n    return list(set(matches))"
      ],
      [
        0.8926858901977539,
        "    uppercase_chars = []\n    for char in string:\n        if char.isupper():\n            uppercase_chars.append(char)\n    return uppercase_chars"
      ]
    ],
    "MBPP/472": [
      [
        0.903806746006012,
        "    factor = 0\n    for i in range(1, int(x / 2 + 1)):\n        if x % i == 0:\n            factor = i\n    return factor"
      ],
      [
        0.9010803699493408,
        "    while x > factor:\n        if x % factor == 0:\n            x //= factor\n        else:\n            factor += 1"
      ],
      [
        0.9007782340049744,
        "    factor = 2\n    while x > factor:\n        if x % factor == 0:\n            x //= factor\n        else:\n            factor += 1\n    return factor"
      ],
      [
        0.8999850153923035,
        "    for y in range(x - 1, 0, -1):\n        if y % 5 == 0:\n            return y"
      ],
      [
        0.8999850153923035,
        "    for y in range(x - 1, 0, -1):\n        if y % 5 == 0:\n            return y"
      ],
      [
        0.8994198441505432,
        "    found = False\n    num = 1\n    while found == False:\n        for i in range(1, n + 1):\n            if num % i != 0:\n                break\n            elif i == n:\n                found = True\n        num += 1\n    return num - 1"
      ],
      [
        0.8965368866920471,
        "    for i in range(1, x + 1):\n        factorial *= i"
      ],
      [
        0.8965246081352234,
        "    for i in range(1, x + 1):\n        factorial *= i"
      ],
      [
        0.8963506817817688,
        "    if num < 0 or not float(num).is_integer():\n        return None\n    fact = 1\n    i = 1\n    while fact < num:\n        i += 1\n        fact *= i\n    return i if fact == num else None"
      ],
      [
        0.8959037065505981,
        "    for num in range(bound, 0, -1):\n        if num % divisor == 0:\n            return num"
      ]
    ],
    "MBPP/473": [
      [
        0.8978985548019409,
        "                if not condition(item):\n                    result.append(remove_tuples(item, condition))"
      ],
      [
        0.8978775143623352,
        "                if not condition(item):\n                    result.append(remove_tuples(item, condition))"
      ],
      [
        0.8953763246536255,
        "    if len(tuples1) != len(tuples2):\n        return 'Error: Both lists should be of same length.'"
      ],
      [
        0.8953601717948914,
        "    if len(tuples1) != len(tuples2):\n        return 'Error: Both lists should be of same length.'"
      ],
      [
        0.8951473236083984,
        "            if condition(i):\n                continue\n            else:\n                result.append(remove_tuples(i, condition))"
      ],
      [
        0.8951447010040283,
        "            if condition(i):\n                continue\n            else:\n                result.append(remove_tuples(i, condition))"
      ],
      [
        0.8942548036575317,
        "    result = []\n    for i in list1:\n        if i in tuple1:\n            result.append(i)\n    return result"
      ],
      [
        0.8928543329238892,
        "    for i in list2:\n        list1.remove(i)\n    return list1"
      ],
      [
        0.892550528049469,
        "    new_tuple = ()\n    for element in tuple_input:\n        if element != target_element:\n            new_tuple += (element,)\n    return new_tuple"
      ],
      [
        0.8925207853317261,
        "    for item in list2:\n        if item in list1:\n            list1.remove(item)\n    return list1"
      ]
    ],
    "MBPP/474": [
      [
        0.9351138472557068,
        "    max_palindrome = 0\n    for item in arr:\n        temp = str(item)\n        if temp == temp[::-1] and max_palindrome < item:\n            max_palindrome = item\n    return max_palindrome"
      ],
      [
        0.9305518865585327,
        "    max_length = -1\n    max_index = -1\n    for i in range(len(arr)):\n        if is_palindrome(arr[i]):\n            length = len(str(arr[i]))\n            if length > max_length:\n                max_length = length\n                max_index = i\n    return max_index"
      ],
      [
        0.9302127957344055,
        "    return max((num for num in numbers if is_palindrome(num)))"
      ],
      [
        0.9291932582855225,
        "    palindromes = [num for num in numbers if str(num) == str(num)[::-1]]\n    if palindromes:\n        return max(palindromes)\n    else:\n        return 'No Palindrome Found'"
      ]
    ],
    "MBPP/475": [
      [
        0.8944272398948669,
        "    return comb(n, k) * p ** k * (1 - p) ** (n - k)"
      ],
      [
        0.8916677236557007,
        "    return factorial(n) / (factorial(x) * factorial(n - x)) * p ** x * (1 - p) ** (n - x)"
      ],
      [
        0.8906259536743164,
        "    return np.random.binomial(n, p)"
      ],
      [
        0.8872653245925903,
        "    total_outcomes = 2 ** n\n    heads_outcomes = total_outcomes / 2\n    probability_of_heads = heads_outcomes / total_outcomes\n    return probability_of_heads"
      ],
      [
        0.8865346908569336,
        "    der = derangement(n)\n    fact = factorial(n)\n    prob = der / fact\n    return prob"
      ],
      [
        0.8858386278152466,
        "    num_outcomes = 6\n    num_favorable = 1\n    probability = num_favorable / num_outcomes\n    return probability"
      ],
      [
        0.8838527202606201,
        "    perm_val = perm(n, r)\n    rFactorial = factorial(r)\n    answer = perm_val / rFactorial\n    return answer"
      ],
      [
        0.8818659782409668,
        "    num_outcomes = 2\n    if event == outcome_1:\n        probability = 1 / num_outcomes\n    elif event == outcome_2:\n        probability = 1 / num_outcomes\n    else:\n        probability = 0\n    return probability"
      ],
      [
        0.8812416791915894,
        "    for i in range(n):\n        probability *= count[i] / n"
      ]
    ],
    "MBPP/476": [],
    "MBPP/477": [
      [
        0.8997561931610107,
        "    regular_area = calculate_area_regular_pentagon(radius)\n    original_side_length = 2 * radius * math.sin(math.pi / 5)\n    delta_length = updated_side_length - original_side_length\n    height_change = delta_length * math.cos(math.pi / 5)\n    base_change = delta_length * math.sin(math.pi / 5)\n    area_change = height_change * base_change\n    new_area = regular_area + area_change\n    return new_area"
      ],
      [
        0.8968299031257629,
        "    if len(sides) != 5:\n        return 'Not a Pentagon'\n    else:\n        return sum(sides)"
      ],
      [
        0.8968299031257629,
        "    if len(sides) != 5:\n        return 'Not a Pentagon'\n    else:\n        return sum(sides)"
      ],
      [
        0.8955419063568115,
        "    side = 2 * radius * math.sin(math.pi / 5)\n    area = 5 / 4 * math.tan(math.pi / 5) * side ** 2\n    return area"
      ],
      [
        0.8775953054428101,
        "    distance = math.sqrt((x - 1) ** 2 + (y + 2) ** 2)\n    angle = math.atan2(y + 2, x - 1)\n    x_axis_angle = math.acos(distance / 5)\n    area = 0.5 * x_axis_angle * 25\n    return area"
      ],
      [
        0.8775913119316101,
        "    distance = math.sqrt((x - 1) ** 2 + (y + 2) ** 2)\n    angle = math.atan2(y + 2, x - 1)\n    x_axis_angle = math.acos(distance / 5)\n    area = 0.5 * x_axis_angle * 25\n    return area"
      ],
      [
        0.8750711679458618,
        "        if isPentagonal(hexagonal):\n            return hexagonal"
      ],
      [
        0.8747114539146423,
        "    elif len(sides) == 5:\n        a, b, c, d, e = sides\n        area = 0.25 * math.sqrt(5 * (5 + 2 * math.sqrt(5))) * a ** 2\n        return area\n    else:\n        return None"
      ],
      [
        0.8742310404777527,
        "    if x < 7 or x > 15:\n        return 'Error: Input value is out of range.'\n    else:\n        perimeter = 5 * x\n        return perimeter"
      ]
    ],
    "MBPP/478": [
      [
        0.9236997365951538,
        "    largest_num = max(lst)\n    freq = lst.count(largest_num)\n    return (largest_num, freq)"
      ],
      [
        0.923690915107727,
        "    largest_num = max(lst)\n    freq = lst.count(largest_num)\n    return (largest_num, freq)"
      ],
      [
        0.9214847683906555,
        "    max_val = max(arr)\n    freq = arr.count(max_val)\n    return [max_val, freq]"
      ],
      [
        0.9173345565795898,
        "    frequency_counter = {}\n    for num in array:\n        if num in frequency_counter:\n            frequency_counter[num] += 1\n        else:\n            frequency_counter[num] = 1\n    max_element = None\n    max_occurrence = 0\n    for num, frequency in frequency_counter.items():\n        if frequency > max_occurrence:\n            max_element = num\n            max_occurrence = frequency\n    return (max_element, max_occurrence)"
      ],
      [
        0.9158741235733032,
        "    frequencies = {}\n    highest_frequency = 0\n    for element in array:\n        if element not in frequencies:\n            frequencies[element] = 1\n        else:\n            frequencies[element] += 1\n        if frequencies[element] > highest_frequency:\n            highest_frequency = frequencies[element]\n    return highest_frequency"
      ],
      [
        0.9136241674423218,
        "    if not arr:\n        raise ValueError('Array is Empty')\n    maxValue = None\n    count = 0\n    for i in arr:\n        if not isinstance(i, int):\n            raise ValueError('Non-integer element found in array')\n        elif maxValue is None or i > maxValue:\n            maxValue = i\n            count = 1\n        elif i == maxValue:\n            count += 1\n    return (maxValue, count)"
      ],
      [
        0.9126977324485779,
        "    counter_dict = {}\n    for val in array:\n        if val in counter_dict:\n            counter_dict[val] += 1\n        else:\n            counter_dict[val] = 1\n    max_count = 0\n    frequent_val = 0\n    for key, val in counter_dict.items():\n        if val > max_count:\n            max_count = val\n            frequent_val = key\n    return frequent_val"
      ],
      [
        0.9126263856887817,
        "    frequency_count = {}\n    for num in array:\n        if num in frequency_count:\n            frequency_count[num] += 1\n        else:\n            frequency_count[num] = 1\n    most_frequent_num = max(frequency_count, key=frequency_count.get)\n    frequency = frequency_count[most_frequent_num]\n    return (most_frequent_num, frequency)"
      ],
      [
        0.9125851392745972,
        "    if not my_list:\n        return 'The list is empty.'\n    max_value = max(my_list)\n    max_count = my_list.count(max_value)\n    return (max_value, max_count)"
      ],
      [
        0.910697877407074,
        "    freq = {}\n    max = arr[0]\n    for i in arr:\n        if i in freq:\n            freq[i] += 1\n        else:\n            freq[i] = 1\n    for key, value in freq.items():\n        if value > max:\n            max = value\n            max_element = key\n        else:\n            max = max\n            max_element = max_element\n    return max_element"
      ]
    ],
    "MBPP/479": [
      [
        0.8769857287406921,
        "    seen = set()\n    pairs = []\n    for item in lst:\n        if -item in seen:\n            pairs.append([-item, item])\n        else:\n            seen.add(item)\n    return pairs"
      ],
      [
        0.8762705326080322,
        "    pairs = []\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            pair = (lst[i], lst[j])\n            pairs.append(pair)\n    return pairs"
      ],
      [
        0.8746640682220459,
        "    if right is None:\n        right = len(sequence) - 1\n    if pairs is None:\n        pairs = []\n    if left >= right:\n        return pairs\n    try:\n        if not isinstance(sequence[left], int) or not isinstance(sequence[right], int):\n            raise ValueError\n    except ValueError:\n        print('Invalid input: sequence should only contain integers')\n        return\n    if sequence[left] == sequence[right]:\n        pair = (sequence[left], sequence[right])\n        if pair not in pairs:\n            pairs.append(pair)\n    return check_symmetrical_pairs(sequence, left + 1, right - 1, pairs)"
      ],
      [
        0.8746151328086853,
        "    set_dict = {}\n    for first, second in tuple_list:\n        key = str(first) + str(second)\n        if key not in set_dict:\n            set_dict[key] = (first, second)\n    return list(set_dict.values())"
      ],
      [
        0.8725658655166626,
        "    unique_tuples = []\n    for tup in tuple_list:\n        if tup not in unique_tuples:\n            unique_tuples.append(tup)\n    return unique_tuples"
      ],
      [
        0.8723528981208801,
        "    for first, second in tuple_list:\n        key = str(first) + str(second)\n        if key not in set_dict:\n            set_dict[key] = (first, second)"
      ],
      [
        0.8718807697296143,
        "    rows = {}\n    for i in range(len(matrix)):\n        row = tuple(matrix[i])\n        reversed_row = tuple(reversed(matrix[i]))\n        if reversed_row in rows:\n            symmetric_pair = (rows[reversed_row], i)\n            return symmetric_pair\n        else:\n            rows[row] = i\n    return None"
      ],
      [
        0.8713879585266113,
        "                if pair not in result and pair[::-1] not in result:\n                    result.append(pair)"
      ],
      [
        0.8710337281227112,
        "    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            pair = (lst[i], lst[j])\n            pairs.append(pair)"
      ],
      [
        0.8708565831184387,
        "    result = []\n    for x in range(len(list1)):\n        for y in range(x + 1, len(list1)):\n            result.append((list1[x], list1[y]))\n    return result"
      ]
    ],
    "MBPP/480": [
      [
        0.8986003994941711,
        "    sum = a * (1 - r ** n) / (1 - r)\n    if 300 <= sum <= 1200:\n        print(f'The sum of the geometric progression is: {sum}.')\n        print('Terms of the geometric progression:')\n        for i in range(n):\n            term = a * r ** i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of the geometric progression is not within the valid range, but {sum}.')"
      ],
      [
        0.897592306137085,
        "    sum = a * (1 - r ** n) / (1 - r)\n    if 300 <= sum <= 1200:\n        print(f'Sum of geometric progression: {sum}.')\n        print('Terms of geometric progression:')\n        for i in range(n):\n            term = a * r ** i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of geometric progression is not within valid range, but {sum}.')"
      ],
      [
        0.8894367218017578,
        "    if 300 <= sum <= 1200:\n        print(f'The sum of the geometric progression is: {sum}.')\n        print('Terms of the geometric progression:')\n        for i in range(n):\n            term = a * r ** i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of the geometric progression is not within the valid range, but {sum}.')"
      ],
      [
        0.8882490396499634,
        "    if 300 <= sum <= 1200:\n        print(f'Sum of geometric progression: {sum}.')\n        print('Terms of geometric progression:')\n        for i in range(n):\n            term = a * r ** i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of geometric progression is not within valid range, but {sum}.')"
      ],
      [
        0.8857979774475098,
        "    total_sum = 0\n    for i in range(n):\n        total_sum += a * r ** i\n    return total_sum"
      ],
      [
        0.8839496970176697,
        "    first_term = sum / (ratio ** terms - 1)\n    progression = [first_term * ratio ** n for n in range(terms)]\n    return progression"
      ],
      [
        0.8836376667022705,
        "    for i in range(1, n + 1):\n        sum = sum + a * r ** (i - 1)"
      ],
      [
        0.8829231858253479,
        "    sum = 0\n    for i in range(1, n + 1):\n        sum = sum + a * r ** (i - 1)\n    return sum"
      ]
    ],
    "MBPP/481": [
      [
        0.9196231961250305,
        "    sorted_arr = sort_array(arr)\n    return binary_search(sorted_arr, 0, len(arr) - 1, x)"
      ]
    ],
    "MBPP/482": [
      [
        0.8758910894393921,
        "    x_coordinates = []\n    y_coordinates = []\n    for i in x:\n        x_coordinates.append(i * 2)\n    for i in y:\n        y_coordinates.append(i * 2)\n    for i in x:\n        x_coordinates.append(i + 1 / 2)\n    for i in y:\n        y_coordinates.append(i + 1 / 2)\n    return (x_coordinates, y_coordinates)"
      ],
      [
        0.8597870469093323,
        "        for y in range(0, 6):\n            if 4 * x + 5 * y == 20:\n                return (x, y)"
      ],
      [
        0.8587017059326172,
        "    if x == 0 and y == 0:\n        return [[(0, 0)]]"
      ],
      [
        0.8586322069168091,
        "    flat_list = []\n    for sublist in grid:\n        for item in sublist:\n            flat_list.append(item)\n    return flat_list"
      ],
      [
        0.8554824590682983,
        "    matrix = [[0] * 6 for _ in range(6)]\n    top, bottom, left, right = (0, 5, 0, 5)\n    num = 0\n    while True:\n        for i in range(left, right + 1):\n            matrix[top][i] = given_list[num]\n            num += 1\n        top += 1\n        if num == len(given_list):\n            break\n        for i in range(top, bottom + 1):\n            matrix[i][right] = given_list[num]\n            num += 1\n        right -= 1\n        if num == len(given_list):\n            break\n        for i in range(right, left - 1, -1):\n            matrix[bottom][i] = given_list[num]\n            num += 1\n        bottom -= 1\n        if num == len(given_list):\n            break\n        for i in range(bottom, top - 1, -1):\n            matrix[i][left] = given_list[num]\n            num += 1\n        left += 1\n        if num == len(given_list):\n            break\n    return matrix"
      ],
      [
        0.8546197414398193,
        "        if isPentagonal(hexagonal):\n            return hexagonal"
      ],
      [
        0.8539493680000305,
        "    for sublist in grid:\n        for item in sublist:\n            flat_list.append(item)"
      ],
      [
        0.8535880446434021,
        "    for x in range(0, 6):\n        for y in range(0, 6):\n            if 4 * x + 5 * y == 20:\n                return (x, y)"
      ],
      [
        0.8525515794754028,
        "    transformed_coordinates = []\n    for x, y in coordinates:\n        transformed_x = x + y\n        transformed_y = x - y\n        transformed_coordinates.append((transformed_x, transformed_y))\n    return transformed_coordinates"
      ],
      [
        0.852170467376709,
        "    result = []\n    for i in range(0, 6):\n        result.append(i)\n    return result"
      ]
    ],
    "MBPP/483": [
      [
        0.9122368693351746,
        "    return int(binary, 2)"
      ],
      [
        0.9122310876846313,
        "    return int(binary, 2)"
      ],
      [
        0.9122243523597717,
        "    return int(binary, 2)"
      ],
      [
        0.9055978655815125,
        "    result = 0\n    for i in range(len(binary)):\n        digit = int(binary[i])\n        result += digit * 2 ** (len(binary) - 1 - i)\n    return result"
      ],
      [
        0.9045217633247375,
        "    return int(binary_string, 2)"
      ],
      [
        0.9045217633247375,
        "    return int(binary_string, 2)"
      ],
      [
        0.9045071005821228,
        "    return int(binary_string, 2)"
      ],
      [
        0.9045028686523438,
        "    return int(binary_string, 2)"
      ],
      [
        0.9041098952293396,
        "    return int(binaryNum, 2)"
      ],
      [
        0.9024234414100647,
        "    result = 0\n    for char in binary_str:\n        result = result * 2 + int(char)\n    return result"
      ]
    ],
    "MBPP/484": [
      [
        0.9082229137420654,
        "    char = char.lower()\n    modified_string = ''\n    i = 0\n    while i < len(string):\n        current_char = string[i].lower()\n        if current_char == char:\n            i += 1\n        else:\n            modified_string += string[i]\n            i += 1\n    return modified_string"
      ],
      [
        0.9066455364227295,
        "    lower_string_to_remove = string_to_remove.lower()\n    lower_string_to_modify = string_to_modify.lower()\n    words = string_to_modify.split()\n    modified_words = [word for word in words if word.lower() != lower_string_to_remove]\n    modified_string = ' '.join(modified_words)\n    return modified_string"
      ],
      [
        0.9064370393753052,
        "    new_string = ''\n    for char in string:\n        if char.islower():\n            new_string += char\n    return new_string"
      ],
      [
        0.9053918123245239,
        "    lowercase_remove = string_to_remove.lower()\n    lowercase_modify = string_to_modify.lower()\n    words = lowercase_modify.split()\n    modified_words = [word.replace(lowercase_remove, '') if lowercase_remove in word else word for word in words]\n    modified_string = ' '.join(modified_words)\n    return modified_string"
      ],
      [
        0.904608964920044,
        "    newStr = ''\n    for i in range(len(my_string)):\n        if my_string[i] != 'c' and my_string[i] != 'C':\n            newStr += my_string[i]\n    return newStr"
      ],
      [
        0.9045653343200684,
        "    pattern = '[aeiouAEIOU]'\n    result = re.sub(pattern, '', string)\n    return result"
      ],
      [
        0.9035202860832214,
        "    modified_string = ''\n    character = character.lower()\n    for char in string:\n        char = char.lower()\n        if char != character:\n            modified_string += char\n    return modified_string"
      ],
      [
        0.9008005857467651,
        "    new_string = ''\n    for char in string:\n        if char.lower() != letter.lower():\n            new_string += char\n    return new_string"
      ],
      [
        0.9000781774520874,
        "    modified_string = ''\n    prev_char = ''\n    for char in input_string:\n        if char.lower() != prev_char.lower():\n            modified_string += char\n        prev_char = char\n    return modified_string"
      ],
      [
        0.8999751210212708,
        "    if not string:\n        return ''\n    chars = set(chars.lower())\n    return ''.join((char for char in string if char.lower() not in chars))"
      ]
    ],
    "MBPP/485": [
      [
        0.9023327827453613,
        "    smallest = float('inf')\n    count = 0\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n        count += 1\n        if count == 4:\n            break\n    return smallest"
      ],
      [
        0.8978906869888306,
        "    heap = []\n    for item in data:\n        heapq.heappush(heap, item)\n    return heap"
      ],
      [
        0.895767092704773,
        "    for num in arr:\n        heapq.heappush(min_heap, num)"
      ],
      [
        0.895635187625885,
        "    for num in lst:\n        heapq.heappush(maxHeap, num)"
      ],
      [
        0.8945479393005371,
        "    min_heap = []\n    for val in values:\n        heapq.heappush(min_heap, val)\n    optimized_values = []\n    while min_heap:\n        value = heapq.heappop(min_heap)\n        optimized_values.append(value)\n    return optimized_values"
      ],
      [
        0.8944986462593079,
        "        for num in l:\n            heapq.heappush(min_heap, num)"
      ],
      [
        0.8937249779701233,
        "    for item in data:\n        heapq.heappush(heap, item)"
      ],
      [
        0.8901100158691406,
        "    smallest = float('inf')\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest"
      ],
      [
        0.8899234533309937,
        "    sorted_list = heapq.nsmallest(n, lst)\n    return sorted_list[k - 1]"
      ],
      [
        0.8899157047271729,
        "    heapq.heapify(arr)\n    return arr"
      ]
    ],
    "MBPP/486": [
      [
        0.8994513750076294,
        "    surface_area = 4 * 3.14159 * radius ** 2\n    return round(surface_area, 2)"
      ],
      [
        0.8977165818214417,
        "    surface_area = 4 * math.pi * radius * radius\n    return surface_area"
      ],
      [
        0.8936299681663513,
        "    return 1 / 3 * math.pi * cone['radius'] ** 2 * cone['height']"
      ],
      [
        0.8928835391998291,
        "    surface_area = b * b + 4 * b * h / 2\n    return surface_area"
      ],
      [
        0.8890383839607239,
        "    surface_area = 3.14 * radius * (radius + (height ** 2 + radius ** 2) ** 0.5)\n    volume = 3.14 * radius ** 2 * (height / 3)\n    return (surface_area, volume)"
      ],
      [
        0.8871985673904419,
        "    if not (isinstance(radius, (int, float)) and isinstance(height, (int, float))):\n        raise TypeError('Radius and height should be numbers.')\n    if radius < 0 or height < 0:\n        raise ValueError('Radius and height should be non-negative.')\n    radius = float(radius)\n    height = float(height)\n    surface_area = 2 * math.pi * radius * (radius + height)\n    if surface_area.is_integer():\n        return int(surface_area)\n    return surface_area"
      ]
    ],
    "MBPP/487": [
      [
        0.9152926206588745,
        "    if num1 == 0:\n        return num2\n    elif num2 == 0:\n        return num1\n    else:\n        return gcd(num2, num1 % num2)"
      ],
      [
        0.9152926206588745,
        "    if num1 == 0:\n        return num2\n    elif num2 == 0:\n        return num1\n    else:\n        return gcd(num2, num1 % num2)"
      ],
      [
        0.9141192436218262,
        "    if a == 0:\n        gcd = b\n    elif b == 0:\n        gcd = a\n    else:\n        while b != 0:\n            temp = b\n            b = a % b\n            a = temp\n        gcd = a\n    return gcd"
      ],
      [
        0.9136336445808411,
        "    if a > b:\n        return getGCD(a - b, b)"
      ],
      [
        0.9135406613349915,
        "    if a > b:\n        return gcd(a % b, b)"
      ],
      [
        0.9132487773895264,
        "    if a > b:\n        return findGCD(a - b, b)"
      ],
      [
        0.9130440354347229,
        "    assert gcd(1, 1) == 1\n    assert gcd(12, 18) == 6\n    assert gcd(15, 5) == 5\n    assert gcd(21, 14) == 7"
      ],
      [
        0.912553071975708,
        "    if a % b == 0:\n        return b\n    elif b % a == 0:\n        return a\n    if a > b:\n        return gcd(a % b, b)\n    else:\n        return gcd(a, b % a)"
      ],
      [
        0.9122949838638306,
        "    if x == 0 or y == 0:\n        return 0\n    if x == y:\n        return x\n    if x > y:\n        return gcd(x - y, y)\n    else:\n        return gcd(x, y - x)"
      ],
      [
        0.9120299220085144,
        "    if a > b:\n        return gcd(a - b, b)"
      ]
    ],
    "MBPP/488": [
      [
        0.9199844002723694,
        "    circumference = 3.14 * diameter\n    return circumference"
      ],
      [
        0.9094131588935852,
        "    radius = diameter / 2\n    area = math.pi * radius ** 2\n    return area"
      ],
      [
        0.9068028330802917,
        "    if diameter <= 0:\n        return 0\n    radius = diameter / 2\n    circumference = 2 * 3.14159 * radius\n    area = circumference * radius / 2\n    return area"
      ],
      [
        0.906118631362915,
        "    circumference = 2 * 3.14 * radius\n    return circumference"
      ],
      [
        0.9043095707893372,
        "    if diameter <= 0:\n        return 0"
      ],
      [
        0.9030133485794067,
        "    perimeter = 2 * math.pi * radius\n    return perimeter"
      ],
      [
        0.9025262594223022,
        "    area = 3.14 * radius ** 2\n    perimeter = 2 * 3.14 * radius\n    return (area, perimeter)"
      ],
      [
        0.9021718502044678,
        "    area = math.pi * radius ** 2\n    circumference = 2 * math.pi * radius\n    return (area, circumference)"
      ],
      [
        0.9021651744842529,
        "    area = math.pi * radius ** 2\n    circumference = 2 * math.pi * radius\n    return (area, circumference)"
      ],
      [
        0.902045726776123,
        "    radius = ''.join(filter(str.isdigit, radius))\n    radius = float(radius)\n    circumference = 2 * math.pi * radius\n    return circumference"
      ]
    ],
    "MBPP/489": [
      [
        0.9185154438018799,
        "    output = ''\n    for item in input_list:\n        output = output + item\n    return output"
      ],
      [
        0.9171593189239502,
        "    result = ''\n    for string in list_of_strings:\n        result += string\n    return result"
      ],
      [
        0.9168969988822937,
        "    final_string = ''\n    for string in input_list:\n        final_string += string\n    return final_string"
      ],
      [
        0.9150952100753784,
        "    final_string = ''\n    for string in list1:\n        final_string += string\n    return final_string"
      ],
      [
        0.9100347757339478,
        "    result = ''\n    for item in string_list:\n        result += item\n    return result"
      ],
      [
        0.9067379832267761,
        "    joinedString = ''\n    for word in givenList:\n        joinedString += word + separator\n    return joinedString.strip(separator)"
      ],
      [
        0.9063740372657776,
        "    result = ''\n    for s in str_list:\n        result += s\n    return result"
      ],
      [
        0.9049974083900452,
        "    result = ''\n    for idx, element in enumerate(input_list):\n        try:\n            result += ' ' + str(element) if idx != 0 else str(element)\n        except TypeError:\n            print('Error: Element not a string')\n    return result"
      ],
      [
        0.9031162261962891,
        "    if type(lst) != list:\n        return 'Invalid input. Please provide a list of strings.'\n    elif not all((isinstance(item, str) for item in lst)):\n        return 'Invalid input. The list should only contain string items.'\n    else:\n        return ', '.join(lst)"
      ],
      [
        0.9031162261962891,
        "    if type(lst) != list:\n        return 'Invalid input. Please provide a list of strings.'\n    elif not all((isinstance(item, str) for item in lst)):\n        return 'Invalid input. The list should only contain string items.'\n    else:\n        return ', '.join(lst)"
      ]
    ],
    "MBPP/490": [
      [
        0.9082554578781128,
        "    if num2 == 0:\n        return num1\n    return greatest_common_divisor(num2, num1 % num2)"
      ],
      [
        0.9040430188179016,
        "    gcd = 1\n    if num1 < num2:\n        small = num1\n    else:\n        small = num2\n    for i in range(1, small + 1):\n        if num1 % i == 0 and num2 % i == 0:\n            gcd = i\n    return gcd"
      ],
      [
        0.9032904505729675,
        "    smallest = min(A, B)\n    largest_divisor = 1\n    for i in range(1, smallest + 1):\n        if A % i == 0 and B % i == 0:\n            largest_divisor = i\n    return largest_divisor"
      ],
      [
        0.9030650854110718,
        "    gcd_value = math.gcd(a, b)\n    lcm_value = abs(a * b) / gcd_value\n    return (gcd_value, lcm_value)"
      ],
      [
        0.9029293060302734,
        "    if N1 < N2:\n        smaller = N1\n    else:\n        smaller = N2\n    largest_common_factor = -1\n    for i in range(1, R + 1):\n        if N1 % i == 0 and N2 % i == 0:\n            largest_common_factor = i\n    return largest_common_factor"
      ],
      [
        0.9025648832321167,
        "    if not isinstance(num1, int) or not isinstance(num2, int) or num1 == 0 or (num2 == 0):\n        return 'Error: Both the inputs have to be non-zero integers!'\n    elif num1 > num2:\n        if num1 % num2 == 0:\n            return num2\n        else:\n            return highest_common_factor(num2, num1 % num2)\n    elif num2 % num1 == 0:\n        return num1\n    else:\n        return highest_common_factor(num1, num2 % num1)"
      ],
      [
        0.9025648832321167,
        "    if not isinstance(num1, int) or not isinstance(num2, int) or num1 == 0 or (num2 == 0):\n        return 'Error: Both the inputs have to be non-zero integers!'\n    elif num1 > num2:\n        if num1 % num2 == 0:\n            return num2\n        else:\n            return highest_common_factor(num2, num1 % num2)\n    elif num2 % num1 == 0:\n        return num1\n    else:\n        return highest_common_factor(num1, num2 % num1)"
      ]
    ],
    "MBPP/491": [
      [
        0.9145887494087219,
        "    a = abs(a)\n    b = abs(b)\n    if a == 0 or b == 0:\n        return 'Error: Zero is not allowed as an input'\n    greater = max(a, b)\n    smaller = min(a, b)\n    remainder = greater % smaller\n    return remainder"
      ],
      [
        0.9115035533905029,
        "    quotient = n1 // n2\n    remainder = n1 - n2 * quotient\n    return remainder"
      ],
      [
        0.9090949296951294,
        "    quotient = num1 / num2\n    remainder = num1 % num2\n    print('The quotient is:', quotient)\n    print('The remainder is:', remainder)\n    return quotient"
      ],
      [
        0.9061474204063416,
        "    quotient = a // b\n    remainder = a % b\n    print('Quotient:', quotient)\n    print('Remainder:', remainder)"
      ],
      [
        0.9040065407752991,
        "    return num1 % num2"
      ],
      [
        0.9039971232414246,
        "    return num1 % num2"
      ],
      [
        0.8991758227348328,
        "    quotient = num1 // num2\n    remainder = num1 % num2\n    return (quotient, remainder)"
      ],
      [
        0.8991524577140808,
        "    quotient = num1 // num2\n    remainder = num1 % num2\n    return (quotient, remainder)"
      ],
      [
        0.8989434242248535,
        "    sum_ab = a + b\n    remainder = sum_ab % c\n    return remainder"
      ],
      [
        0.8988810181617737,
        "    if num < 4:\n        return num\n    else:\n        return remainder(num - 4)"
      ]
    ],
    "MBPP/492": [
      [
        0.9115899205207825,
        "    output_list = []\n    for i in range(len(input_list) - 1):\n        sum = input_list[i] + input_list[i + 1]\n        output_list.append(sum)\n    return output_list"
      ],
      [
        0.9070519208908081,
        "    for i in range(len(input_list) - 1):\n        sum = input_list[i] + input_list[i + 1]\n        output_list.append(sum)"
      ],
      [
        0.9024835228919983,
        "    if len(given_list) == 1:\n        return given_list[0]\n    else:\n        return given_list[0] + sum_list(given_list[1:])"
      ],
      [
        0.9024835228919983,
        "    if len(given_list) == 1:\n        return given_list[0]\n    else:\n        return given_list[0] + sum_list(given_list[1:])"
      ],
      [
        0.9017415046691895,
        "    res = [list[0]]\n    for i in range(1, len(list)):\n        new_num = res[i - 1] + list[i]\n        res.append(new_num)\n    return res"
      ],
      [
        0.901199460029602,
        "    if not nums:\n        return 0\n    return nums[0] + sum_list(nums[1:])"
      ],
      [
        0.9006571173667908,
        "    sum_list = []\n    for i in range(len(original_list)):\n        if i == len(original_list) - 1:\n            continue\n        sum_list.append(original_list[i] + original_list[i + 1])\n    return sum_list"
      ],
      [
        0.8996374607086182,
        "    if len(lst) == 1:\n        return lst[0]\n    else:\n        return lst[0] + add_recursively(lst[1:])"
      ],
      [
        0.8996374607086182,
        "    if len(lst) == 1:\n        return lst[0]\n    else:\n        return lst[0] + add_recursively(lst[1:])"
      ],
      [
        0.8990497589111328,
        "    for i in my_list:\n        sum += i\n        new_list.append(sum)"
      ]
    ],
    "MBPP/493": [
      [
        0.9257227182388306,
        "    sum = 0\n    for i in range(1, n + 1):\n        sum += i ** 3\n    return sum"
      ],
      [
        0.9257173538208008,
        "    sum = 0\n    for i in range(1, n + 1):\n        sum += i ** 3\n    return sum"
      ],
      [
        0.925716757774353,
        "    sum = 0\n    for i in range(1, n + 1):\n        sum += i ** 3\n    return sum"
      ],
      [
        0.9254683256149292,
        "    if not isinstance(n, int) or n < 1:\n        return 'Error: Input should be a natural number.'\n    sum_of_cubes = sum([i ** 3 for i in range(1, n + 1)])\n    sum_of_numbers = sum([i for i in range(1, n + 1)])\n    return sum_of_cubes - sum_of_numbers"
      ],
      [
        0.9254670143127441,
        "    if not isinstance(n, int) or n < 1:\n        return 'Error: Input should be a natural number.'\n    sum_of_cubes = sum([i ** 3 for i in range(1, n + 1)])\n    sum_of_numbers = sum([i for i in range(1, n + 1)])\n    return sum_of_cubes - sum_of_numbers"
      ],
      [
        0.924963653087616,
        "    sum = 0\n    for num in range(1, n + 1):\n        sum += num ** 3\n    return sum"
      ],
      [
        0.9241547584533691,
        "    sum = 0\n    for i in range(n + 1):\n        sum += i ** 3\n    return sum"
      ],
      [
        0.9226182699203491,
        "    if n < 0:\n        raise ValueError('Input cannot be a negative number.')\n    if n == 0:\n        return 0\n    else:\n        return n ** 3 + sum_cubes(n - 1)"
      ],
      [
        0.9220935702323914,
        "    if n == 0:\n        return 0\n    else:\n        return n ** 3 + sum_cubes(n - 1)"
      ],
      [
        0.9196638464927673,
        "    result = 0\n    for i in range(1, n + 1):\n        result += i ** 3\n    return result"
      ]
    ],
    "MBPP/494": [
      [
        0.9229710102081299,
        "        for item in array:\n            if item == 0:\n                count_zero += 1\n            else:\n                new_array.append(move_zeros(item))"
      ],
      [
        0.9229710102081299,
        "        for item in array:\n            if item == 0:\n                count_zero += 1\n            else:\n                new_array.append(move_zeros(item))"
      ],
      [
        0.9212918877601624,
        "    num_zeros = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[num_zeros], nums[i] = (nums[i], nums[num_zeros])\n            num_zeros += 1\n    return nums"
      ],
      [
        0.9163033962249756,
        "    j = 0\n    for i in range(len(arr)):\n        if arr[i] != 0:\n            arr[j] = arr[i]\n            j += 1\n    for i in range(j, len(arr)):\n        arr[i] = 0"
      ],
      [
        0.9160104393959045,
        "    for i in range(len(nums)):\n        if nums[i] == 0:\n            nums.append(nums.pop(i))"
      ],
      [
        0.9150182008743286,
        "    j = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[j] = nums[i]\n            j += 1\n    for k in range(j, len(nums)):\n        nums[k] = 0"
      ]
    ],
    "MBPP/495": [
      [
        0.909854531288147,
        "    perm_val = perm(n, r)\n    rFactorial = factorial(r)\n    answer = perm_val / rFactorial\n    return answer"
      ],
      [
        0.9069410562515259,
        "    coefficient = []\n    for k in range(n + 1):\n        coefficient.append(int(math.factorial(n) / (math.factorial(k) * math.factorial(n - k))))\n    return coefficient"
      ],
      [
        0.9054787158966064,
        "    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
      ],
      [
        0.9054750204086304,
        "    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
      ],
      [
        0.9054486751556396,
        "    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
      ],
      [
        0.9042795896530151,
        "    return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))"
      ],
      [
        0.9035031795501709,
        "    return math.comb(n, k)"
      ],
      [
        0.9028823375701904,
        "    if n < k:\n        return 'Invalid input: n should be greater than or equal to k'\n    elif k == 0 or k == n:\n        return 1\n    else:\n        numerator = 1\n        denominator = 1\n        for i in range(1, min(k, n - k) + 1):\n            numerator *= n - i + 1\n            denominator *= i\n        return numerator // denominator"
      ],
      [
        0.9028823375701904,
        "    if n < k:\n        return 'Invalid input: n should be greater than or equal to k'\n    elif k == 0 or k == n:\n        return 1\n    else:\n        numerator = 1\n        denominator = 1\n        for i in range(1, min(k, n - k) + 1):\n            numerator *= n - i + 1\n            denominator *= i\n        return numerator // denominator"
      ],
      [
        0.9009940028190613,
        "    permutations = 1\n    for i in range(1, n + 1):\n        permutations *= i\n    return permutations"
      ]
    ],
    "MBPP/496": [
      [
        0.9155696630477905,
        "    filtered_words = []\n    for word in words:\n        if word not in filter_list:\n            filtered_words.append(word)\n    return filtered_words"
      ],
      [
        0.9081203937530518,
        "    new_words = []\n    for word in words:\n        if 't' not in word:\n            new_words.append(word)\n    return new_words"
      ],
      [
        0.9079705476760864,
        "    clean_sentence = [word for word in sentence.split(' ') if word not in words]\n    return ' '.join(clean_sentence)"
      ],
      [
        0.9033728837966919,
        "    words = string.split()\n    words_without_target = []\n    for word in words:\n        if word.lower() != target.lower():\n            words_without_target.append(word)\n    return ' '.join(words_without_target)"
      ],
      [
        0.9003111720085144,
        "    words = s.replace(',', '').split()\n    return [word for word in words if word != target]"
      ],
      [
        0.9003031253814697,
        "    words = s.replace(',', '').split()\n    return [word for word in words if word != target]"
      ],
      [
        0.9001098871231079,
        "    lst = str.split()\n    lst2 = []\n    for c in lst:\n        if c != word:\n            lst2.append(c)\n    return ' '.join(lst2)"
      ]
    ],
    "MBPP/497": [
      [
        0.9294617176055908,
        "    if l1 == l2:\n        print('The lists are exactly the same including the order.')\n    else:\n        print('The lists are not exactly the same including the order.')"
      ],
      [
        0.922024667263031,
        "    return set(list1) == set(list2)"
      ],
      [
        0.9220180511474609,
        "    return set(list1) == set(list2)"
      ],
      [
        0.9220178127288818,
        "    return set(list1) == set(list2)"
      ],
      [
        0.9220141172409058,
        "    return set(list1) == set(list2)"
      ],
      [
        0.9220134019851685,
        "    return set(list1) == set(list2)"
      ],
      [
        0.9202070236206055,
        "    if set1 == set2:\n        print('The lists contain the same unique elements regardless of the order.')"
      ],
      [
        0.9197033643722534,
        "    if list1 == list2:\n        return True\n    else:\n        return False"
      ],
      [
        0.9196954369544983,
        "    if list1 == list2:\n        return True\n    else:\n        return False"
      ],
      [
        0.9196401834487915,
        "    if set1 == set2 and l1 != l2:\n        print('The lists contain the same elements but in a different order.')"
      ]
    ],
    "MBPP/498": [],
    "MBPP/499": [
      [
        0.9187495708465576,
        "    if k <= 1:\n        return 0\n    l = 0\n    count = 0\n    product = 1\n    for r in range(len(nums)):\n        product *= nums[r]\n        while product >= k:\n            product /= nums[l]\n            l += 1\n        count += r - l + 1\n    return count"
      ],
      [
        0.9180477857589722,
        "    if k <= 1:\n        return 0\n    prod = 1\n    count = 0\n    left = 0\n    for right in range(len(nums)):\n        prod *= nums[right]\n        while prod >= k:\n            prod /= nums[left]\n            left += 1\n        count += right - left + 1\n    return count"
      ],
      [
        0.9180430173873901,
        "    if k <= 1:\n        return 0\n    prod = 1\n    count = 0\n    left = 0\n    for right in range(len(nums)):\n        prod *= nums[right]\n        while prod >= k:\n            prod /= nums[left]\n            left += 1\n        count += right - left + 1\n    return count"
      ],
      [
        0.9122673273086548,
        "    for r in range(len(nums)):\n        product *= nums[r]\n        while product >= k:\n            product /= nums[l]\n            l += 1\n        count += r - l + 1"
      ],
      [
        0.9086107015609741,
        "    for right in range(len(nums)):\n        prod *= nums[right]\n        while prod >= k:\n            prod /= nums[left]\n            left += 1\n        count += right - left + 1"
      ],
      [
        0.9085885286331177,
        "    for right in range(len(nums)):\n        prod *= nums[right]\n        while prod >= k:\n            prod /= nums[left]\n            left += 1\n        count += right - left + 1"
      ],
      [
        0.9056630730628967,
        "        for j in range(i, n):\n            product *= arr[j]\n            if product > 0:\n                count += 1"
      ],
      [
        0.9042388200759888,
        "    count = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            if product > 0:\n                count += 1\n    return count"
      ],
      [
        0.8999318480491638,
        "    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            if product > 0:\n                count += 1"
      ],
      [
        0.8963116407394409,
        "        while product >= k:\n            product /= nums[l]\n            l += 1"
      ]
    ]
  },
  "bm25": {
    "HumanEval/0": [
      "def find_furthest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Extract two float numbers from the given array (at minimum contains two) that possess the maximum numerical difference. Remember to present them in ascending order (minor, major).\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (1.0, 5.0)\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (1.0, 5.0)\n    \"\"\"\n    return min(numbers), max(numbers)",
      "def rescale_vectors_to_unit(vectors: List[List[float]]) -> List[List[float]]:\n    \"\"\"\n    Accepting a compilation of N-dimensional vectors, an independent linear transform is applied to each dimension,\n    in such a way that the smallest measurement per dimension reduces to 0, and the uppermost rises to 1.\n\n    >>> rescale_vectors_to_unit([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0], [3.0, 4.0, 5.0]])\n    [[0.0, 0.0, 0.0], [0.5, 0.5, 0.5], [1.0, 1.0, 1.0]]\n    \"\"\"\n    dimension = len(vectors[0])\n    min_max = [[float('inf'), float('-inf')] for _ in range(dimension)]\n    \n    # Find the min and max value for each dimension\n    for vector in vectors:\n        for i in range(dimension):\n            if vector[i] < min_max[i][0]:\n                min_max[i][0] = vector[i]\n            if vector[i] > min_max[i][1]:\n                min_max[i][1] = vector[i]\n\n    # Rescale the vectors\n    for vector in vectors:\n        for i in range(dimension):\n            vector[i] = (vector[i] - min_max[i][0]) / (min_max[i][1] - min_max[i][0])\n    \n    return vectors",
      "def rescale_vectors_to_unit(vectors: List[List[float]]) -> List[List[float]]:\n    \"\"\"\n    Accepting a compilation of N-dimensional vectors, an independent linear transform is applied to each dimension,\n    in such a way that the smallest measurement per dimension reduces to 0, and the uppermost rises to 1.\n\n    Ex: rescale_vectors_to_unit([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0], [3.0, 4.0, 5.0]])\n    [[0.0, 0.0, 0.0], [0.5, 0.5, 0.5], [1.0, 1.0, 1.0]]\n    \"\"\"\n    dimension = len(vectors[0])\n    min_max = [[float('inf'), float('-inf')] for _ in range(dimension)]\n\n    # Find the min and max value for each dimension\n    for vector in vectors:\n        for i in range(dimension):\n            if vector[i] < min_max[i][0]:\n                min_max[i][0] = vector[i]\n            if vector[i] > min_max[i][1]:\n                min_max[i][1] = vector[i]\n\n    # Rescale the vectors\n    for vector in vectors:\n        for i in range(dimension):\n            vector[i] = (vector[i] - min_max[i][0]) / (min_max[i][1] - min_max[i][0])\n\n    return vectors",
      "def test_1():\n    start_x = 1.0  # [m]\n    start_y = 1.0  # [m]\n    start_yaw = 0.0  # [rad]\n    end_x = 5.0  # [m]\n    end_y = 3.0  # [m]\n    end_yaw = 1.57  # [rad]\n    px = [1.0, 2.0, 3.0, 4.0, 5.0]\n    py = [1.0, 1.5, 2.0, 2.5, 3.0]\n    pyaw = [0.0, 0.5, 1.0, 1.25, 1.57]\n    check_edge_condition(px, py, pyaw, start_x, start_y, start_yaw, end_x, end_y, end_yaw)",
      "def derivative_and_integral(xs: list, C: int):\n  \"\"\"\n  xs - coefficients of a polynomial (xs[0] + xs[1]*x + xs[2]*x^2 + ...)\n  This function returns the derivative and integral of the given polynomial, includes the constant C, and removes trailing zeros.\n\n  >>> derivative_and_integral([3, 1, 2, 4, 5], 2)\n  ([6, 4, 12, 20], [2.0, 3.0, 0.5, 0.5, 0.8, 1.0])\n  >>> derivative_and_integral([1, 2, 3], 4)\n  ([2, 6], [4.0, 1.0, 1.0, 1.0])\n  \"\"\"\n  derivative = []\n  integral = [C]\n\n  for i in range(len(xs)):\n    if i != 0:\n      derivative.append(i * xs[i])\n    if i+1 != 0:\n      integral.append(xs[i] / (i+1))\n\n  # Remove trailing zeros\n  while integral[-1] == 0:\n    integral = integral[:-1]\n  while derivative and derivative[-1] == 0:\n    derivative = derivative[:-1]\n\n  return derivative, integral"
    ],
    "HumanEval/1": [
      "def separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    This function is designed to process a string that contains multiple nested groups of round, square, and curly brackets, which are frequently encountered in mathematical computations. \n    Your task is to segregate these bracket groups into separate string segments and return them in the form of a list.\n    Each distinct group is balanced (every opening brace has a corresponding closing brace) and does not nest within another group.\n    Disregard any white spaces present in the input string.\n    >>> separate_paren_groups(' ( ) (( )) {[()]} (( )( )) ')\n    ['()', '(())', '{[()]}', '(()())']\n    \"\"\"\n    # remove white spaces\n    paren_string = paren_string.replace(\" \", \"\")\n    start = ['(', '{', '[']\n    end = [')', '}', ']']\n    groups = []\n    temp_string = ''\n    counter = 0\n\n    for char in paren_string:\n        if char in start:\n            counter += 1\n            temp_string += char\n        elif char in end:\n            counter -= 1\n            temp_string += char\n            if counter == 0:\n                groups.append(temp_string)\n                temp_string = ''\n    return groups",
      "def separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    The function receives a string of multiple sets of nested parentheses. Your task is to\n    segregate these groups into distinct strings and return a list containing them.\n    Each separate group is balanced (every opening brace is duly closed) and not embedded within another group.\n    \"\"\"\n    paren_string = paren_string.replace(\" \", \"\")\n    groups = []\n    start = 0\n    bal = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            bal += 1\n        else:\n            bal -= 1\n        if bal == 0:\n            groups.append(paren_string[start:i+1])\n            start = i+1\n    return groups",
      "def separate_paren_groups(paren_string: str) -> List[str]:\n    stack = []\n    groups = []\n    group = \"\"\n    for ch in paren_string.replace(' ', ''):\n        if ch in ['(', '{', '[']:\n            if stack:\n                group += ch\n            stack.append(ch)\n        elif ch in [')', '}', ']']:\n            group += ch\n            stack.pop()\n            if not stack:\n                groups.append(group)\n                group = \"\"\n    return groups",
      "def separate_paren_groups(paren_string: str, complete_sets: bool= True) -> List[str]:\n\n    stack = []\n    result = []\n    last_open = {}\n\n    brackets = {'(':')', '[':']','{':'}'}\n\n    for index, char in enumerate(paren_string):\n        if char in brackets.keys():\n            # Char is an open bracket\n            stack.append(index)\n            last_open[brackets[char]] = len(stack) - 1\n        elif char in brackets.values():\n            # Char is a close bracket\n            if stack and last_open.get(char, -1) == len(stack) - 1:\n                start = stack.pop()\n                result.append(paren_string[start:index+1])\n                last_open.pop(char)\n            elif not complete_sets:\n                result.append(char)\n        elif not char.isspace():\n            # Char is not a bracket or whitespace; treat it as part of the last group\n            if result:\n                result[-1] += char\n            else: \n                result.append(char)\n\n    if not complete_sets:\n        # Include any remaining unbalanced brackets as separate groups\n        while stack:\n            start = stack.pop()\n            result.append(paren_string[start:])\n\n    return result",
      "def separate_paren_groups(paren_string: str, complete_sets: bool = True) -> List[str]:\n    stack = []\n    result = []\n    last_open = {}\n    \n    brackets = {'(':')', '[':']', '{':'}'}\n    \n    for index, char in enumerate(paren_string):\n        if char in brackets.keys():\n            # Char is an open bracket\n            stack.append(index)\n            last_open[brackets[char]] = len(stack)-1\n        elif char in brackets.values():\n            # Char is a close bracket\n            if stack and last_open.get(char, -1) == len(stack) - 1:\n                start = stack.pop()\n                result.append(paren_string[start:index+1])\n                last_open.pop(char)\n            elif not complete_sets:\n                result.append(char)\n        elif not char.isspace():\n            # Char is not a bracket or whitespace; treat it as part of the last group\n            if result:\n                result[-1] += char\n            else:\n                result.append(char)\n\n    if not complete_sets:\n        # Include any remaining unbalanced brackets as separate groups\n        while stack:\n            start = stack.pop()\n            result.append(paren_string[start:])\n    return result"
    ],
    "HumanEval/2": [
      "def extract_integer(number: float) -> int:\n    \"\"\" Upon providing a positive floating-point number, it can invariably be segregated into\n    an integer component (the largest integer that is less than the input number) and the decimal\n    component (the remainder which is always less than 1).\n\n    Deliver the integer part of the number.\n    >>> extract_integer(4.7)\n    4\n    \"\"\"\n    return int(number)",
      "def extract_integer(number: float, precision: int) -> float:\n    \"\"\" Given a float, it breaks down into\n    an integer component (largest integer less or equal to the number) and decimals\n    (remainder always less than 1 and greater than -1).\n\n    The function should return the integer part of the number preserving precision up to a specified decimal point.\n    >>> extract_integer(4.70, 2)\n    4.70\n    >>> extract_integer(-3.200, 3)\n    -3.200\n    \"\"\"\n    decimal_point = Decimal(10) ** -precision  # Defines the decimal point up to the specified precision\n\n    if isinstance(number, (int, float)):\n        number = Decimal(number)  # Create a Decimal instance of the number\n    elif isinstance(number, str):\n        number = Decimal(number.replace(',', '.'))\n\n    return float(number.quantize(decimal_point, rounding=ROUND_DOWN))  # Return the number as a float, rounded to the specified precision",
      "def extract_integer(number: float) -> int:\n    \"\"\" Given a float, it separates into an integer component (\n    the largest integer less than or equal to the given number) and decimals (\n    remaining part always less than 1 and greater than -1).\n    \n    If the input is zero, return zero.\n    If the input number is very large, return an error message instead.\n    Provide the integer segment of the positive or negative number.\n    >>> extract_integer(4.7)\n    4\n    >>> extract_integer(-3.2)\n    -4\n    >>> extract_integer(0)\n    0\n    >>> extract_integer(1.7e308)\n    'Error: Number too large.'\n    \"\"\"\n    \n    if number == 0:\n        return 0\n    elif number == float('inf') or number == -float('inf'):\n        return 'Error: Number too large.'\n    else:\n        return math.floor(number)",
      "def extract_integer(number: float) -> int:\n    \"\"\"\n    A floating-point number can be bifurcated into an integer part (the largest integer no greater\n    than the input number) and a fraction part (the residual fragment, persistently less than 1 \n    but more than -1). \n\n    Architect this function in such a way that it unravels the integer sector of a number, whether \n    it is positive or negative.\n    \"\"\"\n    return math.floor(number)",
      "def extract_integer(number: float) -> int:\n    \"\"\"\n    A floating-point number can be bifurcated into an integer part (the largest integer no greater\n    than the input number) and a fraction part (the residual fragment, persistently less than 1 \n    but more than -1). \n\n    Architect this function in such a way that it unravels the integer sector of a number, whether \n    it is positive or negative.\n    \"\"\"\n    return math.floor(number)"
    ],
    "HumanEval/3": [
      "def below_zero(operations: List[int]) -> bool:\n    \"\"\"\n    You're provided with a set of banking account transactions which consist of \n    deposit and withdrawal actions, starting from a null balance. Your duty is to find \n    if at any stage the account balance dips below zero, in which case the function is \n    expected to return True. Otherwise, the requirement is that it should yield False.\n\n    Example usages:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n    \n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False",
      "def below_zero(operations: List[Union[int, str]], case_insensitive: bool = False) -> bool:\n    \"\"\"\n    Given are deposit and withdrawal operations on a bank account which starts from zero balance. The operations may include integers or string representations of integers. Determine if the account balance dips below zero at any point. If it does, return True, otherwise, return False. If the case_insensitive flag is triggered, return True even when the balance is exactly zero.\n\n    Examples:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, \"-4\", 5])\n    True\n    >>> below_zero([1, \"2\", -3], True)\n    True\n    \"\"\"\n\n    balance = 0\n\n    for op in operations:\n        balance += int(op) # convert string to int if required and update the balance\n\n    if balance < 0 or (case_insensitive and balance == 0):\n        return True\n\n    return False",
      "def below_zero(operations: List[int], case_insensitive: bool = False) -> bool:\n    \"\"\"The function consumes a queue of deposit and withdrawal activities for a financial account inaugurating with a zero equilibrium. Your task involves identifying if the account's balance descends below zero at any juncture. If it does, the function must return True; on the contrary, it should return False. An optional case_insensitive flag exists that, when set to true, will return True when equilibrium touches zero.\n\n    Examples:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    >>> below_zero([1, 2, -3], True)\n    True\n    \"\"\"\n    balance = 0\n    for op in operations:\n        balance += op\n        if case_insensitive and balance <= 0:\n            return True\n        elif not case_insensitive and balance < 0:\n            return True\n    return False",
      "def below_zero(operations: List[Union[int, float]], handle_float: bool = False, balance_limit: int = 10):\n    \"\"\"\n    Your task is to monitor a series of bank transactions starting from a zero balance. If the account balance goes below zero at any point, return True; otherwise, return False. Your function should also include an optional flag for handling floating point values. Additionally, it should handle situations where withdrawals or negative payments take the account past a preset balance limit.\n\n    Examples:\n    >>> below_zero([1, 2, -4, 5])\n    True\n    >>> below_zero([1, 2, -3.5], True)\n    True\n    \"\"\"\n\n    balance = 0\n    for op in operations:\n        if not handle_float and isinstance(op, float):\n            continue\n        balance += op\n        if balance < 0 or balance > balance_limit:\n            return True\n    return False",
      "def below_zero(operations: List[Union[int, float]], handle_float: bool = False, balance_limit: int = 10):\n    \"\"\"\n    Given a list of deposit and withdrawal operations on a bank account starting with a balance of zero, \n    determine if the balance ever goes below zero during the operations and return True if it does. If not, return False. \n    Include an optional handle_float flag to cater for floating point numbers. The function should prohibit negative deposits \n    and withdrawals that exceed the balance limit.\n\n    Examples:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    >>> below_zero([1, 2, -3.5], True)\n    True\n    \"\"\"\n    balance = 0\n\n    for op in operations:\n        if (not handle_float and isinstance(op, float)) or op < 0 or op > balance_limit:\n            raise ValueError('Invalid operation: ' + str(op))\n        \n        balance += op\n\n        if balance < 0:\n            return True\n\n    return False"
    ],
    "HumanEval/4": [
      "def find_furthest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Extract two float numbers from the given array (at minimum contains two) that possess the maximum numerical difference. Remember to present them in ascending order (minor, major).\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (1.0, 5.0)\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (1.0, 5.0)\n    \"\"\"\n    return min(numbers), max(numbers)",
      "def calculate_mean_std(numbers):\n    \"\"\"\n    Calculate the mean and standard deviation of a given list of numbers.\n\n    Args:\n    numbers: A list of numbers.\n\n    Returns:\n    A tuple containing the mean and standard deviation of the input numbers.\n    \"\"\"\n    mean = np.mean(numbers)\n    std_dev = np.std(numbers)\n    return (mean, std_dev)",
      "def calculate_standard_deviation(num_array):\n    # Calculate the mean\n    mean = sum(num_array) / len(num_array)\n    \n    # Calculate the deviation from the mean\n    deviation = [x - mean for x in num_array]\n    \n    # Calculate the squared deviation\n    squared_deviation = [d ** 2 for d in deviation]\n    \n    # Find the average of these squared deviations\n    average_squared_deviation = sum(squared_deviation) / len(squared_deviation)\n    \n    # Finally, take the square root of the average squared deviation to get the standard deviation\n    standard_deviation = math.sqrt(average_squared_deviation)\n    \n    return standard_deviation",
      "def rolling_avg_median(numbers: List[int]) -> List[Tuple[float, float]]:\n    result = []\n    for i in range(1, len(numbers) + 1):\n        sublist = numbers[:i]\n        mean, median = np.mean(sublist), np.median(sublist)\n        if not result or (mean, median) != result[-1]:\n            result.append((mean, median))\n    return result",
      "def rescale_vectors_to_unit(vectors: List[List[float]]) -> List[List[float]]:\n    \"\"\"\n    Accepting a compilation of N-dimensional vectors, an independent linear transform is applied to each dimension,\n    in such a way that the smallest measurement per dimension reduces to 0, and the uppermost rises to 1.\n\n    >>> rescale_vectors_to_unit([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0], [3.0, 4.0, 5.0]])\n    [[0.0, 0.0, 0.0], [0.5, 0.5, 0.5], [1.0, 1.0, 1.0]]\n    \"\"\"\n    dimension = len(vectors[0])\n    min_max = [[float('inf'), float('-inf')] for _ in range(dimension)]\n    \n    # Find the min and max value for each dimension\n    for vector in vectors:\n        for i in range(dimension):\n            if vector[i] < min_max[i][0]:\n                min_max[i][0] = vector[i]\n            if vector[i] > min_max[i][1]:\n                min_max[i][1] = vector[i]\n\n    # Rescale the vectors\n    for vector in vectors:\n        for i in range(dimension):\n            vector[i] = (vector[i] - min_max[i][0]) / (min_max[i][1] - min_max[i][0])\n    \n    return vectors"
    ],
    "HumanEval/5": [
      "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n    result = []\n    for i, num in enumerate(numbers):\n        if i > 0:\n            result.append(delimeter)\n        result.append(num)\n    return result",
      "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Embeds 'delimeter' among consecutive elements of `numbers` and acknowledges absolute values of negative delimeter.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], -2)\n    [1, 2, 3]\n    \"\"\"\n    result = []\n    for i, num in enumerate(numbers):\n        if delimeter < 0 and i == abs(delimeter):\n            continue\n        result.append(num)\n        if i != len(numbers) - 1:\n            result.append(abs(delimeter))\n    return result",
      "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function inserts a number 'delimeter' between each consectute elements of the input list `numbers` and deals with scenarios where the delimeter is negative.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], -2)\n    [1, 2, 3]\n    \"\"\" \n    result = []\n    abs_delimeter = abs(delimeter)\n    for i in range(len(numbers)):\n        result.append(numbers[i])\n        if i != len(numbers)-1:\n            # Exempt the index locations that matches absolute of negative delimeter\n            if i+1 != abs_delimeter:\n                result.append(delimeter)\n    return result",
      "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"\n    Insert 'delimeter' between each pair of consecutive elements in 'numbers'. Check if 'numbers' is strictly increasing.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n    # Check if numbers is strictly increasing\n    if not verify(numbers):\n        return \"Numbers list is not strictly increasing!\"\n    \n    result = []\n    for num in numbers:\n        result.append(num)\n        result.append(delimeter)        \n    return result[:-1]  # Deletes the last unwanted delimeter",
      "def intersperse(numbers: List[Union[int, List[int]]], delimeter: Union[int, float]) -> List[int]:\n    \"\"\"\n    Introduce the 'delimeter' digit amongst every couple of sequential numbers in the supplied 'numbers' list.\n    Moreover, make sure to manage scenarios that involve a negative or non-integer `delimeter`.\n    Also handles nested list within numbers list.\n    For example:\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], -2)\n    [1, 2, 3]\n    >>> intersperse([1, [2, 3]], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], 4.5)\n    [1, 2, 3]\n    \"\"\"\n    outcome = []\n    flattened_numbers = []\n\n    # This block is to handle nested arrays and flatten them.\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimeter))  # recursive flatten\n        else:\n            flattened_numbers.append(num)\n\n    # This block is to place the delimeter (if it's a non-negative integer) in between the numbers.\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i < len(flattened_numbers) - 1 and isinstance(delimeter, int) and delimeter >= 0:\n            outcome.append(delimeter)\n\n    return outcome"
    ],
    "HumanEval/6": [
      "def separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    This function is designed to process a string that contains multiple nested groups of round, square, and curly brackets, which are frequently encountered in mathematical computations. \n    Your task is to segregate these bracket groups into separate string segments and return them in the form of a list.\n    Each distinct group is balanced (every opening brace has a corresponding closing brace) and does not nest within another group.\n    Disregard any white spaces present in the input string.\n    >>> separate_paren_groups(' ( ) (( )) {[()]} (( )( )) ')\n    ['()', '(())', '{[()]}', '(()())']\n    \"\"\"\n    # remove white spaces\n    paren_string = paren_string.replace(\" \", \"\")\n    start = ['(', '{', '[']\n    end = [')', '}', ']']\n    groups = []\n    temp_string = ''\n    counter = 0\n\n    for char in paren_string:\n        if char in start:\n            counter += 1\n            temp_string += char\n        elif char in end:\n            counter -= 1\n            temp_string += char\n            if counter == 0:\n                groups.append(temp_string)\n                temp_string = ''\n    return groups",
      "def all_prefixes_with_lengths(string: str) -> List[Tuple[str, int]]:\n    \"\"\" \n    Function that returns a list of tuples which include all prefixes of an input string from smallest to largest and their corresponding lengths\n    E.g. all_prefixes_with_lengths('abc') should return [('a', 1), ('ab', 2), ('abc', 3)]\n    \"\"\"\n    return [(string[:i], i) for i in range(1, len(string)+1)]",
      "def encode_cyclic(s: str):\n    \"\"\"\n    This function is intended to encode a string by cycling groups of three characters,\n    and then shifting them three positions further in the alphabet using a Caesar cipher.\n    \"\"\"\n    groups = [s[(3 * i)+3: min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    groups = [''.join(chr((ord(c) - 65 + 3) % 26 + 65) for c in group) if group.isalpha() else group for group in groups]\n    return \"\".join(groups)",
      "def cyclic_encode(s: str):\n    \"\"\"\n    Encodes the string by cycling groups of three characters.\n    \"\"\"\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)",
      "def decode_cyclic(s: str):\n    \"\"\"\n    accepts a string encoded with the above encode_cyclic function, decodes, handling special characters, whitespace and numbers.\n    \"\"\"\n    # split the string into groups of three\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    \n    # if length of group is 3, move the last character to the front, otherwise leave as is\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    \n    return \"\".join(groups)"
    ],
    "HumanEval/7": [
      "def filter_by_prefix_and_suffix(strings: List[str], prefix_suffix: Tuple[str, str], min_length: int) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix, end with a given suffix, and have a minimum length.\n    \n    Example:\n    >>> filter_by_prefix_and_suffix([], ('a', 'z'), 3)\n    []\n    \n    >>> filter_by_prefix_and_suffix(['abc', 'bcd', 'cdez', 'arrayz'], ('a', 'z'), 5)\n    ['arrayz']\n    \n    >>> filter_by_prefix_and_suffix(['abc', 'azy'], ('a', 'z'), 3)\n    ['abc']\n    \"\"\"\n    pass",
      "def filter_by_prefix_and_suffix(strings: List[str], prefix_suffix: Tuple[str, str]) -> List[str]:\n    \"\"\" Meticulously filter an input collection of strings for sole instances that inaugurate with a specified prefix and terminate with a distinctive suffix.\n    >>> filter_by_prefix_and_suffix([], ('a', 'z'))\n    []\n    >>> filter_by_prefix_and_suffix(['abc', 'bcd', 'cdez', 'arrayz'], ('a', 'z'))\n    ['arrayz']\n    >>> filter_by_prefix_and_suffix(['abc', 'azy'], ('a', 'z'))\n    ['azy', 'abc']\n    \"\"\"\n    pass",
      "def pattern_match(strings: List[str], pattern: Tuple[List[str], str, str]) -> Tuple[List[str], int, int]:\n    \"\"\" \n    - Filter an input list of strings only for ones that contain a given pattern,\n    - Strings should start with a given prefix, and end with a given suffix \n    - Calculate the Levenshtein distance between the pattern and string found in the list\n    - And count occurrence of the given prefix and suffix in all strings from the list\n\n    >>> pattern_match([], (['a', 'b', 'c'], 'a', 'z'))\n    ([], 0, 0)\n    >>> pattern_match(['abc', 'bcd', 'cdez', 'arrayz'], (['b', 'c', 'd'], 'a', 'z'))\n    (['arrayz'], 1, 2)\n    >>> pattern_match(['abc', 'azy'], (['b', 'c'], 'a', 'z'))\n    (['abc'], 1, 1)\n    \"\"\"\n\n    result, distance, prefix_count, suffix_count = [], 0, 0, 0\n    for string in strings:\n        if string.startswith(pattern[1]):\n            prefix_count += 1\n        if string.endswith(pattern[2]):\n            suffix_count += 1\n        if all(x in string for x in pattern[0]) and string.startswith(pattern[1]) and string.endswith(pattern[2]):\n            result.append(string)\n            distance += leven_dist(''.join(pattern[0]), string)\n    return result, distance, prefix_count, suffix_count",
      "def all_prefixes_with_lengths(string: str) -> List[Tuple[str, int]]:\n    \"\"\" \n    Function that returns a list of tuples which include all prefixes of an input string from smallest to largest and their corresponding lengths\n    E.g. all_prefixes_with_lengths('abc') should return [('a', 1), ('ab', 2), ('abc', 3)]\n    \"\"\"\n    return [(string[:i], i) for i in range(1, len(string)+1)]",
      "def shortest(strings: List[str]) -> Optional[str]:\n    \"\"\"From a list of strings, return the shortest string. If multiple strings have the same length, return the first one with the least consonants. For an empty list, return None.\n    >>> shortest([])\n    None\n    >>> shortest(['a', 'b', 'c'])\n    'a'\n    >>> shortest(['a', 'ab', 'cc'])\n    'a'\n    >>> shortest(['a', 'bc', 'bbc'])\n    'a'\n    >>> shortest(['a', 'ba', 'bb'])\n    'a'\n    \"\"\"\n    if not strings:\n        return None\n\n    # create a list of tuples, each containing a string and its length and no of consonants\n    strings = [(s, len(s), count_consonants(s)) for s in strings]\n\n    # sort by length and no of consonants\n    strings.sort(key=lambda x: [x[1], x[2]])\n\n    return strings[0][0]"
    ],
    "HumanEval/8": [
      "def sum_of_even_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers: A list of integers.\n\n    Returns:\n    The sum of all even numbers in the list.\n    \n    Examples:\n    >>> sum_of_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    30\n    >>> sum_of_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_of_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)",
      "def prime_digit_product(x):\n    \"\"\"Given a list of positive integers x, return a sorted list of all \n    _distinct_ elements wherein the product of its digits is a prime number.\n\n    Note: The resulting list should be sorted in ascending order. \n\n    >>> prime_digit_product([15, 33, 1422, 1, 15])\n    [1, 15]\n    >>> prime_digit_product([152, 323, 1422, 10])\n    [323]\n\n    \"\"\"\n    return sorted(set([i for i in x if is_prime(prod([int(d) for d in str(i)]))]))",
      "def sum_even_numbers(numbers):\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The sum of all even numbers in the list.\n\n    Examples:\n    >>> sum_even_numbers([1, 2, 3, 4, 5, 6])\n    12\n    >>> sum_even_numbers([10, 11, 12, 13, 14, 15])\n    36\n    >>> sum_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)",
      "def sum_even_numbers(numbers):\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The sum of all even numbers in the list. Returns 0 if the list is empty or does not contain any even numbers.\n\n    Examples:\n    >>> sum_even_numbers([1, 2, 3, 4, 5, 6])\n    12\n    >>> sum_even_numbers([1, 3, 5, 7])\n    0\n    >>> sum_even_numbers([])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)",
      "def odd_sum_elements(x):\n    \"\"\"Given a list of positive integers x, return a sorted list of all \n    _unique_ elements where the sum of their digits is an odd number.\n\n    Note: The returned list should be sorted in ascending order. \n\n    >>> odd_sum_elements([15, 33, 1422, 1, 15])\n    [1, 15]\n    >>> odd_sum_elements([152, 323, 1422, 10])\n    [323]\n\n    \"\"\"\n    odd_sum_digits = []\n    for i in set(x):\n        if sum(int(digit) for digit in str(i)) % 2 != 0:\n            odd_sum_digits.append(i)\n    return sorted(odd_sum_digits)"
    ],
    "HumanEval/9": [
      "def rolling_max(numbers1: List[int], numbers2: List[int]) -> Tuple[List[int], List[int]]:\n    \"\"\" From two given lists of integers, generate a list of rolling maximum element found until given moment \n    in the sequence and store them as maximum of each list.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2], [1, 4, 2, 4, 1, 5, 1])\n    ([1, 2, 3, 3, 3, 4, 4], [1, 4, 4, 4, 4, 5, 5])\n    \"\"\"\n    pass  # Your implementation here",
      "def uncommon_elements(sequence):\n    '''\n    Design a function that accepts a non-empty list composed of positive integers and returns a list of distinct integers whose frequency surpasses half of the integer's numerical value. Here, 'frequency' denotes the number of times a specific integer appears within the list.\n    If no integers satisfy these conditions, the function should return an empty list.\n    Examples:\n        uncommon_elements([4, 1, 2, 2, 3, 1]) should yield [2, 3]\n        uncommon_elements([1, 2, 2, 3, 3, 3, 4, 4, 4]) should yield [2, 3, 4]\n        uncommon_elements([5, 5, 4, 4, 4]) should yield [4]\n    '''\n    from collections import Counter\n    count = Counter(sequence)\n    result = []\n    for num, freq in count.items():\n        if freq > num/2:\n            result.append(num)\n    return result",
      "def sum_of_even_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers: A list of integers.\n\n    Returns:\n    The sum of all even numbers in the list.\n    \n    Examples:\n    >>> sum_of_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    30\n    >>> sum_of_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_of_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)",
      "def intersperse(numbers: List[Union[int, List[int]]], delimeter: Union[int, float]) -> List[int]:\n    \"\"\"\n    Introduce the 'delimeter' digit amongst every couple of sequential numbers in the supplied 'numbers' list.\n    Moreover, make sure to manage scenarios that involve a negative or non-integer `delimeter`.\n    Also handles nested list within numbers list.\n    For example:\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], -2)\n    [1, 2, 3]\n    >>> intersperse([1, [2, 3]], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], 4.5)\n    [1, 2, 3]\n    \"\"\"\n    outcome = []\n    flattened_numbers = []\n\n    # This block is to handle nested arrays and flatten them.\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimeter))  # recursive flatten\n        else:\n            flattened_numbers.append(num)\n\n    # This block is to place the delimeter (if it's a non-negative integer) in between the numbers.\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i < len(flattened_numbers) - 1 and isinstance(delimeter, int) and delimeter >= 0:\n            outcome.append(delimeter)\n\n    return outcome",
      "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n    result = []\n    for i, num in enumerate(numbers):\n        if i > 0:\n            result.append(delimeter)\n        result.append(num)\n    return result"
    ],
    "HumanEval/10": [
      "def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix,\n    \"\"\"\n    palindromic_postfix = longest_palindromic_postfix(string)\n    prefix = string[0:len(string) - len(palindromic_postfix)]\n    return string + prefix[::-1]",
      "def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string, ignoring case and non-alphanumeric characters.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    palindromic_postfix = longest_palindromic_postfix(string)\n    prefix = string[0:len(string) - len(palindromic_postfix)]\n    return string + prefix[::-1]",
      "def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    if is_palindrome(string):\n        return string\n\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            reversed_prefix = string[:i][::-1]\n            return string + reversed_prefix\n\n    return string + string[::-1]",
      "def make_palindrome(string: str) -> str:\n    \"\"\"\n    Find the shortest palindrome that begins with a supplied string, considering spaces between words, and ignoring case, \n    and ignoring non-alphanumeric characters.\n    \n    Algorithm idea is simple:\n    - Find the longest suffix of the supplied string that is a palindrome.\n    - Append to the end of the string the reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    filtered_string = ''.join([char for char in string.lower() if char.isalnum()])\n    string_length = len(filtered_string)\n    \n    if is_palindrome(string):\n        return string\n    \n    for postfix_start in range(string_length):\n        postfix = filtered_string[postfix_start:]\n        if is_palindrome(postfix):\n            non_palindronic_part = filtered_string[:postfix_start]\n            return string + non_palindronic_part[::-1]",
      "def make_palindrome(string: str) -> int:\n    \"\"\" Find the minimum number of characters that need to be added at the end of the supplied string to make it a palindrome, ignoring case, non-alphanumeric characters, and spaces between words.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Compute the length of the string prefix that comes before the palindromic suffix.\n    - Return the length of the prefix as the minimum number of characters needed to create the shortest possible palindrome.\n    \"\"\"\n    filtered_string = ''.join(char.lower() for char in string if char.isalnum())\n    \n    for i in range(len(filtered_string)):\n        if is_palindrome(filtered_string[i:]):\n            return i"
    ],
    "HumanEval/11": [
      "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input: two individual string parameters a and b, constructed exclusively from binary digits i.e. 1s and 0s.\n    Conduct a binary exclusive OR operation on the specified inputs and yield the result as a string output.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n    # convert the binary strings to integers\n    a = int(a, 2)\n    b = int(b, 2)\n    \n    # Conduct a binary exclusive OR operation on the inputs\n    result = a ^ b\n    \n    # Format the result as a binary string and return it\n    return format(result, 'b')",
      "def reverse_binary(a: str) -> str:\n    \"\"\" Input: a single string `a` made up only of 1s and 0s.\n    Perform a binary reverse on the input and return the result as a string format.\n    >>> reverse_binary('010')\n    '010'\n    \"\"\"\n    return a[::-1]",
      "def string_and(a: str, b: str) -> str:\n    \"\"\"\n    Inputs: two distinct string parameters a and b, only from hexadecimal digits i.e. 0-9 and A-F, of length between 10^3 and 10^5. \n    Perform AND operation on these inputs, validate strings are formatted correctly in hexadecimal and output the result as a string.\n\n    >>> string_and('A3F','B2E')\n    'A2E'\n    \"\"\"\n    # Check if strings are hexadecimal\n    try:\n        int(a, 16)\n        int(b, 16)\n    except ValueError:\n        raise ValueError('Input must be hexadecimal string')\n\n    # Perform AND operation\n    and_result = int(a, 16) & int(b, 16)\n\n    # Convert to hexadecimal string (removing '0x' prefix) and return\n    return hex(and_result)[2:].upper()",
      "def string_xor(a: str, b: str) -> str:\n\n    # First we check if the strings are not exceeding length 10^3, and if they do, we raise an exception\n    if len(a) > 10**3 or len(b) > 10**3:\n        raise ValueError(\"Input strings length should not exceed 10^3 characters.\") \n\n    # Then we check if the strings are comprised only of 1s and 0s. If not, we raise an exception\n    if not set(a).issubset(set('01')) or not set(b).issubset(set('01')):\n        raise ValueError(\"Input should only contain binary digits (i.e., 1s and 0s).\")\n\n    # If the strings are of different lengths, we pad the shorter one with 0s at the beginning\n    if len(a) != len(b):\n        if len(a) < len(b):\n            a = a.zfill(len(b))\n        else:\n            b = b.zfill(len(a))\n\n    # Then we conduct the XOR operation\n    result = ''\n    for i in range(len(a)):\n        # XOR operation\n        if a[i] == b[i]:\n            result += '0'\n        else:\n            result += '1'\n\n    return result",
      "def string_xor(a: str, b: str) -> str:\n\n    # First we check if the strings are not exceeding length 10^3, and if they do, we raise an exception\n    if len(a) > 10**3 or len(b) > 10**3:\n        raise ValueError(\"Input strings length should not exceed 10^3 characters.\") \n\n    # Then we check if the strings are comprised only of 1s and 0s, if not, we raise an exception\n    if not set(a).issubset(set('01')) or not set(b).issubset(set('01')):\n        raise ValueError(\"Input should only contain binary digits (i.e., 1s and 0s).\")\n    \n    # If the strings are of different lengths, we pad the shorter one with 0s at the beginning\n    if len(a) != len(b):\n        if len(a) < len(b):\n            a = a.zfill(len(b))\n        else:\n            b = b.zfill(len(a))\n\n    # Then we conduct the XOR operation\n    result = ''\n    for i in range(len(a)):\n        # XOR operation\n        if a[i] == b[i]:\n            result += '0'\n        else:\n            result += '1'\n\n    return result"
    ],
    "HumanEval/12": [
      "def longest(strings: List[str]) -> Optional[str]:\n    \"\"\"\n    Return the longest string in a list. If more than one string has the same \n    length, return the first one. If the list is empty, return None.\n\n    Examples:\n\n    >>> longest([])\n    >>>\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n    if not strings: return None\n    return max(strings, key=len)",
      "def longest(strings: List[str]) -> Optional[str]:\n    \"\"\" In a given list of strings, identify and return the string having the longest length. If there are several strings with the same lengths, return the one that appeared first. If the list has no elements, return None.\n\n    >>> longest([])\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n\n    if not strings: # check if the list is empty\n        return None\n\n    longest_string = strings[0]\n    for string in strings:\n        if len(string) > len(longest_string):\n            longest_string = string\n\n    return longest_string",
      "def shortest(strings: List[str]) -> Optional[str]:\n    \"\"\"From a list of strings, return the shortest string. If multiple strings have the same length, return the first one with the least consonants. For an empty list, return None.\n    >>> shortest([])\n    None\n    >>> shortest(['a', 'b', 'c'])\n    'a'\n    >>> shortest(['a', 'bb', 'ccc'])\n    'a'\n    >>> shortest(['a', 'Ccc', 'bbb'])\n    'a'\n    >>> shortest(['a', 'ba', 'bb'])\n    'a'\n    \"\"\"\n    if not strings:\n        return None\n\n    # create a list of tuples, each containing a string and its length and no of consonants\n    strings = [(s, len(s), count_consonants(s)) for s in strings]\n\n    # sort by length and no of consonants\n    strings.sort(key=lambda x: (x[1], x[2]))\n\n    return strings[0][0]",
      "def shortest(strings: List[str]) -> Optional[str]:\n    \"\"\"From a list of strings, return the shortest string. If multiple strings have the same length, return the first one with the least consonants. For an empty list, return None.\n    >>> shortest([])\n    None\n    >>> shortest(['a', 'b', 'c'])\n    'a'\n    >>> shortest(['a', 'ab', 'cc'])\n    'a'\n    >>> shortest(['a', 'bc', 'bbc'])\n    'a'\n    >>> shortest(['a', 'ba', 'bb'])\n    'a'\n    \"\"\"\n    if not strings:\n        return None\n\n    # create a list of tuples, each containing a string and its length and no of consonants\n    strings = [(s, len(s), count_consonants(s)) for s in strings]\n\n    # sort by length and no of consonants\n    strings.sort(key=lambda x: [x[1], x[2]])\n\n    return strings[0][0]",
      "def longest(strings: List[str], n: int) -> Optional[str]:\n    \"\"\" From a list of strings, find and return the nth lengthiest string. If several strings share the same length, return the first one in order of appearance. If the list contains less than n strings, return None.\"\"\"\n    strings.sort(key=len, reverse=True)\n    return strings[n - 1] if n <= len(strings) else None"
    ],
    "HumanEval/13": [
      "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" \n    Return the highest common factor of the two integers a and b.\n    It uses Euclidean Algorithm to find the GCD.\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a",
      "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Return the highest common divisor of the two given non-negative integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    >>> greatest_common_divisor(0, 0)\n    0\n    >>> greatest_common_divisor(0, 5)\n    5\n    \"\"\"\n    if a < 0 or b < 0:\n        raise ValueError(\"Both numbers must be non-negative\")\n    \n    # Optimization: Return early when one of the inputs is zero  \n    if a==0: \n        return b \n    if b==0: \n        return a \n\n    # Use Euclidean Algorithm to return the gcd\n    while a % b != 0:\n        temp = a\n        a = b\n        b = temp % b\n    return b",
      "def calculate_gcd(a: int, b: int) -> int:\n    \"\"\"\n    Returns the greatest common divisor of 'a' and 'b'.\n\n    Parameters:\n    a (int): The first input integer\n    b (int): The second input integer\n\n    Returns:\n    int: The greatest common divisor of 'a' and 'b'\n\n    >>> calculate_gcd(3, 5)\n    1\n    >>> calculate_gcd(25, 15)\n    5\n    >>> calculate_gcd(0, 5)\n    5\n    >>> calculate_gcd(5, 0)\n    5   \n    \"\"\"\n\n    # inputs must be integers\n    if not all(isinstance(i, int) for i in [a, b]):\n        raise TypeError(\"Both inputs must be integers.\")\n\n    # inputs must be non-negative\n    if a < 0 or b < 0:\n        raise ValueError(\"Inputs must be non-negative integers.\")\n\n    # special case when both inputs are zero\n    if a == 0 and b == 0:\n        raise ValueError(\"At least one input must be non-zero.\")\n\n    # main gcd calculation using Euclidean algorithm\n    while b != 0:\n        a, b = b, a % b\n\n    return a",
      "def calculate_gcd(a: int, b: int) -> int:\n    \"\"\"\n    Returns the greatest common divisor of 'a' and 'b'.\n\n    Parameters:\n    a (int): The first input integer\n    b (int): The second input integer\n\n    Returns:\n    int: The greatest common divisor of 'a' and 'b'\n\n    >>> calculate_gcd(3, 5)\n    1\n    >>> calculate_gcd(15, 15)\n    15\n    >>> calculate_gcd(0, 5)\n    5\n    >>> calculate_gcd(5, 0)\n    5   \n    \"\"\"\n\n    # inputs must be integers\n    if not all(isinstance(i, int) for i in [a, b]):\n        raise TypeError(\"Both inputs must be integers.\")\n\n    # inputs must be non-negative\n    if a < 0 or b < 0:\n        raise ValueError(\"Inputs must be non-negative integers.\")\n\n    # special case when both inputs are zero\n    if a == 0 and b == 0:\n        raise ValueError(\"At least one input must be non-zero.\")\n\n    # main gcd calculation using Euclidean algorithm\n    while b != 0:\n        a, b = b, a % b\n\n    return a",
      "def highest_common_factor(a: int, b: int) -> int:\n    \"\"\" Return a highest common factor of two non-negative integers a and b\n    >>> highest_common_factor(3, 5)\n    1\n    >>> highest_common_factor(25, 15)\n    5\n    \"\"\"\n\n    # Validate the input parameters\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise ValueError(\"Input parameters must be integers\")\n    if a < 0 or b < 0:\n        raise ValueError(\"Input parameters must be non-negative\")\n\n    # GCD computation using Euclid's Algorithm\n    while b != 0:\n        a, b = b, a % b\n    return a"
    ],
    "HumanEval/14": [
      "def all_prefixes_with_lengths(string: str) -> List[Tuple[str, int]]:\n    \"\"\" \n    Function that returns a list of tuples which include all prefixes of an input string from smallest to largest and their corresponding lengths\n    E.g. all_prefixes_with_lengths('abc') should return [('a', 1), ('ab', 2), ('abc', 3)]\n    \"\"\"\n    return [(string[:i], i) for i in range(1, len(string)+1)]",
      "def filter_by_prefix_and_suffix(strings: List[str], prefix_suffix: Tuple[str, str]) -> List[str]:\n    \"\"\" Meticulously filter an input collection of strings for sole instances that inaugurate with a specified prefix and terminate with a distinctive suffix.\n    >>> filter_by_prefix_and_suffix([], ('a', 'z'))\n    []\n    >>> filter_by_prefix_and_suffix(['abc', 'bcd', 'cdez', 'arrayz'], ('a', 'z'))\n    ['arrayz']\n    >>> filter_by_prefix_and_suffix(['abc', 'azy'], ('a', 'z'))\n    ['azy', 'abc']\n    \"\"\"\n    pass",
      "def filter_by_prefix_and_suffix(strings: List[str], prefix_suffix: Tuple[str, str], min_length: int) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix, end with a given suffix, and have a minimum length.\n    \n    Example:\n    >>> filter_by_prefix_and_suffix([], ('a', 'z'), 3)\n    []\n    \n    >>> filter_by_prefix_and_suffix(['abc', 'bcd', 'cdez', 'arrayz'], ('a', 'z'), 5)\n    ['arrayz']\n    \n    >>> filter_by_prefix_and_suffix(['abc', 'azy'], ('a', 'z'), 3)\n    ['abc']\n    \"\"\"\n    pass",
      "def shortest(strings: List[str]) -> Optional[str]:\n    \"\"\"From a list of strings, return the shortest string. If multiple strings have the same length, return the first one with the least consonants. For an empty list, return None.\n    >>> shortest([])\n    None\n    >>> shortest(['a', 'b', 'c'])\n    'a'\n    >>> shortest(['a', 'ab', 'cc'])\n    'a'\n    >>> shortest(['a', 'bc', 'bbc'])\n    'a'\n    >>> shortest(['a', 'ba', 'bb'])\n    'a'\n    \"\"\"\n    if not strings:\n        return None\n\n    # create a list of tuples, each containing a string and its length and no of consonants\n    strings = [(s, len(s), count_consonants(s)) for s in strings]\n\n    # sort by length and no of consonants\n    strings.sort(key=lambda x: [x[1], x[2]])\n\n    return strings[0][0]",
      "def pattern_match(strings: List[str], pattern: Tuple[List[str], str, str]) -> Tuple[List[str], int, int]:\n    \"\"\" \n    - Filter an input list of strings only for ones that contain a given pattern,\n    - Strings should start with a given prefix, and end with a given suffix \n    - Calculate the Levenshtein distance between the pattern and string found in the list\n    - And count occurrence of the given prefix and suffix in all strings from the list\n\n    >>> pattern_match([], (['a', 'b', 'c'], 'a', 'z'))\n    ([], 0, 0)\n    >>> pattern_match(['abc', 'bcd', 'cdez', 'arrayz'], (['b', 'c', 'd'], 'a', 'z'))\n    (['arrayz'], 1, 2)\n    >>> pattern_match(['abc', 'azy'], (['b', 'c'], 'a', 'z'))\n    (['abc'], 1, 1)\n    \"\"\"\n\n    result, distance, prefix_count, suffix_count = [], 0, 0, 0\n    for string in strings:\n        if string.startswith(pattern[1]):\n            prefix_count += 1\n        if string.endswith(pattern[2]):\n            suffix_count += 1\n        if all(x in string for x in pattern[0]) and string.startswith(pattern[1]) and string.endswith(pattern[2]):\n            result.append(string)\n            distance += leven_dist(''.join(pattern[0]), string)\n    return result, distance, prefix_count, suffix_count"
    ],
    "HumanEval/15": [
      "def string_sequence(n):\n    # Initialise an empty list to hold the sequence\n    sequence = []\n    # Iterate from 0 to n inclusive\n    for i in range(n + 1):\n        # Add each number to the sequence list, converting it into a string\n        sequence.append(str(i))\n    # Join all elements in the list into a string separated by spaces and return\n    return ' '.join(sequence)",
      "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"Determine the frequency of a given substring in the initial string. Include overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count",
      "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Determine the frequency of a given substring in the initial string. Include overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count",
      "def classify_number(n):\n    \"\"\"\n    This function returns 'square' for perfect square numbers, 'prime' for prime numbers, and 'neither' for the rest.\n    >>> classify_number(4)\n    'square'\n    >>> classify_number(101)\n    'prime'\n    >>> classify_number(6)\n    'neither'\n    >>> classify_number(11)\n    'prime'\n    >>> classify_number(1)\n    'neither' # 1 is neither prime nor composite\n    \"\"\"\n    import math\n\n    # Check if number is a perfect square\n    sqrt = math.sqrt(n)\n    if sqrt == int(sqrt):\n        return 'square'\n\n    # Check if number is a prime\n    elif n > 1:\n        for i in range(2, int(sqrt) + 1):\n            if (n % i) == 0:\n                return 'neither'\n        return 'prime'\n\n    else:\n        return 'neither'",
      "def classify_number(n):\n    \"\"\"\n    This function returns 'square' for perfect square numbers, 'prime' for prime numbers, and 'neither' for the rest.\n    >>> classify_number(4)\n    'square'\n    >>> classify_number(101)\n    'prime'\n    >>> classify_number(6)\n    'neither'\n    >>> classify_number(11)\n    'prime'\n    >>> classify_number(1)\n    'neither' # 1 is neither prime nor composite\n    \"\"\"\n    import math\n\n    # Check if number is a perfect square\n    sqrt = math.sqrt(n)\n    if sqrt == int(sqrt):\n        return 'square'\n\n    # Check if number is a prime\n    elif n > 1:\n        for i in range(2, int(sqrt) + 1):\n            if (n % i) == 0:\n                return 'neither'\n        return 'prime'\n\n    else:\n        return 'neither'"
    ],
    "HumanEval/16": [
      "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"Determine the frequency of a given substring in the initial string. Include overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count",
      "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Determine the frequency of a given substring in the initial string. Include overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count",
      "def count_distinct_characters(string):\n    distinct_characters = set(string)\n    return len(distinct_characters)",
      "def is_isogram(string: str) -> bool:\n    \"\"\"\n    Verify if a string is an isogram, considering case and non-alphanumeric characters\n    \"\"\"\n    if len(string) > 200:\n        raise ValueError(\"String length exceeds maximum limit of 200 characters.\")\n    return len(string) == len(set(string))",
      "def longest_palindromic_postfix(string: str) -> str:\n    \"\"\" \n    Find the longest palindrome present at the end of the supplied string, \n    while ignoring case and non-alphanumeric characters\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string, i, len(string)-1):\n            return string[i:]"
    ],
    "HumanEval/17": [
      "def parse_music(music_string: str) -> List[int]:\n    notes_map = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    notes = music_string.split()\n    beats = [notes_map[note] for note in notes]\n    return beats",
      "def parse_music(music_string: str) -> List[int]:\n    notes = music_string.split(' ')\n    beat_duration = []\n    for note in notes:\n        if note == 'o':\n            beat_duration.append(4)\n        elif note == 'o|':\n            beat_duration.append(2)\n        elif note == '.|':\n            beat_duration.append(1)\n    return beat_duration",
      "def parse_music(music_string: str, tempo_multiplier: float = 1) -> Tuple[List[List[float]], int]:\n    beats = []\n    measure = []\n    total_beats = 0\n    measures_count = 0\n\n    # Split the given string into individual notes\n    notes = music_string.split()\n\n    # Traverse each note\n    for note in notes:\n        # get the note value and apply the tempo_multiplier\n        note_value = NOTE_VALUES[note] * tempo_multiplier\n\n        # If the new note makes total beats exceed 1, start a new measure\n        if total_beats + note_value > 1:\n            beats.append(measure)\n            measure = []\n            total_beats = 0\n            measures_count += 1\n\n        # add the note to the current measure and update total beats\n        measure.append(note_value)\n        total_beats += note_value\n\n    # Append remaining notes in the last measure\n    if measure:\n        beats.append(measure)\n        measures_count += 1\n\n    return beats, measures_count",
      "def parse_music(music_string: str, tempo_multiplier: float = 1) -> Tuple[List[List[float]], int]:\n    beats = []\n    measure = []\n    total_beats = 0\n    measures_count = 0\n    \n    # Split the given string into individual notes\n    notes = music_string.split()\n    \n    # Traverse each note\n    for note in notes:\n        # get the note value and apply the tempo_multiplier\n        note_value = NOTE_VALUES[note] * tempo_multiplier\n        \n        # If the new note makes total beats exceed 1, start a new measure\n        if total_beats + note_value > 1:\n            beats.append(measure)\n            measure = []\n            total_beats = 0\n            measures_count += 1\n            \n        # Add the note to the current measure and update total beats\n        measure.append(note_value)\n        total_beats += note_value\n    \n    # Append remaining notes in the last measure\n    if measure:\n        beats.append(measure)\n        measures_count += 1\n    \n    return beats, measures_count",
      "def advanced_custom_sort(l: list, n: int, m: int, s: str, r: int, f: str) -> list:\n    \"\"\"\n    This function takes a list l, two integers n and m, a sort directive s ('asc' or 'desc'), \n    an arithmetic function f ('square' or 'cube') and a rotation value r, \n    returning a new list. \n    In the new list, elements whose indices do not fall within the range of (n, m) remain the same as in l, \n    while the elements values within the range (n, m) are transformed by the function 'f' \n    of their corresponding indices in l, sorted according to s. \n    The list is then rotated r times.\n\n    Function f can transform an element x in the following ways:\n    'square' - x is changed to x squared.\n    'cube' - x is changed to x cubed.\n\n    >>> advanced_custom_sort([1, 2, 3], 1, 2, 'asc', 1, 'square')\n    [4, 3, 1]\n    >>> advanced_custom_sort([5, 6, 3, 4, 8, 9, 2], 2, 5, 'desc', 2, 'cube')\n    [81, 4, 2, 5, 6, 720, 64]\n    >>> advanced_custom_sort([8, 7, 4, 1, 3, 2, 5], 1, 4, 'asc', 2, 'cube')\n    [4, 27, 3, 6, 5, 8, 1]\n    \"\"\"\n    \n    transform = {'square': lambda x: x*x,\n                 'cube': lambda x: x*x*x}\n\n    transformed = [transform[f](x) if n<=i<m else x for i,x in enumerate(l)]\n    sorted_l = sorted(transformed[n:m], reverse= s == 'desc') + transformed[m:]\n    return sorted_l[-r:] + sorted_l[:-r]"
    ],
    "HumanEval/18": [
      "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"Determine the frequency of a given substring in the initial string. Include overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count",
      "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Determine the frequency of a given substring in the initial string. Include overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count",
      "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"Calculate the frequency of a given substring in a source string, including overlapping instances.\"\"\"\n    count = start = 0\n    while True:\n        start = string.find(substring, start) + 1\n        if start > 0:\n            count += 1\n        else:\n            return count",
      "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"Calculate the frequency of a given substring in a source string, including overlapping instances.\"\"\"\n    count = start = 0\n    while True:\n        start = string.find(substring, start) + 1\n        if start > 0:\n            count += 1\n        else:\n            return count",
      "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"Identifying the incidence rate of a specified substring within the primary string. Includes overlapping instances.\"\"\"\n    return sum(1 for i in range(len(string)) if string.startswith(substring, i))"
    ],
    "HumanEval/19": [
      "def get_decimal_sum(decimal_digit_words):\n    decimal_words = {'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'}\n    american_number_system = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n\n    decimal_number_sum = 0\n    for dec_word in decimal_digit_words:\n        if dec_word not in decimal_words:\n            return 0\n        else:\n            decimal_number_sum += american_number_system[dec_word]\n\n    return float(decimal_number_sum)",
      "def num_to_words(num):\n    # Your logic to convert number to words goes here\n    # For simplicity, let's assume this function\n    return ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'][int(num)]",
      "def num_to_words(n):\n    if n == 0:\n        return 'zero'\n    num_to_word = {\n        1: 'one',\n        2: 'two',\n        3: 'three',\n        4: 'four',\n        5: 'five',\n        6: 'six',\n        7: 'seven',\n        8: 'eight',\n        9: 'nine',\n        10: 'ten'\n    }\n    return num_to_word.get(n, '')",
      "def to_english(n):\n    num_to_english = {\n        0: 'Zero',\n        1: 'One',\n        2: 'Two',\n        3: 'Three',\n        4: 'Four',\n        5: 'Five',\n        6: 'Six',\n        7: 'Seven',\n        8: 'Eight',\n        9: 'Nine'\n    }\n    \n    if n in num_to_english:\n        return num_to_english[n]\n    else:\n        return ''",
      "def numberToWords(num: int) -> str:\n    ones = ['','one','two','three','four','five','six','seven','eight','nine']\n    tens = ['','ten','twenty','thirty','forty','fifty','sixty','seventy','eighty','ninety']\n    hundreds = ['','one hundred','two hundred','three hundred','four hundred','five hundred','six hundred','seven hundred',\n           'eight hundred','nine hundred']\n    thousand = ['','one thousand','two thousand','three thousand','four thousand','five thousand','six thousand','seven thousand',\n           'eight thousand','nine thousand']\n\n    if num == 0:\n        return \"zero\"\n\n    result = \"\"\n    if num // 1000 > 0:\n        result += thousand[num // 1000] + \" \"\n        num %= 1000\n    if num // 100 > 0:\n        result += hundreds[num // 100] + \" \"\n        num %= 100\n    if num >= 20:\n        result += tens[num // 10] + \" \"\n        num %= 10\n    if num > 0:\n        result += ones[num]\n\n    return result.strip()"
    ],
    "HumanEval/20": [
      "def find_furthest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Extract two float numbers from the given array (at minimum contains two) that possess the maximum numerical difference. Remember to present them in ascending order (minor, major).\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (1.0, 5.0)\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (1.0, 5.0)\n    \"\"\"\n    return min(numbers), max(numbers)",
      "def rescale_vectors_to_unit(vectors: List[List[float]]) -> List[List[float]]:\n    \"\"\"\n    Accepting a compilation of N-dimensional vectors, an independent linear transform is applied to each dimension,\n    in such a way that the smallest measurement per dimension reduces to 0, and the uppermost rises to 1.\n\n    >>> rescale_vectors_to_unit([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0], [3.0, 4.0, 5.0]])\n    [[0.0, 0.0, 0.0], [0.5, 0.5, 0.5], [1.0, 1.0, 1.0]]\n    \"\"\"\n    dimension = len(vectors[0])\n    min_max = [[float('inf'), float('-inf')] for _ in range(dimension)]\n    \n    # Find the min and max value for each dimension\n    for vector in vectors:\n        for i in range(dimension):\n            if vector[i] < min_max[i][0]:\n                min_max[i][0] = vector[i]\n            if vector[i] > min_max[i][1]:\n                min_max[i][1] = vector[i]\n\n    # Rescale the vectors\n    for vector in vectors:\n        for i in range(dimension):\n            vector[i] = (vector[i] - min_max[i][0]) / (min_max[i][1] - min_max[i][0])\n    \n    return vectors",
      "def rescale_vectors_to_unit(vectors: List[List[float]]) -> List[List[float]]:\n    \"\"\"\n    Accepting a compilation of N-dimensional vectors, an independent linear transform is applied to each dimension,\n    in such a way that the smallest measurement per dimension reduces to 0, and the uppermost rises to 1.\n\n    Ex: rescale_vectors_to_unit([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0], [3.0, 4.0, 5.0]])\n    [[0.0, 0.0, 0.0], [0.5, 0.5, 0.5], [1.0, 1.0, 1.0]]\n    \"\"\"\n    dimension = len(vectors[0])\n    min_max = [[float('inf'), float('-inf')] for _ in range(dimension)]\n\n    # Find the min and max value for each dimension\n    for vector in vectors:\n        for i in range(dimension):\n            if vector[i] < min_max[i][0]:\n                min_max[i][0] = vector[i]\n            if vector[i] > min_max[i][1]:\n                min_max[i][1] = vector[i]\n\n    # Rescale the vectors\n    for vector in vectors:\n        for i in range(dimension):\n            vector[i] = (vector[i] - min_max[i][0]) / (min_max[i][1] - min_max[i][0])\n\n    return vectors",
      "def test_1():\n    start_x = 1.0  # [m]\n    start_y = 1.0  # [m]\n    start_yaw = 0.0  # [rad]\n    end_x = 5.0  # [m]\n    end_y = 3.0  # [m]\n    end_yaw = 1.57  # [rad]\n    px = [1.0, 2.0, 3.0, 4.0, 5.0]\n    py = [1.0, 1.5, 2.0, 2.5, 3.0]\n    pyaw = [0.0, 0.5, 1.0, 1.25, 1.57]\n    check_edge_condition(px, py, pyaw, start_x, start_y, start_yaw, end_x, end_y, end_yaw)",
      "def find_closest_elements(numbers: List[int]) -> Tuple[int, int, int]:\n    \"\"\"\n    In the given list of numbers, find and return the two closest numbers firstly the smaller number, \n    then the larger number and the frequency of the smallest difference.\n    For example:\n    find_closest_elements([1, 2, 3, 4, 5, 2])\n    Returns: (2, 2, 2)\n    find_closest_elements([1, 5, 2, 7, 6, 3])\n    Returns: (2, 3, 1)\n    \"\"\"    \n    numbers.sort()\n    pairs = [(numbers[i], numbers[i + 1]) for i in range(len(numbers) - 1)]\n    minimum = min(pair[1] - pair[0] for pair in pairs)\n    result = [pair for pair in pairs if pair[1] - pair[0] == minimum]\n    return result[0][0], result[0][1], len(result)"
    ],
    "HumanEval/21": [
      "def find_furthest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Extract two float numbers from the given array (at minimum contains two) that possess the maximum numerical difference. Remember to present them in ascending order (minor, major).\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (1.0, 5.0)\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (1.0, 5.0)\n    \"\"\"\n    return min(numbers), max(numbers)",
      "def rescale_vectors_to_unit(vectors: List[List[float]]) -> List[List[float]]:\n    \"\"\"\n    Accepting a compilation of N-dimensional vectors, an independent linear transform is applied to each dimension,\n    in such a way that the smallest measurement per dimension reduces to 0, and the uppermost rises to 1.\n\n    >>> rescale_vectors_to_unit([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0], [3.0, 4.0, 5.0]])\n    [[0.0, 0.0, 0.0], [0.5, 0.5, 0.5], [1.0, 1.0, 1.0]]\n    \"\"\"\n    dimension = len(vectors[0])\n    min_max = [[float('inf'), float('-inf')] for _ in range(dimension)]\n    \n    # Find the min and max value for each dimension\n    for vector in vectors:\n        for i in range(dimension):\n            if vector[i] < min_max[i][0]:\n                min_max[i][0] = vector[i]\n            if vector[i] > min_max[i][1]:\n                min_max[i][1] = vector[i]\n\n    # Rescale the vectors\n    for vector in vectors:\n        for i in range(dimension):\n            vector[i] = (vector[i] - min_max[i][0]) / (min_max[i][1] - min_max[i][0])\n    \n    return vectors",
      "def rescale_vectors_to_unit(vectors: List[List[float]]) -> List[List[float]]:\n    \"\"\"\n    Accepting a compilation of N-dimensional vectors, an independent linear transform is applied to each dimension,\n    in such a way that the smallest measurement per dimension reduces to 0, and the uppermost rises to 1.\n\n    Ex: rescale_vectors_to_unit([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0], [3.0, 4.0, 5.0]])\n    [[0.0, 0.0, 0.0], [0.5, 0.5, 0.5], [1.0, 1.0, 1.0]]\n    \"\"\"\n    dimension = len(vectors[0])\n    min_max = [[float('inf'), float('-inf')] for _ in range(dimension)]\n\n    # Find the min and max value for each dimension\n    for vector in vectors:\n        for i in range(dimension):\n            if vector[i] < min_max[i][0]:\n                min_max[i][0] = vector[i]\n            if vector[i] > min_max[i][1]:\n                min_max[i][1] = vector[i]\n\n    # Rescale the vectors\n    for vector in vectors:\n        for i in range(dimension):\n            vector[i] = (vector[i] - min_max[i][0]) / (min_max[i][1] - min_max[i][0])\n\n    return vectors",
      "def find_closest_elements(numbers: List[float]) -> Tuple[float, float, float]:\n    \"\"\"\n    In a given list of numbers (with a minimum length of two), identify and return the\n    two elements with the smallest difference between them, with the lower value first,\n    then the higher value, plus the actual difference.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError('Invalid input! The input list must include at least two numbers.')\n    \n    numbers.sort()\n    \n    # Start with the first pair of values in the list.\n    smallest_diff = numbers[1] - numbers[0]\n    best_pair = (numbers[0], numbers[1], smallest_diff)\n    \n    for i in range(1, len(numbers) - 1):\n        # Compute the difference between the current pair of elements.\n        diff = numbers[i+1] - numbers[i]\n        # Track the pair with the smallest difference.\n        if diff < smallest_diff:\n            smallest_diff = diff\n            best_pair = (numbers[i], numbers[i+1], smallest_diff)\n    \n    return best_pair",
      "def test_1():\n    start_x = 1.0  # [m]\n    start_y = 1.0  # [m]\n    start_yaw = 0.0  # [rad]\n    end_x = 5.0  # [m]\n    end_y = 3.0  # [m]\n    end_yaw = 1.57  # [rad]\n    px = [1.0, 2.0, 3.0, 4.0, 5.0]\n    py = [1.0, 1.5, 2.0, 2.5, 3.0]\n    pyaw = [0.0, 0.5, 1.0, 1.25, 1.57]\n    check_edge_condition(px, py, pyaw, start_x, start_y, start_yaw, end_x, end_y, end_yaw)"
    ],
    "HumanEval/22": [
      "def filter_by_prefix_and_suffix(strings: List[str], prefix_suffix: Tuple[str, str], min_length: int) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix, end with a given suffix, and have a minimum length.\n    \n    Example:\n    >>> filter_by_prefix_and_suffix([], ('a', 'z'), 3)\n    []\n    \n    >>> filter_by_prefix_and_suffix(['abc', 'bcd', 'cdez', 'arrayz'], ('a', 'z'), 5)\n    ['arrayz']\n    \n    >>> filter_by_prefix_and_suffix(['abc', 'azy'], ('a', 'z'), 3)\n    ['abc']\n    \"\"\"\n    pass",
      "def rolling_max(numbers1: List[int], numbers2: List[int]) -> Tuple[List[int], List[int]]:\n    \"\"\" From two given lists of integers, generate a list of rolling maximum element found until given moment \n    in the sequence and store them as maximum of each list.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2], [1, 4, 2, 4, 1, 5, 1])\n    ([1, 2, 3, 3, 3, 4, 4], [1, 4, 4, 4, 4, 5, 5])\n    \"\"\"\n    pass  # Your implementation here",
      "def diffList(numList: List[int], absolute_difference: bool = False) -> List[int]:\n    \"\"\" Return the difference of each pair of consecutive numbers from `numList'\n    >>> diffList([1, 2, 3])\n    [1, 1]\n    >>> diffList([2, 5, 9, 16])\n    [3, 4, 7]\n    >>> diffList([2, 5, 9, 16], absolute_difference=True)\n    [3, 4, 7]\n    \"\"\"\n    diff_list = []\n    \n    for i in range(1, len(numList)):\n        difference = numList[i] - numList[i-1]\n        \n        if absolute_difference:\n            difference = abs(difference)\n        \n        diff_list.append(difference)\n    \n    return diff_list",
      "def pattern_match(strings: List[str], pattern: Tuple[List[str], str, str]) -> Tuple[List[str], int, int]:\n    \"\"\" \n    - Filter an input list of strings only for ones that contain a given pattern,\n    - Strings should start with a given prefix, and end with a given suffix \n    - Calculate the Levenshtein distance between the pattern and string found in the list\n    - And count occurrence of the given prefix and suffix in all strings from the list\n\n    >>> pattern_match([], (['a', 'b', 'c'], 'a', 'z'))\n    ([], 0, 0)\n    >>> pattern_match(['abc', 'bcd', 'cdez', 'arrayz'], (['b', 'c', 'd'], 'a', 'z'))\n    (['arrayz'], 1, 2)\n    >>> pattern_match(['abc', 'azy'], (['b', 'c'], 'a', 'z'))\n    (['abc'], 1, 1)\n    \"\"\"\n\n    result, distance, prefix_count, suffix_count = [], 0, 0, 0\n    for string in strings:\n        if string.startswith(pattern[1]):\n            prefix_count += 1\n        if string.endswith(pattern[2]):\n            suffix_count += 1\n        if all(x in string for x in pattern[0]) and string.startswith(pattern[1]) and string.endswith(pattern[2]):\n            result.append(string)\n            distance += leven_dist(''.join(pattern[0]), string)\n    return result, distance, prefix_count, suffix_count",
      "def lowest_common_multiple(x: List[int], y: List[int]) -> List[int]:\n    \"\"\" Returns the LCM of each pair of positive integers x and y\n    >>> lowest_common_multiple([3, 5], [5, 15])\n    [15, 75]\n    \"\"\"\n    return [abs(a*b) // gcd(a, b) for a, b in zip(x, y)]"
    ],
    "HumanEval/23": [
      "def double_up(str_list):\n  double_list = []\n  for string in str_list:\n    double_str = string + string\n    strlen = len(string)\n    char_at_index = double_str[strlen]\n    if char_at_index.islower():\n      char_at_index = char_at_index.upper()\n    double_list.append(double_str)\n    double_list.append(char_at_index)\n  return double_list",
      "def double_up(str_list):\n  double_list = []\n  for str in str_list:\n    double_str = str + str\n    strlen = len(str)\n    double_list.append(double_str[strlen - 1])\n  return double_list",
      "def double_up(input_str):\n  double_str = input_str + input_str\n  strlen = len(input_str)\n  return double_str[strlen - 1]",
      "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"Determine the frequency of a given substring in the initial string. Include overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count",
      "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Determine the frequency of a given substring in the initial string. Include overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count"
    ],
    "HumanEval/24": [
      "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, yet, is smaller than n\n    >>> largest_divisor(-15)\n    5\n    \"\"\"\n    # convert the number to absolute\n    n = abs(n)\n    if n < 2:\n        return None\n    # Check for all divisors starting from half of the number\n    for i in range(n//2, 0, -1): \n        if n % i == 0:\n            return i",
      "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, yet is smaller than n\n    >>> largest_divisor(-15)\n    5\n    \"\"\"\n    # convert the number to absolute\n    n = abs(n)\n    if n < 2:\n        return None\n    # check for all divisors starting from half of the number\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i",
      "def largest_divisors_of_list(numbers: List[int]) -> List[int]:\n    \"\"\" For a given list of integers, find the largest absolute divisors for each integer and return a new list with these values\n    >>> largest_divisors_of_list([15, -20, 25])\n    [5, 10, 5]\n    \"\"\"\n    # check for null list\n    if not numbers:\n        return None\n    largest_divisors = []\n    # for each number in the list, find the largest divisor and append to the output list\n    for num in numbers:\n        largest_divisors.append(largest_divisor(num))\n    return largest_divisors",
      "def largest_divisors_of_list(numbers: List[int]) -> List[int]:\n    \"\"\" For a given list of integers, find the largest absolute divisors for each integer and return a new list with these values\n    <<< largest_divisors_of_list([15, -20, 25])\n    [5, 10, 5]\n    \"\"\"\n    # check for null list\n    if not numbers:\n        return None\n    largest_divisors = []\n    # for each number in the list, find the largest divisor and append to the output list\n    for num in numbers:\n        largest_divisors.append(largest_divisor(num))\n    return largest_divisors",
      "def largest_divisor(n: int) -> int:\n    \"\"\""
    ],
    "HumanEval/25": [
      "def factorize(n: int) -> Tuple[List[int], Dict[int, int], Dict[int, bool]]:\n    \"\"\"\n    Returns a prime factor list and a dictionary displaying the frequency of each factor in the decomposition process. \n    Perform primality testing on each factor.\n\n    Factors should be listed according to their frequency of appearance in the decomposition process.\n    The entered number (2 \u2264 n \u2264 10^6) should be the product of all factors.\n\n    factorize(8)\n    ([2, 2, 2], {2: 3}, {2: True})\n    \n    factorize(25)\n    ([5, 5], {5: 2}, {5: True})\n    \n    factorize(70)\n    ([2, 5, 7], {2: 1, 5: 1, 7: 1}, {2: True, 5: True, 7: True})\n    \"\"\"\n    factors = []\n    freq = {}\n    primes = {}\n    \n    # Prime factorization\n    while n % 2 == 0:\n        factors.append(2)\n        n = n / 2\n    for i in range(3,int(math.sqrt(n))+1,2):\n        while n % i== 0:\n            factors.append(int(i))\n            n = n / i \n    if n > 2:\n        factors.append(int(n))\n\n    # Count the frequency of each factor\n    for factor in factors:\n        if factor not in freq:\n            freq[factor] = 1\n        else:\n            freq[factor] += 1\n\n    # Perform primality check on each factor\n    for factor in freq.keys():\n        primes[factor] = is_prime(factor)\n\n    return (factors, freq, primes)",
      "def factorize(n: int) -> Tuple[List[int], Dict[int, int], Dict[int, bool]]:\n    \"\"\"\n    Returns a prime factor list and a dictionary displaying the frequency of each factor in the decomposition process,\n    Perform primality testing on each factor.\n\n    Factors should be listed according to their frequency of appearance in the decomposition process.\n    The entered number (2 \u2264 n \u2264 10^6) should be the product of all factors.\n\n    factorize(8)\n    ([2, 2, 2], {2: 3}, {2: True})\n\n    factorize(25)\n    ([5, 5], {5: 2}, {5: True})\n\n    factorize(70)\n    ([2, 5, 7], {2: 1, 5: 1, 7: 1}, {2: True, 5: True, 7: True})\n    \"\"\"\n    \n    factors = []\n    freq = {}\n    primes = {}\n\n    # Prime factorization\n    while n % 2 == 0:\n        factors.append(2)\n        n = n / 2\n    \n    for i in range(3, int(math.sqrt(n))+1, 2):\n        while n % i == 0:\n            factors.append(int(i))\n            n = n / i\n    if n > 2:\n        factors.append(int(n))\n\n    # count the frequency of each factor\n    for factor in factors:\n        if factor not in freq:\n            freq[factor] = 1\n        else:\n            freq[factor] += 1\n\n    # perform primality check on each factor\n    for factor in freq.keys():\n        primes[factor] = is_prime(factor)\n\n    return [factors, freq, primes]",
      "def sum_of_even_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers: A list of integers.\n\n    Returns:\n    The sum of all even numbers in the list.\n    \n    Examples:\n    >>> sum_of_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    30\n    >>> sum_of_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_of_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)",
      "def prime_digit_product(x):\n    \"\"\"Given a list of positive integers x, return a sorted list of all \n    _distinct_ elements wherein the product of its digits is a prime number.\n\n    Note: The resulting list should be sorted in ascending order. \n\n    >>> prime_digit_product([15, 33, 1422, 1, 15])\n    [1, 15]\n    >>> prime_digit_product([152, 323, 1422, 10])\n    [323]\n\n    \"\"\"\n    return sorted(set([i for i in x if is_prime(prod([int(d) for d in str(i)]))]))",
      "def sum_even_numbers(numbers):\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The sum of all even numbers in the list.\n\n    Examples:\n    >>> sum_even_numbers([1, 2, 3, 4, 5, 6])\n    12\n    >>> sum_even_numbers([10, 11, 12, 13, 14, 15])\n    36\n    >>> sum_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)"
    ],
    "HumanEval/26": [
      "def remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"Remove duplicates while maintaining order.\n    Given a list of integers, remove any number that occurs more than once,\n    while keeping the order of the remaining numbers the same as the original list.\n    Determine the number of times each number occurs, and remove the numbers that occur more than once.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count_map = {}\n    result = []\n    for num in numbers:\n        if num not in count_map:\n            count_map[num] = 1\n            result.append(num)\n        else:\n            count_map[num] += 1\n            if count_map[num] > 1 and num in result:\n                result.remove(num)\n    return result",
      "def remove_duplicates(numbers: List[int], threshold: int) -> Tuple[List[int], List[int]]:\n    \"\"\"From a list of integers, remove duplicate elements, elements that occur more than a specified number of times, prime numbers, and negative integers.\n    Keep order of elements the same as in the input.\n    Return two lists, one with the remaining elements and one with the removed elements, both in the original order.\"\"\"\n    counts = Counter(numbers)\n    removed = []\n    left = []\n    for num in numbers:\n        if counts[num] > threshold or is_prime(num) or num < 0:\n            if num not in removed:\n                removed.append(num)\n        else:\n            left.append(num)\n            counts[num] = threshold + 1\n    return left, removed",
      "def common_elements(list1: List[int], list2: List[int]) -> List[int]:\n    \"\"\" From two lists of integers, find all elements that occur in both lists.\n    Keep order of elements the same as in the first list.\n    >>> common_elements([1, 2, 3, 4], [2, 4, 6, 7])\n    [2, 4]\n    \"\"\"\n    set2 = set(list2) # convert list2 to set for faster lookup\n    return [value for value in list1 if value in set2] # use list comprehension to find common elements",
      "def remove_duplicates(numbers: List[int], threshold: int) -> List[int]:\n    \"\"\" From a list of integers, remove duplicate elements, elements that occur more \n    than a specified number of times and prime numbers.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    frequency = Counter(numbers)\n    non_duplicates = [number for number in numbers if frequency[number] <= threshold and not is_prime(number)]\n    return non_duplicates",
      "def remove_duplicates(numbers: List[int], threshold: int) -> Tuple[List[int], List[int]]:\n    \"\"\" From a list of integers, remove duplicate elements, elements that occur more than a specified number of times, prime numbers, and negative integers.\n    Keep order of elements left the same as in the input.\n    Return two lists, one with the remaining elements and one with the removed elements, both in the original order. \"\"\"\n    counts = Counter(numbers)\n    removed = []\n    left = []\n    for num in numbers:\n        if counts[num] > threshold or is_prime(num) or num < 0:\n            if num not in removed:\n                removed.append(num)\n        else:\n            left.append(num)\n            counts[num] = threshold + 1\n    return left, removed"
    ],
    "HumanEval/27": [
      "def invert_case_special(string: str) -> str:\n    \"\"\"\n    For a given string, reverse the string, flip lowercase characters to uppercase and uppercase characters to lowercase,\n    make numbers even by subtracting one from odd numbers, quadruple special characters, \n    and count the occurrences of each modified character.\n\n    >>> invert_case_special('H\u20acll0!')\n    '!00ll3h': {'!': 2, '0': 1, 'l': 2, '3': 1, 'h': 1}\n    \"\"\"\n    rev_str = string[::-1]\n    transformed_str = \"\"\n    char_count = {}\n\n    for char in rev_str:\n        if char.isalpha():\n            # Swap case\n            new_char = char.swapcase()\n        elif char.isdigit():\n            # Make numbers even\n            num = int(char)\n            new_char = str(num - 1 if num % 2 != 0 else num)\n        else:\n            # Quadruple special characters\n            new_char = char * 4\n\n        transformed_str += new_char\n\n        # Count occurrence of each character\n        if new_char not in char_count:\n            char_count[new_char] = 0\n        char_count[new_char] += 1\n\n    return transformed_str, char_count",
      "def lowercase(string):\n    \"\"\"\n    Converts a string from all uppercase to all lowercase.\n    Parameters:\n        str string: The string to convert.\n    Returns:\n        str: The converted string.\n    \"\"\"\n    return string.lower()",
      "def generate_random_string(length: int) -> str:\n    \"\"\"\n    Generate a random string of specified length consisting of uppercase letters, lowercase letters, and digits.\n    \"\"\"\n    characters = string.ascii_letters + string.digits\n    return ''.join(random.choice(characters) for _ in range(length))",
      "def flip_case_and_modify(string: str) -> str:\n    \"\"\" For an inputted sequence of characters, invert lowercase to uppercase and vice versa, substitute odd numerals with its succeeding even numeral, and duplicate any peculiar symbols. \n    >>> flip_case_and_modify('Hello4!')\n    'hELLO6!!'\n    \"\"\"\n\n    modified_string = ''\n    for char in string:\n        if char.isalpha():\n            modified_string += char.swapcase()\n        elif char.isdigit():\n            if int(char) % 2 != 0:\n                modified_string += str(int(char) + 1)\n            else:\n                modified_string += char\n        else:\n            modified_string += char * 2\n\n    return modified_string",
      "def countLetters(s): \n   uppercase, lowercase = 0, 0\n   for x in s: \n      if x.islower(): \n         lowercase += 1\n      elif x.isupper(): \n         uppercase += 1\n   print(\"No. of Upper case characters:\", uppercase) \n   print(\"No. of Lower case Characters:\", lowercase) "
    ],
    "HumanEval/28": [
      "def custom_string_manipulation(strings: List[str]) -> str:\n    \"\"\"Combine a list of strings into a single string using a complicated method of intertwining and reversing the characters.\n    >>> custom_string_manipulation([])\n    ''\n    >>> custom_string_manipulation(['a', 'b', 'c'])\n    'cba'\n    >>> custom_string_manipulation(['ab', 'cd', 'ef'])\n    'fedcba'\n    \"\"\"\n    # Join all the characters in the input list of strings into one string.\n    all_chars = ''.join(strings)\n    # Use slicing to reverse the combined string.\n    return all_chars[::-1]",
      "def filter_by_prefix_and_suffix(strings: List[str], prefix_suffix: Tuple[str, str]) -> List[str]:\n    \"\"\" Meticulously filter an input collection of strings for sole instances that inaugurate with a specified prefix and terminate with a distinctive suffix.\n    >>> filter_by_prefix_and_suffix([], ('a', 'z'))\n    []\n    >>> filter_by_prefix_and_suffix(['abc', 'bcd', 'cdez', 'arrayz'], ('a', 'z'))\n    ['arrayz']\n    >>> filter_by_prefix_and_suffix(['abc', 'azy'], ('a', 'z'))\n    ['azy', 'abc']\n    \"\"\"\n    pass",
      "def filter_by_prefix_and_suffix(strings: List[str], prefix_suffix: Tuple[str, str], min_length: int) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix, end with a given suffix, and have a minimum length.\n    \n    Example:\n    >>> filter_by_prefix_and_suffix([], ('a', 'z'), 3)\n    []\n    \n    >>> filter_by_prefix_and_suffix(['abc', 'bcd', 'cdez', 'arrayz'], ('a', 'z'), 5)\n    ['arrayz']\n    \n    >>> filter_by_prefix_and_suffix(['abc', 'azy'], ('a', 'z'), 3)\n    ['abc']\n    \"\"\"\n    pass",
      "def pattern_match(strings: List[str], pattern: Tuple[List[str], str, str]) -> Tuple[List[str], int, int]:\n    \"\"\" \n    - Filter an input list of strings only for ones that contain a given pattern,\n    - Strings should start with a given prefix, and end with a given suffix \n    - Calculate the Levenshtein distance between the pattern and string found in the list\n    - And count occurrence of the given prefix and suffix in all strings from the list\n\n    >>> pattern_match([], (['a', 'b', 'c'], 'a', 'z'))\n    ([], 0, 0)\n    >>> pattern_match(['abc', 'bcd', 'cdez', 'arrayz'], (['b', 'c', 'd'], 'a', 'z'))\n    (['arrayz'], 1, 2)\n    >>> pattern_match(['abc', 'azy'], (['b', 'c'], 'a', 'z'))\n    (['abc'], 1, 1)\n    \"\"\"\n\n    result, distance, prefix_count, suffix_count = [], 0, 0, 0\n    for string in strings:\n        if string.startswith(pattern[1]):\n            prefix_count += 1\n        if string.endswith(pattern[2]):\n            suffix_count += 1\n        if all(x in string for x in pattern[0]) and string.startswith(pattern[1]) and string.endswith(pattern[2]):\n            result.append(string)\n            distance += leven_dist(''.join(pattern[0]), string)\n    return result, distance, prefix_count, suffix_count",
      "def write_to_csv(strings: List[str]) -> None:\n    # Concatenate all the strings into a single string separated by commas\n    csv_content = ','.join(strings)\n    \n    # Write the resulting string to a CSV file\n    with open('outcsv.csv', 'w') as outfile:\n        outfile.write(csv_content)"
    ],
    "HumanEval/29": [
      "def filter_by_prefix_and_suffix(strings: List[str], prefix_suffix: Tuple[str, str], min_length: int) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix, end with a given suffix, and have a minimum length.\n    \n    Example:\n    >>> filter_by_prefix_and_suffix([], ('a', 'z'), 3)\n    []\n    \n    >>> filter_by_prefix_and_suffix(['abc', 'bcd', 'cdez', 'arrayz'], ('a', 'z'), 5)\n    ['arrayz']\n    \n    >>> filter_by_prefix_and_suffix(['abc', 'azy'], ('a', 'z'), 3)\n    ['abc']\n    \"\"\"\n    pass",
      "def filter_by_prefix_and_suffix(strings: List[str], prefix_suffix: Tuple[str, str]) -> List[str]:\n    \"\"\" Meticulously filter an input collection of strings for sole instances that inaugurate with a specified prefix and terminate with a distinctive suffix.\n    >>> filter_by_prefix_and_suffix([], ('a', 'z'))\n    []\n    >>> filter_by_prefix_and_suffix(['abc', 'bcd', 'cdez', 'arrayz'], ('a', 'z'))\n    ['arrayz']\n    >>> filter_by_prefix_and_suffix(['abc', 'azy'], ('a', 'z'))\n    ['azy', 'abc']\n    \"\"\"\n    pass",
      "def pattern_match(strings: List[str], pattern: Tuple[List[str], str, str]) -> Tuple[List[str], int, int]:\n    \"\"\" \n    - Filter an input list of strings only for ones that contain a given pattern,\n    - Strings should start with a given prefix, and end with a given suffix \n    - Calculate the Levenshtein distance between the pattern and string found in the list\n    - And count occurrence of the given prefix and suffix in all strings from the list\n\n    >>> pattern_match([], (['a', 'b', 'c'], 'a', 'z'))\n    ([], 0, 0)\n    >>> pattern_match(['abc', 'bcd', 'cdez', 'arrayz'], (['b', 'c', 'd'], 'a', 'z'))\n    (['arrayz'], 1, 2)\n    >>> pattern_match(['abc', 'azy'], (['b', 'c'], 'a', 'z'))\n    (['abc'], 1, 1)\n    \"\"\"\n\n    result, distance, prefix_count, suffix_count = [], 0, 0, 0\n    for string in strings:\n        if string.startswith(pattern[1]):\n            prefix_count += 1\n        if string.endswith(pattern[2]):\n            suffix_count += 1\n        if all(x in string for x in pattern[0]) and string.startswith(pattern[1]) and string.endswith(pattern[2]):\n            result.append(string)\n            distance += leven_dist(''.join(pattern[0]), string)\n    return result, distance, prefix_count, suffix_count",
      "def all_prefixes_with_lengths(string: str) -> List[Tuple[str, int]]:\n    \"\"\" \n    Function that returns a list of tuples which include all prefixes of an input string from smallest to largest and their corresponding lengths\n    E.g. all_prefixes_with_lengths('abc') should return [('a', 1), ('ab', 2), ('abc', 3)]\n    \"\"\"\n    return [(string[:i], i) for i in range(1, len(string)+1)]",
      "def shortest(strings: List[str]) -> Optional[str]:\n    \"\"\"From a list of strings, return the shortest string. If multiple strings have the same length, return the first one with the least consonants. For an empty list, return None.\n    >>> shortest([])\n    None\n    >>> shortest(['a', 'b', 'c'])\n    'a'\n    >>> shortest(['a', 'ab', 'cc'])\n    'a'\n    >>> shortest(['a', 'bc', 'bbc'])\n    'a'\n    >>> shortest(['a', 'ba', 'bb'])\n    'a'\n    \"\"\"\n    if not strings:\n        return None\n\n    # create a list of tuples, each containing a string and its length and no of consonants\n    strings = [(s, len(s), count_consonants(s)) for s in strings]\n\n    # sort by length and no of consonants\n    strings.sort(key=lambda x: [x[1], x[2]])\n\n    return strings[0][0]"
    ],
    "HumanEval/30": [
      "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n\n    result = []\n    for num in l:\n        if num > 0:\n          result.append(num)\n    return result",
      "def get_positive_and_sort(l: list):\n    \"\"\"Return only positive numbers in the list, sorted in ascending order.\n    >>> get_positive_and_sort([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive_and_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n\n    return sorted([num for num in l if num > 0])",
      "def get_positive_and_sort(n: list):\n    \"\"\"\n    Discard only the positive numbers in the list and arrange them in incremental order.\n    >>> get_positive_and_sort([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive_and_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n\n    positive_nums = [num for num in n if num > 0]  # Filter out positive numbers.\n    return sorted(positive_nums)  # Sort the positive numbers.",
      "def get_positive_and_sort(input_list):\n    \"\"\"\n    Return only positive numbers in the_list, sorted in ascending order.\n    >>> get_positive_and_sort([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive_and_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n\n    # Filter the positive numbers\n    l = [num for num in input_list if num > 0]\n\n    # Implement a bubble sorting algorithm\n    for i in range(len(l)):\n        for j in range(len(l) - i - 1):\n            if l[j] > l[j+1]:\n                # Swap elements\n                l[j], l[j+1] = l[j+1], l[j]\n    \n    return l",
      "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))"
    ],
    "HumanEval/31": [
      "def is_prime(n):\n    \"\"\"Returns true for prime integers, false for non-prime integers.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, math.isqrt(n)+1): \n        if n % i == 0:\n            return False\n    return True",
      "def is_prime(n):\n    \"\"\"Returns true for prime integers, false for non-prime integers.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n\n    if n == 2:\n        return True\n\n    if n % 2 == 0:\n        return False\n\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n\n    return True",
      "def is_prime(n):\n    \"\"\"Returns true for prime numbers, false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(0)\n    False\n    >>> is_prime(-101)\n    False\n    >>> is_prime(2.5)\n    False\n    \"\"\"\n    if isinstance(n, (float, complex)) or n < 2: #negatives & floats are not primes\n        return False\n    for i in range(2, math.isqrt(n) + 1): #only check up to square root of n\n        if n % i == 0:\n            return False\n    return True",
      "def is_prime(n):\n    \"\"\"Manifests as true for integers that are prime, reveals false for those that aren't.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    \n    if n in (2, 3):\n        return True\n    if n == 1 or n % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True",
      "def is_prime(n):\n    \"\"\"Returns true for prime integers, false for non-prime integers.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Check if the number is 2 (2 is the only even prime number)\n    if n == 2: \n      return True\n    # Check for less than 2 and even numbers\n    elif n < 2 or n % 2 == 0: \n      return False\n    # Check for divisibility by any other number up to sqrt(n)\n    for current in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % current == 0:\n            return False\n    return True"
    ],
    "HumanEval/32": [
      "def derivative_and_integral(xs: list, C: int):\n    \"\"\" \n    xs denotes the coefficients of a given polynomial. xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Function should output the derivative and integral of this polynomial in an identical format, incorporating C.\n    It should also return an error if the polynomial or constant C is invalid.\n    \"\"\"\n    \n    # Check if the polynomial is an empty list\n    if len(xs) == 0:\n        return \"Invalid polynomial\"\n    \n    # Check if the coefficients of the polynomial are integers\n    for coeff in xs:\n        if not isinstance(coeff, int):\n            return \"Invalid polynomial\"\n            \n    # Check if constant C is an integer\n    if not isinstance(C, int):\n        return \"Invalid constant\"\n        \n    # Calculate the derivative of the polynomial\n    derivative = [i*x for i, x in enumerate(xs)][1:]\n    \n    # Calculate the integral of the polynomial\n    integral = [C] + [x/(i+1) for i, x in enumerate(xs)]\n    \n    return derivative, integral",
      "def compute_derivative_integral(xs: list, C: int):\n    \"\"\"\n    Assumptions broken: (xs = coefficients of a polynomial in order: xs[0] + xs[1] * x + xs[2] * x^2 + ....)\n    Compute both the derivative and integral of the given polynomial, incorporate constant C and remove any surplus zeros. Ensure correctness with edge cases.\n    \"\"\"\n    if not xs:\n        return [], [C]\n    \n    derivative = []\n    integral = [C]\n\n    for i in range(len(xs)):\n        if i > 0:  derivative.append(i * xs[i])\n        if i > 0:  integral.append(xs[i-1] /(i))\n        \n    integral.append(xs[-1] / len(xs))\n\n    while derivative and derivative[-1] == 0:\n        derivative.pop()\n        \n    while len(integral) > 1 and integral[-1] == 0:  # retain the constant term even if it's zero.\n        integral.pop()\n\n    return derivative, integral",
      "def derivative_and_integral(xs: list, C: int):\n    \"\"\"\n    Violations: (xs = coefficients of a polynomial.     xs[0] + xs[1] * x + xs[2] * x^2 + ....)\n    Return derivative and integral of this polynomial, include constant C and remove any trailing zeros. Ensure this works for edge cases.\n    >>> derivative_and_integral([3, 1, 2, 4, 5], 2)\n    ([1, 4, 12, 20], [2, 3, 0.5, 0.6666666666666666, 1, 1])\n    >>> derivative_and_integral([1, 2, 3], 4)\n    ([2, 6], [4, 1, 1, 1])\n    \"\"\"\n\n    derivative = []\n    integral = [C]\n\n    for i in range(len(xs)):\n        if i != 0:\n            derivative.append(i * xs[i])\n            integral.append(xs[i-1] / i)\n        else:\n            # The derivative of a constant is 0\n            derivative.append(0)\n    integral.append(xs[-1] / len(xs))         \n    # All the trailing zeros are removed from the derivative.    \n    while derivative and derivative[-1] == 0:\n        derivative.pop()\n\n    return derivative, integral",
      "def derivative_and_integral(xs, C):\n    \"\"\"\n    Given xs: coefficients of a polynomial: xs[0] + xs[1] * x + xs[2] * x^2 t....\n    Return derivative and integral of this polynomial, including constant C and remove any trailing zeros.\n    Ensure this works for edge cases.\n\n    >>> derivative_and_integral([3, 1, 2, 4, 5], 2)\n    ([1, 4, 12, 20], [2, 3, 0.5, 0.6666666666666666, 1])\n    >>> derivative_and_integral([1, 2, 3], 4)\n    ([2, 6], [4, 1, 1, 1])\n    \"\"\"\n\n    derivative = []\n    integral = [C]\n    \n    for i in range(len(xs)):\n        if i != 0:\n            derivative.append(i * xs[i])\n            integral.append(xs[i-1] / i)\n        else:\n            # The derivative of a constant is 0\n            derivative.append(0)\n            integral.append(xs[0])\n\n    # All the trailing zeros are removed from the derivative.\n    while derivative and derivative[-1] == 0:\n        derivative.pop()\n\n    return derivative, integral",
      "def derivative_and_integral(xs: list, C: int):\n    \"\"\"\n    xs = coefficients of a polynomial (xs[0] + xs[1] * x + xs[2] * x^2 + ....)\n    This function returns the derivative and integral of the given polynomial, includes the constant C, and removes trailing zeros.\n\n    >>> derivative_and_integral([3, 1, 2, 4, 5], 2)\n    ([1, 4, 12, 20], [2.0, 3.0, 0.5, 0.5, 0.8, 1.0])\n    >>> derivative_and_integral([1, 2, 3], 4)\n    ([2, 6], [4.0, 1.0, 1.0, 1.0])\n    \"\"\"\n    derivative = []\n    integral = [C]\n\n    for i in range(len(xs)):\n        if i != 0:\n            derivative.append(i * xs[i])\n        if i+1 != 0:\n            integral.append(xs[i] / (i+1))\n\n    # Remove trailing zeros\n    while integral[-1] == 0:\n        integral = integral[:-1] \n    while derivative and derivative[-1] == 0:\n        derivative = derivative[:-1]\n  \n    return derivative, integral"
    ],
    "HumanEval/33": [
      "def advanced_sort(l: list, n: int):\n    \"\"\"\n    This function accepts a list l, an integer n and returns a new resultant list l' that satisfies the next conditions:\n    l' equates l at indices not divisible by n; however at indices divisible by n, values parallel l's corresponding indices, but with the uniqueness of being multiplied by 2 and arranged in reverse.\n\n    >>> advanced_sort([1, 2, 3], 2)\n    [1, 2, 3]\n    >>> advanced_sort([5, 6, 3, 4, 8, 9, 2], 3)\n    [5, 6, 3, 2, 8, 9, 1]\n    >>> advanced_sort([8, 7, 4, 1, 3, 6, 5], 3)\n    [8, 7, 4, 5, 3, 6, 1]\n    \"\"\"\n\n    sublist = [val * 2 for i, val in enumerate(l) if i % n == 0]\n    sublist.sort(reverse=True)\n\n    new_list = l.copy()\n    index = 0\n    for i, val in enumerate(new_list):\n        if i % n == 0:\n            new_list[i] = sublist[index]\n            index += 1\n\n    return new_list",
      "def sort_special(l: list):\n    \"\"\"\n    This function takes in a list l and returns a modified list l' that follows these conditions:\n    l' aligns with l at indexes not exactly divided by five; however, for indexes fully divisible by five, the values equal relative positions in list l,\n    but in a reverse order, while middle elements should also be sorted in ascending order.\n    In addition, the 3rd element of every triple (i.e., the element at index 2 and every 3rd spot thereafter) needs to be multiplied by \n    the index it is in. If after multiplication, the value of the element is greater than the last element,\n    the value of the element becomes the average of the entire list (integer division).\n\n    >>> sort_special([1, 2, 3])\n    [1, 2, 6]\n    >>> sort_special([5, 6, 3, 4, 8, 9, 2])\n    [5, 6, 9, 2, 4, 27, 1]\n    >>> sort_special([8, 7, 4, 1, 3, 6, 5])\n    [8, 7, 12, 1, 15, 5, 6]\n    \"\"\"\n    return l",
      "def sort_and_transform_even_indices(l: list) -> list:\n    \"\"\"\n    This function accepts a list l and generates a new list l'. This new list preserves the odd indices from l. At the even indices,\n    it creates a list from the corresponding positions in l, sorts it in ascending order, and transforms the sorted data using the square function before placing \n    them in the new list.\n\n    >>> sort_and_transform_even_indices([1, 2, 3])\n    [1, 2, 9]\n    >>> sort_and_transform_even_indices([5, 6, 3, 4, 8, 9, 2])\n    [4, 6, 9, 4, 25, 9, 64]\n    >>> sort_and_transform_even_indices([8, 7, 4, 1, 3, 6, 5])\n    [1, 7, 9, 1, 16, 6, 64]\n    \"\"\"\n\n    even_indices_list = sorted([l[i] for i in range(0, len(l), 2)])\n    return [square(even_indices_list.pop(0)) if i % 2 == 0 else l[i] for i in range(len(l))]",
      "def sort_and_transform_even_indices(l: list) -> list:\n    \"\"\"\n    This function accepts a list l and generates a new list l'. This new list preserves the odd indices from l. At the even indices,\n    it creates a list from the corresponding positions in l, sorts it in ascending order, and transforms the sorted data using the square function before placing \n    them in the new list.\n\n    >>> sort_and_transform_even_indices([1, 2, 3])\n    [1, 2, 9]\n    >>> sort_and_transform_even_indices([5, 6, 3, 4, 8, 9, 2])\n    [4, 6, 9, 4, 25, 9, 64]\n    >>> sort_and_transform_even_indices([8, 7, 4, 1, 3, 6, 5])\n    [1, 7, 9, 1, 16, 6, 64]\n    \"\"\"\n\n    even_indices_list = sorted([l[i] for i in range(0, len(l), 2)])\n    return [square(even_indices_list.pop(0)) if i % 2 == 0 else l[i] for i in range(len(l))]",
      "def sort_and_transform_even_indices(l: list) -> list:\n    \"\"\"\n    This function accepts a list l and generates a new list l'. This new list preserves the odd indices from l. \n    At the even indices, it creates a list from the corresponding positions in l, \n    sorts it in ascending order, and transforms the sorted data using the square function before placing \n    them in the new list.\n\n    >>> sort_and_transform_even_indices([1, 2, 3])\n    [1, 2, 9]\n    >>> sort_and_transform_even_indices([5, 6, 3, 4, 8, 9, 2])\n    [4, 6, 9, 4, 25, 9, 64]\n    >>> sort_and_transform_even_indices([8, 7, 4, 1, 3, 6, 5])\n    [1, 7, 9, 1, 16, 6, 64]\n    \"\"\"\n    even_indices_list = sorted([l[i] for i in range(0, len(l), 2)])\n    return [square(even_indices_list.pop(0)) if i % 2 == 0 else l[i] for i in range(len(l))]"
    ],
    "HumanEval/34": [
      "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))",
      "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # convert the list to a set to remove duplicates, then convert it back to a list\n    l = list(set(l))\n\n    # sort the list in increasing order\n    l.sort()\n\n    return l",
      "def unique_count(l: list):\n    \"\"\"Return sorted unique elements in a list and their count\n\n    >>> unique_count([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [(0, 1), (2, 1), (3, 3), (5, 2), (9, 1), (123, 1)] \n    \"\"\" \n    l_counter = Counter(l)\n    result = sorted(l_counter.items())\n    return result",
      "def get_positive_and_sort(l: list):\n    \"\"\"Return only positive numbers in the list, sorted in ascending order.\n    >>> get_positive_and_sort([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive_and_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n\n    return sorted([num for num in l if num > 0])",
      "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n\n    result = []\n    for num in l:\n        if num > 0:\n          result.append(num)\n    return result"
    ],
    "HumanEval/35": [
      "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n\n    result = []\n    for num in l:\n        if num > 0:\n          result.append(num)\n    return result",
      "def get_positive_and_sort(l: list):\n    \"\"\"Return only positive numbers in the list, sorted in ascending order.\n    >>> get_positive_and_sort([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive_and_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n\n    return sorted([num for num in l if num > 0])",
      "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))",
      "def get_positive_and_sort(n: list):\n    \"\"\"\n    Discard only the positive numbers in the list and arrange them in incremental order.\n    >>> get_positive_and_sort([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive_and_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n\n    positive_nums = [num for num in n if num > 0]  # Filter out positive numbers.\n    return sorted(positive_nums)  # Sort the positive numbers.",
      "def sorted_absolute_values(numbers: list):\n    \"\"\"Return sorted list of absolute values\n    >>> sorted_absolute_values([-5, 3, -2, 2, 3, -3, 9, 0, -123])\n    [0, 2, 2, 3, 3, 3, 5, 9, 123]\n    \"\"\"\n    abs_numbers = [abs(num) for num in numbers]\n    abs_numbers.sort()\n    return abs_numbers"
    ],
    "HumanEval/36": [
      "def fib(n):\n    a, b = 0, 1\n    for _ in range(n):\n        fizz_buzz = \"\"\n        if a % 2 == 0:\n            fizz_buzz += \"Fizz\"\n        if a % 5 == 0:\n            fizz_buzz += \"Buzz\"\n\n        if fizz_buzz == \"\":\n            print(a)\n        else:\n            print(fizz_buzz)\n        \n        a, b = b, a + b",
      "def is_prime(n):\n    \"\"\"Returns true for prime integers, false for non-prime integers.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Check if the number is 2 (2 is the only even prime number)\n    if n == 2: \n      return True\n    # Check for less than 2 and even numbers\n    elif n < 2 or n % 2 == 0: \n      return False\n    # Check for divisibility by any other number up to sqrt(n)\n    for current in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % current == 0:\n            return False\n    return True",
      "def is_prime(n):\n    \"\"\"Returns true for prime integers, false for non-prime integers.\n    \n    >>> is_prime(-3)\n    False\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Check if the input is of the correct type (integer)\n    if type(n) != int:\n        return False\n\n    # Check for negative numbers and numbers less than or equal to 1\n    if n <= 1:\n        return False\n\n    # Check if n is divisible by any number up to the square root of n\n    for i in range(2, int(n**0.5)+1):\n        if (n % i) == 0:\n            return False\n\n    # If no factors found, then n is prime\n    return True",
      "def sum_of_squares(arr):\n    \"\"\"Calculate square sum of numbers divisible by 3 or 7.\n    \n    This function takes a list of integers and strings, converting \n    strings to integers where possible, and returns the sum of the squares \n    of all positive elements divisible by either 3 or 7. Non-convertible \n    strings and negative numbers are ignored.\n\n    Args:\n        arr (list): A list containing integers and strings.\n\n    Returns:\n        int: The sum of squares of all positive elements divisible by 3 or 7.\n\n    Examples:\n        >>> sum_of_squares([])\n        0\n        >>> sum_of_squares(['3', 7, -1, '11', 'not-an-int'])\n        58\n        >>> sum_of_squares([4, '9', 7, '3'])\n        130\n    \"\"\"\n    return sum(int(i)**2 for i in arr if str(i).isdigit() and int(i) > 0 and (int(i) % 3 == 0 or int(i) % 7 == 0))",
      "def is_prime(n):\n    \"\"\"Manifests as true for integers that are prime, reveals false for those that aren't.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    \n    if n in (2, 3):\n        return True\n    if n == 1 or n % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True"
    ],
    "HumanEval/37": [
      "def sort_special(l: list):\n    \"\"\"\n    This function takes in a list l and returns a modified list l' that follows these conditions:\n    l' aligns with l at indexes not exactly divided by five; however, for indexes fully divisible by five, the values equal relative positions in list l,\n    but in a reverse order, while middle elements should also be sorted in ascending order.\n    In addition, the 3rd element of every triple (i.e., the element at index 2 and every 3rd spot thereafter) needs to be multiplied by \n    the index it is in. If after multiplication, the value of the element is greater than the last element,\n    the value of the element becomes the average of the entire list (integer division).\n\n    >>> sort_special([1, 2, 3])\n    [1, 2, 6]\n    >>> sort_special([5, 6, 3, 4, 8, 9, 2])\n    [5, 6, 9, 2, 4, 27, 1]\n    >>> sort_special([8, 7, 4, 1, 3, 6, 5])\n    [8, 7, 12, 1, 15, 5, 6]\n    \"\"\"\n    return l",
      "def sort_and_transform_even_indices(l: list) -> list:\n    \"\"\"\n    This function accepts a list l and generates a new list l'. This new list preserves the odd indices from l. At the even indices,\n    it creates a list from the corresponding positions in l, sorts it in ascending order, and transforms the sorted data using the square function before placing \n    them in the new list.\n\n    >>> sort_and_transform_even_indices([1, 2, 3])\n    [1, 2, 9]\n    >>> sort_and_transform_even_indices([5, 6, 3, 4, 8, 9, 2])\n    [4, 6, 9, 4, 25, 9, 64]\n    >>> sort_and_transform_even_indices([8, 7, 4, 1, 3, 6, 5])\n    [1, 7, 9, 1, 16, 6, 64]\n    \"\"\"\n\n    even_indices_list = sorted([l[i] for i in range(0, len(l), 2)])\n    return [square(even_indices_list.pop(0)) if i % 2 == 0 else l[i] for i in range(len(l))]",
      "def sort_and_transform_even_indices(l: list) -> list:\n    \"\"\"\n    This function accepts a list l and generates a new list l'. This new list preserves the odd indices from l. At the even indices,\n    it creates a list from the corresponding positions in l, sorts it in ascending order, and transforms the sorted data using the square function before placing \n    them in the new list.\n\n    >>> sort_and_transform_even_indices([1, 2, 3])\n    [1, 2, 9]\n    >>> sort_and_transform_even_indices([5, 6, 3, 4, 8, 9, 2])\n    [4, 6, 9, 4, 25, 9, 64]\n    >>> sort_and_transform_even_indices([8, 7, 4, 1, 3, 6, 5])\n    [1, 7, 9, 1, 16, 6, 64]\n    \"\"\"\n\n    even_indices_list = sorted([l[i] for i in range(0, len(l), 2)])\n    return [square(even_indices_list.pop(0)) if i % 2 == 0 else l[i] for i in range(len(l))]",
      "def sort_and_transform_even_indices(l: list) -> list:\n    \"\"\"\n    This function accepts a list l and generates a new list l'. This new list preserves the odd indices from l. \n    At the even indices, it creates a list from the corresponding positions in l, \n    sorts it in ascending order, and transforms the sorted data using the square function before placing \n    them in the new list.\n\n    >>> sort_and_transform_even_indices([1, 2, 3])\n    [1, 2, 9]\n    >>> sort_and_transform_even_indices([5, 6, 3, 4, 8, 9, 2])\n    [4, 6, 9, 4, 25, 9, 64]\n    >>> sort_and_transform_even_indices([8, 7, 4, 1, 3, 6, 5])\n    [1, 7, 9, 1, 16, 6, 64]\n    \"\"\"\n    even_indices_list = sorted([l[i] for i in range(0, len(l), 2)])\n    return [square(even_indices_list.pop(0)) if i % 2 == 0 else l[i] for i in range(len(l))]",
      "def advanced_sort(l: list, n: int):\n    \"\"\"\n    This function accepts a list l, an integer n and returns a new resultant list l' that satisfies the next conditions:\n    l' equates l at indices not divisible by n; however at indices divisible by n, values parallel l's corresponding indices, but with the uniqueness of being multiplied by 2 and arranged in reverse.\n\n    >>> advanced_sort([1, 2, 3], 2)\n    [1, 2, 3]\n    >>> advanced_sort([5, 6, 3, 4, 8, 9, 2], 3)\n    [5, 6, 3, 2, 8, 9, 1]\n    >>> advanced_sort([8, 7, 4, 1, 3, 6, 5], 3)\n    [8, 7, 4, 5, 3, 6, 1]\n    \"\"\"\n\n    sublist = [val * 2 for i, val in enumerate(l) if i % n == 0]\n    sublist.sort(reverse=True)\n\n    new_list = l.copy()\n    index = 0\n    for i, val in enumerate(new_list):\n        if i % n == 0:\n            new_list[i] = sublist[index]\n            index += 1\n\n    return new_list"
    ],
    "HumanEval/38": [
      "def encode_cyclic(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of three characters.\n    \"\"\"\n\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)",
      "def encode_cyclic(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of three characters - including numbers.\n    \"\"\"\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)",
      "def decode_cyclic(s: str):\n    \"\"\"\n    Given a string encoded with the encode_cyclic function, this function returns the original (decoded) string.\n    \"\"\"\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)",
      "def encode_cyclic(z: str):\n    \"\"\"\n    Returns encoded string by cycling groups of three characters.\n    \"\"\"\n    groups = [z[3 * i:min(3 * i + 3, len(z))] for i in range((len(z) + 2) // 3)]\n    groups = [group[1:] + group[0] if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)",
      "def decode_cyclic(s: str):\n    \"\"\"\n    Accepts a string encoded with the above encode_cyclic function and returns the decoded string, handling special characters and whitespace.\n    \"\"\"\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"
    ],
    "HumanEval/39": [
      "def get_prime_fibonacci(p):\n    fib_series = get_fibonacci(p)\n    prime_fib = [num for num in fib_series if is_prime(num)]\n    return prime_fib",
      "def prime_fib(n):\n    # Check if the input is an integer\n    if type(n) != int:\n        raise TypeError(\"Input must be an integer.\")\n    # Check if the input is greater than 0\n    if n <= 0:\n        raise ValueError(\"Input must be greater than 0.\")\n \n    a, b = 0, 1\n    primes = []\n    for i in range(n):\n        # calculate next fibonacci number\n        a, b = b, a + b\n        # exit if next fib number is greater than 150\n        if a > 150:\n            break\n        # check if next fib number is prime\n        if a < 2: continue\n        is_prime = all(a % num != 0 for num in range(2, int(a**0.5) + 1))\n        if(is_prime):\n            primes.append(a)\n    return primes",
      "def is_prime(n):\n    \"\"\"Returns true for prime integers, false for non-prime integers.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Check if the number is 2 (2 is the only even prime number)\n    if n == 2: \n      return True\n    # Check for less than 2 and even numbers\n    elif n < 2 or n % 2 == 0: \n      return False\n    # Check for divisibility by any other number up to sqrt(n)\n    for current in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % current == 0:\n            return False\n    return True",
      "def lcm(x: int, y: int, z: int):\n  \"\"\" \n  LCM determination function for x, y and z. \n\n  Constraints: x, y, z are prime numbers; 1 <= x, y, z <= 10^9\n\n  >>> lcm(3, 5, 7)\n  105\n  >>> lcm(2, 11, 13)\n  286\n  >>> lcm(2, 23, 89)\n  4094\n  >>> lcm(5, 7, 11)\n  385\n  >>> lcm(31, 37, 41)\n  46957\n  \"\"\"\n  temp_lcm = (x * y) // gcd(x, y)\n  return (temp_lcm * z) // gcd(temp_lcm, z)",
      "def is_prime(n):\n    \"\"\"Returns true for prime integers, false for non-prime integers.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:   # 0 and 1 are not prime\n        return False\n    if n <= 3:   # 2 and 3 are prime\n        return True\n    if n % 2 == 0 or n % 3 == 0:  # eliminate multiples of 2 and 3 \n        return False\n    i = 5\n    while (i * i <= n):\n        if (n % i) == 0 or (n % (i + 2)) == 0: # increment the counter in steps of 6\n            return False\n        i += 6\n    return True"
    ],
    "HumanEval/40": [
      "def sum_of_even_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers: A list of integers.\n\n    Returns:\n    The sum of all even numbers in the list.\n    \n    Examples:\n    >>> sum_of_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    30\n    >>> sum_of_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_of_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)",
      "def diffList(numList: List[int], absolute_difference: bool = False) -> List[int]:\n    \"\"\" Return the difference of each pair of consecutive numbers from `numList'\n    >>> diffList([1, 2, 3])\n    [1, 1]\n    >>> diffList([2, 5, 9, 16])\n    [3, 4, 7]\n    >>> diffList([2, 5, 9, 16], absolute_difference=True)\n    [3, 4, 7]\n    \"\"\"\n    diff_list = []\n    \n    for i in range(1, len(numList)):\n        difference = numList[i] - numList[i-1]\n        \n        if absolute_difference:\n            difference = abs(difference)\n        \n        diff_list.append(difference)\n    \n    return diff_list",
      "def sort_and_transform_even_indices(l: list) -> list:\n    \"\"\"\n    This function accepts a list l and generates a new list l'. This new list preserves the odd indices from l. At the even indices,\n    it creates a list from the corresponding positions in l, sorts it in ascending order, and transforms the sorted data using the square function before placing \n    them in the new list.\n\n    >>> sort_and_transform_even_indices([1, 2, 3])\n    [1, 2, 9]\n    >>> sort_and_transform_even_indices([5, 6, 3, 4, 8, 9, 2])\n    [4, 6, 9, 4, 25, 9, 64]\n    >>> sort_and_transform_even_indices([8, 7, 4, 1, 3, 6, 5])\n    [1, 7, 9, 1, 16, 6, 64]\n    \"\"\"\n\n    even_indices_list = sorted([l[i] for i in range(0, len(l), 2)])\n    return [square(even_indices_list.pop(0)) if i % 2 == 0 else l[i] for i in range(len(l))]",
      "def sort_and_transform_even_indices(l: list) -> list:\n    \"\"\"\n    This function accepts a list l and generates a new list l'. This new list preserves the odd indices from l. At the even indices,\n    it creates a list from the corresponding positions in l, sorts it in ascending order, and transforms the sorted data using the square function before placing \n    them in the new list.\n\n    >>> sort_and_transform_even_indices([1, 2, 3])\n    [1, 2, 9]\n    >>> sort_and_transform_even_indices([5, 6, 3, 4, 8, 9, 2])\n    [4, 6, 9, 4, 25, 9, 64]\n    >>> sort_and_transform_even_indices([8, 7, 4, 1, 3, 6, 5])\n    [1, 7, 9, 1, 16, 6, 64]\n    \"\"\"\n\n    even_indices_list = sorted([l[i] for i in range(0, len(l), 2)])\n    return [square(even_indices_list.pop(0)) if i % 2 == 0 else l[i] for i in range(len(l))]",
      "def sort_and_transform_even_indices(l: list) -> list:\n    \"\"\"\n    This function accepts a list l and generates a new list l'. This new list preserves the odd indices from l. \n    At the even indices, it creates a list from the corresponding positions in l, \n    sorts it in ascending order, and transforms the sorted data using the square function before placing \n    them in the new list.\n\n    >>> sort_and_transform_even_indices([1, 2, 3])\n    [1, 2, 9]\n    >>> sort_and_transform_even_indices([5, 6, 3, 4, 8, 9, 2])\n    [4, 6, 9, 4, 25, 9, 64]\n    >>> sort_and_transform_even_indices([8, 7, 4, 1, 3, 6, 5])\n    [1, 7, 9, 1, 16, 6, 64]\n    \"\"\"\n    even_indices_list = sorted([l[i] for i in range(0, len(l), 2)])\n    return [square(even_indices_list.pop(0)) if i % 2 == 0 else l[i] for i in range(len(l))]"
    ],
    "HumanEval/41": [
      "def advanced_concurrent_collision_detector(n: int, left_lane_autos: List[Tuple[float, float]], right_lane_autos: List[Tuple[float, float]]) -> List[Tuple[int, int, float, float]]:\n    \"\"\" Detects the concurrent collisions between cars in both lanes.\n    Returns a list of tuples where each tuple represents a collision.\n    The first two elements are the index of the collided cars in left and right lanes and the other two elements are the overlapping distance.\n\n    :param n: Number of automobiles in each lane\n    :param left_lane_autos: List of tuples indicating the start and end points of automobiles in left lane\n    :param right_lane_autos: List of tuples indicating the start and end points of automobiles in right lane\n    :return: A list of tuples indicating the collided automobiles and their overlapping distance\n    \"\"\"\n    collisions = []\n    for i in range(n):\n        for j in range(n):\n            if left_lane_autos[i][0] < right_lane_autos[j][1] and left_lane_autos[i][1] > right_lane_autos[j][0]:  # Check if ranges of left and right cars overlap\n                overlap_start = max(right_lane_autos[j][0], left_lane_autos[i][0])\n                overlap_end = min(right_lane_autos[j][1], left_lane_autos[i][1])\n                collisions.append((i, j, overlap_start, overlap_end))\n    return collisions",
      "def advanced_concurrent_collision_detection(n: int, left_lane_autos: List[Tuple[float, float]], right_lane_autos: List[Tuple[float, float]]) -> List[Tuple[int, int, float, float]]:\n    \"\"\"\n    Detects the concurrent collisions between cars in both lanes.\n    Returns a list of tuples where each tuple represents a collision.\n    The first two elements are the index of the collided cars in left and right lanes and the other two elements are the overlapping distance.\n\n    :param n: Number of automobiles in each lane\n    :param left_lane_autos: List of tuples indicating the start and end points of automobiles in left lane\n    :param right_lane_autos: List of tuples indicating the start and end points of automobiles in right lane\n    :return: A list of tuples indicating the collided automobiles and their overlapping distance\n    \"\"\"\n    collisions = []\n    for i in range(n):\n        for j in range(n):\n            if left_lane_autos[i][0] <= right_lane_autos[j][1] and left_lane_autos[i][1] > right_lane_autos[j][0]:  # Check if ranges of left and right cars overlap\n                overlap_start = max(right_lane_autos[j][0], left_lane_autos[i][0])\n                overlap_end = min(right_lane_autos[j][1], left_lane_autos[i][1])\n                collisions.append((i, j, overlap_start, overlap_end))\n    return collisions",
      "def product_except_self(nums):\n    length = len(nums)\n    # Initialize an array named \"output\" with all 1s.\n    output = [1]*length\n    \n    # Define two variables left and right and initialize them to 1.\n    left = right = 1\n    \n    # Traverse the input array from left and right corners in such a way that from left,\n    # we are calculating the product of all the elements to the left and from right,\n    # we are calculating the product of all the elements to the right.\n    for i in range(length):\n        output[i] *= left\n        output[length-1-i] *= right\n        left *= nums[i]\n        right *= nums[length-1-i]\n    \n    # Return the output.\n    return output",
      "def simulate_motion():\n    S = 50 # Speed of the slower car in km/h\n    D = 340 # Maximum distance between the cars in km\n    time_interval = 1 # Time interval in seconds\n\n    t = 0 # Initial time\n    distance = 0 # Initial distance between the cars\n\n    while distance < D:\n        speed_slow = S\n        speed_fast = F(S, A(t))\n\n        position_slow = speed_slow * t\n        position_fast = speed_fast * t\n\n        distance = abs(position_slow - position_fast)\n\n        print(\"Time:\", t, \"seconds\")\n        print(\"Position of slower car:\", position_slow, \"km\")\n        print(\"Position of faster car:\", position_fast, \"km\")\n        print(\"Speed of slower car:\", speed_slow, \"km/h\")\n        print(\"Speed of faster car:\", speed_fast, \"km/h\")\n        print(\"Total distance between the cars:\", distance, \"km\")\n        print(\"\")\n\n        t += time_interval",
      "def find_all_electric_cars(cars, index=0, electric_cars=None):\n    if electric_cars is None:\n        electric_cars = []\n\n    if index >= len(cars):\n        electric_cars.sort()\n        return electric_cars\n\n    car = cars[index]\n    if car['type'] == 'electric' and car['range'] >= 200:\n        electric_cars.append(car['name'])\n\n    return find_all_electric_cars(cars, index + 1, electric_cars)"
    ],
    "HumanEval/42": [
      "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n\n    result = []\n    for num in l:\n        if num > 0:\n          result.append(num)\n    return result",
      "def get_positive_and_sort(l: list):\n    \"\"\"Return only positive numbers in the list, sorted in ascending order.\n    >>> get_positive_and_sort([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive_and_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n\n    return sorted([num for num in l if num > 0])",
      "def advanced_sort(l: list, n: int):\n    \"\"\"\n    This function accepts a list l, an integer n and returns a new resultant list l' that satisfies the next conditions:\n    l' equates l at indices not divisible by n; however at indices divisible by n, values parallel l's corresponding indices, but with the uniqueness of being multiplied by 2 and arranged in reverse.\n\n    >>> advanced_sort([1, 2, 3], 2)\n    [1, 2, 3]\n    >>> advanced_sort([5, 6, 3, 4, 8, 9, 2], 3)\n    [5, 6, 3, 2, 8, 9, 1]\n    >>> advanced_sort([8, 7, 4, 1, 3, 6, 5], 3)\n    [8, 7, 4, 5, 3, 6, 1]\n    \"\"\"\n\n    sublist = [val * 2 for i, val in enumerate(l) if i % n == 0]\n    sublist.sort(reverse=True)\n\n    new_list = l.copy()\n    index = 0\n    for i, val in enumerate(new_list):\n        if i % n == 0:\n            new_list[i] = sublist[index]\n            index += 1\n\n    return new_list",
      "def test_quick_sort():\n    assert quick_sort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10]\n    assert quick_sort([3]) == [3]\n    assert quick_sort([]) == []\n    assert quick_sort([9, 8, 7, 6, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert quick_sort([1, 2, 3, 4, 5, 6, 7, 8, 9]) == [1, 2, 3, 4, 5, 6, 7, 8, 9]",
      "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))"
    ],
    "HumanEval/43": [
      "def diffList(numList: List[int], absolute_difference: bool = False) -> List[int]:\n    \"\"\" Return the difference of each pair of consecutive numbers from `numList'\n    >>> diffList([1, 2, 3])\n    [1, 1]\n    >>> diffList([2, 5, 9, 16])\n    [3, 4, 7]\n    >>> diffList([2, 5, 9, 16], absolute_difference=True)\n    [3, 4, 7]\n    \"\"\"\n    diff_list = []\n    \n    for i in range(1, len(numList)):\n        difference = numList[i] - numList[i-1]\n        \n        if absolute_difference:\n            difference = abs(difference)\n        \n        diff_list.append(difference)\n    \n    return diff_list",
      "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Authoritatively yield manually ordered, non-repetitive intersecting elements for two lists. \n    This function is constructed to handle integer arrays including negative integers, without depending \n    on inherent Python list functionalities. The function returns a well-ordered list eliminating any duplicates.\n    If one of the lists is empty, the function returns an empty list. \n    \n    :param l1: The first list of integers.\n    :type l1: list\n    :param l2: The second list of integers.\n    :type l2: list\n    :returns: A list containing ordered intersecting elements from both lists, without duplicates.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    >>> common([-2, -3, 0, 2, 5], [-5, 2, 0, -3])\n    [-3, 0, 2]\n    >>> common([-2, -3, 0, 2, 5], [])\n    []\n    \"\"\"\n    common_set = set()\n    ordered_set = set()\n    \n    # Traverse through lists and add common elements to common_set\n    for num in l1:\n        if num in l2 and num not in common_set:\n            common_set.add(num)\n            \n    # Traverse through common_set and add elements into ordered_set in sorted order.\n    # This step ensures the elimination of duplicate elements and correct ordering.\n    for num in sorted(common_set):\n        ordered_set.add(num)\n    \n    return list(ordered_set)",
      "def sum_of_even_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers: A list of integers.\n\n    Returns:\n    The sum of all even numbers in the list.\n    \n    Examples:\n    >>> sum_of_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    30\n    >>> sum_of_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_of_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)",
      "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Authoritatively yield manually ordered, non-repetitive intersecting elements for two lists.\n    This function is constructed to handle integer arrays including negative integers,without depending \n    on inherent Python list functionalities. The function returns a well-ordered list eliminating any duplicates.\n    If one of the lists is empty, the function returns an empty list. \n\n    :param l1: The first list of integers.\n    :type l1: list\n    :param l2: The second list of integers.\n    :type l2: list\n    :returns: A list containing ordered intersecting elements from both lists, without duplicates.\n\n    >>> common([1, 4, 3, 34, 86, 2, 5], [5, 7, 1, 8, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    >>> common([-2, -3, 0, 2, 5], [-5, 2, 0, -3])\n    [-3, 0, 2]\n    >>> common([-2, -3, 0, 2, 5], [])\n    []\n    \"\"\"\n    common_set = set()\n    ordered_set = set()\n\n    # Traverse through lists and add common elements to common_set\n    for num in l1:\n        if num in l2 and num not in common_set:\n            common_set.add(num)\n\n    # Traverse through common_set and add elements into ordered_set in sorted order.\n    # This step ensures the elimination of duplicate elements and correct ordering.\n    for num in sorted(common_set):\n        ordered_set.add(num)\n\n    return list(ordered_set)",
      "def pattern_check(l: list, even: bool = False) -> bool:\n    \"\"\"\n    Returns True if the list follows an alternated pattern (number, letter, number, and so on) heeding the even requirement and a supplementary condition - the list should not carry any even numbers when 'even' parameter is True. \n    If even is True, numbers in the list must be even; otherwise, they may be any.\n    \n    >>> pattern_check([1, 'a', 3, 'b', 5])\n    True\n    >>> pattern_check([2, 'b', 4, 'd', 6], even=True)\n    True\n    >>> pattern_check([1, 'c', 2, 'd', 3])\n    False\n    >>> pattern_check([2, 'c', 4, 'd', 6], even=False)\n    False\n    \"\"\"\n    for i in range(len(l)):\n        if i % 2 == 0:\n            if even:\n                if not(isinstance(l[i], int) and l[i] % 2 == 0):\n                    return False\n            else:\n                if not isinstance(l[i], int):\n                    return False\n        elif not isinstance(l[i], str):\n            return False\n    return True"
    ],
    "HumanEval/44": [
      "def number_to_binary(x: str, base: int):\n    \"\"\"Switch an input number -- submitted as a string -- with a declared base (as integer) into the respective binary interpretation, represented as a string. \n    The base may be 8 (indicating octal), 10 (reflecting decimal), or 16 (representing hexadecimal).\n    >>> number_to_binary('8', 16)\n    '1000'\n    >>> number_to_binary('F', 16)\n    '1111'\n    >>> number_to_binary('1A', 16)\n    '11010'\n    >>> number_to_binary('10', 8)\n    '1000'\n    >>> number_to_binary('7', 8)\n    '111'\n    >>> number_to_binary('12', 8)\n    '1010'\n    >>> number_to_binary('9', 10)\n    '1001'\n    >>> number_to_binary('15', 10)\n    '1111'\n    >>> number_to_binary('26', 10)\n    '11010'\n    \"\"\"\n    return bin(int(x, base))[2:]",
      "def number_to_binary(x: str, base: int):\n    \"\"\"Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent as a string.\n    The base can be either 8 (indicating octal), 10 (indicating decimal), or 16 (for hexadecimal).\n    Examples are provided below for better understanding:\n    >>> number_to_binary('8', 16) => '1000'\n    >>> number_to_binary('F', 16) => '1111'\n    >>> number_to_binary('1A', 16) => '11010'\n    >>> number_to_binary('10', 8) => '1000'\n    >>> number_to_binary('7', 8)  => '111'\n    >>> number_to_binary('12', 8) => '1010'\n    >>> number_to_binary('9', 10) => '1001'\n    >>> number_to_binary('15', 10) => '1111'\n    >>> number_to_binary('26', 10) => '11010'\n    \"\"\"\n    # Convert the input to an integer with the specified base\n    x = int(x, base)\n\n    # Convert the integer to binary\n    binary = bin(x)\n\n    # Return the binary value, omitting the first two characters ('0b')\n    return binary[2:]",
      "def number_to_binary(x: str, base: int):\n    \"\"\"Convert an input number, represented as a string of a specified base (integer) into its binary equivalent as a string.\n    The base can be either 8 (indicating octal), 10 (indicating decimal), or 16 (for hexadecimal).\n    Examples are provided below for better understanding:\n    >>> number_to_binary('8', 16) => '1000'\n    >>> number_to_binary('F', 16) => '1111'\n    >>> number_to_binary('1A', 16) => '11010'\n    >>> number_to_binary('10', 8) => '1000'\n    >>> number_to_binary('7', 8)  => '111'\n    >>> number_to_binary('12', 8) => '1010'\n    >>> number_to_binary('9', 10) => '1001'\n    >>> number_to_binary('15', 10) => '1111'\n    >>> number_to_binary('26', 10) => '11010'\n    \"\"\"\n    #Convert the input to an integer with the specified base\n    x = int(x, base)\n\n    # Convert the integer to binary\n    binary = bin(x)\n\n    # Return the binary value, omitting the first two characters ('0b')\n    return binary[2:]",
      "def number_to_binary(x: str, base: int):\n    \"\"\"Convert a number from a specified base into its binary equivalent, both represented as strings. \"\"\"\n    if not isinstance(x, str):\n        raise ValueError(\"Input x must be a string.\")\n        \n    if not isinstance(base, int):\n        raise ValueError(\"Input base must be an integer.\")\n    \n    if base not in (8, 10, 16):\n        raise ValueError(\"Base must be 8 (octal), 10 (decimal), or 16 (hexadecimal).\")\n        \n    # convert to integer in the specific base, then convert to binary,\n    # slice the '0b' prefix of binary representation\n    binary = bin(int(x, base))[2:]\n    return binary",
      "def number_to_binary(x: str, base: int):\n    \"\"\"\n    Convert an input number, represented as a string, of a specified base (integer) into its binary equivalent. Also handle the conversion of negative numbers and non-integer numbers into their binary equivalents. \n    The function should support base 8 (octal), base 10 (decimal),  base 16 (hexadecimal), and base 2 (binary).\n    \"\"\"\n    \n    if x[0] == '-':\n        prefix = '-'\n        x = x[1:]\n    else:\n        prefix = ''\n    \n    if '.' in x:\n        integer_part, fractional_part = x.split('.')\n        \n        integer_part = int(integer_part, base)\n        fractional_part = int(fractional_part, base) / (base ** len(fractional_part))\n        \n        binary_integer_part = bin(integer_part)[2:]\n        binary_fractional_part = '.'\n        \n        while fractional_part > 0:\n            fractional_part *= 2\n            bit = int(fractional_part)\n            \n            if bit == 1:\n                fractional_part -= bit\n                binary_fractional_part += '1'\n            else:\n                binary_fractional_part += '0'\n                \n        return prefix + binary_integer_part + binary_fractional_part\n    else:\n        return prefix + bin(int(x, base))[2:]"
    ],
    "HumanEval/45": [
      "def triangle_area(a, h):\n    \"\"\"Given length of a side and height, return the triangle's area.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n    return 0.5*a*h   # Corrected formula",
      "def triangle_area(a, h):\n    \"\"\"Using side length and height, compute the triangle's area.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n\n    # step 1: validate input\n    if a <= 0 or h <= 0:\n        raise ValueError(\"Side length and height must be positive\")\n\n    # step 2: compute the area using the formula\n    area = 0.5 * a * h\n\n    return area",
      "def triangle_area(a, h):\n    \"\"\"\n    Utilizing input values representing the side length and height, \n    accurately calculate the triangle's area if inputs form a valid triangle.\n    It considers a and h as the base and height of a right triangle.\n    \n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n    # validation for non-positive inputs\n    if a <= 0 or h <= 0:\n        raise ValueError('Input values must be positive numbers.')\n        \n    # calculation of the triangle's area\n    return 0.5 * a * h",
      "def triangle_area(a, h):\n    \"\"\"Given length of a side and height, return the triangle's area.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n    # Data validation\n    if not isinstance(a, (int, float)) or not isinstance(h, (int, float)):\n        return \"Error: both side-length and height need to be numbers\"\n      \n    if a < 0 or h < 0:\n        return \"Error: side-length and height values can't be negative\"\n        \n    if a == 0 or h == 0:\n        return \"Error: side-length or height can't be zero\"\n\n    # Calculation\n    return 0.5 * a * h",
      "def triangle_area(a, h):\n    \"\"\"Utilizing input values representing the side length (a) and height (h), accurately calculate the triangle's area.\"\"\"\n    area = 0.5 * a * h\n    return area"
    ],
    "HumanEval/46": [
      "def fibfib(n: int, memo = {}):\n    \"\"\"\n    This function exemplifies the FibFib sequence, a reflection of the Fibonacci sequence but subject to this distinctive set of regulations:\n    - fibfib(0) == 0\n    - fibfib(1) == 0\n    - fibfib(2) == 1\n    - fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3) where n > 2\n    - fibfib(n) = fibfib(n+3) - fibfib(n+2) - fibfib(n+1) where n < 0\n\n    The application of dynamic programming and memoization techniques is imperative for optimizing the function.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    >>> fibfib(-1)\n    1\n    >>> fibfib(-5)\n    -4\n    \"\"\"\n    if n in memo:\n        return memo[n]\n\n    if n == 0:\n        result = 0\n    elif n == 1:\n        result = 0\n    elif n == 2:\n        result = 1\n    elif n > 2:\n        result = fibfib(n-1, memo) + fibfib(n-2, memo) + fibfib(n-3, memo)\n    else: # where n < 0\n        result = fibfib(n+3, memo) - fibfib(n+2, memo) - fibfib(n+1, memo)\n\n    memo[n] = result\n    return result",
      "def fibfib(n: int, memo = {}):\n    \"\"\"\n    This function exemplifies the FibFib sequence, a reflection of the Fibonacci sequence but subject to this distinctive set of regulations:\n    - fibfib(0) == 0\n    - fibfib(1) == 0\n    - fibfib(2) == 1\n    - fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) where n > 2\n    - fibfib(n) == fibfib(n+3) - fibfib(n+2) - fibfib(n+1) where n < 0\n\n    The application of dynamic programming and memoization techniques is imperative for optimizing the function.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    >>> fibfib(-1)\n    1\n    >>> fibfib(-5)\n    -4\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        result = 0\n    elif n == 1:\n        result = 0\n    elif n == 2:\n        result = 1\n    elif n > 2:\n        result = fibfib(n-1, memo) + fibfib(n-2, memo) + fibfib(n-3, memo)\n    else: # when n < 0\n        result = fibfib(n+3, memo) - fibfib(n+2, memo) - fibfib(n+1, memo)\n        \n    memo[n] = result\n    return result",
      "def fibfib(n: int, memo = {}):\n    \"\"\"\n    This function encapsulates the FibFib sequence that mirrors the Fibonacci sequence but with this specific set of rules:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) where n > 2\n    fibfib(n) == fibfib(n+3) - fibfib(n+2) - fibfib(n+1) where n < 0\n\n    Applying dynamic programming and memoization is essential for function optimization.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(6)\n    2\n    >>> fibfib(-1)\n    1\n    >>> fibfib(-5)\n    -4\n    \"\"\"\n    if n in memo:\n        return memo[n]\n\n    if n >= 0:\n        if n < 3:\n            result = n % 2\n        else:\n            result = fibfib(n - 1, memo) + fibfib(n - 2, memo) + fibfib(n - 3, memo)\n    else:\n        result = fibfib(n + 3, memo) - fibfib(n + 2, memo) - fibfib(n + 1, memo)\n\n    # Store the result in the memo dictionary for future reference\n    memo[n] = result\n\n    return result",
      "def fibfib(n: int, memo = {}):\n    \"\"\"\n    This function encapsulates the FibFib sequence that mirrors the Fibonacci sequence but with this specific set of rules:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) where n > 2\n    fibfib(n) == fibfib(n+3) - fibfib(n+2) - fibfib(n+1) where n < 0\n\n    Applying dynamic programming and memoization is essential for function optimization.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    >>> fibfib(-1)\n    1\n    >>> fibfib(-5)\n    -4\n    \"\"\"\n    if n in memo:\n        return memo[n]\n\n    if n >= 0:\n        if n < 3:\n            result = n % 2\n        else:\n            result = fibfib(n - 1, memo) + fibfib(n - 2, memo) + fibfib(n - 3, memo)\n    else:\n        result = fibfib(n + 3, memo) - fibfib(n + 2, memo) - fibfib(n + 1, memo)\n\n    # store the result in the memo dictionary for future reference\n    memo[n] = result\n\n    return result",
      "def fibfib(n: int):\n    \"\"\"\n    The FibFib sequence mirrors the Fibonacci sequence, as defined below:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) for n > 2\n    fibfib(n) == fibfib(n+3) - fibfib(n+2) - fibfib(n+1) for n < 0\n\n    Implement dynamic programming and memoization for function optimization.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    elif n > 2:\n        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n    elif n < 0:\n        return fibfib(n+3) - fibfib(n+2) - fibfib(n+1)"
    ],
    "HumanEval/47": [
      "def median(l: list):\n    \"\"\"Return median of elements in the list l without sorting it or using built-in functions.\n    Handles tuples with even and odd number of elements, and duplicates.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    >>> median([1, 2, 2, 4, 5])\n    2\n    \"\"\"\n    length = len(l)\n    if length % 2 == 0:\n        return (quickSelect(l, 0, length - 1, length // 2 - 1) + quickSelect(l, 0, length - 1, length // 2)) / 2\n    else:\n        return quickSelect(l, 0, length - 1, length // 2)",
      "def median(l: list):\n    \"\"\"Return median of elements in the list without sorting it or using built-in functions.\n    Handles tuples with even and odd number of elements, and duplicates.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    >>> median((1, 2, 2, 4, 5))\n    2\n    \"\"\"\n    length = len(l)\n    if length % 2 == 0:\n        return (quickSelect(l, 0, length - 1, length // 2 - 1) + quickSelect(l, 0, length - 1, length // 2)) / 2\n    else:\n        return quickSelect(l, 0, length - 1, length // 2)",
      "def median(l: list):\n    \"\"\"\n    Computation of the median of a set of numeric elements encompassed within a specified list, bypassing the need for any sorting layer. \n    Accommodates tuples of varying counts, either odd or even, coupling with negative integers and floating-point figures.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    >>> median([2.5, -3.7, 5.1])\n    2.5\n    \"\"\"\n    length = len(l) \n    mid = length // 2\n\n    if length % 2 == 1:\n        return _quickSelect(l, mid, 0, length - 1)\n    else:\n        return (_quickSelect(l, mid - 1, 0, length - 1) + _quickSelect(l, mid, 0, length - 1)) / 2.0  ",
      "def median(l: list) -> float:\n    \"\"\"\n    Return median of elements in the list l without sorting or using built-in functions.\n\n    Handles collections including negative numbers and floating point numbers \n    using the QuickSelect algorithm for linear time complexity.\n\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    10\n    \"\"\"\n    num_list = l if isinstance(l, list) else list(l)\n    length = len(num_list)\n\n    if length % 2 == 1:\n        # If list has odd number of elements, the median is the middle element\n        return quick_select(num_list, length // 2)\n    else:\n        # If list has even number of elements, the median is the average of the two middle elements\n        return 0.5 * (quick_select(num_list, length // 2 - 1) + quick_select(num_list, length // 2))",
      "def median(l: list) -> float:\n    \"\"\"\n    Return median of elements in the list l without sorting or using built-in functions.\n\n    Handles collections including negative numbers and floating point numbers \n    using the QuickSelect algorithm for linear time complexity.\n\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    10\n    \"\"\"\n    num_list = l if isinstance(l, list) else list(l)\n    length = len(num_list)\n\n    if length % 2 == 1:\n        # If list has odd number of elements, the median is the middle element\n        return quick_select(num_list, length // 2)\n    else:\n        # If list has even number of elements, the median is the average of the two middle elements\n        return 0.5 * (quick_select(num_list, length // 2 - 1) + quick_select(num_list, length // 2))"
    ],
    "HumanEval/48": [
      "def is_palindrome(input_string):\n    \"\"\"Returns positive response for palindrome strings, negative response for non-palindrome strings.\n    >>> is_palindrome('racecar')\n    True\n    >>> is_palindrome('python')\n    False\n    >>> is_palindrome('madam')\n    True\n    >>> is_palindrome('civic')\n    True\n    >>> is_palindrome('hello')\n    False\n    >>> is_palindrome('wow')\n    True\n    \"\"\"\n    return input_string == input_string[::-1]",
      "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)",
      "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Test if given string is a palindrome, ignoring case and non-alphanumeric characters, using recursion \"\"\"\n    if l >= r:\n        return True\n    if not string[l].isalnum():\n        return is_palindrome(string, l + 1, r)\n    if not string[r].isalnum():\n        return is_palindrome(string, l, r - 1)\n    if string[l].lower() != string[r].lower():\n        return False\n    return is_palindrome(string, l + 1, r - 1)",
      "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Validate if delivered string emulates a palindrome using an iterative mechanism \"\"\"\n    if (l >= r):\n        return True\n    else:\n        return (string[l] == string[r]) and is_palindrome(string, l + 1, r - 1)",
      "def is_palindrome(string: str, l: int, r: int) -> bool:\n    \"\"\" Validate if delivered string emulates a palindrome using an iterative mechanism \"\"\"\n    if (l >= r):\n        return True\n    else:\n        return (string[l] == string[r]) and is_palindrome(string, l + 1, r - 1)"
    ],
    "HumanEval/49": [
      "def is_prime(n):\n    \"\"\"Manifests as true for integers that are prime, reveals false for those that aren't.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    \n    if n in (2, 3):\n        return True\n    if n == 1 or n % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True",
      "def is_prime(n):\n    \"\"\"Returns true for prime integers, false for non-prime integers.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n\n    if n == 2:\n        return True\n\n    if n % 2 == 0:\n        return False\n\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n\n    return True",
      "def is_prime(n):\n    \"\"\"Returns true for prime integers, false for non-prime integers.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n\n    # Start from 3 and step through odd numbers up to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True",
      "def LCM(a: int, b: int, c: int):\n    \"\"\"\n    Compute LCM of a, b, and c.\n\n    Constraints: 1 <= a, b, c <= 10^9\n\n    >>> LCM(3, 5, 8)\n    120\n    >>> LCM(21, 14, 31)\n    9578\n    >>> LCM(7, 11, 25)\n    1925\n    >>> LCM(12, 15, 18)\n    180\n    >>> LCM(9, 3, 1)\n    9\n    \"\"\"\n    # Compute LCM of a, b, and c as LCM(a, LCM(b, c))\n    return a * b * c // math.gcd(a, math.gcd(b, c))",
      "def lcm(x: int, y: int, z: int) -> int:\n    \"\"\"\n    Ascertain the LCM of x, y, and z using a resource-efficient technique.\n\n    Constraints: 1 <= x, y, z <= 10^9\n\n    >>> lcm(4, 6, 8)\n    24\n    >>> lcm(21, 14, 7)\n    42\n    >>> lcm(10, 25, 5)\n    50\n    >>> lcm(12, 15, 3)\n    60\n    >>> lcm(9, 3, 1)\n    9\n    \"\"\"\n    lcm_two = (x * y) // gcd(x, y)\n    return (lcm_two * z) // gcd(lcm_two, z)"
    ],
    "HumanEval/50": [
      "def encode_semantic_diff(s: str) -> str:\n    \"\"\"\n    Returns encoded string by shifting every character \n    based on its Unicode difference with its next character.\n    \"\"\"\n    encoded = []\n    \n    for i in range(len(s) - 1):\n        diff = ord(s[i]) - ord(s[i + 1])\n        encoded.append(chr((ord(s[i]) + diff) % 256))\n    encoded.append(s[-1])  # add the last character (unchanged)\n\n    return ''.join(encoded)",
      "def decode_semantic_diff(s: str) -> str:\n    \"\"\"\n    Accepts a string that is encoded with the above encode_semantic_diff function and returns the decoded string, capably handling unique characters, empty spaces, and special symbols.\n    \"\"\"\n    decoded = [s[0]]  # first character remains unchanged\n\n    for i in range(1,len(s)):\n        prev_diff = ord(s[i - 1]) - ord(decoded[-1])\n        decoded.append(chr((ord(s[i]) - prev_diff) % 256))\n\n    return ''.join(decoded)",
      "def rot13(message):\n    encoded = \"\"\n\n    for ch in message:\n        if ch.isalpha():\n            if (ch.isupper()):\n                encoded += chr((ord(ch) - 65 + 13) % 26 + 65)\n            else:\n                encoded += chr((ord(ch) - 97 + 13) % 26 + 97)\n        else: \n            encoded += ch\n\n    return encoded",
      "def decode_cyclic(s: str, shift: int = 3) -> str:\n    \"\"\"Decode a string that has been encoded using a Caesar Cipher. The shift varies based on the character position.\"\"\"\n    result = \"\"\n    for i in range(len(s)):\n        char = s[i]\n        if char.isalpha():\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            result += chr((ord(char) - ascii_offset - (i % shift) + 26) % 26 + ascii_offset)\n        else:\n            result += chr((ord(char) - (i % shift) + 256) % 256)\n    return result",
      "def decode_cyclic(s: str):\n    \"\"\"\n    Accepts a string encoded with the cyclic_encode function and returns the decoded string. \n    \"\"\"\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"
    ],
    "HumanEval/51": [
      "def remove_vowels(string):\n    if len(string) == 0:\n        return \"\"\n\n    first_char = string[0]\n\n    if first_char.lower() in \"aeiou\":\n        return remove_vowels(string[1:])\n    else:\n        return remove_vowels(string[1:]) + first_char",
      "def remove_vowels(strings):\n    '''This function takes a list of strings and returns a new list without any vowels.'''\n    vowels = ('a', 'e', 'i', 'o', 'u')\n    return [s.lower().replace(c, '') for s in strings for c in vowels]",
      "def remove_vowels(string):\n    vowels = 'aeiou'\n    for i in string.lower():\n        if i in vowels:\n            string = string.replace(i, \"\")\n    return string",
      "def remove_vowels(string):\n    \"\"\"Remove all the vowels from the given string.\"\"\"\n    return re.sub(r'[aeiouAEIOU]', '', string)",
      "def remove_vowels(string):\n    return re.sub(r'[aeiouAEIOU]', '', string)"
    ],
    "HumanEval/52": [
      "def below_threshold(l: list, t: int) -> bool:\n    \"\"\"Return True if every integer in list l is below the threshold t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for i in l:\n        if i >= t:\n            return False\n    return True",
      "def below_threshold(l, t):\n    \"\"\"\n    Provide a boolean return stating whether every integer in a collection labelled 'l' is less than a specific, predetermined limit 't'.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    return all(e < t for e in l)",
      "def below_threshold(l: list, t: int) -> bool:\n    \"\"\"\n    Indicates if all integers in list l do not exceed the specified threshold t.\n    If the element is not an integer type, it will be ignored.\n    \"\"\"\n    for item in l:\n        if isinstance(item, int) and item > t:\n            return False\n    return True",
      "def above_limit(l: list, lim: int) -> bool:\n    \"\"\"Return True if every integer in list l is above the limit lim.\n    >>> above_limit([10, 20, 30, 50], 5)\n    True\n    >>> above_limit([1, 5, 8, 15], 10)\n    False\n    \"\"\"\n    return all(i > lim for i in l)",
      "def below_threshold(l: list, t: int):\n    \"\"\"The function determines if all integers contained in list l are within the specified threshold t. A situation where the list may include non-integer data types is also accounted for.\n    \"\"\"\n    for i in l:\n        if isinstance(i, int) and i > t:\n            return False\n    return True"
    ],
    "HumanEval/53": [
      "def lcm(x: int, y: int, z: int):\n  \"\"\" \n  LCM determination function for x, y and z. \n\n  Constraints: x, y, z are prime numbers; 1 <= x, y, z <= 10^9\n\n  >>> lcm(3, 5, 7)\n  105\n  >>> lcm(2, 11, 13)\n  286\n  >>> lcm(2, 23, 89)\n  4094\n  >>> lcm(5, 7, 11)\n  385\n  >>> lcm(31, 37, 41)\n  46957\n  \"\"\"\n  temp_lcm = (x * y) // gcd(x, y)\n  return (temp_lcm * z) // gcd(temp_lcm, z)",
      "def lowest_common_multiple(x: int, y: int) -> int:\n    \"\"\" Return the lowest common multiple of two integers x and y\n    >>> lowest_common_multiple(3, 5)\n    15\n    >>> lowest_common_multiple(25, 15)\n    75\n    \"\"\"\n    return (x * y) // math.gcd(x, y)",
      "def smallest_common_multiple(x: int, y: int) -> int:\n    \"\"\" Return the least common multiple of the two integers x and y\n    >>> smallest_common_multiple(5, 3)\n    15\n    >>> smallest_common_multiple(15, 25)\n    75\n    \"\"\"\n    return (x*y) // math.gcd(x, y)",
      "def lcm(x: int, y: int, z: int) -> int:\n    \"\"\"\n    Ascertain the LCM of x, y, and z using a resource-efficient technique.\n\n    Constraints: 1 <= x, y, z <= 10^9\n\n    >>> lcm(4, 6, 8)\n    24\n    >>> lcm(21, 14, 7)\n    42\n    >>> lcm(10, 25, 5)\n    50\n    >>> lcm(12, 15, 3)\n    60\n    >>> lcm(9, 3, 1)\n    9\n    \"\"\"\n    lcm_two = (x * y) // gcd(x, y)\n    return (lcm_two * z) // gcd(lcm_two, z)",
      "def calculate_lcm(x: int, y: int) -> int:\n    \"\"\" Return the LCM of two integers x and y\n    >>> calculate_lcm(3, 5)\n    15\n    >>> calculate_lcm(25, 15)\n    75\n    \"\"\"\n    if x == 0 or y == 0:  # Prevent zero division error\n        return 0\n    else:        \n        return abs(x * y) // math.gcd(x, y)"
    ],
    "HumanEval/54": [
      "def same_chars(s1, s2):\n    # Removes all the special characters and convert to lower case\n    s1 = re.sub(r'\\W+', '', s1).lower()\n    s2 = re.sub(r'\\W+', '', s2).lower()\n\n    # Sorts the strings and compare them\n    return sorted(s1) == sorted(s2)",
      "def custom_merge_strings(strings: Tuple[str, str]) -> str:\n    \"\"\" Merge two strings by alternately taking characters from each string and then reversing the merged string.\n    >>> custom_merge_strings('', '')\n    ''\n    >>> custom_merge_strings('a', 'b')\n    'ba'\n    >>> custom_merge_strings('abc', 'def')\n    'fedcba'\n    \"\"\"\n    s1, s2 = strings\n    result = []\n\n    for c1, c2 in zip(s1, s2):\n        result.extend([c1, c2])\n\n    if len(s1) > len(s2):\n        result.extend(s1[len(s2):])\n    else:\n        result.extend(s2[len(s1):])\n\n    return ''.join(result[::-1])",
      "def pattern_check(l: list, even: bool = False) -> bool:\n    \"\"\"\n    Returns True if the list follows an alternated pattern (number, letter, number, and so on) heeding the even requirement and a supplementary condition - the list should not carry any even numbers when 'even' parameter is True. \n    If even is True, numbers in the list must be even; otherwise, they may be any.\n    \n    >>> pattern_check([1, 'a', 3, 'b', 5])\n    True\n    >>> pattern_check([2, 'b', 4, 'd', 6], even=True)\n    True\n    >>> pattern_check([1, 'c', 2, 'd', 3])\n    False\n    >>> pattern_check([2, 'c', 4, 'd', 6], even=False)\n    False\n    \"\"\"\n    for i in range(len(l)):\n        if i % 2 == 0:\n            if even:\n                if not(isinstance(l[i], int) and l[i] % 2 == 0):\n                    return False\n            else:\n                if not isinstance(l[i], int):\n                    return False\n        elif not isinstance(l[i], str):\n            return False\n    return True",
      "def duplicate_detector(values: list[tuple[int, str]], show_duplicates: bool = False) -> bool:\n    \"\"\"Evaluate someone's series of logical access code operations, determining whether there are any duplicate entries. If there are, return True; if not, return False. Additionally, invent an optional show duplicates flag that, when on, allows the function to mark '1234' and '1234' [similar to '5678' and '5678'] as duplicates, thereby returning True if a duplicate entry is detected in any instance.\n\n    Argument list consists of tuples laid out as (Access Code, Operation).\n\n    Examples:\n    >>> duplicate_detector([(1234, 'ADD'), (5678, 'ADD'), (9101, 'DELETE')])\n    False\n    >>> duplicate_detector([(1234, 'ADD'), (5678, 'ADD'), (5678, 'DELETE'), (1234,'DELETE')])\n    True\n    >>> duplicate_detector([(1234, 'ADD'), (5678, 'ADD'), (5678, 'DELETE'), (1234, 'ADD')], True)\n    True\n    \"\"\"\n    seen_values = set()\n    duplicates = []\n\n    for value in values:\n        if value in seen_values:\n            duplicates.append(value)\n        else:\n            seen_values.add(value)\n\n    if show_duplicates and duplicates:\n        print('Duplicates: ', duplicates)\n\n    return bool(duplicates)",
      "def same_chars(str1, str2):\n    if len(str1) != len(str2):\n        return False\n    for i in range(len(str1)):\n        if str1[i] != str2[i]:\n            return False\n    return True"
    ],
    "HumanEval/55": [
      "def fibonacci_sequence(x: float):\n    \"\"\"Return the number at position 'x' in the Fibonacci sequence, which can be both a positive or negative floating-point number. Assume that 'x' is not 0 and not a prime number. Structure an efficient method of identifying the fibonacci sequence.\n    >>> fibonacci_sequence(9.1)\n    34\n    >>> fibonacci_sequence(20.9)\n    6765\n    >>> fibonacci_sequence(-9.1)\n    34\n    \"\"\"\n    pos = round(abs(x)) # convert x to an absolute rounded int as fibonacci sequence calculations are generally for positive integers\n\n    if pos == 0:\n        return 0\n    else:\n        fib = [0,1]\n        for i in range(2, pos + 1):\n            fib.append(fib[-1] + fib[-2])\n    return fib[pos]",
      "def prime_fibonacci(start = 1, end = 100):\n    if end < start or start < 0 or end < 0:\n        print(\"Invalid range\")\n        return\n    for fib in fibonacci_numbers():\n        if fib > end:\n            break\n        if fib >= start:\n            if is_prime(fib):\n                print(fib)",
      "def fib_sequence(n):\n    if isinstance(n, int) and n >= 0:\n        fib = [0, 1]\n        for i in range(2,n):\n            fib.append(fib[-1] + fib[-2])\n        return fib\n    else:\n        raise ValueError(\"Invalid input. Please enter a non-negative integer.\")",
      "def prime_fib_product(start, end):\n  if start > end or start < 0:\n    return \"Invalid Range\"\n  product = 1\n  i = 0\n  while fib(i) <= end:\n    if fib(i) >= start and is_prime(fib(i)):\n      product *= fib(i)\n    i += 1\n  return product",
      "def fib(n): \n    if n == 1 or n == 2: \n        return 1\n    elif n > 2: \n        return fib(n-1) + fib(n-2)"
    ],
    "HumanEval/56": [
      "def correct_bracketing(brackets):\n    s = []\n    for bracket in brackets:\n        if bracket == '<':\n            s.append('<')\n        else:\n            if not s:\n                return False\n            else:\n                s.pop()\n    if not s:\n        return True\n    else:\n        return False",
      "def is_valid_brackets(sequence: str) -> bool:\n    stack = []\n    for c in sequence:\n        if c in \"({[<\":\n            stack.append(c)\n        elif c in \")}]>\":\n            if not stack:\n                return False  # More closing brackets than opening brackets\n            opening = stack.pop()\n            if (c == \")\" and opening != \"(\") or (c == \"}\" and opening != \"{\") or (c == \"]\" and opening != \"[\") or (c == \">\" and opening != \"<\"):\n                return False  # Mismatched opening and closing brackets\n    return not stack  # True if stack is empty, False if there are unmatched opening brackets",
      "def correct_bracketing(brackets):\n    stack = []\n    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        elif bracket == ')':\n            if not stack or stack.pop() != '(':\n                return False\n    return not stack",
      "def is_valid_brackets(s: str) -> bool:\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n    for char in s:\n        if char in mapping.values():  # If the character is an opening bracket\n            stack.append(char)\n        else:  # If the character is a closing bracket\n            if not stack or stack.pop() != mapping[char]:\n                return False  # Unmatched closing bracket or no opening bracket to match\n    return not stack  # Return True if stack is empty (all brackets matched and closed properly)",
      "def check_prime(n):\n    \"\"\"Augments performance via a seldom-used optimization technique, providing true for prime numbers and false for non-prime numbers.\n    >>> check_prime(6)\n    False\n    >>> check_prime(101)\n    True\n    >>> check_prime(11)\n    True\n    >>> check_prime(13441)\n    False\n    >>> check_prime(61)\n    True\n    >>> check_prime(4)\n    False\n    >>> check_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True"
    ],
    "HumanEval/57": [
      "def monotonic(l: list, strict: bool = False):\n    \"\"\"\n    This function determines if the sequence of elements in the list is either monotonically increasing or decreasing, considering the strictness criterion put in place.\n    If the strict parameter is assigned to be True, consecutive elements are not allowed to be identical; however, if it's False, they may be the same.\n\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 1, 0, -10], strict=True)\n    False\n    >>> monotonic([1, 1, 1, 1], strict=False)\n    True\n    \"\"\"\n    # Initialize flags for increasing and decreasing\n    increasing = decreasing = True\n\n    # Loop through the list to check sequence\n    for i in range(len(l) - 1):\n        # If strict is True\n        if strict:\n            if l[i] <= l[i + 1]:\n                increasing = False\n            elif l[i] >= l[i + 1]:\n                decreasing = False\n        # If strict is False\n        else:\n            if l[i] < l[i + 1]:\n                increasing = False\n            elif l[i] > l[i + 1]:\n                decreasing = False\n\n    # If list is not increasing and not decreasing, return False\n    if not increasing and not decreasing:\n        return False\n\n    # If the function has not returned yet, it means the list is either increasing or decreasing.\n    return True",
      "def monotonic(l: list, strict: bool = False):\n    \"\"\"\n    This function determines if the sequence of elements in the list is either monotonically increasing or decreasing, considering the strictness criterion put in place.\n    If the strict parameter is assigned to be True, consecutive elements are not allowed to be identical; however, if it's False, they may be the same.\n\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 1, 0, -10], strict=True)\n    False\n    >>> monotonic([1, 1, 1, 1], strict=False)\n    True\n    \"\"\"\n    # Initialize flags for increasing and decreasing\n    increasing = decreasing = True\n\n    # Loop through the list to check sequence\n    for i in range(len(l) - 1):\n        # If strict is True\n        if strict:\n            if l[i] > l[i + 1]:\n                increasing = False\n            elif l[i] < l[i + 1]:\n                decreasing = False\n        # If strict is False\n        else:\n            if l[i] >= l[i + 1]:\n                increasing = False\n            elif l[i] <= l[i + 1]:\n                decreasing = False\n\n        # If list is not increasing and not decreasing, return False\n        if not increasing and not decreasing:\n            return False\n\n    # If the function has not returned yet, it means the list is either increasing or decreasing.\n    return True",
      "def below_threshold(l: list, t: int) -> bool:\n    \"\"\"Return True if every integer in list l is below the threshold t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for i in l:\n        if i >= t:\n            return False\n    return True",
      "def monotonic(l: list, strict: bool = False) -> bool:\n    \"\"\"\n    Check if array is monotonically increasing or decreasing with strictness option, and without prime numbers.\n    \"\"\"\n    if any(is_prime(i) for i in l):\n        return False\n\n    if len(l) < 2: \n        return True\n    \n    if strict: \n        return all(x < y for x, y in zip(l, l[1:])) or all(x > y for x, y in zip(l, l[1:]))\n    else: \n        return all(x <= y for x, y in zip(l, l[1:])) or all(x >= y for x, y in zip(l, l[1:]))",
      "def complex_median(l: Union[list, set]):\n    \"\"\"\n    Return median including complex numbers of elements in the list or set l without sorting or using built-in functions.\n    Handles even and odd number of elements, duplicates and returns 'None' for non-list or non-set inputs.\n    >>> complex_median([3, 1, 2, 4, 5])\n    3\n    >>> complex_median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    >>> complex_median([1, 2, 2, 4, 5])\n    2\n    >>> complex_median([(1+2j), (3+4j), (5+6j), (7+8j), (9+10j)])\n    (5+6j)\n    >>> complex_median(\"12345\")\n    None\n    \"\"\"\n\n    if not isinstance(l, (list, set)):\n        return None\n        \n    l = list(l)\n\n    if len(l) == 0:\n        return None\n        \n    # sort the list\n    l.sort(key=complex_sort)\n\n    middle_index = len(l) // 2\n\n    # if length is even\n    if len(l) % 2 == 0:\n        return (l[middle_index - 1] + l[middle_index]) / 2\n    else:\n        return l[middle_index]"
    ],
    "HumanEval/58": [
      "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Authoritatively yield manually ordered, non-repetitive intersecting elements for two lists. \n    This function is constructed to handle integer arrays including negative integers, without depending \n    on inherent Python list functionalities. The function returns a well-ordered list eliminating any duplicates.\n    If one of the lists is empty, the function returns an empty list. \n    \n    :param l1: The first list of integers.\n    :type l1: list\n    :param l2: The second list of integers.\n    :type l2: list\n    :returns: A list containing ordered intersecting elements from both lists, without duplicates.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    >>> common([-2, -3, 0, 2, 5], [-5, 2, 0, -3])\n    [-3, 0, 2]\n    >>> common([-2, -3, 0, 2, 5], [])\n    []\n    \"\"\"\n    common_set = set()\n    ordered_set = set()\n    \n    # Traverse through lists and add common elements to common_set\n    for num in l1:\n        if num in l2 and num not in common_set:\n            common_set.add(num)\n            \n    # Traverse through common_set and add elements into ordered_set in sorted order.\n    # This step ensures the elimination of duplicate elements and correct ordering.\n    for num in sorted(common_set):\n        ordered_set.add(num)\n    \n    return list(ordered_set)",
      "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Authoritatively yield manually ordered, non-repetitive intersecting elements for two lists.\n    This function is constructed to handle integer arrays including negative integers,without depending \n    on inherent Python list functionalities. The function returns a well-ordered list eliminating any duplicates.\n    If one of the lists is empty, the function returns an empty list. \n\n    :param l1: The first list of integers.\n    :type l1: list\n    :param l2: The second list of integers.\n    :type l2: list\n    :returns: A list containing ordered intersecting elements from both lists, without duplicates.\n\n    >>> common([1, 4, 3, 34, 86, 2, 5], [5, 7, 1, 8, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    >>> common([-2, -3, 0, 2, 5], [-5, 2, 0, -3])\n    [-3, 0, 2]\n    >>> common([-2, -3, 0, 2, 5], [])\n    []\n    \"\"\"\n    common_set = set()\n    ordered_set = set()\n\n    # Traverse through lists and add common elements to common_set\n    for num in l1:\n        if num in l2 and num not in common_set:\n            common_set.add(num)\n\n    # Traverse through common_set and add elements into ordered_set in sorted order.\n    # This step ensures the elimination of duplicate elements and correct ordering.\n    for num in sorted(common_set):\n        ordered_set.add(num)\n\n    return list(ordered_set)",
      "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))",
      "def get_positive_and_sort(l: list):\n    \"\"\"Return only positive numbers in the list, sorted in ascending order.\n    >>> get_positive_and_sort([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive_and_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n\n    return sorted([num for num in l if num > 0])",
      "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n\n    result = []\n    for num in l:\n        if num > 0:\n          result.append(num)\n    return result"
    ],
    "HumanEval/59": [
      "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Provide the most significant prime divisor of a positive or negative 'n'. \n    It is to be assumed that abs(n) is greater than 1 and not prime in nature. \n    Look to exploit the process by scrutinizing only the odd factors subsequent to 2.\n\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    >>> largest_prime_factor(-13195)\n    29\n    \"\"\"\n    # Handling the negative input\n    n = abs(n)\n\n    # The largest prime factor of n\n    largest_prime = 2\n\n    # Factor out all 2's that divide n\n    while n % 2 == 0:\n        n = n // 2\n\n    # n must be odd at this point, thus a skip of 2 can be used\n    i = 3\n    while i * i <= n:\n        # While i divides n, factor i and divide n\n        while n % i == 0:\n            largest_prime = i\n            n = n // i\n        i += 2\n\n    # This condition is to handle the case when n is a prime number\n    # greater than 2\n    if n > 2:\n        largest_prime = n\n\n    return largest_prime",
      "def largest_prime_factor(n: int) -> int:\n    \"\"\"Provide the most significant prime divisor of a positive or negative 'n'. It is to be assumed that abs(n) is greater than 1 and not prime in nature. \n    Look to expedite the process by scrutinizing only the odd factors subsequent to 2.\n\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    >>> largest_prime_factor(-13195)\n    29\n    \"\"\"\n    # Handling the negative input\n    n = abs(n)\n\n    # The largest prime factor of n\n    largest_prime = 2\n\n    # Factor out all 2's that divide n\n    while n % 2 == 0:\n        n = n // 2\n\n    # n must be odd at this point, thus a skip of 2 can be used\n    i = 3\n    while i * i <= n:\n        # While i divides n , factor i and divide n\n        while n % i == 0:\n            largest_prime = i\n            n = n // i\n        i = i + 2\n\n    # This condition is to handle the case when n is a prime number\n    # greater than 2\n    if n > 2:\n        largest_prime = n\n\n    return largest_prime",
      "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime divisor of the integer 'n',\n    Both positive and negative integers are handled\n    Prime factor identification is optimized by checking divisors up to sqrt(n)\n    \"\"\"\n    n = abs(n)  # ensures handling of negative integers\n    factor = 2  # smallest prime factor\n    while factor * factor <= n:\n        if n % factor:\n            factor += 1\n        else:\n            n //= factor\n    return n",
      "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of a positive or negative n. Assume abs(n) > 1 and is not prime.\n    Optimize the procedure by only scrutinizing odd factors succeeding 2.\n    \"\"\"\n    n = abs(n)\n    last_factor = 1\n    # get rid of 2's\n    while n % 2 == 0:\n        last_factor = 2\n        n = n / 2\n    factor = 3\n    max_factor = n ** 0.5\n    while n > 1 and factor <= max_factor:\n        if n % factor == 0:\n            n = n / factor\n            last_factor = factor\n            while n % factor == 0:\n                n = n / factor\n            max_factor = n ** 0.5\n        factor += 2\n    if n == 1:\n        return last_factor\n    else:\n        return n",
      "def prime_sum_and_largest_factor(n):\n    primes = [i for i in range(n, 0, -1) if is_prime(i)]\n    primes_sum = sum(primes)\n    largest_prime_factor = next((x for x in primes if n % x == 0), None)\n\n    print(\"Prime numbers:\", primes)\n    print(\"Sum of prime numbers:\", primes_sum)\n    print(\"Largest prime factor:\", largest_prime_factor)"
    ],
    "HumanEval/60": [
      "def sum_to_n(n):\n    if n == 1:\n        return 1\n    else:\n        return n + sum_to_n(n-1)",
      "def sum_to_n(n):\n    total = 0\n    for i in range(1, n+1):\n        total += i\n    return total",
      "def sum_to_n(n):\n\n    # Edge cases\n    if n < 0: \n        return 0\n    if n == 0:\n        return 0\n\n    # Binomial sum formula \n    return (n * (n+1)) / 2 ",
      "def sum_to_n(n):\n    # Initialize the sum\n    total = 0\n\n    # The loop continues as long as n is greater than 0\n    while n > 0:\n        total += n\n        n -= 1\n\n        # A sophisticated loop termination command\n        if total > 10000:  # Supposing we want to stop the loop when the sum exceeds 10000\n            print(\"The sum exceeded the limit!\")\n            break\n\n    # Return the total sum\n    return total",
      "def square(n: int) -> int:\n    \"\"\"\n    This function accepts an integer n and returns the square of n.\n\n    >>> square(2)\n    4\n    >>> square(3)\n    9\n    >>> square(4)\n    16\n    \"\"\"\n    return n * n"
    ],
    "HumanEval/61": [
      "def correct_bracketing(brackets):\n    stack = []\n    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        elif bracket == ')':\n            if not stack or stack.pop() != '(':\n                return False\n    return not stack",
      "def correct_bracketing(brackets):\n    s = []\n    for bracket in brackets:\n        if bracket == '<':\n            s.append('<')\n        else:\n            if not s:\n                return False\n            else:\n                s.pop()\n    if not s:\n        return True\n    else:\n        return False",
      "def is_valid_brackets(sequence: str) -> bool:\n    stack = []\n    for c in sequence:\n        if c in \"({[<\":\n            stack.append(c)\n        elif c in \")}]>\":\n            if not stack:\n                return False  # More closing brackets than opening brackets\n            opening = stack.pop()\n            if (c == \")\" and opening != \"(\") or (c == \"}\" and opening != \"{\") or (c == \"]\" and opening != \"[\") or (c == \">\" and opening != \"<\"):\n                return False  # Mismatched opening and closing brackets\n    return not stack  # True if stack is empty, False if there are unmatched opening brackets",
      "def is_valid_brackets(s: str) -> bool:\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n    for char in s:\n        if char in mapping.values():  # If the character is an opening bracket\n            stack.append(char)\n        else:  # If the character is a closing bracket\n            if not stack or stack.pop() != mapping[char]:\n                return False  # Unmatched closing bracket or no opening bracket to match\n    return not stack  # Return True if stack is empty (all brackets matched and closed properly)",
      "def isolate_balanced_bracket_groups(bracket_sequence: str, manage_syntax_errors: bool) -> List[str]:\n    stack = []  # Stack to keep track of brackets level\n    result = []  # Resultant list of groups\n    curr_group = \"\"  # Current group of brackets\n\n    for bracket in bracket_sequence:\n        # Ignore white spaces\n        if bracket.isspace():\n            continue\n        # Push to stack if it's an opening bracket\n        elif bracket == '(':\n            if curr_group:\n                stack.append(curr_group)\n                curr_group = \"\"\n            stack.append(bracket)\n        # Pop from stack if it's a closing bracket\n        elif bracket == ')':\n            if not stack or stack[-1] != '(':\n                if manage_syntax_errors:\n                    print(\"Syntax error: unbalanced closing bracket.\")\n                    continue\n                else:\n                    raise SyntaxError(\"Unbalanced closing bracket.\")\n            else:\n                stack.pop()\n                curr_group += bracket\n                if not stack or stack[-1] != '(':\n                    # If the stack becomes empty or the top of stack is not opening bracket,\n                    # It means we have a balance group of brackets\n                    result.append(curr_group)\n                    curr_group = \"\"\n                    if stack:\n                        curr_group = stack.pop()\n        else:\n            raise ValueError(\"Invalid character: expected brackets or white space.\")\n    # If there are still remaining brackets in the stack, then it's an error\n    if stack:\n        if manage_syntax_errors:\n            print(\"Syntax error: unbalanced opening bracket.\")\n        else:\n            raise SyntaxError(\"Unbalanced opening bracket.\")\n\n    return result"
    ],
    "HumanEval/62": [
      "def derivative_and_integral(xs, C):\n    \"\"\"\n    Given xs: coefficients of a polynomial: xs[0] + xs[1] * x + xs[2] * x^2 t....\n    Return derivative and integral of this polynomial, including constant C and remove any trailing zeros.\n    Ensure this works for edge cases.\n\n    >>> derivative_and_integral([3, 1, 2, 4, 5], 2)\n    ([1, 4, 12, 20], [2, 3, 0.5, 0.6666666666666666, 1])\n    >>> derivative_and_integral([1, 2, 3], 4)\n    ([2, 6], [4, 1, 1, 1])\n    \"\"\"\n\n    derivative = []\n    integral = [C]\n    \n    for i in range(len(xs)):\n        if i != 0:\n            derivative.append(i * xs[i])\n            integral.append(xs[i-1] / i)\n        else:\n            # The derivative of a constant is 0\n            derivative.append(0)\n            integral.append(xs[0])\n\n    # All the trailing zeros are removed from the derivative.\n    while derivative and derivative[-1] == 0:\n        derivative.pop()\n\n    return derivative, integral",
      "def derivative_and_integral(xs: list, C: int):\n    \"\"\"\n    Violations: (xs = coefficients of a polynomial.     xs[0] + xs[1] * x + xs[2] * x^2 + ....)\n    Return derivative and integral of this polynomial, include constant C and remove any trailing zeros. Ensure this works for edge cases.\n    >>> derivative_and_integral([3, 1, 2, 4, 5], 2)\n    ([1, 4, 12, 20], [2, 3, 0.5, 0.6666666666666666, 1, 1])\n    >>> derivative_and_integral([1, 2, 3], 4)\n    ([2, 6], [4, 1, 1, 1])\n    \"\"\"\n\n    derivative = []\n    integral = [C]\n\n    for i in range(len(xs)):\n        if i != 0:\n            derivative.append(i * xs[i])\n            integral.append(xs[i-1] / i)\n        else:\n            # The derivative of a constant is 0\n            derivative.append(0)\n    integral.append(xs[-1] / len(xs))         \n    # All the trailing zeros are removed from the derivative.    \n    while derivative and derivative[-1] == 0:\n        derivative.pop()\n\n    return derivative, integral",
      "def derivative_and_integral(xs: list, C: int):\n    \"\"\"\n    xs = coefficients of a polynomial (xs[0] + xs[1] * x + xs[2] * x^2 + ....)\n    This function returns the derivative and integral of the given polynomial, includes the constant C, and removes trailing zeros.\n\n    >>> derivative_and_integral([3, 1, 2, 4, 5], 2)\n    ([1, 4, 12, 20], [2.0, 3.0, 0.5, 0.5, 0.8, 1.0])\n    >>> derivative_and_integral([1, 2, 3], 4)\n    ([2, 6], [4.0, 1.0, 1.0, 1.0])\n    \"\"\"\n    derivative = []\n    integral = [C]\n\n    for i in range(len(xs)):\n        if i != 0:\n            derivative.append(i * xs[i])\n        if i+1 != 0:\n            integral.append(xs[i] / (i+1))\n\n    # Remove trailing zeros\n    while integral[-1] == 0:\n        integral = integral[:-1] \n    while derivative and derivative[-1] == 0:\n        derivative = derivative[:-1]\n  \n    return derivative, integral",
      "def derivative_and_integral(xs: list, C: int):\n  \"\"\"\n  xs - coefficients of a polynomial (xs[0] + xs[1]*x + xs[2]*x^2 + ...)\n  This function returns the derivative and integral of the given polynomial, includes the constant C, and removes trailing zeros.\n\n  >>> derivative_and_integral([3, 1, 2, 4, 5], 2)\n  ([6, 4, 12, 20], [2.0, 3.0, 0.5, 0.5, 0.8, 1.0])\n  >>> derivative_and_integral([1, 2, 3], 4)\n  ([2, 6], [4.0, 1.0, 1.0, 1.0])\n  \"\"\"\n  derivative = []\n  integral = [C]\n\n  for i in range(len(xs)):\n    if i != 0:\n      derivative.append(i * xs[i])\n    if i+1 != 0:\n      integral.append(xs[i] / (i+1))\n\n  # Remove trailing zeros\n  while integral[-1] == 0:\n    integral = integral[:-1]\n  while derivative and derivative[-1] == 0:\n    derivative = derivative[:-1]\n\n  return derivative, integral",
      "def compute_derivative_integral(xs: list, C: int):\n    \"\"\"\n    Assumptions broken: (xs = coefficients of a polynomial in order: xs[0] + xs[1] * x + xs[2] * x^2 + ....)\n    Compute both the derivative and integral of the given polynomial, incorporate constant C and remove any surplus zeros. Ensure correctness with edge cases.\n    \"\"\"\n    if not xs:\n        return [], [C]\n    \n    derivative = []\n    integral = [C]\n\n    for i in range(len(xs)):\n        if i > 0:  derivative.append(i * xs[i])\n        if i > 0:  integral.append(xs[i-1] /(i))\n        \n    integral.append(xs[-1] / len(xs))\n\n    while derivative and derivative[-1] == 0:\n        derivative.pop()\n        \n    while len(integral) > 1 and integral[-1] == 0:  # retain the constant term even if it's zero.\n        integral.pop()\n\n    return derivative, integral"
    ],
    "HumanEval/63": [
      "def fibfib(n: int):\n    \"\"\"\n    The FibFib sequence mirrors the Fibonacci sequence, as defined below:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) for n > 2\n    fibfib(n) == fibfib(n+3) - fibfib(n+2) - fibfib(n+1) for n < 0\n\n    Implement dynamic programming and memoization for function optimization.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    elif n > 2:\n        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n    elif n < 0:\n        return fibfib(n+3) - fibfib(n+2) - fibfib(n+1)",
      "def fibfib(n: int, memo = {}):\n    \"\"\"\n    This function exemplifies the FibFib sequence, a reflection of the Fibonacci sequence but subject to this distinctive set of regulations:\n    - fibfib(0) == 0\n    - fibfib(1) == 0\n    - fibfib(2) == 1\n    - fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) where n > 2\n    - fibfib(n) == fibfib(n+3) - fibfib(n+2) - fibfib(n+1) where n < 0\n\n    The application of dynamic programming and memoization techniques is imperative for optimizing the function.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    >>> fibfib(-1)\n    1\n    >>> fibfib(-5)\n    -4\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        result = 0\n    elif n == 1:\n        result = 0\n    elif n == 2:\n        result = 1\n    elif n > 2:\n        result = fibfib(n-1, memo) + fibfib(n-2, memo) + fibfib(n-3, memo)\n    else: # when n < 0\n        result = fibfib(n+3, memo) - fibfib(n+2, memo) - fibfib(n+1, memo)\n        \n    memo[n] = result\n    return result",
      "def fibfib(n: int, memo = {}):\n    \"\"\"\n    This function exemplifies the FibFib sequence, a reflection of the Fibonacci sequence but subject to this distinctive set of regulations:\n    - fibfib(0) == 0\n    - fibfib(1) == 0\n    - fibfib(2) == 1\n    - fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3) where n > 2\n    - fibfib(n) = fibfib(n+3) - fibfib(n+2) - fibfib(n+1) where n < 0\n\n    The application of dynamic programming and memoization techniques is imperative for optimizing the function.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    >>> fibfib(-1)\n    1\n    >>> fibfib(-5)\n    -4\n    \"\"\"\n    if n in memo:\n        return memo[n]\n\n    if n == 0:\n        result = 0\n    elif n == 1:\n        result = 0\n    elif n == 2:\n        result = 1\n    elif n > 2:\n        result = fibfib(n-1, memo) + fibfib(n-2, memo) + fibfib(n-3, memo)\n    else: # where n < 0\n        result = fibfib(n+3, memo) - fibfib(n+2, memo) - fibfib(n+1, memo)\n\n    memo[n] = result\n    return result",
      "def fibfib(n: int, memo = {}):\n    \"\"\"\n    This function encapsulates the FibFib sequence that mirrors the Fibonacci sequence but with this specific set of rules:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) where n > 2\n    fibfib(n) == fibfib(n+3) - fibfib(n+2) - fibfib(n+1) where n < 0\n\n    Applying dynamic programming and memoization is essential for function optimization.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    >>> fibfib(-1)\n    1\n    >>> fibfib(-5)\n    -4\n    \"\"\"\n    if n in memo:\n        return memo[n]\n\n    if n >= 0:\n        if n < 3:\n            result = n % 2\n        else:\n            result = fibfib(n - 1, memo) + fibfib(n - 2, memo) + fibfib(n - 3, memo)\n    else:\n        result = fibfib(n + 3, memo) - fibfib(n + 2, memo) - fibfib(n + 1, memo)\n\n    # store the result in the memo dictionary for future reference\n    memo[n] = result\n\n    return result",
      "def fibfib(n: int, memo = {}):\n    \"\"\"\n    This function encapsulates the FibFib sequence that mirrors the Fibonacci sequence but with this specific set of rules:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) where n > 2\n    fibfib(n) == fibfib(n+3) - fibfib(n+2) - fibfib(n+1) where n < 0\n\n    Applying dynamic programming and memoization is essential for function optimization.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(6)\n    2\n    >>> fibfib(-1)\n    1\n    >>> fibfib(-5)\n    -4\n    \"\"\"\n    if n in memo:\n        return memo[n]\n\n    if n >= 0:\n        if n < 3:\n            result = n % 2\n        else:\n            result = fibfib(n - 1, memo) + fibfib(n - 2, memo) + fibfib(n - 3, memo)\n    else:\n        result = fibfib(n + 3, memo) - fibfib(n + 2, memo) - fibfib(n + 1, memo)\n\n    # Store the result in the memo dictionary for future reference\n    memo[n] = result\n\n    return result"
    ],
    "HumanEval/64": [
      "def vowels_count(s):\n    \"\"\"\n    This function, named as vowels_count, \n    takes a string representing a word as an argument and \n    returns the total number of all vowels it contains.\n    The vowels considered here are 'a', 'e', 'i', 'o', 'u', and 'y' if it appears at the end of the word.\n    The function ignores case sensitivity and carefully handles unusual characters within the input string.\n\n    Test Cases:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"\u00e9xampl\u00eb\")\n    3\n    \"\"\"\n    \n    # Checking for empty string\n    if not s:\n        return 0\n\n    s = s.lower()  # convert string in lower case to remove case sensitivity\n    pattern = re.compile(r'[aeiou]|y$')  # pattern to match vowels and y at the end\n\n    return len(pattern.findall(s))  # return count of matched vowels ",
      "def vowels_count(s):\n    \"\"\"Compose a function 'vowels_count', accepting a string representing\n    a word as input, returning the number of vowels in the string.\n    Vowels, in this case, are 'a', 'e', 'i', 'o', 'u', and 'y' ONLY when\n    found at the end of the input word. Ignore case and include special\n    characters, numbers, blank spaces, and empty strings within the input word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDy\")\n    3\n    >>> vowels_count(\"\u00e9xampl\u00eb 42\")\n    4\n    \"\"\"\n    count = 0;\n    if s == '':\n         return count;\n    s = s.lower()\n\n    for char in s:\n        if char == 'a' or char == 'e' or char == 'i' or char == 'o' or char == 'u':\n            count += 1\n    if s[-1] == 'y':\n        count += 1\n\n    return count",
      "def vowels_count(s):\n    \"\"\"\n    Compose a function 'vowels_count', accepting a string representing\n    a word as input, returning the number of vowels in the string.\n    Vowels, in this case, are 'a', 'e', 'i', 'o', 'u', and 'y' ONLY when\n    found at the end of the input word. Ignore case and include special\n    characters, numbers, blank spaces, and empty strings within the input word,\n    \n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEUv\")\n    3\n    >>> vowels_count(\"example a2\")\n    4\n    \"\"\"\n    count = 0\n    if s == '':\n        return count\n    s = s.lower()\n\n    for char in s:\n        if char == 'a' or char == 'e' or char == 'i' or char == 'o' or char == 'u':\n            count += 1\n        if s[-1] == 'y':\n            count += 1\n\n    return count",
      "def vowels_count(s):\n    \"\"\"Design an operation termed vowels_count, which accepts a string symbolising\n    a term as input and generates the sum of vowels found in the string.\n    Vowels entail 'a', 'e', 'i', 'o', 'u', together with 'y' SOLELY when unveiled\n    at the closing of the provided term. Overlook the letter casing and consider\n    unique characters within the term.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"\u00e9xampl\u00eb\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    s = s.lower()\n    count = 0\n    for i in s:\n        if i in vowels:\n            count+=1\n    if s[-1] == 'y':\n        count+=1\n    return count",
      "def vowels_count(s):\n    \"\"\"\n    This function takes a string, disregards its case, and counts the number of vowels \n    it contains. The vowels are 'a', 'e', 'i', 'o', 'u', and 'y' if it is at the end of \n    the string. It also allows for unusual characters in the string.\n\n    Test Cases:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"\u00e9xampl\u00eb\")\n    3\n    \"\"\"\n\n    # The regular expression pattern matches all vowels irrespective of case and 'y' when it occurs \n    # at the end of the string. Other unusual characters are also taken care of.\n    pattern = r'[aeiou]|[yY]$'\n    \n    # The flags argument is used to enable various special features and syntax variations.\n    # re.IGNORECASE performs case-insensitive matching; expressions like [A-Z] will match lowercase letters, too.\n    matches = re.findall(pattern, s, re.IGNORECASE)\n    \n    return len(matches)"
    ],
    "HumanEval/65": [
      "def circularShift(x, shift):\n    # Initialize 2 variables to store the length of 'x' and the result\n    lengthOfX, result = 0, 0\n    \n    # Store a copy of 'x' to calculate the length\n    tempX = x\n    while tempX != 0:\n        tempX //= 10\n        lengthOfX += 1\n\n    # If the shift is greater than the number of digits, return the digits reversed\n    if shift >= lengthOfX:\n        while x != 0:\n            result = result * 10 + x % 10\n            x //= 10\n    else:\n        rightPart = x % 10**shift\n        leftPart = x // 10**shift\n        multiplier = 10**(lengthOfX-shift)\n        result = rightPart * multiplier + leftPart\n    return result",
      "def encrypt_caesar(plaintext, shift):\n    \"\"\"\n    Encrypts a plaintext string using the Caesar cipher.\n\n    Args:\n        plaintext: The plaintext to encrypt.\n        shift: The number of characters to shift by.\n\n    Returns:\n        The ciphertext.\n    \"\"\"\n    alphabet = string.ascii_lowercase\n    shifted_alphabet = alphabet[shift:] + alphabet[:shift] \n    table = str.maketrans(alphabet, shifted_alphabet) \n    ciphertext = plaintext.translate(table)\n    return ciphertext",
      "def circular_shift(matrix):\n    try:\n        # Convert input list to numpy array\n        arr = np.array(matrix)\n\n        # Check if the array is 2D\n        if arr.ndim != 2:\n            raise ValueError('Input matrix should be a 2D list.')\n\n        # Check if all sub-lists (rows) have the same number of elements (columns)\n        if len(set(map(len, arr))) != 1:\n            raise ValueError('All sub-lists (rows) should have the same number of elements (columns).')\n\n        # Perform circular shift on each row\n        shifted_rows = np.roll(arr, shift=-1, axis=1)\n\n        # Perform circular shift on the columns\n        shifted_matrix = np.roll(shifted_rows, shift=-1, axis=0)\n\n        # Return the shifted matrix as a nested list\n        return shifted_matrix.tolist()\n\n    except Exception as e:\n        # Logging the error\n        logging.error(\"An error occurred: %s\", str(e))",
      "def applyVerticalShift(image, mask, max_shift=0.05, p=0.5):\n    \"\"\"Apply random vertical shift to the input image based on the mask.\"\"\"\n    if np.random.rand() < p:  # Apply the shift with probability p\n        max_shift_pixels = int(max_shift * image.shape[0])\n        shift = np.random.choice(np.arange(-max_shift_pixels, max_shift_pixels+1))\n        shifted_image = np.roll(image, shift, axis=0) * mask  # Apply shift based on the mask\n        return shifted_image\n    else:\n        return image  # Return the original image if shift is not applied",
      "def base_10_to_base_12(num):\n    \"\"\"Convert a number from base 10 to base 12.\"\"\"\n    \n    # List of numbers for base 12\n    digits = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\"]\n    \n    # Initialise the result\n    result = \"\"\n    # Loop while the number is greater than 0\n    while num > 0:\n        # Find the remainder after dividing the number by 12\n        remainder = num % 12\n        # Divide the number by 12\n        num //= 12\n        # Add the remainder to the result\n        result = digits[remainder] + result\n    \n    return result"
    ],
    "HumanEval/66": [
      "def digitSum(m):\n    digitSum = 0\n    while m:\n        digitSum += m % 10\n        m //= 10\n    return digitSum",
      "def digitSum(n):\n    digitSum = 0\n    while n:\n        digitSum += n % 10\n        n //= 10\n    return digitSum",
      "def digitSum(n):\n    if n == 0: \n        return 0\n    else:\n        return (n % 10) + digitSum(int(n / 10))",
      "def primeWithPrimeDigitSum(lst):\n    maxPrime = 0\n    sumDigits = 0\n    for i in lst:\n      if isprime(i):\n        digit_sum = digitSum(i)\n        if isprime(digit_sum) and i > maxPrime:\n          maxPrime = i\n          sumDigits = digit_sum\n    if maxPrime == 0:\n      return None\n    else:\n      return (maxPrime, sumDigits)",
      "def primeWithPrimeDigitSum(lst):\n    maxPrime = 0\n    sumDigits = 0\n    for i in lst:\n        if isprime(i):\n            digit_sum = digitSum(i)\n            if isprime(digit_sum) and i > maxPrime:\n                maxPrime = i\n                sumDigits = digit_sum\n    if maxPrime == 0:\n        return None\n    else:\n        return (maxPrime, sumDigits)"
    ],
    "HumanEval/67": [
      "def fruit_distribution(s, n, fruits, max_quantity):\n    \"\"\"\n    You have a string list containing various fruit quantities such as \"apples\", \"oranges\", \"mangoes\", etc.\n    The format of the list will be: [\"X apples\", \"Y oranges\", \"Z mangoes\"...]\n    Given such a list, an integer representing the total number of fruits in the basket, another list with all possible fruits, \n    and an integer representing the maximum allowed quantity for each fruit, generate a dictionary showing the quantity of \n    each type of fruit not specified in the list and ensure the total distributed quantity of each fruit doesn't exceed \n    the maximum limit.\n\n    For example:\n    fruit_distribution([\"5 apples\", \"6 oranges\"], 19, [\"apples\", \"oranges\", \"mangoes\"], 10) -> {\"mangoes\": 8}\n\n    If the total distributed quantity of a fruit exceeds the maximum quantity, raise a ValueError.\n    \"\"\"\n    result = {}\n    total_specified = 0\n\n    for fruit in s:\n        quantity = int(fruit.split(\" \")[0])\n        total_specified += quantity\n\n    remaining_fruits = n - total_specified\n    for fruit in fruits:\n        if fruit not in s:\n            if remaining_fruits > max_quantity:\n                raise ValueError(\"Total quantity exceeds maximum allowed quantity for fruit type.\")\n            else:\n                result[fruit] = remaining_fruits\n\n    return result",
      "def fruit_distribution(s, n):\n    fruits = list(map(int, re.findall(r'\\d+', s)))\n    apples, oranges = fruits[0], fruits[1]\n    return n - apples - oranges",
      "def test_issue_30():\n    cases = [\n        (\"The value is: {}\", [(10, \"The value is: 10\"), (20, \"The value is: 20\")]),\n        (\"{} apples and {} oranges\", [(3,  \"3 apples and 5 oranges\"), (5, \"5 apples and 7 oranges\")]),\n        # Add more test cases as needed\n    ]\n\n    for case in cases:\n        val = case[0]\n        for fmt, expected in case[1:]:\n            actual = custom_format(fmt, val)\n            assert actual == expected",
      "def count_fruits(apples, oranges):\n    if apples < 0 or oranges < 0:\n        return \"Error: The counts cannot be negative.\"\n    \n    total_count = apples + oranges\n    \n    if total_count % 3 == 0:\n        return \"Error: The total count should not be divisible by 3.\"\n    \n    return total_count",
      "def fruit_distribution(s, n, fruits, servings, exp_dates):\n    \"\"\"\n    You will receive a list of strings representing the quantity of various fruits\n    in a basket (e.g., [\"X apples\", \"Y oranges\", \"Z mangoes\"...]).\n\n    You'll also receive a dictionary with the number of servings per fruit and another \n    dictionary with the fruits' expiration dates (format: YYYY-MM-DD).\n\n    Given these inputs, return a dictionary reflecting the quantity of servings \n    of each fruit not mentioned in the list and not expired yet.\n\n    Outcome must be a dictionary including only the fruits with a non-zero count of servings.\n    Some syntax or semantic errors may exist in the provided code.\n    \"\"\"\n\n    result = {}  # Initialized here but not being used.\n\n    today = datetime.date.today()  # Get today's date\n\n    not_in_fruit_basket = set(servings.keys()) - set(fruits)  # Fruits not in basket\n\n    # Try to update the servings for each fruit and catch errors\n    for fruit in servings.keys():\n        try:\n            servings_this_fruit = servings[fruit]\n            date_string = exp_dates[fruit]\n            fruit_exp_date = datetime.datetime.strptime(date_string, '%Y-%m-%d').date()\n\n            # Get fruits not in the basket and not expired yet\n            if (fruit not in fruits and fruit_exp_date >= today):\n                result[fruit] = servings_this_fruit\n        # If error caught, prints it and continues with the next fruit \n        except Exception as e:\n            print(f\"Error occurred with fruit {fruit}: {e}\")\n            continue\n\n    return result"
    ],
    "HumanEval/68": [
      "def heapify(array, index, heap_size):\n    smallest = index\n    left = 2 * index + 1\n    right = 2 * index + 2\n    if left < heap_size and array[left] < array[smallest]:\n        smallest = left\n    if right < heap_size and array[right] < array[smallest]:\n        smallest = right\n    if smallest != index:\n        array[index], array[smallest] = array[smallest], array[index]\n        heapify(array, smallest, heap_size)",
      "def heapify(array, index, heap_size):\n    smallest = index\n    left = 2 * index + 1\n    right = 2 * index + 2\n    if left < heap_size and array[left] < array[smallest]:\n        smallest = left\n    if right < heap_size and array[right] < array[smallest]:\n        smallest = right\n    if smallest != index:\n        array[index], array[smallest] = array[smallest], array[index]\n        heapify(array, smallest, heap_size)",
      "def strange_sort_list_bst(lst):\n    '''\n    This function should accept a list of integers and decimal numbers and return the list in a specific pattern, leveraging the principles of a binary search tree. The steps for this peculiar sorting pattern should be:\n    - Commence with the smallest number.\n    - Next, identify the highest value from the remaining elements.\n    - Then, ascertain the lowest value among the untouched output, and continue in this manner.\n    \n    Examples:\n    strange_sort_list_bst([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list_bst([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list_bst([]) == []\n    strange_sort_list_bst([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n    \n    # First, we will sort the list in ascending order.\n    lst.sort()\n\n    output = []\n\n    # Then, while lst is not empty, we will remove and append to output the smallest\n    # and largest element alternatively.\n    while lst:\n        output.append(lst.pop(0))  # smallest\n        if lst:\n            output.append(lst.pop(-1))  # largest\n\n    return output",
      "def strange_sort_list_bst(lst):\n    '''\n    This function should accept a list of integers and decimal_numbers and return the list in a specific pattern, leveraging the principles of a binary search tree. The steps to this peculiar_sorting pattern should be:\n    - Commence with the smallest number.\n    - Next, identify the highest value from the remaining elements.\n    - Then, ascertain the lowest_value among the untouched output, and continue in this manner.\n\n    Examples:\n    strange_sort_list_bst([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list_bst([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list_bst([]) == []\n    strange_sort_list_bst([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # First, we will sort the list in ascending_order.\n    lst.sort()\n\n    output = []\n\n    # Then, while lst is not empty, we will remove and append to output the smallest\n    # and largest element alternately.\n    while lst:\n        output.append(lst.pop(0))  # smallest\n        if lst:\n            output.append(lst.pop(-1))  # largest\n\n    return output",
      "def sift_down(arr, current, size):\n    while current < size:\n        smallest = current\n        left = 2 * current + 1\n        right = 2 * current + 2\n\n        # Compare with left child\n        if left < size and arr[left] < arr[smallest]:\n            smallest = left\n\n        # Compare with right child\n        if right < size and arr[right] < arr[smallest]:\n            smallest = right\n\n        # If the smallest is not the current node, swap and continue sift-down\n        if smallest != current:\n            arr[current], arr[smallest] = arr[smallest], arr[current]\n            current = smallest\n        else:\n            break"
    ],
    "HumanEval/69": [
      "def uncommon_elements(sequence):\n    '''\n    Design a function that accepts a non-empty list composed of positive integers and returns a list of distinct integers whose frequency surpasses half of the integer's numerical value. Here, 'frequency' denotes the number of times a specific integer appears within the list.\n    If no integers satisfy these conditions, the function should return an empty list.\n    Examples:\n        uncommon_elements([4, 1, 2, 2, 3, 1]) should yield [2, 3]\n        uncommon_elements([1, 2, 2, 3, 3, 3, 4, 4, 4]) should yield [2, 3, 4]\n        uncommon_elements([5, 5, 4, 4, 4]) should yield [4]\n    '''\n    from collections import Counter\n    count = Counter(sequence)\n    result = []\n    for num, freq in count.items():\n        if freq > num/2:\n            result.append(num)\n    return result",
      "def rolling_max(numbers1: List[int], numbers2: List[int]) -> Tuple[List[int], List[int]]:\n    \"\"\" From two given lists of integers, generate a list of rolling maximum element found until given moment \n    in the sequence and store them as maximum of each list.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2], [1, 4, 2, 4, 1, 5, 1])\n    ([1, 2, 3, 3, 3, 4, 4], [1, 4, 4, 4, 4, 5, 5])\n    \"\"\"\n    pass  # Your implementation here",
      "def strange_sort_list_bst(lst):\n    '''\n    This function should accept a list of integers and decimal_numbers and return the list in a specific pattern, leveraging the principles of a binary search tree. The steps to this peculiar_sorting pattern should be:\n    - Commence with the smallest number.\n    - Next, identify the highest value from the remaining elements.\n    - Then, ascertain the lowest_value among the untouched output, and continue in this manner.\n\n    Examples:\n    strange_sort_list_bst([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list_bst([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list_bst([]) == []\n    strange_sort_list_bst([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # First, we will sort the list in ascending_order.\n    lst.sort()\n\n    output = []\n\n    # Then, while lst is not empty, we will remove and append to output the smallest\n    # and largest element alternately.\n    while lst:\n        output.append(lst.pop(0))  # smallest\n        if lst:\n            output.append(lst.pop(-1))  # largest\n\n    return output",
      "def strange_sort_list_bst(lst):\n    '''\n    This function should accept a list of integers and decimal numbers and return the list in a specific pattern, leveraging the principles of a binary search tree. The steps for this peculiar sorting pattern should be:\n    - Commence with the smallest number.\n    - Next, identify the highest value from the remaining elements.\n    - Then, ascertain the lowest value among the untouched output, and continue in this manner.\n    \n    Examples:\n    strange_sort_list_bst([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list_bst([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list_bst([]) == []\n    strange_sort_list_bst([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n    \n    # First, we will sort the list in ascending order.\n    lst.sort()\n\n    output = []\n\n    # Then, while lst is not empty, we will remove and append to output the smallest\n    # and largest element alternatively.\n    while lst:\n        output.append(lst.pop(0))  # smallest\n        if lst:\n            output.append(lst.pop(-1))  # largest\n\n    return output",
      "def unique_BST_sort(lst):\n    '''\n    Upon a mixed assemblage of integers and real numbers, restore the list arrayed in a peculiar order employing Binary Search Tree (BST) tactic.\n    The arraying sequence should adhere to the following progression:\n    - Initiate with the least number.\n    - Subsequently recognize the apex numeric from the remaining.\n    - Proceed to decipher the least numerical not yet included from the remaining, and maintain this sequence.\n    \n    Demonstrations:\n    unique_BST_sort([1, 2, 3, 4]) == [1, 4, 2, 3]\n    unique_BST_sort([5, 5, 5, 5]) == [5, 5, 5, 5]\n    unique_BST_sort([]) == []\n    unique_BST_sort([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n    \n    # sort values in ascending order\n    lst.sort()\n    result = []\n    \n    while lst: \n        # Pop the smallest value and append it to the result list\n        result.append(lst.pop(0))\n        \n        # If there are values remaining, pop the largest value and append it to the result list\n        if lst:\n            result.append(lst.pop())\n            \n    return result"
    ],
    "HumanEval/70": [
      "def strange_sort_list_bst(lst):\n    '''\n    This function should accept a list of integers and decimal numbers and return the list in a specific pattern, leveraging the principles of a binary search tree. The steps for this peculiar sorting pattern should be:\n    - Commence with the smallest number.\n    - Next, identify the highest value from the remaining elements.\n    - Then, ascertain the lowest value among the untouched output, and continue in this manner.\n    \n    Examples:\n    strange_sort_list_bst([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list_bst([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list_bst([]) == []\n    strange_sort_list_bst([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n    \n    # First, we will sort the list in ascending order.\n    lst.sort()\n\n    output = []\n\n    # Then, while lst is not empty, we will remove and append to output the smallest\n    # and largest element alternatively.\n    while lst:\n        output.append(lst.pop(0))  # smallest\n        if lst:\n            output.append(lst.pop(-1))  # largest\n\n    return output",
      "def strange_sort_list_bst(lst):\n    '''\n    This function should accept a list of integers and decimal_numbers and return the list in a specific pattern, leveraging the principles of a binary search tree. The steps to this peculiar_sorting pattern should be:\n    - Commence with the smallest number.\n    - Next, identify the highest value from the remaining elements.\n    - Then, ascertain the lowest_value among the untouched output, and continue in this manner.\n\n    Examples:\n    strange_sort_list_bst([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list_bst([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list_bst([]) == []\n    strange_sort_list_bst([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # First, we will sort the list in ascending_order.\n    lst.sort()\n\n    output = []\n\n    # Then, while lst is not empty, we will remove and append to output the smallest\n    # and largest element alternately.\n    while lst:\n        output.append(lst.pop(0))  # smallest\n        if lst:\n            output.append(lst.pop(-1))  # largest\n\n    return output",
      "def hybrid_sort_list_heap(lst):\n    '''\n    Given a list of integers and decimals, use a heap sort combined with binary insertion sort to arrange the list in a special order. The ordering should start with the smallest value, then the largest, then the smallest of the remaining values not yet included in the output, and continue doing this until all elements are sorted.\n\n    Examples:\n    hybrid_sort_list_heap([1, 2, 3, 4]) == [1, 4, 2, 3]\n    hybrid_sort_list_heap([5, 5, 5, 5]) == [5, 5, 5, 5]\n    hybrid_sort_list_heap([]) == []\n    hybrid_sort_list_heap([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # Make input list to a heap\n    heapq.heapify(lst)\n\n    # If the size of the list is less than 10 use Binary Insertion Sort\n    if len(lst) < 10:\n        sorted_lst = binary_insertion_sort(lst)\n    else:\n        # Else use Heap Sort\n        sorted_lst = [heapq.heappop(lst) for _ in range(len(lst))]\n\n    # Create a resultant list as per special order\n    result = []\n    while sorted_lst:\n        result.append(sorted_lst.pop(0))  # pop the smallest\n        if sorted_lst:\n            result.append(sorted_lst.pop(-1))  # pop the largest\n\n    return result",
      "def hybrid_sort_list_heap(lst):\n    '''\n    Given a list of integers and decimals, use a heap sort combined \n    with binary insertion sort to arrange the list in a special order. \n    The ordering should start with the smallest value, then the largest, \n    then the smallest of the remaining values not yet included in the output, \n    and continue doing this until all elements are sorted.\n\n    Examples:\n    hybrid_sort_list_heap([1, 2, 3, 4]) == [1, 4, 2, 3]\n    hybrid_sort_list_heap([5, 5, 5, 5]) == [5, 5, 5, 5]\n    hybrid_sort_list_heap([]) == []\n    hybrid_sort_list_heap([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # Make input list to a heap\n    heapq.heapify(lst)\n\n    # If the size of the list is less than 10 use Binary Insertion Sort\n    if len(lst) < 10:\n        sorted_lst = binary_insertion_sort(lst)\n    else:\n        # Else use Heap Sort\n        sorted_lst = [heapq.heappop(lst) for _ in range(len(lst))]\n\n    # Create a resultant list as per special order\n    result = []\n    while sorted_lst:\n        result.append(sorted_lst.pop(0))  # pop the smallest\n        if sorted_lst:\n            result.append(sorted_lst.pop(-1))  # pop the largest\n\n    return result",
      "def unique_BST_sort(lst):\n    '''\n    Upon a mixed assemblage of integers and real numbers, restore the list arrayed in a peculiar order employing Binary Search Tree (BST) tactic.\n    The arraying sequence should adhere to the following progression:\n    - Initiate with the least number.\n    - Subsequently recognize the apex numeric from the remaining.\n    - Proceed to decipher the least numerical not yet included from the remaining, and maintain this sequence.\n    \n    Demonstrations:\n    unique_BST_sort([1, 2, 3, 4]) == [1, 4, 2, 3]\n    unique_BST_sort([5, 5, 5, 5]) == [5, 5, 5, 5]\n    unique_BST_sort([]) == []\n    unique_BST_sort([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n    \n    # sort values in ascending order\n    lst.sort()\n    result = []\n    \n    while lst: \n        # Pop the smallest value and append it to the result list\n        result.append(lst.pop(0))\n        \n        # If there are values remaining, pop the largest value and append it to the result list\n        if lst:\n            result.append(lst.pop())\n            \n    return result"
    ],
    "HumanEval/71": [
      "def triangle_area(side1, side2=None, side3=None):\n    \"\"\"\n    Given the sides of the triangle, compute the triangle's area.\n    For triangle_area(a) => a is the side of an equilateral triangle\n    For triangle_area(a, h) => a is the base and h is the height of isosceles triangle\n    For triangle_area(a, b, c) => a, b, c are the sides of the scalene triangle\n    \"\"\"\n    if side2 == None and side3 == None:\n        # equilateral triangle\n        # area = (sqrt(3)/4) * a^2\n        area = (math.sqrt(3) / 4) * pow(side1, 2)\n    elif side3 == None:\n        # isosceles triangle\n        # area = 1/2 * base * height\n        area = 0.5 * side1 * side2\n    else:\n        # scalene triangle\n        # from the sides, get the semi-perimeter (s = (a+b+c)/2)\n        # then plug it in Heron's formula: area = sqrt(s*(s-a)*(s-b)*(s-c))\n        # which gives the formula for the area of a triangle from its sides\n        semi_perimeter = (side1 + side2 + side3) / 2\n        area = math.sqrt(semi_perimeter * (semi_perimeter-side1) * (semi_perimeter-side2) * (semi_perimeter-side3))\n    \n    return area",
      "def triangle_area(side1, side2=None, side3=None):\n    \"\"\"\n    Given the sides of the triangle, compute the triangle's area.\n    For triangle_area(a) => a is the side of an equilateral triangle\n    For triangle_area(a, h) => a is the base and h is the height of isosceles triangle\n    For triangle_area(a, b, c) => a, b, c are the sides of the scalene triangle\n    \"\"\"\n    if side2 is None and side3 is None:\n        # equilateral triangle\n        # area = (sqrt(3)/4) * a^2\n        area = (math.sqrt(3) / 4) * pow(side1, 2)\n    elif side3 is None:\n        # isosceles triangle\n        # area = 1/2 * base * height\n        area = 0.5 * side1 * side2\n    else:\n        # scalene triangle\n        # from the sides, get the semi-perimeter (s = (a+b+c)/2)\n        # then plug it in Heron's formula: area = sqrt(s*(s-a)*(s-b)*(s-c))\n        # which gives the formula for the area of a triangle from its sides\n        semi_perimeter = (side1 + side2 + side3) / 2\n        area = math.sqrt(semi_perimeter * (semi_perimeter - side1) * (semi_perimeter - side2) * (semi_perimeter - side3))\n    \n    return area",
      "def triangle_area(a, b, c):\n    # Check to see if the sides are positive and create a valid triangle\n    if a <= 0 or b <= 0 or c <= 0:\n        print(\"Sides of a triangle must be positive.\")\n        return None\n    if a + b <= c or a + c <= b or b + c <= a:\n        print(\"The sum of any two sides of a triangle must exceed the third side.\")\n        return None\n\n    # Calculate the semi-perimeter\n    p = (a + b + c) / 2\n\n    # Calculate the area using Heron's formula\n    area = round(math.sqrt(p * (p - a) * (p - b) * (p - c)), 4)\n\n    # Check for minuscule area\n    if area < 0.0001:\n        return \"Warning: The area of the triangle is very small.\"\n\n    return area",
      "def validate_and_compute_area(a, b, c):\n    sides = sorted([a, b, c])\n    if sides[2] >= sides[0] + sides[1]: \n        # The triangle inequality theorem states that for any triangle, the sum of the lengths of any two sides must be greater than or equal to the length of the remaining side.\n        raise ValueError(\"The provided values do not form a valid triangle\")\n    \n    # Check the isosceles condition\n    if not (a == b or b == c or a == c):\n        raise ValueError(\"The provided values do not form an isosceles triangle\")\n\n    s = (a + b + c) / 2.0   # compute the semi perimeter\n    return math.sqrt(s * (s - a) * (s - b) * (s - c))",
      "def triangle_area(a, b, c):\n    \"\"\"Compute and return the area and the altitude of a triangle from its three side lengths\"\"\"\n    \n    # check if the sides can form a valid triangle\n    if a + b <= c or b + c <= a or a + c <= b:\n        return -1\n    \n    # check if the triangle is equilateral\n    if a == b == c:\n        return -1\n\n    # calculate semi-perimeter\n    s = (a + b + c) / 2\n\n    # calculate area using Heron's formula\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    area = round(area, 2)\n\n    # calculate altitude\n    # altitude = 2 * area / base\n    # assume c is the base for computing the altitude.\n    # for isosceles triangle, any side can be considered as base.\n    # for scalene triangle, the altitude varies with the chosen base.\n    altitude = 2 * area / c\n    altitude = round(altitude, 2)\n\n    return (area, altitude)"
    ],
    "HumanEval/72": [
      "def will_it_fly(q,w):\n    '''\n    The function's purpose is to discern q's flight potential, return True if achievable, and False if not. For q to fly, it must fulfil two prerequisites: it must be palindromic and the total weights of its elements should not go beyond the maximum acceptable weight w.\n\n    Implement the function with error handling mechanisms. It should return a \"Non-numeric input\" error if it receives a non-numeric input, and a \"Non-sequence input\" error if it receives a non-sequence input.\n\n    Examples:\n    will_it_fly([1, 2], 5) \u279e False \n\n    will_it_fly([3, 2, 3], 1) \u279e False\n\n    will_it_fly([3, 2, 3], 9) \u279e True\n\n    will_it_fly([3], 5) \u279e True\n    \n    Error Cases:\n    will_it_fly([\"a\",\"b\",\"c\"], 5) \u279e \"Non-numeric input\"\n    \n    will_it_fly(123, 5) \u279e \"Non-sequence input\"\n    '''\n    # Handle Non-sequence input error\n    if not isinstance(q, (list, tuple, str)):\n        return \"Non-sequence input\"\n    \n    for i in q:\n        # Handle Non-numeric input error\n        if not isinstance(i, (int, float)):\n            return \"Non-numeric input\"\n    \n    return is_palindrome(q) and sum(q) <= w",
      "def will_it_fly(q, w):\n    # Check if list q is palindrome by comparing it to its reverse.\n    if q == q[::-1]:\n        # If it is, check if sum of elements of q is less than or equal to w\n        if sum(q) <= w:\n            return True\n        else:\n            return False\n    else:\n        return False",
      "def will_it_fly(q, w, n):\n    # Check if the list is a palindrome.\n    if q != q[::-1]:\n        return False\n\n    # Check if the sum of numbers is less than or equal to w.\n    if sum(q) > w:\n        return False\n    \n    # Check if the size of unique smallest numbers is equal to n.\n    if len(set(sorted(q)[:n])) != n:\n        return False\n    \n    return True",
      "def will_it_fly(q, w):\n    q_len = len(q)\n    \n    # Check if the list is palindromic\n    for i in range(q_len // 2):\n        if q[i] != q[q_len - 1 - i]:\n            return False\n    \n    # Check if the sum of its elements is less than or equal to w\n    if sum(q) > w:\n        return False\n    \n    return True",
      "def will_it_fly(q, w):\n    # Check if list is palindrome\n    if q == q[::-1]:\n        # Check if sum is less than or equal to w\n        if sum(q) <= w:\n            return True\n    return False"
    ],
    "HumanEval/73": [
      "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n        1. Perform rightward shifting operation as required.\n        2. Swap at most three pair of balls.\n        3. After the operations, elements smaller than the first element in the array should be odd in number.\n\n    Return True, if the array could be sorted, otherwise False. \n\n    Examples:\n    move_three_balls([3, 4, 5, 1, 2, 6]) => True\n    move_three_balls([1, 3, 5, 4, 2, 6]) => True\n    move_three_balls([1, 2, 3, 5, 4, 6]) => True\n    move_three_balls([5, 4, 3, 1, 2, 6]) => False\n\n    \"\"\"\n    if not arr:\n        return True\n\n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False",
      "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n    1. Perform rightward shifting operation as required.\n    2. Swap at most three pair of balls.\n    3. After the operations, elements smaller than the first element in the array should be odd in number.\n    \n    Return True, if the array could be sorted; otherwise, False. \n    \n    Examples:\n    move_three_balls([5, 4, 5, 1, 2, 6]) -> True\n    move_three_balls([1, 3, 5, 4, 2, 6]) -> True\n    move_three_balls([1, 2, 3, 5, 4, 6]) -> True\n    move_three_balls([5, 4, 3, 1, 2, 6]) -> False\n    \"\"\"\n    \n    if not arr:\n        return True\n    \n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False",
      "def test_bubble_sort():\n    # Empty array\n    arr = []\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != []:\n        print(\"Error: Bubble Sort failed on empty array.\")\n\n    # Array with duplicate values\n    arr = [4, 3, 2, 2, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 2, 3, 4]:\n        print(\"Error: Bubble Sort failed on array with duplicate values.\")\n\n    # Sorted array in descending order\n    arr = [5, 4, 3, 2, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 3, 4, 5]:\n        print(\"Error: Bubble Sort failed on sorted array in descending order.\")\n\n    # Random unsorted array\n    arr = [5, 3, 2, 4, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 3, 4, 5]:\n        print(\"Error: Bubble Sort failed on random unsorted array.\")",
      "def sort_by_binary_len(arr):\n    \"\"\"\n    Reorders an array of strictly positive integers according to\n    the length of their binary representations, in increasing order.\n    In instances of overlapping binary lengths, the array uses\n    decimal numerical values as the basis for establishing order.\n\n    The output produced should conform to the examples provided:\n    >>> sort_by_binary_len([1, 31, 15, 2, 7]) == [1, 2, 7, 15, 31]\n    >>> sort_by_binary_len([14, 58, 39, 41, 61]) == [14, 39, 41, 58, 61]\n    >>> sort_by_binary_len([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n\n    # Sort the array based on binary length and then value\n    return sorted(arr, key = lambda x: (bin(x)[2:], x))",
      "def test_unique_elements():\n    # Test case 1: Empty array\n    assert unique_elements([]) == []\n\n    # Test case 2: Array with all elements being the same\n    assert unique_elements([5, 5, 5, 5, 5]) == [5]\n\n    # Test case 3: Array with mix of positive and negative integers\n    assert unique_elements([1, 2, 3, 4, 5, 4, 3, 2, 1, -1, -2, -3, -4, -5]) == [1, 2, 3, 4, 5, -1, -2, -3, -4, -5]\n\n    # Test case 4: Array with no repeated elements\n    assert unique_elements([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\n    print(\"All test cases pass\")"
    ],
    "HumanEval/74": [
      "def total_match(lst1, lst2, case_sensitive=False):\n    '''\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n    \n    The function also drop duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case_sensitive parameter to True.\n    \n    Should both iterables have an equal total character length, the function returns the first iterable.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    total_match(['hi world'], ['hi', ' w', 'or', 'ld']) \u279e ['hi', ' w', 'or', 'ld']\n    '''\n    import re\n\n    # Remove non-alphanumeric characters and possibly convert to lower case\n    lst1 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst1]\n    lst2 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst2]\n\n    # Eliminate duplicates, preserving the original order\n    lst1, lst2 = list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2))\n\n    # Determine which list has a less or equal total character count\n    return lst1 if sum(len(s) for s in lst1) <= sum(len(s) for s in lst2) else lst2",
      "def total_match(lst1, lst2, case_sensitive=False):\n    \"\"\"\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n\n    The function also drops duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case sensitive parameter to True.\n\n    Should both iterables have an equal total character length, the function returns the first iterable.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['HI', 'HI']) \u279e ['HI', 'HI']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'hi']) \u279e ['hi', 'hi']\n    total_match(['A'], ['1', '2', '3', '4', '5']) \u279e ['A']\n    total_match(['hi world'], ['hi', ' w', 'or', 'ld']) \u279e ['hi', ' w', 'or', 'ld']\n    \"\"\"\n\n    # Remove non-alphanumeric characters and possibly convert to lower case\n    lst1 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst1]\n    lst2 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst2]\n\n    # Eliminate duplicates, preserving the original order\n    lst1, lst2 = list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2))\n\n    # Determine which list has a less or equal total character count\n    return lst1 if sum(len(s) for s in lst1) <= sum(len(s) for s in lst2) else lst2",
      "def get_greeting():\n    current_time = datetime.datetime.now()\n    if current_time.hour < 12:\n        return random.choice(['Good morning', 'Hello', 'Hi there'])\n    elif 12 <= current_time.hour < 18:\n        return random.choice(['Good afternoon', 'Hello', 'Hi there'])\n    else:\n        return random.choice(['Good evening', 'Hello', 'Hi there'])",
      "def greeting_response(user_input):\n    greeting_inputs = ['hi', 'hello', 'hey', 'hola', 'greetings', 'wassup']\n    greeting_responses = ['Hello!', 'Hi there!', 'Hey!', 'Hi!', 'Hola!', 'Greetings!']\n    \n    for word in user_input.split():\n        if word.lower() in greeting_inputs:\n            return random.choice(greeting_responses)\n        \n    return None",
      "def greeting_response(user_input):\n    greeting_inputs = ['hi', 'hello', 'hey', 'hola', 'greetings', 'wassup']\n    greeting_responses = ['Hello!', 'Hi there!', 'Hey!', 'Hi!', 'Hola!', 'Greetings!']\n    \n    for word in user_input.split():\n        if word.lower() in greeting_inputs:\n            return random.choice(greeting_responses)\n        \n    return None"
    ],
    "HumanEval/75": [
      "def is_multiply_prime(n):\n    \"\"\"Check if a number is the product of four distinct prime numbers.\"\"\"\n    # Generate a list of primes smaller than square root of n\n    primes = list(primerange(2, int(n**0.5) + 1))\n\n    # Check all possible combinations of four primes\n    for combo in combinations(primes, 4):\n        if combo[0]*combo[1]*combo[2]*combo[3] == n:\n            return True\n\n    return False",
      "def is_multiply_prime(a):\n    \"\"\"\n    Improved function to check if the acquired numeric value stems \n    from the product of three distinct prime integers. \n    \"\"\"\n    primes = get_distinct_primes(a)\n    return len(primes) == 3",
      "def is_multiply_prime(a):\n    \"\"\"Return if the input number is the product of five distinct prime numbers.\"\"\"\n\n    # List of factors\n    factors = []\n\n    # Factorization\n    for i in sympy.primerange(2, 5001):\n        if a % i == 0:  # if i is a factor of a\n            while a % i == 0:  # while i is still a factor of a\n                a /= i  # divide a by i to \"remove\" this factor from a\n            factors.append(i)  # it's guaranteed that i is a prime number here\n            if len(factors) > 5:  # no need to try further, a has too many different prime factors\n                return False\n\n    return len(factors) == 5",
      "def is_multiple(n):\n    \"\"\"\n    Function to check if a given number is a multiple of 3 or 5.\n    \n    Parameters: \n    n (int): The given number to check.\n    \n    Returns: \n    bool: True if number is a multiple of 3 or 5, False otherwise.\n    \"\"\"\n    return n % 3 == 0 or n % 5 == 0",
      "def is_divisible_by_3_and_5(number):\n    \"\"\"This function checks whether a number is divisible by 3 and 5.\n\n    Parameters: \n        number (int): The number to be checked.\n\t\n    Returns: \n        True if the number is divisible by both 3 and 5, False otherwise.\n    \"\"\"\n    if (number % 3 == 0) and (number % 5 == 0):\n        return True\n    else:\n        return False"
    ],
    "HumanEval/76": [
      "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n        1. Perform rightward shifting operation as required.\n        2. Swap at most three pair of balls.\n        3. After the operations, elements smaller than the first element in the array should be odd in number.\n\n    Return True, if the array could be sorted, otherwise False. \n\n    Examples:\n    move_three_balls([3, 4, 5, 1, 2, 6]) => True\n    move_three_balls([1, 3, 5, 4, 2, 6]) => True\n    move_three_balls([1, 2, 3, 5, 4, 6]) => True\n    move_three_balls([5, 4, 3, 1, 2, 6]) => False\n\n    \"\"\"\n    if not arr:\n        return True\n\n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False",
      "def exponential_diff(l: list, k: int, x: int, strict: bool = False) -> bool:\n    \"\"\"\n    Check if the difference between every two successive elements\n    in the list is the k'th power of x. \n    If the option 'strict' is true, no two neighboring elements can be the same; \n    otherwise, they can be. \n    The function returns true only when the difference between every two \n    successive elements is k raised to the power of x.\n\n    >>> exponential_diff([1, 2, 4, 8], 2, 1)\n    True\n    >>> exponential_diff([1, 2, 4, 16], 2, 2)\n    False\n    >>> exponential_diff([1, 3, 6, 27], 3, 2)\n    False\n    >>> exponential_diff([1, 1, 1, 1], 0, 0, strict=True)\n    True\n    \"\"\"\n    last = l[0]\n    for el in l[1:]:\n        if strict and el == last:\n            return False\n        if el - last != x ** k:\n            return False\n        last = el\n    return True",
      "def exponential_diff(l: list, k: int, x: int, strict: bool = False) -> bool:\n  \"\"\"\n  Check if the difference between every two successive elements \n  in the list is the k'th power of x. \n  If the option 'strict' is True, no two neighboring elements can be the same; \n  otherwise, they can be. \n  The function returns True only when the difference between every two \n  successive elements is k raised to the power of x.\n\n  >>> exponential_diff([1, 2, 4, 8], 2, 1)\n  True\n  >>> exponential_diff([1, 2, 4, 16], 2, 2)\n  False\n  >>> exponential_diff([1, 3, 9, 27], 3, 2)\n  False\n  >>> exponential_diff([1, 1, 1, 1], 0, 0, strict=False)\n  True\n  \"\"\"\n  last = l[0]\n  for el in l[1:]:\n    if strict and el == last:\n      return False\n    if el - last != k ** x:\n      return False\n    last = el\n  return True",
      "def is_prime(n: int) -> bool:\n    \"\"\"Return True if n is a prime number, False otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n%2 == 0:  # Exclude the even numbers > 2\n        return False\n    for x in range(3, int(sqrt(n)) + 1, 2):\n        if n % x == 0:\n            return False\n    return True",
      "def miller_rabin(n, k=5):  # number of tests to run\n    if n == 2 or n == 3:\n        return True\n    if n <= 1 or n % 2 == 0:\n        return False\n    \n    # write (n - 1) as 2^r * d\n    r, d = 0, n - 1\n    while d % 2 == 0:\n        r += 1\n        d //= 2\n    \n    # run k tests\n    for _ in range(k):\n        a = random.randint(2, n - 1)\n        x = pow(a, d, n)\n        if x == 1 or x == n - 1:\n            continue\n        for _ in range(r - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                break\n        else:\n            return False\n    return True"
    ],
    "HumanEval/77": [
      "def Iscube(a):\n    a = abs(a)  # We are interested in the absolute value because cube root of both positive and negative numbers can be an integer.\n    root = round(a**(1/3)) # Calculate the cube root and round it to the nearest integer\n    return root**3 == a  # Return True if the cube of the nearest integer is equal to 'a'",
      "def check_if_prime(integer):\n    '''\n    This function takes an integer input and checks if it is a prime number or not.\n    '''\n    if integer > 1:\n        for i in range(2, integer):\n            if (integer % i) == 0:\n                return False\n        else:\n            return True\n    else:\n        return False",
      "def is_perfect_square(x):\n    \"\"\"Generates an affirmation for integers that are perfect squares, and a negation for integers that aren't.\n    >>> is_perfect_square(9)\n    True\n    >>> is_perfect_square(144)\n    True\n    >>> is_perfect_square(25)\n    True\n    >>> is_perfect_square(169)\n    True\n    >>> is_perfect_square(2)\n    False\n    >>> is_perfect_square(-9)\n    'Invalid input, please enter a positive integer.'\n    >>> is_perfect_square(0)\n    True\n    >>> is_perfect_square(1)\n    True\n    \"\"\"\n\n    if not isinstance(x, int) or x < 0:\n        return 'Invalid input, please enter a positive integer.'\n    \n    return int(x ** 0.5) ** 2 == x",
      "def is_prime(n: int) -> bool:\n    \"\"\"\n    Check if an input number is a prime number.\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(1)\n    False\n    >>> is_prime(0)\n    False\n    \"\"\"\n    if n == 0 or n == 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True",
      "def is_prime(n: int) -> bool:\n    \"\"\"\n    Check if an input number is a prime number.\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(1)\n    False\n    >>> is_prime(0)\n    False\n    \"\"\"\n    if n == 0 or n == 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"
    ],
    "HumanEval/78": [
      "def enhanced_solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are at even positions.    \n\n    Examples\n    enhanced_solution([5, 8, 7, 1]) => 5\n    enhanced_solution([3, 3, 3, 3, 3]) => 9\n    enhanced_solution([30, 13, 24, 321]) => 30\n    \"\"\"\n    return sum(num for i, num in enumerate(lst[::2]) if num % 2 == 1)",
      "def is_prime(number):\n    if not isinstance(number, int) or number <= 1:\n        raise ValueError(\"Invalid input: Number must be a positive integer.\")\n    \n    # Check for small prime numbers\n    small_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    if number in small_primes:\n        return True\n    \n    # Check for divisibility by small primes\n    for prime in small_primes:\n        if number % prime == 0:\n            return False\n    \n    # Run probabilistic primality test (Miller-Rabin)\n    k = 5  # Number of iterations for accuracy\n    d = number - 1\n    s = 0\n    while d % 2 == 0:\n        d //= 2\n        s += 1\n    \n    for _ in range(k):\n        a = random.randint(2, number - 1)\n        x = pow(a, d, number)\n        \n        if x == 1 or x == number - 1:\n            continue\n        \n        for _ in range(s - 1):\n            x = pow(x, 2, number)\n            \n            if x == number - 1:\n                break\n        else:\n            return False\n    \n    return True",
      "def is_hex_color(s):\n    if len(s) != 7 and len(s) != 4:\n        # A valid hexadecimal color starts with '#' and followed by 3 or 6 hexadecimal numbers, so the length should be 4 or 7\n        return False\n\n    if s[0] != \"#\":\n        # A valid hexadecimal color starts with '#'\n        return False\n\n    # Check if all the other characters are hexadecimal\n    hex_chars = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f'}\n    return all(c in hex_chars for c in s[1:])",
      "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n        1. Perform rightward shifting operation as required.\n        2. Swap at most three pair of balls.\n        3. After the operations, elements smaller than the first element in the array should be odd in number.\n\n    Return True, if the array could be sorted, otherwise False. \n\n    Examples:\n    move_three_balls([3, 4, 5, 1, 2, 6]) => True\n    move_three_balls([1, 3, 5, 4, 2, 6]) => True\n    move_three_balls([1, 2, 3, 5, 4, 6]) => True\n    move_three_balls([5, 4, 3, 1, 2, 6]) => False\n\n    \"\"\"\n    if not arr:\n        return True\n\n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False",
      "def print_prime_numbers(start, end):\n    if start < 0 or end < 0:\n        raise ValueError(\"Both start and end numbers should be non-negative.\")\n    if end < start:\n        raise ValueError(\"End number should be greater than or equal to start number.\")\n    prime_numbers = []\n    for num in range(start, end + 1):\n        if is_prime(num):\n            prime_numbers.append(num)\n    if prime_numbers:\n        print(\"Prime numbers between\", start, \"and\", end, \"are:\")\n        for prime in prime_numbers:\n            print(prime)\n    else:\n        print(\"There are no prime numbers between\", start, \"and\", end)"
    ],
    "HumanEval/79": [
      "def decimal_to_binary(n):\n    \"\"\"\n    Converts a decimal number to its binary representation.\n    \n    Args:\n        n (int): The decimal number to be converted.\n    \n    Returns:\n        str: The binary representation of the input decimal number.\n    \"\"\"\n    return bin(n).replace(\"0b\", \"\")",
      "def decimal_to_binary(num):\n    \"\"\"\n    This function will return a binary representation of a given decimal number.\n    \n    Parameters:\n    num: decimal number\n    \n    Returns:\n    binary representation of the number\n    \"\"\"\n    if num == 0:\n        return 0\n    \n    binary = \"\"\n    while (num > 0):\n        rem = num % 2\n        binary = str(rem) + binary\n        num = num//2\n    \n    return binary",
      "def find_index_of_first_occurrence(string, character):\n    '''\n    This function will find the index of the first occurrence of a given character in a string.\n\n    Args:\n        string (str): the string to be searched\n        character (str): the character to be searched for\n\n    Returns:\n        int: the index of the first occurrence of the character\n    '''\n    return string.find(character)",
      "def isPalindrome(string):\n    '''This function will return whether or not a string is a palindrome.'''\n\n    # Ensure that the input is a string and has at least one character\n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string.\")\n    if len(string) < 1:\n        raise ValueError(\"Input string must have at least one character.\")\n\n    # Ensure that the input string only contains alphabetic characters\n    if not string.isalpha():\n        raise ValueError(\"Input string must only contain alphabetic characters.\")\n\n    # Create a stack to store the characters in reverse order\n    stack = []\n\n    # Iterate through each character in the string and push it onto the stack\n    for char in string:\n        stack.append(char)\n\n    # Create a new string by popping each character from the stack\n    reversed_string = \"\"\n    while stack:\n        reversed_string += stack.pop()\n\n    # Compare the original string and the reversed string\n    return string == reversed_string",
      "def check_anagram_segments(text: str) -> bool:\n    \"\"\"\n    Given an input string, the function is intended to determine whether it is possible to \n    divide the string into two or more segments that are anagrams of one another. \n\n    Anagrams are words or phrases formed by reordering the letters of a different word or phrase, \n    typically using all the original letters exactly once.\n\n    The function counts the frequency of each unique character in the string and stores it in a dictionary. \n    If all frequencies are even number then the function returns True as the string can be divided into \n    two or more segments that are anagrams of one another. \n    \n    But if there is more than one character with an odd count frequency, then the function returns False\n    as it is not possible to divide the string into segments that are anagrams of one another. \n\n    Parameters:\n    text (str): The string to check for anagram segments\n\n    Returns:\n    bool: True if the string can be divided into anagram segments, False otherwise.\n\n    Examples:\n    \n    >>> check_anagram_samples('abcdefabcdegf')\n    True\n    >>> check_anagram_samples('helloworld')\n    False\n    \"\"\"\n\n    # count the frequency of each unique character in the string\n    frequency = {}\n    for char in text:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n\n    # count characters with odd count frequency\n    count_odd = sum(1 for count in frequency.values() if count % 2)\n\n    return count_odd <= 1"
    ],
    "HumanEval/80": [
      "def is_happy(s):\n    \"\"\"\n    You are assigned a string s.\n    Ascertain whether the string is happy or not.\n    A string is described as happy if it is at least 3 characters long, each consolidative set of 3 characters are individual, every unique character appears no less than twice, and no character appears thrice in a direct sequence.\n    Additionally, the string is happy if all character sets of 3 or more contains at least 1 vowel and the string should not start or end with the same character.\n\n    For instance:\n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => False\n    is_happy(aabb) => False\n    is_happy(adbbd) => True\n    is_happy(xyzz) => False\n    is_happy(aoa) => True\n    \"\"\"\n    from collections import Counter\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    if len(s) < 3 or s[0] == s[-1]:\n        return False\n    counter = Counter(s)\n    for k, v in counter.items():\n        if v < 2 or v > 2:\n            return False\n    for i in range(len(s)-2):\n        if len(set(s[i:i+3])) != 3 or len(set(s[i:i+3]).intersection(vowels)) < 1:\n            return False\n    return True",
      "def is_happy(s):\n    \"\"\"\n    You are assigned a string s.\n    Ascertain whether the string is happy or not.\n    A string is described as happy if it is at least 3 characters long, each consecutive set of 3 characters are individual, \n    every unique character appears no less than twice, and no characters appears thrice in a direct sequence.\n    Additionally, the string is happy if all character sets of 3 or more contains at least 1 vowel \n    and the string should not start or end with the same character.\n\n    For instance:\n    is_happy(4) => False\n    is_happy(aa) => False\n    is_happy(abc) => False\n    is_happy(aabb) -> False\n    is_happy(aabba) -> True\n    is_happy(kyzz) -> False\n    is_happy(aba) => True\n    \"\"\"\n    from collections import Counter\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    if len(s) < 3 or s[0] == s[-1]:\n        return False\n    counter_ = Counter(s)\n    for x, u in counter_.items():\n        if u < 2 or u > 2:\n            return False\n    for i in range(len(s) - 2):\n        if len(set(s[i:i+3])) != 3 or len(set(s[i:i+3]).intersection(vowels)) < 1:\n            return False\n    return True",
      "def is_happy(s):\n    \"\"\"You are given a string s.\n    Determine if the string is happy or not.\n    A string is happy if its length is at least 3, each set of 3 sequential characters are unique,\n    every distinct character occurs at least twice, no character appears three times in a row,\n    and there is no number in the string.\"\"\"\n\n    # If length of string is less than 3 or there's a digit in the string, it's not happy\n    if len(s) < 3 or any(char.isdigit() for char in s):\n        return False\n\n    # Create a dictionary to keep count of characters\n    count_dict = {}\n    for ch in s:\n        if ch in count_dict:\n            count_dict[ch] += 1\n        else:\n            count_dict[ch] = 1\n\n    # If any character occurs only once or more than twice in a row, string is not happy\n    for ch in count_dict:\n        if count_dict[ch] < 2 or s.count(ch*3) > 0:\n            return False\n\n    # If there's any three sequential characters are not unique, string is not happy\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] == s[i + 2]:\n            return False\n\n    # String is happy\n    return True",
      "def is_happy(s):\n    \"\"\"You are given a string s.\n    Determine if the string is happy or not.\n    A string is happy if its length is at least 3, each set of 3 sequential characters are unique,\n    every distinct character occurs at least twice, no character appears three times in a row,\n    and there is no number in the string.\"\"\"\n    \n    # If length of string is less than 3 or there's a digit in the string, it's not happy\n    if len(s) < 3 or any(char.isdigit() for char in s):\n        return False\n\n    # Create a dictionary to keep count of characters\n    count_dict = {}\n    for ch in s: \n        if ch in count_dict: \n            count_dict[ch] += 1\n        else: \n            count_dict[ch] = 1\n\n    # If any character occurs only once or more than twice in a row, string is not happy\n    for ch in count_dict: \n        if count_dict[ch] < 2 or s.count(ch*3) > 0: \n            return False\n        \n    # If there's any three sequential characters are not unique, string is not happy\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] == s[i + 2]:\n            return False\n\n    # String is happy\n    return True",
      "def is_happy(s):\n    \"\"\" This function takes a string s as input and returns True if it represents happiness and False otherwise.\"\"\"\n    \n    # Check if the string contains only alphanumeric characters\n    if not s.isalnum():\n        return \"Invalid input string! Only alphanumeric characters are allowed.\"\n    \n    n = len(s)\n    \n    # The string must have at least a length of 3 for it to be happy\n    if n < 3: return False\n    \n    # Check that every group of three successive characters are distinct\n    for i in range(n-2):\n        if len(set(s[i:i+3])) != 3:\n            return False\n    \n    # Check that each discrete character appears not less than twice\n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    if min(char_count.values()) < 2:\n        return False\n     \n    # Check that no character appears three times consecutively\n    if re.search(r'(.)\\1\\1', s):\n        return False\n    \n    return True"
    ],
    "HumanEval/81": [
      "def gpa_to_letter_grade(gpa):\n  if gpa >= 4.0:\n    return \"A\"\n  elif gpa >= 3.7:\n    return \"A-\"\n  elif gpa >= 3.3:\n    return \"B+\"\n  elif gpa >= 3.0:\n    return \"B\"\n  elif gpa >= 2.7:\n    return \"B-\"\n  elif gpa >= 2.3:\n    return \"C+\"\n  elif gpa >= 2.0:\n    return \"C\"\n  elif gpa >= 1.7:\n    return \"C-\"\n  elif gpa >= 1.3:\n    return \"D+\"\n  elif gpa >= 1.0:\n    return \"D\"\n  else:\n    return \"F\"",
      "def convert_letter_grade(grade):\n    grades = {\n        'A': 4.0,\n        'B': 3.0,\n        'C': 2.0,\n        'D': 1.0\n    }\n    return grades[grade]",
      "def count_zeros(matrix: List[List[int]], strict_zero: bool = False) -> int:\n    \"\"\"The data input is a matrix of integers. The task at hand is to devise a function which can quantify the zero occurrences in the matrix. An optional parameter 'strict_zero' has been added to the function to increase the level of difficulty. If this parameter is turned on (strict_zero=True), the function counts only true zeros, discarding any units that could potentially qualify as false in a boolean context like '' or False. If off (strict_zero=False), these units should also be categorized as zeros.\n\n    Examples:\n    >>> count_zeros([[1, 0, 3], [4, 0, 0]])\n    3\n    >>> count_zeros([[1, '', 3], [4, '0', '-0']])\n    0\n    >>> count_zeros([[1, '', 3], [4, '0', '-0']], False)\n    3\n    \"\"\"    \n    zero_count = 0\n    for row in matrix:\n        for num in row:\n            if (strict_zero and num == 0) or (not strict_zero and not num):\n                zero_count += 1\n    return zero_count",
      "def count_zeros(matrix: List[List[int]], strict_zero: bool = True) -> int:\n    \"\"\"\n    The data input is a matrix of integers. The task at hand is to devise a function which can quantify the zero occurrences in the matrix. \n    An optional parameter 'strict_zero' has been added to the function to increase the level of difficulty. If this parameter is turned on \n    (strict_zero=True), the function counts only true zeros, discarding any units that could potentially qualify as false in a boolean context \n    like '' or False. If off (strict_zero=False), these units should also be categorized as zeros.\n\n    Examples:\n    >>> count_zeros([[1, 0, 3], [4, 0, 0]]) \n    3 \n    >>> count_zeros([[1, '', 3], [4, '0', '=0']]) \n    0 \n    >>> count_zeros([[1, '', 3], [4, '0', '-0']], False) \n    5 \n    \"\"\"\n    zero_count = 0\n    for row in matrix:\n        for num in row:\n            if (strict_zero and num == 0) or (not strict_zero and not num):\n                zero_count += 1\n    return zero_count",
      "def longest(strings: List[str]) -> Optional[str]:\n    \"\"\" In a given list of strings, identify and return the string having the longest length. If there are several strings with the same lengths, return the one that appeared first. If the list has no elements, return None.\n\n    >>> longest([])\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n\n    if not strings: # check if the list is empty\n        return None\n\n    longest_string = strings[0]\n    for string in strings:\n        if len(string) > len(longest_string):\n            longest_string = string\n\n    return longest_string"
    ],
    "HumanEval/82": [
      "def prime_length(string):\n    '''Determine if the string's length is a prime number'''\n    length = len(string)\n    if is_prime(length):\n        return True\n    else:\n        return False",
      "def prime_length(string):\n    \"\"\"Check if length of a string is a prime number.\"\"\"\n    length = len(string)\n    return is_prime(length)",
      "def prime_length(string):\n    \"\"\"Accept a string, get its length, and verify if \n    the length is a prime number.\"\"\"\n    length = len(string)\n    return is_prime(length)",
      "def prime_length(string):\n    return is_prime(len(string))",
      "def check_strings(strings):\n    if len(strings) == 0:\n        print(\"The list is empty.\")\n        return False\n    \n    for string in strings:\n        if not is_palindrome(string) or not is_prime(len(string)):\n            print(f\"The string '{string}' does not meet the criteria.\")\n            return False\n    \n    print(\"All strings in the list are palindromes and have a length that is a prime number.\")\n    return True"
    ],
    "HumanEval/83": [
      "def proper_code(*args):\n    \"\"\"\n    Given single or multiple positive integers, check if any of them is a perfect square.\n    If at least one is a perfect square, create and test a function that returns the number of n-digit positive integers that start or end with 1.\n    Also, these numbers must be divisible by any three distinct prime numbers.\n    Return 'Not a perfect square.' if none of them is a perfect square.\n    \"\"\"\n    # Find first three prime numbers\n    primes = list(sympy.primerange(0,100))[:3]\n    for i in args:\n        if is_perfect_square(i):\n            # n is taken as the number of digits in the first perfect square found\n            n = len(str(i))\n            return num_start_end_with_1(n, primes)\n    return 'Not a perfect square.'",
      "def proper_code(*args):\n    \"\"\"\n    Given single or multiple positive integers, check if any of them is a perfect square. \n    If at least one is a perfect square, create and test a function that returns the number of n-digit positive integers that start or end with 1. \n    Also, these numbers must be divisible by any three distinct prime numbers. \n    Return 'Not a perfect square.' if none of them is a perfect square.\n    \"\"\"\n    # Find first three prime numbers\n    primes = list(sympy.primerange(0, 100))[:3]\n    for i in args:\n        if is_perfect_square(i):\n            # n is taken as the number of digits in the first perfect square found\n            n = len(str(i))\n            return num_start_end_with_1(n, primes)\n    return 'Not a perfect square.'",
      "def one_ends_divisible(n):\n    \"\"\"\n    Given a positive integer n, check if it's a perfect square.\n    If it's a perfect square, return the number of n-digit positive integers that start or end with 1 and are divisible by three distinct prime numbers.\n    If it's not a perfect square, return 'Not a perfect square.'\n    \"\"\"\n\n    if not is_perfect_square(n):\n        return 'Not a perfect square'\n\n    numbers_with_one_ends = all_n_digit_numbers_with_one_ends(n)\n\n    counts = 0\n\n    for num in numbers_with_one_ends:\n        factors = prime_factors(num)\n        if len(set(factors)) >= 3:\n            counts += 1\n\n    return counts",
      "def one_ends_divisible(n):\n    \"\"\"\n    Given a positive integer n, check if it's a perfect square. If it's a perfect square, \n    return the number of n-digit positive integers that start or end with 1 and are divisible by three distinct prime numbers.\n    If it's not a perfect square, return 'Not a perfect square.'\n    \"\"\"\n\n    if not is_perfect_square(n):\n        return 'Not a perfect square'\n\n    numbers_with_one_ends = all_n_digit_numbers_with_one_ends(n)\n    \n    counts = 0\n\n    for num in numbers_with_one_ends:\n        factors = prime_factors(num)\n        if len(set(factors)) >= 3:\n            counts += 1\n\n    return counts",
      "def starts_one_ends(n, x, y):\n    \"\"\"\n    Given a positive integer n, and two non-negative integers x,y; return the count of n-digit positive \n    integers that start and end with 1, are divisible by both 3 and 5, and do not contain x or y anywhere in the sequence.\n    \"\"\"\n    if n < 2:\n        return 0\n\n    dp = [0] * (n + 1)\n\n    forbidden = {str(x), str(y)}\n\n    dp[2] = 3  # 15, 51, 11\n\n    for i in range(3, n + 1):\n        dp[i] = 8 * dp[i - 1] - dp[i - 2]  # exclude numbers with forbidden digits\n        if '1' not in forbidden:\n            dp[i] += 2 ** (i - 2)\n        if '5' not in forbidden:\n            dp[i] += 2 ** (i - 2)\n\n    return dp[n]"
    ],
    "HumanEval/84": [
      "def calculate_numbers(n):\n    # Check if input is positive integer\n    if not isinstance(n, int) or n <= 0:\n        return \"Input should be a positive integer\"\n  \n    # Convert number to list of digits\n    digits = [int(x) for x in str(n)]\n  \n    # Calculate cumulative total of digits\n    total = sum(digits)\n  \n    # Calculate sum of factorials of digits\n    factorial_sum = sum(math.factorial(i) for i in digits)\n  \n    return total, factorial_sum",
      "def calculate_numbers(n):\n    # Check if input is positive integer\n    if not isinstance(n, int) or n <= 0:\n        return \"Input should be a positive integer\"\n  \n    # Convert number to list of digits\n    digits = [int(x) for x in str(n)]\n  \n    # Calculate cumulative total of digits\n    total = sum(digits)\n  \n    # Calculate sum of factorials of digits\n    factorial_sum = sum(math.factorial(i) for i in digits)\n  \n    return total, factorial_sum",
      "def digit_product_sum(n):\n    \"\"\"\n    Calculate the sum and the product of the digits of a number.\n\n    Args:\n    n (int): A positive integer.\n\n    Returns:\n    Tuple: A tuple containing the product and the sum of the digits.\n    \"\"\"\n    product = 1\n    digit_sum = 0\n    for digit in str(n):\n        product *= int(digit)\n        digit_sum += int(digit)\n    return product, digit_sum, n",
      "def check_armstrong(number):\n    # Check if input is an integer\n    if not isinstance(number, int):\n        return \"The input must be an integer.\"\n    # Check if input is in range 1 to 10000\n    elif number < 1 or number > 10000:\n        return \"The input must be a positive integer between 1 and 10,000.\"\n    else:\n        # Convert integer to string to facilitate iteration over digits\n        digits = str(number)\n        num_digits = len(digits)\n        # Calculate sum of digits to the power of the number of digits\n        armstrong_sum = sum(int(digit)**num_digits for digit in digits)\n        # Check if number is equal to Armstrong sum\n        if number == armstrong_sum:\n            return True\n        else:\n            return False",
      "def check_armstrong(number):\n    # Check if input is an integer\n    if not isinstance(number, int):\n        return \"The input must be an integer.\"\n    # Check if input is in range 1 to 10000\n    elif number < 1 or number > 10000:\n        return \"The input must be a positive integer between 1 and 10,000.\"\n    else:\n        # Convert integer to string to facilitate iteration over digits\n        digits = str(number)\n        num_digits = len(digits)\n        # Calculate sum of digits to the power of the number of digits\n        armstrong_sum = sum(int(digit)**num_digits for digit in digits)\n        # Check if number is equal to Armstrong sum\n        if number == armstrong_sum:\n            return True\n        else:\n            return False"
    ],
    "HumanEval/85": [
      "def enhanced_solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are at even positions.    \n\n    Examples\n    enhanced_solution([5, 8, 7, 1]) => 5\n    enhanced_solution([3, 3, 3, 3, 3]) => 9\n    enhanced_solution([30, 13, 24, 321]) => 30\n    \"\"\"\n    return sum(num for i, num in enumerate(lst[::2]) if num % 2 == 1)",
      "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)",
      "def multiply(lst):\n    \"\"\"Given a populated array of integers, lst, compute the product of all odd numerals located at even indices within the array that are simultaneously multiples of 3. The indices of the array start at 0 (even).\n\n    Illustrative scenario (Correct):\n        multiply([3, 5, 7, 8, 9]) yields 27  \n    \"\"\"\n    result = 1\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 == 1 and lst[i] % 3 == 0:\n            result *= lst[i]\n    return result",
      "def multiply(lst):\n    \"\"\"Given a non-empty list of integers lst, perform multiple steps calculation to find the product of odd elements located at even indices. Ensure none of the elements in the list exceeds 100 and that you handle possible exceptions. Additionally, guarantee the final product does not exceed 5000.\n\n    Example\uff1a\n    multiply([3, 5, 7, 8, 6]) ==> 21\n    \"\"\"\n    if not lst:    # if list is empty \n        return \"Input list should not be empty.\"\n    if not all(type(i) == int for i in lst):    # if list has non-integer elements \n        return \"All elements of the input list should be integers.\"\n    if not all(0 <= i <= 100 for i in lst):    # if list has elements exceeding 100\n        return \"Elements of the list should not exceed 100.\"\n    try:\n        product = 1\n        for i in range(0, len(lst), 2):    # skipping 1 element i.e., considering elements at even indices\n            if lst[i] % 2 != 0:    # if the element is odd\n                product *= lst[i]\n            if product > 5000:    # if the product exceeds 5000\n                return \"Product exceeded 5000.\"\n        return product\n    except Exception as e:\n        return str(e)",
      "def multiply(lst):\n    \"\"\"Given a non-empty list of integers lst, perform multiple steps calculation to find the product of odd elements located at even indices. Ensure none of the elements in the list exceeds 100 and that you handle possible exceptions. Additionally, guarantee the final product does not exceed 5000.\n\n    Example\uff1a\n         multiply([3, 5, 7, 8, 9]) ==> 21\n    \"\"\"\n    if not lst:    # if list is empty \n        return \"Input list should not be empty.\"\n    if not all(type(i) == int for i in lst):    # if list has non-integer elements \n        return \"All elements of the input list should be integer.\"\n    if not all(0 <= i <= 100 for i in lst):    # if list has elements exceeding 100\n        return \"Elements of the list should not exceed 100.\"\n    try:\n        product = 1\n        for i in range(0, len(lst), 2):    # skipping 1 element i.e., considering elements at even indices\n            if lst[i] % 2 != 0:    # if the element is odd\n                product *= lst[i]\n                if product > 5000:    # if the product exceeds 5000\n                    return \"Product exceeded 5000.\"\n        return product\n    except Exception as e:\n        return str(e)"
    ],
    "HumanEval/86": [
      "def anti_shuffle(s):\n    \"\"\"\n    Function that accepts a string and produces an ordered variant using the custom_sort function.\n    The ordered variant of a string is a new phrase where every word (partitioned by space) \n    is replaced by a new word where every character adheres to the custom_sort methodology.\n    The word and blank space sequence in the sentence remains unchanged.\n\n    Args: \n        s: string\n\n    Returns:\n        The modified string with each word sorted according to the rules of custom_sort\n    \"\"\"\n    \n    sorted_words = [custom_sort(word) for word in s.split(\" \")]\n    return ' '.join(sorted_words)",
      "def anti_shuffle(s):\n    \"\"\"\n    Function that accepts a string and produces an ordered variant using the custom sort function.\n    The ordered variant of a string is a new phrase where every word (partitioned by space)\n    is replaced by a new word where every character adheres to the custom sort methodology.\n    The word and blank space sequence in the sentence remains unchanged.\n\n    Args:\n    s: String\n\n    Returns:\n    The modified string with each word sorted according to the rules of custom_sort\n    \"\"\"\n\n    sorted_words = [custom_sort(word) for word in s.split(\" \")]\n    return ' '.join(sorted_words)",
      "def analyze_string(input_string):\n    \"\"\"This function takes an input string, checks the occurrence of 'hello world', \n        transmutes the string into capital letters if 'hello world' is found, finds \n        the starting and ending indices of 'hello world', and stores the result in \n        a JSON file.\n    \n    Args:\n        input_string (str): The string to analyze.\n        \n    Returns:\n        str: The updated string if 'hello world' is found.\n    \"\"\"\n    # Specify search pattern\n    pattern = 'hello world'\n    \n    # Find all occurrences of the pattern in the string\n    matches = [match.span() for match in re.finditer(pattern, input_string)]\n    \n    # If the pattern is found, change the string to upper case\n    if matches:\n        # Form the array to be stored in JSON\n        array = [{'start': start, 'end': end, 'count': i+1} \n            for i, (start, end) in enumerate(matches)]\n        \n        # Store the array into a JSON file\n        store_to_json(array, 'output.json')\n\n        input_string = input_string.upper()\n\n    return input_string",
      "def join_with_dash(line):\n    \"\"\"\n    Joins the words in the input string with a dash.\n\n    Args:\n    line (str): The input string containing words separated by spaces.\n\n    Returns:\n    str: A new string where the words are joined with a dash (\"-\") instead of spaces.\n    \"\"\"\n    return \"-\".join(line.split())",
      "def arrange_string(s):\n    \"\"\"\n    This function takes a string 's', splits it into words, applies the custom_order function to each word to sort the characters in it,\n    and then rejoins the sorted words back together with a space in between. The function preserves the original order of words \n    and blank spaces in the sentence.\n    \"\"\"\n\n    # Split the string into a list of words\n    words_list = s.split(' ')\n\n    # Apply the custom_order function to each word in the list\n    ordered_words_list = [custom_order(word) for word in words_list]\n\n    # Join the ordered words back together with a space in between to form a string\n    ordered_s = ' '.join(ordered_words_list)\n\n    return ordered_s"
    ],
    "HumanEval/87": [
      "def get_row(lst, x):\n    result = []\n    for row_index, row in enumerate(lst):\n        for column_index, element in enumerate(row):\n            if element == x:\n                result.append((row_index, column_index))\n    result.sort(key=lambda a: (a[0], -a[1]))\n    return result",
      "def find_closest_elements(numbers: List[int]) -> Tuple[int, int, int]:\n    \"\"\"\n    In the given list of numbers, find and return the two closest numbers firstly the smaller number, \n    then the larger number and the frequency of the smallest difference.\n    For example:\n    find_closest_elements([1, 2, 3, 4, 5, 2])\n    Returns: (2, 2, 2)\n    find_closest_elements([1, 5, 2, 7, 6, 3])\n    Returns: (2, 3, 1)\n    \"\"\"    \n    numbers.sort()\n    pairs = [(numbers[i], numbers[i + 1]) for i in range(len(numbers) - 1)]\n    minimum = min(pair[1] - pair[0] for pair in pairs)\n    result = [pair for pair in pairs if pair[1] - pair[0] == minimum]\n    return result[0][0], result[0][1], len(result)",
      "def hybrid_sort_list_heap(lst):\n    '''\n    Given a list of integers and decimals, use a heap sort combined with binary insertion sort to arrange the list in a special order. The ordering should start with the smallest value, then the largest, then the smallest of the remaining values not yet included in the output, and continue doing this until all elements are sorted.\n\n    Examples:\n    hybrid_sort_list_heap([1, 2, 3, 4]) == [1, 4, 2, 3]\n    hybrid_sort_list_heap([5, 5, 5, 5]) == [5, 5, 5, 5]\n    hybrid_sort_list_heap([]) == []\n    hybrid_sort_list_heap([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # Make input list to a heap\n    heapq.heapify(lst)\n\n    # If the size of the list is less than 10 use Binary Insertion Sort\n    if len(lst) < 10:\n        sorted_lst = binary_insertion_sort(lst)\n    else:\n        # Else use Heap Sort\n        sorted_lst = [heapq.heappop(lst) for _ in range(len(lst))]\n\n    # Create a resultant list as per special order\n    result = []\n    while sorted_lst:\n        result.append(sorted_lst.pop(0))  # pop the smallest\n        if sorted_lst:\n            result.append(sorted_lst.pop(-1))  # pop the largest\n\n    return result",
      "def hybrid_sort_list_heap(lst):\n    '''\n    Given a list of integers and decimals, use a heap sort combined \n    with binary insertion sort to arrange the list in a special order. \n    The ordering should start with the smallest value, then the largest, \n    then the smallest of the remaining values not yet included in the output, \n    and continue doing this until all elements are sorted.\n\n    Examples:\n    hybrid_sort_list_heap([1, 2, 3, 4]) == [1, 4, 2, 3]\n    hybrid_sort_list_heap([5, 5, 5, 5]) == [5, 5, 5, 5]\n    hybrid_sort_list_heap([]) == []\n    hybrid_sort_list_heap([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # Make input list to a heap\n    heapq.heapify(lst)\n\n    # If the size of the list is less than 10 use Binary Insertion Sort\n    if len(lst) < 10:\n        sorted_lst = binary_insertion_sort(lst)\n    else:\n        # Else use Heap Sort\n        sorted_lst = [heapq.heappop(lst) for _ in range(len(lst))]\n\n    # Create a resultant list as per special order\n    result = []\n    while sorted_lst:\n        result.append(sorted_lst.pop(0))  # pop the smallest\n        if sorted_lst:\n            result.append(sorted_lst.pop(-1))  # pop the largest\n\n    return result",
      "def intersperse(numbers: List[Union[int, List[int]]], delimeter: Union[int, float]) -> List[int]:\n    \"\"\"\n    Introduce the 'delimeter' digit amongst every couple of sequential numbers in the supplied 'numbers' list.\n    Moreover, make sure to manage scenarios that involve a negative or non-integer `delimeter`.\n    Also handles nested list within numbers list.\n    For example:\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], -2)\n    [1, 2, 3]\n    >>> intersperse([1, [2, 3]], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], 4.5)\n    [1, 2, 3]\n    \"\"\"\n    outcome = []\n    flattened_numbers = []\n\n    # This block is to handle nested arrays and flatten them.\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimeter))  # recursive flatten\n        else:\n            flattened_numbers.append(num)\n\n    # This block is to place the delimeter (if it's a non-negative integer) in between the numbers.\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i < len(flattened_numbers) - 1 and isinstance(delimeter, int) and delimeter >= 0:\n            outcome.append(delimeter)\n\n    return outcome"
    ],
    "HumanEval/88": [
      "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n        1. Perform rightward shifting operation as required.\n        2. Swap at most three pair of balls.\n        3. After the operations, elements smaller than the first element in the array should be odd in number.\n\n    Return True, if the array could be sorted, otherwise False. \n\n    Examples:\n    move_three_balls([3, 4, 5, 1, 2, 6]) => True\n    move_three_balls([1, 3, 5, 4, 2, 6]) => True\n    move_three_balls([1, 2, 3, 5, 4, 6]) => True\n    move_three_balls([5, 4, 3, 1, 2, 6]) => False\n\n    \"\"\"\n    if not arr:\n        return True\n\n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False",
      "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n    1. Perform rightward shifting operation as required.\n    2. Swap at most three pair of balls.\n    3. After the operations, elements smaller than the first element in the array should be odd in number.\n    \n    Return True, if the array could be sorted; otherwise, False. \n    \n    Examples:\n    move_three_balls([5, 4, 5, 1, 2, 6]) -> True\n    move_three_balls([1, 3, 5, 4, 2, 6]) -> True\n    move_three_balls([1, 2, 3, 5, 4, 6]) -> True\n    move_three_balls([5, 4, 3, 1, 2, 6]) -> False\n    \"\"\"\n    \n    if not arr:\n        return True\n    \n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False",
      "def test_bubble_sort():\n    # Empty array\n    arr = []\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != []:\n        print(\"Error: Bubble Sort failed on empty array.\")\n\n    # Array with duplicate values\n    arr = [4, 3, 2, 2, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 2, 3, 4]:\n        print(\"Error: Bubble Sort failed on array with duplicate values.\")\n\n    # Sorted array in descending order\n    arr = [5, 4, 3, 2, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 3, 4, 5]:\n        print(\"Error: Bubble Sort failed on sorted array in descending order.\")\n\n    # Random unsorted array\n    arr = [5, 3, 2, 4, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 3, 4, 5]:\n        print(\"Error: Bubble Sort failed on random unsorted array.\")",
      "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)",
      "def advanced_sort(l: list, n: int):\n    \"\"\"\n    This function accepts a list l, an integer n and returns a new resultant list l' that satisfies the next conditions:\n    l' equates l at indices not divisible by n; however at indices divisible by n, values parallel l's corresponding indices, but with the uniqueness of being multiplied by 2 and arranged in reverse.\n\n    >>> advanced_sort([1, 2, 3], 2)\n    [1, 2, 3]\n    >>> advanced_sort([5, 6, 3, 4, 8, 9, 2], 3)\n    [5, 6, 3, 2, 8, 9, 1]\n    >>> advanced_sort([8, 7, 4, 1, 3, 6, 5], 3)\n    [8, 7, 4, 5, 3, 6, 1]\n    \"\"\"\n\n    sublist = [val * 2 for i, val in enumerate(l) if i % n == 0]\n    sublist.sort(reverse=True)\n\n    new_list = l.copy()\n    index = 0\n    for i, val in enumerate(new_list):\n        if i % n == 0:\n            new_list[i] = sublist[index]\n            index += 1\n\n    return new_list"
    ],
    "HumanEval/89": [
      "def encrypt(s, shift):\n    # The 'encryption' function implements the Caesar cipher for encoding\n    result = \"\"\n\n    for v in s:\n        # Check if character is an uppercase letter\n        if v.isupper():\n            # Encrypt character and preserve case\n            # The ord function returns the number representing the unicode character\n            # The chr function returns a string representing a character whose Unicode code point is the integer\n            result += chr((ord(v) - 65 + shift) % 26 + 65)\n\n        # Check if character is a lowercase letter\n        elif v.islower():\n            # Encrypt character and preserve case\n            result += chr((ord(v) - 97 + shift) % 26 + 97)\n\n        # Leave non-alphabet characters as they are\n        else:\n            result += v\n            \n    return result",
      "def encrypt(s, shift, seed=0):\n    \"\"\"Create a function named encrypt that accepts two parameters, a string and an integer for rotation. The function should return an encrypted string using a shuffled alphabet based on the input integer. It should handle case sensitivity and preserve non-alphabetic characters. It should also handle exceptions due to rotations exceeding the length of the alphabet.\"\"\"\n\n    # Define alphabet\n    lower_alphabet = string.ascii_lowercase\n    upper_alphabet = string.ascii_uppercase\n\n    # Introduce seed manipulation for more complexity\n    shift = (shift + seed) % 26\n\n    result = \"\"\n\n    for c in s:\n        # Support for unicode characters\n        if not c.isascii():\n            result += chr(ord(c) + shift)\n        # Preserve non-alphabetical characters\n        elif not c.isalpha():\n            result += c\n        else:\n            # Handle upper/lower-case characters differently for case sensitivity\n            if c.isupper():\n                result += upper_alphabet[(upper_alphabet.index(c) + shift) % 26]\n            else:\n                result += lower_alphabet[(lower_alphabet.index(c) + shift) % 26]\n\n    return result",
      "def encrypt_caesar(plaintext, shift):\n    \"\"\"\n    Encrypts a plaintext string using the Caesar cipher.\n\n    Args:\n        plaintext: The plaintext to encrypt.\n        shift: The number of characters to shift by.\n\n    Returns:\n        The ciphertext.\n    \"\"\"\n    alphabet = string.ascii_lowercase\n    shifted_alphabet = alphabet[shift:] + alphabet[:shift] \n    table = str.maketrans(alphabet, shifted_alphabet) \n    ciphertext = plaintext.translate(table)\n    return ciphertext",
      "def cipher(s):\n    \"\"\"Derive a python function called 'cipher' that takes a string parameter and returns a ciphered string utilizing a rotated alphabet (the alphabet is shifted three positions ahead, using the modulo operator in Python to handle wrapping at the ends). This function should conserve the case of the characters (upper and lower), keep the non-alphabetical characters unchanged in the derived output, and work for all characters of the lower case and uppercase English alphabets. Here are some examples:\n    cipher('Hi') renders 'Lm'\n    cipher('aSdFgHjKl') tends to become 'dUgIjLmNpQr'\n    cipher('Zx112e_') translates to 'Ca!I23h_'\n    cipher('E.x + Uz') is turned into 'H.a + Xc'\n    \"\"\"\n    result = ''\n\n    for char in s:\n    # preserve the non-alphabetical characters\n        if not char.isalpha():\n            result += char\n            continue\n\n    # shift three positions ahead, with case consideration\n        shifted_char = chr((ord(char.lower()) - 97 + 3) % 26 + 97) if char.islower() else chr((ord(char.upper()) - 65 + 3) % 26 + 65)\n        result += shifted_char\n\n    return result",
      "def cipher(s):\n    \"\"\"Derive a python function called 'cipher' that takes a string parameter and returns a ciphered string utilizing a rotated alphabet (the alphabet is shifted three positions ahead, using the modulo operator in Python to handle wrapping at the ends). This function should conserve the case of the characters (upper and lower), keep the non-alphabetical characters unchanged in the derived output, and work for all characters of the lower case and uppercase English alphabets. Here are some examples:\n    cipher('Hi') renders 'Lm'\n    cipher('aSdFgHjKl') tends to become 'dVgIjKmNpQr'\n    cipher('Zx!123_') translates to 'Ca!123_'\n    cipher('E.T + Ux') is turned into 'H.Y + Xc'\n    \"\"\"\n    result = ''\n    \n    for char in s:\n        # preserve the non-alphabetical characters\n        if not char.isalpha():\n            result += char\n            continue\n\n        # shift three positions ahead, with case consideration\n        shifted_char = chr((ord(char.lower()) - 97 + 3) % 26 + 97) if char.islower() else chr((ord(char.upper()) - 65 + 3) % 26 + 65)\n        result += shifted_char\n\n    return result"
    ],
    "HumanEval/90": [
      "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    smallest = float('inf')\n    next_smallest = float('inf')\n    for i in range(0, len(lst)):\n        if lst[i] < smallest:\n            next_smallest = smallest\n            smallest = lst[i]\n        elif lst[i] > smallest and lst[i] < next_smallest:\n            next_smallest = lst[i]\n    return None if next_smallest == float('inf') else next_smallest",
      "def uncommon_elements(sequence):\n    '''\n    Design a function that accepts a non-empty list composed of positive integers and returns a list of distinct integers whose frequency surpasses half of the integer's numerical value. Here, 'frequency' denotes the number of times a specific integer appears within the list.\n    If no integers satisfy these conditions, the function should return an empty list.\n    Examples:\n        uncommon_elements([4, 1, 2, 2, 3, 1]) should yield [2, 3]\n        uncommon_elements([1, 2, 2, 3, 3, 3, 4, 4, 4]) should yield [2, 3, 4]\n        uncommon_elements([5, 5, 4, 4, 4]) should yield [4]\n    '''\n    from collections import Counter\n    count = Counter(sequence)\n    result = []\n    for num, freq in count.items():\n        if freq > num/2:\n            result.append(num)\n    return result",
      "def strange_sort_list_bst(lst):\n    '''\n    This function should accept a list of integers and decimal_numbers and return the list in a specific pattern, leveraging the principles of a binary search tree. The steps to this peculiar_sorting pattern should be:\n    - Commence with the smallest number.\n    - Next, identify the highest value from the remaining elements.\n    - Then, ascertain the lowest_value among the untouched output, and continue in this manner.\n\n    Examples:\n    strange_sort_list_bst([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list_bst([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list_bst([]) == []\n    strange_sort_list_bst([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # First, we will sort the list in ascending_order.\n    lst.sort()\n\n    output = []\n\n    # Then, while lst is not empty, we will remove and append to output the smallest\n    # and largest element alternately.\n    while lst:\n        output.append(lst.pop(0))  # smallest\n        if lst:\n            output.append(lst.pop(-1))  # largest\n\n    return output",
      "def strange_sort_list_bst(lst):\n    '''\n    This function should accept a list of integers and decimal numbers and return the list in a specific pattern, leveraging the principles of a binary search tree. The steps for this peculiar sorting pattern should be:\n    - Commence with the smallest number.\n    - Next, identify the highest value from the remaining elements.\n    - Then, ascertain the lowest value among the untouched output, and continue in this manner.\n    \n    Examples:\n    strange_sort_list_bst([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list_bst([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list_bst([]) == []\n    strange_sort_list_bst([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n    \n    # First, we will sort the list in ascending order.\n    lst.sort()\n\n    output = []\n\n    # Then, while lst is not empty, we will remove and append to output the smallest\n    # and largest element alternatively.\n    while lst:\n        output.append(lst.pop(0))  # smallest\n        if lst:\n            output.append(lst.pop(-1))  # largest\n\n    return output",
      "def enhanced_solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are at even positions.    \n\n    Examples\n    enhanced_solution([5, 8, 7, 1]) => 5\n    enhanced_solution([3, 3, 3, 3, 3]) => 9\n    enhanced_solution([30, 13, 24, 321]) => 30\n    \"\"\"\n    return sum(num for i, num in enumerate(lst[::2]) if num % 2 == 1)"
    ],
    "HumanEval/91": [
      "def count_sentences(s):\n    \"\"\"Develop a function named 'count_sentences', that takes a string as an input,\n    and returns the count of sentences contained within that string. The function should assume that \n    sentences are separated by full stops ('.'). However, the full stops within abbreviations or decimal \n    numbers should not be considered as sentence endings.\n\n    Example:\n    >>> count_sentences(\"Hello. World.\")\n    2\n    >>> count_sentences(\"This is Dr. Smith.\")\n    1\n    >>> count_sentences(\"The cost is $2.5.\")\n    1\n    \"\"\"\n\n    try:\n      # Using regular expressions to count the number of sentences in a string.\n      # Ignore abbreviations or decimal numbers during counting.\n      count = len(re.findall(r\"[A-Z][^.!?]*[.!?]\", s, re.IGNORECASE))\n    except TypeError as e:\n      # Catching & handling the error if the input is not a string.\n      print(f\"TypeError: {e}\")\n      print(\"The input provided should be a string. Please provide a string input and try again.\")\n    except Exception as e:\n      # Handle other types of exceptions.\n      print(f\"An error occurred: {e}\")\n    else:\n      # If no exception is raised, then it returns the count of sentences.\n      return count",
      "def count_sentences(s):\n    \"\"\"Develop a function named 'count_sentences', that takes a string as an input,\n    and returns the count of sentences contained within that string. The function should assume that \n    sentences are separated by full stops ('.'). However, the full stops within abbreviations or decimal \n    numbers should not be considered as sentence endings.\n\n    Example:\n    >>> count_sentences(\"Hello. World.\")\n    2\n    >>> count_sentences(\"This is Dr. Smith.\")\n    1\n    >>> count_sentences(\"The cost is $2.5.\")\n    1\n    \"\"\"\n\n    try:\n        # Using regular expressions to count the number of sentences in a string.\n        # Ignore abbreviations or decimal numbers during counting.\n        count = len(re.findall(r\"[A-Z][^.!?]*[.!?]\", s, re.IGNORECASE))\n    except TypeError as e:\n        # Catching & handling the error if the input is not a string.\n        print(f\"TypeError: {e}\")\n        print(\"The input provided should be a String. Please provide a String input and try again.\")\n    except Exception as e:\n        # Handle other types of exceptions.\n        print(f\"An error occurred: {e}\")\n    else:\n        # If no exception is raised, then it returns the count of sentences.\n        return count",
      "def word_count(s):\n    \"\"\"Craft a function named word_count, which takes a string as input, \n    and computes the total quantity of words that the string contains. A word \n    is identified as a separate entity partitioned by whitespaces. Case sensitivity is ignored, \n    however, special characters within words are included. \n\n    Example:\n    >>> word_count(\"Hello World\")\n    2\n    >>> word_count(\"This is a sentence.\")\n    4\n    >>> word_count(\"\u00e1nother_ex\u00e4mple\")\n    1\n    \"\"\"\n    if type(s) != str:      # makesure the input is a string\n        return \"Error: Input should be a string\"\n        \n    if s.strip()==\"\":       # checks if the string is not empty or just whitespaces\n        return 0\n            \n    words = re.findall(r'\\S+', s)      # finds all the separate words using regular expression\n    return len(words)",
      "def word_count(s):\n    \"\"\"Define a function word_count, that accepts a string as an input, \n    provides the total count of words present within the string. Words \n    are identified as separate entities divided by whitespaces, including\n    leading, trailing and multiple consecutive whitespaces. The case is \n    disregarded but include special characters within the words. \n\n    Check for None and non-string input types and return appropriate \n    error message.\n\n    Example:\n    >>> word_count(\"Hello World\")\n    2\n    >>> word_count(\"This is a sentence.\")\n    4\n    >>> word_count(\"\u00e1nother_ex\u00e4mple\")\n    1\n    >>> word_count(\" Leading and trailing  white  spaces \")\n    5\n    >>> word_count(None)\n    'Error: Input is None'\n    >>> word_count(1234)\n    'Error: Input should be a string'\n    \"\"\"\n    if s is None:\n        return 'Error: Input is None'\n    elif type(s) != str:\n        return 'Error: Input should be a string'\n\n    # Removing leading and trailing whitespaces \n    # and replacing multiple consecutive whitespaces with a single space\n    s = ' '.join(s.split())\n                      \n    return len(s.split(' '))",
      "def is_bored(S):\n    # Splitting the string into sentences\n    sentences = [sentence.strip() for sentence in re.split('[.!?]', S) if sentence.strip()]\n    \n    # Initializing the counter variables\n    boring_count = 0\n    exciting_count = 0\n    \n    # Evaluating each sentence\n    for sentence in sentences:\n        if sentence.startswith(\"I\"):\n            boring_count += 1\n        if sentence.endswith(\"!\"):\n            exciting_count += 1\n    \n    return (boring_count, exciting_count)"
    ],
    "HumanEval/92": [
      "def will_it_fly(q,w):\n    '''\n    The function's purpose is to discern q's flight potential, return True if achievable, and False if not. For q to fly, it must fulfil two prerequisites: it must be palindromic and the total weights of its elements should not go beyond the maximum acceptable weight w.\n\n    Implement the function with error handling mechanisms. It should return a \"Non-numeric input\" error if it receives a non-numeric input, and a \"Non-sequence input\" error if it receives a non-sequence input.\n\n    Examples:\n    will_it_fly([1, 2], 5) \u279e False \n\n    will_it_fly([3, 2, 3], 1) \u279e False\n\n    will_it_fly([3, 2, 3], 9) \u279e True\n\n    will_it_fly([3], 5) \u279e True\n    \n    Error Cases:\n    will_it_fly([\"a\",\"b\",\"c\"], 5) \u279e \"Non-numeric input\"\n    \n    will_it_fly(123, 5) \u279e \"Non-sequence input\"\n    '''\n    # Handle Non-sequence input error\n    if not isinstance(q, (list, tuple, str)):\n        return \"Non-sequence input\"\n    \n    for i in q:\n        # Handle Non-numeric input error\n        if not isinstance(i, (int, float)):\n            return \"Non-numeric input\"\n    \n    return is_palindrome(q) and sum(q) <= w",
      "def total_match(lst1, lst2, case_sensitive=False):\n    \"\"\"\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n\n    The function also drops duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case sensitive parameter to True.\n\n    Should both iterables have an equal total character length, the function returns the first iterable.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['HI', 'HI']) \u279e ['HI', 'HI']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'hi']) \u279e ['hi', 'hi']\n    total_match(['A'], ['1', '2', '3', '4', '5']) \u279e ['A']\n    total_match(['hi world'], ['hi', ' w', 'or', 'ld']) \u279e ['hi', ' w', 'or', 'ld']\n    \"\"\"\n\n    # Remove non-alphanumeric characters and possibly convert to lower case\n    lst1 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst1]\n    lst2 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst2]\n\n    # Eliminate duplicates, preserving the original order\n    lst1, lst2 = list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2))\n\n    # Determine which list has a less or equal total character count\n    return lst1 if sum(len(s) for s in lst1) <= sum(len(s) for s in lst2) else lst2",
      "def total_match(lst1, lst2, case_sensitive=False):\n    '''\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n    \n    The function also drop duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case_sensitive parameter to True.\n    \n    Should both iterables have an equal total character length, the function returns the first iterable.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    total_match(['hi world'], ['hi', ' w', 'or', 'ld']) \u279e ['hi', ' w', 'or', 'ld']\n    '''\n    import re\n\n    # Remove non-alphanumeric characters and possibly convert to lower case\n    lst1 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst1]\n    lst2 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst2]\n\n    # Eliminate duplicates, preserving the original order\n    lst1, lst2 = list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2))\n\n    # Determine which list has a less or equal total character count\n    return lst1 if sum(len(s) for s in lst1) <= sum(len(s) for s in lst2) else lst2",
      "def sum_even_numbers(numbers):\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The sum of all even numbers in the list. Returns 0 if the list is empty or does not contain any even numbers.\n\n    Examples:\n    >>> sum_even_numbers([1, 2, 3, 4, 5, 6])\n    12\n    >>> sum_even_numbers([1, 3, 5, 7])\n    0\n    >>> sum_even_numbers([])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)",
      "def sum_of_even_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers: A list of integers.\n\n    Returns:\n    The sum of all even numbers in the list.\n    \n    Examples:\n    >>> sum_of_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    30\n    >>> sum_of_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_of_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)"
    ],
    "HumanEval/93": [
      "def vowels_count(s):\n    \"\"\"\n    A function that accepts a string that represents a word as an input parameter \n    and returns a count of all vowels it contains. The vowels include 'a', 'e', 'i', \n    'o', 'u', and 'y' (if it is at the end of the input word). It does not consider \n    case sensitivity and handles atypical characters contained in the input word.\n\n    The function has also been modified to handle cases where the input might not be \n    a string. In such situations, it raises a TypeError with an appropriate error \n    message. Moreover, it handles accentuated vowels.\n\n    Test Cases:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDV\")\n    3\n    >>> vowels_count(\"\u00e9xanpl\u00eb\")\n    5\n    >>> vowels_count(12345)\n    Traceback (most recent call last):\n    ...\n    TypeError: The input must be a string.\n    \"\"\"\n\n    if not isinstance(s, str):\n        raise TypeError('The input must be a string.')\n\n    vowels = \"aeiouyAEIOUY\"\n    accented_vowels = \"\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f2\u00f3\u00f4\u00f5\u00f6\u00f9\u00fa\u00fb\u00fc\u00fd\u00ff\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d2\u00d3\u00d4\u00d5\u00d6\u00d9\u00da\u00db\u00dc\u00dd\"\n    last_character = s[-1] if s else ''\n    return sum(1 for c in s if c in vowels or c in accented_vowels) + (1 if last_character == 'y' else 0)",
      "def vowels_count(s):\n    \"\"\"\n    A function that accepts a string that represents a word as an input parameter \n    and returns a count of all vowels it contains. The vowels include 'a', 'e', 'i', \n    'o', 'u', and 'y' (if it is at the end of the input word). It does not consider \n    case sensitivity and handles atypical characters contained in the input word.\n\n    The function has also been modified to handle cases where the input might not be \n    a string. In such situations, it raises a TypeError with an appropriate error \n    message. Moreover, it handles accentuated vowels.\n\n    Test Cases:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"\u00e9xampl\u00eb\")\n    5\n    >>> vowels_count(12345)\n    Traceback (most recent call last):\n      ...\n    TypeError: The input must be a string.\n    \"\"\"\n\n    if not isinstance(s, str):\n        raise TypeError('The input must be a string.')\n        \n    vowels = \"aeiouyAEIOUY\"\n    accented_vowels = \"\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f2\u00f3\u00f4\u00f5\u00f6\u00f9\u00fa\u00fb\u00fc\u00fd\u00ff\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d2\u00d3\u00d4\u00d5\u00d6\u00d9\u00da\u00db\u00dc\u00dd\"\n    last_character = s[-1] if s else ''\n    return sum(1 for c in s if c in vowels or c in accented_vowels) - (1 if last_character == 'y' else 0)",
      "def get_closest_vowel(word):\n    \"\"\"Insert a word, and then retrieve the nearest vowel that is ensconced amid a pair of consonants, \n    starting from the right section of the word, while being case-sensitive. \n    Bypass vowels at either the genesis or finale of the word. \n    Respond with a vacant string if such a vowel is nonexistent. \n    Presume that the input string is comprised strictly of English letters.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\n\n    vowels = 'aeiouAEIOU'\n    for i in reversed(range(1, len(word) - 1)): #not including the first and the last characters\n        if (word[i] in vowels) and (word[i - 1] not in vowels) and (word[i + 1] not in vowels):\n            return word[i]\n    return ''",
      "def get_closest_vowel(word):\n    \"\"\"Input a word and then find out the vowel closest from the right side of the word that is \n    between two consonants, distinguishing between upper and lower case. Ignore vowels at the \n    beginning or end of the word. If this kind of vowel does not exist, return an empty string. \n    Assume that the input string only contains English letters.\n\n    Examples:\n    get_closest_vowel(\"yogurt\") => \"u\"\n    get_closest_vowel(\"FULL\") => \"U\"\n    get_closest_vowel(\"quick\") => \"\"\n    get_closest_vowel(\"ab\") => \"\"\n    \"\"\"\n\n    # First, strip any vowels from the beginning and end of the word,\n    while len(word) > 0 and (word[0] in 'aeiouAEIOU' or word[-1] in 'aeiouAEIOU'):\n        if word[0] in 'aeiouAEIOU':\n            word = word[1:]\n\n        if len(word) > 0 and word[-1] in 'aeiouAEIOU':\n            word = word[:-1]\n\n    # Then, find the closest vowel sequence from the right side,\n    for i in range(len(word)-1, -1, -1):\n        if word[i] in 'aeiouAEIOU':\n            return word[i]\n    return \"\"",
      "def check_str(string):\n    '''\n    This function takes a string as input and checks if it contains all letters of the \n    English alphabet (a-z).\n    '''\n\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    for letter in alphabet:\n        if letter not in string.lower():\n            return False\n    return True"
    ],
    "HumanEval/94": [
      "def get_product_array(lst):\n    # Initialize a variable to keep track of the product\n    right_product = 1\n    # Initialize an array of ones with the same size as the input\n    output = [1] * len(lst)\n    \n    # Calculate the product of the numbers before the current index\n    for i in range(1, len(lst)):\n        output[i] = output[i - 1] * lst[i - 1]\n   \n    # Calculate the product of the numbers after the current index\n    for i in range(len(lst) - 1, -1, -1):\n        output[i] *= right_product\n        right_product *= lst[i]\n    \n    return output",
      "def generate_comma_separated_string(lst):\n    # Selection sort\n    for i in range(len(lst)):\n        min_idx = i\n        for j in range(i+1, len(lst)):\n            # Compare lengths first\n            if len(lst[j]) < len(lst[min_idx]):\n                min_idx = j\n            # If lengths are equal, compare alphabetically\n            elif len(lst[j]) == len(lst[min_idx]) and lst[j] < lst[min_idx]:\n                min_idx = j\n        # Swap elements\n        lst[i], lst[min_idx] = lst[min_idx], lst[i]\n\n    # Generate comma-separated string\n    output = \"\"\n    for i in range(len(lst)):\n        output += lst[i] + \",\"\n    output = output.lower().strip(\",\")\n\n    return output",
      "def findMedian(lst):\n    # Checking if input is a list\n    if not isinstance(lst, list):\n        raise TypeError(\"Input should be a list of integers.\")\n    # Checking if list contains integers\n    for i in lst:\n        if not isinstance(i, int):\n            raise ValueError(\"All elements in the list should be integers.\")\n\n    # Sorting the list \n    lst.sort()\n\n    # Calculating median\n    n = len(lst)\n    if n % 2 == 0:  # if even\n        median1 = lst[n//2]\n        median2 = lst[n//2 - 1]\n        median = (median1 + median2)/2\n    else:\n        median = lst[n//2]\n\n    return median",
      "def sort_method(lst):\n    minHeap = []\n    maxHeap = []\n\n    # Push all elements into minHeap, this will cause an error in the final output\n    for num in lst:\n        heapq.heappush(maxHeap, num)\n    \n    # Note the deliberate error: minHeap.pop() should be maxHeap.pop() and vice versa\n    result = [heapq.heappop(minHeap) if i % 2 == 0 else -heapq.heappop(maxHeap) for i in range(len(lst))]\n\n    return result",
      "def array_to_dict(lst):\n    output = {}\n    for i in range(0, len(lst), 2):\n        output[lst[i]] = lst[i+1]\n \n    return output"
    ],
    "HumanEval/95": [
      "def distorted_compare_word_sets(phrase1: str, phrase2: str):\n    \"\"\"\n    Determine if two phrases have the identical word set with multiple constraints including word duplicity, case sensitivity, and punctuation.\n    >>> distorted_compare_word_sets(\"Apple, Banana: Orange!\", \"orange apple Banana\")\n    False\n    >>> distorted_compare_word_sets(\"apple banana\", \"Apple, Orange BaNaNa!\")\n    False\n    >>> distorted_compare_word_sets(\"ApPle!\", \"appLE, Apple\")\n    True\n    >>> distorted_compare_word_sets(\"Banana?\", \"Apple BaNana!\")\n    False\n    >>> distorted_compare_word_sets(\"Apple BaNana Orange.\", \"Orange, BanaNa grape!\")\n    False\n    \"\"\"\n\n    # Remove punctuation, convert to lowercase and split by space\n    phrase1_words = set(phrase1.translate(str.maketrans(\"\", \"\", string.punctuation)).lower().split(\" \"))\n    phrase2_words = set(phrase2.translate(str.maketrans(\"\", \"\", string.punctuation)).lower().split(\" \"))\n\n    # Return comparison result\n    return phrase1_words == phrase2_words",
      "def verify_same_word_sets_freqs(phrase1: str, phrase2: str):\n    \"\"\"\n    >>> verify_same_word_sets_freqs(\"Apple Banana Orange\", \"Orange Apple Banana\")\n    True\n    >>> verify_same_word_sets_freqs(\"apple banana\", \"Apple Orange BaNaNa\")\n    False\n    >>> verify_same_word_sets_freqs(\"ApPle\", \"appLE Apple\")\n    False\n    >>> verify_same_word_sets_freqs(\"Banana Apple\", \"Apple BaNana\")\n    True\n    >>> verify_same_word_sets_freqs(\"Apple BaNana Orange\", \"Orange BanaNa grape\")\n    False\n    \"\"\"\n    map1 = Counter(phrase1.lower().split())\n    map2 = Counter(phrase2.lower().split())\n    return map1 == map2",
      "def validate_data_set(data):\n    required_keys = [\"country\", \"capital\", \"population\"]\n    for key in required_keys:\n        if key not in data:\n            print(f\"Key: {key} is missing in the data set.\")\n            return False\n\n    if not isinstance(data[\"country\"], str):\n        print(f\"Value of key: country should be a string.\")\n        return False\n    if not isinstance(data[\"capital\"], str):\n        print(f\"Value of key: capital should be a string.\")\n        return False\n    if not isinstance(data[\"population\"], str):\n        print(f\"Value of key: population should be a string.\")\n        return False\n    \n    return True",
      "def validate_data_set(data):\n    required_keys = [\"country\", \"capital\", \"population\"]\n    for key in required_keys:\n        if key not in data:\n            print(f\"Key: {key} is missing in the data set.\")\n            return False\n\n    if not isinstance(data[\"country\"], str):\n        print(f\"Value of key: country should be a string.\")\n        return False\n    if not isinstance(data[\"capital\"], str):\n        print(f\"Value of key: capital should be a string.\")\n        return False\n    if not isinstance(data[\"population\"], str):\n        print(f\"Value of key: population should be a string.\")\n        return False\n    \n    return True",
      "def construct_json(name, age, address=None, job_title=None, contact_details=None):\n    if not name or not age:\n        return json.dumps({'error': 'Name and Age parameters are required!'})\n\n    if not isinstance(name, str):\n        return json.dumps({'error': 'Invalid name. Name should be a string.'})\n\n    if not isinstance(age, int) or age < 0:\n        return json.dumps({'error': 'Invalid age. Age should be a non-negative integer.'})\n\n    data = {\n        \"Name\": name,\n        \"Age\": age,\n        \"Address\": address if address else \"Not provided\",\n        \"Job Title\": job_title if job_title else \"Not provided\",\n        \"Contact Details\": contact_details if contact_details else \"Not provided\",\n    }\n\n    return json.dumps(data, indent=4)"
    ],
    "HumanEval/96": [
      "def count_up_to(n):\n    \"\"\"Implement a function that takes a non-negative integer and returns a list of prime numbers below n.\"\"\"\n    primes = []\n    for i in range(2, n):\n        if is_prime(i):\n            primes.append(i)\n    return primes",
      "def count_up_to(n):\n    primes = []\n    for possiblePrime in range(2, n):\n        isPrime = True\n        for num in range(2, possiblePrime):\n            if possiblePrime % num == 0:\n                isPrime = False\n        if isPrime:\n            primes.append(possiblePrime)\n    return primes",
      "def count_up_to(n):\n    \"\"\"Return all primes less than n and measure efficiency.\"\"\"\n    if n < 2: \n        return []\n\n    start_time = time.time()\n    primes = [2]\n    i = 3\n    while i < n:\n        if all(i % p != 0 for p in primes):\n            primes.append(i)\n        i += 2\n\n    print(f\"Time taken: {time.time() - start_time} seconds.\")\n\n    # validate the correctness\n    if not all(is_prime(p) for p in primes):\n        print(\"The algorithm is not correct.\")\n    else:\n        print(\"The algorithm is correct.\")\n\n    return primes",
      "def rearrange_list(lst):\n    \"\"\"\n    Rearranges an array of numbers such that the smallest numbers come first\n    \"\"\"\n    n = len(lst)\n    for i in range(n):\n        min_idx = i\n        for j in range(i+1, n):\n            if lst[min_idx] > lst[j]:\n                min_idx = j \n\n        lst[i], lst[min_idx] = lst[min_idx], lst[i]\n    \n    return lst",
      "def find_prime_numbers(n):\n    \"\"\"Return an array of all primes less than n.\"\"\"\n    sieve = np.ones(n//3 + (n%6==2), dtype=bool)\n    for i in range(1,int(n**0.5)//3+1):\n        if sieve[i]:\n            k = 3*i+1|1\n            sieve[       k*k//3     ::2*k] = False\n            sieve[k*(k-2*(i&1)+4)//3::2*k] = False\n    return np.r_[2,3,((3*np.nonzero(sieve)[0][1:]+1)|1)]"
    ],
    "HumanEval/97": [
      "def multiply(lst, idx=0, prod=1):\n    \"\"\"Multiply prime numbers at prime indices.\"\"\"\n    if idx >= len(lst):\n        return prod\n    elif is_prime(idx) and is_prime(lst[idx]):\n        return multiply(lst, idx+1, prod * lst[idx])\n    else:\n        return multiply(lst, idx+1, prod)",
      "def multiply(lst):\n    \"\"\"Given a non-empty list of integers lst, perform multiple steps calculation to find the product of odd elements located at even indices. Ensure none of the elements in the list exceeds 100 and that you handle possible exceptions. Additionally, guarantee the final product does not exceed 5000.\n\n    Example\uff1a\n    multiply([3, 5, 7, 8, 6]) ==> 21\n    \"\"\"\n    if not lst:    # if list is empty \n        return \"Input list should not be empty.\"\n    if not all(type(i) == int for i in lst):    # if list has non-integer elements \n        return \"All elements of the input list should be integers.\"\n    if not all(0 <= i <= 100 for i in lst):    # if list has elements exceeding 100\n        return \"Elements of the list should not exceed 100.\"\n    try:\n        product = 1\n        for i in range(0, len(lst), 2):    # skipping 1 element i.e., considering elements at even indices\n            if lst[i] % 2 != 0:    # if the element is odd\n                product *= lst[i]\n            if product > 5000:    # if the product exceeds 5000\n                return \"Product exceeded 5000.\"\n        return product\n    except Exception as e:\n        return str(e)",
      "def multiply(a, b):\n    if b == 0:\n        return 0\n    return a + multiply(a, subtract(b, 1))",
      "def multiply(a, b):\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        print(\"Error: Inputs must be integers or floats.\")\n        return None\n    return a * b",
      "def multiply(lst):\n    \"\"\"Given a non-empty list of integers lst, perform multiple steps calculation to find the product of odd elements located at even indices. Ensure none of the elements in the list exceeds 100 and that you handle possible exceptions. Additionally, guarantee the final product does not exceed 5000.\n\n    Example\uff1a\n         multiply([3, 5, 7, 8, 9]) ==> 21\n    \"\"\"\n    if not lst:    # if list is empty \n        return \"Input list should not be empty.\"\n    if not all(type(i) == int for i in lst):    # if list has non-integer elements \n        return \"All elements of the input list should be integer.\"\n    if not all(0 <= i <= 100 for i in lst):    # if list has elements exceeding 100\n        return \"Elements of the list should not exceed 100.\"\n    try:\n        product = 1\n        for i in range(0, len(lst), 2):    # skipping 1 element i.e., considering elements at even indices\n            if lst[i] % 2 != 0:    # if the element is odd\n                product *= lst[i]\n                if product > 5000:    # if the product exceeds 5000\n                    return \"Product exceeded 5000.\"\n        return product\n    except Exception as e:\n        return str(e)"
    ],
    "HumanEval/98": [
      "def count_upper(s):\n    \"\"\"\n    Example:\n    count_upper('aBCdEf') returns 1\n    count_upper('abcdefg') returns 0\n    count_upper('dBBE') returns 0\n    \"\"\"\n    upper_vowels = ['A', 'E', 'I', 'O', 'U']\n    \n    # count of uppercase vowels at even indices\n    count = sum(1 for i in range(len(s)) if i % 2 == 0 and s[i] in upper_vowels)\n  \n    return count",
      "def count_upper(s):\n    \"\"\"\n    count_upper('aBCdEfG') returns 2\n    count_upper('ABCDEF') returns 3\n    count_upper('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') returns 5\n    \"\"\"\n    assert 1 <= len(s) <= 1000, \"String length should be between 1 and 1000 characters\"\n    \n    vow = ['A', 'E', 'I', 'O', 'U']\n    count = sum(1 for i in range(len(s)) if i % 2 == 0 and s[i] in vow)\n    \n    return count",
      "def count_upper(s):\n    \"\"\"\n    Count uppercase vowels in even index positions.\n    Use the Python builtin isupper() to check for uppercase letters, and set() for O(1) membership lookup.\n    Params: s - string input\n    Returns: count - number of capitalised vowels in even-positioned indices\n    \"\"\"\n    assert 1 <= len(s) <= 1000, \"Invalid string length. It should be between 1 and 1000 characters\"\n    vowels = set(\"AEIOU\")\n    count = sum(1 for i in range(0, len(s)) if s[i].isupper() and s[i] in vowels and i % 2 == 0)\n    return count",
      "def count_upper(s):\n    \"\"\"\n    Counts the number of uppercase vowels present in even indices of an input string.\n    \"\"\"\n    vowels = ['A', 'E', 'I', 'O', 'U']\n    return sum(1 for i in range(0, len(s), 2) if s[i] in vowels)",
      "def count_upper(s):\n    \"\"\"Count the number of uppercase vowel characters present at the even indices within the input string\"\"\"\n    upper_vowels ='AEIOU'\n    return sum(1 for i in range(len(s)) if i % 2 == 0 and s[i] in upper_vowels)"
    ],
    "HumanEval/99": [
      "def elite_truncation(figure, low, apex):\n    '''\n    Construct an operation that accedes to a figure (string) mimicking a digit along with two integers,\n    low and apex, which act as limiters of scope. The assignment involves returning the closest integer \n    to the input figure without the assistance of already available functions like round(). Furthermore, corroborate\n    that the supplied figure equates to a valid integer or float, and resides within the assigned boundaries.\n    If not, retrieve an error message. In a scenario where the digit finds itself at equal distance from two integers,\n    round it in the direction of zero.\n\n    Examples\n    >>> elite_truncation(\"10\", 0, 20)\n    10\n    >>> elite_truncation(\"15.6\", 10, 20)\n    15\n    >>> elite_truncation(\"out_of_range\", 5, 10)\n    \"Error: Invalid input.\"\n    >>> elite_truncation(\"25\", 0, 20)\n    \"Error: Out of range.\"\n\n    Note:\n    Rounding towards zero indicates that when the submitted number is halfway between two integers,\n    output the one that's nearest to zero. For instance, elite_truncation(\"14.5\", 10, 20) should\n    yield 14, whereas elite_truncation(\"-14.5\", -20, -10) should give -14.\n    '''\n    try:\n        num = float(figure)\n    except ValueError:\n        return \"Error: Invalid input.\"\n\n    if num < low or num > apex:\n        return \"Error: Out of range.\"\n        \n    if low<=num<apex:\n        if num>=0:\n            return int(num) if num-int(num)<0.5 else int(num)+1\n        else:\n            return int(num) if int(num)-num<0.5 else int(num)-1",
      "def elite_truncation(figure, low, apex):\n    '''\n    Construct an operation that access to a figure (string) mimicking a digit along with two integers,\n    low and apex, which act as limiters of scope. The assignment involves returning the closest integer \n    to the input figure without the assistance of already available functions like round(). Furthermore, \n    corroborate that the supplied figure equates to a valid integer or float, and resides within the assigned boundaries.\n    If not, retrieve an error message. In a scenario where the digit finds itself at equal distance from two integers,\n    round it in the direction of zero.\n\n    Examples\n    >>> elite_truncation(\"10\", 0, 20)\n    10\n    >>> elite_truncation(\"15.6\", 10, 20)\n    15\n    >>> elite_truncation(\"out_of_range\", 8, 10)\n    \"Error: Invalid input.\"\n    >>> elite_truncation(\"25\", 0, 20)\n    \"Error: Out of range.\"\n\n    Note:\n    Rounding towards zero indicates that when the submitted number is halfway between two integers,\n    output the one that's nearest to zero. For instance, elite_truncation(\"14.5\", 10, 20) should\n    yield 14, whereas elite_truncation(\"-14.5\", -20, -10) should give -14.\n    '''\n    try:\n        num = float(figure)\n    except ValueError:\n        return \"Error: Invalid input.\"\n\n    if num < low or num > apex:\n        return \"Error: Out of range.\"\n\n    if low <= num <= apex:\n        if num < 0:\n            return int(num) if num-int(num) < 0.5 else int(num) + 1\n        else:\n            return int(num) if int(num) - num < 0.5 else int(num) - 1",
      "def complex_rounding(value, low, high):\n    \"\"\"\n    Create a function that takes in a number represented as a string, value, and two \n    integers, low and high, establishing range parameters. This function should yield \n    the nearest integer to the input number without falling back on standard functions such\n    as round(). Alongside this, ascertain that the specified number is a valid integer or \n    floating-point number residing within the defined interval. Otherwise, \n    reciprocate with an error alert. For numbers at an equal distance from two integers, round it \n    towards zero.\n    \"\"\"\n    # Check if the input value is a valid number\n    try:\n        num_value = Decimal(value)\n    except InvalidOperation:\n        return \"Error: Invalid input.\"\n\n    # Check if the value is within the given range\n    if not (low <= num_value <= high):\n        return \"Error: Beyond range.\"\n\n    # Round according to the rules specified\n    decimal, integer = divmod(num_value, 1)\n\n    if decimal <= Decimal('0.5'):\n        return int(integer + 1)\n    elif decimal <= Decimal('-0.5'):\n        return int(integer - 1)\n    else:\n        return int(integer)",
      "def complex_rounding(value, low, high):\n    '''\n    Craft a function that takes in a number represented as a string, value, and two \n    integers, low and high, establishing range delimiters. This function should yield \n    the nearest integer to the input number without falling back on standard functions such \n    as round(). Alongside this, ascertain that the specified number is a valid integer or \n    floating-point number residing within the defined interval. Otherwise, \n    reciprocate with an error alert. For numbers at an equal distance from two integers, conform it \n    towards zero.\n    '''\n    # Check if the input value is a valid number\n    try:\n        num_value = Decimal(value)\n    except InvalidOperation:\n        return \"Error: Invalid input.\"\n    \n    # Check if the value is within the given range\n    if not (low <= num_value <= high):\n        return \"Error: Beyond range.\"\n      \n    # Round according to the rules specified\n    decimal, integer = divmod(num_value, 1)\n    \n    if decimal >= Decimal('0.5'):\n        return int(integer + 1)\n    elif decimal <= Decimal('-0.5'):\n        return int(integer - 1)\n    else:\n        return int(integer)",
      "def customize_rounding(number: float, round_down: bool = True, random_round: bool = False) -> int:\n    if random_round:\n        # if number is negative, rounding down means rounding towards zero and vice versa\n        if number < 0:\n            return math.floor(number) if random.randint(0, 1) else math.ceil(number)\n        else:\n            return math.floor(number) if random.randint(0, 1) else math.ceil(number)\n    elif round_down:\n        # if number is positive, rounding down means moving towards zero\n        # if number is negative, rounding down means moving away from zero\n        return math.floor(number) if number >= 0 else math.ceil(number)\n    else:\n        # if number is positive, rounding up means moving away from zero\n        # if number is negative, rounding up means moving towards zero\n        return math.ceil(number) if number >= 0 else math.floor(number)"
    ],
    "HumanEval/100": [
      "def make_a_pile(n, pattern, offset=0):\n    if type(n) != int or n < 1:\n        return \"Please input a non-zero positive integer for 'n'.\"\n    if pattern not in ['odd', 'even']:\n        return \"Please input 'odd' or 'even' for 'pattern'.\"\n    if type(offset) != int:\n        return \"Please input an integer for 'offset'.\"\n\n    stones = [n + offset]\n    for i in range(1, n):\n        if pattern == 'odd':\n            stones.append(stones[-1] + 2)\n        elif pattern == 'even':\n            stones.append(stones[-1] + 2*i + offset)\n    return stones",
      "def make_a_pile(n, pattern, offset=0):\n    stones = [n]\n    for i in range(1, n): # Start the loop from 1 because the offset in the first round should be 1.\n        if pattern == 'odd':\n            stones.append(stones[-1] + 2*i+1)\n        elif pattern == 'even':\n            stones.append(stones[-1] + 2*i+offset) # offset added here\n    return stones",
      "def make_a_pile(n, pattern, offset=0):\n    stones = [n + offset]\n    for i in range(1, n):\n        if pattern == 'odd':\n            stones.append(stones[-1] + 2*i - 1)\n        elif pattern == 'even':\n            stones.append(stones[-1] + 2*i)\n    return stones",
      "def lastStoneWeight(stones):\n    # Convert all weights to negative so we can use Python's min-heap as a max-heap.\n    stones = [-x for x in stones]\n    \n    heapq.heapify(stones) # Create a heap\n\n    while len(stones) > 1: # While there's more than one stone...\n        # Take the two heaviest stones.\n        y = -heapq.heappop(stones)\n        x = -heapq.heappop(stones)\n        # If they're not equal, add the remaining stone back to the heap.\n        if y != x:\n            heapq.heappush(stones, -abs(y-x))\n\n    # Return the weight of the last stone, or 0 if there are no stones.\n    return -stones[0] if stones else 0",
      "def canCross(stones: List[int]) -> bool:\n    # Create a set to store the positions of the stones for quick lookup\n    stone_set = set(stones)\n    \n    # Create a dictionary to store the possible jumps from each stone\n    jumps = {stone: set() for stone in stones}\n    jumps[0].add(0)  # The frog starts at the first stone with a jump of 0\n    \n    for stone in stones:\n        for jump in jumps[stone]:\n            for next_jump in range(jump - 1, jump + 2):\n                if next_jump > 0 and stone + next_jump in stone_set:\n                    jumps[stone + next_jump].add(next_jump)\n    \n    # If the last stone has any valid jumps, the frog can cross the river\n    return bool(jumps[stones[-1]])"
    ],
    "HumanEval/101": [
      "def int_to_string(num):\n    string_nums = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    return string_nums[num]",
      "def convert_number_words(text):\n    number_words_to_numbers = {\n        \"one\": \"1\", \"two\": \"2\", \"three\": \"3\", \"four\": \"4\",\n        \"five\": \"5\", \"six\": \"6\", \"seven\": \"7\", \n        \"eight\": \"8\", \"nine\": \"9\"\n    }\n    words = text.split(' ')\n    for i, word in enumerate(words):\n        if word in number_words_to_numbers:\n            words[i] = number_words_to_numbers[word]\n    return ' '.join(words)",
      "def transform_text(text):\n    digit_to_word = {\n        \"0\": \"ZERO\",\n        \"1\": \"ONE\",\n        \"2\": \"TWO\",\n        \"3\": \"THREE\",\n        \"4\": \"FOUR\",\n        \"5\": \"FIVE\",\n        \"6\": \"SIX\",\n        \"7\": \"SEVEN\",\n        \"8\": \"EIGHT\",\n        \"9\": \"NINE\"\n    }\n\n    words = [digit_to_word[character] if character.isdigit() else character for character in text.upper()]\n    return ' '.join(words)  # join the words with a space",
      "def text_to_number(input_str):\n    num_dict = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9,\n        \"ten\": 10,\n        \"hundred\": 100\n    }\n\n    words = input_str.lower().split(\" \")\n\n    number = 0\n    for i in range(len(words)):\n        if words[i] in num_dict.keys():\n            if words[i] == \"hundred\" and i > 0:\n                number *= num_dict[words[i]]\n            else:\n                number += num_dict[words[i]]\n\n    return number",
      "def complex_words_without_target(s, target):\n    \"\"\"\n    Given a string of words separated by various delimiters like commas, colons, semi-colons, spaces, or a combination. Your task is to split this string into words and create a dictionary. The dictionary keys will be the delimiters and the values will be lists storing the words in their original sequence after removing all instances of a given 'target' word and reversing the remaining words. If the 'target' appears in any word, eliminate that entire word.\n\n    For instance:\n\n    complex_words_without_target(\"Hello, how: are; you\", \"are\") \n    {\",\": [\"uoy\", \"woh\"], \":\": [\"woH\"], \";\": [\"olleH\"]}\n\n    complex_words_without_target(\"Cat, mouse: cheese; bread, butter; jam\", \"cheese\") \n    {\",\": [\"maj\", \"retub\"], \":\": [\"esuom\"], \";\": [\"taC\"]}\n    \"\"\"\n    \n    # Find the delimiters in the string\n    delimiters = re.findall(r'[^\\w\\s]', s)\n    # Split the string into words\n    words = re.findall(r'\\b(?:(?!{})\\w)+\\b'.format(target), s)\n    words = [word[::-1] for word in words]\n\n    # Create a dictionary with delimiters as keys and lists of words as values\n    result = {}\n    for delimiter, word in zip(delimiters, words):\n        if delimiter in result:\n            result[delimiter].append(word)\n        else:\n            result[delimiter] = [word]\n\n    return result"
    ],
    "HumanEval/102": [
      "def choose_num(x, y, z):\n    \"\"\"\n    This function accepts three positive integers x, y, and z, and its objective is to return the\n    greatest even integer within the inclusive range of [x, y] that can be evenly divided by z. In the\n    absence of such a number, the function should yield -1.\n\n    Example cases:\n    choose_num(12, 15, 2) = 14\n    choose_num(13, 12, 3) = -1\n    choose_num(10, 20, 4) = 20\n    \"\"\"\n\n    # Start checking from the largest number in the range [x, y]\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0 and num % z == 0:\n            return num\n    return -1",
      "def choose_num(x, y, z):\n    \"\"\"This function should take three positive numbers x, y, and z. The function must return \n    the largest even integer number that is less than or equal to y and greater than or equal \n    to x, which is also a multiple of z. In case no such number exists, the function should return None.\n    \n    Validate your code with the added complexity of handling potential exceptions.\n    \"\"\"  \n    if not (type(x) == type(y) == type(z) == int):\n        return \"Error: Inputs must be integers.\"\n\n    if not (x >= 0 and y >= 0 and z >= 0):\n        return \"Error: Inputs must be positive.\"\n\n    if x > y:\n        return \"Error: x should be less than or equal to y.\"\n\n    #Initialize the largest number as None.\n    largest_num = None\n    \n    #Iterate from y to x both inclusive to find largest even multiple of z.\n    for i in range(y, x - 1, -1):\n        if i % z == 0 and i % 2 == 0:\n            largest_num = i\n            break\n        \n    #Return the largest number.\n    return largest_num",
      "def choose_num(x, y, z, n):\n    # Initialize an empty list to store the even numbers divisible by z\n    chosen_num_list = []\n\n    # If y is less than x, switch their values. This ensures x is the start of the range and y is the end.\n    if y < x:\n        x, y = y, x\n\n    # Scan every number in the range [x, y]\n    for num in range(x, y+1):\n        # If num is even and divisible by z, add it to the list\n        if num % 2 == 0 and num % z == 0:\n            chosen_num_list.append(num)\n\n    # Sort the list in descending order to get the nth largest number at index n-1\n    chosen_num_list.sort(reverse=True)\n\n    # If the length of the list is less than n (no nth largest number), return -1\n    if len(chosen_num_list) < n:\n        return -1\n    else:\n        return chosen_num_list[n-1]",
      "def choose_num(x, y, z, w, m):\n    # Create a list to store the found numbers\n    numbers_found = []\n\n    # Iterate over the range, from y down to x (inclusive), in steps of -1\n    for num in range(y, x-1, -1):\n        # Check whether the number is even, and whether it is divisible by z and w\n        if num % 2 == 0 and num % z == 0 and num % w == 0:\n            # If so, append the number to our list\n            numbers_found.append(num)\n\n            # If we have found m numbers, return the last one found\n            if len(numbers_found) == m:\n                return numbers_found[-1]\n\n    # If no number has been found or m is larger than the count of such numbers, return -1\n    return -1",
      "def least_common_multiple(x: Union[int, float], y: Union[int, float], z: Union[int, float]) -> Union[int, str]:\n    \"\"\" \n    Return the least common multiple of three positive integers x, y, and z\n    \"\"\"\n    try:\n        # checking if the number is integer and positive\n        if not (isinstance(x, int) and x > 0) or not (isinstance(y, int) and y > 0) or not (isinstance(z, int) and z > 0):\n            return 'Input should be positive integers.'\n\n        # gcd is a function in math module that \n        # returns the greatest common divisor of two numbers\n        # lcm formula = (x*y)/gcd(x,y)\n        gcd = math.gcd(x, y)\n        lcm = x * y // gcd\n\n        gcd = math.gcd(lcm, z)\n        lcm = lcm * z // gcd\n\n        return lcm\n\n    except Exception as e:\n        return f'An error occurred: {e}' "
    ],
    "HumanEval/103": [
      "def convert_all_sums(n, m, start, base):\n    \"\"\"\n    You are provided two positive integers n and m (n <= m), and an additional starting number (start),\n    your task is to determine the sum of all the numbers from n through m (inclusive), starting from the 'start' number.\n    Then convert the sum into a custom base system. The custom base system will be another integer (base)\n    ranging from [2, 10] (inclusive). If n is greater than m, the start number is less than zero,\n    or the base is out of the given range, return -1. \n    \n    Example:\n    convert_all_sums(1, 5, 0, 2) => \"0b110\"\n    convert_all_sums(7, 5, 2, 2) => -1\n    convert_all_sums(10, 2, 10, 2) => \"0b10110\"\n    convert_all_sums(20, 33, 0, 2) => \"0b110101\"\n    convert_all_sums(15, 20, 10, 8) => \"0o25\"\n    \"\"\"\n    # Check for valid input\n    if n > m or start < 0 or not(2 <= base <= 10):\n        return -1\n    # Calculates the sum of the series\n    total = sum(range(n, m+1)) + start\n    # Converts the sum to the appropriate base\n    if base == 2:\n        return bin(total)\n    elif base == 8:\n        return oct(total)\n    elif base == 10:\n        return str(total)\n    else:\n        return \"Base not supported\"",
      "def convert_all_sums(n, m, start, base):\n    \"\"\"\n    You are provided two positive integers n and m (n <= m), \n    and an additional starting number (start), \n    your task is to determine the sum of all the numbers from n through m (inclusive), starting from the 'start' number,\n    Then convert the sum into a custom base system. The custom base system will be another integer (base)\n    ranging from [2, 10] (inclusive), If n is greater than m, the start number is less than zero,\n    or the base is out of the given range, return -1,\n\n    Example:\n    convert_all_sums(1, 5, 0, 2) => \"0b110\"\n    convert_all_sums(7, 5, 2, 2) => -1\n    convert_all_sums(10, 2, 10, 2) => \"0b1010\"\n    convert_all_sums(20, 33, 0, 2) => \"0b110101\"\n    convert_all_sums(15, 20, 10, 2) => \"0b25\"\n    \"\"\"\n    # Check for valid input\n    if n > m or start < 0 or not(2 <= base <= 10):\n        return -1\n    # Calculates the sum of the series\n    total = sum(range(n, m+1)) + start\n    # Converts the sum to the appropriate base\n    if base == 2:\n        return bin(total)\n    elif base == 8:\n        return oct(total)\n    elif base == 10:\n        return str(total)\n    else:\n        return \"Base not supported\"",
      "def square_nums(n, m):\n    # Check if n and m are positive integers\n    if n <= 0 or m <= 0 or type(n) != int or type(m) != int:\n        return \"n and m must be positive integers.\"\n    \n    # Check if m is greater than or equal to n\n    if m < n:\n        return \"m must be greater than or equal to n.\"\n    \n    # Calculate the squares of the numbers from n to m\n    result = [i ** 2 for i in range(n, m+1)]\n    return result",
      "def square_range(n, m):\n    # Validate that n and m are positive integers\n    if not isinstance(n, int) or not isinstance(m, int) or n <= 0 or m <= 0:\n        return \"Error: n and m must be positive integers\"\n    \n    # Ensure that n and m are within the range of 1 to 10^9\n    if n > 10**9 or m > 10**9:\n        return \"Error: n and m must be within the range of 1 to 10^9\"\n    \n    # Handle cases where n and m are equal\n    if n == m:\n        return [n**2]\n    \n    # Handle cases where m is less than n\n    if m < n:\n        return []\n    \n    # Calculate the squares of the numbers from n to m\n    squares = []\n    for i in range(m, n-1, -1):\n        squares.append(i**2)\n    \n    return squares",
      "def validate_input(n, m):\n    n = round(n)\n    m = round(m)\n    if n < 0 or m < 0:\n        raise ValueError(\"n and m must be positive integers.\")\n    return n, m"
    ],
    "HumanEval/104": [
      "def odd_sum_elements(x):\n    \"\"\"Given a list of positive integers x, return a sorted list of all \n    _unique_ elements where the sum of their digits is an odd number.\n\n    Note: The returned list should be sorted in ascending order. \n\n    >>> odd_sum_elements([15, 33, 1422, 1, 15])\n    [1, 15]\n    >>> odd_sum_elements([152, 323, 1422, 10])\n    [323]\n\n    \"\"\"\n    odd_sum_digits = []\n    for i in set(x):\n        if sum(int(digit) for digit in str(i)) % 2 != 0:\n            odd_sum_digits.append(i)\n    return sorted(odd_sum_digits)",
      "def prime_digit_product(x):\n    \"\"\"Given a list of positive integers x, return a sorted list of all \n    _distinct_ elements wherein the product of its digits is a prime number.\n\n    Note: The resulting list should be sorted in ascending order. \n\n    >>> prime_digit_product([15, 33, 1422, 1, 15])\n    [1, 15]\n    >>> prime_digit_product([152, 323, 1422, 10])\n    [323]\n\n    \"\"\"\n    return sorted(set([i for i in x if is_prime(prod([int(d) for d in str(i)]))]))",
      "def odd_sum_elements(x):\n    \"\"\"\n    Accepts a list of positive numbers (x), returning a sorted list comprising unique elements, the sum of whose digits equals an odd number.\n\n    Note: The output list must be sorted in increasing order.\n\n    >>> odd_sum_elements([15, 33, 1422, 1, 15])\n    [1, 15]\n    >>> odd_sum_elements([152, 323, 1422, 10])\n    [323]\n\n    \"\"\"\n    unique_nums = set(x)  # create a set from the list to remove duplicates\n    odd_digits_sum_nums = [num for num in unique_nums if sum(int(digit) for digit in str(num)) % 2 != 0]\n    return sorted(odd_digits_sum_nums)  # return the sorted list",
      "def split_odd_totals(y):\n    \"\"\"In this function, given an array y of positive integers, generate two sorted arrays. One includes \n    _singular_ elements whose sum of their digits is odd and ends with an odd number, and other with \n    elements whose sum of their digits is odd and ends with an even number, both in ascending sequence.\n\n    >>> split_odd_totals([15, 33, 1422, 1, 15])\n    ([1, 15, 33], [1422])\n    >>> split_odd_totals([152, 323, 1422, 10])\n    ([323], [152, 1422])\n    \"\"\"\n\n    odd_ending = []\n    even_ending = []\n\n    for num in y:\n        digit_sum = sum(int(digit) for digit in str(num))\n        \n        if digit_sum % 2 != 0: # sum of digits is odd\n            if num % 2 != 0: # number ends with odd digit\n                odd_ending.append(num)\n            else: # number ends with even digit\n                even_ending.append(num)\n                \n    return sorted(odd_ending), sorted(even_ending)",
      "def unique_odd_digit_sum(x):\n    \"\"\"Given a list of integers x, return a sorted list of unique positive integers that have an odd sum of their digits. The same integer should not appear twice.  \n\n    Sort the final output list in ascending order. \n\n    E.g.:\n    >>> unique_odd_digit_sum([15, 38, 1420, 1, 15])\n    [1]\n    >>> unique_odd_digit_sum([154, 323, 1422, 10])\n    [323]\n    >>> unique_odd_digit_sum([-15, 38, -1420, -1, 15])\n    [15]\n    \"\"\"\n\n    # Create an empty list to store the resulting integers\n    result = []\n\n    # Loop over the input list x\n    for num in x:\n        # Exclude negative numbers\n        if num < 0:\n            continue\n\n        # Calculate the sum of the digits of num\n        digit_sum = sum(int(digit) for digit in str(num))\n\n        # Exclude integers with an even sum of digits\n        if digit_sum % 2 == 0:\n            continue\n\n        # Exclude integers that are already in the result list\n        if num in result:\n            continue\n\n        # Add the integer to the result list\n        result.append(num)\n        \n    return sorted(result)"
    ],
    "HumanEval/105": [
      "def test_bubble_sort():\n    # Empty array\n    arr = []\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != []:\n        print(\"Error: Bubble Sort failed on empty array.\")\n\n    # Array with duplicate values\n    arr = [4, 3, 2, 2, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 2, 3, 4]:\n        print(\"Error: Bubble Sort failed on array with duplicate values.\")\n\n    # Sorted array in descending order\n    arr = [5, 4, 3, 2, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 3, 4, 5]:\n        print(\"Error: Bubble Sort failed on sorted array in descending order.\")\n\n    # Random unsorted array\n    arr = [5, 3, 2, 4, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 3, 4, 5]:\n        print(\"Error: Bubble Sort failed on random unsorted array.\")",
      "def word_to_num(word):\n    word_num = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4, \"five\": 5,\n                \"six\": 6, \"seven\": 7, \"eight\": 8, \"nine\": 9, \"ten\": 10}\n    return word_num[word]",
      "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n    1. Perform rightward shifting operation as required.\n    2. Swap at most three pair of balls.\n    3. After the operations, elements smaller than the first element in the array should be odd in number.\n    \n    Return True, if the array could be sorted; otherwise, False. \n    \n    Examples:\n    move_three_balls([5, 4, 5, 1, 2, 6]) -> True\n    move_three_balls([1, 3, 5, 4, 2, 6]) -> True\n    move_three_balls([1, 2, 3, 5, 4, 6]) -> True\n    move_three_balls([5, 4, 3, 1, 2, 6]) -> False\n    \"\"\"\n    \n    if not arr:\n        return True\n    \n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False",
      "def text_to_number(input_str):\n    num_dict = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9,\n        \"ten\": 10,\n        \"hundred\": 100\n    }\n\n    words = input_str.lower().split(\" \")\n\n    number = 0\n    for i in range(len(words)):\n        if words[i] in num_dict.keys():\n            if words[i] == \"hundred\" and i > 0:\n                number *= num_dict[words[i]]\n            else:\n                number += num_dict[words[i]]\n\n    return number",
      "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n        1. Perform rightward shifting operation as required.\n        2. Swap at most three pair of balls.\n        3. After the operations, elements smaller than the first element in the array should be odd in number.\n\n    Return True, if the array could be sorted, otherwise False. \n\n    Examples:\n    move_three_balls([3, 4, 5, 1, 2, 6]) => True\n    move_three_balls([1, 3, 5, 4, 2, 6]) => True\n    move_three_balls([1, 2, 3, 5, 4, 6]) => True\n    move_three_balls([5, 4, 3, 1, 2, 6]) => False\n\n    \"\"\"\n    if not arr:\n        return True\n\n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False"
    ],
    "HumanEval/106": [
      "def fibfib(n: int):   # Define function fibfib that takes an integer n as an argument.\n    dp = [0]*max(3, n+1)  # Creates a list named dp, with size depending on max of 3 and n+1. Initially all elements are set to 0.\n    dp[0], dp[1], dp[2] = 0, 0, 1  # Set the first three numbers in dp to 0, 0, and 1, respectively.\n    for i in range(3, n+1):  # This loop starts from 3 (as we've already set the values of 0, 1 and 2 index elements) to n+1.\n        dp[i] = dp[i-1] + dp[i-2] + dp[i-3] #  Each new element at index i in dp is set as the sum of the three previous numbers. It suggests the sequence is something like 0, 0, 1, 1, 2, 4, 7, 13, 24 etc.\n    return dp[n]  # Finally, this function returns the nth number in the sequence.",
      "def f(n):\n  # Initialize an empty list\n  result_list = []\n  # Use a for loop that starts at 1 and ends at n\n  for i in range(1, n+1):\n    # Use a conditional statement to check if the number is even\n    if i % 2 == 0:\n      # If the number is even, call the factorial function and append the result to the list\n      result_list.append(factorial(i))\n    else:\n      # If the number is odd, call the sumOfSquare function and append the result to the list\n      result_list.append(sumOfSquare(i))\n  return result_list",
      "def factorial(n=5):\n    \"\"\"\n    Calculate the factorial of a given positive integer.\n\n    Args:\n    n: An optional integer for which the factorial needs to be calculated (default is 5).\n\n    Returns:\n    The factorial of the input integer n.\n    \"\"\"\n    f = 1\n    for i in range(1, n + 1):\n        f *= i\n    return f",
      "def proper_code(*args):\n    \"\"\"\n    Given single or multiple positive integers, check if any of them is a perfect square. \n    If at least one is a perfect square, create and test a function that returns the number of n-digit positive integers that start or end with 1. \n    Also, these numbers must be divisible by any three distinct prime numbers. \n    Return 'Not a perfect square.' if none of them is a perfect square.\n    \"\"\"\n    # Find first three prime numbers\n    primes = list(sympy.primerange(0, 100))[:3]\n    for i in args:\n        if is_perfect_square(i):\n            # n is taken as the number of digits in the first perfect square found\n            n = len(str(i))\n            return num_start_end_with_1(n, primes)\n    return 'Not a perfect square.'",
      "def sum_even_numbers(numbers):\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The sum of all even numbers in the list. Returns 0 if the list is empty or does not contain any even numbers.\n\n    Examples:\n    >>> sum_even_numbers([1, 2, 3, 4, 5, 6])\n    12\n    >>> sum_even_numbers([1, 3, 5, 7])\n    0\n    >>> sum_even_numbers([])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)"
    ],
    "HumanEval/107": [
      "def multiply(lst):\n    \"\"\"Given a populated array of integers, lst, compute the product of all odd numerals located at even indices within the array that are simultaneously multiples of 3. The indices of the array start at 0 (even).\n\n    Illustrative scenario (Correct):\n        multiply([3, 5, 7, 8, 9]) yields 27  \n    \"\"\"\n    result = 1\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 == 1 and lst[i] % 3 == 0:\n            result *= lst[i]\n    return result",
      "def multiply(lst):\n    \"\"\"\n    An array of integers is provided, denoted as 'lst'. Calculate the product of those odd numbers positioned at even locations where these numbers are also multiples of the integer three.\n\n    Example:\n        multiply([3, 5, 7, 8, 9]) yields 27\n    \"\"\"\n    product = 1  # Initialize the product to be 1\n    for i, v in enumerate(lst):\n        if i % 2 == 0 and v % 3 == 0:  # Check if index is even and value divisible by 3\n            product *= v  # multiply product by v\n    return product",
      "def main():\n    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(\"Even numbers from the list are:\")\n    print_numbers(numbers)",
      "def count_even(n):\n    # Check whether given input is valid integer or not\n    if not isinstance(n, int):\n        return \"Error: Input should be an integer\"\n    \n    # handle the cases where n is less than 0\n    if n < 0:\n        return \"Error: Input should be non-negative integer\"\n    \n    # As number at odd indexes are even number in series 0 to n (since 0 is considered even),\n    # by integer division of n by 2, would directly derive count of non-negative even numbers less than n\n    return (n // 2)",
      "def sum_of_even_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers: A list of integers.\n\n    Returns:\n    The sum of all even numbers in the list.\n    \n    Examples:\n    >>> sum_of_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    30\n    >>> sum_of_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_of_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)"
    ],
    "HumanEval/108": [
      "def count_nums(arr):\n    \"\"\"\n    >>> count_nums([]) == 0\n    >>> count_nums([-4, 15, -12]) == 2\n    >>> count_nums([2, 5, -1]) == 0\n    \"\"\"\n    count = 0\n    for num in arr:\n        total = 0\n        num_str = str(num)\n        # if num is negative, start from 2nd character, and subtract the 1st digit (considered as negative)\n        start = 0\n        if num < 0: \n            start = 1\n            total -= int(num_str[1])\n        for digit in num_str[start:]:\n            total += int(digit)\n        if total > 0 and total % 4 == 0:\n            count += 1\n    return count",
      "def count_nums(arr):\n    count = 0\n    for number in arr:\n        digits = map(int, str(abs(number)))\n        digit_sum = sum(digits)\n\n        # consider the leading digit negative if the number itself is negative\n        if number < 0:\n            digit_sum -= 2 * digits[0]\n\n        # check if the sum is both greater than zero and a multiple of 4\n        if digit_sum > 0 and digit_sum % 4 == 0:\n            count += 1\n    return count",
      "def count_nums(arr):\n    nums = []\n    max_sum = float('-inf')\n    max_sum_tuple = (-1, -1)\n\n    # Parsing array for finding relevant numbers\n    for num in arr:\n        temp = str(abs(num))  # Taking absolute for simplicity\n        digits = [int(digit) for digit in temp]\n\n        # Using list slicing [::] minus sign on first digit if original number was negative\n        digits_sum = -digits[0] + sum(digits[1:]) if num < 0 else sum(digits)\n\n        if digits_sum > 0 and digits_sum % 4 == 0:\n            nums.append(num)\n\n            # Check if this pair has the greatest sum so far\n            if len(nums) >= 2 and sum(nums[-2:]) > max_sum:\n                max_sum = sum(nums[-2:])  \n                max_sum_tuple = (nums[-2], nums[-1])\n\n    count = len(nums)\n    return count, max_sum_tuple if max_sum != float('-inf') else (-1, -1)",
      "def split_odd_totals(y):\n    \"\"\"In this function, given an array y of positive integers, generate two sorted arrays. One includes \n    _singular_ elements whose sum of their digits is odd and ends with an odd number, and other with \n    elements whose sum of their digits is odd and ends with an even number, both in ascending sequence.\n\n    >>> split_odd_totals([15, 33, 1422, 1, 15])\n    ([1, 15, 33], [1422])\n    >>> split_odd_totals([152, 323, 1422, 10])\n    ([323], [152, 1422])\n    \"\"\"\n\n    odd_ending = []\n    even_ending = []\n\n    for num in y:\n        digit_sum = sum(int(digit) for digit in str(num))\n        \n        if digit_sum % 2 != 0: # sum of digits is odd\n            if num % 2 != 0: # number ends with odd digit\n                odd_ending.append(num)\n            else: # number ends with even digit\n                even_ending.append(num)\n                \n    return sorted(odd_ending), sorted(even_ending)",
      "def sum_of_squares(arr):\n    \"\"\"Calculate square sum of numbers divisible by 3 or 7.\n    \n    This function takes a list of integers and strings, converting \n    strings to integers where possible, and returns the sum of the squares \n    of all positive elements divisible by either 3 or 7. Non-convertible \n    strings and negative numbers are ignored.\n\n    Args:\n        arr (list): A list containing integers and strings.\n\n    Returns:\n        int: The sum of squares of all positive elements divisible by 3 or 7.\n\n    Examples:\n        >>> sum_of_squares([])\n        0\n        >>> sum_of_squares(['3', 7, -1, '11', 'not-an-int'])\n        58\n        >>> sum_of_squares([4, '9', 7, '3'])\n        130\n    \"\"\"\n    return sum(int(i)**2 for i in arr if str(i).isdigit() and int(i) > 0 and (int(i) % 3 == 0 or int(i) % 7 == 0))"
    ],
    "HumanEval/109": [
      "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n        1. Perform rightward shifting operation as required.\n        2. Swap at most three pair of balls.\n        3. After the operations, elements smaller than the first element in the array should be odd in number.\n\n    Return True, if the array could be sorted, otherwise False. \n\n    Examples:\n    move_three_balls([3, 4, 5, 1, 2, 6]) => True\n    move_three_balls([1, 3, 5, 4, 2, 6]) => True\n    move_three_balls([1, 2, 3, 5, 4, 6]) => True\n    move_three_balls([5, 4, 3, 1, 2, 6]) => False\n\n    \"\"\"\n    if not arr:\n        return True\n\n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False",
      "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n    1. Perform rightward shifting operation as required.\n    2. Swap at most three pair of balls.\n    3. After the operations, elements smaller than the first element in the array should be odd in number.\n    \n    Return True, if the array could be sorted; otherwise, False. \n    \n    Examples:\n    move_three_balls([5, 4, 5, 1, 2, 6]) -> True\n    move_three_balls([1, 3, 5, 4, 2, 6]) -> True\n    move_three_balls([1, 2, 3, 5, 4, 6]) -> True\n    move_three_balls([5, 4, 3, 1, 2, 6]) -> False\n    \"\"\"\n    \n    if not arr:\n        return True\n    \n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False",
      "def advanced_sort(numbers):\n    \"\"\"\n    Given a list 'numbers' with N integers from 1 to 10^6 in random order. Determine if it's possible \n    to sort into non-decreasing order by the following operations:\n        1. Reverse any sublist any number of times.\n        2. Remove one element from the list.\n        3. Swap any two elements once.\n        \n    If possible, return 'True', if not, 'False'. If the list is empty, return 'True'.\n    Also, provide the sequence of operations taken to sort the list.\n\n    \"\"\"\n    N = len(numbers)\n    # If list is empty, return True\n    if N == 0:\n        return True, []\n\n    # If list is already sorted, return True\n    if numbers == sorted(numbers):\n        return True, []\n\n    # Else perform operations\n    i = 0\n    operations = []\n    while i < N - 1:\n        if numbers[i] > numbers[i + 1]:\n            numbers.pop(i)\n            operations.append('Remove ' + str(i))\n            N -= 1\n        else:\n            i += 1\n\n        if numbers == sorted(numbers):\n            return True, operations\n\n    # If after all operations, list is not sorted\n    return False, []",
      "def advanced_sort(numbers):\n    \"\"\"\n    Given a list 'numbers' with N integers from 1 to 10^6 in random order, determine if it's possible \n    to sort into non-decreasing order by the following operations:\n    1. Reverse any sublist any number of times.\n    2. Remove one element from the list.\n    3. Swap any two elements once.\n\n    If possible, return 'True', if not, 'False'. If the list is empty, return 'True'.\n    Also, provide the sequence of operations taken to sort the list.\n    \"\"\"\n    N = len(numbers)\n    # If list is empty, return True\n    if N == 0:\n        return True, []\n\n    # If list is already sorted, return True\n    if numbers == sorted(numbers):\n        return True, []\n\n    # Else perform operations\n    i = 0\n    operations = []\n    while i < N - 1:\n        if numbers[i] < numbers[i + 1]:\n            numbers.pop(i)\n            operations.append('Remove ' + str(i))\n            N -= 1\n        else:\n            i += 1\n\n    if numbers == sorted(numbers):\n        return True, operations\n\n    # If after all operations, list is not sorted\n    return False, []",
      "def insertion_sort(array, left=0, right=None):\n    if right is None:\n        right = len(array) - 1\n\n    # Loop from the left pointer to the right\n    for i in range(left + 1, right + 1):\n        # This is the element we want to position in its correct place\n        key_item = array[i]\n\n        # Initialize the variable that will be used to find the correct position of the element referenced by `key_item`\n        j = i - 1\n\n        # Run through the list of items (the left portion of the array) and find the correct position\n        # of the element referenced by `key_item`. Do this only if `key_item` is smaller than its adjacent values.\n        while j >= left and array[j] > key_item:\n            # Shift the value one position to the right and reposition j to point to the next element (from right to left)\n            array[j + 1] = array[j]\n            j -= 1\n\n        # When we finish shifting the elements, we can position `key_item` in its correct location\n        array[j + 1] = key_item\n\n    return array"
    ],
    "HumanEval/110": [
      "def exchange(lst1, lst2):\n    # Check if total sum of lst1 and lst2 are both even numbers.\n    # If not, return \"NO\" directly because even number of swaps can't make uneven sum to be even.\n    if sum(lst1) % 2 != 0 or sum(lst2) % 2 != 0:\n        return \"No\"\n\n    # If the sum of both lists are even, then check if it's possible to make lst1 to be a list of even numbers.\n    # If an odd number in lst1 is found, then try to find an even number in lst2 to swap. If not found, return \"NO\" directly.\n    for i in range(len(lst1)):\n        if lst1[i] % 2 != 0:\n            has_swap = False\n            for j in range(len(lst2)):\n                if lst2[j] % 2 == 0:\n                    # Swap found, exchange the elements and break the loop.\n                    lst1[i], lst2[j] = lst2[j], lst1[i]\n                    has_swap = True\n                    break\n            if not has_swap:\n                return \"NO\"\n\n    # If all odd numbers in lst1 can find matched even numbers in lst2 to swap, return \"YES\".\n    return \"YES\"",
      "def exchange_with_floats_and_sci_notation(lst1, lst2):\n    \"\"\"\n    Example:\n    exchange([1.5e-1, 2.3e0, 3.7e1, 4.6e2], [1.1e1, 2.3e2, 3.4e-1, 4.5e-2]) => \"YES\"\n    exchange([1.1e2, 2.3e-1, 3.7e-2, 4.6e-3], [1.8e-2, 2.2e-1, 5.4e2, 4.5e1]) => \"NO\"\n    \"\"\"\n    # Change floats and scientific notation numbers to decimal for precise calculation\n    lst1 = [Decimal(str(n)) for n in lst1]\n    lst2 = [Decimal(str(n)) for n in lst2]\n\n    for i in range(len(lst1)):\n        # Convert floating-point numbers to integers by rounding them\n        n1 = round(lst1[i])\n        n2 = round(lst2[i])\n\n        # If both numbers are even or both numbers are odd, no need to swap\n        if (n1 % 2 == 0 and n2 % 2 == 0) or (n1 % 2 == 1 and n2 % 2 == 1):\n            continue\n        \n        # If one number is even and the other is odd, swap them\n        lst1[i], lst2[i] = lst2[i], lst1[i]\n\n    # Check if all numbers in lst1 are even and all numbers in lst2 are odd\n    for i in range(len(lst1)):\n        if round(lst1[i]) % 2 == 1 or round(lst2[i]) % 2 == 0:\n            return \"NO\"\n\n    return \"YES\"",
      "def exchange_with_floats_and_sci_notation(lst1, lst2):\n    \"\"\"\n    Example:\n    exchange([1.1e1, 2.3e0, 3.7e1, 4.6e2], [1.1e1, 2.3e2, 3.4e1, 4.5e2]) -> \"YES\"\n    exchange([1.1e2, 2.3e-1, 3.7e2, 4.6e2], [1.8e2, 2.2e-1, 5.4e2, 4.5e1]) -> \"NO\"\n    \"\"\"\n    # Change floats and scientific notation numbers to decimal for precise calculation\n    lst1 = [Decimal(str(n)) for n in lst1]\n    lst2 = [Decimal(str(n)) for n in lst2]\n\n    for i in range(len(lst1)):\n        # Convert floating-point numbers to integers by rounding them\n        n1 = round(lst1[i])\n        n2 = round(lst2[i])\n\n        # If both numbers are even or both numbers are odd, no need to swap\n        if (n1 % 2 == 0 and n2 % 2 == 0) or (n1 % 2 == 1 and n2 % 2 == 1):\n            continue\n\n        # If one number is even and the other is odd, swap them\n        lst1[i], lst2[i] = lst2[i], lst1[i]\n\n    # Check if all numbers in lst1 are even and all numbers in lst2 are odd\n    for i in range(len(lst1)):\n        if round(lst1[i]) % 2 == 1 or round(lst2[i]) % 2 == 0:\n            return \"NO\"\n\n    return \"YES\"",
      "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact.\n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n    # Separate primes and non-primes in both lists\n    primes1, nonprimes1 = [n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)]\n    primes2, nonprimes2 = [n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)]\n\n    # Check if all non-primes in lst1 can be replaced with primes from lst2\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for i, prime in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            # Replace non-prime with the smallest prime that is greater than it\n            i, prime = min(replaceable, key = lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            # If no prime in lst2 can replace the non-prime in lst1, return \"NO\"\n            return \"NO\"\n\n    # Check if the total sum across both lists remains the same\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return \"NO\"\n\n    return \"YES\"",
      "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n    # Separate primes and non-primes in both lists\n    primes1, nonprimes1 = [n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)]\n    primes2, nonprimes2 = [n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)]\n    \n    # Check if all non-primes in lst1 can be replaced with primes from lst2\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for i, prime in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            # Replace non-prime with the smallest prime that is greater than it\n            i, prime = min(replaceable, key = lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            # If no prime in lst2 can replace the non-prime in lst1, return \"NO\"\n            return \"NO\"\n    \n    # Check if the total sum across both lists remains the same\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return \"NO\"\n    \n    return \"YES\""
    ],
    "HumanEval/111": [
      "def test_create_dict():\n    assert create_dict([\"a\",\"b\",\"c\"]) == {'a': 0, 'b': 5, 'c': 10}\n    assert create_dict([\"a\",\"b\",\"c\",\"a\"]) == {'a': 15, 'b': 5, 'c': 10}\n    assert create_dict([]) == {}\n    print(\"All test cases pass\")",
      "def sum_values(a, b, max_sum=100):\n    if not isinstance(a, (int, float)):\n        raise ValueError(f\"Error: Parameter 'a' must be a number. '{a}' is not a number.\")\n    if not isinstance(b, (int, float)):\n        raise ValueError(f\"Error: Parameter 'b' must be a number. '{b}' is not a number.\")\n    if isinstance(a, str):\n        raise ValueError(f\"Error: Parameter 'a' must be a number. '{a}' is a string.\")\n    if isinstance(b, str):\n        raise ValueError(f\"Error: Parameter 'b' must be a number. '{b}' is a string.\")\n    if a + b > max_sum:\n        raise ValueError(f\"Error: Sum of parameters exceeds the maximum allowed sum of {max_sum}.\")\n    return a + b",
      "def advanced_subword_check(a , b):\n    from collections import Counter\n\n    # Check if string b or its rotations are subwords in string a\n    for i in range(len(b)):\n        if b in a:\n            print(f\"'{b}' is a subword of '{a}'\")\n            return\n        else:\n            b = b[1:] + b[0]\n\n    # Check if string b can become a subword of string a\n    # by rearranging all its letters in any order\n    counterA = Counter(a)\n    counterB = Counter(b)\n    \n    for letter, count in counterB.items():\n        if letter not in counterA.keys() or count > counterA[letter]: # if letter of b is not in a or count is more than in a\n            print(f\"After rearranging, '{b}' cannot be a subword of '{a}'\")\n            return\n    \n    print(f\"After rearranging, '{b}' can be a subword of '{a}'\")",
      "def generate_dictionary(a, b, c):\n    # Check if the values are integers\n    if not all(value.isdigit() for value in (a, b, c)):\n        raise ValueError(\"All values must be integers\")\n\n    # Convert values to integers\n    a, b, c = int(a), int(b), int(c)\n\n    # Check if the values are prime numbers\n    if not all(is_prime(value) for value in (a, b, c)):\n        raise ValueError(\"All values must be prime numbers\")\n\n    # Check if the values are palindromic numbers\n    if not all(is_palindrome(value) for value in (a, b, c)):\n        raise ValueError(\"All values must be palindromic numbers\")\n\n    # Generate and return the dictionary\n    return {'a': a, 'b': b, 'c': c}",
      "def triangle_type(a, b, c):\n    '''This function detects triangle types (equilateral, isosceles, or scalene).'''\n    if a == b and b == c:\n        return 'equilateral'\n    elif a == b or b == c or a == c:\n        return 'isosceles'\n    else: \n        return 'scalene'"
    ],
    "HumanEval/112": [
      "def convert_to_camel_case(s):\n    # Remove leading and trailing separators\n    s = s.strip(' -_')\n\n    # Initialize an empty result string\n    result = \"\"\n\n    # Variable to track if the next character should be capitalized\n    capitalize_next = False\n\n    # Iterate through each character in the string\n    for i, c in enumerate(s):\n        # If the current character is a separator, mark the next character to be capitalized\n        if c in ' -_':\n            capitalize_next = True\n        # If the current character is a letter or a digit, add it to the result string\n        elif c.isalpha() or c.isdigit():\n            # If the current character should be capitalized, convert it to uppercase\n            if capitalize_next:\n                result += c.upper()\n                capitalize_next = False\n            # Otherwise, add it as it is\n            else:\n                result += c\n\n    return result",
      "def string_validator(s):\n    count_upper = sum(1 for c in s if c.isupper())\n    count_digits = sum(1 for c in s if c.isdigit())\n    special_chars = \"!?_@\"\n    errors = []\n    if not 8 <= len(s) <= 12:\n        errors.append(\"Length should be between 8 and 12 characters\")\n    if count_upper < 2:\n        errors.append(\"Should contain at least 2 upper-case letters\")\n    if count_digits < 2:\n        errors.append(\"Should contain at least 2 digits\")\n    if not all(c in special_chars for c in s if not c.isalnum()):\n        errors.append(\"Only special characters allowed are !, ?, _, @\")\n    \n    if not errors: \n        return True\n    else: \n        print(f\"Failure for string '{s}': {', '.join(errors)}\")\n        return False",
      "def advanced_array_aggregation(lst, reverse=False):\n    \"\"\"\n    This function accepts a list of strings, filters the list by dropping strings of odd length or containing numbers,\n    and returns a sorted list based on the following criteria:\n    = All list entries must be strings; no grouping of numbers allowed\n    = Duplicates in the list are possible\n    = List is sorted in ascending order based on word length, and then alphabetically for words of the same length\n    = Ignore capitalization and special characters during sorting\n    Additionally, sorting order can be switched by initializing an optional logical 'reverse' parameter.\n\n    Furthermore, the function should also check for characters that appear more than twice in a single string and\n    discard these strings from the list.\n    \"\"\"\n\n    # We filter the strings of odd length or containing numbers\n    filtered = [s for s in lst if len(s) % 2 == 0 and not any(c.isdigit() for c in s)]\n    \n    # We check for characters that appear more than twice in a single string and discard these strings\n    filtered = [s for s in filtered if all(v <= 2 for v in Counter(s).values())]\n    \n    # Ignore capitalization and special characters during sorting\n    filtered = [\"\".join(ch for ch in s if ch.isalnum()) for s in filtered]\n    filtered = [s.lower() for s in filtered]\n\n    # Add some complexity by sorting the list according to length, and then by lexical order\n    filtered = sorted(filtered, key=lambda s: (len(s), s) , reverse=reverse)\n    \n    return filtered",
      "def is_palindrome(s):\n    \"\"\"\n    Checks if the given string is a palindrome\n\n    :param s: the string to be checked\n    :returns: True if the string is a palindrome, False otherwise\n    \"\"\"\n    # remove all non-alphanumeric characters\n    s = ''.join([c for c in s if c.isalnum()])\n    # convert to lower case\n    s = s.lower()\n    # compare reversed string to the original\n    return s == s[::-1]",
      "def encrypt(s, shift, seed=0):\n    \"\"\"Create a function named encrypt that accepts two parameters, a string and an integer for rotation. The function should return an encrypted string using a shuffled alphabet based on the input integer. It should handle case sensitivity and preserve non-alphabetic characters. It should also handle exceptions due to rotations exceeding the length of the alphabet.\"\"\"\n\n    # Define alphabet\n    lower_alphabet = string.ascii_lowercase\n    upper_alphabet = string.ascii_uppercase\n\n    # Introduce seed manipulation for more complexity\n    shift = (shift + seed) % 26\n\n    result = \"\"\n\n    for c in s:\n        # Support for unicode characters\n        if not c.isascii():\n            result += chr(ord(c) + shift)\n        # Preserve non-alphabetical characters\n        elif not c.isalpha():\n            result += c\n        else:\n            # Handle upper/lower-case characters differently for case sensitivity\n            if c.isupper():\n                result += upper_alphabet[(upper_alphabet.index(c) + shift) % 26]\n            else:\n                result += lower_alphabet[(lower_alphabet.index(c) + shift) % 26]\n\n    return result"
    ],
    "HumanEval/113": [
      "def unusual_addition(lst):\n    \"\"\"This function accepts a list solely made up of strings containing numerical digits only and returns a list.\n    In the output, for each element, replace the 'i' with the true count of odd digits and 'e' with the true count of even digits in \n    the i'th string from the input.\n\n    >>> unusual_addition(['1234567'])\n    [\"the number of odd elements 4n the str3ng 3 of the 4nput.\"]\n    >>> unusual_addition(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str0ng 0 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for idx, str in enumerate(lst):\n        odd_count = sum(1 for s in str if int(s) % 2 != 0)\n        even_count = sum(1 for s in str if int(s) % 2 == 0)\n        replace_string = f\"the number of odd elements {odd_count}n the str{even_count}ng {even_count} of the {odd_count}nput.\"\n        output.append(replace_string)\n\n    return output",
      "def unusual_addition(lst):\n    \"\"\"Provided with a list, purely made up of strings containing numerical figures, deliver a return list.\n    Each index 'i' and the sum 's' of odd elements present in the i'th string of input, should transform into the actual sum of odd digits and their sum's square root respectively; also return the cumulative sum of all the peculiar digits.\n\n    >>> unusual_addition(['1234567'])\n    [\"the number of odd elements 4n the str4ng sqrt(4) of the 4nput.\", round(4**0.5), 16]\n    >>> unusual_addition(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng sqrt(1) of the 1nput.\", round(1**0.5), 3,\n     \"the number of odd elements 8n the str8ng sqrt(8) of the 8nput.\", round(8**0.5), 8]\n    \"\"\"\n    result = []\n    total = 0\n    for i in range(len(lst)):\n        sum_odds = sum([int(c) for c in lst[i] if int(c) % 2 == 1])\n        total += sum_odds\n        result.append(\"the number of odd elements %dn the str%2sng %d of the %dnput.\" % (sum_odds, \"sqrt(\"+str(sum_odds)+\")\", i, total))\n        result.append(round(sum_odds**0.5))\n        result.append(total)\n    return result",
      "def unusual_addition(lst):\n    \"\"\"\n    This function accepts a list solely made up of strings containing numerical digits only and returns a list.\n    In the output, for each element, replace the '1' with the true count of odd digits and 'e' with the true count of even digits in\n    the nth string from the input.\n\n    >>> unusual_addition(['1234567'])\n    [\"the number of odd elements are 3 of the string 1 of the input.\"]\n    >>> unusual_addition(['3', \"1111111\"])\n    [\"the number of odd elements are 1 of the string 1 of the input.\",\n    \"the number of odd elements are 7 of the string 0 of the input.\"]\n    \"\"\"\n    output = []\n    for idx, string in enumerate(lst):\n        odd_count = sum(1 for s in string if int(s) % 2 != 0)\n        even_count = sum(1 for s in string if int(s) % 2 == 0)\n        replace_string = f\"the number of odd elements are {odd_count} of the string {even_count} of the input\"\n        output.append(replace_string)\n\n    return output",
      "def unusual_addition(lst: list) -> list:\n    \"\"\"\n    Given a list consisting only of strings with numerical characters, return a list.\n    Each 'i' in the output statement for each element, \"+he number of odd elements present in the\n    i'th input string,\", should be replaced with the actual count of odd numbers.\n    \"\"\" \n    results = []\n\n    for i, string in enumerate(lst):\n\n        totals = [0, 0]  # [total odd_numbers, total_even_numbers]\n\n        # Count number of odd and even numbers within the string\n        for char in string:\n            if int(char) % 2 == 0:\n                totals[1] += 1\n            else:\n                totals[0] += 1\n\n        totals = [num**2 for num in totals]  # Square of counts\n\n        odd_squares = {el for el in range(totals[0])}\n        even_squares = [el for el in range(totals[1])]\n\n        odd_square_totals = sum([num**2 for num in odd_squares])\n        even_square_totals = sum([num**2 for num in even_squares])\n\n        output_string = f\"The number of odd elements {odd_square_totals} in the string {string} of the input.\"\n        results.append(output_string)\n\n    return results",
      "def ascii_check(lst):\n    \"\"\"\n    This function accepts a list of strings, returning a string indicating the count of ASCII characters in every individual string in the list. Each response should be part of a list, stating \"the number of ASCII characters in the i'th input string\" - \"i\" should be replaced with the actual count of ASCII characters present.\n    \n    >>> ascii_check(['Test%$','ASCII@!'])\n    [\"the number of ASCII characters is 6 in the string 1 of the input.\",\n     \"the number of ASCII characters is 7 in the string 2 of the input.\"]\n    >>> ascii_check(['123#','Hello_*'])\n    [\"the number of ASCII characters is 4 in the string 1 of the input.\",\n     \"the number of ASCII characters is 7 in the string 2 of the input.\"]\n    \"\"\"\n    result = []\n    for i, string in enumerate(lst, 1):\n        ascii_count = len([char for char in string if ord(char) < 128])\n        result.append(\"the number of ASCII characters is {} in the string {} of the input.\".format(ascii_count, i))\n    return result"
    ],
    "HumanEval/114": [
      "def test_unique_elements():\n    # Test case 1: Empty array\n    assert unique_elements([]) == []\n\n    # Test case 2: Array with all elements being the same\n    assert unique_elements([5, 5, 5, 5, 5]) == [5]\n\n    # Test case 3: Array with mix of positive and negative integers\n    assert unique_elements([1, 2, 3, 4, 5, 4, 3, 2, 1, -1, -2, -3, -4, -5]) == [1, 2, 3, 4, 5, -1, -2, -3, -4, -5]\n\n    # Test case 4: Array with no repeated elements\n    assert unique_elements([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\n    print(\"All test cases pass\")",
      "def uncommon_elements(sequence):\n    '''\n    Design a function that accepts a non-empty list composed of positive integers and returns a list of distinct integers whose frequency surpasses half of the integer's numerical value. Here, 'frequency' denotes the number of times a specific integer appears within the list.\n    If no integers satisfy these conditions, the function should return an empty list.\n    Examples:\n        uncommon_elements([4, 1, 2, 2, 3, 1]) should yield [2, 3]\n        uncommon_elements([1, 2, 2, 3, 3, 3, 4, 4, 4]) should yield [2, 3, 4]\n        uncommon_elements([5, 5, 4, 4, 4]) should yield [4]\n    '''\n    from collections import Counter\n    count = Counter(sequence)\n    result = []\n    for num, freq in count.items():\n        if freq > num/2:\n            result.append(num)\n    return result",
      "def rolling_max(numbers1: List[int], numbers2: List[int]) -> Tuple[List[int], List[int]]:\n    \"\"\" From two given lists of integers, generate a list of rolling maximum element found until given moment \n    in the sequence and store them as maximum of each list.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2], [1, 4, 2, 4, 1, 5, 1])\n    ([1, 2, 3, 3, 3, 4, 4], [1, 4, 4, 4, 4, 5, 5])\n    \"\"\"\n    pass  # Your implementation here",
      "def sort_by_binary_len(arr):\n    \"\"\"\n    Rearrange an array of non-negative integers considering the lengths \n    of their binary notations. Sort the numbers by their decimal values \n    in case of binary length matches. \n\n    The expected output will be: \n    >>> sort_by_binary_len([1, 31, 15, 2, 7]) == [1, 2, 7, 15, 31]\n    >>> sort_by_binary_len([14, 58, 39, 41, 61]) == [14, 39, 41, 58, 61]\n    >>> sort_by_binary_len([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    \"\"\"\n    \n    sorted_arr = sorted(arr, key=lambda x: (bin(x)[2:].zfill(8), x))\n    return sorted_arr",
      "def enhanced_solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are at even positions.    \n\n    Examples\n    enhanced_solution([5, 8, 7, 1]) => 5\n    enhanced_solution([3, 3, 3, 3, 3]) => 9\n    enhanced_solution([30, 13, 24, 321]) => 30\n    \"\"\"\n    return sum(num for i, num in enumerate(lst[::2]) if num % 2 == 1)"
    ],
    "HumanEval/115": [
      "def minesweeper(grid):\n    # Get the grid size.\n    n, m = len(grid), len(grid[0])\n\n    # Initialize an output grid with all values set to 0.\n    output = [[0]*m for _ in range(n)]\n\n    # Loop over each cell in the grid.\n    for i in range(n):\n        for j in range(m):\n\n            # If the cell is a mine, mark it as such in the output.\n            if grid[i][j] == '#':\n                output[i][j] = '#'\n                continue\n\n            # Check the neighboring cells.\n            for dx in [-1, 0, 1]:\n                for dy in [-1, 0, 1]:\n                    # If the neighbor is within the grid and it is a mine, \n                    # increment the output value of the current cell.\n                    if 0 <= i+dx < n and 0 <= j+dy < m and grid[i+dx][j+dy] == '#':\n                        output[i][j] += 1\n\n            # Convert the count to string.\n            output[i][j] = str(output[i][j])\n    # Return the output grid.\n    return output",
      "def well_emptying(grid, capacity):\n    # Get the number of rows and columns in the grid\n    rows, cols = len(grid), len(grid[0])\n\n    # Initialize the number of bucket lowerings to 0\n    lowerings = 0\n\n    # Iterate over the rows in the grid\n    for i in range(rows):\n        # Initialize the remaining capacity of the bucket\n        remaining_capacity = capacity\n\n        # Iterate over the columns in the row\n        for j in range(cols):\n            # If the current well has water\n            if grid[i][j] == 1:\n                # Decrease the remaining capacity of the bucket\n                remaining_capacity -= 1\n\n                # If the bucket is full, empty it and reset the capacity\n                if remaining_capacity == 0:\n                    lowerings += 1\n                    remaining_capacity = capacity\n\n        # If the bucket has water after finishing a row, empty it\n        if remaining_capacity != capacity:\n            lowerings += 1\n\n    return lowerings",
      "def minPath(grid: List[List[int]], k: int) -> List[int]:\n    if not isinstance(grid, list) or not all(isinstance(i, list) for i in grid):\n        return \"Invalid input. Input has to be a 2D grid.\"\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n*n:\n        return \"Invalid input. K has to be an integer and within range.\"\n    if any(not isinstance(i, int) for sublist in grid for i in sublist):\n        return \"Invalid input. Grid should only contain integers.\"\n\n    heap = [(grid[0][0], (0, 0))]   \n    sumCache = {(0, 0): grid[0][0]}   \n    pathCache = {(0, 0): [grid[0][0]]} \n\n    while heap:\n        curvalue, (curi, curj) = heapq.heappop(heap)\n        for nexti, nextj in getNeighbors(curi, curj, n):\n            newSum = sumCache[(curi, curj)] + grid[nexti][nextj]\n            newPath = pathCache[(curi, curj)] + [grid[nexti][nextj]]\n            if len(newPath) > k:   \n                continue\n            if (nexti, nextj) not in sumCache or newSum < sumCache[(nexti, nextj)]:\n                sumCache[(nexti, nextj)] = newSum\n                heapq.heappush(heap, [newSum, (nexti, nextj)])\n                pathCache[(nexti, nextj)] = newPath\n    return min((path for path in pathCache.values() if len(path)==k), key=sum)",
      "def move_character(grid, commands):\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    treasures = sum(row.count('T') for row in grid)\n    character_position = [(i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == 'C'][0]\n\n    for command in commands:\n        new_row = character_position[0] + directions[command][0]\n        new_col = character_position[1] + directions[command][1]\n\n        if 0 <= new_row < len(grid) and 0 <= new_col < len(grid[0]):\n            if grid[new_row][new_col] == 'T':\n                treasures -= 1\n            elif grid[new_row][new_col] == 'O':\n                return \"Game over!\"\n            grid[character_position[0]][character_position[1]] = '.'\n            grid[new_row][new_col] = 'C'\n            character_position = (new_row, new_col)\n\n        if treasures == 0:\n            return \"You win!\"\n\n    return \"You lose!\"",
      "def minTimeToEmptyWells(grid, bucket_capacity):\n    count = [0] * len(grid[0])\n    for row in grid:\n        for j in range(len(row)):\n            count[j] += row[j]\n    count.sort()\n\n    time = 0\n    while count:\n        i = len(count) - 1\n        while i >= 0 and count[i] > 0:\n            count[i] -= bucket_capacity\n            i -= 1\n        count = [x for x in count if x > 0]\n        time += 1\n\n    return time - 1 if len(grid[0]) > bucket_capacity else time"
    ],
    "HumanEval/116": [
      "def test_unique_elements():\n    # Test case 1: Empty array\n    assert unique_elements([]) == []\n\n    # Test case 2: Array with all elements being the same\n    assert unique_elements([5, 5, 5, 5, 5]) == [5]\n\n    # Test case 3: Array with mix of positive and negative integers\n    assert unique_elements([1, 2, 3, 4, 5, 4, 3, 2, 1, -1, -2, -3, -4, -5]) == [1, 2, 3, 4, 5, -1, -2, -3, -4, -5]\n\n    # Test case 4: Array with no repeated elements\n    assert unique_elements([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\n    print(\"All test cases pass\")",
      "def get_positive_and_sort(l: list):\n    \"\"\"Return only positive numbers in the list, sorted in ascending order.\n    >>> get_positive_and_sort([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive_and_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n\n    return sorted([num for num in l if num > 0])",
      "def sort_by_binary_len(arr):\n    \"\"\"\n    Reorders an array of strictly positive integers according to\n    the length of their binary representations, in increasing order.\n    In instances of overlapping binary lengths, the array uses\n    decimal numerical values as the basis for establishing order.\n\n    The output produced should conform to the examples provided:\n    >>> sort_by_binary_len([1, 31, 15, 2, 7]) == [1, 2, 7, 15, 31]\n    >>> sort_by_binary_len([14, 58, 39, 41, 61]) == [14, 39, 41, 58, 61]\n    >>> sort_by_binary_len([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n\n    # Sort the array based on binary length and then value\n    return sorted(arr, key = lambda x: (bin(x)[2:], x))",
      "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n\n    result = []\n    for num in l:\n        if num > 0:\n          result.append(num)\n    return result",
      "def get_positive_and_sort(n: list):\n    \"\"\"\n    Discard only the positive numbers in the list and arrange them in incremental order.\n    >>> get_positive_and_sort([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive_and_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n\n    positive_nums = [num for num in n if num > 0]  # Filter out positive numbers.\n    return sorted(positive_nums)  # Sort the positive numbers."
    ],
    "HumanEval/117": [
      "def print_lyrics():\n    print(\"Mary had a little lamb, its fleece was white as snow;\")\n    print(\"And everywhere that Mary went, the lamb was sure to go.\")\n    print(\"It followed her to school each day, t'was even known to play;\")\n    print(\"And all the children shouted out, 'Oh, Mary, what a lamb!' \")",
      "def decode_cyclic(s: str):\n    \"\"\"\n    A function that handles a string encoded with the mischievous encode_cyclic function and returns the decoded string, handling singular characters, empty spaces, and punctuation.\n    \"\"\"\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)",
      "def all_prefixes_with_lengths(string: str) -> List[Tuple[str, int]]:\n    \"\"\" \n    Function that returns a list of tuples which include all prefixes of an input string from smallest to largest and their corresponding lengths\n    E.g. all_prefixes_with_lengths('abc') should return [('a', 1), ('ab', 2), ('abc', 3)]\n    \"\"\"\n    return [(string[:i], i) for i in range(1, len(string)+1)]",
      "def decode_cyclic(s: str):\n    \"\"\"\n    Should handle a string encoded with the encode_cyclic function and return the decoded string,\n    managing singular characters, empty spaces, and punctuation.\n    \"\"\"\n    groups = [s[3 * i:min(3 * i + 3, len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [group[-1] + group[:-1] if len(group) == 3 else group for group in groups]\n\n    return \"\".join(groups)",
      "def decode_cyclic(s: str):\n    \"\"\"\n    should handle a string encoded with the encode_cyclic function and return the decoded string, managing singular characters, empty spaces, and punctuation.\n    \"\"\"\n\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n\n    return \"\".join(groups)"
    ],
    "HumanEval/118": [
      "def get_closest_vowel(word):\n    \"\"\"Input a word and then find out the vowel closest from the right side of the word that is \n    between two consonants, distinguishing between upper and lower case. Ignore vowels at the \n    beginning or end of the word. If this kind of vowel does not exist, return an empty string. \n    Assume that the input string only contains English letters.\n\n    Examples:\n    get_closest_vowel(\"yogurt\") => \"u\"\n    get_closest_vowel(\"FULL\") => \"U\"\n    get_closest_vowel(\"quick\") => \"\"\n    get_closest_vowel(\"ab\") => \"\"\n    \"\"\"\n\n    # First, strip any vowels from the beginning and end of the word,\n    while len(word) > 0 and (word[0] in 'aeiouAEIOU' or word[-1] in 'aeiouAEIOU'):\n        if word[0] in 'aeiouAEIOU':\n            word = word[1:]\n\n        if len(word) > 0 and word[-1] in 'aeiouAEIOU':\n            word = word[:-1]\n\n    # Then, find the closest vowel sequence from the right side,\n    for i in range(len(word)-1, -1, -1):\n        if word[i] in 'aeiouAEIOU':\n            return word[i]\n    return \"\"",
      "def get_closest_vowel(word):\n    \"\"\"Insert a word, and then retrieve the nearest vowel that is ensconced amid a pair of consonants, \n    starting from the right section of the word, while being case-sensitive. \n    Bypass vowels at either the genesis or finale of the word. \n    Respond with a vacant string if such a vowel is nonexistent. \n    Presume that the input string is comprised strictly of English letters.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\n\n    vowels = 'aeiouAEIOU'\n    for i in reversed(range(1, len(word) - 1)): #not including the first and the last characters\n        if (word[i] in vowels) and (word[i - 1] not in vowels) and (word[i + 1] not in vowels):\n            return word[i]\n    return ''",
      "def get_closest_vowel(word):\n    \"\"\"\n    Enter a word, proceeding to pinpoint the nearest vowel nestled between a \n    dual of consonants, initiating from the right portion of the word, whilst \n    honoring case-sensitivity. Overlook vowels situated at the word's inception \n    or termination. Relay an unoccupied string if such a character is absent. \n    Assume the input string to be constituted exclusively of English alphabets.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    for i in range(len(word) - 1, 0, -1):\n        if word[i] in vowels and word[i-1] not in vowels and word[i+1] not in vowels:\n            return word[i]\n    return \"\"",
      "def get_first_consonant_flanked_vowel(word):\n    \"\"\"Given a word, find the first vowel that is enclosed by consonants from the left side of the word (case sensitive). Do not include vowels at the initiation or cessation of the word. Return an empty string if no such vowel found. The input string must only have English characters.\n\n    Example:\n    get_first_consonant_flanked_vowel(\"umbrella\") ==> \"e\"\n    get_first_consonant_flanked_vowel(\"STRONG\") ==> \"O\"\n    get_first_consonant_flanked_vowel(\"grape\") ==> \"a\"\n    get_first_consonant_flanked_vowel(\"fly\") ==> \"\"\n    \"\"\"\n    vowels = 'AEIOUaeiou'\n    for i in range(1, len(word) - 1):  # Skip first and last characters\n        if word[i] in vowels and word[i - 1] not in vowels:\n            return word[i]\n    \n    return \"\"  # Return empty string if no vowel found",
      "def get_first_consonant_flanked_vowel(word):\n    \"\"\"\n    Given a word, find the first vowel that is enclosed by consonants from the left side of the word (case sensitive). \n    Do not include vowels at the initiation or cessation of the word. \n    Return an empty string if no such vowel found. \n    The input string must only have English characters.\n\n    Example:\n    get_first_consonant_flanked_vowel(\"umbrella\") --> \"e\"\n    get_first_consonant_flanked_vowel(\"STRONG\") --> \"O\"\n    get_first_consonant_flanked_vowel(\"grape\") --> \"a\"\n    get_first_consonant_flanked_vowel(\"fly\") --> \"\"\n    \"\"\"\n    vowels = 'AEIOUaeiou'\n\n    for i in range(1, len(word) - 1):  # Skip first and last characters\n        if word[i] in vowels and word[i - 1] not in vowels:\n            return word[i]\n\n    return \"\"  # Return empty_string if no vowel found"
    ],
    "HumanEval/119": [
      "def advanced_bracket_sequence(arr):\n    '''\n    Accepting an array of minimum two singular strings containing only open parentheses '(',\n    closing parentheses ')', open curly braces '{' and closing curly braces '}'. \n    The function ought to determine if a possible concatenation sequence exists, \n    that when assembled results in a string with accurately nested brackets. \n    For example, '(()){}' is a valid sequence, while '()){)' isn't.\n    The function returns 'Yes' for a possible sequence, or 'No' otherwise.\n\n    Examples:\n    advanced_bracket_sequence(['(', ')(){', '((']) == 'Yes'\n    advanced_bracket_sequence([')', ')', '(', '{', '}', '(', '{']) == 'No'\n    '''\n    bracket_types = {'(': ')', '{': '}'}\n    open_brackets, closed_brackets = [], []\n\n    for cell in arr:\n        for char in cell:\n            if char in bracket_types:\n                open_brackets.append(char)\n            else:\n                if len(open_brackets) == 0:\n                    return 'No'\n                else:\n                    if bracket_types[open_brackets[-1]] == char:\n                        open_brackets.pop()\n                    else:\n                        return 'No'\n            \n    if len(open_brackets) > 0:\n        return 'No'\n\n    return 'Yes'",
      "def advanced_bracket_sequence(arr):\n    '''\n    Accepting an array of minimum two singular strings containing only open parentheses '(',\n    closing parentheses ')', open curly braces '{' and closing curly braces '}'.\n    The function ought to determine if a possible concatenation sequence exists \n    that when assembled results in a string with accurately nested brackets.\n    For example, '[()]{}' is a valid sequence, while '[(])(){' isn't.\n    The function returns 'Yes' for a possible sequence, or 'No' otherwise.\n    \n    Examples:\n    advanced_bracket_sequence(['(', ')(){', '((']) == 'Yes'\n    advanced_bracket_sequence([']', ')', '(', '{', '}', '(', '(']) == 'No'\n    '''\n    bracket_types = {'(': ')', '{': '}'}\n    open_brackets, closed_brackets = [], []\n\n    for cell in arr:\n        for char in cell:\n            if char in bracket_types:\n                open_brackets.append(char)\n            else:\n                if len(open_brackets) == 0:\n                    return 'No'\n                else:\n                    if bracket_types[open_brackets[-1]] == char:\n                        open_brackets.pop()\n                    else:\n                        return 'No'\n\n    if len(open_brackets) > 0:\n        return 'No'\n\n    return 'Yes'",
      "def match_braces(lst):\n    # Concatenate all the parentheses into a single string\n    opening_parentheses = ['(', '[']\n    closing_parentheses = [')', ']']\n    stack = []\n    s = ''.join(lst)\n    for i in s:\n        # If the character is an opening parentheses, push it onto the stack\n        if i in opening_parentheses:\n            stack.append(i)\n        # If the character is a closing parentheses, check if it matches with the last opening parentheses on the stack\n        elif i in closing_parentheses:\n            # If the stack is empty or there is no match, return 'No'\n            if not stack or opening_parentheses.index(stack.pop()) != closing_parentheses.index(i):\n                return 'No'\n    # If there are still unmatched opening parentheses in the stack, return 'No'\n    if stack:\n        return 'No'\n    return 'Yes'",
      "def check_nested_sequences(sequence):\n    '''\n    This function should take a string consisting of '(' and ')' characters, and check whether the parentheses in the string are correctly nested.\n    That is, each '(' must be eventually followed by a ')', and at any point in the string, there cannot be more ')' characters \n    preceding than '(' characters.\n    If the string is correctly nested, it should return 'Yes'. Otherwise, it should return 'No'.\n    '''\n    stack = []\n    for char in sequence:\n        if char == '(':\n            stack.append(char)\n        elif char == ')' and len(stack) > 0:\n            stack.pop()\n        else:\n            return 'No'\n    return 'Yes' if not stack else 'No'",
      "def check_nested_sequences(sequence):\n    '''\n    This function should take a string consisting of '(' and ')' characters, and check whether the parentheses in the string are correctly nested,\n    That is, each '(' must be eventually followed by a ')', and at any point in the string, there cannot be more ')' characters \n    preceding than '(' characters.\n    If the string is correctly nested, it should return 'Yes'. otherwise, it should return 'No'.\n    '''\n    stack = []\n    for char in sequence:\n        if char == '(':\n            stack.append(char)\n        elif char == ')' and len(stack) > 0:\n            stack.pop()\n        else:\n            return 'No'\n    return 'Yes' if not stack else 'No'"
    ],
    "HumanEval/120": [
      "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n        1. Perform rightward shifting operation as required.\n        2. Swap at most three pair of balls.\n        3. After the operations, elements smaller than the first element in the array should be odd in number.\n\n    Return True, if the array could be sorted, otherwise False. \n\n    Examples:\n    move_three_balls([3, 4, 5, 1, 2, 6]) => True\n    move_three_balls([1, 3, 5, 4, 2, 6]) => True\n    move_three_balls([1, 2, 3, 5, 4, 6]) => True\n    move_three_balls([5, 4, 3, 1, 2, 6]) => False\n\n    \"\"\"\n    if not arr:\n        return True\n\n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False",
      "def test_bubble_sort():\n    # Empty array\n    arr = []\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != []:\n        print(\"Error: Bubble Sort failed on empty array.\")\n\n    # Array with duplicate values\n    arr = [4, 3, 2, 2, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 2, 3, 4]:\n        print(\"Error: Bubble Sort failed on array with duplicate values.\")\n\n    # Sorted array in descending order\n    arr = [5, 4, 3, 2, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 3, 4, 5]:\n        print(\"Error: Bubble Sort failed on sorted array in descending order.\")\n\n    # Random unsorted array\n    arr = [5, 3, 2, 4, 1]\n    sorted_arr = bubble_sort(arr)\n    if sorted_arr != [1, 2, 3, 4, 5]:\n        print(\"Error: Bubble Sort failed on random unsorted array.\")",
      "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n    1. Perform rightward shifting operation as required.\n    2. Swap at most three pair of balls.\n    3. After the operations, elements smaller than the first element in the array should be odd in number.\n    \n    Return True, if the array could be sorted; otherwise, False. \n    \n    Examples:\n    move_three_balls([5, 4, 5, 1, 2, 6]) -> True\n    move_three_balls([1, 3, 5, 4, 2, 6]) -> True\n    move_three_balls([1, 2, 3, 5, 4, 6]) -> True\n    move_three_balls([5, 4, 3, 1, 2, 6]) -> False\n    \"\"\"\n    \n    if not arr:\n        return True\n    \n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False",
      "def quicksort(arr):\n    \"\"\"\n    Sorts the input array in-place using the Quicksort algorithm with duplicate handling.\n    \"\"\"\n    if len(arr) <= 1:\n        return\n    # Choose two pivot elements\n    pivot1, pivot2 = arr[0], arr[-1]\n    i, j = 0, len(arr) - 1\n    k = 0\n    while k <= j:\n        if arr[k] < pivot1:\n            arr[i], arr[k] = arr[k], arr[i]\n            i += 1\n            k += 1\n        elif arr[k] > pivot2:\n            arr[j], arr[k] = arr[k], arr[j]\n            j -= 1\n        else:\n            k += 1\n    # Recursively sort the first and third sub-arrays\n    quicksort(arr[:i])\n    quicksort(arr[j+1:])",
      "def max_subarray_sum(arr, k):\n    length = len(arr)\n    # Handling edge cases\n    if not arr or length < k:\n        return \"Invalid input\"\n    if length == k and all(i < 0 for i in arr):\n        return \"All numbers in the array are negative\"\n    \n    # Create and initialize variables\n    window_sum, max_sum = sum(arr[:k]), sum(arr[:k])\n    start_index = 0\n    \n    # Slide the window\n    for i in range(k, length):\n        window_sum = window_sum - arr[i - k] + arr[i]\n        if window_sum > max_sum:\n            max_sum = window_sum\n            start_index = i - k + 1\n    end_index = start_index + k - 1\n    \n    # Return maximum sum and start and end index of that subarray\n    return max_sum, start_index, end_index"
    ],
    "HumanEval/121": [
      "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)",
      "def enhanced_solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are at even positions.    \n\n    Examples\n    enhanced_solution([5, 8, 7, 1]) => 5\n    enhanced_solution([3, 3, 3, 3, 3]) => 9\n    enhanced_solution([30, 13, 24, 321]) => 30\n    \"\"\"\n    return sum(num for i, num in enumerate(lst[::2]) if num % 2 == 1)",
      "def sum_even_numbers(numbers):\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The sum of all even numbers in the list.\n\n    Examples:\n    >>> sum_even_numbers([1, 2, 3, 4, 5, 6])\n    12\n    >>> sum_even_numbers([10, 11, 12, 13, 14, 15])\n    36\n    >>> sum_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)",
      "def sum_of_even_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers: A list of integers.\n\n    Returns:\n    The sum of all even numbers in the list.\n    \n    Examples:\n    >>> sum_of_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    30\n    >>> sum_of_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_of_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)",
      "def solve_system():\n    # System of Equations\n    A = np.array([[5, -2, 3], \n                  [2, 1, -1], \n                  [-1, 3, 1]])\n    B = np.array([11, 8, -2])\n    # Solving the System\n    solution = np.linalg.solve(A, B)\n    return solution"
    ],
    "HumanEval/122": [
      "def max_sum_subarray(arr, k):\n    '''This function takes an array of integers and an integer k and returns the maximum sum of a subarray of size k.'''\n    \n    if len(arr) < k:\n        return 0\n    \n    max_sum = 0\n    sum = 0\n    for i in range(k):\n        sum += arr[i]\n    \n    max_sum = sum\n    i = 0\n    j = k\n    while j < len(arr):\n        sum = sum - arr[i] + arr[j]\n        if sum > max_sum:\n            max_sum = sum        \n        i += 1\n        j += 1\n    return max_sum",
      "def quicksort(arr):\n    \"\"\"\n    Sorts the input array in-place using the Quicksort algorithm with duplicate handling.\n    \"\"\"\n    if len(arr) <= 1:\n        return\n    # Choose two pivot elements\n    pivot1, pivot2 = arr[0], arr[-1]\n    i, j = 0, len(arr) - 1\n    k = 0\n    while k <= j:\n        if arr[k] < pivot1:\n            arr[i], arr[k] = arr[k], arr[i]\n            i += 1\n            k += 1\n        elif arr[k] > pivot2:\n            arr[j], arr[k] = arr[k], arr[j]\n            j -= 1\n        else:\n            k += 1\n    # Recursively sort the first and third sub-arrays\n    quicksort(arr[:i])\n    quicksort(arr[j+1:])",
      "def max_sum_subarray(arr, k):\n    # Check if the length of the array is less than 'k'\n    if len(arr) < k:\n        return \"Invalid\"\n\n    # Compute the sum of first 'k' elements  \n    window_sum = sum(arr[:k])\n\n    # This sum is the maximum sum so far\n    max_sum = window_sum\n    \n    # Slide the window over the array \n    for i in range(k, len(arr)):\n        # Subtract the element going out and add the element coming in \n        window_sum = window_sum - arr[i - k] + arr[i]\n        max_sum = max(window_sum, max_sum)\n\n    return max_sum",
      "def three_sum(arr, target):\n    \"\"\"\n    This function takes an array and an Integer and finds three elements of the array which sum up \n    to the given number.\n\n    Parameters\n    ----------\n    arr : list\n        list of numbers\n    target : int\n        target sum\n    \n    Returns\n    -------\n    list\n        list of three elements which sum up to the target\n    \"\"\"\n    # sort the list\n    arr.sort()\n    \n    # loop through the list from 0 to length-2\n    for i in range(len(arr)-2):\n        # set j to start from the next index and k to start from the last index\n        j, k = i+1, len(arr)-1\n        # find the target sum\n        while j < k:\n            s = arr[i] + arr[j] + arr[k]\n            if s == target:\n                return [arr[i], arr[j], arr[k]]\n            elif s < target:\n                j += 1\n            else:\n                k -= 1",
      "def max_subarray_sum(arr, k):\n    length = len(arr)\n    # Handling edge cases\n    if not arr or length < k:\n        return \"Invalid input\"\n    if length == k and all(i < 0 for i in arr):\n        return \"All numbers in the array are negative\"\n    \n    # Create and initialize variables\n    window_sum, max_sum = sum(arr[:k]), sum(arr[:k])\n    start_index = 0\n    \n    # Slide the window\n    for i in range(k, length):\n        window_sum = window_sum - arr[i - k] + arr[i]\n        if window_sum > max_sum:\n            max_sum = window_sum\n            start_index = i - k + 1\n    end_index = start_index + k - 1\n    \n    # Return maximum sum and start and end index of that subarray\n    return max_sum, start_index, end_index"
    ],
    "HumanEval/123": [
      "def fib(n):\n    # checks if the input is below 0 which is invalid.\n    if n < 0:\n        return \"Invalid input. Please enter a positive number\"\n\n    # initializes a list to store the sequence\n    fib_sequence = [0, 1] + [0] * (n - 1)\n\n    # iterates from the 3rd term to nth term to fill the list\n    for i in range(2, n + 1):\n        fib_sequence[i] = fib_sequence[i - 1] + fib_sequence[i - 2]\n\n    # returns the full fibonacci sequence list and the nth term\n    return fib_sequence[:n+1], fib_sequence[n]",
      "def fibonacci_sequence(n):\n    sequence = [0, 1]  # Initialize the sequence with the first two terms\n    total_sum = sum(sequence)  # Initialize the sum of the sequence\n    \n    if n <= 2:\n        return sequence[:n], total_sum  # Return the sequence and sum if n is 1 or 2\n    \n    for i in range(2, n):\n        next_term = sequence[-1] + sequence[-2]  # Calculate the next term by summing the last two terms\n        sequence.append(next_term)  # Add the next term to the sequence\n        total_sum += next_term  # Add the next term to the sum\n    \n    return sequence, total_sum  # Return the complete sequence and the sum",
      "def generate_fibonacci(n):\n    # validate the input, it should only be positive integer\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"The number of terms should be a positive integer.\")\n\n    # generate the sequence\n    fib_sequence = []\n\n    # the sequence starts with 0 and 1\n    if n >= 1:\n        fib_sequence.append(0)\n    if n >= 2:\n        fib_sequence.append(1)\n\n    # calculate the rest of the sequence\n    for i in range(2, n):\n        next_term = fib_sequence[i-1] + fib_sequence[i-2]   # each term is the sum of the previous two terms\n        fib_sequence.append(next_term)\n\n    return fib_sequence",
      "def Fibonacci(n): \n    # If n is negative, return None\n    if n < 0: \n        return None\n    # Create an array to store Fibonacci sequence\n    fibo = [0, 1] \n      \n    # Append the next term until the n-th term\n    for i in range(2, n): \n        fibo.append(fibo[i-1] + fibo[i-2])\n    # Return the required term\n    return fibo[n-1]",
      "def fibonacci_sequence(n):\n    # Initializing first two Fibonacci numbers\n    # Fibonacci series is 0, 1, 1, 2, 3, 5, 8, 13, ...\n    fib_sequence = [0, 1]\n   \n    # Calculate the next Fibonacci term using the formula (nth-1 term + nth-2 term)\n    while len(fib_sequence) < n:\n        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])\n    \n    return fib_sequence"
    ],
    "HumanEval/124": [
      "def send_warning(scheduled_date):\n    # Calculate the difference between the current date and the scheduled date\n    diff = scheduled_date - datetime.date.today()\n\n    # If the difference is less than or equal to 7 days, send a warning message\n    if diff.days <= 7:\n        print(\"Warning: Scheduled business trip approaching in\", diff.days, \"days.\")",
      "def convert_date(input_date):\n    # Split the input_date string into day, month, and year\n    date_parts = input_date.split('/')\n    \n    # Check if the input_date has three parts\n    if len(date_parts) != 3:\n        return \"Invalid date\"\n    \n    # Convert the day, month, and year strings into integers\n    day = int(date_parts[1])\n    month = int(date_parts[0])\n    year = int(date_parts[2])\n    \n    # Check if the month value is valid (between 1 and 12)\n    if month < 1 or month > 12:\n        return \"Invalid date\"\n    \n    # Check if the day value is valid for the given month and year\n    if day < 1 or day > 31:\n        return \"Invalid date\"\n    \n    # Check for months with 30 days\n    if month in [4, 6, 9, 11] and day > 30:\n        return \"Invalid date\"\n    \n    # Check for February\n    if month == 2:\n        # Check if it is a leap year\n        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):\n            if day > 29:\n                return \"Invalid date\"\n        else:\n            if day > 28:\n                return \"Invalid date\"\n    \n    # Convert the date to the required format (DD-MM-YYYY)\n    converted_date = str(day).zfill(2) + '-' + str(month).zfill(2) + '-' + str(year)\n    \n    return converted_date",
      "def is_valid_date(date):\n    # Mapping of month names to their respective number\n    month_map = {\n        'jan': 1, 'feb': 2, 'mar': 3, 'apr': 4, 'may': 5, 'jun': 6,\n        'jul': 7, 'aug': 8, 'sep': 9, 'oct': 10, 'nov': 11, 'dec': 12\n    }\n\n    # Mapping of month numbers to their respective number of days\n    month_days_map = {\n        1: 31, 2: 28, 3: 31, 4: 30, 5: 31, 6: 30,\n        7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31\n    }\n\n    # Remove any leading or trailing whitespaces\n    date = date.strip()\n\n    # Determine the separator used in the date\n    separators = ['/','-','.']\n    separator = None\n    for sep in separators:\n        if sep in date:\n            separator = sep\n            break\n\n    if separator is None:\n        return False\n\n    # Split the date into month, day, and year\n    parts = date.split(separator)\n\n    if len(parts) != 3:\n        return False\n\n    # Extract the month, day, and year from the parts\n    if separator == '.':\n        month, day, year = parts[0], parts[1], parts[2]\n    else:\n        month, day, year = parts[0], parts[1], parts[2][:4] # Handle case of year with more than 4 digits\n\n    # Convert the month to a number\n    if month.isdigit():\n        month = int(month)\n    else:\n        month = month_map.get(month.lower())\n\n    # Check if the month is valid\n    if month is None or month < 1 or month > 12:\n        return False\n\n    # Check if the year is valid\n    if not year.isdigit() or len(year) != 4:\n        return False\n\n    year = int(year)\n\n    # Check for dates before the adoption of the Gregorian calendar (October 4, 1582 and earlier)\n    if year < 1582 or (year == 1582 and month < 10) or (year == 1582 and month == 10 and day < 4):\n        return False\n\n    # Check if it's a leap year and adjust the number of days in February accordingly\n    if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n        month_days_map[2] = 29\n\n    # Check if the day is valid\n    if not day.isdigit() or int(day) < 1 or int(day) > month_days_map[month]:\n        return False\n\n    return True",
      "def sum_days(date1_str, date2_str):\n    dateFormat = \"%Y-%m-%d\"\n    try:\n        # Convert string to date\n        date1 = dt.strptime(date1_str, dateFormat)\n        date2 = dt.strptime(date2_str, dateFormat)\n        \n        # Check if date1 is later than date2\n        if date1 > date2:\n            print(\"Error: The first date is later than the second date.\")\n            return \"Invalid Input\"\n        \n        # Compute the cumulative sum of days\n        delta = date2 - date1\n        return delta.days\n    except ValueError:\n        print(\"Error: The date format is incorrect. Please use the 'YYYY-MM-DD' format.\")\n        return \"Invalid Input\"",
      "def is_valid_ipv4_address(ip_address):\n    # Check if the string is empty\n    if not ip_address:\n        return False\n    \n    # Check if the string contains any characters other than digits and periods\n    if not all(char.isdigit() or char == '.' for char in ip_address):\n        return False\n    \n    # Split the string into four decimal numbers\n    decimal_numbers = ip_address.split('.')\n    \n    # Check if there are more or less than four decimal numbers\n    if len(decimal_numbers) != 4:\n        return False\n    \n    for number in decimal_numbers:\n        # Check if the decimal number contains leading or trailing whitespace\n        if number.strip() != number:\n            return False\n        \n        # Check if the decimal number is within the range of 0 to 255\n        if not 0 <= int(number) <= 255:\n            return False\n    \n    return True"
    ],
    "HumanEval/125": [
      "def generate_polymorphic_hello_world():\n    # Define a list of different ways to print \"Hello, World!\" in Python\n    print_statements = [\n        'print(\"Hello, World!\")',\n        'print(\"Hello,\" + \" World!\")',\n        'print(\"\".join([\"Hello\", \", \", \"World!\"]))',\n        'print(\"{}, {}!\".format(\"Hello\", \"World\"))',\n        'print(f\"{\"Hello\"}, {\"World\"}!\")'\n    ]\n\n    # Define a list of no-operation (NOP) instructions for obfuscation\n    nop_operations = [\"\", \"pass\", \"# no operation\"]\n\n    # Randomly select a print statement and NOPs\n    print_statement = random.choice(print_statements)\n    nop = random.choice(nop_operations)\n\n    # Generate a polymorphic function with the selected NOP and print statement\n    polymorphic_function = f\"\"\"def polymorphic_hello_world():\n    {nop}\n    {print_statement}\n    {nop}\n\"\"\"\n\n    return polymorphic_function",
      "def print_hello_world():\n    print(\"Hello, world!\")\n    print(\"Hello, world!\")\n    print(\"Hello, world!\")\n    print(\"Hello, world!\")\n    print(\"Hello, world!\")\n    print(\"Hello, world!\")\n    print(\"Hello, world!\")\n    print(\"Hello, world!\")\n    print(\"Hello, world!\")\n    print(\"Hello, world!\")",
      "def reverse_string_words(s, target):\n    # Firstly we replace commas and fullstops with space, \n    # to have just one delimiter for splitting the string\n    replaced = s.replace(\",\", \" \").replace(\".\", \" \")\n\n    # Then split the string by space to make a list\n    split_words = replaced.split()\n\n    # Remove target words from list\n    split_words = [word for word in split_words if word != target]\n\n    # Reverse the list\n    reversed = split_words[::-1]\n\n    return reversed",
      "def code_generator(language, instructions): \n    if language == 'Python': \n        code_string = 'print(\"Hello World!\")' \n    elif language == 'Java': \n        code_string = 'System.out.println(\"Hello World!\");' \n \n    return code_string",
      "def generate_polymorphic_payload():\n    \"\"\"Generate a polymorphic payload that prints \"Hello, World!\".\"\"\"\n    key = generate_random_key()\n    payload = \"print('Hello, World!')\"\n    encrypted_payload = encrypt(payload, key)\n    return encrypted_payload, key"
    ],
    "HumanEval/126": [
      "def will_it_fly(q,w):\n    '''\n    The function's purpose is to discern q's flight potential, return True if achievable, and False if not. For q to fly, it must fulfil two prerequisites: it must be palindromic and the total weights of its elements should not go beyond the maximum acceptable weight w.\n\n    Implement the function with error handling mechanisms. It should return a \"Non-numeric input\" error if it receives a non-numeric input, and a \"Non-sequence input\" error if it receives a non-sequence input.\n\n    Examples:\n    will_it_fly([1, 2], 5) \u279e False \n\n    will_it_fly([3, 2, 3], 1) \u279e False\n\n    will_it_fly([3, 2, 3], 9) \u279e True\n\n    will_it_fly([3], 5) \u279e True\n    \n    Error Cases:\n    will_it_fly([\"a\",\"b\",\"c\"], 5) \u279e \"Non-numeric input\"\n    \n    will_it_fly(123, 5) \u279e \"Non-sequence input\"\n    '''\n    # Handle Non-sequence input error\n    if not isinstance(q, (list, tuple, str)):\n        return \"Non-sequence input\"\n    \n    for i in q:\n        # Handle Non-numeric input error\n        if not isinstance(i, (int, float)):\n            return \"Non-numeric input\"\n    \n    return is_palindrome(q) and sum(q) <= w",
      "def test_quick_sort():\n    assert quick_sort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10]\n    assert quick_sort([3]) == [3]\n    assert quick_sort([]) == []\n    assert quick_sort([9, 8, 7, 6, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert quick_sort([1, 2, 3, 4, 5, 6, 7, 8, 9]) == [1, 2, 3, 4, 5, 6, 7, 8, 9]",
      "def generate_rubik():\n    cube = [[[0 for i in range(3)] for j in range(3)] for k in range(3)]\n    initial_gates = [\n        [[6, 6, 6], [2, 0, 1], [3, 4, 5]],\n        [[0, 0, 0], [1, 1, 1], [2, 2, 2]],\n        [[7, 7, 7], [5, 4, 3], [2, 1, 0]],\n        [[7, 7, 7], [3, 4, 5], [1, 0, 2]],\n        [[5, 5, 5], [3, 0, 4], [2, 1, 7]],\n        [[5, 5, 5], [1, 0, 2], [4, 7, 3]]\n    ]\n    for i in range(6):\n        for j in range(3):\n            for k in range(3):\n                cube[i][j][k] = initial_gates[i][j][k]\n    return cube",
      "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n        1. Perform rightward shifting operation as required.\n        2. Swap at most three pair of balls.\n        3. After the operations, elements smaller than the first element in the array should be odd in number.\n\n    Return True, if the array could be sorted, otherwise False. \n\n    Examples:\n    move_three_balls([3, 4, 5, 1, 2, 6]) => True\n    move_three_balls([1, 3, 5, 4, 2, 6]) => True\n    move_three_balls([1, 2, 3, 5, 4, 6]) => True\n    move_three_balls([5, 4, 3, 1, 2, 6]) => False\n\n    \"\"\"\n    if not arr:\n        return True\n\n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False",
      "def move_three_balls(arr):\n    \"\"\"\n    Given an array 'arr'. Your task is: \n    1. Perform rightward shifting operation as required.\n    2. Swap at most three pair of balls.\n    3. After the operations, elements smaller than the first element in the array should be odd in number.\n    \n    Return True, if the array could be sorted; otherwise, False. \n    \n    Examples:\n    move_three_balls([5, 4, 5, 1, 2, 6]) -> True\n    move_three_balls([1, 3, 5, 4, 2, 6]) -> True\n    move_three_balls([1, 2, 3, 5, 4, 6]) -> True\n    move_three_balls([5, 4, 3, 1, 2, 6]) -> False\n    \"\"\"\n    \n    if not arr:\n        return True\n    \n    arr.sort()\n    for i in range(len(arr)):\n        b = arr[i:]\n        c = b.copy()\n        c.sort()\n        if b == c:\n            if count_smaller_than_first(arr[i:]) % 2 == 1:\n                return True\n    return False"
    ],
    "HumanEval/127": [
      "def convert_all_sums(n, m, start, base):\n    \"\"\"\n    You are provided two positive integers n and m (n <= m), and an additional starting number (start),\n    your task is to determine the sum of all the numbers from n through m (inclusive), starting from the 'start' number.\n    Then convert the sum into a custom base system. The custom base system will be another integer (base)\n    ranging from [2, 10] (inclusive). If n is greater than m, the start number is less than zero,\n    or the base is out of the given range, return -1. \n    \n    Example:\n    convert_all_sums(1, 5, 0, 2) => \"0b110\"\n    convert_all_sums(7, 5, 2, 2) => -1\n    convert_all_sums(10, 2, 10, 2) => \"0b10110\"\n    convert_all_sums(20, 33, 0, 2) => \"0b110101\"\n    convert_all_sums(15, 20, 10, 8) => \"0o25\"\n    \"\"\"\n    # Check for valid input\n    if n > m or start < 0 or not(2 <= base <= 10):\n        return -1\n    # Calculates the sum of the series\n    total = sum(range(n, m+1)) + start\n    # Converts the sum to the appropriate base\n    if base == 2:\n        return bin(total)\n    elif base == 8:\n        return oct(total)\n    elif base == 10:\n        return str(total)\n    else:\n        return \"Base not supported\"",
      "def maximumSizeOfSet(intervals):\n    # Initialize S as an empty priority queue\n    S = []\n\n    # Sort the intervals by the start point\n    intervals.sort()\n\n    # For each interval\n    for start, end in intervals:\n        if S and S[0] < start:\n            # If the smallest element in S is less than start,\n            # pop it until it is not smaller than start.\n            heapq.heappop(S)\n\n        if len(S) < 2:\n            # If the queue size is 0 or 1, then push end into the priority queue.\n            heapq.heappush(S, end)\n        elif S[0] < end:\n            # If the smallest element in S is less than end,\n            # then pop it and push end into the priority queue.\n            heapq.heappop(S)\n            heapq.heappush(S, end)\n\n    # Return the size of S\n    return len(S)",
      "def convert_all_sums(n, m, start, base):\n    \"\"\"\n    You are provided two positive integers n and m (n <= m), \n    and an additional starting number (start), \n    your task is to determine the sum of all the numbers from n through m (inclusive), starting from the 'start' number,\n    Then convert the sum into a custom base system. The custom base system will be another integer (base)\n    ranging from [2, 10] (inclusive), If n is greater than m, the start number is less than zero,\n    or the base is out of the given range, return -1,\n\n    Example:\n    convert_all_sums(1, 5, 0, 2) => \"0b110\"\n    convert_all_sums(7, 5, 2, 2) => -1\n    convert_all_sums(10, 2, 10, 2) => \"0b1010\"\n    convert_all_sums(20, 33, 0, 2) => \"0b110101\"\n    convert_all_sums(15, 20, 10, 2) => \"0b25\"\n    \"\"\"\n    # Check for valid input\n    if n > m or start < 0 or not(2 <= base <= 10):\n        return -1\n    # Calculates the sum of the series\n    total = sum(range(n, m+1)) + start\n    # Converts the sum to the appropriate base\n    if base == 2:\n        return bin(total)\n    elif base == 8:\n        return oct(total)\n    elif base == 10:\n        return str(total)\n    else:\n        return \"Base not supported\"",
      "def print_prime_numbers(start, end):\n    if start <= end:\n        print(\"The first integer must be greater than the second integer.\")\n        return\n    prime_numbers = [n for n in range(start, end - 1, -1) if is_prime(n)]\n    if prime_numbers:\n        print(\"Prime numbers between\", start, \"and\", end, \"are:\")\n        for prime in prime_numbers:\n            print(prime)\n    else:\n        print(\"There are no prime numbers between\", start, \"and\", end)",
      "def cubed_results(interval):\n    try:\n        #check if the input is a list and has at least two elements\n        if type(interval) is not list or len(interval) < 2:\n            raise ValueError('The input should be a list containing at least two elements (interval).')\n            \n        #check if the first two elements of the list are integers\n        if not all(isinstance(i, int) for i in interval[:2]):\n            raise ValueError('First two elements of the list should be integers.')\n            \n        # check if interval's start is less than its end\n        if interval[0] >= interval[1]:\n            raise ValueError('The interval is not correct, its start should be smaller than its end')\n        \n        numbers = np.arange(interval[0], interval[1])\n        cubed_values = numbers**3\n        cube_roots = np.cbrt(cubed_values)\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return None\n    return cubed_values, cube_roots"
    ],
    "HumanEval/128": [
      "def prod_signs(arr):\n    \"\"\"\n    Given an array arr made up of non-zero integers (size between 1 to 500), return the product of the signs (represented as 1, -1, or 0) of all unique digits and the sum of their corresponding absolute values. If arr is empty or contains values greater than 500, return None.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == None\n    >>> prod_signs([]) == None\n    >>> prod_signs([501, 1]) == None\n    \"\"\"\n    if not arr or len(arr) > 500 or any(abs(x) > 500 for x in arr):\n        return None\n\n    arr = [x for x in arr if x != 0]  # remove zero\n    unique_arr = list(set(arr))  # remove duplicates\n\n    sign_product = 1\n    sum_ = 0\n\n    for x in unique_arr:\n        sign_product *= (1 if x > 0 else -1)\n        sum_ += abs(x)\n\n    return sign_product * sum_",
      "def prod_signs(arr):\n    \"\"\"\n    Given a list arr of non-zero integers, compute and return the sum of the absolute\n    values of unique integers and the combined product of signs (+1, -1) for each unique number in the list.\n    If the list is empty or only contains zero, return a dictionary indicating that zero and empty arrays are invalid.\n\n    Example:\n    >>> prod_signs([1, 2, -2, -4]) == {'Sum': 9, 'Sign_product': -1}\n    >>> prod_signs([0, 1]) == {'error': 'Invalid input. The list should not contain zero only or be empty.'}\n    >>> prod_signs([]) == {'error': 'Invalid input. The list should not contain zeros only or be empty.'}\n    \"\"\"\n\n    # remove zeros and duplicate values\n    unique_arr = list(set(arr))\n    if 0 in unique_arr: \n        unique_arr.remove(0)\n\n    # check if the array is empty or contains zeros only\n    if not unique_arr: \n        return {'error': 'Invalid input. The list should not contain zeros only or be empty.'}\n    else:\n        sum_arr = sum([abs(i) for i in unique_arr])\n        sign_product = 1\n        for i in unique_arr:\n            sign_product *= 1 if i > 0 else -1 \n        return {'Sum': sum_arr, 'Sign product': sign_product}",
      "def prod_signs(arr):\n    \"\"\"\n    Given a list arr of non-zero integers, compute and return the sum of the absolute values of unique integers and the combined product of signs (+1, -1) for each unique number in the list. If the list is empty or only contains zero, return a dictionary indicating that zero and empty arrays are invalid.\n    \n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == {'Sum': 7, 'Sign product': -1}\n    >>> prod_signs([0, 1]) == {'error': 'Invalid input. The list should not contain zeros only or be empty.'}\n    >>> prod_signs([]) == {'error': 'Invalid input. The list should not contain zeros only or be empty.'}\n    \"\"\"\n\n    # remove zeros and duplicate values\n    unique_arr = list(set(arr))\n    if 0 in unique_arr: unique_arr.remove(0)\n    \n    # check if the array is empty or contains zeros only\n    if not unique_arr: \n        return {'error': 'Invalid input. The list should not contain zeros only or be empty.'}\n    else:\n        sum_arr = sum(abs(i) for i in unique_arr)\n        sign_product = 1\n        for i in unique_arr:\n            sign_product *= 1 if i > 0 else -1 \n        return {'Sum': sum_arr, 'Sign product': sign_product}",
      "def prod_signs(arr):\n\n    if not arr:  # condition for empty array\n        return None\n    \n    val, sign = 0,1\n\n    for num in arr:\n        if num == 0:  # condition for existence of zero in array\n            return None\n        else:   # calculate sum of values multiplied by sign.\n            val += abs(num)*(1 if num>0 else -1)\n    return val ",
      "def sum_of_squares(arr):\n    \"\"\"Calculate square sum of numbers divisible by 3 or 7.\n    \n    This function takes a list of integers and strings, converting \n    strings to integers where possible, and returns the sum of the squares \n    of all positive elements divisible by either 3 or 7. Non-convertible \n    strings and negative numbers are ignored.\n\n    Args:\n        arr (list): A list containing integers and strings.\n\n    Returns:\n        int: The sum of squares of all positive elements divisible by 3 or 7.\n\n    Examples:\n        >>> sum_of_squares([])\n        0\n        >>> sum_of_squares(['3', 7, -1, '11', 'not-an-int'])\n        58\n        >>> sum_of_squares([4, '9', 7, '3'])\n        130\n    \"\"\"\n    return sum(int(i)**2 for i in arr if str(i).isdigit() and int(i) > 0 and (int(i) % 3 == 0 or int(i) % 7 == 0))"
    ],
    "HumanEval/129": [
      "def maxSumPath(grid, k):\n    # Given each cell has distinct value, the maximum k cells will always be the maximum k values in the grid.\n    # Flatten the grid to a list and sort it in reverse order\n    values = sorted(sum(grid, []), reverse=True)\n    max_values = values[:k]\n    max_sum = sum(max_values)\n    # Compute path which is the value itself in this case\n    path = max_values\n\n    return [max_sum, path]",
      "def optimizedTraversal(grid, k):\n    N = len(grid)\n\n    # Store the directions of traversal (-1, 0) = Left, (1, 0) = Right, (0, -1) = Up, (0, 1) = Down.\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    # Initialize dict to store the maximal values for paths of length k starting from each cell.\n    dp = {(i, j, k): grid[i][j] for i in range(N) for j in range(N) for k in range(1, K + 1)}\n\n    for steps in range(1, K):  # For each possible number of steps\n        for i in range(N):  # For each row\n            for j in range(N):  # For each column\n\n                # Initialize current cell's value for paths of length (steps + 1) as negative infinity.\n                dp[(i, j, steps + 1)] = float(\"-inf\") \n\n                # For each direction of traversal\n                for dx, dy in directions:\n                    ni, nj = i + dx, j + dy  # Next cell's coordinates\n                    if 0 <= ni < N and 0 <= nj < N:  # If next cell is within grid\n\n                        # Update current cell's value for paths of length (steps + 1) as max value from current cell value or next cell's value.\n                        dp[(i, j, steps + 1)] = max(dp[(i, j, steps + 1)], grid[i][j] + dp[(ni, nj, steps)])\n\n    # Find the max total value and the starting cell for the optimal path.\n    max_val, max_cell = max((val, cell) for (cell, _, steps), val in dp.items() if steps == k)\n\n    # Backtrack to find the cells in the optimal path.\n    path = [max_cell]\n    while len(path) < k:\n        val = max_val - grid[max_cell[0]][max_cell[1]]\n        for dx, dy in directions:\n            ni, nj = max_cell[0] + dx, max_cell[1] + dy  # Next cell's coordinates\n            if 0 <= ni < N and 0 <= nj < N and dp[(ni, nj, len(path))] == val:\n                max_cell = (ni, nj)  # Update the current cell as the next cell\n                max_val = val  # Update the max value as the value at next cell\n                path.append(max_cell)  # Add the next cell to the path\n                break\n    return path",
      "def minesweeper(grid):\n    # Get the grid size.\n    n, m = len(grid), len(grid[0])\n\n    # Initialize an output grid with all values set to 0.\n    output = [[0]*m for _ in range(n)]\n\n    # Loop over each cell in the grid.\n    for i in range(n):\n        for j in range(m):\n\n            # If the cell is a mine, mark it as such in the output.\n            if grid[i][j] == '#':\n                output[i][j] = '#'\n                continue\n\n            # Check the neighboring cells.\n            for dx in [-1, 0, 1]:\n                for dy in [-1, 0, 1]:\n                    # If the neighbor is within the grid and it is a mine, \n                    # increment the output value of the current cell.\n                    if 0 <= i+dx < n and 0 <= j+dy < m and grid[i+dx][j+dy] == '#':\n                        output[i][j] += 1\n\n            # Convert the count to string.\n            output[i][j] = str(output[i][j])\n    # Return the output grid.\n    return output",
      "def minPath(grid: List[List[int]], k: int) -> List[int]:\n    #Checking for erroneous input\n    if not isinstance(grid, list) or not all(isinstance(i, list) for i in grid):\n        return \"Invalid input. Input has to be a 2D grid.\"\n    n = len(grid)\n    if not isinstance(k, int) or not 1 <= k <= n*n:\n        return \"Invalid input. k has to be an integer and within range.\"\n    if any(not isinstance(i, int) for sublist in grid for i in sublist):\n        return \"Invalid input. Grid should only contain integers.\"\n\n    heap = [[grid[0][0], [0, 0]]]   # value at cell, coords\n    sumCache = {(0, 0): grid[0][0]}   # Cache total path sum at each cell. Key is coords\n    pathCache = {(0, 0): [grid[0][0]]}   # Cache path at each cell. Key is coords\n\n    while heap:\n        curvalue, (curi, curj) = heapq.heappop(heap)\n        #Generate all paths from current cell to neighbours\n        for nexti, nextj in getNeighbors(curi, curj, n):\n            newSum = sumCache[(curi, curj)] + grid[nexti][nextj]\n            newPath = pathCache[(curi, curj)] + [grid[nexti][nextj]]\n            if len(newPath) > k:   # If path too long, skip\n                continue\n            #If cell not visited yet or new path is shorter than existing, update cell's path sum\n            if (nexti, nextj) not in sumCache or newSum < sumCache[(nexti, nextj)]:\n                sumCache[(nexti, nextj)] = newSum\n                heapq.heappush(heap, [newSum, [nexti, nextj]])\n                pathCache[(nexti, nextj)] = newPath\n    #Return min path among all the paths of len k\n    return min((path for path in pathCache.values() if len(path)==k), key=sum)",
      "def minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    \n    # Mark blocked cells\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n\n    # Start from each cell on the grid\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n\n                # Four possible directions\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\n                # BFS\n                while not queue.empty():\n                    cur_i, cur_j = queue.get()\n                    for direction in directions:\n                        new_i, new_j = cur_i + direction[0], cur_j + direction[1]\n                        # check if it's within the boundary of the grid and not blocked\n                        if 0 <= new_i < N and 0 <= new_j < N and distances[new_i][new_j] != -1:\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n\n    # Return the cell values for the shortest path with length k\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    \n    # If no path of length k is found, return -1\n    if not path:\n        return -1\n\n    path.sort()\n    return path"
    ],
    "HumanEval/130": [
      "def tri(n):\n    sequence = []\n    if n < 0:\n        return sequence\n    if n >= 0:\n        sequence.append(3)\n    if n >= 2:\n        sequence.append(2)\n    if n >= 3:\n        sequence.append(sequence[-2] + sequence[-1] + 1)\n    for i in range(4, n+1):\n        if i%2==0:\n            sequence.append(1 + i // 2)\n        else:\n            sequence.append(sequence[-2] + sequence[-1] + sequence[-3])\n    return sequence",
      "def tribonacci(n: int, memo = {}):\n    \"\"\"\n    The Tribonacci sequence adheres to the following rules:\n    tribonacci(0) = 0\n    tribonacci(1) = 1\n    tribonacci(2) = 1\n    tribonacci(n) = tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3) for n > 2\n    tribonacci(n) = tribonacci(n+3) - tribonacci(n+2) - tribonacci(n+1) for n < 0\n\n    Apply dynamic programming and cache intermediate results using memoization for optimization.\n    >>> tribonacci(1)\n    1\n    >>> tribonacci(5)\n    7\n    >>> tribonacci(8)\n    44\n    >>> tribonacci(-1)\n    1\n    >>> tribonacci(-5)\n    -7\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    elif n == 0:\n        return 0\n    elif n == 1 or n == 2:\n        return 1\n    elif n < 0:\n        result = tribonacci(n + 3, memo) - tribonacci(n + 2, memo) - tribonacci(n + 1, memo)\n    else:\n        result = tribonacci(n - 1, memo) + tribonacci(n - 2, memo) + tribonacci(n - 3, memo)\n        \n    memo[n] = result\n    return result",
      "def main():\n    print(tri(3))",
      "def fibfib(n: int, memo = {}):\n    \"\"\"\n    This function encapsulates the FibFib sequence that mirrors the Fibonacci sequence but with this specific set of rules:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) where n > 2\n    fibfib(n) == fibfib(n+3) - fibfib(n+2) - fibfib(n+1) where n < 0\n\n    Applying dynamic programming and memoization is essential for function optimization.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    >>> fibfib(-1)\n    1\n    >>> fibfib(-5)\n    -4\n    \"\"\"\n    if n in memo:\n        return memo[n]\n\n    if n >= 0:\n        if n < 3:\n            result = n % 2\n        else:\n            result = fibfib(n - 1, memo) + fibfib(n - 2, memo) + fibfib(n - 3, memo)\n    else:\n        result = fibfib(n + 3, memo) - fibfib(n + 2, memo) - fibfib(n + 1, memo)\n\n    # store the result in the memo dictionary for future reference\n    memo[n] = result\n\n    return result",
      "def generate_mesh(voxel_data):\n    # Create a 3D mesh from voxel data using Delaunay triangulation\n    x, y, z = np.where(voxel_data)\n    points = np.column_stack([x, y, z])\n    tri = Delaunay(points)\n    \n    # Plot the mesh using Mayavi\n    fig = mlab.figure()\n    mlab.triangular_mesh(x, y, z, tri.simplices, representation='wireframe')\n    mlab.show()"
    ],
    "HumanEval/131": [
      "def numsManipulation(n):\n    \"\"\"Given a positive integer n, return the product of the cubes of odd digits and the sum of squares of the even digits.\n    If all digits are even, return the product of cubes of the first half of even digits.\n    If all digits are odd, return the sum of the squares of the first half of odd digits.\n    For example:\n    numsManipulation(1)   == 1\n    numsManipulation(4)   == 16\n    numsManipulation(235) == 31 (2^2 + 3^3*5^3)\n    \"\"\"\n\n    # List of odd and even digits\n    odd_digits = [int(digit) for digit in str(n) if int(digit) % 2 != 0]\n    even_digits = [int(digit) for digit in str(n) if int(digit) % 2 == 0]\n\n    # Determine the calculation based on the digits\n    if len(odd_digits) > 0 and len(even_digits) > 0:\n        # Both odd and even digits\n        return sum(d ** 2 for d in even_digits) + prod(d ** 3 for d in odd_digits)\n    elif len(odd_digits) > 0:\n        # Only odd digits\n        return sum(d ** 2 for d in odd_digits[:len(odd_digits)//2])\n    else:\n        # Only even digits\n        return prod(d ** 3 for d in even_digits[:len(even_digits)//2])",
      "def numsManipulation(n):\n    \"\"\"\n    Given a positive integer n, return the product of the cubes of odd digits and the sum of the squares of the even digits.\n    If all digits are even, return the product of cubes of the first half of even digits.\n    If all digits are odd, return the sum of the squares of the first half of odd digits.\n    For example:\n    numsManipulation(1) == 1\n    numsManipulation(4) == 16\n    numsManipulation(235) == 31 (2^2 + 3^3 + 5^3)\n    \"\"\"\n\n    # List of odd and even digits\n    odd_digits = [int(digit) for digit in str(n) if int(digit) % 2 != 0]\n    even_digits = [int(digit) for digit in str(n) if int(digit) % 2 == 0]\n\n    # Determine the calculation based on the digits\n    if len(odd_digits) > 0 and len(even_digits) > 0:\n        # Both odd and even digits\n        return sum(d ** 2 for d in even_digits) + prod(d ** 3 for d in odd_digits)\n    elif len(odd_digits) > 0:\n        # Only odd digits\n        return sum(d ** 2 for d in odd_digits[:len(odd_digits)//2])\n    else:\n        # Only even digits\n        return prod(d ** 3 for d in even_digits[:len(even_digits)//2])",
      "def digits(n):\n    n = [int(i) for i in str(n)]\n    odd = [i for i in n if i % 2 != 0]\n    even = [i for i in n if i % 2 == 0]\n\n    if len(odd) == 0:  # all digits are even\n        half = len(even) // 2\n        product = 1\n        for num in even[:half]:\n            product *= num\n        return product\n\n    elif len(even) == 0:  # all digits are odd\n        half = len(odd) // 2\n        return sum(odd[:half])\n        \n    else:  # mix of odd and even digits\n        product = 1\n        for num in odd:\n            product *= num\n        return product + sum(even)",
      "def digits(n):\n    s = str(n)  # convert the number to a string to iterate through the digits\n    evens = [int(d) for d in s if int(d) % 2 == 0]  # list of even digits\n    odds = [int(d) for d in s if int(d) % 2 == 1]  # list of odd digits\n\n    # if all digits are even\n    if len(evens) == len(s):\n        half = len(evens)//2\n        result = 1\n        for i in range(half):\n            result *= evens[i]\n        return result\n\n    # if all digits are odd\n    elif len(odds) == len(s):\n        half = len(odds)//2\n        return sum(odds[:half])\n\n    # the default case (n has both odd and even digits)\n    else:\n        return sum(evens) * prod(odds)",
      "def calculate_numbers(n):\n    # Check if input is positive integer\n    if not isinstance(n, int) or n <= 0:\n        return \"Input should be a positive integer\"\n  \n    # Convert number to list of digits\n    digits = [int(x) for x in str(n)]\n  \n    # Calculate cumulative total of digits\n    total = sum(digits)\n  \n    # Calculate sum of factorials of digits\n    factorial_sum = sum(math.factorial(i) for i in digits)\n  \n    return total, factorial_sum"
    ],
    "HumanEval/132": [
      "def total_match(lst1, lst2, case_sensitive=False):\n    \"\"\"\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n\n    The function also drops duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case sensitive parameter to True.\n\n    Should both iterables have an equal total character length, the function returns the first iterable.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['HI', 'HI']) \u279e ['HI', 'HI']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'hi']) \u279e ['hi', 'hi']\n    total_match(['A'], ['1', '2', '3', '4', '5']) \u279e ['A']\n    total_match(['hi world'], ['hi', ' w', 'or', 'ld']) \u279e ['hi', ' w', 'or', 'ld']\n    \"\"\"\n\n    # Remove non-alphanumeric characters and possibly convert to lower case\n    lst1 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst1]\n    lst2 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst2]\n\n    # Eliminate duplicates, preserving the original order\n    lst1, lst2 = list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2))\n\n    # Determine which list has a less or equal total character count\n    return lst1 if sum(len(s) for s in lst1) <= sum(len(s) for s in lst2) else lst2",
      "def total_match(lst1, lst2, case_sensitive=False):\n    '''\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n    \n    The function also drop duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case_sensitive parameter to True.\n    \n    Should both iterables have an equal total character length, the function returns the first iterable.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    total_match(['hi world'], ['hi', ' w', 'or', 'ld']) \u279e ['hi', ' w', 'or', 'ld']\n    '''\n    import re\n\n    # Remove non-alphanumeric characters and possibly convert to lower case\n    lst1 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst1]\n    lst2 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst2]\n\n    # Eliminate duplicates, preserving the original order\n    lst1, lst2 = list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2))\n\n    # Determine which list has a less or equal total character count\n    return lst1 if sum(len(s) for s in lst1) <= sum(len(s) for s in lst2) else lst2",
      "def is_nested(string):\n    stack = []\n    brackets = {'(': ')', '[': ']', '{': '}', '<': '>'}\n    for i, char in enumerate(string):\n        if char in brackets:\n            stack.append((char, i))\n        elif len(stack) == 0 or brackets[stack.pop()[0]] != char:\n            return False, 'Position ' + str(i)\n    return (len(stack) == 0, None) if len(stack) == 0 else (False, 'Position ' + str(stack[0][1]))",
      "def will_it_fly(q,w):\n    '''\n    The function's purpose is to discern q's flight potential, return True if achievable, and False if not. For q to fly, it must fulfil two prerequisites: it must be palindromic and the total weights of its elements should not go beyond the maximum acceptable weight w.\n\n    Implement the function with error handling mechanisms. It should return a \"Non-numeric input\" error if it receives a non-numeric input, and a \"Non-sequence input\" error if it receives a non-sequence input.\n\n    Examples:\n    will_it_fly([1, 2], 5) \u279e False \n\n    will_it_fly([3, 2, 3], 1) \u279e False\n\n    will_it_fly([3, 2, 3], 9) \u279e True\n\n    will_it_fly([3], 5) \u279e True\n    \n    Error Cases:\n    will_it_fly([\"a\",\"b\",\"c\"], 5) \u279e \"Non-numeric input\"\n    \n    will_it_fly(123, 5) \u279e \"Non-sequence input\"\n    '''\n    # Handle Non-sequence input error\n    if not isinstance(q, (list, tuple, str)):\n        return \"Non-sequence input\"\n    \n    for i in q:\n        # Handle Non-numeric input error\n        if not isinstance(i, (int, float)):\n            return \"Non-numeric input\"\n    \n    return is_palindrome(q) and sum(q) <= w",
      "def isValidPhoneNumber(phoneNumber):\n    if len(phoneNumber) != 14:\n        return False\n    \n    if phoneNumber[0] != '(' or phoneNumber[4] != ')' or phoneNumber[5] != ' ' or phoneNumber[9] != '-':\n        return False\n    \n    areaCode = phoneNumber[1:4]\n    if areaCode[0] in ['0', '1']:\n        return False\n    \n    if areaCode[1] == '9':\n        return False\n    \n    if areaCode[0] == areaCode[1] == areaCode[2]:\n        return False\n    \n    if int(areaCode) in [int(areaCode[0]) + 1, int(areaCode[0]) - 1, int(areaCode[0]) + 2, int(areaCode[0]) - 2]:\n        return False\n    \n    if phoneNumber[6] in ['0', '1']:\n        return False\n    \n    if phoneNumber[7] == '9':\n        return False\n    \n    if phoneNumber[10] == phoneNumber[11] == phoneNumber[12] == phoneNumber[13]:\n        return False\n    \n    if int(phoneNumber[10:14]) in [int(phoneNumber[10:14][0]) + 1, int(phoneNumber[10:14][0]) - 1, int(phoneNumber[10:14][0]) + 2, int(phoneNumber[10:14][0]) - 2]:\n        return False\n    \n    return True"
    ],
    "HumanEval/133": [
      "def find_lcm_in_array(lst):\n    # This function calculates the lcm for a list of numbers\n\n    try:\n        num1 = lst[0]\n        num2 = lst[1]\n        lcm = find_lcm(num1, num2)\n\n        for i in range(2, len(lst)):\n            lcm = find_lcm(lcm, lst[i])\n\n        print(\"The LCM of the list is: \",lcm)\n\n    except IndexError as e:\n        print(\"Error: List should have at least two numbers.\")\n    except TypeError as e:\n        print(\"Error: All elements of the list should be numeric.\")",
      "def get_product_array(lst):\n    # Initialize a variable to keep track of the product\n    right_product = 1\n    # Initialize an array of ones with the same size as the input\n    output = [1] * len(lst)\n    \n    # Calculate the product of the numbers before the current index\n    for i in range(1, len(lst)):\n        output[i] = output[i - 1] * lst[i - 1]\n   \n    # Calculate the product of the numbers after the current index\n    for i in range(len(lst) - 1, -1, -1):\n        output[i] *= right_product\n        right_product *= lst[i]\n    \n    return output",
      "def swap(lst, i, j):\n    \"\"\"\n    Swaps two elements in the given list.\n\n    Parameters:\n    lst (list): The list in which the elements should be swapped.\n    i (int): The index of the first element to be swapped.\n    j (int): The index of the second element to be swapped.\n\n    Returns:\n    list: The modified list with the elements swapped.\n    \"\"\"\n\n    # Step 1: Check if the indices are valid.\n    if i < 0 or i >= len(lst) or j < 0 or j >= len(lst):\n        raise ValueError(\"Invalid indices\")\n\n    # Step 2: Swap the elements using a temporary variable.\n    temp = lst[i]\n    lst[i] = lst[j]\n    lst[j] = temp\n\n    # Step 3: Return the modified list.\n    return lst",
      "def unusual_addition(lst: list) -> list:\n    \"\"\"\n    Given a list consisting only of strings with numerical characters, return a list.\n    Each 'i' in the output statement for each element, \"+he number of odd elements present in the\n    i'th input string,\", should be replaced with the actual count of odd numbers.\n    \"\"\" \n    results = []\n\n    for i, string in enumerate(lst):\n\n        totals = [0, 0]  # [total odd_numbers, total_even_numbers]\n\n        # Count number of odd and even numbers within the string\n        for char in string:\n            if int(char) % 2 == 0:\n                totals[1] += 1\n            else:\n                totals[0] += 1\n\n        totals = [num**2 for num in totals]  # Square of counts\n\n        odd_squares = {el for el in range(totals[0])}\n        even_squares = [el for el in range(totals[1])]\n\n        odd_square_totals = sum([num**2 for num in odd_squares])\n        even_square_totals = sum([num**2 for num in even_squares])\n\n        output_string = f\"The number of odd elements {odd_square_totals} in the string {string} of the input.\"\n        results.append(output_string)\n\n    return results",
      "def find_elements(lists: List[List[int]], x: int) -> List[int]:\n    all_elements = []\n    distinct_elements = []\n\n    for lst in lists:\n        all_elements.extend(lst)\n        distinct_elements.extend(set(lst))\n\n    output = [element for element in distinct_elements if all_elements.count(element) == x]\n    return output"
    ],
    "HumanEval/134": [
      "def will_it_fly(q,w):\n    '''\n    The function's purpose is to discern q's flight potential, return True if achievable, and False if not. For q to fly, it must fulfil two prerequisites: it must be palindromic and the total weights of its elements should not go beyond the maximum acceptable weight w.\n\n    Implement the function with error handling mechanisms. It should return a \"Non-numeric input\" error if it receives a non-numeric input, and a \"Non-sequence input\" error if it receives a non-sequence input.\n\n    Examples:\n    will_it_fly([1, 2], 5) \u279e False \n\n    will_it_fly([3, 2, 3], 1) \u279e False\n\n    will_it_fly([3, 2, 3], 9) \u279e True\n\n    will_it_fly([3], 5) \u279e True\n    \n    Error Cases:\n    will_it_fly([\"a\",\"b\",\"c\"], 5) \u279e \"Non-numeric input\"\n    \n    will_it_fly(123, 5) \u279e \"Non-sequence input\"\n    '''\n    # Handle Non-sequence input error\n    if not isinstance(q, (list, tuple, str)):\n        return \"Non-sequence input\"\n    \n    for i in q:\n        # Handle Non-numeric input error\n        if not isinstance(i, (int, float)):\n            return \"Non-numeric input\"\n    \n    return is_palindrome(q) and sum(q) <= w",
      "def distorted_compare_word_sets(phrase1: str, phrase2: str):\n    \"\"\"\n    Determine if two phrases have the identical word set with multiple constraints including word duplicity, case sensitivity, and punctuation.\n    >>> distorted_compare_word_sets(\"Apple, Banana: Orange!\", \"orange apple Banana\")\n    False\n    >>> distorted_compare_word_sets(\"apple banana\", \"Apple, Orange BaNaNa!\")\n    False\n    >>> distorted_compare_word_sets(\"ApPle!\", \"appLE, Apple\")\n    True\n    >>> distorted_compare_word_sets(\"Banana?\", \"Apple BaNana!\")\n    False\n    >>> distorted_compare_word_sets(\"Apple BaNana Orange.\", \"Orange, BanaNa grape!\")\n    False\n    \"\"\"\n\n    # Remove punctuation, convert to lowercase and split by space\n    phrase1_words = set(phrase1.translate(str.maketrans(\"\", \"\", string.punctuation)).lower().split(\" \"))\n    phrase2_words = set(phrase2.translate(str.maketrans(\"\", \"\", string.punctuation)).lower().split(\" \"))\n\n    # Return comparison result\n    return phrase1_words == phrase2_words",
      "def total_match(lst1, lst2, case_sensitive=False):\n    \"\"\"\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n\n    The function also drops duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case sensitive parameter to True.\n\n    Should both iterables have an equal total character length, the function returns the first iterable.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['HI', 'HI']) \u279e ['HI', 'HI']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'hi']) \u279e ['hi', 'hi']\n    total_match(['A'], ['1', '2', '3', '4', '5']) \u279e ['A']\n    total_match(['hi world'], ['hi', ' w', 'or', 'ld']) \u279e ['hi', ' w', 'or', 'ld']\n    \"\"\"\n\n    # Remove non-alphanumeric characters and possibly convert to lower case\n    lst1 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst1]\n    lst2 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst2]\n\n    # Eliminate duplicates, preserving the original order\n    lst1, lst2 = list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2))\n\n    # Determine which list has a less or equal total character count\n    return lst1 if sum(len(s) for s in lst1) <= sum(len(s) for s in lst2) else lst2",
      "def check_if_substring(string1, string2):\n    \"\"\"This function checks if a given string (string1) is a\n    substring of the other given string (string2).\n\n    Args:\n        string1 (str): The string that might be a substring of string2.\n        string2 (str): The string to check if string1 is a substring.\n\n    Returns:\n        bool: True if string1 is a substring of string2, False otherwise.\n    \"\"\"\n    if string1 in string2:\n        return True\n    else:\n        return False",
      "def verify_same_word_sets_freqs(phrase1: str, phrase2: str):\n    \"\"\"\n    >>> verify_same_word_sets_freqs(\"Apple Banana Orange\", \"Orange Apple Banana\")\n    True\n    >>> verify_same_word_sets_freqs(\"apple banana\", \"Apple Orange BaNaNa\")\n    False\n    >>> verify_same_word_sets_freqs(\"ApPle\", \"appLE Apple\")\n    False\n    >>> verify_same_word_sets_freqs(\"Banana Apple\", \"Apple BaNana\")\n    True\n    >>> verify_same_word_sets_freqs(\"Apple BaNana Orange\", \"Orange BanaNa grape\")\n    False\n    \"\"\"\n    map1 = Counter(phrase1.lower().split())\n    map2 = Counter(phrase2.lower().split())\n    return map1 == map2"
    ],
    "HumanEval/135": [
      "def can_arrange_v2(arr, limits, criterion):\n    \"\"\"Specify a function that not only locates an element suitable for a distinct role, but also its likely swap contender, according to a constraint that the swapping elements must be within specified limits. If the elements are inexistent, return {'index': -1, 'swap_with': -1}. The input array should not contain duplicate values, 'limits' is a tuple of two integers indicating a subarray to consider elements within, and 'criterion' is a unique condition that the found element must meet.\n\n    Examples:\n    can_arrange_v2([1,2,4,3,5], (2, 4), is_prime) = {'index': 3, 'swap_with': 2}\n    can_arrange_v2([1,2,3], (0, 2), odd_number) = {'index': -1, 'swap_with': -1}\n    \"\"\"\n    # Extract subarray\n    subarray = arr[limits[0]:limits[1]+1]\n    \n    # Find the index of the first element within limits that meets the criterion\n    index = find_index_of_element_meeting_criterion(subarray, criterion)\n    \n    # If no such element exists\n    if index == -1:\n        return {'index': -1, 'swap_with': -1}\n    \n    # If such an element exists, find the swap contender\n    swap_with_index = find_index_of_next_possible_swap(subarray, index)\n    \n    # If no such swap contender exists\n    if swap_with_index == -1:\n        return {'index': -1, 'swap_with': -1}\n    \n    # If a valid swap contender does exist\n    return {'index': index + limits[0], 'swap_with': swap_with_index + limits[0]}  #add lower limit to adjust index for the actual array as opposed to the subarray.",
      "def can_arrange_v2(arr, limits, criterion):\n    \"\"\"\n    Specify a function that not only locates an element suitable for a distinct role, but also its likely swap contender, according to a constraint where the swapping elements must be within specified limits. If the elements are inexistent, return {'index': -1, 'swap_with': -1}. The input array should not contain duplicate values, 'limits' is a tuple of two integers indicating a subarray to consider elements within, and 'criterion' is a unique condition that the found element must meet.\n    \n    Examples:\n    can_arrange_v2([1,2,4,3,5], (2, 4), is_prime) - {'index': 3, 'swap_with': 2}\n    can_arrange_v2([1,2,3], (0, 2), odd_number) - {'index': -1, 'swap_with': -1}\n    \"\"\"\n    # Extract subarray\n    subarray = arr[limits[0]:limits[1]+1]\n\n    # Find the index of the first element within limits that meets the criterion\n    index = find_index_of_element_meeting_criterion(subarray, criterion)\n\n    # If no such element exists\n    if index == -1:\n        return {'index': -1, 'swap_with': -1}\n\n    # If such an element exists, find the swap contender\n    swap_with_index = find_index_of_next_possible_swap(subarray, index)\n\n    # If no such swap contender exists\n    if swap_with_index == -1:\n        return {'index': -1, 'swap_with': -1}\n\n    # If a valid swap contender does exist\n    return {'index': index + limits[0], 'swap_with': swap_with_index + limits[0]}  ",
      "def find_max(arr):\n    \"\"\"\n    Function to find the largest numerical value in an array. \n\n    Parameters:\n    arr (list): The list of integers.\n  \n    Returns:\n    max_val (int): The largest numerical value in the array.\n  \n    \"\"\"\n    \n    # Step 1: Initialize a variable max_val with the value at the 0th index in the array\n    max_val = arr[0]\n\n    # Step 2: Iterate over each element in the array from 1 to n-1\n    for i in range(1, len(arr)):\n        # Step 3: If the value at the current index in the array is greater than max_val, update max_val\n        if arr[i] > max_val:\n            max_val = arr[i]\n\n    # Step 4: Return max_val, which now holds the largest numerical value in the array\n    return max_val",
      "def find_kth_largest(arr, k):\n    \"\"\"\n    Function to find the kth largest element in an array\n    \"\"\"\n    \n    # make a copy of the array\n    arr_copy = arr[:]\n    \n    # get the length of the array\n    length = len(arr_copy)\n    \n    # if k is greater than or equal to the length of the array, return the maximum element\n    if k >= length:\n        return max(arr_copy)\n        \n    # sort the array in descending order\n    arr_copy.sort(reverse=True)\n    \n    # get the kth element from the sorted array\n    kth_largest = arr_copy[k-1]\n    \n    return kth_largest",
      "def binary_search(arr, x):\n    \"\"\"\n    Perform a binary search of a sorted array.\n\n    Parameters:\n        arr(list): A sorted list of elements.\n        x(int): The element to be searched.\n\n    Returns:\n        int: The index of the element in the array, or -1 if not found.\n    \"\"\" \n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            # found the element\n            return mid\n        elif x > arr[mid]:\n            # element is greater than mid - search the upper half\n            low = mid + 1 \n        else:\n            # element is less than mid - search the lower half\n            high = mid - 1\n    \n    # element not found\n    return -1"
    ],
    "HumanEval/136": [
      "def uncommon_elements(sequence):\n    '''\n    Design a function that accepts a non-empty list composed of positive integers and returns a list of distinct integers whose frequency surpasses half of the integer's numerical value. Here, 'frequency' denotes the number of times a specific integer appears within the list.\n    If no integers satisfy these conditions, the function should return an empty list.\n    Examples:\n        uncommon_elements([4, 1, 2, 2, 3, 1]) should yield [2, 3]\n        uncommon_elements([1, 2, 2, 3, 3, 3, 4, 4, 4]) should yield [2, 3, 4]\n        uncommon_elements([5, 5, 4, 4, 4]) should yield [4]\n    '''\n    from collections import Counter\n    count = Counter(sequence)\n    result = []\n    for num, freq in count.items():\n        if freq > num/2:\n            result.append(num)\n    return result",
      "def sum_of_squares(arr):\n    \"\"\"Calculate square sum of numbers divisible by 3 or 7.\n    \n    This function takes a list of integers and strings, converting \n    strings to integers where possible, and returns the sum of the squares \n    of all positive elements divisible by either 3 or 7. Non-convertible \n    strings and negative numbers are ignored.\n\n    Args:\n        arr (list): A list containing integers and strings.\n\n    Returns:\n        int: The sum of squares of all positive elements divisible by 3 or 7.\n\n    Examples:\n        >>> sum_of_squares([])\n        0\n        >>> sum_of_squares(['3', 7, -1, '11', 'not-an-int'])\n        58\n        >>> sum_of_squares([4, '9', 7, '3'])\n        130\n    \"\"\"\n    return sum(int(i)**2 for i in arr if str(i).isdigit() and int(i) > 0 and (int(i) % 3 == 0 or int(i) % 7 == 0))",
      "def hybrid_sort_list_heap(lst):\n    '''\n    Given a list of integers and decimals, use a heap sort combined with binary insertion sort to arrange the list in a special order. The ordering should start with the smallest value, then the largest, then the smallest of the remaining values not yet included in the output, and continue doing this until all elements are sorted.\n\n    Examples:\n    hybrid_sort_list_heap([1, 2, 3, 4]) == [1, 4, 2, 3]\n    hybrid_sort_list_heap([5, 5, 5, 5]) == [5, 5, 5, 5]\n    hybrid_sort_list_heap([]) == []\n    hybrid_sort_list_heap([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # Make input list to a heap\n    heapq.heapify(lst)\n\n    # If the size of the list is less than 10 use Binary Insertion Sort\n    if len(lst) < 10:\n        sorted_lst = binary_insertion_sort(lst)\n    else:\n        # Else use Heap Sort\n        sorted_lst = [heapq.heappop(lst) for _ in range(len(lst))]\n\n    # Create a resultant list as per special order\n    result = []\n    while sorted_lst:\n        result.append(sorted_lst.pop(0))  # pop the smallest\n        if sorted_lst:\n            result.append(sorted_lst.pop(-1))  # pop the largest\n\n    return result",
      "def hybrid_sort_list_heap(lst):\n    '''\n    Given a list of integers and decimals, use a heap sort combined \n    with binary insertion sort to arrange the list in a special order. \n    The ordering should start with the smallest value, then the largest, \n    then the smallest of the remaining values not yet included in the output, \n    and continue doing this until all elements are sorted.\n\n    Examples:\n    hybrid_sort_list_heap([1, 2, 3, 4]) == [1, 4, 2, 3]\n    hybrid_sort_list_heap([5, 5, 5, 5]) == [5, 5, 5, 5]\n    hybrid_sort_list_heap([]) == []\n    hybrid_sort_list_heap([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # Make input list to a heap\n    heapq.heapify(lst)\n\n    # If the size of the list is less than 10 use Binary Insertion Sort\n    if len(lst) < 10:\n        sorted_lst = binary_insertion_sort(lst)\n    else:\n        # Else use Heap Sort\n        sorted_lst = [heapq.heappop(lst) for _ in range(len(lst))]\n\n    # Create a resultant list as per special order\n    result = []\n    while sorted_lst:\n        result.append(sorted_lst.pop(0))  # pop the smallest\n        if sorted_lst:\n            result.append(sorted_lst.pop(-1))  # pop the largest\n\n    return result",
      "def strange_sort_list_bst(lst):\n    '''\n    This function should accept a list of integers and decimal_numbers and return the list in a specific pattern, leveraging the principles of a binary search tree. The steps to this peculiar_sorting pattern should be:\n    - Commence with the smallest number.\n    - Next, identify the highest value from the remaining elements.\n    - Then, ascertain the lowest_value among the untouched output, and continue in this manner.\n\n    Examples:\n    strange_sort_list_bst([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list_bst([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list_bst([]) == []\n    strange_sort_list_bst([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # First, we will sort the list in ascending_order.\n    lst.sort()\n\n    output = []\n\n    # Then, while lst is not empty, we will remove and append to output the smallest\n    # and largest element alternately.\n    while lst:\n        output.append(lst.pop(0))  # smallest\n        if lst:\n            output.append(lst.pop(-1))  # largest\n\n    return output"
    ],
    "HumanEval/137": [
      "def will_it_fly(q,w):\n    '''\n    The function's purpose is to discern q's flight potential, return True if achievable, and False if not. For q to fly, it must fulfil two prerequisites: it must be palindromic and the total weights of its elements should not go beyond the maximum acceptable weight w.\n\n    Implement the function with error handling mechanisms. It should return a \"Non-numeric input\" error if it receives a non-numeric input, and a \"Non-sequence input\" error if it receives a non-sequence input.\n\n    Examples:\n    will_it_fly([1, 2], 5) \u279e False \n\n    will_it_fly([3, 2, 3], 1) \u279e False\n\n    will_it_fly([3, 2, 3], 9) \u279e True\n\n    will_it_fly([3], 5) \u279e True\n    \n    Error Cases:\n    will_it_fly([\"a\",\"b\",\"c\"], 5) \u279e \"Non-numeric input\"\n    \n    will_it_fly(123, 5) \u279e \"Non-sequence input\"\n    '''\n    # Handle Non-sequence input error\n    if not isinstance(q, (list, tuple, str)):\n        return \"Non-sequence input\"\n    \n    for i in q:\n        # Handle Non-numeric input error\n        if not isinstance(i, (int, float)):\n            return \"Non-numeric input\"\n    \n    return is_palindrome(q) and sum(q) <= w",
      "def compare_one(a, b):\n    # Convert to string, replace optional ',' by '.'\n    aC = str(a).replace(',', '.') if isinstance(a, str) else str(a)\n    bC = str(b).replace(',', '.') if isinstance(b, str) else str(b)\n\n    # Convert strings to numbers for comparison\n    aN = float(aC)\n    bN = float(bC)\n\n    # Compare values\n    if aN > bN:\n        return a\n    elif aN < bN:\n        return b\n\n    # If values are equal, return None\n    return None",
      "def total_match(lst1, lst2, case_sensitive=False):\n    \"\"\"\n    The function takes in two iterables of alphanumeric strings and returns the iterable with a total character length \n    (disregarding white spaces and non-alphanumeric characters) that's less or equal to the other iterable's length, \n    maintaining the original order of the elements in each iterable.\n\n    The function also drops duplicate strings from both lists, keeping only the first occurrence of each string. Text case is ignored during string evaluations by default. This can be modified by setting the case sensitive parameter to True.\n\n    Should both iterables have an equal total character length, the function returns the first iterable.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['HI', 'HI']) \u279e ['HI', 'HI']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'hi']) \u279e ['hi', 'hi']\n    total_match(['A'], ['1', '2', '3', '4', '5']) \u279e ['A']\n    total_match(['hi world'], ['hi', ' w', 'or', 'ld']) \u279e ['hi', ' w', 'or', 'ld']\n    \"\"\"\n\n    # Remove non-alphanumeric characters and possibly convert to lower case\n    lst1 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst1]\n    lst2 = [re.sub(r'\\W+', '', s).lower() if not case_sensitive else re.sub(r'\\W+', '', s) for s in lst2]\n\n    # Eliminate duplicates, preserving the original order\n    lst1, lst2 = list(dict.fromkeys(lst1)), list(dict.fromkeys(lst2))\n\n    # Determine which list has a less or equal total character count\n    return lst1 if sum(len(s) for s in lst1) <= sum(len(s) for s in lst2) else lst2",
      "def compareOne(a, b):\n    try:\n        if isinstance(a, str):\n            a = float(a.replace(\",\", \".\"))\n        if isinstance(b, str):\n            b = float(b.replace(\",\", \".\"))\n\n        if a > b:\n            return isinstance(a, float) and str(a).replace(\".\", \",\") or a\n        elif b > a:\n            return isinstance(b, float) and str(b).replace(\".\", \",\") or b\n        \n        return None\n    except ValueError:\n        return None",
      "def cumulative_binomial_product(n):\n    if type(n) not in (int, float, complex, list, tuple):\n        return \"Invalid input. Please enter a positive integer, a floating point number, a complex number, a list or a tuple.\"\n\n    if type(n) in (float, complex):\n        return \"Binomial coefficients are not defined for floating point and complex numbers.\"\n\n    if type(n) == int and n < 0:\n        return \"Invalid input. Please enter a non-negative integer.\"\n\n    if type(n) in (list, tuple):\n        try:\n            cumulative_product = 1\n            for i in n:\n                if i < 0 or type(i) != int:\n                    return \"Invalid input in list/tuple. Please ensure all elements are non-negative integers.\"\n\n                if i > 0: \n                    cumulative_product *= functools.reduce(operator.mul, (math.comb(i, j) for j in range(i+1)), 1)\n            return cumulative_product\n        except TypeError:\n            return\n    elif type(n) == int:\n        return functools.reduce(operator.mul, (math.comb(n, i) for i in range(n+1)), 1)"
    ],
    "HumanEval/138": [
      "def is_prime(n):\n    \"\"\"Returns true for prime integers, false for non-prime integers.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Check if the number is 2 (2 is the only even prime number)\n    if n == 2: \n      return True\n    # Check for less than 2 and even numbers\n    elif n < 2 or n % 2 == 0: \n      return False\n    # Check for divisibility by any other number up to sqrt(n)\n    for current in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % current == 0:\n            return False\n    return True",
      "def prime_factor_product(n):\n    \"\"\"Return true if n is a product of exactly four distinct prime numbers, false otherwise.\"\"\"\n    factors = []\n    for count in range(2, math.isqrt(n) + 1): \n        if n % count == 0: \n            if(is_prime(count)): \n                factors.append(count)\n            if(is_prime(n // count)): \n                factors.append(n // count)\n    factors = list(set(factors))\n    \n    return True if len(factors) == 4 else False",
      "def is_valid_ip(ip_str, N):\n    if N == 4:\n        try:\n            ipaddress.IPv4Address(ip_str)\n            return True\n        except ipaddress.AddressValueError:\n            return False\n    elif N == 6:\n        try:\n            ipaddress.IPv6Address(ip_str)\n            return True\n        except ipaddress.AddressValueError:\n            return False\n    else:\n        return \"Error: N must be 4 or 6\"",
      "def check_divisibility(number):\n    if not isinstance(number, int) or number <= 0:\n        print(\"Error: The input must be a positive integer\")\n        return\n\n    if number % 4 == 0 and number % 3 == 0:\n        print(\"both\")\n    elif number % 4 == 0:\n        print(\"even\")\n    elif number % 3 == 0:\n        print(\"odd\")\n    else:\n        print(\"neither\")",
      "def check_divisibility(n):\n    if isinstance(n, int) and n > 0:\n        if n % 4 == 0 and n % 3 != 0:\n            print(\"even\")\n        elif n % 3 == 0 and n % 4 != 0:\n            print(\"odd\")\n        elif n % 4 == 0 and n % 3 == 0:\n            print(\"both\")\n        else:\n            print(\"neither\")\n    else:\n        print(\"Error: Input must be a positive integer\")"
    ],
    "HumanEval/139": [
      "def factorial(n):\n    \"\"\"\n    Calculates the factorial of an integer (n \u2265 0) and returns None for negative values.\n    The factorial function is not defined for negative integers. Instead of returning an error or exception, \n    this function returns None and prints out a message.\n    The function proves to be internally consistent with the known factorial function for non-negative integers \n    (i.e., n! = n*(n-1)*(n-2)*...*3*2*1 for n\u22650).\n    \"\"\"\n    if n < 0:\n        print(\"The factorial function isn\u2019t defined for negative integers\")\n        return None\n    elif n == 0:\n        return 1\n    else:\n        fact = 1\n        for i in range(1, n + 1):\n            fact *= i\n        return fact",
      "def factorial(n):\n    try:\n        # Check if the number is valid i.e. non-negative integer\n        if not n >= 0:\n            raise ValueError(\"Invalid input! Please, input a non-negative integer.\")\n\n        # Check the type of input i.e. integer\n        if not isinstance(n, int):\n            raise TypeError(\"Invalid input type! Please, input an integer.\")\n\n        # Base case: factorial of 0 is 1\n        if n == 0:\n            return 1\n\n        # Recursive case: n! = n * (n-1)!\n        else:\n            return n * factorial(n-1)\n    except (ValueError, TypeError) as e:\n        return e",
      "def factorial(n):\n    try:\n        # Check if the number is valid i.e. non-negative integer\n        if not n >= 0:\n            raise ValueError(\"Invalid input! Please provide a non-negative integer.\")\n\n        # Check the type of input i.e. integer\n        if not isinstance(n, int):\n            raise TypeError(\"Invalid input type! Please provide an integer.\")\n\n        # Base case: factorial of 0 is 1\n        if n == 0:\n            return 1\n\n        # Recursive case: n! = n * (n-1)!\n        else:\n            return n * factorial(n-1)\n    except (ValueError, TypeError) as e:\n        return e",
      "def factorial(n):\n    # Check that the input is a positive integer\n    if not n >= 0:\n        print(\"Input must be a positive integer\")\n        return None\n    # The base case: 0! = 1\n    elif n == 0:\n        return 1\n    # Recursive case: n! = n * (n-1)!\n    else:\n        return n * factorial(n-1)",
      "def factorial(n):\n    # Check that the input is a positive integer\n    if not n >= 0:\n        print(\"Input must be a positive integer\")\n        return None\n    # The base case: 0! = 1\n    elif n == 0:\n        return 1\n    # Recursive case: n! = n * (n-1)!\n    else:\n        return n * factorial(n-1)"
    ],
    "HumanEval/140": [
      "def erroneous_solution(input_string):\n    \"\"\"\n    Given a string called input_string, perform the following modifications:\n    1. Replace all instances of white space with an underscore.\n    2. Substitute any occurrence of two or more successive white spaces with a hyphen.\n    3. Transform all words in the string to be fully capitalized.\n\n    erroneous_solution(\"example\") should return \"EXAMPLE\"\n    erroneous_solution(\"example 1\") should return \"EXAMPLE_1\"\n    erroneous_solution(\" example 2\") should return \"_EXAMPLE_2\"\n    erroneous_solution(\" example   3\") should return \"_EXAMPLE-3\"\n    erroneous_solution(\"this is a sample\") should return \"THIS_IS_A_SAMPLE\"\n    \"\"\"\n\n    # Capitalizes all words in the string first\n    input_string = input_string.upper()\n\n    # Replace all instances of white space with an underscore\n    input_string = input_string.replace(\" \", \"_\")\n\n    # Substitute any occurrence of two or more successive underscores with a hyphen\n    input_string = input_string.replace(\"__\", \"-\")\n\n    return input_string",
      "def fix_spaces(text):\n    text = re.sub(r' {2,}', '-', text) # replaces instances of two or more consecutive spaces with a dash\n    text = re.sub(r' $', '!', text) # replaces a single space at the end of the string with an exclamation mark\n    text = text.replace(\" \", \"_\") # replaces all other single spaces with underscores\n    text = re.sub(r'-\\b', '_', text) # replaces a dash followed by word boundary with underscore\n    text = re.sub(r'-{2,}$', lambda m: '!'*len(m.group()), text) # replaces ending dashes with exlamation marks.\n    \n    return text",
      "def replace_space(original_string, character):\n    # First replace all spaces with given character\n    new_string = original_string.replace(\" \", character)\n    \n    # Then find all occurrences of more than two consecutive characters and replace them with two characters\n    new_string = re.sub(character + \"{3,}\", character*2, new_string)\n    \n    return new_string",
      "def normalize_text(text):\n    # Convert all characters to lowercase\n    text = text.lower()\n    \n    # Remove all punctuation marks\n    text = text.translate(str.maketrans(\"\", \"\", string.punctuation))\n    \n    # Remove all numbers\n    text = ''.join([i for i in text if not i.isdigit()])\n    \n    # Remove any leading or trailing white spaces\n    text = text.strip()\n    \n    # Replace all consecutive spaces with a single space\n    text = ' '.join(text.split())\n    \n    return text",
      "def intricate_text_transformation(input_text):\n    \"\"\" \n    Given a string called input_text, the function carries out the transformations \n    including transforming text to uppercase, replacing blank spaces with underscores\n    and replacing two or more sequential spaces with a hyphen. \n    \"\"\"\n    input_text = input_text.replace(\" \", \"_\") # replacement of blank space with underscore\n    while \"__\" in input_text:\n        input_text = input_text.replace(\"__\", \"-\") # replacement of sequential underscores with a hyphen\n    return input_text.upper() # transforming all expressions to their uppercase equivalents"
    ],
    "HumanEval/141": [
      "def file_name_check(file_name):\n    # Check if the file's name length is within the allowed range\n    if not 5 <= len(file_name) <= 50:\n        return \"No\"\n\n    name, dot, extension = file_name.rpartition('.')\n\n    # Check if the file's name has exactly one dot and a valid extension\n    if not dot or extension not in ['txt', 'exe', 'dll', 'pdf', 'jpeg']:\n        return \"No\"\n\n    # Check if the file's name has valid alphanumeric characters, and has at least\n    # one uppercase, one lowercase, and maximum of three consecutive digits\n    if not (re.search(r'[A-Za-z].*', name) and\n            re.search(r'[A-Z]', name) and\n            re.search(r'[a-z]', name) and\n            not re.search(r'\\d{4,}', name)):\n        return \"No\"\n\n    # Check if the file's name has exactly two latin alphabet letters\n    if len(re.findall(r'[A-Za-z]', name)) != 2:\n        return \"No\"\n    \n    return \"Yes\"",
      "def file_name_check(file_name):\n    # Check if the file's name length is within the allowed range\n    if not 5 <= len(file_name) <= 50:\n        return \"No\"\n    \n    name, dot, extension = file_name.rpartition('.')\n    \n    # Check if the file's name has exactly one dot and a valid extension\n    if not dot or extension not in ['txt', 'exe', 'dll', 'pdf', 'jpeg']:\n        return \"No\"\n    \n    # Check if the file's name has valid alphanumeric characters, and has at least\n    # one uppercase, one lowercase, and maximum of three consecutive digits\n    if not (re.match(r'[A-Za-z].*$', name) and\n            re.search(r'[A-Z]', name) and\n            re.search(r'[a-z]', name) and\n            not re.search(r'\\d{4,}', name)):\n        return \"No\"\n    \n    # Check if the file's name has exactly two latin alphabet letters\n    if len(re.findall(r'[A-Za-z]', name)) < 2:\n        return \"No\"\n    \n    return \"Yes\"",
      "def file_name_check(file_name):\n    # Check the length\n    if len(file_name)<5 or len(file_name)>50:\n        return 'No'\n\n    # Split the file name based on '/' to get nested names\n    list_of_file_names = file_name.split('/')\n\n    # Iterate for every file in the path\n    for name in list_of_file_names:\n        # Split the extension from the file name using '.'\n        # Check if the file name is empty\n        # Check if there are more than one dots present\n        split_name = name.split('.')\n        if len(split_name) != 2 or not split_name[0] or not split_name[1]:\n            return 'No'\n\n        # Check the extension\n        if split_name[1].lower() not in [\"txt\", \"exe\", \"dll\", \"pdf\", \"jpeg\"]:\n            return 'No'\n\n        # Check if file name starts with a letter and has no more than three digits \n        # Search for the regular expression which satisfies the condition\n        if not re.search('[a-zA-Z].*(a-zA-Z)', split_name[0]) or len(re.findall('\\d', split_name[0])) > 3:\n            return 'No'\n\n    return 'Yes'",
      "def file_name_check(file_name):\n    # Check the length  \n    if len(file_name)<5 or len(file_name)>50:\n        return 'No'\n  \n    # Split the file name based on '/' to get nested names\n    list_of_file_names = file_name.split('/')\n  \n    # Iterate for every file in the path\n    for name in list_of_file_names:\n        # Split the extension from the file name using '.'\n        # check if the file name is empty\n        # check if there are more than one dots present\n        split_name = name.split('.')\n        if len(split_name) != 2 or not split_name[0] or not split_name[1]:\n            return 'No'\n        \n        # Check the extension\n        if split_name[1].lower() not in [\"txt\", \"exe\", \"dll\", \"pdf\", \"jpeg\"]:\n            return 'No'\n        \n        # Check if file name starts with a letter and has no more than three digits \n        # Search for the regular expression which satisfy the condition\n        if not re.search('[a-zA-Z].*[a-zA-Z]', split_name[0]) or len(re.findall('\\d', split_name[0])) > 3:\n            return 'No'\n  \n    return 'Yes'",
      "def file_name_check(file_name):\n    # Check for the reserved Windows characters\n    reserved_chars = ['<', '>', ':', '\"', '/', '\\\\', '|', '?', '*']\n    if any(c in file_name for c in reserved_chars):\n        return 'No'\n    # Check for the length requirement\n    if not (5 <= len(file_name) <= 50):\n        return 'No'\n    # Check if the file name has exactly one dot and get the name and extension parts\n    parts = file_name.split('.')\n    if len(parts) != 2:\n        return 'No'\n    name, extension = parts\n    # Check the conditions for the name part\n    if not re.match(r'^[a-zA-Z][a-zA-Z0-9]*$', name) or not any(c.isupper() for c in name) or not any(c.islower() for c in name) or len(re.findall(r'\\d{4,}', name)) > 0:\n        return 'No'\n    # Check the conditions for the extension part\n    if extension not in ['txt', 'exe', 'dll', 'pdf', 'jpeg']:\n        return 'No'\n    return 'Yes'"
    ],
    "HumanEval/142": [
      "def strange_sort_list_bst(lst):\n    '''\n    This function should accept a list of integers and decimal numbers and return the list in a specific pattern, leveraging the principles of a binary search tree. The steps for this peculiar sorting pattern should be:\n    - Commence with the smallest number.\n    - Next, identify the highest value from the remaining elements.\n    - Then, ascertain the lowest value among the untouched output, and continue in this manner.\n    \n    Examples:\n    strange_sort_list_bst([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list_bst([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list_bst([]) == []\n    strange_sort_list_bst([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n    \n    # First, we will sort the list in ascending order.\n    lst.sort()\n\n    output = []\n\n    # Then, while lst is not empty, we will remove and append to output the smallest\n    # and largest element alternatively.\n    while lst:\n        output.append(lst.pop(0))  # smallest\n        if lst:\n            output.append(lst.pop(-1))  # largest\n\n    return output",
      "def strange_sort_list_bst(lst):\n    '''\n    This function should accept a list of integers and decimal_numbers and return the list in a specific pattern, leveraging the principles of a binary search tree. The steps to this peculiar_sorting pattern should be:\n    - Commence with the smallest number.\n    - Next, identify the highest value from the remaining elements.\n    - Then, ascertain the lowest_value among the untouched output, and continue in this manner.\n\n    Examples:\n    strange_sort_list_bst([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list_bst([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list_bst([]) == []\n    strange_sort_list_bst([-2, 1.5, 3.5, -1]) == [-2, 3.5, -1, 1.5]\n    '''\n\n    # First, we will sort the list in ascending_order.\n    lst.sort()\n\n    output = []\n\n    # Then, while lst is not empty, we will remove and append to output the smallest\n    # and largest element alternately.\n    while lst:\n        output.append(lst.pop(0))  # smallest\n        if lst:\n            output.append(lst.pop(-1))  # largest\n\n    return output",
      "def multiply(lst):\n    \"\"\"Given a non-empty list of integers lst, perform multiple steps calculation to find the product of odd elements located at even indices. Ensure none of the elements in the list exceeds 100 and that you handle possible exceptions. Additionally, guarantee the final product does not exceed 5000.\n\n    Example\uff1a\n         multiply([3, 5, 7, 8, 9]) ==> 21\n    \"\"\"\n    if not lst:    # if list is empty \n        return \"Input list should not be empty.\"\n    if not all(type(i) == int for i in lst):    # if list has non-integer elements \n        return \"All elements of the input list should be integer.\"\n    if not all(0 <= i <= 100 for i in lst):    # if list has elements exceeding 100\n        return \"Elements of the list should not exceed 100.\"\n    try:\n        product = 1\n        for i in range(0, len(lst), 2):    # skipping 1 element i.e., considering elements at even indices\n            if lst[i] % 2 != 0:    # if the element is odd\n                product *= lst[i]\n                if product > 5000:    # if the product exceeds 5000\n                    return \"Product exceeded 5000.\"\n        return product\n    except Exception as e:\n        return str(e)",
      "def multiply(lst):\n    \"\"\"Given a non-empty list of integers lst, perform multiple steps calculation to find the product of odd elements located at even indices. Ensure none of the elements in the list exceeds 100 and that you handle possible exceptions. Additionally, guarantee the final product does not exceed 5000.\n\n    Example\uff1a\n    multiply([3, 5, 7, 8, 6]) ==> 21\n    \"\"\"\n    if not lst:    # if list is empty \n        return \"Input list should not be empty.\"\n    if not all(type(i) == int for i in lst):    # if list has non-integer elements \n        return \"All elements of the input list should be integers.\"\n    if not all(0 <= i <= 100 for i in lst):    # if list has elements exceeding 100\n        return \"Elements of the list should not exceed 100.\"\n    try:\n        product = 1\n        for i in range(0, len(lst), 2):    # skipping 1 element i.e., considering elements at even indices\n            if lst[i] % 2 != 0:    # if the element is odd\n                product *= lst[i]\n            if product > 5000:    # if the product exceeds 5000\n                return \"Product exceeded 5000.\"\n        return product\n    except Exception as e:\n        return str(e)",
      "def create_dictionary(keys, values):\n    # Check if the length of the keys list is a multiple of 2\n    if len(keys) % 2 != 0:\n        return \"Length of keys list should be a multiple of 2.\"\n\n    # Check if the length of the values list is a multiple of 3\n    if len(values) % 3 != 0:\n        return \"Length of values list should be a multiple of 3.\"\n\n    # Check if the lengths of keys and values lists are the same\n    if len(keys) != len(values):\n        return \"Lengths of keys and values lists should be equal.\"\n\n    # Create an empty dictionary\n    dictionary = {}\n\n    # Iterate over the keys and values lists simultaneously\n    for key, value in zip(keys, values):\n        # Check if the key is unique\n        if key in dictionary:\n            return \"Keys should be unique.\"\n        \n        # Check if the value is of type string\n        if not isinstance(value, str):\n            return \"Values should be of type string.\"\n\n        # Add key-value pair to the dictionary\n        dictionary[key] = value\n\n    return dictionary"
    ],
    "HumanEval/143": [
      "def detect_hate_speech(sentence):\n    # Define a list of hateful words or phrases\n    hateful_words = ['offensive_word1', 'offensive_word2', 'offensive_word3']\n\n    # Preprocess the sentence by removing non-alphabetic characters and converting to lowercase\n    processed_sentence = re.sub(r'[^a-zA-Z\\s]', '', sentence.lower())\n\n    # Split the processed sentence into characters\n    characters = list(processed_sentence)\n\n    # Check if any hateful words are present in the sentence\n    for word in hateful_words:\n        if word in characters:\n            return \"The sentiment of the sentence is: Hateful. The sentence contains hate speech.\"\n\n    # If no hateful words are found, the sentence is non-hateful\n    return \"The sentiment of the sentence is: Non-Hateful. The sentence does not contain any hate speech.\"",
      "def check(sentence):\n    words = sentence.split()\n    words = [normalize(word) for word in words]\n\n    for word in words:\n        if not is_palindrome(word):\n            return \"The sentence is not composed of palindromes.\"\n\n    if len(set(words)) < 2: \n        return \"The sentence is composed of palindromes. However, the words are not anagrams of each other.\"\n    \n    first_word = words[0]\n    remainder_words = words[1:]\n\n    if is_anagram(first_word, remainder_words):\n        return \"The sentence is composed of palindromes and every word is an anagram of each other.\"\n    else:\n        return \"The sentence is composed of palindromes. However, the words are not anagrams of each other.\"",
      "def shorthand_notation(sentence):\n    \"\"\"\n    Develop an algorithm for converting a given sequence of words into its equivalent shorthand notations.\n    \n    Parameters:\n    sentence (string): the sentence to be converted\n    \n    Returns:\n    string: the converted sentence\n    \"\"\"\n    words = sentence.split(\" \")\n    result = \"\"\n    for word in words:\n        result += word[0]\n    return result",
      "def delete_words_at_end(sentence):\n    # Define regular expression to match \"at the end\" phrases\n    at_the_end_regex = re.compile(r'\\bat the end\\b')\n    # Find all \"at the end\" phrases in the sentence\n    at_the_end_matches = at_the_end_regex.finditer(sentence)\n    # Loop through each \"at the end\" phrase\n    for match in at_the_end_matches:\n        # Prompt the user to select which words to delete\n        words_to_delete = input(f\"Which three words would you like to delete from '{match.group(0)}'? \")\n        # Split the words to delete into a list\n        words_to_delete_list = words_to_delete.split()\n        # Delete the selected words from the sentence\n        sentence = sentence[:match.start()] + sentence[match.end():]\n        for word in words_to_delete_list:\n            sentence = sentence.replace(word, '', 1)\n    # Return the revised sentence\n    return sentence",
      "def kebab_case(sentence):\n    # If input is not of string data type, return an error message\n    if not isinstance(sentence, str):\n        return 'Input must be a string.'\n\n    # If input is an empty string return an empty string\n    if sentence == '':\n        return ''\n\n    # Replace non-alphabetic characters with a space\n    modified_sentence = re.sub(r'[^A-Za-z0-9 ]', ' ', sentence)\n\n    # Split the sentence into words\n    words = modified_sentence.split()\n\n    # Join the words with hyphen and convert to lower case\n    kebab_case = \"-\".join(words).lower()\n\n    return kebab_case"
    ],
    "HumanEval/144": [
      "def divide_numbers(numerator, denominator):\n    try:\n        quotient = numerator / denominator\n        print(\"The quotient is:\", quotient)\n    except ZeroDivisionError:\n        print(\"Error: You are attempting to divide by zero.\")\n    except TypeError:\n        print(\"Error: Invalid input. Both the numerator and denominator should be numbers.\")\n    finally:\n        print(\"This is the end of the division operation.\")",
      "def add_up_fractions(lst):\n    \"\"\"\n    Given a list of numerical items in the form of fractions, the function aims to return \n    the summation of these fractions, but only tackles the fractions whose bottom value is an even number.\n    \"\"\"\n    total = Fraction(0, 1)\n    for fraction in lst:\n        if fraction == '0':\n            continue\n        \n        numerator, denominator = map(int, fraction.split('/'))\n\n        if denominator % 2 == 0:\n            total += Fraction(numerator, denominator)\n\n    return str(total)",
      "def mixed_to_improper(mixed_fractions):\n    improper_fractions = []\n    for fraction in mixed_fractions:\n        parts = fraction.split()\n        whole = int(parts[0])\n        numerator, denominator = map(int, parts[1].split('/'))\n        if whole < 0:\n            numerator = -numerator + (abs(whole) * denominator)\n        else:\n            numerator = numerator + (whole * denominator)\n        improper_fractions.append(f\"{numerator}/{denominator}\")\n    return improper_fractions",
      "def calculate_denominator(A, c, dual, b):\n    \"\"\"\n    Calculate the denominator of a fraction.\n\n    Args:\n    A: numpy.ndarray, the constraint matrix with shape (m, n)\n    c: numpy.ndarray, the coefficients of the objective function with shape (n,)\n    dual: numpy.ndarray, the dual variables with shape (m,)\n    b: numpy.ndarray, the right-hand side of the constraints with shape (m,)\n\n    Returns:\n    float, the calculated denominator value\n    \"\"\"\n    m, n = A.shape\n    denominator = 0\n    for i in range(m):\n        denominator += np.dot(c, A[i]) * dual[i]\n    return denominator",
      "def divide(numerator, denominator):\n    if denominator == 0:\n        raise ZeroDivisionError(\"Denominator cannot be zero.\")\n    \n    sign = -1 if (numerator < 0) ^ (denominator < 0) else 1\n    numerator = abs(numerator)\n    denominator = abs(denominator)\n    \n    quotient = 0\n    while numerator >= denominator:\n        numerator -= denominator\n        quotient += 1\n    \n    return sign * quotient"
    ],
    "HumanEval/145": [
      "def odd_sum_elements(x):\n    \"\"\"Given a list of positive integers x, return a sorted list of all \n    _unique_ elements where the sum of their digits is an odd number.\n\n    Note: The returned list should be sorted in ascending order. \n\n    >>> odd_sum_elements([15, 33, 1422, 1, 15])\n    [1, 15]\n    >>> odd_sum_elements([152, 323, 1422, 10])\n    [323]\n\n    \"\"\"\n    odd_sum_digits = []\n    for i in set(x):\n        if sum(int(digit) for digit in str(i)) % 2 != 0:\n            odd_sum_digits.append(i)\n    return sorted(odd_sum_digits)",
      "def unique_odd_digit_sum(x):\n    \"\"\"Given a list of integers x, return a sorted list of unique positive integers that have an odd sum of their digits. The same integer should not appear twice.  \n\n    Sort the final output list in ascending order. \n\n    E.g.:\n    >>> unique_odd_digit_sum([15, 38, 1420, 1, 15])\n    [1]\n    >>> unique_odd_digit_sum([154, 323, 1422, 10])\n    [323]\n    >>> unique_odd_digit_sum([-15, 38, -1420, -1, 15])\n    [15]\n    \"\"\"\n\n    # Create an empty list to store the resulting integers\n    result = []\n\n    # Loop over the input list x\n    for num in x:\n        # Exclude negative numbers\n        if num < 0:\n            continue\n\n        # Calculate the sum of the digits of num\n        digit_sum = sum(int(digit) for digit in str(num))\n\n        # Exclude integers with an even sum of digits\n        if digit_sum % 2 == 0:\n            continue\n\n        # Exclude integers that are already in the result list\n        if num in result:\n            continue\n\n        # Add the integer to the result list\n        result.append(num)\n        \n    return sorted(result)",
      "def unique_odd_digit_sum(x):\n    \"\"\"\n    Given a list of integers x, return a sorted list of unique positive integers\n    that have an odd sum of their digits. The same integer should not appear twice.\n    Sort the final output list in ascending order.\n\n    E.g.:\n    >>< unique_odd_digit_sum([15, 38, 1420, 1, 15])\n    [1]\n    >>< unique_odd_digit_sum([154, 323, 122, 10])\n    [323]\n    >>< unique_odd_digit_sum([-15, 38, 1420, -1, 15])\n    [15]\n    \"\"\"\n    \n    # Create an empty list to store the resulting integers\n    result = []\n\n    # Loop over the input list\n    for num in x:\n        # Exclude negative numbers\n        if num < 0:\n            continue\n\n        # Calculate the sum of the digits of num\n        digit_sum = sum(int(digit) for digit in str(num))\n\n        # Exclude integers with an even sum of digits\n        if digit_sum % 2 == 0:\n            continue\n\n        # Exclude integers that are already in the result list\n        if num in result:\n            continue\n\n        # Add the integer to the result list\n        result.append(num)\n\n    return sorted(result)",
      "def split_odd_totals(y):\n    \"\"\"In this function, given an array y of positive integers, generate two sorted arrays. One includes \n    _singular_ elements whose sum of their digits is odd and ends with an odd number, and other with \n    elements whose sum of their digits is odd and ends with an even number, both in ascending sequence.\n\n    >>> split_odd_totals([15, 33, 1422, 1, 15])\n    ([1, 15, 33], [1422])\n    >>> split_odd_totals([152, 323, 1422, 10])\n    ([323], [152, 1422])\n    \"\"\"\n\n    odd_ending = []\n    even_ending = []\n\n    for num in y:\n        digit_sum = sum(int(digit) for digit in str(num))\n        \n        if digit_sum % 2 != 0: # sum of digits is odd\n            if num % 2 != 0: # number ends with odd digit\n                odd_ending.append(num)\n            else: # number ends with even digit\n                even_ending.append(num)\n                \n    return sorted(odd_ending), sorted(even_ending)",
      "def prime_digit_product(x):\n    \"\"\"Given a list of positive integers x, return a sorted list of all \n    _distinct_ elements wherein the product of its digits is a prime number.\n\n    Note: The resulting list should be sorted in ascending order. \n\n    >>> prime_digit_product([15, 33, 1422, 1, 15])\n    [1, 15]\n    >>> prime_digit_product([152, 323, 1422, 10])\n    [323]\n\n    \"\"\"\n    return sorted(set([i for i in x if is_prime(prod([int(d) for d in str(i)]))]))"
    ],
    "HumanEval/146": [
      "def split_odd_totals(y):\n    \"\"\"In this function, given an array y of positive integers, generate two sorted arrays. One includes \n    _singular_ elements whose sum of their digits is odd and ends with an odd number, and other with \n    elements whose sum of their digits is odd and ends with an even number, both in ascending sequence.\n\n    >>> split_odd_totals([15, 33, 1422, 1, 15])\n    ([1, 15, 33], [1422])\n    >>> split_odd_totals([152, 323, 1422, 10])\n    ([323], [152, 1422])\n    \"\"\"\n\n    odd_ending = []\n    even_ending = []\n\n    for num in y:\n        digit_sum = sum(int(digit) for digit in str(num))\n        \n        if digit_sum % 2 != 0: # sum of digits is odd\n            if num % 2 != 0: # number ends with odd digit\n                odd_ending.append(num)\n            else: # number ends with even digit\n                even_ending.append(num)\n                \n    return sorted(odd_ending), sorted(even_ending)",
      "def enhanced_solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are at even positions.    \n\n    Examples\n    enhanced_solution([5, 8, 7, 1]) => 5\n    enhanced_solution([3, 3, 3, 3, 3]) => 9\n    enhanced_solution([30, 13, 24, 321]) => 30\n    \"\"\"\n    return sum(num for i, num in enumerate(lst[::2]) if num % 2 == 1)",
      "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Authoritatively yield manually ordered, non-repetitive intersecting elements for two lists. \n    This function is constructed to handle integer arrays including negative integers, without depending \n    on inherent Python list functionalities. The function returns a well-ordered list eliminating any duplicates.\n    If one of the lists is empty, the function returns an empty list. \n    \n    :param l1: The first list of integers.\n    :type l1: list\n    :param l2: The second list of integers.\n    :type l2: list\n    :returns: A list containing ordered intersecting elements from both lists, without duplicates.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    >>> common([-2, -3, 0, 2, 5], [-5, 2, 0, -3])\n    [-3, 0, 2]\n    >>> common([-2, -3, 0, 2, 5], [])\n    []\n    \"\"\"\n    common_set = set()\n    ordered_set = set()\n    \n    # Traverse through lists and add common elements to common_set\n    for num in l1:\n        if num in l2 and num not in common_set:\n            common_set.add(num)\n            \n    # Traverse through common_set and add elements into ordered_set in sorted order.\n    # This step ensures the elimination of duplicate elements and correct ordering.\n    for num in sorted(common_set):\n        ordered_set.add(num)\n    \n    return list(ordered_set)",
      "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Authoritatively yield manually ordered, non-repetitive intersecting elements for two lists.\n    This function is constructed to handle integer arrays including negative integers,without depending \n    on inherent Python list functionalities. The function returns a well-ordered list eliminating any duplicates.\n    If one of the lists is empty, the function returns an empty list. \n\n    :param l1: The first list of integers.\n    :type l1: list\n    :param l2: The second list of integers.\n    :type l2: list\n    :returns: A list containing ordered intersecting elements from both lists, without duplicates.\n\n    >>> common([1, 4, 3, 34, 86, 2, 5], [5, 7, 1, 8, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    >>> common([-2, -3, 0, 2, 5], [-5, 2, 0, -3])\n    [-3, 0, 2]\n    >>> common([-2, -3, 0, 2, 5], [])\n    []\n    \"\"\"\n    common_set = set()\n    ordered_set = set()\n\n    # Traverse through lists and add common elements to common_set\n    for num in l1:\n        if num in l2 and num not in common_set:\n            common_set.add(num)\n\n    # Traverse through common_set and add elements into ordered_set in sorted order.\n    # This step ensures the elimination of duplicate elements and correct ordering.\n    for num in sorted(common_set):\n        ordered_set.add(num)\n\n    return list(ordered_set)",
      "def odd_sum_elements(x):\n    \"\"\"Given a list of positive integers x, return a sorted list of all \n    _unique_ elements where the sum of their digits is an odd number.\n\n    Note: The returned list should be sorted in ascending order. \n\n    >>> odd_sum_elements([15, 33, 1422, 1, 15])\n    [1, 15]\n    >>> odd_sum_elements([152, 323, 1422, 10])\n    [323]\n\n    \"\"\"\n    odd_sum_digits = []\n    for i in set(x):\n        if sum(int(digit) for digit in str(i)) % 2 != 0:\n            odd_sum_digits.append(i)\n    return sorted(odd_sum_digits)"
    ],
    "HumanEval/147": [
      "def get_max_triples(n, p):\n    # calculate the array 'a' according to formula\n    a = [(i * i - i + p) + (i % p) for i in range(1, n+1)]\n    \n    # initialize count of triples to 0\n    counters = 0\n\n    # consider all triples a[i], a[j], a[k] such that i < j < k\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                # calculate modulus of product a[i]*a[j] by a[k]\n                product_modulus = (a[i] * a[j]) % a[k]\n\n                # check if the result is a multiple of n or p, increment the count\n                if product_modulus % n == 0 or product_modulus % p == 0:\n                    counters += 1\n\n    return counters",
      "def get_max_triples(n):\n    # Create an array 'a' of length 'n' with elements as per the given formula\n    a = [(i * i - i + 1) + (i % 3) for i in range(1, n + 1)]\n    triple_count = 0  # Initialize variable to count triples\n\n    #For all possible combinations of three items (a[i], a[j], a[k])\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                # Calculate the modulus of the product of any two elements by the third\n                product = (a[i] * a[j]) % a[k]\n                # Check if the result is a multiple of n\n                if product % n == 0:\n                    triple_count += 1  # Increment the counter if true\n\n    return triple_count  # Return the number of desired triples",
      "def lll_reduction(A):\n    \"\"\"\n    Implementation of the Lenstra-Lenstra-Lov\u00e1sz (LLL) algorithm for lattice reduction.\n\n    The LLL algorithm is a probabilistic polynomial-time algorithm for finding a short basis\n    of an integer lattice. It is based on the idea of Gram-Schmidt orthogonalization and\n    is a key component of many lattice-based cryptographic algorithms.\n\n    :param A: A matrix representing the basis of a lattice L.\n    :return: The reduced basis matrix B.\n    \"\"\"\n    n, m = A.shape\n    B = np.copy(A)\n    mu = np.array([np.linalg.norm(B[i]) ** 2 for i in range(n)])\n    k = 1\n\n    while k < n:\n        for j in range(k - 1, -1, -1):\n            mu[k] = mu[k] - (mu[j] * (B[k] @ B[j]) ** 2) / mu[j]\n            B[k] = B[k] - (B[j] * np.dot(B[k], B[j])) / mu[j]\n\n        if mu[k] < (0.75 - 0.5 * 0.5 ** k) * mu[k - 1]:\n            B[[k, k - 1]] = B[[k - 1, k]]\n            mu[[k, k - 1]] = mu[[k - 1, k]]\n            k = max(k - 1, 1)\n        else:\n            k += 1\n\n    return B",
      "def solve_linear_system(A):\n    n = len(A)\n\n    for i in range(n):\n        # Partial pivoting\n        max_row = i\n        for k in range(i+1, n):\n            if abs(A[k, i]) > abs(A[max_row, i]):\n                max_row = k\n        A[[i, max_row]] = A[[max_row, i]]\n\n        if A[i, i] == 0:\n            return \"Infinite solutions or inconsistent system\"\n\n        for j in range(i+1, n):\n            factor = A[j, i] / A[i, i]\n            A[j, i:] -= factor * A[i, i:]\n\n    if A[n-1, n-1] == 0:\n        return \"Infinite solutions or inconsistent system\"\n\n    x = np.zeros(n)\n    for i in range(n-1, -1, -1):\n        x[i] = (A[i, n] - np.dot(A[i, i+1:n], x[i+1:])) / A[i, i]\n\n    return x",
      "def gauss_elimination(a, b):\n    a = a.astype(float)\n    b = b.astype(float)\n    n = len(a)\n    for k in range(n):\n        # Pivot for column k\n        i_max = np.argmax(np.abs(a[k:,k])) + k \n        if a[i_max, k] == 0:\n            raise ValueError(\"Matrix is singular.\")\n        # Swap rows\n        a[[k, i_max]] = a[[i_max, k]]\n        b[[k, i_max]] = b[[i_max, k]]\n        # Gauss elimination\n        for i in range(k+1, n):\n            factor = a[i,k] / a[k,k]\n            a[i, k:] = a[i, k:] - factor * a[k, k:]\n            b[i] = b[i] - factor * b[k]\n    # Back substitution\n    x = np.zeros_like(b)\n    for k in range(n-1, -1, -1):\n        x[k] = (b[k] - np.dot(a[k, k+1:], x[k+1:])) / a[k, k]\n    return x"
    ],
    "HumanEval/148": [
      "def greet(*planets):\n    valid_planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    for planet in planets:\n        if planet in valid_planets:\n            if planet == \"Earth\":\n                print(\"Greetings Earth\")\n            else:\n                print(f\"{planet} is a valid planet but the greetings is only for Earth\")\n        else:\n            print(f\"Error: {planet} is not a valid planet\")",
      "def planet_distance_from_sun(planets):\n    # Defined distance from the sun in astronomical units (AU where 1 AU = 149,597,870.7)\n    distances = {\n        \"Mercury\": 0.387,\n        \"Venus\": 0.723,\n        \"Earth\": 1.000,\n        \"Mars\": 1.524,\n        \"Jupiter\": 5.203,\n        \"Saturn\": 9.537,\n        \"Uranus\": 19.191,\n        \"Neptune\": 30.069\n    }\n\n    # Sorting the planets by distance from the sun\n    sorted_planets = sorted(list(distances.keys()), key=lambda x: distances[x])\n\n    return sorted_planets",
      "def bf(planet1, planet2, planet3):\n    if is_valid(planet1) and is_valid(planet2) and is_valid(planet3): \n    # Sort the planets based on their position in the solar system\n        planets = sorted([planet1, planet2, planet3], key=SOLAR_SYSTEM.index)\n        return get_neighbors(planets[-1])  # Return the neighbors of the furthest planet\n    else:\n        return ()",
      "def bf(planet1, planet2, planet3):\n    if is_valid(planet1) and is_valid(planet2) and is_valid(planet3): \n        # sort the planets based on their position in the solar system\n        planets = sorted([planet1, planet2, planet3], key=SOLAR_SYSTEM.index)\n        return get_neighbors(planets[-1])  # return the neighbors of the furthest planet\n    else:\n        return ()",
      "def bf(planet1, planet2):\n    if is_valid(planet1) and is_valid(planet2):\n        # Sorted list of planet names\n        sorted_planets = sorted(PLANETS, key=PLANETS.get)\n        \n        idx1, idx2 = sorted_planets.index(planet1), sorted_planets.index(planet2)\n        # Ensure idx1 is always less than idx2\n        if idx2 < idx1:\n            idx1, idx2 = idx2, idx1       \n        planets_between = sorted_planets[idx1+1:idx2]\n        \n        result = []\n        for planet in planets_between:\n            # Calculate time to travel from the sun to each planet at the speed of light\n            time_to_planet = PLANETS[planet]*10**6/SPEED_OF_LIGHT\n            result.append((planet, time_to_planet)) \n            \n        return tuple(result)\n    else:\n        return ()"
    ],
    "HumanEval/149": [
      "def complex_sorted_list(lst, reverse=False, min_sum=0, max_sum=None, sort_function=None, secondary_sort_function=None):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter and performs the following:\n    - Delete strings with odd lengths or containing numerals.\n    - Sort the list based on the sum of the ASCII values of the characters in each string.\n    - The list may contain duplicates, ignore case, and special characters.\n    - Toggle sorting between ascending and descending order using an optional boolean `reverse` (default is False).\n    - Implement an optional minimum sum `min_sum` (default is 0) to return only strings with a sum greater or equal.\n    - Implement an optional maximum sum `max_sum` to return only strings with a sum less than or equal.\n    - Implement an optional custom sorting method `sort_function` to sort strings using a custom function.\n    - Implement an optional secondary custom sorting method `secondary_sort_function` to sort strings using a secondary function.\n    \n    E.g.:\n    assert complex_sorted_list([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert complex_sorted_list([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    assert complex_sorted_list([\"ab\", \"a\", \"aaa\", \"cd\"], True) => [\"cd\", \"ab\"]\n    assert complex_sorted_list([\"ab\", \"a\", \"aaa\", \"cd\"], min_sum=200) => [\"cd\"]\n    \"\"\"\n    \n    # Remove strings with odd lengths and strings containing numerals\n    clean_lst = [s for s in lst if len(s) % 2 == 0 and not any(c.isdigit() for c in s)]\n    \n    if not sort_function:\n        sort_function = lambda s: sum(ord(c) for c in s)\n    \n    if secondary_sort_function:\n        clean_lst.sort(key=secondary_sort_function)\n    \n    # Sort strings based on the sort_function\n    clean_lst.sort(key=sort_function, reverse=reverse)\n    \n    # Filter strings based on min_sum and max_sum\n    filtered_lst = [s for s in clean_lst if min_sum <= sort_function(s) <= (max_sum if max_sum else float(\"inf\"))]\n    \n    return filtered_lst",
      "def sorted_list_sum(lst, reverse=False):\n    \"\"\"\n    This function takes as input a list of strings, removes any string that contains a numerical digit or \n    an odd number of characters, sorts remaining strings in ascending order by both length and alphabetically, \n    and then returns the sorted list.\n    \n    Achieves this by using list comprehension to filter out unwanted elements, \n    and Python's built-in sorted function to sort the list. The sorted function uses a compound sorting key \n    consisting of the length of each element and the element itself, allowing for sorting by multiple criteria.\n    \n    The ordering of the sorted list can be reversed by supplying a second argument of True.\n\n    Parameters:\n    lst (list): A list of strings to be filtered and sorted.\n    reverse (bool): Optional parameter to reverse the order of the sorted list. Defaults to False.\n\n    Returns:\n    list: The sorted list of strings.\n    \"\"\"\n    \n    # Filter out any strings containing numerical digits or with odd length\n    lst = [i for i in lst if not any(j.isdigit() for j in i) and len(i) % 2 == 0]\n    \n    # Return the list sorted by length and then alphabetically, in ascending or descending order\n    return sorted(lst, key=lambda x: (len(x), x), reverse=reverse)",
      "def sorted_list(lst, reverse=False):\n    \"\"\"\n    This function takes a list of string literals, discards strings that are of odd lengths or contain digits, \n    and returns a sorted list according to the specified stipulations.\n    The list is sorted based on the length of each word in an ascending sequence. \n    For words of equivalent length, it is sorted in alphabetical order. \n    Case sensitivity and special characters are ignored during the sorting operation.\n    An optional boolean parameter `reverse`, with a default value set to False, can be used to toggle the sorting pattern \n    between ascending and descending.\n    Note:\n    The input will always be a list of string literals and can never be of numeric type.\n    The list can have duplicate elements.\n    \"\"\"\n    import re\n    \n    # Filter out string literals of odd length and those containing digits\n    filtered_list = [x for x in lst if len(x) % 2 == 0 and not bool(re.search(r'\\d', x))]\n    \n    # Sort the list first by length, then by alphabetical order (case insensitive), and optionally in reverse order\n    return sorted(filtered_list, key=lambda x: (len(x), x.lower()), reverse=reverse)",
      "def sort_strings(strings, descending=False):\n    \"\"\"\n    Sorts a list of strings according to their length, while also ensuring that strings with the same length are sorted\n    in alphabetical order. The function can sort the list in ascending or descending order based on user input.\n    \n    Args:\n        strings (list): A list of strings to be sorted\n        descending (bool, optional): If True, sorts the list in descending order. Defaults to False.\n    \n    Returns:\n        list: A sorted list of strings\n    \"\"\"\n    # Sort the strings by length and then by alphabetical order\n    sorted_strings = sorted(strings, key=lambda s: (len(s), s))\n    \n    # Reverse the list if descending is True\n    if descending:\n        sorted_strings.reverse()\n    \n    return sorted_strings",
      "def advanced_array_aggregation(lst, reverse=False):\n    \"\"\"\n    This function accepts a list of strings, filters the list by dropping strings of odd length or containing numbers,\n    and returns a sorted list based on the following criteria:\n    = All list entries must be strings; no grouping of numbers allowed\n    = Duplicates in the list are possible\n    = List is sorted in ascending order based on word length, and then alphabetically for words of the same length\n    = Ignore capitalization and special characters during sorting\n    Additionally, sorting order can be switched by initializing an optional logical 'reverse' parameter.\n\n    Furthermore, the function should also check for characters that appear more than twice in a single string and\n    discard these strings from the list.\n    \"\"\"\n\n    # We filter the strings of odd length or containing numbers\n    filtered = [s for s in lst if len(s) % 2 == 0 and not any(c.isdigit() for c in s)]\n    \n    # We check for characters that appear more than twice in a single string and discard these strings\n    filtered = [s for s in filtered if all(v <= 2 for v in Counter(s).values())]\n    \n    # Ignore capitalization and special characters during sorting\n    filtered = [\"\".join(ch for ch in s if ch.isalnum()) for s in filtered]\n    filtered = [s.lower() for s in filtered]\n\n    # Add some complexity by sorting the list according to length, and then by lexical order\n    filtered = sorted(filtered, key=lambda s: (len(s), s) , reverse=reverse)\n    \n    return filtered"
    ],
    "HumanEval/150": [
      "def x_or_y(n, x, y):\n    return x if _is_prime(n) else y",
      "def choose_num(x, y, z):\n    \"\"\"\n    This function accepts three positive integers x, y, and z, and its objective is to return the\n    greatest even integer within the inclusive range of [x, y] that can be evenly divided by z. In the\n    absence of such a number, the function should yield -1.\n\n    Example cases:\n    choose_num(12, 15, 2) = 14\n    choose_num(13, 12, 3) = -1\n    choose_num(10, 20, 4) = 20\n    \"\"\"\n\n    # Start checking from the largest number in the range [x, y]\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0 and num % z == 0:\n            return num\n    return -1",
      "def lowest_common_multiple(x: int, y: int) -> int:\n    \"\"\" Reveals the lowest common multiple for a couple of positive integers, x and y\n    >>> lowest_common_multiple(3, 5)\n    15\n    >>> lowest_common_multiple(25, 15)\n    75\n    \"\"\"\n    return abs(x*y) // math.gcd(x, y)",
      "def lowest_common_multiple(x: int, y: int) -> int:\n    \"\"\" Reveals the lowest common multiple for a couple of positive integers, x and y\n    >>> lowest_common_multiple(3, 5)\n    15\n    >>> lowest_common_multiple(25, 15)\n    75\n    \"\"\"\n    return abs(x*y) // math.gcd(x, y)",
      "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)"
    ],
    "HumanEval/151": [
      "def positive_cubes_sum(lst):\n    '''\n    This function calculates sum of cubes of both odd and even positive integers in a list.\n    \n    positive_cubes_sum([1, 2, 3, 4]) == 1 + 8 + 27 + 64 = 100\n    positive_cubes_sum([-1, -2, 1, 2]) == 9\n    positive_cubes_sum([8, -3]) == 512\n    positive_cubes_sum([0]) == 0\n\n    If input is empty, function should return 0.\n    '''\n    return sum(i**3 for i in lst if i > 0)",
      "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)",
      "def enhanced_solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are at even positions.    \n\n    Examples\n    enhanced_solution([5, 8, 7, 1]) => 5\n    enhanced_solution([3, 3, 3, 3, 3]) => 9\n    enhanced_solution([30, 13, 24, 321]) => 30\n    \"\"\"\n    return sum(num for i, num in enumerate(lst[::2]) if num % 2 == 1)",
      "def sum_of_even_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers: A list of integers.\n\n    Returns:\n    The sum of all even numbers in the list.\n    \n    Examples:\n    >>> sum_of_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    30\n    >>> sum_of_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_of_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)",
      "def sum_even_numbers(numbers):\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The sum of all even numbers in the list.\n\n    Examples:\n    >>> sum_even_numbers([1, 2, 3, 4, 5, 6])\n    12\n    >>> sum_even_numbers([10, 11, 12, 13, 14, 15])\n    36\n    >>> sum_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)"
    ],
    "HumanEval/152": [
      "def chosen_ciphertext_attack(key_length, plaintext_length, num_samples):\n    # Generate a key\n    key = generate_key(key_length)\n    \n    # Generate a series of ciphertexts\n    ciphertexts = []\n    for _ in range(num_samples):\n        plaintext = generate_plaintext(plaintext_length)\n        ciphertext = encrypt(key, plaintext)\n        ciphertexts.append((plaintext, ciphertext))\n    \n    # Analyze the ciphertexts to infer information (this is the part you need to implement)\n    # For example, you could try to guess the key by analyzing the ciphertexts\n    # and then using the known plaintext to confirm your guess.\n    \n    # Let's try to guess the key by looking at the distribution of XORed bits\n    guessed_key = ''\n    for i in range(plaintext_length):\n        # Count the number of 0s and 1s at position i across all ciphertexts\n        ones_count = sum(1 for plaintext, ciphertext in ciphertexts if ciphertext[i] == chr(ord(plaintext[i]) ^ ord('1')))\n        zeros_count = sum(1 for plaintext, ciphertext in ciphertexts if ciphertext[i] == chr(ord(plaintext[i]) ^ ord('0')))\n        \n        # The most common bit at position i in the ciphertexts is likely the bit of the key at position i\n        if ones_count > zeros_count:\n            guessed_key += '1'\n        else:\n            guessed_key += '0'\n    \n    # Confirm the guessed key by XORing it with a known plaintext and comparing with the ciphertext\n    known_plaintext = ciphertexts[0][0]  # Use the first plaintext as the known plaintext\n    known_ciphertext = ciphertexts[0][1]  # Use the first ciphertext as the known ciphertext\n    confirmed_key = ''.join(chr(ord(p) ^ ord(k)) for p, k in zip(known_plaintext, guessed_key))\n    \n    # Check if the confirmed key is correct\n    if confirmed_key == known_ciphertext:\n        print(\"The key was successfully guessed:\", guessed_key)\n    else:\n        print(\"The key was not guessed correctly.\")",
      "def veggie_distribution(s, n, veggies, servings, exp_dates, time_in_rack):\n    \"\"\"\n    In this task, you are provided with a list of phrases indicating different quantities of vegetables\n    stored in a rack. The rack can hold potatoes, tomatoes, onions, and other varieties.\n    The list might be represented as follows: [\"X potatoes\", \"Y tomatoes\", \"Z onions\",...]\n\n    You are also given a hash map that displays the number of servings each vegetable can provide,\n    another hash map that depicts the expiration dates of the veggies (format: YYYY-MM-DD), and a hash map\n    that shows the duration each vegetable has been stationed in the rack.\n    \n    Given this list, an integer denoting the total vegetables in the rack, the servings hash map, \n    the expiration dates hash map, and the duration in the rack, return a hash map that displays the \n    quantity of servings of each vegetable that is not expired and has been in the\n    rack for a duration of two hours or less.\n    \n    Note that the result should be a hash map that includes only the vegetables with a non-zero count of servings\n    and have been stationed in the rack for a maximum of two hours.\n    \"\"\"\n    from datetime import datetime, timedelta\n    valid_veggies = {}\n    current_time = datetime.now()\n\n    for veg in veggies:\n        veg_name = veg.split()[1]  # extract vegetable name\n        # check if it's not listed and not expired, and in the rack for a maximum of two hours\n        if (veg_name not in servings or servings[veg_name] == 0 or datetime.strptime(exp_dates[veg_name], \"%Y-%m-%d\") < current_time or time_in_rack[veg_name] > timedelta(hours=2)):\n            continue\n        else:\n            valid_veggies[veg_name] = servings[veg_name]\n            \n    return valid_veggies",
      "def abs_larger(x: Union[int, float], y: Union[int, float]) -> Union[int, float]:\n    \"\"\"\n    This function calculates the absolute value of the larger input.\n\n    Args:\n        x (Union[int, float]): The first input value\n        y (Union[int, float]): The second input value\n\n    Returns:\n        Union[int, float]: The absolute value of the larger input\n\n    Raises:\n        TypeError: If any input value is not an integer or float\n    \"\"\"\n\n    # check if the inputs are integers or floats\n    if not isinstance(x, (int, float)) or not isinstance(y, (int, float)):\n        raise TypeError(\"Input values must be integers or floats.\")\n\n    # calculate the absolute value of x and y\n    abs_x = abs(x)\n    abs_y = abs(y)\n\n    # compare the absolute values of x and y and return the larger absolute value\n    if abs_x > abs_y:\n        return abs_x\n    else:\n        return abs_y",
      "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function inserts a number 'delimeter' between each consectute elements of the input list `numbers` and deals with scenarios where the delimeter is negative.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    >>> intersperse([1, 2, 3], -2)\n    [1, 2, 3]\n    \"\"\" \n    result = []\n    abs_delimeter = abs(delimeter)\n    for i in range(len(numbers)):\n        result.append(numbers[i])\n        if i != len(numbers)-1:\n            # Exempt the index locations that matches absolute of negative delimeter\n            if i+1 != abs_delimeter:\n                result.append(delimeter)\n    return result",
      "def compareStrings(str1, str2):\n    '''Function to compare two strings and return the index of the first different character.'''\n    \n    # We assume that both strings have the same length\n    l1 = len(str1)\n    l2 = len(str2)\n    \n    # If the lengths are not equal, return -1\n    if l1 != l2:\n        return -1\n        \n    for i in range(l1):\n        if str1[i] != str2[i]:\n            return i\n    \n    # Return -1 if there is no difference between the strings\n    return -1"
    ],
    "HumanEval/153": [
      "def count_file_extensions(file_list):\n    \"\"\"\n    Counts the occurrences of unique file extensions in the given list of file names.\n\n    Args:\n    file_list: A list of strings representing file names.\n\n    Returns:\n    A dictionary where keys are unique file extensions and values are the count of their occurrences in the file_list.\n    \"\"\"\n    extension_count = {}\n    for file_name in file_list:\n        parts = file_name.split('.')\n        if len(parts) > 1:\n            extension = parts[-1]\n        else:\n            extension = ''\n        extension_count[extension] = extension_count.get(extension, 0) + 1\n    return extension_count",
      "def file_name_check(file_name):\n    # Check if the file's name length is within the allowed range\n    if not 5 <= len(file_name) <= 50:\n        return \"No\"\n\n    name, dot, extension = file_name.rpartition('.')\n\n    # Check if the file's name has exactly one dot and a valid extension\n    if not dot or extension not in ['txt', 'exe', 'dll', 'pdf', 'jpeg']:\n        return \"No\"\n\n    # Check if the file's name has valid alphanumeric characters, and has at least\n    # one uppercase, one lowercase, and maximum of three consecutive digits\n    if not (re.search(r'[A-Za-z].*', name) and\n            re.search(r'[A-Z]', name) and\n            re.search(r'[a-z]', name) and\n            not re.search(r'\\d{4,}', name)):\n        return \"No\"\n\n    # Check if the file's name has exactly two latin alphabet letters\n    if len(re.findall(r'[A-Za-z]', name)) != 2:\n        return \"No\"\n    \n    return \"Yes\"",
      "def file_name_check(file_name):\n    # Check if the file's name length is within the allowed range\n    if not 5 <= len(file_name) <= 50:\n        return \"No\"\n    \n    name, dot, extension = file_name.rpartition('.')\n    \n    # Check if the file's name has exactly one dot and a valid extension\n    if not dot or extension not in ['txt', 'exe', 'dll', 'pdf', 'jpeg']:\n        return \"No\"\n    \n    # Check if the file's name has valid alphanumeric characters, and has at least\n    # one uppercase, one lowercase, and maximum of three consecutive digits\n    if not (re.match(r'[A-Za-z].*$', name) and\n            re.search(r'[A-Z]', name) and\n            re.search(r'[a-z]', name) and\n            not re.search(r'\\d{4,}', name)):\n        return \"No\"\n    \n    # Check if the file's name has exactly two latin alphabet letters\n    if len(re.findall(r'[A-Za-z]', name)) < 2:\n        return \"No\"\n    \n    return \"Yes\"",
      "def peculiar_ordering(lst, d):\n    '''\n    Given a list of integers and a dictionary with integer keys and unique string values, return the list in a special order.\n    \n    normalize the input list to have a mean of zero and a standard deviation of one.\n    \n    For each element in the list, append its corresponding string value from the dictionary to a new list.\n    The peculiarity of ordering the string values extends to removing any duplicate string values in the new list no matter how often they appear in the original list.\n    \n    Then order this new list in a peculiar manner:\n    - Start with the string associated with the minimal value integer.\n    - Then, find the string associated with the maximum remaining integer.\n    - Next, find the string associated with the minimum remaining integer, and so on.\n    The function should also handle negative integers, and decimal numbers and there should be a mapping provided for them in the dictionary. \n\n    For example:\n    peculiar_ordering([1, 2, 3, 4, 5], {1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e'}) == ['a', 'b', 'c', 'd','e']\n    Note: In the example, 'a' represents 1, 'b' represents 2, etc.\n    '''\n    # normalize the input list\n    lst = [(i - np.mean(lst)) / np.std(lst) for i in lst]\n\n    value_order = []\n\n    for v in lst:\n        value = d.get(v)\n        \n        if value not in value_order:\n            value_order.append(value)\n\n    # sort the values in a peculiar order\n    value_order = sorted(value_order, key=lambda x: (value_order.index(x) % 2, x))\n\n    return value_order",
      "def veggie_distribution(s, n, veggies, servings, exp_dates, time_in_rack):\n    \"\"\"\n    In this task, you are provided with a list of phrases indicating different quantities of vegetables\n    stored in a rack. The rack can hold potatoes, tomatoes, onions, and other varieties.\n    The list might be represented as follows: [\"X potatoes\", \"Y tomatoes\", \"Z onions\",...]\n\n    You are also given a hash map that displays the number of servings each vegetable can provide,\n    another hash map that depicts the expiration dates of the veggies (format: YYYY-MM-DD), and a hash map\n    that shows the duration each vegetable has been stationed in the rack.\n    \n    Given this list, an integer denoting the total vegetables in the rack, the servings hash map, \n    the expiration dates hash map, and the duration in the rack, return a hash map that displays the \n    quantity of servings of each vegetable that is not expired and has been in the\n    rack for a duration of two hours or less.\n    \n    Note that the result should be a hash map that includes only the vegetables with a non-zero count of servings\n    and have been stationed in the rack for a maximum of two hours.\n    \"\"\"\n    from datetime import datetime, timedelta\n    valid_veggies = {}\n    current_time = datetime.now()\n\n    for veg in veggies:\n        veg_name = veg.split()[1]  # extract vegetable name\n        # check if it's not listed and not expired, and in the rack for a maximum of two hours\n        if (veg_name not in servings or servings[veg_name] == 0 or datetime.strptime(exp_dates[veg_name], \"%Y-%m-%d\") < current_time or time_in_rack[veg_name] > timedelta(hours=2)):\n            continue\n        else:\n            valid_veggies[veg_name] = servings[veg_name]\n            \n    return valid_veggies"
    ],
    "HumanEval/154": [
      "def cycpattern_check(a , b):\n    \"\"\"Example usage:    \n    cycpattern_check(\"AbcD\",\"aBd\") => False\n    cycpattern_check(\"Hello\",\"ELl\") => True\n    cycpattern_check(\"Whas$sup\",\"pSUs\") => False\n    cycpattern_check(\"aB!ab\",\"BAa\") => True\n    cycpattern_check(\"EfEF\",\"EeFf\") => False\n    cycpattern_check(\"Hi^mensS\",\"sImen\") => True\n    \"\"\"\n    # Clean the strings: convert to lower case and remove special characters\n    a_clean = re.sub(r'\\W+', '', a).lower()\n    b_clean = re.sub(r'\\W+', '', b).lower()\n    \n    # Create all cyclic permutations of the second string\n    cyclic_permutations = [b_clean[i:] + b_clean[:i] for i in range(len(b_clean))]\n    \n    # Check if any of the permutations is in the first string\n    return any(permutation in a_clean for permutation in cyclic_permutations)",
      "def cycpattern_check(a , b):\n    # Preprocessing of strings\n    a = \"\".join(re.findall(\"[a-zA-Z0-9]*\", a)).lower()\n    b = \"\".join(re.findall(\"[a-zA-Z0-9]*\", b)).lower()\n\n    # Function for getting all the cyclic permutations\n    cycle = lambda s: [s[i:] + s[:i] for i in range(len(s))]\n\n    # Check for presence of b or its cyclic permutations in a\n    return any(c in a for c in cycle(b))",
      "def cycpattern_check(a , b):\n    a, b = clean_string(a), clean_string(b)\n    return any(is_subsequence(a, perm) for perm in cyclic_permutations(b))",
      "def find_max(words, case_sensitive=False):\n    \"\"\"This function accepts a list of distinct strings as an input. \n    It returns the string with the greatest number of unique characters. \n    If there is a tie, it provides the first word in lexicographical order. \n    Character cases are considered separate only if the parameter case_sensitive is set to True.\n\n    >>> find_max([\"name\", \"of\", \"String\"], True)\n    \"String\"\n    >>> find_max([\"name\", \"enam\", \"Game\"])\n    \"enam\"\n    >>> find_max([\"aaaaaaa\", \"BB\" ,\"cc\"])\n    \"aaaaaaa\"\n    \"\"\"\n    # Error handling for bad input types\n    if not isinstance(words, list) or not all(isinstance(i, str) for i in words):\n        raise ValueError('Invalid input type. Please enter a list of strings')\n\n    # If case_sensitive is False, convert all words to lowercase. \n    words_lower  = [word.lower() for word in words] if not case_sensitive else words\n\n    # Loop through the words and find the word with the most unique characters.\n    # In case of tie, return the word that comes first lexicographically.\n    max_unique_chars = 0\n    max_word = ''\n    for word in words_lower:\n        num_unique_chars = len(set(word))\n        if num_unique_chars > max_unique_chars:\n            max_unique_chars = num_unique_chars\n            max_word = word\n        elif num_unique_chars == max_unique_chars:\n            max_word = min(word, max_word)\n    return max_word",
      "def find_max(words, case_sensitive=False):\n    \"\"\"\n    This function accepts a list of distinct strings as an input, \n    It returns the string with the greatest number of unique characters.\n    If there is a tie, it provides the first word in lexicographical order. \n    Character cases are considered separate only if the parameter case_sensitive is set to True.\n\n    >>> find_max([\"name\", \"of\", \"string\"], True)\n    'string'\n    >>> find_max([\"name\", \"enam\", \"game\"])\n    'enam'\n    >>> find_max([\"aaaaaaa\", \"b13\" ,\"cc\"])\n    'aaaaaaa'\n    \"\"\"\n    \n    # Error handling for bad input types\n    if not isinstance(words, list) or not all(isinstance(w, str) for w in words):\n        raise ValueError('Invalid input type. Please enter a list of strings')\n\n    # If case_sensitive is False, convert all words to lowercase. \n    words_lower  = [word.lower() for word in words] if not case_sensitive else words\n    \n    # Loop through the words and find the word with the most unique characters.\n    # In case of tie, return the word that comes first lexicographically.\n    max_unique_chars = 0\n    max_word = ''\n    for word in words_lower:\n        num_unique_chars = len(set(word))\n        if num_unique_chars > max_unique_chars:\n            max_unique_chars = num_unique_chars\n            max_word = word\n        elif num_unique_chars == max_unique_chars:\n            max_word = min(word, max_word)\n    return max_word"
    ],
    "HumanEval/155": [
      "def even_odd_count(num):\n    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):  # Converting the input to a positive string number\n        if int(digit) % 2 == 0:  # Checking if the digit is even\n            even_count += 1      # If even, increment the even_count\n        else:\n            odd_count += 1       # If odd, increment the odd_count\n    return (even_count, odd_count) # Return the counts as a tuple",
      "def numsManipulation(n):\n    \"\"\"Given a positive integer n, return the product of the cubes of odd digits and the sum of squares of the even digits.\n    If all digits are even, return the product of cubes of the first half of even digits.\n    If all digits are odd, return the sum of the squares of the first half of odd digits.\n    For example:\n    numsManipulation(1)   == 1\n    numsManipulation(4)   == 16\n    numsManipulation(235) == 31 (2^2 + 3^3*5^3)\n    \"\"\"\n\n    # List of odd and even digits\n    odd_digits = [int(digit) for digit in str(n) if int(digit) % 2 != 0]\n    even_digits = [int(digit) for digit in str(n) if int(digit) % 2 == 0]\n\n    # Determine the calculation based on the digits\n    if len(odd_digits) > 0 and len(even_digits) > 0:\n        # Both odd and even digits\n        return sum(d ** 2 for d in even_digits) + prod(d ** 3 for d in odd_digits)\n    elif len(odd_digits) > 0:\n        # Only odd digits\n        return sum(d ** 2 for d in odd_digits[:len(odd_digits)//2])\n    else:\n        # Only even digits\n        return prod(d ** 3 for d in even_digits[:len(even_digits)//2])",
      "def numsManipulation(n):\n    \"\"\"\n    Given a positive integer n, return the product of the cubes of odd digits and the sum of the squares of the even digits.\n    If all digits are even, return the product of cubes of the first half of even digits.\n    If all digits are odd, return the sum of the squares of the first half of odd digits.\n    For example:\n    numsManipulation(1) == 1\n    numsManipulation(4) == 16\n    numsManipulation(235) == 31 (2^2 + 3^3 + 5^3)\n    \"\"\"\n\n    # List of odd and even digits\n    odd_digits = [int(digit) for digit in str(n) if int(digit) % 2 != 0]\n    even_digits = [int(digit) for digit in str(n) if int(digit) % 2 == 0]\n\n    # Determine the calculation based on the digits\n    if len(odd_digits) > 0 and len(even_digits) > 0:\n        # Both odd and even digits\n        return sum(d ** 2 for d in even_digits) + prod(d ** 3 for d in odd_digits)\n    elif len(odd_digits) > 0:\n        # Only odd digits\n        return sum(d ** 2 for d in odd_digits[:len(odd_digits)//2])\n    else:\n        # Only even digits\n        return prod(d ** 3 for d in even_digits[:len(even_digits)//2])",
      "def split_odd_totals(y):\n    \"\"\"In this function, given an array y of positive integers, generate two sorted arrays. One includes \n    _singular_ elements whose sum of their digits is odd and ends with an odd number, and other with \n    elements whose sum of their digits is odd and ends with an even number, both in ascending sequence.\n\n    >>> split_odd_totals([15, 33, 1422, 1, 15])\n    ([1, 15, 33], [1422])\n    >>> split_odd_totals([152, 323, 1422, 10])\n    ([323], [152, 1422])\n    \"\"\"\n\n    odd_ending = []\n    even_ending = []\n\n    for num in y:\n        digit_sum = sum(int(digit) for digit in str(num))\n        \n        if digit_sum % 2 != 0: # sum of digits is odd\n            if num % 2 != 0: # number ends with odd digit\n                odd_ending.append(num)\n            else: # number ends with even digit\n                even_ending.append(num)\n                \n    return sorted(odd_ending), sorted(even_ending)",
      "def check_integer(number):\n    if number % 2 == 0:\n        if number % 3 == 0:\n            print(\"The given integer is even and a multiple of 3.\")\n        else:\n            print(\"The given integer is even and not a multiple of 3.\")\n    else:\n        if number % 3 == 0:\n            print(\"The given integer is odd and a multiple of 3.\")\n        else:\n            print(\"The given integer is odd and not a multiple of 3.\")"
    ],
    "HumanEval/156": [
      "def convert_number(number, conversion_type):\n    \"\"\"\n    Converts a positive integer or roman numeral to each other.\n    Conversion types: 'int_to_roman' or 'roman_to_int'.\n    Limitations: 1 <= num <= 1000 for integers and valid roman numerals\n\n    Examples:\n    >>> convert_number(19, 'int_to_roman') == 'xix'\n    >>> convert_number(152, 'int_to_roman') == 'clii'\n    >>> convert_number('cdxxvi', 'roman_to_int') == 426\n    \"\"\"\n    # Define all unique symbols and corresponding values for roman numerals\n    VALUES = {\n    'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,\n    'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000\n    }\n    # A reversed map of above, for int to roman conversion\n    ROMANS = {v: k for k, v in reversed(sorted(VALUES.items()))}\n\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            raise ValueError(\"Input integer must be between 1 and 1000.\")\n        \n        result = ''\n        for value, numeral in ROMANS.items():\n            count = number // value\n            result += numeral * count\n            number -= value * count\n        return result\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str) or any(i not in VALUES for i in number):\n            raise ValueError(\"Invalid Roman Numeral.\")\n        \n        result = 0\n        i = 0\n        while i < len(number):\n            # If this is a subtractive combination, process both elements\n            if i + 1 < len(number) and number[i:i+2] in VALUES:\n                result += VALUES[number[i:i+2]]\n                i += 2\n            else:\n                # Else, process one element\n                result += VALUES[number[i]]\n                i += 1\n\n        if result < 1 or result > 1000:\n            raise ValueError(\"Result is out of range!\")\n        return result\n    else:\n        raise ValueError(\"Invalid conversion type!\")",
      "def convert_number(number, conversion_type):\n    \"\"\"\n    Converts a positive integer or roman numeral to each other.\n    Conversion types: 'int_to_roman' or 'roman_to_int'\n    Limitations: 1 <= num <= 1000 for integers and valid roman numerals\n\n    Examples:\n    >>> convert_number(19, 'int_to_roman') == 'xix'\n    >>> convert_number(152, 'int_to_roman') == 'clii'\n    >>> convert_number('cdxxvi', 'roman_to_int') == 426\n    \"\"\"\n    # Define all unique symbols and corresponding values for roman numerals\n    VALUES = {\n      'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,\n      'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000\n    }\n    # A reversed map of above, for int to roman conversion\n    ROMANS = {v: k for k, v in reversed(sorted(VALUES.items()))}\n\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            raise ValueError(\"Input integer must be between 1 and 1000!\")\n        result = ''\n        for value, numeral in ROMANS.items():\n            count = number // value\n            result += numeral * count\n            number -= value * count\n        return result\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str) or any(i not in VALUES for i in number):\n            raise ValueError(\"Invalid Roman Numeral!\")\n        result = 0\n        i = 0\n        while i < len(number):\n            # If this is a subtractive combination, process both elements\n            if i + 1 < len(number) and number[i:i+2] in VALUES:\n                result += VALUES[number[i:i+2]]\n                i += 2\n            else:\n                # Else, process one element\n                result += VALUES[number[i]]\n                i += 1\n        if result < 1 or result > 1000:\n            raise ValueError(\"Result is out of range!\")\n        return result\n    else:\n        raise ValueError(\"Invalid conversion type!\")",
      "def convert_number(number, conversion_type):\n    \"\"\"\n    Converts a positive integer or Roman numeral to each other.\n    Conversion types: 'int_to_roman' or 'roman_to_int'\n    Limitations: 1 <= num <= 1000 for integers and valid Roman numerals\n\n    Examples:\n    >>> convert_number(19, 'int_to_roman') == 'xix'\n    >>> convert_number(152, 'int_to_roman') == 'clii'\n    >>> convert_number('cdxxvi', 'roman_to_int') == 426\n    \"\"\"\n    # Define all unique symbols and corresponding values for Roman numerals\n    VALUES = {\n      'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,\n      'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000\n    }\n    # A reversed map of above, for int to Roman conversion\n    ROMANS = {v: k for k, v in reversed(sorted(VALUES.items()))}\n\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            raise ValueError(\"Input integer must be between 1 and 1000!\")\n        result = ''\n        for value, numeral in ROMANS.items():\n            count = number // value\n            result += numeral * count\n            number -= value * count\n        return result\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str) or any(i not in VALUES for i in number):\n            raise ValueError(\"Invalid Roman Numeral!\")\n        result = 0\n        i = 0\n        while i < len(number):\n            # If this is a subtractive combination, process both elements\n            if i + 1 < len(number) and number[i:i+2] in VALUES:\n                result += VALUES[number[i:i+2]]\n                i += 2\n            else:\n                # Else, process one element\n                result += VALUES[number[i]]\n                i += 1\n        if result < 1 or result > 1000:\n            raise ValueError(\"Result is out of range!\")\n        return result\n    else:\n        raise ValueError(\"Invalid conversion type!\")",
      "def int_to_mini_roman(number):\n    # Map of integers to their corresponding roman numerals\n    int_to_roman_map = [(1000, 'm'), (900, 'cm'), (500, 'd'), (400, 'cd'),\n                        (100, 'c'), (90, 'xc'), (50, 'l'), (40, 'xl'),\n                        (10, 'x'), (9, 'ix'), (5, 'v'), (4, 'iv'), (1, 'i')]\n\n    roman_numeral = ''\n    for i, numeral in int_to_roman_map:\n        while number >= i:\n            roman_numeral += numeral\n            number -= i\n    return roman_numeral",
      "def int_to_mini_roman(number):\n    mapping = [(1000, \"m\"), (900, \"cm\"), (500, \"d\"), (400, \"cd\"),\n               (100, \"c\"), (90, \"xc\"), (50, \"l\"), (40, \"xl\"),\n               (10, \"x\"), (9, \"ix\"), (5, \"v\"), (4, \"iv\"), (1, \"i\")]\n    result = \"\"\n    for arabic, roman in mapping:\n        while number >= arabic:\n            result += roman\n            number -= arabic\n    return result"
    ],
    "HumanEval/157": [
      "def pythagorean_check_and_area(a, b, c):\n    # Sort the sides to make sure c is the longest side (hypotenuse)\n    sides = sorted([a, b, c])\n    \n    # Check right angled triangle condition\n    if sides[0]**2 + sides[1]**2 == sides[2]**2:\n        print(\"It's a right-angled triangle.\")\n        \n        # Area calculation for right angled triangle: 1/2 * base * height\n        area = 0.5 * sides[0] * sides[1]\n        print(\"Area of the triangle is\", area, \"square units.\")\n        \n    else:\n        print(\"It's not a right-angled triangle.\")",
      "def triangleType(a, b, c):\n  # First, let's check if the sides form a valid triangle\n  if (a + b <= c) or (a + c <= b) or (b + c <= a):\n    return \"Not a valid triangle\"\n\n  # Next, we'll check if all sides are equal, indicating an equilateral triangle\n  if a == b and b == c:\n    return \"Equilateral triangle\"\n\n  # If all sides are different lengths, it's a scalene triangle\n  if (a != b) and (b != c) and (a != c):\n    return \"Scalene triangle\"\n\n  # If it's not equilateral or scalene, it must be an isosceles triangle\n  return \"Isosceles triangle\"",
      "def compute_triangle_area(a, b, c):\n    # Check if sides are integers\n    if not isinstance(a, int) or not isinstance(b, int) or not isinstance(c, int):\n        raise InvalidTriangleError(\"Invalid triangle: the given sides are not integers.\")\n    \n    # Check if the given sides can form a triangle\n    if a + b <= c or b + c <= a or a + c <= b:\n        raise InvalidTriangleError(\"Invalid triangle: the given sides cannot form a triangle.\")\n    \n    # Compute the area using Heron's formula\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return area",
      "def triangle_properties(a, b, c):\n    # check if the sides can form a triangle\n    assert a + b > c and a + c > b and b + c > a, \"These sides do not form a triangle\"\n\n    # calculate the perimeter\n    perimeter = a + b + c \n\n    # calculate the semi-perimeter\n    s = perimeter / 2 \n\n    # calculate the area using Heron's formula\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c)) \n\n    # classifying the triangle based on its side lengths\n    if a == b == c:\n        shape = 'equilateral'\n    elif a == b or a == c or b == c:\n        shape = 'isosceles'\n    else:\n        shape = 'scalene'\n\n    # classifying the triangle based on its angles\n    sides = sorted([a, b, c]) \n    if sides[2]**2 > sides[0]**2 + sides[1]**2:\n        angle = 'obtuse-angled'\n    elif sides[2]**2 == sides[0]**2 + sides[1]**2:\n        angle = 'right-angled'\n    else:\n        angle = 'acute-angled'\n\n    return (perimeter, area, f'{shape}, {angle}')",
      "def triangle_area(side1, side2=None, side3=None):\n    \"\"\"\n    Given the sides of the triangle, compute the triangle's area.\n    For triangle_area(a) => a is the side of an equilateral triangle\n    For triangle_area(a, h) => a is the base and h is the height of isosceles triangle\n    For triangle_area(a, b, c) => a, b, c are the sides of the scalene triangle\n    \"\"\"\n    if side2 == None and side3 == None:\n        # equilateral triangle\n        # area = (sqrt(3)/4) * a^2\n        area = (math.sqrt(3) / 4) * pow(side1, 2)\n    elif side3 == None:\n        # isosceles triangle\n        # area = 1/2 * base * height\n        area = 0.5 * side1 * side2\n    else:\n        # scalene triangle\n        # from the sides, get the semi-perimeter (s = (a+b+c)/2)\n        # then plug it in Heron's formula: area = sqrt(s*(s-a)*(s-b)*(s-c))\n        # which gives the formula for the area of a triangle from its sides\n        semi_perimeter = (side1 + side2 + side3) / 2\n        area = math.sqrt(semi_perimeter * (semi_perimeter-side1) * (semi_perimeter-side2) * (semi_perimeter-side3))\n    \n    return area"
    ],
    "HumanEval/158": [
      "def find_max(words, case_sensitive=False):\n    \"\"\"\n    This function accepts a list of distinct strings as input.\n    It outputs the word that contains the greatest number of unique characters.\n    In the event of a tie, the function will return the word that comes first lexicographically.\n    If case_sensitive is set to True, the function will treat different character cases as unique.\n    If the words list is empty, it raises a ValueError.\n\n    >>> find_max([\"name\", \"of\", \"String\"], True)\n    \"String\"\n    >>> find_max([\"name\", \"enam\", \"Game\"])\n    \"enam\"\n    >>> find_max([\"aaaaaaa\", \"BB\" ,\"cc\"])\n    \"aaaaaaa\"\n    >>> find_max([])\n    ValueError: 'words' list can't be empty\n    \"\"\"\n    if not words:\n        raise ValueError(\"'words' list can't be empty\")\n    max_count, max_word = 0, \"\"\n    for word in words:\n        unique_chars = set(word.lower()) if not case_sensitive else set(word)\n        if len(unique_chars) > max_count or (len(unique_chars) == max_count and word < max_word):\n            max_count = len(unique_chars)\n            max_word = word\n    return max_word",
      "def find_max(words, case_sensitive=False):\n    \"\"\"This function accepts a list of distinct strings as an input. \n    It returns the string with the greatest number of unique characters. \n    If there is a tie, it provides the first word in lexicographical order. \n    Character cases are considered separate only if the parameter case_sensitive is set to True.\n\n    >>> find_max([\"name\", \"of\", \"String\"], True)\n    \"String\"\n    >>> find_max([\"name\", \"enam\", \"Game\"])\n    \"enam\"\n    >>> find_max([\"aaaaaaa\", \"BB\" ,\"cc\"])\n    \"aaaaaaa\"\n    \"\"\"\n    # Error handling for bad input types\n    if not isinstance(words, list) or not all(isinstance(i, str) for i in words):\n        raise ValueError('Invalid input type. Please enter a list of strings')\n\n    # If case_sensitive is False, convert all words to lowercase. \n    words_lower  = [word.lower() for word in words] if not case_sensitive else words\n\n    # Loop through the words and find the word with the most unique characters.\n    # In case of tie, return the word that comes first lexicographically.\n    max_unique_chars = 0\n    max_word = ''\n    for word in words_lower:\n        num_unique_chars = len(set(word))\n        if num_unique_chars > max_unique_chars:\n            max_unique_chars = num_unique_chars\n            max_word = word\n        elif num_unique_chars == max_unique_chars:\n            max_word = min(word, max_word)\n    return max_word",
      "def find_max(words, case_sensitive=False):\n    \"\"\"\n    This function accepts a list of distinct strings as an input, \n    It returns the string with the greatest number of unique characters.\n    If there is a tie, it provides the first word in lexicographical order. \n    Character cases are considered separate only if the parameter case_sensitive is set to True.\n\n    >>> find_max([\"name\", \"of\", \"string\"], True)\n    'string'\n    >>> find_max([\"name\", \"enam\", \"game\"])\n    'enam'\n    >>> find_max([\"aaaaaaa\", \"b13\" ,\"cc\"])\n    'aaaaaaa'\n    \"\"\"\n    \n    # Error handling for bad input types\n    if not isinstance(words, list) or not all(isinstance(w, str) for w in words):\n        raise ValueError('Invalid input type. Please enter a list of strings')\n\n    # If case_sensitive is False, convert all words to lowercase. \n    words_lower  = [word.lower() for word in words] if not case_sensitive else words\n    \n    # Loop through the words and find the word with the most unique characters.\n    # In case of tie, return the word that comes first lexicographically.\n    max_unique_chars = 0\n    max_word = ''\n    for word in words_lower:\n        num_unique_chars = len(set(word))\n        if num_unique_chars > max_unique_chars:\n            max_unique_chars = num_unique_chars\n            max_word = word\n        elif num_unique_chars == max_unique_chars:\n            max_word = min(word, max_word)\n    return max_word",
      "def find_max(words, case_sensitive=False):\n    \"\"\"This function accepts a list of unique strings as its primary input.\n    Its output is the word with the greatest count of distinguished characters.\n    In the event of a tie, yield the word that appears first lexicographically.\n    If case_sensitive is specified as True, cases of characters are deemed distinct.\n    \"\"\"\n    if not case_sensitive:\n        # convert all words to lower case\n        words = [word.lower() for word in words]\n    \n    # create a list of tuples, with each tuple containing a word and its corresponding\n    # count of unique characters\n    words_and_counts = [(word, len(set(word))) for word in words]\n    \n    # sort the list of tuples lexicographically and by descending order of counts\n    words_and_counts.sort(key = lambda x: (-x[1], x[0]))\n    \n    # return the word with the maximum count of unique characters, or the\n    # lexicographically first word in case of a tie\n    return words_and_counts[0][0]",
      "def find_max(words):\n    \"\"\" Finds the word from a list with the maximum number of unique letters\n    \n    Args:\n        words (List[str]): list of words\n\n    Returns:\n        str : the word with maximum unique letters. \n        If there are multiple such words, the one appearing first alphabetically\n\n    \"\"\"\n\n    max_word = ''\n    max_unique_chars = 0\n    \n    for word in words:\n        unique_chars = set(word.lower())\n        num_unique_chars = len(unique_chars)\n\n        if num_unique_chars == max_unique_chars:\n            if word.lower() < max_word.lower():\n                max_word = word\n        elif num_unique_chars > max_unique_chars:\n            max_word = word\n            max_unique_chars = num_unique_chars\n\n    return max_word"
    ],
    "HumanEval/159": [
      "def validateID(number):\n  \n  if (len(number) != 10):\n    return False\n    \n  weights = [2, 4, 8, 5, 10, 9, 7, 3, 6]\n  total = 0\n\n  for i in range(len(number) - 1):\n    total += weights[i] * int(number[i])\n    \n  return True if (total % 11 == int(number[9])) else False",
      "def calculate_coins(amount):\n    \"\"\"\n    This function takes an amount and returns the minimum number of coins \n    required to make the amount using coins of value 1, 5, 10, and 25.\n    \"\"\"\n    coins = [25, 10, 5, 1]\n \n    result = []\n    remaining = amount\n \n    for coin in coins:\n        if remaining >= coin:\n            number_of_coins = int(remaining / coin)\n            for i in range(number_of_coins):\n                result.append(coin)\n            remaining = remaining % coin\n \n    return result",
      "def convert_number(number, conversion_type):\n    \n    roman_to_int_mapping = {'i': 1, \n                            'v': 5, \n                            'x': 10, \n                            'l': 50, \n                            'c': 100, \n                            'd': 500, \n                            'm': 1000}\n    \n    int_to_roman_mapping = {1: 'i', \n                            4: 'iv', \n                            5: 'v', \n                            9: 'ix', \n                            10: 'x', \n                            40: 'xl', \n                            50: 'l', \n                            90: 'xc', \n                            100: 'c', \n                            400: 'cd', \n                            500: 'd', \n                            900: 'cm', \n                            1000: 'm'}\n    \n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            raise ValueError('Invalid value. Should be an integer between 1 and 1000.')\n        num = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        res = ''\n        for i in num:\n            while number >= i:\n                res += int_to_roman_mapping[i]\n                number -= i\n        return res \n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            raise ValueError('Invalid value. Should be a valid Roman numeral.')\n        number = number.lower()    \n        res, i = 0, 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i+2] in int_to_roman_mapping.values():\n                res += roman_to_int_mapping[number[i+1]] - roman_to_int_mapping[number[i]]\n                i += 2\n            else:\n                res += roman_to_int_mapping.get(number[i], 0)\n                i += 1\n        return res\n    else:\n       raise ValueError('Invalid conversion type. Should be \"int_to_roman\" or \"roman_to_int\".')",
      "def convert_number(number, conversion_type):\n\n    roman_to_int_mapping = {'i': 1,  \n                            'v': 5,  \n                            'x': 10, \n                            'l': 50,  \n                            'c': 100, \n                            'd': 500, \n                            'm': 1000}\n\n    int_to_roman_mapping = {1: 'i',  \n                            4: 'iv',\n                            5: 'v', \n                            9: 'ix', \n                            10: 'x', \n                            40: 'xl', \n                            50: 'l', \n                            90: 'xc',\n                            100: 'c',  \n                            400: 'cd', \n                            500: 'd', \n                            900: 'cm', \n                            1000: 'm'}\n\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            raise ValueError('Invalid value, should be an integer between 1 and 1000.')\n        num = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        res = ''\n        for i in num:\n            while number >= i:\n                res += int_to_roman_mapping[i]\n                number -= i\n        return res \n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            raise ValueError('Invalid value. Should be a valid Roman numeral.')\n        number = number.lower()\n        res, i = 0, 0\n        while i < len(number):\n            if i+1 < len(number) and number[i:i+2] in int_to_roman_mapping.values():\n                res += roman_to_int_mapping[number[i+1]] - roman_to_int_mapping[number[i]]\n                i += 2\n            else:\n                res += roman_to_int_mapping.get(number[i], 0)\n                i += 1\n        return res\n    else:\n        raise ValueError('Invalid conversion type, Should be \"int_to_roman\" or \"roman_to_int\".')",
      "def convert_all_sums(n, m, start, base):\n    \"\"\"\n    You are provided two positive integers n and m (n <= m), and an additional starting number (start),\n    your task is to determine the sum of all the numbers from n through m (inclusive), starting from the 'start' number.\n    Then convert the sum into a custom base system. The custom base system will be another integer (base)\n    ranging from [2, 10] (inclusive). If n is greater than m, the start number is less than zero,\n    or the base is out of the given range, return -1. \n    \n    Example:\n    convert_all_sums(1, 5, 0, 2) => \"0b110\"\n    convert_all_sums(7, 5, 2, 2) => -1\n    convert_all_sums(10, 2, 10, 2) => \"0b10110\"\n    convert_all_sums(20, 33, 0, 2) => \"0b110101\"\n    convert_all_sums(15, 20, 10, 8) => \"0o25\"\n    \"\"\"\n    # Check for valid input\n    if n > m or start < 0 or not(2 <= base <= 10):\n        return -1\n    # Calculates the sum of the series\n    total = sum(range(n, m+1)) + start\n    # Converts the sum to the appropriate base\n    if base == 2:\n        return bin(total)\n    elif base == 8:\n        return oct(total)\n    elif base == 10:\n        return str(total)\n    else:\n        return \"Base not supported\""
    ],
    "HumanEval/160": [
      "def do_algebra(operator, operand, round_off):\n    # mapping the arithmetic operators to their respective functions\n    operators = {'+': op.add, '-': op.sub, '*': op.mul, '//': op.floordiv, '**': op.pow}\n\n    # error handling\n    if len(operand)-len(operator)!=1:\n        raise ValueError('The number of operators must be exactly one less than the number of operands.')\n\n    # initializing the result to the first operand\n    result = operand[0]\n\n    # going through each operator\n    for idx in range(len(operator)):\n         # updating the result based on the current operator and the next operand\n        result = operators[operator[idx]](result, operand[idx+1])\n    \n    # rounding off the result if needed\n    if round_off:\n        result = round(result)\n        \n    return result",
      "def evaluate_expression(expression: str) -> int:\n    tokens = expression.split()  # Split the expression into tokens\n    result = int(tokens[0])  # Initialize the result with the first operand\n\n    # Iterate through the tokens in pairs (operator, operand)\n    for i in range(1, len(tokens), 2):\n        operator = tokens[i]  # Get the operator\n        operand = int(tokens[i + 1])  # Get the operand\n\n        if operator == '+':\n            result += operand  # Perform addition\n        elif operator == '-':\n            result -= operand  # Perform subtraction\n\n    return result  # Return the final result",
      "def calculate_expression(operations, numbers):\n    # Dictionary that maps arithmetic operations to their equivalent python operator.\n    operators_map = {'+': operator.add, \n                     '-': operator.sub, \n                     '*': operator.mul, \n                     '/': operator.truediv, \n                     '%': operator.mod }\n\n    # First operand\n    result = numbers[0]\n\n    # Loop through the list of operations\n    for i in range(1, len(numbers)):\n        if operations[i-1] in operators_map: # Check if the operation is valid.\n            op = operators_map[operations[i-1]] # Get the python operator function.\n            result = op(result, numbers[i]) # Apply the operation.\n        else:\n            raise ValueError(f\"Invalid operation '{operations[i-1]}'\") \n\n    # The function should return the final result.\n    return result",
      "def needs_brackets(operand, order, explicit):\n    # Define the precedence of operators based on the given order\n    precedence = {'B': 0, 'O': 1, 'D': 2, 'M': 3, 'A': 4, 'S': 5}\n\n    # Check if the operand is a single variable or a complex expression\n    if len(operand) == 1:\n        return False  # Single variable does not need brackets\n\n    # If the operand is a complex expression, determine if brackets are needed\n    stack = []\n    for token in operand:\n        if token.isalnum():  # Operand is a variable\n            stack.append(token)\n        else:  # Operand is an operator\n            while stack and precedence[stack[-1]] <= precedence[token]:\n                stack.pop()\n            stack.append(token)\n\n    # Check if brackets are needed for explicit multiplication\n    if explicit and '*' in operand:\n        return True\n\n    # If the stack is not empty, brackets are needed\n    return len(stack) > 0",
      "def do_calculations(operator, operand):\n    result = operand[0]\n\n    for i in range(len(operator)):\n        if operator[i] == '+':\n            result += operand[i + 1]\n        elif operator[i] == '-':\n            result -= operand[i + 1]\n        elif operator[i] == '*':\n            result *= operand[i + 1]\n        elif operator[i] == '//':\n            result //= operand[i + 1]\n        elif operator[i] == '**':\n            result **= operand[i + 1]\n        elif operator[i] == 'sin':\n            result -= math.sin(math.radians(operand[i + 1]))\n        elif operator[i] == 'cos':\n            result -= math.cos(math.radians(operand[i + 1]))\n        elif operator[i] == 'tan':\n            result -= math.tan(math.radians(operand[i + 1]))\n            \n    return result"
    ],
    "HumanEval/161": [
      "def is_palindrome(s):\n    \"\"\"\n    Checks if the given string is a palindrome\n\n    :param s: the string to be checked\n    :returns: True if the string is a palindrome, False otherwise\n    \"\"\"\n    # remove all non-alphanumeric characters\n    s = ''.join([c for c in s if c.isalnum()])\n    # convert to lower case\n    s = s.lower()\n    # compare reversed string to the original\n    return s == s[::-1]",
      "def complex_sorted_list(lst, reverse=False, min_sum=0, max_sum=None, sort_function=None, secondary_sort_function=None):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter and performs the following:\n    - Delete strings with odd lengths or containing numerals.\n    - Sort the list based on the sum of the ASCII values of the characters in each string.\n    - The list may contain duplicates, ignore case, and special characters.\n    - Toggle sorting between ascending and descending order using an optional boolean `reverse` (default is False).\n    - Implement an optional minimum sum `min_sum` (default is 0) to return only strings with a sum greater or equal.\n    - Implement an optional maximum sum `max_sum` to return only strings with a sum less than or equal.\n    - Implement an optional custom sorting method `sort_function` to sort strings using a custom function.\n    - Implement an optional secondary custom sorting method `secondary_sort_function` to sort strings using a secondary function.\n    \n    E.g.:\n    assert complex_sorted_list([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert complex_sorted_list([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    assert complex_sorted_list([\"ab\", \"a\", \"aaa\", \"cd\"], True) => [\"cd\", \"ab\"]\n    assert complex_sorted_list([\"ab\", \"a\", \"aaa\", \"cd\"], min_sum=200) => [\"cd\"]\n    \"\"\"\n    \n    # Remove strings with odd lengths and strings containing numerals\n    clean_lst = [s for s in lst if len(s) % 2 == 0 and not any(c.isdigit() for c in s)]\n    \n    if not sort_function:\n        sort_function = lambda s: sum(ord(c) for c in s)\n    \n    if secondary_sort_function:\n        clean_lst.sort(key=secondary_sort_function)\n    \n    # Sort strings based on the sort_function\n    clean_lst.sort(key=sort_function, reverse=reverse)\n    \n    # Filter strings based on min_sum and max_sum\n    filtered_lst = [s for s in clean_lst if min_sum <= sort_function(s) <= (max_sum if max_sum else float(\"inf\"))]\n    \n    return filtered_lst",
      "def classify_string(s):\n    # Remove spaces and punctuation marks from the string\n    modified_string = ''.join(c for c in s if c not in string.punctuation and c != ' ')\n\n    # Check if the modified string is a palindrome\n    if modified_string.lower() == modified_string.lower()[::-1]:\n        return \"Palindrome\"\n    \n    # Check if the modified string contains only alphabets\n    if modified_string.isalpha():\n        return \"Word\"\n    \n    # Otherwise, classify it as a phrase\n    return \"Phrase\"",
      "def format_sentence(s):\n    # Base case: if the string is empty, return an empty string\n    if not s:\n        return \"\"\n\n    # Recursive case: process the string\n    first_char = s[0]\n\n    # If the first character is a period, replace it with an exclamation point\n    if first_char == \".\":\n        first_char = \"!\"\n\n    # If the first character is an exclamation point, replace it with a question mark\n    elif first_char == \"!\":\n        first_char = \"?\"\n\n    # If the first character is a question mark, replace it with a period\n    elif first_char == \"?\":\n        first_char = \".\"\n\n    # If the first character is a letter and the previous character is a punctuation mark,\n    # capitalize the letter\n    elif first_char.isalpha() and (not s[1:] or s[1].isspace()):\n        first_char = first_char.upper()\n\n    # Recursively process the remaining string\n    return first_char + format_sentence(s[1:])",
      "def subset_sum(s, C):\n    \"\"\"\n    Design a program using a greedy algorithm to solve the subset sum problem.\n    \n    Parameters:\n    s (list): set of integers\n    C (int): target sum\n\n    Returns:\n    boolean: True if the sum is equal to C, False otherwise\n    \"\"\"\n    s.sort(reverse=True)\n    current_sum = 0\n\n    for i in range(len(s)):\n        if s[i] + current_sum <= C:\n            current_sum += s[i]\n\n    if current_sum == C:\n        return True\n    else:\n        return False"
    ],
    "HumanEval/162": [
      "def string_to_md5(text):\n    # If 'text' is an empty string, return None\n    if text == '':\n        return None\n\n    # Create an md5 hash object\n    hash_object = hashlib.md5()\n\n    # Update the hash object with 'text', encoded into utf-8 bytes\n    hash_object.update(text.encode('utf-8'))\n\n    # Return the hexadecimal representation of the md5 hash\n    return hash_object.hexdigest()",
      "def hello(name=''):\n    try:\n        # Check if the variable 'name' is of type string\n        if type(name) is not str:\n            return 'The variable `name` should be a string.'\n\n        # Check if 'name' is an empty string\n        elif name.strip() == '':\n            return 'Hello!'\n\n        # If 'name' is not an empty string\n        else:\n            return 'Hello, ' + name.strip() + '!'\n    except Exception as e:\n        return str(e)",
      "def hello(name=''):\n    try:\n        # Check if the variable 'name' is of type string\n        if type(name) is not str:\n            return 'The variable `name` should be a string.'\n\n        # Check if 'name' is an empty string\n        elif name.strip() == '':\n            return 'Hello!'\n\n        # If 'name' is not an empty string\n        else:\n            return 'Hello, ' + name.strip() + '!'\n    except Exception as e:\n        return str(e)",
      "def extract_text_value(json_obj: dict) -> Union[str, None]:\n    if 'text' in json_obj and isinstance(json_obj['text'], dict):\n        return extract_text_value(json_obj['text'])\n    elif 'text' in json_obj and isinstance(json_obj['text'], str):\n        return json_obj['text']\n    else:\n        for key, value in json_obj.items():\n            if isinstance(value, dict):\n                result = extract_text_value(value)\n                if result is not None:\n                    return result\n    return None",
      "def longest(strings: List[str]) -> Optional[str]:\n    \"\"\" In a given list of strings, identify and return the string having the longest length. If there are several strings with the same lengths, return the one that appeared first. If the list has no elements, return None.\n\n    >>> longest([])\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n\n    if not strings: # check if the list is empty\n        return None\n\n    longest_string = strings[0]\n    for string in strings:\n        if len(string) > len(longest_string):\n            longest_string = string\n\n    return longest_string"
    ],
    "HumanEval/163": [
      "def sum_of_even_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers: A list of integers.\n\n    Returns:\n    The sum of all even numbers in the list.\n    \n    Examples:\n    >>> sum_of_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    30\n    >>> sum_of_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_of_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)",
      "def main():\n    # Example array of 10 positive integers sorted in ascending order\n    my_array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    # Call the new function and print the result\n    even_sum = sum_even_numbers(my_array)\n    print(\"Sum of even numbers in array:\", even_sum)",
      "def sum_even_numbers(numbers):\n    \"\"\"\n    Calculate the sum of all even numbers in the given list.\n\n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The sum of all even numbers in the list.\n\n    Examples:\n    >>> sum_even_numbers([1, 2, 3, 4, 5, 6])\n    12\n    >>> sum_even_numbers([10, 11, 12, 13, 14, 15])\n    36\n    >>> sum_even_numbers([2, 4, 6, 8, 10])\n    30\n    >>> sum_even_numbers([1, 3, 5, 7, 9])\n    0\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)",
      "def sort_and_transform_even_indices(l: list) -> list:\n    \"\"\"\n    This function accepts a list l and generates a new list l'. This new list preserves the odd indices from l. At the even indices,\n    it creates a list from the corresponding positions in l, sorts it in ascending order, and transforms the sorted data using the square function before placing \n    them in the new list.\n\n    >>> sort_and_transform_even_indices([1, 2, 3])\n    [1, 2, 9]\n    >>> sort_and_transform_even_indices([5, 6, 3, 4, 8, 9, 2])\n    [4, 6, 9, 4, 25, 9, 64]\n    >>> sort_and_transform_even_indices([8, 7, 4, 1, 3, 6, 5])\n    [1, 7, 9, 1, 16, 6, 64]\n    \"\"\"\n\n    even_indices_list = sorted([l[i] for i in range(0, len(l), 2)])\n    return [square(even_indices_list.pop(0)) if i % 2 == 0 else l[i] for i in range(len(l))]",
      "def sort_and_transform_even_indices(l: list) -> list:\n    \"\"\"\n    This function accepts a list l and generates a new list l'. This new list preserves the odd indices from l. At the even indices,\n    it creates a list from the corresponding positions in l, sorts it in ascending order, and transforms the sorted data using the square function before placing \n    them in the new list.\n\n    >>> sort_and_transform_even_indices([1, 2, 3])\n    [1, 2, 9]\n    >>> sort_and_transform_even_indices([5, 6, 3, 4, 8, 9, 2])\n    [4, 6, 9, 4, 25, 9, 64]\n    >>> sort_and_transform_even_indices([8, 7, 4, 1, 3, 6, 5])\n    [1, 7, 9, 1, 16, 6, 64]\n    \"\"\"\n\n    even_indices_list = sorted([l[i] for i in range(0, len(l), 2)])\n    return [square(even_indices_list.pop(0)) if i % 2 == 0 else l[i] for i in range(len(l))]"
    ],
    "MBPP/0": [],
    "MBPP/1": [],
    "MBPP/2": [],
    "MBPP/3": [],
    "MBPP/4": [],
    "MBPP/5": [],
    "MBPP/6": [],
    "MBPP/7": [],
    "MBPP/8": [],
    "MBPP/9": [],
    "MBPP/10": [],
    "MBPP/11": [],
    "MBPP/12": [],
    "MBPP/13": [],
    "MBPP/14": [],
    "MBPP/15": [],
    "MBPP/16": [],
    "MBPP/17": [],
    "MBPP/18": [],
    "MBPP/19": [],
    "MBPP/20": [],
    "MBPP/21": [],
    "MBPP/22": [],
    "MBPP/23": [],
    "MBPP/24": [],
    "MBPP/25": [],
    "MBPP/26": [],
    "MBPP/27": [],
    "MBPP/28": [],
    "MBPP/29": [],
    "MBPP/30": [],
    "MBPP/31": [],
    "MBPP/32": [],
    "MBPP/33": [],
    "MBPP/34": [],
    "MBPP/35": [],
    "MBPP/36": [],
    "MBPP/37": [],
    "MBPP/38": [],
    "MBPP/39": [],
    "MBPP/40": [],
    "MBPP/41": [],
    "MBPP/42": [],
    "MBPP/43": [],
    "MBPP/44": [],
    "MBPP/45": [],
    "MBPP/46": [],
    "MBPP/47": [],
    "MBPP/48": [],
    "MBPP/49": [],
    "MBPP/50": [],
    "MBPP/51": [],
    "MBPP/52": [],
    "MBPP/53": [],
    "MBPP/54": [],
    "MBPP/55": [],
    "MBPP/56": [],
    "MBPP/57": [],
    "MBPP/58": [],
    "MBPP/59": [],
    "MBPP/60": [],
    "MBPP/61": [],
    "MBPP/62": [],
    "MBPP/63": [],
    "MBPP/64": [],
    "MBPP/65": [],
    "MBPP/66": [],
    "MBPP/67": [],
    "MBPP/68": [],
    "MBPP/69": [],
    "MBPP/70": [],
    "MBPP/71": [],
    "MBPP/72": [],
    "MBPP/73": [],
    "MBPP/74": [],
    "MBPP/75": [],
    "MBPP/76": [],
    "MBPP/77": [],
    "MBPP/78": [],
    "MBPP/79": [],
    "MBPP/80": [],
    "MBPP/81": [],
    "MBPP/82": [],
    "MBPP/83": [],
    "MBPP/84": [],
    "MBPP/85": [],
    "MBPP/86": [],
    "MBPP/87": [],
    "MBPP/88": [],
    "MBPP/89": [],
    "MBPP/90": [],
    "MBPP/91": [],
    "MBPP/92": [],
    "MBPP/93": [],
    "MBPP/94": [],
    "MBPP/95": [],
    "MBPP/96": [],
    "MBPP/97": [],
    "MBPP/98": [],
    "MBPP/99": [],
    "MBPP/100": [],
    "MBPP/101": [],
    "MBPP/102": [],
    "MBPP/103": [],
    "MBPP/104": [],
    "MBPP/105": [],
    "MBPP/106": [],
    "MBPP/107": [],
    "MBPP/108": [],
    "MBPP/109": [],
    "MBPP/110": [],
    "MBPP/111": [],
    "MBPP/112": [],
    "MBPP/113": [],
    "MBPP/114": [],
    "MBPP/115": [],
    "MBPP/116": [],
    "MBPP/117": [],
    "MBPP/118": [],
    "MBPP/119": [],
    "MBPP/120": [],
    "MBPP/121": [],
    "MBPP/122": [],
    "MBPP/123": [],
    "MBPP/124": [],
    "MBPP/125": [],
    "MBPP/126": [],
    "MBPP/127": [],
    "MBPP/128": [],
    "MBPP/129": [],
    "MBPP/130": [],
    "MBPP/131": [],
    "MBPP/132": [],
    "MBPP/133": [],
    "MBPP/134": [],
    "MBPP/135": [],
    "MBPP/136": [],
    "MBPP/137": [],
    "MBPP/138": [],
    "MBPP/139": [],
    "MBPP/140": [],
    "MBPP/141": [],
    "MBPP/142": [],
    "MBPP/143": [],
    "MBPP/144": [],
    "MBPP/145": [],
    "MBPP/146": [],
    "MBPP/147": [],
    "MBPP/148": [],
    "MBPP/149": [],
    "MBPP/150": [],
    "MBPP/151": [],
    "MBPP/152": [],
    "MBPP/153": [],
    "MBPP/154": [],
    "MBPP/155": [],
    "MBPP/156": [],
    "MBPP/157": [],
    "MBPP/158": [],
    "MBPP/159": [],
    "MBPP/160": [],
    "MBPP/161": [],
    "MBPP/162": [],
    "MBPP/163": [],
    "MBPP/164": [],
    "MBPP/165": [],
    "MBPP/166": [],
    "MBPP/167": [],
    "MBPP/168": [],
    "MBPP/169": [],
    "MBPP/170": [],
    "MBPP/171": [],
    "MBPP/172": [],
    "MBPP/173": [],
    "MBPP/174": [],
    "MBPP/175": [],
    "MBPP/176": [],
    "MBPP/177": [],
    "MBPP/178": [],
    "MBPP/179": [],
    "MBPP/180": [],
    "MBPP/181": [],
    "MBPP/182": [],
    "MBPP/183": [],
    "MBPP/184": [],
    "MBPP/185": [],
    "MBPP/186": [],
    "MBPP/187": [],
    "MBPP/188": [],
    "MBPP/189": [],
    "MBPP/190": [],
    "MBPP/191": [],
    "MBPP/192": [],
    "MBPP/193": [],
    "MBPP/194": [],
    "MBPP/195": [],
    "MBPP/196": [],
    "MBPP/197": [],
    "MBPP/198": [],
    "MBPP/199": [],
    "MBPP/200": [],
    "MBPP/201": [],
    "MBPP/202": [],
    "MBPP/203": [],
    "MBPP/204": [],
    "MBPP/205": [],
    "MBPP/206": [],
    "MBPP/207": [],
    "MBPP/208": [],
    "MBPP/209": [],
    "MBPP/210": [],
    "MBPP/211": [],
    "MBPP/212": [],
    "MBPP/213": [],
    "MBPP/214": [],
    "MBPP/215": [],
    "MBPP/216": [],
    "MBPP/217": [],
    "MBPP/218": [],
    "MBPP/219": [],
    "MBPP/220": [],
    "MBPP/221": [],
    "MBPP/222": [],
    "MBPP/223": [],
    "MBPP/224": [],
    "MBPP/225": [],
    "MBPP/226": [],
    "MBPP/227": [],
    "MBPP/228": [],
    "MBPP/229": [],
    "MBPP/230": [],
    "MBPP/231": [],
    "MBPP/232": [],
    "MBPP/233": [],
    "MBPP/234": [],
    "MBPP/235": [],
    "MBPP/236": [],
    "MBPP/237": [],
    "MBPP/238": [],
    "MBPP/239": [],
    "MBPP/240": [],
    "MBPP/241": [],
    "MBPP/242": [],
    "MBPP/243": [],
    "MBPP/244": [],
    "MBPP/245": [],
    "MBPP/246": [],
    "MBPP/247": [],
    "MBPP/248": [],
    "MBPP/249": [],
    "MBPP/250": [],
    "MBPP/251": [],
    "MBPP/252": [],
    "MBPP/253": [],
    "MBPP/254": [],
    "MBPP/255": [],
    "MBPP/256": [],
    "MBPP/257": [],
    "MBPP/258": [],
    "MBPP/259": [],
    "MBPP/260": [],
    "MBPP/261": [],
    "MBPP/262": [],
    "MBPP/263": [],
    "MBPP/264": [],
    "MBPP/265": [],
    "MBPP/266": [],
    "MBPP/267": [],
    "MBPP/268": [],
    "MBPP/269": [],
    "MBPP/270": [],
    "MBPP/271": [],
    "MBPP/272": [],
    "MBPP/273": [],
    "MBPP/274": [],
    "MBPP/275": [],
    "MBPP/276": [],
    "MBPP/277": [],
    "MBPP/278": [],
    "MBPP/279": [],
    "MBPP/280": [],
    "MBPP/281": [],
    "MBPP/282": [],
    "MBPP/283": [],
    "MBPP/284": [],
    "MBPP/285": [],
    "MBPP/286": [],
    "MBPP/287": [],
    "MBPP/288": [],
    "MBPP/289": [],
    "MBPP/290": [],
    "MBPP/291": [],
    "MBPP/292": [],
    "MBPP/293": [],
    "MBPP/294": [],
    "MBPP/295": [],
    "MBPP/296": [],
    "MBPP/297": [],
    "MBPP/298": [],
    "MBPP/299": [],
    "MBPP/300": [],
    "MBPP/301": [],
    "MBPP/302": [],
    "MBPP/303": [],
    "MBPP/304": [],
    "MBPP/305": [],
    "MBPP/306": [],
    "MBPP/307": [],
    "MBPP/308": [],
    "MBPP/309": [],
    "MBPP/310": [],
    "MBPP/311": [],
    "MBPP/312": [],
    "MBPP/313": [],
    "MBPP/314": [],
    "MBPP/315": [],
    "MBPP/316": [],
    "MBPP/317": [],
    "MBPP/318": [],
    "MBPP/319": [],
    "MBPP/320": [],
    "MBPP/321": [],
    "MBPP/322": [],
    "MBPP/323": [],
    "MBPP/324": [],
    "MBPP/325": [],
    "MBPP/326": [],
    "MBPP/327": [],
    "MBPP/328": [],
    "MBPP/329": [],
    "MBPP/330": [],
    "MBPP/331": [],
    "MBPP/332": [],
    "MBPP/333": [],
    "MBPP/334": [],
    "MBPP/335": [],
    "MBPP/336": [],
    "MBPP/337": [],
    "MBPP/338": [],
    "MBPP/339": [],
    "MBPP/340": [],
    "MBPP/341": [],
    "MBPP/342": [],
    "MBPP/343": [],
    "MBPP/344": [],
    "MBPP/345": [],
    "MBPP/346": [],
    "MBPP/347": [],
    "MBPP/348": [],
    "MBPP/349": [],
    "MBPP/350": [],
    "MBPP/351": [],
    "MBPP/352": [],
    "MBPP/353": [],
    "MBPP/354": [],
    "MBPP/355": [],
    "MBPP/356": [],
    "MBPP/357": [],
    "MBPP/358": [],
    "MBPP/359": [],
    "MBPP/360": [],
    "MBPP/361": [],
    "MBPP/362": [],
    "MBPP/363": [],
    "MBPP/364": [],
    "MBPP/365": [],
    "MBPP/366": [],
    "MBPP/367": [],
    "MBPP/368": [],
    "MBPP/369": [],
    "MBPP/370": [],
    "MBPP/371": [],
    "MBPP/372": [],
    "MBPP/373": [],
    "MBPP/374": [],
    "MBPP/375": [],
    "MBPP/376": [],
    "MBPP/377": [],
    "MBPP/378": [],
    "MBPP/379": [],
    "MBPP/380": [],
    "MBPP/381": [],
    "MBPP/382": [],
    "MBPP/383": [],
    "MBPP/384": [],
    "MBPP/385": [],
    "MBPP/386": [],
    "MBPP/387": [],
    "MBPP/388": [],
    "MBPP/389": [],
    "MBPP/390": [],
    "MBPP/391": [],
    "MBPP/392": [],
    "MBPP/393": [],
    "MBPP/394": [],
    "MBPP/395": [],
    "MBPP/396": [],
    "MBPP/397": [],
    "MBPP/398": [],
    "MBPP/399": [],
    "MBPP/400": [],
    "MBPP/401": [],
    "MBPP/402": [],
    "MBPP/403": [],
    "MBPP/404": [],
    "MBPP/405": [],
    "MBPP/406": [],
    "MBPP/407": [],
    "MBPP/408": [],
    "MBPP/409": [],
    "MBPP/410": [],
    "MBPP/411": [],
    "MBPP/412": [],
    "MBPP/413": [],
    "MBPP/414": [],
    "MBPP/415": [],
    "MBPP/416": [],
    "MBPP/417": [],
    "MBPP/418": [],
    "MBPP/419": [],
    "MBPP/420": [],
    "MBPP/421": [],
    "MBPP/422": [],
    "MBPP/423": [],
    "MBPP/424": [],
    "MBPP/425": [],
    "MBPP/426": [],
    "MBPP/427": [],
    "MBPP/428": [],
    "MBPP/429": [],
    "MBPP/430": [],
    "MBPP/431": [],
    "MBPP/432": [],
    "MBPP/433": [],
    "MBPP/434": [],
    "MBPP/435": [],
    "MBPP/436": [],
    "MBPP/437": [],
    "MBPP/438": [],
    "MBPP/439": [],
    "MBPP/440": [],
    "MBPP/441": [],
    "MBPP/442": [],
    "MBPP/443": [],
    "MBPP/444": [],
    "MBPP/445": [],
    "MBPP/446": [],
    "MBPP/447": [],
    "MBPP/448": [],
    "MBPP/449": [],
    "MBPP/450": [],
    "MBPP/451": [],
    "MBPP/452": [],
    "MBPP/453": [],
    "MBPP/454": [],
    "MBPP/455": [],
    "MBPP/456": [],
    "MBPP/457": [],
    "MBPP/458": [],
    "MBPP/459": [],
    "MBPP/460": [],
    "MBPP/461": [],
    "MBPP/462": [],
    "MBPP/463": [],
    "MBPP/464": [],
    "MBPP/465": [],
    "MBPP/466": [],
    "MBPP/467": [],
    "MBPP/468": [],
    "MBPP/469": [],
    "MBPP/470": [],
    "MBPP/471": [],
    "MBPP/472": [],
    "MBPP/473": [],
    "MBPP/474": [],
    "MBPP/475": [],
    "MBPP/476": [],
    "MBPP/477": [],
    "MBPP/478": [],
    "MBPP/479": [],
    "MBPP/480": [],
    "MBPP/481": [],
    "MBPP/482": [],
    "MBPP/483": [],
    "MBPP/484": [],
    "MBPP/485": [],
    "MBPP/486": [],
    "MBPP/487": [],
    "MBPP/488": [],
    "MBPP/489": [],
    "MBPP/490": [],
    "MBPP/491": [],
    "MBPP/492": [],
    "MBPP/493": [],
    "MBPP/494": [],
    "MBPP/495": [],
    "MBPP/496": [],
    "MBPP/497": [],
    "MBPP/498": [],
    "MBPP/499": []
  }
};
    </script>
    
    <script>
        let allProblems = [];
        let augmentedData = {
            function_wise: {},
            block_wise: {},
            bm25: {}
        };
        
        // Load all data
        async function loadData() {
            try {
                // This will be populated by Python
                allProblems = PROBLEMS_DATA;
                augmentedData = AUGMENTED_DATA;
                
                renderProblems();
                setupEventListeners();
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('problems-container').innerHTML = 
                    '<div class="no-results">Error loading data. Please check the console for details.</div>';
            }
        }
        
        function renderProblems(filteredProblems = null) {
            const container = document.getElementById('problems-container');
            const problems = filteredProblems || allProblems;
            
            if (problems.length === 0) {
                document.getElementById('no-results').style.display = 'block';
                container.innerHTML = '';
                return;
            }
            
            document.getElementById('no-results').style.display = 'none';
            document.getElementById('visible-problems').textContent = problems.length;
            
            container.innerHTML = problems.map(problem => createProblemCard(problem)).join('');
        }
        
        function createProblemCard(problem) {
            const taskId = problem.task_id;
            const dataset = problem.dataset || (taskId.startsWith('HumanEval/') ? 'HumanEval' : 'MBPP');
            const headerClass = dataset === 'MBPP' ? 'problem-header mbpp' : 'problem-header';
            
            return `
                <div class="problem-card" data-task-id="${taskId}" data-dataset="${dataset}">
                    <div class="${headerClass}" onclick="toggleProblem('${taskId}')">
                        <div>
                            <div class="problem-title">${taskId}</div>
                            <span class="dataset-badge">${dataset}</span>
                        </div>
                        <div class="expand-icon" id="icon-${taskId}"></div>
                    </div>
                    <div class="problem-content" id="content-${taskId}">
                        <div class="problem-section">
                            <div class="section-title">Problem Statement</div>
                            <div class="code-block">${escapeHtml(problem.prompt)}</div>
                        </div>
                        
                        <div class="problem-section">
                            <div class="section-title">Canonical Solution</div>
                            <div class="code-block">${escapeHtml(problem.canonical_solution)}</div>
                        </div>
                        
                        <div class="problem-section">
                            <div class="section-title">Test Cases</div>
                            <div class="code-block">${escapeHtml(problem.test)}</div>
                        </div>
                        
                        <div class="problem-section">
                            <div class="section-title">Augmented Contexts</div>
                            <div class="tab-container">
                                <button class="tab active" onclick="showTab('${taskId}', 'function_wise')">Function-wise</button>
                                <button class="tab" onclick="showTab('${taskId}', 'block_wise')">Block-wise</button>
                                <button class="tab" onclick="showTab('${taskId}', 'bm25')">BM25</button>
                            </div>
                            
                            <div class="tab-content active" id="tab-${taskId}-function_wise">
                                ${createAugmentedContent(taskId, 'function_wise')}
                            </div>
                            <div class="tab-content" id="tab-${taskId}-block_wise">
                                ${createAugmentedContent(taskId, 'block_wise')}
                            </div>
                            <div class="tab-content" id="tab-${taskId}-bm25">
                                ${createAugmentedContent(taskId, 'bm25')}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function createAugmentedContent(taskId, type) {
            const data = augmentedData[type][taskId];
            
            if (!data) {
                return '<div class="augmented-context">No augmented data available for this type.</div>';
            }
            
            if (type === 'bm25') {
                // BM25 data is an array of strings
                return `
                    <div class="augmented-context">
                        ${data.map((item, index) => `
                            <div class="context-item">
                                <div style="font-weight: bold; margin-bottom: 0.5rem;">Context ${index + 1}</div>
                                <div class="code-block">${escapeHtml(item)}</div>
                            </div>
                        `).join('')}
                    </div>
                `;
            } else {
                // Voyage data is an array of [score, content] pairs
                return `
                    <div class="augmented-context">
                        ${data.map((item, index) => `
                            <div class="context-item">
                                <div class="relevance-score">Relevance: ${item[0].toFixed(3)}</div>
                                <div class="code-block">${escapeHtml(item[1])}</div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
        }
        
        function toggleProblem(taskId) {
            const content = document.getElementById(`content-${taskId}`);
            const icon = document.getElementById(`icon-${taskId}`);
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                icon.textContent = '';
            } else {
                content.classList.add('expanded');
                icon.textContent = '';
            }
        }
        
        function showTab(taskId, type) {
            // Remove active class from all tabs and contents for this problem
            const tabs = document.querySelectorAll(`[onclick*="${taskId}"]`);
            const contents = document.querySelectorAll(`[id^="tab-${taskId}-"]`);
            
            tabs.forEach(tab => tab.classList.remove('active'));
            contents.forEach(content => content.classList.remove('active'));
            
            // Add active class to selected tab and content
            event.target.classList.add('active');
            document.getElementById(`tab-${taskId}-${type}`).classList.add('active');
        }
        
        function expandAll() {
            document.querySelectorAll('.problem-content').forEach(content => {
                content.classList.add('expanded');
            });
            document.querySelectorAll('.expand-icon').forEach(icon => {
                icon.textContent = '';
            });
        }
        
        function collapseAll() {
            document.querySelectorAll('.problem-content').forEach(content => {
                content.classList.remove('expanded');
            });
            document.querySelectorAll('.expand-icon').forEach(icon => {
                icon.textContent = '';
            });
        }
        
        function setupEventListeners() {
            const searchInput = document.getElementById('search-input');
            const filterSelect = document.getElementById('dataset-filter');
            
            searchInput.addEventListener('input', filterProblems);
            filterSelect.addEventListener('change', filterProblems);
        }
        
        function filterProblems() {
            const searchTerm = document.getElementById('search-input').value.toLowerCase();
            const datasetFilter = document.getElementById('dataset-filter').value;
            
            let filtered = allProblems.filter(problem => {
                const matchesSearch = problem.task_id.toLowerCase().includes(searchTerm) ||
                                    problem.prompt.toLowerCase().includes(searchTerm) ||
                                    problem.canonical_solution.toLowerCase().includes(searchTerm);
                
                let matchesFilter = true;
                if (datasetFilter === 'humaneval') {
                    matchesFilter = problem.task_id.startsWith('HumanEval/');
                } else if (datasetFilter === 'mbpp') {
                    matchesFilter = problem.task_id.startsWith('MBPP/');
                } else if (datasetFilter !== 'all') {
                    // Augmentation type filters
                    const hasAugmentation = augmentedData[datasetFilter][problem.task_id];
                    matchesFilter = !!hasAugmentation;
                }
                
                return matchesSearch && matchesFilter;
            });
            
            renderProblems(filtered);
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', loadData);
    </script>
</body>
</html> 