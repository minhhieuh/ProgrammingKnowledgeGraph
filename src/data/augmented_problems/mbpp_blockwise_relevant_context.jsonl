{"task_id": "MBPP/0", "problem": [[0.8935022354125977, "    new_string = given_string.replace(character, '')\n    return new_string"], [0.8933295011520386, "    result = ''\n    for c in string:\n        if c != char:\n            result += c\n    return result"], [0.8930686116218567, "    char = char.lower()\n    modified_string = ''\n    i = 0\n    while i < len(string):\n        current_char = string[i].lower()\n        if current_char == char:\n            i += 1\n        else:\n            modified_string += string[i]\n            i += 1\n    return modified_string"], [0.8915549516677856, "    string_list = list(string)\n    for i in string_list:\n        if i == char:\n            string_list.remove(i)\n    string = ''.join(string_list)\n    return string"], [0.8910537958145142, "    res = ''\n    for i in range(len(string)):\n        if string[i] != char:\n            res += string[i]\n    return res"], [0.8907175064086914, "    new_string = string.replace(char, '')\n    return new_string"], [0.8887303471565247, "    modified_string = string.replace(char, '')\n    reversed_string = modified_string[::-1]\n    return reversed_string"], [0.8870867490768433, "    modified_string = ''\n    for c in input_string:\n        if c != char:\n            modified_string += c\n    return modified_string"], [0.886863112449646, "    newString = ''\n    for ch in s:\n        if ch != character:\n            newString += ch\n    return newString"], [0.8857054710388184, "    new_string = ''\n    for char in input_string:\n        if char != character_to_remove:\n            new_string += char\n    return new_string"]]}
{"task_id": "MBPP/1", "problem": [[0.9157993793487549, "    sums = get_row_sums(arr)\n    sorted_arr = [x for _, x in sorted(zip(sums, arr), reverse=True)]\n    return sorted_arr"], [0.9088024497032166, "    row_sums = [sum(row) for row in arr]\n    rows_with_sums = [(row_sum, row) for row_sum, row in zip(row_sums, arr) if not any((num < 0 for num in row))]\n    sorted_rows = sorted(rows_with_sums, key=lambda x: x[0])\n    sorted_arr = [row for _, row in sorted_rows]\n    return sorted_arr"], [0.9086021184921265, "    for row in matrix:\n        row.sort()"], [0.9085951447486877, "    for row in matrix:\n        row.sort()"], [0.9055625200271606, "    for i in range(len(arr)):\n        for j in range(len(arr[i])):\n            for k in range(len(arr[i]) - j - 1):\n                if arr[i][k] > arr[i][k + 1]:\n                    arr[i][k], arr[i][k + 1] = (arr[i][k + 1], arr[i][k])\n    sum_rows = [(sum(arr[i]), i) for i in range(len(arr))]\n    sum_rows.sort()\n    arr = [arr[i] for _, i in sum_rows]\n    return arr"], [0.9041557312011719, "    for row in matrix:\n        row.sort()\n    return matrix"], [0.9040737152099609, "    array.sort(key=lambda x: sum(x))\n    return array"], [0.9039385318756104, "    sort_rows = []\n    for i in range(len(matrix)):\n        sorted_cols = sorted(matrix[i])\n        sort_rows.append(sorted_cols)\n    return sort_rows"], [0.9002572298049927, "    arr.sort(key=lambda x: sum(x))\n    return arr"], [0.8990293741226196, "    for col in range(len(matrix[0])):\n        column = [matrix[row][col] for row in range(len(matrix))]\n        column.sort(reverse=True)\n        for row in range(len(matrix)):\n            matrix[row][col] = column[row]"]]}
{"task_id": "MBPP/2", "problem": [[0.9292007088661194, "    counter = Counter(words)\n    most_common = counter.most_common()\n    most_common_words = [x[0] for x in most_common]\n    return most_common_words"]]}
{"task_id": "MBPP/3", "problem": [[0.9031164646148682, "    assert a >= 0 and b >= 0 and (c >= 0) and (h >= 0), 'Ensure non-negative prism dimensions'\n    assert a + b > c and b + c > a and (c + a > b), 'Ensure valid triangle dimensions'\n    v = a * b * c / (4 * math.sqrt((a + b + c) * (-a + b + c) * (a - b + c) * (a + b - c))) * h\n    return v"], [0.9006482362747192, "    assert a >= 0 and b >= 0 and (c >= 0) and (h >= 0), 'Ensure non-negative prism dimensions'\n    assert a + b > c and b + c > a and (c + a > b), 'Ensure valid triangle dimensions'\n    s = a * h + b * h + c * h + a * b * c / (2 * math.sqrt((a + b + c) * (-a + b + c) * (a - b + c) * (a + b - c)))\n    return s"], [0.8990471363067627, "    volume = 1 / 3 * base_area * height\n    return volume"], [0.8981781601905823, "    volume = side ** 2 * height / 3\n    return volume"], [0.8971623182296753, "    elif base == 0 or height == 0:\n        return 0\n    else:\n        volume = 1 / 3 * base * height\n        return volume"], [0.8971431255340576, "    if base < 0 or height < 0:\n        return 'Error: Base and height must be zero or positive numbers.'\n    elif base == 0 or height == 0:\n        return 0\n    else:\n        volume = 1 / 3 * base * height\n        return volume"], [0.8971431255340576, "    if base < 0 or height < 0:\n        return 'Error: Base and height must be zero or positive numbers.'\n    elif base == 0 or height == 0:\n        return 0\n    else:\n        volume = 1 / 3 * base * height\n        return volume"], [0.8959054350852966, "    base_area = base_side ** 2\n    lateral_area = base_side * slant_height\n    surface_area = base_area + lateral_area\n    height = math.sqrt(slant_height ** 2 - (base_side / 2) ** 2)\n    volume = base_area * height / 3\n    return (surface_area, volume)"], [0.8927569389343262, "    base_area = base_length * base_width\n    volume = 1 / 3 * base_area * height\n    return volume"], [0.8924069404602051, "    base_area = base_length1 * base_width1\n    top_area = top_length2 * top_width2\n    volume = 1 / 3 * height * (base_area + top_area + sqrt(base_area * top_area))\n    return volume"]]}
{"task_id": "MBPP/4", "problem": [[0.8883125185966492, "    pattern = re.compile(delimiter, re.IGNORECASE)\n    return pattern.split(my_string)"], [0.886772871017456, "    output = []\n    for string in strings:\n        if string == '':\n            output.append(('', ''))\n        elif char in string:\n            index = string.index(char)\n            output.append((string[:index], string[index + 1:]))\n        else:\n            output.append(None)\n    return output"], [0.8861655592918396, "    for item in lst:\n        if item[0].islower():\n            lower_case.append(item)\n        else:\n            upper_case.append(item)"], [0.8859021067619324, "    words = []\n    word = ''\n    for char in string:\n        if char != ' ':\n            word += char\n        else:\n            if word.isupper():\n                words.append(word)\n            word = ''\n    if word.isupper():\n        words.append(word)\n    return words"], [0.8856807947158813, "    result = []\n    for string in lst:\n        if char in string:\n            index = string.index(char)\n            substring1 = string[:index]\n            substring2 = string[index + 1:]\n            result.append((substring1, substring2))\n        else:\n            result.append(('None', 'None'))\n    return result"], [0.8837289810180664, "    result = []\n    current_word = ''\n    for char in string:\n        if char == delimiter:\n            result.append(current_word)\n            current_word = ''\n        else:\n            current_word += char\n    result.append(current_word)\n    return result"], [0.8823074698448181, "    lower_case = []\n    upper_case = []\n    for item in lst:\n        if item[0].islower():\n            lower_case.append(item)\n        else:\n            upper_case.append(item)\n    return lower_case + upper_case"]]}
{"task_id": "MBPP/5", "problem": [[0.8898218870162964, "    elif cases['Underscore']:\n        return 'Underscore'"], [0.8838483095169067, "    return re.findall('[A-Z][^A-Z]*', s)"], [0.8827824592590332, "    pattern = '\\\\b(?<![bcdfghjklmnpqrstvwxyz])[a-z]*a[a-z]+\\\\b'\n    words = re.findall(pattern, string, re.I)\n    return words"], [0.8818235993385315, "    pattern = re.compile('[a-z\\\\W].*\\\\d$')\n    matches = pattern.findall(s)\n    return matches"], [0.8817222714424133, "    pattern = '\\\\b\\\\w*[bcdfghjklmnpqrstvwxyz]{3}\\\\w*\\\\b'\n    return re.findall(pattern, text, re.I)"], [0.8800414800643921, "    string = string.strip()\n    converted_string = ''\n    prev_char = ''\n    for char in string:\n        if char.isalpha():\n            if prev_char == ' ':\n                converted_string += '_'\n            converted_string += char\n        prev_char = char\n    return converted_string"], [0.8799607753753662, "    matches = re.finditer('.+?(?:(?<=[a-z])(?=[A-Z])|(?<=[A-Z])(?=[A-Z][a-z])|$)', identifier)\n    return [m.group(0) for m in matches]"], [0.8796290755271912, "    pattern = re.compile('a.*Z')\n    return pattern.findall(text)"], [0.8788444399833679, "    pattern = '\\\\b[aA]\\\\w*\\\\b'\n    matches = re.findall(pattern, text)\n    return matches"], [0.8780224323272705, "    pattern = '[a-zA-Z]*a[a-zA-Z]*'\n    result = re.findall(pattern, text)\n    return result"]]}
{"task_id": "MBPP/6", "problem": [[0.8896439671516418, "    perimeter = sum(sides)\n    return perimeter"], [0.8876674771308899, "    perimeter = 2 * math.pi * radius\n    return perimeter"], [0.887175977230072, "    area = n * n\n    perimeter = 4 * n\n    return (area, perimeter)"], [0.8830826282501221, "    perimeter = side1 + side2 + side3\n    return perimeter"], [0.8811260461807251, "    import math\n    return math.sqrt(4)"]]}
{"task_id": "MBPP/7", "problem": [[0.9303379654884338, "    str1_list = list(str1)\n    str2_list = list(str2)\n    for char in str1_list:\n        if char in str2_list:\n            str1_list.remove(char)\n    output_str = ''.join(str1_list)\n    return output_str"], [0.9269521236419678, "    return_char = [ch for ch in s1 if ch not in s2]\n    return ''.join(return_char)"], [0.9210196733474731, "    for char in second_string:\n        first_string = first_string.replace(char, '')"], [0.9210057258605957, "    for char in second_string:\n        first_string = first_string.replace(char, '')"], [0.9199011921882629, "    new_string = ''\n    for char in string2:\n        if char not in string1:\n            new_string += char\n    return new_string"], [0.9158872365951538, "    substring = ''\n    for char in string_1:\n        if char not in string_2:\n            substring += char\n    return substring"], [0.9137983322143555, "    return [char for char in stringA if char not in set(stringB)]"], [0.9130845665931702, "    t_set = set(t)\n    result = [char for char in s if char not in t_set]\n    return ''.join(result)"], [0.9123449325561523, "    new_string = ''\n    for char in string:\n        if char != remove_char:\n            new_string += char\n    return new_string"], [0.9104128479957581, "    new_string = ''\n    for char in input_string:\n        if char != character_to_remove:\n            new_string += char\n    return new_string"]]}
{"task_id": "MBPP/8", "problem": [[0.9274294376373291, "    duplicates = set()\n    for num in arr:\n        if num in duplicates:\n            return True\n        duplicates.add(num)\n    return False"], [0.9272282719612122, "    dup_set = set()\n    for i in arr:\n        if i in dup_set:\n            return True\n        else:\n            dup_set.add(i)\n    return False"], [0.9252391457557678, "    mySet = set()\n    for item in arr:\n        if item in mySet:\n            return True\n        else:\n            mySet.add(item)\n    return False"], [0.9236360192298889, "    seen_elements = {}\n    for element in arr:\n        if element in seen_elements:\n            return True\n        else:\n            seen_elements[element] = 1\n    return False"], [0.9233723282814026, "    for element in array1:\n        if type(element) == int:\n            if element in Hash1:\n                return True\n            Hash1[element] = 1"], [0.9233717322349548, "    seen = set()\n    for num in array:\n        if num in seen:\n            return True\n        else:\n            seen.add(num)\n    return False"], [0.9224867820739746, "    for item in arr:\n        if item in mySet:\n            return True\n        else:\n            mySet.add(item)"], [0.9220190048217773, "    seen = set()\n    for element in array:\n        if element in seen:\n            return True\n        seen.add(element)\n    return False"], [0.9219200611114502, "    seen = {}\n    for num in arr:\n        if num in seen:\n            return True\n        else:\n            seen[num] = True\n    return False"], [0.9218522310256958, "    count = {}\n    for elem in arr:\n        if elem in count:\n            return True\n        else:\n            count[elem] = 0\n    return False"]]}
{"task_id": "MBPP/9", "problem": [[0.8898142576217651, "        if num >= 2 and num <= 6 and (num % 3 == 0):\n            return True\n        else:\n            return False"], [0.889068603515625, "    return number % 7 == 0"], [0.8880895376205444, "    try:\n        num = int(input_num)\n        if num >= 2 and num <= 6 and (num % 3 == 0):\n            return True\n        else:\n            return False\n    except ValueError:\n        return False"], [0.8880895376205444, "    try:\n        num = int(input_num)\n        if num >= 2 and num <= 6 and (num % 3 == 0):\n            return True\n        else:\n            return False\n    except ValueError:\n        return False"], [0.887243390083313, "    return num % 4 == 0 or num % 6 == 0"], [0.8867993354797363, "    if number <= 3:\n        return True"], [0.8864123821258545, "    if number % 7 == 0:\n        return True\n    return False"], [0.8860408067703247, "    if number % 10 == 0:\n        return True\n    return False"], [0.8859274387359619, "    return '3' in str(number)"], [0.8854297399520874, "    if number == 2 or number == 3:\n        return True"]]}
{"task_id": "MBPP/10", "problem": [[0.9231947660446167, "    multiples = []\n    for i in range(start, end + 1):\n        if i % m == 0:\n            multiples.append(i)\n    return multiples"], [0.9197291135787964, "    i = 0\n    multiples_list = []\n    while i < n:\n        i += multiple\n        if i <= n:\n            multiples_list.append(i)\n    return multiples_list"], [0.9187780618667603, "    multiples = []\n    for i in range(start, end + 1):\n        if i % n == 0:\n            multiples.append(i)\n    return multiples"], [0.9183543920516968, "    numbers = list(range(start, end + 1))\n    multiples = [i for i in numbers if i % n == 0]\n    return multiples"], [0.916021466255188, "    for i in range(start, end + 1):\n        if i % m == 0:\n            multiples.append(i)"], [0.9148183465003967, "        if i % m == 0:\n            multiples.append(i)"], [0.9148125052452087, "    while i < n:\n        i += multiple\n        if i <= n:\n            multiples_list.append(i)"], [0.9144061803817749, "    for i in range(start, end + 1):\n        if i % n == 0:\n            multiples.append(i)"], [0.9139091968536377, "    for i in range(start, upper_limit + 1):\n        if i % n == 0:\n            multiples.append(i)"], [0.9136213064193726, "    multiples = []\n    start = max(n, lower_limit)\n    for i in range(start, upper_limit + 1):\n        if i % n == 0:\n            multiples.append(i)\n    return multiples"]]}
{"task_id": "MBPP/11", "problem": [[0.9256086349487305, "    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return -1"], [0.9256068468093872, "    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return -1"], [0.9240059852600098, "    seen = set()\n    for i in A:\n        if i in seen:\n            return i\n        seen.add(i)\n    return -1"], [0.923652708530426, "    seen = dict()\n    for i, n in enumerate(arr):\n        if n in seen:\n            return i\n        else:\n            seen[n] = True\n    return -1"], [0.9226357936859131, "    seen = set()\n    for i in range(len(arr)):\n        elem = arr[i]\n        if elem in seen:\n            return i\n        else:\n            seen.add(elem)\n    return None"], [0.9209039211273193, "    number_frequencies = {}\n    number_indices = {}\n    duplicate_index = {}\n    for i in range(len(a)):\n        if a[i] not in number_frequencies:\n            number_frequencies[a[i]] = 1\n            number_indices[a[i]] = i\n        elif a[i] in number_frequencies:\n            if number_frequencies[a[i]] < 2:\n                number_frequencies[a[i]] += 1\n                number_indices[a[i]] = i\n    for number in number_frequencies:\n        if number_frequencies[number] == 2:\n            duplicate_index[number] = number_indices[number]\n    if not duplicate_index:\n        return -1\n    else:\n        minimal_index_key = min(duplicate_index, key=duplicate_index.get)\n        return duplicate_index[minimal_index_key]"], [0.9207968711853027, "    seen = {}\n    for i in range(len(arr)):\n        if arr[i] in seen:\n            return i\n        else:\n            seen[arr[i]] = True\n    return -1"], [0.9203717708587646, "    seen = set()\n    for element in arr:\n        if element in seen:\n            return element\n        else:\n            seen.add(element)\n    return None"], [0.9196879267692566, "    for i, n in enumerate(arr):\n        if n in seen:\n            return i\n        else:\n            seen[n] = True"], [0.9194589853286743, "    elements = set()\n    for a in arr:\n        if a in elements:\n            return a\n        else:\n            elements.add(a)\n    return None"]]}
{"task_id": "MBPP/12", "problem": [[0.9312211871147156, "    for lst in list_of_lists:\n        if max_sum is None or sum(lst) > max_sum:\n            max_sum = sum(lst)\n            max_list = lst"], [0.9267818927764893, "    max_sum = None\n    max_list = None\n    for lst in list_of_lists:\n        if max_sum is None or sum(lst) > max_sum:\n            max_sum = sum(lst)\n            max_list = lst\n    return max_list"], [0.9173154234886169, "    sum_list = [sum(row) for row in arr]\n    max_element = max(sum_list)\n    return max_element"], [0.9035146236419678, "    max_sum = float('-inf')\n    max_row = None\n    row_sums = []\n    for i in range(len(arr)):\n        row_sum = sum(arr[i])\n        row_sums.append(row_sum)\n        if row_sum > max_sum:\n            max_sum = row_sum\n            max_row = arr[i]\n    return (max_row, row_sums)"], [0.9034614562988281, "    for lis in lists:\n        if not lis:\n            result.append(0)\n        else:\n            max_num = -10 ** 18\n            for num in lis:\n                max_num = max(max_num, num)\n            result.append(max_num)"], [0.9021005034446716, "    sums = [sum(sublist) for sublist in arr]\n    highest_sum = max(sums)\n    highest_sum_arrays = [[arr[i], highest_sum] for i in range(len(arr)) if sums[i] == highest_sum]\n    flattened_list = [item for sublist in highest_sum_arrays for item in sublist]\n    return flattened_list"], [0.900605320930481, "    max_sum = max((sum(sublist) for sublist in lst))\n    max_index = next((i for i, sublist in enumerate(lst) if sum(sublist) == max_sum))\n    return (max_sum, max_index)"], [0.900556206703186, "    max_sum = max((sum(sublist) for sublist in lst))\n    max_index = next((i for i, sublist in enumerate(lst) if sum(sublist) == max_sum))\n    return (max_sum, max_index)"], [0.8997026085853577, "    lists = [x, y, z]\n    result = []\n    for lis in lists:\n        if not lis:\n            result.append(0)\n        else:\n            max_num = -10 ** 18\n            for num in lis:\n                max_num = max(max_num, num)\n            result.append(max_num)\n    result = list(dict.fromkeys(result))\n    return result"], [0.8992716073989868, "    max_sum = 0\n    for inner_arr in arr:\n        curr_sum = 0\n        for sub_arr in inner_arr:\n            curr_sum += sum(sub_arr)\n        if curr_sum > max_sum:\n            max_sum = curr_sum\n    return max_sum"]]}
{"task_id": "MBPP/13", "problem": [[0.9327227473258972, "    decimal_number = 0\n    for digit in binary_number:\n        decimal_number = decimal_number * 2 + int(digit)\n    return decimal_number"], [0.9317863583564758, "    decimal = 0\n    for digit in binary:\n        decimal = decimal * 2 + int(digit)\n    return decimal"], [0.931767463684082, "    decimal = 0\n    for digit in binary:\n        decimal = decimal * 2 + int(digit)\n    return decimal"], [0.9317631721496582, "    decimal = 0\n    for digit in binary:\n        decimal = decimal * 2 + int(digit)\n    return decimal"], [0.9317542910575867, "    decimal = 0\n    for digit in binary:\n        decimal = decimal * 2 + int(digit)\n    return decimal"], [0.9297353029251099, "    if not isinstance(binary_num, str):\n        raise ValueError('Input number must be a binary string.')\n    decimal_num = int(binary_num, 2)\n    return decimal_num"], [0.9296039342880249, "    binary = str(binary)\n    decimal = 0\n    for digit in binary:\n        decimal = decimal * 2 + int(digit)\n    return decimal"], [0.929593563079834, "    binary = str(binary)\n    decimal = 0\n    for digit in binary:\n        decimal = decimal * 2 + int(digit)\n    return decimal"], [0.928455114364624, "    decimal = 0\n    for i in range(0, len(binary)):\n        decimal += int(binary[i]) * 2 ** (len(binary) - 1 - i)\n    return decimal"], [0.928343653678894, "    decimal_num = 0\n    for digit in binary_num:\n        decimal_num = decimal_num * 2 + int(digit)\n    return decimal_num"]]}
{"task_id": "MBPP/14", "problem": [[0.9236128926277161, "    unique_lst = set(lst)\n    product = 1\n    for num in unique_lst:\n        product *= num\n    return product"], [0.9166404008865356, "    distinct_nums = set(num_list)\n    product = reduce(operator.mul, distinct_nums, 1)\n    return product"], [0.9158223271369934, "    product = 1\n    for num in arr:\n        if num % 3 == 0 and num != 4:\n            product *= num\n    return product"], [0.9143580794334412, "    if len(array) == 1:\n        return array[0]\n    else:\n        return array[0] * product(array[1:])"], [0.9143580794334412, "    if len(array) == 1:\n        return array[0]\n    else:\n        return array[0] * product(array[1:])"], [0.9140768051147461, "    product = 1\n    for i in range(len(arr)):\n        product *= arr[i]\n    return product"], [0.9134902954101562, "    product = 1\n    unique_numbers = set(seq)\n    for number in unique_numbers:\n        product *= number\n    return product"], [0.913489818572998, "    product = 1\n    unique_numbers = set(seq)\n    for number in unique_numbers:\n        product *= number\n    return product"], [0.9134044647216797, "    for i in range(len(arr)):\n        product *= arr[i]"], [0.9130109548568726, "    for num in distinct_arr:\n        product *= num"]]}
{"task_id": "MBPP/15", "problem": [[0.8865698575973511, "    for t in tuples:\n        if 'k' in t:\n            return True\n    return False"], [0.8855915069580078, "    if not isinstance(k, int):\n        return \"Error: Argument 'k' should be an integer\"\n    if not all((isinstance(t, tuple) for t in tuples)):\n        return 'Error: All elements should be tuples'\n    indices = [i for i, t in enumerate(tuples) if k in t]\n    if not indices:\n        return f'No tuples found containing the number {k}'\n    return indices"], [0.8820208311080933, "    for t in tuples:\n        if 'k' in t:\n            return True"], [0.8812617063522339, "    for i in t:\n        if type(i) == tuple:\n            count += find_frequency(i, k)\n        elif i == k:\n            count += 1"], [0.8812515735626221, "    for i in t:\n        if type(i) == tuple:\n            count += find_frequency(i, k)\n        elif i == k:\n            count += 1"], [0.8801748752593994, "    count = 0\n    for i in t:\n        if type(i) == tuple:\n            count += find_frequency(i, k)\n        elif i == k:\n            count += 1\n    return count"], [0.8801641464233398, "    count = 0\n    for i in t:\n        if type(i) == tuple:\n            count += find_frequency(i, k)\n        elif i == k:\n            count += 1\n    return count"], [0.8796579837799072, "    if not all((isinstance(t, tuple) for t in tuples)):\n        raise TypeError('All input items must be of type tuple.')\n    elif not isinstance(k, int):\n        raise TypeError('The search key must be an integer.')\n    indices = [i for i, t in enumerate(tuples) if k in t]\n    if not indices:\n        return f\"The integer '{k}' was not found in any tuple.\"\n    else:\n        return indices"], [0.8796533346176147, "    if not all((isinstance(t, tuple) for t in tuples)):\n        raise TypeError('All input items must be of type tuple.')\n    elif not isinstance(k, int):\n        raise TypeError('The search key must be an integer.')\n    indices = [i for i, t in enumerate(tuples) if k in t]\n    if not indices:\n        return f\"The integer '{k}' was not found in any tuple.\"\n    else:\n        return indices"], [0.8793767690658569, "    if check_presence:\n        return element in my_tuple\n    else:\n        return element not in my_tuple"]]}
{"task_id": "MBPP/16", "problem": [[0.9047301411628723, "    output_string = ''\n    for char in input_string:\n        if not char.isdigit():\n            output_string += char\n    return output_string"], [0.9047287702560425, "    output_string = ''\n    for char in input_string:\n        if not char.isdigit():\n            output_string += char\n    return output_string"], [0.9039291739463806, "    filtered = []\n    for item in arr:\n        if item.isdigit():\n            filtered.append(item)\n    return filtered"], [0.9029483795166016, "    filtered_list = []\n    for string in strings_list:\n        if any((char.isalnum() for char in string)):\n            filtered_list.append(string)\n    return filtered_list"], [0.897061288356781, "    filtered_words = []\n    for word in list_of_strings:\n        if not any((char.isdigit() for char in word)):\n            if not word[0].isupper():\n                filtered_words.append(word)\n    return filtered_words"], [0.8966808319091797, "    non_numbers = [character for character in input_string if not character.isdigit()]\n    return ''.join(non_numbers)"], [0.8957465291023254, "    output = ''.join(filter(lambda x: not x.isdigit(), string))\n    return output"], [0.8952904939651489, "    lowercase_letters = []\n    for string in strings:\n        lowercase_letters += remove_digits_special_chars(string)\n    return lowercase_letters"], [0.8951559066772461, "    numbers = []\n    for char in my_string:\n        if char.isdigit():\n            numbers.append(char)\n    return numbers"], [0.895067572593689, "    modified_document = ''\n    for ch in document:\n        if not ch.isdigit():\n            modified_document += ch\n    return modified_document"]]}
{"task_id": "MBPP/17", "problem": [[0.9105063676834106, "    if type(n) in (float, complex):\n        return 'Binomial coefficients are not defined for floating point and complex numbers.'"], [0.9104688167572021, "    if type(n) in (float, complex):\n        return 'Binomial coefficients are not defined for floating point and complex numbers.'"], [0.9087896943092346, "    if type(n) not in (int, float, complex, list, tuple):\n        return 'Invalid input. Please enter a positive integer, a floating point number, a complex number, a list or a tuple.'\n    if type(n) in (float, complex):\n        return 'Binomial coefficients are not defined for floating point and complex numbers.'\n    if type(n) == int and n < 0:\n        return 'Invalid input. Please enter a non-negative integer.'\n    if type(n) in (list, tuple):\n        try:\n            cumulative_product = 1\n            for i in n:\n                if i < 0 or type(i) != int:\n                    return 'Invalid input in list/tuple. Please ensure all elements are non-negative integers.'\n                if i > 0:\n                    cumulative_product *= functools.reduce(operator.mul, (math.comb(i, j) for j in range(i + 1)), 1)\n            return cumulative_product\n        except TypeError:\n            return\n    elif type(n) == int:\n        return functools.reduce(operator.mul, (math.comb(n, i) for i in range(n + 1)), 1)"], [0.908073902130127, "    if type(n) not in (int, float, complex, list, tuple):\n        return 'Invalid input. Please enter a positive integer, a floating point number, a complex number, a list or a tuple.'\n    if type(n) in (float, complex):\n        return 'Binomial coefficients are not defined for floating point and complex numbers.'\n    if type(n) == int and n < 0:\n        return 'Invalid input. Please enter a non-negative integer.'\n    if type(n) in (list, tuple):\n        try:\n            cumul_product = 1\n            for i in n:\n                if i < 0 or type(i) != int:\n                    return 'Invalid input in list/tuple. Please assure all elements are non-negative integers.'\n                if i > 0:\n                    cumul_product *= functools.reduce(operator.mul, (math.comb(i, j) for j in range(i + 1)), 1)\n            return cumul_product\n        except TypeError:\n            return\n    elif type(n) == int:\n        return functools.reduce(operator.mul, (math.comb(n, i) for i in range(n + 1)), 1)"], [0.9074580073356628, "    if n == k or k == 0:\n        return 1\n    return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k)"], [0.9048932790756226, "    if k == 0 or k == n:\n        return 1\n    return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k)"], [0.9041604995727539, "    coefficient = []\n    for k in range(n + 1):\n        coefficient.append(int(math.factorial(n) / (math.factorial(k) * math.factorial(n - k))))\n    return coefficient"], [0.8973772525787354, "    for k in range(n + 1):\n        coefficient.append(int(math.factorial(n) / (math.factorial(k) * math.factorial(n - k))))"], [0.8967903852462769, "    if k == 0 or k == n:\n        return 1\n    else:\n        return (binomial_coefficient(n - 1, k - 1, modulo) + binomial_coefficient(n - 1, k, modulo)) % modulo"]]}
{"task_id": "MBPP/18", "problem": [[0.9176737070083618, "    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    for num in arr:\n        if freq[num] % 2 != 0:\n            return num\n    return None"], [0.916891872882843, "    for num in arr:\n        if freq[num] % 2 != 0:\n            return num"], [0.9165377616882324, "    for num in arr:\n        if frequency[num] % 2 != 0:\n            return num"], [0.913617730140686, "    count_dict = {}\n    for num in arr:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    for key, value in count_dict.items():\n        if value % 2 == 1:\n            return key\n    return None"], [0.9114210605621338, "    counter_dict = {}\n    for num in lst:\n        if num in counter_dict:\n            counter_dict[num] += 1\n        else:\n            counter_dict[num] = 1\n    odd_occurrence_list = [num for num, freq in counter_dict.items() if freq % 2 == 1]\n    return odd_occurrence_list"], [0.9112945795059204, "    count = {}\n    for num in arr:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    for num in arr:\n        if count[num] % 2 == 1:\n            return num\n    return -1"], [0.9104864597320557, "    for num in arr:\n        if count[num] % 2 == 1:\n            return num"], [0.9088071584701538, "    counter = Counter(array)\n    odd_counter = {k: v for k, v in counter.items() if k % 2 != 0}\n    if odd_counter:\n        return max(odd_counter, key=odd_counter.get)\n    else:\n        return 'No odd numbers in array'"], [0.9077858924865723, "    count_dict = {}\n    for num in arr:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    for num, count in count_dict.items():\n        if count % 2 != 0:\n            return num\n    return -1"], [0.9073256254196167, "    for i in range(len(arr)):\n        if arr[i] % 2 != 0:\n            return arr[i]\n    return 'No odd number found'"]]}
{"task_id": "MBPP/19", "problem": [[0.915766179561615, "    count = 0\n    for i in range(len(input_str)):\n        for j in range(i + 1, len(input_str) + 1):\n            substr = input_str[i:j]\n            if substr[0] == substr[-1]:\n                count += 1\n    return count"], [0.9149429798126221, "            if substr[0] == substr[-1]:\n                count += 1"], [0.9137494564056396, "    for i in range(len(input_str)):\n        for j in range(i + 1, len(input_str) + 1):\n            substr = input_str[i:j]\n            if substr[0] == substr[-1]:\n                count += 1"], [0.9116255044937134, "    count = 0\n    for s in lst:\n        if len(s) >= 2 and s[0] == s[-1]:\n            count += 1\n    return count"], [0.9114566445350647, "        for j in range(i + 1, len(input_str) + 1):\n            substr = input_str[i:j]\n            if substr[0] == substr[-1]:\n                count += 1"], [0.9099735021591187, "    for s in lst:\n        if len(s) >= 2 and s[0] == s[-1]:\n            count += 1"], [0.9082250595092773, "        while l >= 0 and r < n and (s[l] == s[r]):\n            count += 1\n            dp[r] = (dp[r] + dp[l]) % MOD\n            l -= 1\n            r += 1"], [0.9082250595092773, "        while l >= 0 and r < n and (s[l] == s[r]):\n            count += 1\n            dp[r] = (dp[r] + dp[l]) % MOD\n            l -= 1\n            r += 1"], [0.9065709710121155, "    for i in range(n):\n        l = r = i\n        while l >= 0 and r < n and (s[l] == s[r]):\n            count += 1\n            l -= 1\n            r += 1"], [0.9046937227249146, "            if substring == substring[::-1]:\n                count += 1"]]}
{"task_id": "MBPP/20", "problem": [[0.927685558795929, "    frequency = {}\n    for value in array:\n        if value in frequency:\n            frequency[value] += 1\n        else:\n            frequency[value] = 1\n    heap = []\n    for value, freq in frequency.items():\n        heapq.heappush(heap, (freq, value))\n        if len(heap) > k:\n            heapq.heappop(heap)\n    k_most_common = []\n    while heap:\n        freq, value = heapq.heappop(heap)\n        k_most_common.append((value, freq))\n    k_most_common.reverse()\n    return k_most_common"], [0.9235748052597046, "    frequency = Counter(nums)\n    min_heap = []\n    for num, freq in frequency.items():\n        heappush(min_heap, (freq, num))\n        if len(min_heap) > k:\n            heappop(min_heap)\n    return [heappop(min_heap)[1] for _ in range(k)]"], [0.9223538041114807, "    counter = Counter(nums)\n    heap = []\n    for num, count in counter.items():\n        heapq.heappush(heap, (count, num))\n        if len(heap) > k:\n            heapq.heappop(heap)\n    return [num for count, num in heap]"], [0.9214645028114319, "    freq_map = defaultdict(int)\n    for num in nums:\n        freq_map[num] += 1\n    min_heap = []\n    for num, freq in freq_map.items():\n        if len(min_heap) < k:\n            heapq.heappush(min_heap, (freq, num))\n        elif freq > min_heap[0][0]:\n            heapq.heappop(min_heap)\n            heapq.heappush(min_heap, (freq, num))\n    result = []\n    while min_heap:\n        result.append(heapq.heappop(min_heap)[1])\n    return result[::-1]"], [0.9212324619293213, "    count = Counter(nums)\n    heap = []\n    for num, freq in count.items():\n        if len(heap) < k:\n            heapq.heappush(heap, (freq, num))\n        elif freq > heap[0][0]:\n            heapq.heapreplace(heap, (freq, num))\n    return [x[1] for x in heap]"], [0.9210920929908752, "    for num, count in counter.items():\n        heapq.heappush(heap, (count, num))\n        if len(heap) > k:\n            heapq.heappop(heap)"], [0.9208821058273315, "    for num, freq in frequency.items():\n        heappush(min_heap, (freq, num))\n        if len(min_heap) > k:\n            heappop(min_heap)"], [0.9205962419509888, "    freq_map = {}\n    for num in nums:\n        freq_map[num] = freq_map.get(num, 0) + 1\n    min_heap = []\n    for num, freq in freq_map.items():\n        heapq.heappush(min_heap, (freq, num))\n        if len(min_heap) > k:\n            heapq.heappop(min_heap)\n    result = []\n    while min_heap:\n        result.append(heapq.heappop(min_heap)[1])\n    result.reverse()\n    return result"], [0.9202529788017273, "        if len(heap) < k:\n            heapq.heappush(heap, (freq, num))\n        elif freq > heap[0][0]:\n            heapq.heapreplace(heap, (freq, num))"], [0.9199120998382568, "    for value, freq in frequency.items():\n        heapq.heappush(heap, (freq, value))\n        if len(heap) > k:\n            heapq.heappop(heap)"]]}
{"task_id": "MBPP/21", "problem": []}
{"task_id": "MBPP/22", "problem": [[0.9260730743408203, "    binary_number = bin(decimal_number).replace('0b', '')\n    return binary_number"], [0.9185986518859863, "    if n > 1:\n        decimalToBinary(n // 2)"], [0.9185972213745117, "    binary_num = bin(decimal_num)\n    binary_num = binary_num[2:]\n    return binary_num"], [0.9184532165527344, "    binary = ''\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal = decimal // 2\n    return binary"], [0.9184191823005676, "    binary = ''\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal = decimal // 2\n    return binary"], [0.9184033870697021, "    binary = bin(decimal)[2:]\n    return binary"], [0.9183006286621094, "    if num > 1:\n        decimal_to_binary(num // 2)"], [0.9178834557533264, "    decimal = 0\n    for digit in binary:\n        decimal = decimal * 2 + int(digit)\n    print('Decimal: ', decimal)\n    binary = input('Enter a binary number: ')\n    binaryConversion(binary)"], [0.9177542924880981, "    binary = []\n    while decimal > 0:\n        binary.append(decimal % 2)\n        decimal = decimal // 2\n    binary.reverse()\n    return binary"], [0.9176636934280396, "    if decimal == 0:\n        return '0'\n    binary = ''\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal = decimal // 2\n    return binary"]]}
{"task_id": "MBPP/23", "problem": [[0.9294337630271912, "    sorted_arr = sorted(arr)\n    curr = sorted_arr[0]\n    for element in sorted_arr[1:]:\n        if element != curr + 1:\n            return curr + 1\n        else:\n            curr = element\n    return missing"], [0.9209897518157959, "    all_nums = set(range(1, arr[-1] + 1))\n    arr_nums = set(arr)\n    missing_number = list(all_nums - arr_nums)[0]\n    return missing_number"]]}
{"task_id": "MBPP/24", "problem": [[0.8968980312347412, "        if triangular_number <= n:\n            count += 1"], [0.8882505893707275, "    count = 0\n    for i in range(n):\n        triangular_number = i * (i + 1) // 2\n        if triangular_number <= n:\n            count += 1\n    return count"], [0.8876500129699707, "        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4"], [0.8876383304595947, "        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4"], [0.8871201872825623, "    index = math.ceil((math.sqrt(8 * math.pow(10, n - 1) + 1) - 1) / 2)\n    triang_num = index * (index + 1) // 2\n    return (index, triang_num)"], [0.8851717710494995, "    for i in range(n):\n        triangular_number = i * (i + 1) // 2\n        if triangular_number <= n:\n            count += 1"], [0.8836828470230103, "    if n == 1:\n        return 1\n    else:\n        return n + triangle_num(n - 1)"], [0.8836828470230103, "    if n == 1:\n        return 1\n    else:\n        return n + triangle_num(n - 1)"], [0.8834736347198486, "        if triangular_num >= start and triangular_num <= end:\n            count += 1"], [0.8827284574508667, "    for square in square_generator(n):\n        square_sum += square"]]}
{"task_id": "MBPP/25", "problem": [[0.8853890895843506, "    if n > 0:\n        return Decimal(fibonacci(n)) / Decimal(fibonacci(n - 1))\n    else:\n        return 0"], [0.8830133676528931, "    getcontext().prec = 1000\n    if n > 0:\n        return Decimal(fibonacci(n)) / Decimal(fibonacci(n - 1))\n    else:\n        return 0"], [0.8794726133346558, "    if a % 2 != 0:\n        if n < 0:\n            return 'Cannot use negative indices with this value of a'\n        elif n == 0:\n            return a\n        elif n == 1:\n            return b\n        elif n == 2:\n            return 1\n    else:\n        if n == 0:\n            return a\n        elif n == 1:\n            return b\n        elif n == 2:\n            return 1\n        if n < 0:\n            if b > 10 and b % 2 == 0:\n                return a + b - n"], [0.8781769871711731, "    if fractional_part > 0:\n        next_digit = int(fractional_part * base)\n        result += str(next_digit)\n        fractional_part -= next_digit / base\n        next_digits = recursive_function(fractional_part, base, precision - 1)\n        result += next_digits"], [0.8781167268753052, "    if a % 2 != 0:\n        if n < 0:\n            return 'Cannot use negative indices with this value of a'\n        if n == 0:\n            return a\n        if n == 1:\n            return b\n        if n == 2:\n            return 1\n    else:\n        if n == 0:\n            return a\n        if n == 1:\n            return b\n        if n == 2:\n            return 1\n        if n < 0:\n            if b > 10 and b % 2 == 0:\n                return a + b - n"], [0.8775906562805176, "    if not isinstance(number, (int, float)) or not isinstance(base, int) or (not isinstance(precision, int)):\n        return 'Invalid input. Please provide a number, base, and precision as integers or floats.'\n    if base <= 0 or precision < 0:\n        return 'Invalid input. Base should be a positive integer and precision should be a non-negative integer.'\n    if precision == 0:\n        return str(round(number))\n    integer_part = int(number)\n    fractional_part = abs(number - integer_part)\n    result = str(integer_part) + '.'\n    if fractional_part > 0:\n        next_digit = int(fractional_part * base)\n        result += str(next_digit)\n        fractional_part -= next_digit / base\n        next_digits = recursive_function(fractional_part, base, precision - 1)\n        result += next_digits\n    return result"], [0.8753545880317688, "        if numerator >= denominator:\n            numerator -= denominator\n            decimal += 1\n        else:\n            break"], [0.874433696269989, "    if not isinstance(n, int):\n        raise ValueError('Input must be an integer.')\n    if n < 0:\n        n = -n\n    least_digit = n % 10\n    print('The least significant digit of', n, 'is', least_digit)\n    return least_digit"], [0.8737269639968872, "    getcontext().prec = n + 1\n    fib_n = calculate_fib_number(n)\n    fib_n1 = calculate_fib_number(n - 1)\n    golden_number = fib_n / fib_n1\n    return round(golden_number, n)"], [0.8736559152603149, "    if n == 0:\n        return count\n    else:\n        return recursive_function(n // 10, count + 1)"]]}
{"task_id": "MBPP/26", "problem": [[0.9319460988044739, "    strings = [element for element in mixed_list if isinstance(element, str)]\n    strings.sort()\n    sorted_list = []\n    i = 0\n    for element in mixed_list:\n        if isinstance(element, str):\n            sorted_list.append(strings[i])\n            i += 1\n        else:\n            sorted_list.append(element)\n    return sorted_list"], [0.9284327030181885, "    int_list = list(filter(lambda x: isinstance(x, int), mixed_list))\n    str_list = list(filter(lambda x: isinstance(x, str), mixed_list))\n    str_list.sort()\n    sorted_list = int_list + str_list\n    return sorted_list"], [0.9248067140579224, "    nums = [num for num in list1 if isinstance(num, int)]\n    strings = [s for s in list1 if isinstance(s, str)]\n    sorted_nums = sorted(nums)\n    sorted_strings = sorted(strings)\n    sorted_list = sorted_nums + sorted_strings\n    return sorted_list"], [0.9202629327774048, "    strings = [item for item in mixed_list if isinstance(item, str)]\n    indices = [index for index, item in enumerate(mixed_list) if isinstance(item, str)]\n    strings.sort()\n    for i, index in enumerate(indices):\n        mixed_list[index] = strings[i]\n    return mixed_list"], [0.9171537160873413, "    for element in mixed_list:\n        if isinstance(element, str):\n            sorted_list.append(strings[i])\n            i += 1\n        else:\n            sorted_list.append(element)"], [0.9168510437011719, "    str_indices = [i for i, x in enumerate(mixed_list) if type(x) == str]\n    str_list = sorted([x for x in mixed_list if type(x) == str])\n    for i, index in enumerate(str_indices):\n        mixed_list[index] = str_list[i]\n    return mixed_list"], [0.9155541658401489, "    str_list = [item for item in mixed_list if isinstance(item, str)]\n    str_list.sort()\n    int_index_list = [i for i, item in enumerate(mixed_list) if isinstance(item, int)]\n    for index, string in zip(int_index_list, str_list):\n        mixed_list.insert(index, string)\n    for i in int_index_list:\n        mixed_list.remove(mixed_list[i + len(int_index_list)])\n    return mixed_list"], [0.9151340126991272, "    numbers = []\n    strings = []\n    for element in arr:\n        if element.isdigit():\n            numbers.append(element)\n        else:\n            strings.append(element)\n    numbers.sort()\n    strings.sort()\n    sorted_arr = numbers + strings\n    return sorted_arr"], [0.9144963026046753, "    integers = []\n    strings = []\n    for element in arr:\n        if isinstance(element, int):\n            integers.append(element)\n        elif isinstance(element, str):\n            if not re.search('[^a-zA-Z]', element):\n                strings.append(element.lower())\n    integers.sort()\n    strings.sort(key=lambda x: len(x))\n    return integers + strings"], [0.9142650365829468, "    string_list = sorted([x for x in mix_list if isinstance(x, str)])\n    non_string_list = [x for x in mix_list if not isinstance(x, str)]\n    return non_string_list + string_list"]]}
{"task_id": "MBPP/27", "problem": [[0.9199866056442261, "    odd_numbers = []\n    even_numbers = []\n    for num in lst:\n        if num % 2 == 0:\n            even_numbers.append(num)\n        else:\n            odd_numbers.append(num)\n    return (odd_numbers, even_numbers)"], [0.9196422100067139, "    even = []\n    odd = []\n    for i in lst:\n        if i % 2 == 0:\n            even.append(i)\n        else:\n            odd.append(i)\n    return (even, odd)"], [0.91841721534729, "    odd_list = []\n    even_list = []\n    for num in l:\n        if num % 2 == 0:\n            even_list.append(num)\n        else:\n            odd_list.append(num)\n    return (even_list, odd_list)"], [0.9171104431152344, "    odd_list = []\n    even_list = []\n    for i in my_list:\n        if i % 2 == 0:\n            even_list.append(i)\n        else:\n            odd_list.append(i)\n    return (odd_list, even_list)"], [0.9167214632034302, "    even = []\n    odd = []\n    for number in arr:\n        if number % 2 == 0:\n            even.append(number)\n        else:\n            odd.append(number)\n    return (even, odd)"], [0.9167214035987854, "    even = []\n    odd = []\n    for number in arr:\n        if number % 2 == 0:\n            even.append(number)\n        else:\n            odd.append(number)\n    return (even, odd)"], [0.9161020517349243, "    even = []\n    odd = []\n    for i in arr:\n        if i % 2 == 0:\n            even.append(i)\n        else:\n            odd.append(i)\n    return (even, odd)"], [0.9157766103744507, "    odd = []\n    even = []\n    for num in arr:\n        if num % 2 == 0:\n            even.append(num)\n        else:\n            odd.append(num)\n    return (odd, even)"], [0.9154547452926636, "    odd = []\n    even = []\n    for x in arr:\n        if x % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n    return (odd, even)"], [0.9148949980735779, "    odd_numbers = []\n    even_numbers = []\n    for num in mylist:\n        if num % 2 == 0:\n            even_numbers.append(num)\n        else:\n            odd_numbers.append(num)\n    return (odd_numbers, even_numbers)"]]}
{"task_id": "MBPP/28", "problem": [[0.9145445823669434, "    is_palindromeable = False\n    for i in range(len(string)):\n        j = len(string) - i - 1\n        if string[i] == string[j]:\n            is_palindromeable = True\n        else:\n            is_palindromeable = False\n            break\n    if is_palindromeable:\n        print('It is possible to rearrange the letters in the string to create a palindrome.')\n    else:\n        print('It is not possible to rearrange the letters in the string to create a palindrome.')"], [0.9033040404319763, "    if is_palindromeable:\n        print('It is possible to rearrange the letters in the string to create a palindrome.')\n    else:\n        print('It is not possible to rearrange the letters in the string to create a palindrome.')"], [0.9031730890274048, "    if all((v % 2 == 0 for v in letter_fre_dict.values())) and all((v >= 2 for v in letter_fre_dict.values())):\n        return not any((s[i] == s[i + 1] for i in range(len(s) - 1)))"], [0.8992611169815063, "    for i in range(len(arr)):\n        s1 = arr[i]\n        for j in range(i + 1, len(arr)):\n            s2 = arr[j]\n            if sorted(s1) != sorted(s2):\n                return False\n    return True"], [0.8989501595497131, "    for i in range(len(arr)):\n        s1 = arr[i]\n        for j in range(i + 1, len(arr)):\n            s2 = arr[j]\n            if sorted(s1) != sorted(s2):\n                return False"], [0.8961955308914185, "    if is_palindrome(s) and can_rearrange_to_palindrome(s):\n        return True\n    return False"], [0.8961407542228699, "    if is_palindrome(s) and can_rearrange_to_palindrome(s):\n        return True"], [0.8958625793457031, "    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            return False\n        letter_count[s[i]] = letter_count.get(s[i], 0) + 1"], [0.8947417140007019, "    is_anagrams = True\n    for i in range(len(a) - 1):\n        if not is_anagram(a[i], a[i + 1]):\n            is_anagrams = False\n            break\n    return is_anagrams"], [0.8943107724189758, "    for i in range(len(str)):\n        for j in range(i + 1, len(str)):\n            if str[i] == str[j]:\n                return False"]]}
{"task_id": "MBPP/29", "problem": [[0.907184898853302, "    freq_dict = {}\n    for item in list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict"], [0.9067159295082092, "    freq = {}\n    for element in lst:\n        if element in freq:\n            freq[element] += 1\n        else:\n            freq[element] = 1\n    return freq"], [0.906667172908783, "    if not input_list:\n        return {}\n    frequency_counter = Counter(input_list)\n    frequency_dict = dict(frequency_counter)\n    return frequency_dict"], [0.9059315919876099, "    frequency_dict = dict(Counter(input_list))\n    return frequency_dict"], [0.9053337574005127, "    frequency_dict = {}\n    for element in lst:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict"], [0.9053122401237488, "    frequency = {}\n    for item in arr:\n        for element in item.values():\n            if element in frequency:\n                frequency[element] += 1\n            else:\n                frequency[element] = 1\n    return frequency"], [0.9048202633857727, "    frequency = {}\n    for item in my_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency"], [0.9026111364364624, "    frequency = {}\n    for i in lst:\n        if i in frequency:\n            frequency[i] += 1\n        else:\n            frequency[i] = 1\n    return frequency"], [0.9017436504364014, "    frequency_dict = {}\n    for sublist in matrix:\n        if isinstance(sublist, list):\n            for item in sublist:\n                if isinstance(item, list):\n                    for subitem in item:\n                        frequency_dict[subitem] = frequency_dict.get(subitem, 0) + 1\n                else:\n                    frequency_dict[item] = frequency_dict.get(item, 0) + 1\n        else:\n            frequency_dict[sublist] = frequency_dict.get(sublist, 0) + 1\n    return frequency_dict"], [0.9016973972320557, "    frequency_dict = {}\n    for sublist in matrix:\n        if isinstance(sublist, list):\n            for item in sublist:\n                if isinstance(item, list):\n                    for subitem in item:\n                        frequency_dict[subitem] = frequency_dict.get(subitem, 0) + 1\n                else:\n                    frequency_dict[item] = frequency_dict.get(item, 0) + 1\n        else:\n            frequency_dict[sublist] = frequency_dict.get(sublist, 0) + 1\n    return frequency_dict"]]}
{"task_id": "MBPP/30", "problem": [[0.9334943294525146, "    even_numbers = filter(lambda num: num % 2 == 0, numbers)\n    return list(even_numbers)"]]}
{"task_id": "MBPP/31", "problem": [[0.9148580431938171, "    unique_elements = set()\n    total_sum = 0\n    for element in arr:\n        if element not in unique_elements:\n            unique_elements.add(element)\n            total_sum += element\n    return total_sum"], [0.9148404598236084, "    unique_elements = set()\n    total_sum = 0\n    for element in arr:\n        if element not in unique_elements:\n            unique_elements.add(element)\n            total_sum += element\n    return total_sum"], [0.9146536588668823, "    arr = sorted(arr)\n    total_sum = sum(arr)\n    print('Sum of elements:', total_sum)\n    count_dict = dict()\n    for i in arr:\n        if i in count_dict:\n            count_dict[i] += 1\n        else:\n            count_dict[i] = 1\n    max_freq = max(count_dict.values())\n    max_freq_nums = sorted([key for key, value in count_dict.items() if value == max_freq])\n    if len(max_freq_nums) > 0:\n        print('Element with highest cumulative frequency:', max_freq_nums)\n    else:\n        print('No repeated elements.')"], [0.9091377854347229, "    for num in array:\n        if array.count(num) == 1:\n            sum += num"], [0.9085156321525574, "    unique_integers = set()\n    total_sum = 0\n    for num in lst:\n        if num not in unique_integers:\n            unique_integers.add(num)\n            total_sum += num\n    return total_sum"], [0.9078803062438965, "    for element in arr:\n        if element not in unique_elements:\n            unique_elements.add(element)\n            total_sum += element"], [0.9078797101974487, "    for element in arr:\n        if element not in unique_elements:\n            unique_elements.add(element)\n            total_sum += element"], [0.9069874882698059, "    unique_elements = set()\n    for element in my_list:\n        unique_elements.add(element)\n    sum_of_elements = 0\n    for unique_element in unique_elements:\n        sum_of_elements += unique_element\n    return sum_of_elements"], [0.9060685634613037, "    for num in arr:\n        if num not in unique_nums:\n            unique_nums.append(num)\n            sum += num"], [0.9060282707214355, "    unique_numbers = set()\n    total_sum = 0\n    for num in lst:\n        if num not in unique_numbers:\n            unique_numbers.add(num)\n            total_sum += num\n    return total_sum"]]}
{"task_id": "MBPP/32", "problem": [[0.8857033252716064, "    pattern = re.compile('a.*Z')\n    return pattern.findall(text)"], [0.8850178718566895, "    pattern = re.compile('[a-z\\\\W].*\\\\d$')\n    matches = pattern.findall(s)\n    return matches"], [0.8826394081115723, "    pattern = '\\\\b\\\\w*[bcdfghjklmnpqrstvwxyz]{3}\\\\w*\\\\b'\n    return re.findall(pattern, text, re.I)"], [0.8821999430656433, "    return re.findall('[A-Z][^A-Z]*', s)"], [0.8819348812103271, "    elif cases['Underscore']:\n        return 'Underscore'"], [0.8815767168998718, "    pattern_ab = '\\\\b(?:[A-Z][^A-Z]*){4}\\\\b'\n    matches_ab = re.findall(pattern_ab, text)\n    pattern_cd = '\\\\b(?:[C][D]){4}\\\\b'\n    matches_cd = re.findall(pattern_cd, text)\n    return matches_ab + matches_cd"], [0.8815728425979614, "    pattern_ab = '\\\\b(?:[A-Z][^A-Z]*){4}\\\\b'\n    matches_ab = re.findall(pattern_ab, text)\n    pattern_cd = '\\\\b(?:[C][D]){4}\\\\b'\n    matches_cd = re.findall(pattern_cd, text)\n    return matches_ab + matches_cd"], [0.8812544345855713, "    pattern = '[a-zA-Z]*a[a-zA-Z]*'\n    result = re.findall(pattern, text)\n    return result"], [0.8812242150306702, "    pattern = '[a-zA-Z]*a[a-zA-Z]*'\n    result = re.findall(pattern, text)\n    return result"], [0.8805678486824036, "    pattern = '\\\\b[aA]\\\\w*\\\\b'\n    matches = re.findall(pattern, text)\n    return matches"]]}
{"task_id": "MBPP/33", "problem": [[0.8953014612197876, "    words = sentence.split()\n    matches = []\n    for word in words:\n        if word[0] == letter:\n            matches.append(word)\n    return matches"], [0.8944974541664124, "    pattern = '^hello people$'\n    result = re.match(pattern, s)\n    if result:\n        return True\n    else:\n        return False"], [0.8930805325508118, "    return word == 'hello'"], [0.8927688002586365, "    return re.search(word, string)"], [0.8909099102020264, "    pattern = re.compile('^phoenix', re.IGNORECASE | re.MULTILINE)\n    matches = pattern.findall(text)\n    if matches:\n        return 'The lexeme \"phoenix\" is found at the inception of a paragraph.'\n    else:\n        return 'The lexeme \"phoenix\" is NOT found at the inception of a paragraph.'"], [0.8894956111907959, "    words = source_string.split()\n    result = []\n    for word in words:\n        if word[0].lower() == letter:\n            result.append(word)\n    return result"], [0.8894665837287903, "    result = []\n    words = string.split(' ')\n    for word in words:\n        if word[0] == letter:\n            result.append(word)\n    return result"], [0.8876655101776123, "    pattern = '\\\\bA\\\\w*\\\\b'\n    words_starting_with_A = re.findall(pattern, text)\n    return words_starting_with_A"], [0.8876148462295532, "    pattern = re.compile('\\\\b(beginning|starting)\\\\b', re.IGNORECASE)\n    return pattern.findall(input_str)"], [0.8871334791183472, "    results = []\n    for word in words:\n        if word.startswith(s):\n            results.append(word)\n    return results"]]}
{"task_id": "MBPP/34", "problem": [[0.9341455698013306, "    num1 = arr[0]\n    num2 = arr[1]\n    gcd = math.gcd(num1, num2)\n    for i in range(2, len(arr)):\n        gcd = math.gcd(gcd, arr[i])\n    return gcd"], [0.9341355562210083, "    num1 = arr[0]\n    num2 = arr[1]\n    gcd = math.gcd(num1, num2)\n    for i in range(2, len(arr)):\n        gcd = math.gcd(gcd, arr[i])\n    return gcd"], [0.9341233968734741, "    num1 = arr[0]\n    num2 = arr[1]\n    gcd = math.gcd(num1, num2)\n    for i in range(2, len(arr)):\n        gcd = math.gcd(gcd, arr[i])\n    return gcd"], [0.9319241642951965, "    num1 = arr[0]\n    for i in range(1, len(arr)):\n        num1 = gcd(num1, arr[i])\n    return num1"], [0.9314443469047546, "    num1 = arr[0]\n    num2 = arr[1]\n    hcf = math.gcd(num1, num2)\n    for i in range(2, len(arr)):\n        hcf = math.gcd(hcf, arr[i])\n    return hcf"], [0.9295242428779602, "    result = arr[0]\n    for i in arr[1:]:\n        result = gcd(result, i)\n    return result"], [0.9263591170310974, "    arr_len = len(nums)\n    if arr_len == 1:\n        return nums[0]\n    else:\n        g = gcd(nums[0], nums[1])\n        for i in range(2, arr_len):\n            g = gcd(g, nums[i])\n    return g"], [0.9228516817092896, "    for i in range(len(arr)):\n        gcd_val = gcd(gcd_val, arr[i])"], [0.9225709438323975, "    result = arr[0]\n    for i in range(1, len(arr)):\n        result = gcd_recursion(result, arr[i])\n    return result"], [0.9220433235168457, "    if len(array) == 0:\n        return 'Array is empty'\n    if len(array) == 1:\n        return abs(array[0])\n    result = abs(array[0])\n    for i in range(1, len(array)):\n        result = gcd(result, abs(array[i]))\n    return result"]]}
{"task_id": "MBPP/35", "problem": [[0.9132770299911499, "    for i in range(len(my_list)):\n        for j in range(i + 1, len(my_list)):\n            if my_list[i] != my_list[j]:\n                return False\n    return True"], [0.9117287993431091, "    unique_numbers = set(numbers)\n    if len(numbers) == len(unique_numbers):\n        return True\n    else:\n        return False"], [0.9105596542358398, "    first_elem = arr[0]\n    is_equal = True\n    for elem in arr:\n        if elem != first_elem:\n            is_equal = False\n            break\n    return is_equal"], [0.9089961051940918, "    if len(numbers) == len(unique_numbers):\n        return True\n    else:\n        return False"], [0.9070613384246826, "    if len(numbers) == len(set(numbers)):\n        return True\n    else:\n        return False"], [0.9070613384246826, "    if len(numbers) == len(set(numbers)):\n        return True\n    else:\n        return False"], [0.9064140319824219, "    for i in range(len(my_list)):\n        for j in range(i + 1, len(my_list)):\n            if my_list[i] != my_list[j]:\n                return False"], [0.9052616357803345, "    return len(num_list) == len(set(num_list))"], [0.9049234390258789, "    elif all((x == arr[0] for x in arr)):\n        return True\n    else:\n        return False"], [0.9042202234268188, "    unique_list = []\n    for i in my_list:\n        if i not in unique_list:\n            unique_list.append(i)\n    if len(unique_list) == len(my_list):\n        return True\n    else:\n        return False"]]}
{"task_id": "MBPP/36", "problem": [[0.896355390548706, "    last_digit_a = abs(a) % 10\n    last_digit_b = abs(b) % 10\n    return last_digit_a * last_digit_b"], [0.8955261707305908, "    if b == 0:\n        return a\n    else:\n        return divisor_function(b, a % b)"], [0.8955261707305908, "    if b == 0:\n        return a\n    else:\n        return divisor_function(b, a % b)"], [0.8927644491195679, "    if b == 0:\n        return 'Cannot divide by zero'\n    result = 0\n    power = 1\n    while a >= b:\n        divisor = b\n        power_of_2 = 1\n        while divisor << 1 <= a:\n            divisor <<= 1\n            power_of_2 <<= 1\n        a -= divisor\n        result += power_of_2\n    return a"], [0.8921276330947876, "    return last_ten_digits(a * b)"], [0.8912484645843506, "    if not b % a:\n        return 0"], [0.8901526927947998, "    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n        while factorial % 10 == 0:\n            factorial //= 10\n        factorial %= 1000000000\n    return factorial % 10"], [0.8901399374008179, "    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n        while factorial % 10 == 0:\n            factorial //= 10\n        factorial %= 1000000000\n    return factorial % 10"], [0.8894123435020447, "    if a > b:\n        return findGCD(a - b, b)"], [0.8885712027549744, "    if a > b:\n        return gcf(a - b, b)"]]}
{"task_id": "MBPP/37", "problem": [[0.8925512433052063, "    odd_set = set()\n    for num in lst:\n        if num % 2 != 0:\n            odd_set.add(num)\n    return list(odd_set)"], [0.892090380191803, "    odd_nums = [num for num in arr if num % 2 == 1]\n    return odd_nums"], [0.8915214538574219, "    odd_nums = []\n    for num in nums:\n        if num % 2 != 0:\n            odd_nums.append(num)\n    return odd_nums"], [0.8896796703338623, "    odd_arr = []\n    for num in arr:\n        if num % 2 != 0:\n            odd_arr.append(num)\n    return odd_arr"], [0.8893517255783081, "    odd_arr = []\n    for num in arr:\n        if num % 2 == 1:\n            odd_arr.append(num)\n    return odd_arr"], [0.8893333673477173, "    odd_list = []\n    for number in original_list:\n        if number % 2 != 0:\n            odd_list.append(number)\n    return odd_list"], [0.8886145949363708, "    oddNums = []\n    for num in nums:\n        if num % 2 == 1:\n            oddNums.append(num)\n    return oddNums"], [0.8876538276672363, "    odds = []\n    for num in arr:\n        if num % 2 != 0:\n            odds.append(num)\n    return odds"], [0.8876150250434875, "    odd_nums = []\n    for i in arr:\n        if i % 2 != 0:\n            odd_nums.append(i)\n    return odd_nums"], [0.8871062994003296, "    odd_nums = []\n    for num in numbers:\n        if num % 2 == 1:\n            odd_nums.append(num)\n    return odd_nums"]]}
{"task_id": "MBPP/38", "problem": [[0.8894197940826416, "    output_list = []\n    for element in input_list:\n        try:\n            output_list.append(element[index])\n        except IndexError:\n            output_list.append('')\n    return output_list"], [0.8890827298164368, "    for element in input_list:\n        try:\n            output_list.append(element[index])\n        except IndexError:\n            output_list.append('')"], [0.8844093680381775, "    if len(my_list) < n:\n        return 'Error: List contains less than n elements'\n    elif isinstance(my_list[0], list):\n        return [x[2] for x in my_list if len(x) >= 3]\n    else:\n        return my_list[2]"], [0.8844093680381775, "    if len(my_list) < n:\n        return 'Error: List contains less than n elements'\n    elif isinstance(my_list[0], list):\n        return [x[2] for x in my_list if len(x) >= 3]\n    else:\n        return my_list[2]"], [0.8810790777206421, "    extracted_elements = []\n    for i in range(3):\n        extracted_elements.append(lst[i])\n    return extracted_elements"], [0.8807437419891357, "    for sublist in input_list:\n        if len(sublist) >= 1:\n            first_list.append(sublist[0])\n            if len(sublist) >= 2:\n                second_list.append(sublist[1])"], [0.8793918490409851, "    first_list = []\n    second_list = []\n    for sublist in input_list:\n        if len(sublist) >= 1:\n            first_list.append(sublist[0])\n            if len(sublist) >= 2:\n                second_list.append(sublist[1])\n    return [first_list, second_list]"], [0.8777686357498169, "    column_index = t[1]\n    column_values = [row[column_index] for row in grid]\n    return column_values"], [0.8760937452316284, "                if all((elem == first for elem in sub_list)):\n                    result.append(first)\n                else:\n                    result.append(None)"], [0.8752939701080322, "    getter = itemgetter(*indices)\n    items = list(getter(items_all))\n    return items"]]}
{"task_id": "MBPP/39", "problem": [[0.9017757177352905, "    min_value = min(list1)\n    return min_value"], [0.893377423286438, "    shortest_words = []\n    min_length = len(words_list[0])\n    for word in words_list:\n        if len(word) < min_length:\n            min_length = len(word)\n            shortest_words = [word]\n        elif len(word) == min_length:\n            shortest_words.append(word)\n    return shortest_words"], [0.8909814953804016, "    shortest = input_list[0]\n    for word in input_list:\n        if len(word) < len(shortest):\n            shortest = word\n    return shortest"], [0.8880941867828369, "    min_length = min((len(city) for city in cities))\n    shortest_cities = [city for city in cities if len(city) == min_length]\n    return shortest_cities"], [0.8876590728759766, "    min_length = len(strings[0])\n    shortest_string = strings[0]\n    for string in strings[1:]:\n        if len(string) < min_length:\n            min_length = len(string)\n            shortest_string = string\n    return shortest_string"], [0.8866062164306641, "    min_val = list[0]\n    for num in list:\n        if num < min_val:\n            min_val = num\n    return min_val"], [0.8866005539894104, "    min_val = list[0]\n    for num in list:\n        if num < min_val:\n            min_val = num\n    return min_val"], [0.8856693506240845, "    input_list = list(set(input_list))\n    return find_min(input_list)"], [0.8853512406349182, "    if len(lst) == 1:\n        return lst[0]\n    else:\n        return min(lst[0], find_minimum(lst[1:]))"], [0.8853512406349182, "    if len(lst) == 1:\n        return lst[0]\n    else:\n        return min(lst[0], find_minimum(lst[1:]))"]]}
{"task_id": "MBPP/40", "problem": [[0.9217349886894226, "    if side1 == side2 == side3:\n        print('Equilateral triangle')\n        return"], [0.9198529720306396, "    if a == b and b == c:\n        return 'Equilateral triangle'"], [0.9183226227760315, "    if a == b == c:\n        return 'Equilateral triangle'"], [0.9124480485916138, "        if a == b == c and a != 0:\n            return 'Equilateral'"], [0.912250280380249, "    if a == b == c:\n        triangle_type = 'Equilateral'\n    elif a != b and b != c and (a != c):\n        triangle_type = 'Scalene'\n    else:\n        triangle_type = 'Isosceles'"], [0.9073838591575623, "        if a == b == c:\n            triangle_type = 'Equilateral'\n        elif a == b or b == c or c == a:\n            triangle_type = 'Isosceles'\n        else:\n            triangle_type = 'Scalene'"], [0.9073770046234131, "        if a == b == c:\n            triangle_type = 'Equilateral'\n        elif a == b or b == c or c == a:\n            triangle_type = 'Isosceles'\n        else:\n            triangle_type = 'Scalene'"], [0.9058823585510254, "    if a == b and b == c:\n        return 'Equilateral triangle'\n    elif a == b or b == c or a == c:\n        return 'Isosceles triangle'\n    else:\n        return 'Scalene triangle'"], [0.9053143262863159, "    if A == B and B == C:\n        return 'Equilateral Triangle'\n    elif A == B or B == C or A == C:\n        return 'Isosceles Triangle'\n    else:\n        return 'Scalene Triangle'"], [0.9053143262863159, "    if A == B and B == C:\n        return 'Equilateral Triangle'\n    elif A == B or B == C or A == C:\n        return 'Isosceles Triangle'\n    else:\n        return 'Scalene Triangle'"]]}
{"task_id": "MBPP/41", "problem": [[0.9049040675163269, "    areas = []\n    for p in parallelograms:\n        angle_in_radians = math.radians(p[2])\n        area = p[0] * p[1] * math.sin(angle_in_radians)\n        areas.append(area)\n    return areas"], [0.9048106670379639, "    assert calculate_area(6, 4) == 12\n    assert calculate_area(6, 4, shape='parallelogram') == 24"], [0.9044114351272583, "    if x <= 0 or y <= 0 or x >= y or (angle <= 0) or (angle >= 180):\n        raise ValueError('Invalid parameters for a parallelogram')\n    return x * y * math.sin(math.radians(angle))"], [0.8989388942718506, "    for p in parallelograms:\n        angle_in_radians = math.radians(p[2])\n        area = p[0] * p[1] * math.sin(angle_in_radians)\n        areas.append(area)"], [0.8930141925811768, "    area = length * width\n    return area"], [0.8930042386054993, "    area = length * width\n    return area"], [0.892493486404419, "    area = 0.5 * side_a * side_b\n    return area"]]}
{"task_id": "MBPP/42", "problem": [[0.922330379486084, "    if len(string) < 2:\n        return False\n    return string[0] == string[-1]"], [0.9089089035987854, "    output_list = []\n    for string in input_list:\n        if string[0] == string[-1]:\n            output_list.append(string)\n    return output_list"], [0.9089089035987854, "    output_list = []\n    for string in input_list:\n        if string[0] == string[-1]:\n            output_list.append(string)\n    return output_list"], [0.9061794877052307, "    word_list = my_string.split()\n    for word in word_list:\n        if word[0] != word[-1]:\n            return False\n    return True"], [0.903364360332489, "    my_string = ''.join((char for char in input_str if char not in string.punctuation))\n    words = my_string.split()\n    count = 0\n    for word in words:\n        if word[0].lower() == word[-1].lower():\n            count += 1\n    return (count == len(words), count)"], [0.9027965068817139, "    for string in input_list:\n        if string[0] == string[-1]:\n            output_list.append(string)"], [0.9027780294418335, "    for string in input_list:\n        if string[0] == string[-1]:\n            output_list.append(string)"], [0.9016807675361633, "    elif str[0] == str[-1]:\n        return isAnagram(str[1:-1])\n    else:\n        return False"], [0.900642454624176, "    elif word[0] == word[-1]:\n        return palindrome_check(word[1:-1])\n    else:\n        return False"], [0.9006321430206299, "    elif word[0] == word[-1]:\n        return palindrome_check(word[1:-1])\n    else:\n        return False"]]}
{"task_id": "MBPP/43", "problem": []}
{"task_id": "MBPP/44", "problem": [[0.9034754037857056, "        for i in range(n):\n            term = a * r ** i\n            print(term)"], [0.9034656286239624, "        for i in range(n):\n            term = a * r ** i\n            print(term)"], [0.9023756384849548, "    geometric_sequence = [first_term]\n    for _ in range(1, total_terms):\n        next_term = geometric_sequence[-1] * common_ratio\n        geometric_sequence.append(next_term)\n    return geometric_sequence"], [0.9023408889770508, "    geometric_sequence = [first_term]\n    for _ in range(1, total_terms):\n        next_term = geometric_sequence[-1] * common_ratio\n        geometric_sequence.append(next_term)\n    return geometric_sequence"], [0.8968919515609741, "    for _ in range(1, total_terms):\n        next_term = geometric_sequence[-1] * common_ratio\n        geometric_sequence.append(next_term)"], [0.8968838453292847, "    for _ in range(1, total_terms):\n        next_term = geometric_sequence[-1] * common_ratio\n        geometric_sequence.append(next_term)"], [0.8851804733276367, "    sum = a * (1 - r ** n) / (1 - r)\n    if 300 <= sum <= 1200:\n        print(f'Sum of geometric progression: {sum}.')\n        print('Terms of geometric progression:')\n        for i in range(n):\n            term = a * r ** i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of geometric progression is not within valid range, but {sum}.')"], [0.8849542737007141, "    sum = a * (1 - r ** n) / (1 - r)\n    if 300 <= sum <= 1200:\n        print(f'The sum of the geometric progression is: {sum}.')\n        print('Terms of the geometric progression:')\n        for i in range(n):\n            term = a * r ** i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of the geometric progression is not within the valid range, but {sum}.')"], [0.8837755918502808, "    total_sum = 0\n    for i in range(n):\n        total_sum += a * r ** i\n    return total_sum"], [0.8836991786956787, "    gp = [a]\n    for i in range(1, n):\n        gp.append(gp[-1] * r)\n    return gp"]]}
{"task_id": "MBPP/45", "problem": [[0.9209355115890503, "    if num == reverse:\n        return True\n    else:\n        return False"], [0.9153075218200684, "    if rev == num:\n        return True\n    else:\n        return False"], [0.9153075218200684, "    if rev == num:\n        return True\n    else:\n        return False"], [0.915286123752594, "    if rev == num:\n        return True\n    else:\n        return False"], [0.9152277708053589, "    temp = num\n    rev = 0\n    while temp > 0:\n        rev = rev * 10 + temp % 10\n        temp = temp // 10\n    if rev == num:\n        return True\n    else:\n        return False"], [0.91518235206604, "    if num == rev:\n        return True\n    else:\n        return False"], [0.9151732921600342, "    if num == rev:\n        return True\n    else:\n        return False"], [0.9149579405784607, "    rev = n[::-1]\n    return n == rev"], [0.9147549867630005, "    x = n\n    rev = 0\n    while x > 0:\n        dig = x % 10\n        rev = rev * 10 + dig\n        x = x // 10\n    if n == rev:\n        return True\n    else:\n        return False"], [0.9147495031356812, "    temp = num\n    rev = 0\n    while temp > 0:\n        rev = rev * 10 + temp % 10\n        temp = temp // 10\n    if num == rev:\n        return True\n    else:\n        return False"]]}
{"task_id": "MBPP/46", "problem": [[0.9051604866981506, "    for i in digits:\n        largest = largest * 10 + i"], [0.8984189033508301, "    largest_number = ''\n    for number in arr:\n        largest_number += str(number)\n    return int(largest_number)"]]}
{"task_id": "MBPP/47", "problem": [[0.9036495089530945, "    if abs(x) == abs(y):\n        return True\n    else:\n        return False"], [0.9036495089530945, "    if abs(x) == abs(y):\n        return True\n    else:\n        return False"], [0.8956394791603088, "    if num1 ^ num2 >= 0:\n        if abs_num1 > abs_num2:\n            return 1\n        elif abs_num1 < abs_num2:\n            return -1\n        else:\n            return 0\n    elif num1 < 0:\n        return 1\n    else:\n        return -1"], [0.8952537775039673, "    elif num1 < 0:\n        return 1\n    else:\n        return -1"], [0.8936898708343506, "    abs_num1 = abs(num1)\n    abs_num2 = abs(num2)\n    if num1 ^ num2 >= 0:\n        if abs_num1 > abs_num2:\n            return 1\n        elif abs_num1 < abs_num2:\n            return -1\n        else:\n            return 0\n    elif num1 < 0:\n        return 1\n    else:\n        return -1"], [0.8887724876403809, "    if num1 < 0 or num2 < 0:\n        raise ValueError('Input numbers cannot be negative.')\n    if num1 % 2 == 0 and num2 % 2 != 0:\n        return True\n    else:\n        return False"], [0.8846558332443237, "        if num1 > num2:\n            return '1'\n        elif num1 < num2:\n            return '-1'"], [0.8844513297080994, "    return (x >= 0) == (y >= 0)"], [0.8844330310821533, "    return (x >= 0) == (y >= 0)"], [0.8839975595474243, "    diff = a - b\n    if diff == 0:\n        return True\n    else:\n        return False"]]}
{"task_id": "MBPP/48", "problem": [[0.9015012979507446, "        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4"], [0.9014909267425537, "        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4"], [0.8902581930160522, "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"], [0.8902581930160522, "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"], [0.890254020690918, "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"], [0.890254020690918, "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"], [0.8891839385032654, "    if n in memory:\n        return memory[n]\n    if n < 1 or n > 1000 or (not isinstance(n, int)):\n        return 'Invalid input'\n    elif n == 1:\n        return 1\n    else:\n        memory[n] = n * (7 * n - 5) // 2\n        return nonagonal(n - 1, memory)"], [0.8891648054122925, "    if n in memory:\n        return memory[n]\n    if n < 1 or n > 1000 or (not isinstance(n, int)):\n        return 'Invalid input'\n    elif n == 1:\n        return 1\n    else:\n        memory[n] = n * (7 * n - 5) // 2\n        return nonagonal(n - 1, memory)"], [0.8886972069740295, "    if type(n) != int or n < 0:\n        return 'ERROR: Invalid Input'\n    if n > 5000:\n        return 'ERROR: Input number too large'\n    if n in computed:\n        return computed[n]\n    computed[n] = n * (5 * n - 3) / 2 + heptagonal(n - 1)\n    return computed[n]"], [0.8886882066726685, "    if n < 1 or n > 1000 or (not isinstance(n, int)):\n        return 'Invalid input'\n    elif n == 1:\n        return 1\n    else:\n        memory[n] = n * (7 * n - 5) // 2\n        return nonagonal(n - 1, memory)"]]}
{"task_id": "MBPP/49", "problem": [[0.9034944772720337, "    dp = {}\n    maxLength = 0\n    for num in arr:\n        dp[num] = dp.get(num - difference, 0) + 1\n        maxLength = max(maxLength, dp[num])\n    return maxLength"], [0.9034719467163086, "    dp = {}\n    maxLength = 0\n    for num in arr:\n        dp[num] = dp.get(num - difference, 0) + 1\n        maxLength = max(maxLength, dp[num])\n    return maxLength"], [0.9019003510475159, "    arr = sorted(arr)\n    max_length = 1\n    length = 1\n    for i in range(len(arr) - 1):\n        if arr[i] + 1 == arr[i + 1]:\n            length = length + 1\n        else:\n            if length > max_length:\n                max_length = length\n            length = 1\n    return max_length"], [0.9007587432861328, "    max_length = 0\n    length = 0\n    for i in range(len(arr) - 1):\n        if arr[i + 1] == arr[i] + 1:\n            length += 1\n        else:\n            max_length = max(max_length, length)\n            length = 0\n    return max(max_length, length) + 1"], [0.9002622365951538, "    max_length = 0\n    cur_length = 1\n    for i in range(len(arr) - 1):\n        if arr[i] + 1 == arr[i + 1]:\n            cur_length += 1\n        else:\n            if cur_length > max_length:\n                max_length = cur_length\n            cur_length = 1\n    if cur_length > max_length:\n        max_length = cur_length\n    return max_length"], [0.8999264240264893, "    max_length = 0\n    start_index = 0\n    while start_index < len(arr) - 1 and arr[start_index] + 1 == arr[start_index + 1]:\n        start_index += 1\n    for i in range(start_index + 1, len(arr)):\n        prev = arr[i - 1]\n        curr = arr[i]\n        if prev + 1 == curr:\n            length = i - start_index + 1\n            if length > max_length:\n                max_length = length\n        else:\n            start_index = i\n    return max_length"], [0.8992247581481934, "    for i in range(len(arr) - 1):\n        if arr[i + 1] == arr[i] + 1:\n            length += 1\n        else:\n            max_length = max(max_length, length)\n            length = 0"], [0.8988118171691895, "    max_diff = 0\n    for i in range(0, len(arr) - 1):\n        diff = arr[i + 1] - arr[i]\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff"], [0.8984203338623047, "    cur_length = 1\n    max_length = 1\n    for i in range(1, len(arr)):\n        if arr[i] - 1 == arr[i - 1]:\n            cur_length += 1\n        else:\n            if cur_length > max_length:\n                max_length = cur_length\n            cur_length = 1\n    if cur_length > max_length:\n        max_length = cur_length\n    return max_length"], [0.8977590799331665, "        if arr[i + 1] == arr[i] + 1:\n            length += 1\n        else:\n            max_length = max(max_length, length)\n            length = 0"]]}
{"task_id": "MBPP/50", "problem": [[0.8965426087379456, "    count = 0\n    for num in range(start, end + 1):\n        count += str(num).count(str(digit))\n    return count"]]}
{"task_id": "MBPP/51", "problem": [[0.9316339492797852, "    smallest_number = num_list[0]\n    for num in num_list:\n        if num < smallest_number:\n            smallest_number = num\n    return smallest_number"], [0.931399941444397, "    smallest = list[0]\n    i = 1\n    while i < len(list):\n        if list[i] < smallest:\n            smallest = list[i]\n        i += 1\n    return smallest"], [0.9273426532745361, "    smallest = lst[0]\n    for number in lst:\n        if number < smallest:\n            smallest = number\n    return smallest"], [0.9261994361877441, "    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest"], [0.9243289828300476, "    smallest = givenList[0]\n    for num in givenList[1:]:\n        if num < smallest:\n            smallest = num\n    return smallest"], [0.9239944219589233, "    smallest_number = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < smallest_number:\n            smallest_number = arr[i]\n    return smallest_number"], [0.9239901900291443, "    smallest_number = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < smallest_number:\n            smallest_number = arr[i]\n    return smallest_number"], [0.9229352474212646, "    smallest = float('inf')\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest"], [0.9228798747062683, "    n = len(arr)\n    smallest = arr[0]\n    for i in range(1, n):\n        if arr[i] < smallest:\n            smallest = arr[i]\n    return smallest"], [0.9226624369621277, "    smallest = arr[0]\n    for num in arr:\n        smallest = min(smallest, num)\n    return smallest"]]}
{"task_id": "MBPP/52", "problem": [[0.906682550907135, "    maxDifference = 0\n    for i in range(len(elementList)):\n        for j in range(i + 1, len(elementList)):\n            if elementList[j] - elementList[i] > maxDifference:\n                maxDifference = elementList[j] - elementList[i]\n    return maxDifference"], [0.9037089347839355, "    maxDifference = 0\n    maxDifferencePair = ()\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            difference = abs(arr[i] - arr[j])\n            if difference > maxDifference:\n                maxDifference = difference\n                maxDifferencePair = (arr[i], arr[j])\n    return maxDifferencePair"], [0.8991773128509521, "    max_difference = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] - arr[i] > max_difference:\n                max_difference = arr[j] - arr[i]\n    return max_difference"], [0.8981812000274658, "    if not arr:\n        return\n    min_el = arr[0]\n    max_diff = arr[1] - arr[0]\n    pair = (arr[0], arr[1])\n    for i in range(1, len(arr)):\n        if arr[i] < min_el:\n            min_el = arr[i]\n        elif arr[i] - min_el > max_diff:\n            max_diff = arr[i] - min_el\n            pair = (min_el, arr[i])\n    return (max_diff, pair)"], [0.8950934410095215, "    for i in range(len(elementList)):\n        for j in range(i + 1, len(elementList)):\n            if elementList[j] - elementList[i] > maxDifference:\n                maxDifference = elementList[j] - elementList[i]"]]}
{"task_id": "MBPP/53", "problem": [[0.9126307368278503, "    sorted_list = sorted(tuples, key=lambda x: x[1])\n    return sorted_list"], [0.9110075831413269, "    sorted_list = sorted(tuples, key=lambda tup: tup[1])\n    return sorted_list"], [0.906570553779602, "    sorted_list = sorted(tuples_list, key=lambda x: x[0])\n    return sorted_list"]]}
{"task_id": "MBPP/54", "problem": []}
{"task_id": "MBPP/55", "problem": [[0.9301419258117676, "    positive_numbers = 0\n    for num in input_numbers:\n        if num > 0:\n            positive_numbers += 1\n    return positive_numbers"], [0.9274849891662598, "    count = 0\n    for num in nums:\n        if num > 0:\n            count += 1\n    print('Number of positive numbers:', count)"], [0.9153268337249756, "    count = 0\n    for num in numbers:\n        if num > 0:\n            count += 1\n    return count"], [0.9085139632225037, "    result = 0\n    for num in numbers:\n        if num > 0:\n            result += 1\n    return result"], [0.9078720808029175, "    positive_integers = []\n    for num in input_list:\n        if num > 0:\n            positive_integers.append(num)\n    return positive_integers"], [0.907593309879303, "    count = 0\n    for i in arr:\n        if i > 0:\n            count += 1\n    return count"], [0.9057207107543945, "    for num in numbers:\n        if num > 0:\n            count += 1"], [0.9056857824325562, "    for num in input_list:\n        if num > 0:\n            positive_list.append(num)"], [0.9054811000823975, "    positive_nums = []\n    for n in lst:\n        if n > 0:\n            positive_nums.append(n)\n    return positive_nums"], [0.9047286510467529, "    input_list = [1, -2, 3, -4, 5]\n    expected_output = [1, 3, 5]\n    assert positive(input_list) == expected_output"]]}
{"task_id": "MBPP/56", "problem": [[0.888710618019104, "    for j in range(1, i + 1):\n        bell_matrix[i][j] = bell_matrix[i - 1][j - 1] + bell_matrix[i][j - 1]"], [0.888710618019104, "    for j in range(1, i + 1):\n        bell_matrix[i][j] = bell_matrix[i - 1][j - 1] + bell_matrix[i][j - 1]"], [0.8870828747749329, "    for i in range(1, n + 1):\n        bell_matrix[i][0] = bell_matrix[i - 1][i - 1]"], [0.8870828747749329, "    for i in range(1, n + 1):\n        bell_matrix[i][0] = bell_matrix[i - 1][i - 1]"], [0.886833667755127, "        for j in range(1, i + 1):\n            bell_matrix[i][j] = bell_matrix[i - 1][j - 1] + bell_matrix[i][j - 1]"], [0.886833667755127, "        for j in range(1, i + 1):\n            bell_matrix[i][j] = bell_matrix[i - 1][j - 1] + bell_matrix[i][j - 1]"], [0.8846511244773865, "        for j in range(1, i + 1):\n            Bell[i][j] = Bell[i - 1][j] + Bell[i][j - 1]"], [0.8846511244773865, "        for j in range(1, i + 1):\n            Bell[i][j] = Bell[i - 1][j] + Bell[i][j - 1]"], [0.8834362030029297, "        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]"], [0.8834362030029297, "        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]"]]}
{"task_id": "MBPP/57", "problem": [[0.9142146110534668, "    is_monotonic = True\n    for i in range(len(list) - 1):\n        if list[i] > list[i + 1]:\n            is_monotonic = False\n    return is_monotonic"], [0.9073672294616699, "    for i in range(len(list) - 1):\n        if list[i] > list[i + 1]:\n            is_monotonic = False"], [0.9044870138168335, "    try:\n        is_nested = any((isinstance(i, list) for i in l))\n    except TypeError:\n        print('Input value is not iterable')\n        return False\n    if is_nested:\n        return all((monotonic(sub_list, strict) for sub_list in l))\n    elif strict:\n        return all((i < j for i, j in zip(l, l[1:]))) or all((i > j for i, j in zip(l, l[1:])))\n    else:\n        return all((i <= j for i, j in zip(l, l[1:]))) or all((i >= j for i, j in zip(l, l[1:])))"], [0.9023445844650269, "    length = len(array)\n    if length <= 1:\n        return True\n    difference = array[length - 1] - array[0]\n    if difference >= 0:\n        is_ascending = True\n    else:\n        is_ascending = False\n    for i in range(1, length):\n        difference = array[i] - array[i - 1]\n        if difference > 0 and (not is_ascending) or (difference < 0 and is_ascending):\n            return False\n    return True"], [0.8974828720092773, "    status = False\n    check = arr[0]\n    for i in range(1, len(arr)):\n        if check < arr[i]:\n            check = arr[i]\n            status = True\n        else:\n            status = False\n            break\n    return status"], [0.8939199447631836, "        if list[i] > list[i + 1]:\n            is_monotonic = False"], [0.8931002616882324, "    if is_nested:\n        return all((monotonic(sub_list, strict) for sub_list in l))\n    elif strict:\n        return all((i < j for i, j in zip(l, l[1:]))) or all((i > j for i, j in zip(l, l[1:])))\n    else:\n        return all((i <= j for i, j in zip(l, l[1:]))) or all((i >= j for i, j in zip(l, l[1:])))"], [0.8929349184036255, "    n = len(arr)\n    if all((arr[i] <= arr[i + 1] for i in range(n - 1))):\n        return True\n    else:\n        return False"], [0.8897340297698975, "    if not arr:\n        return True\n    prev_el = arr[0]\n    for el in arr[1:]:\n        if el < prev_el:\n            return False\n        prev_el = el\n    return True"], [0.889224112033844, "    n = len(arr)\n    for i in range(1, n):\n        if arr[i] < arr[i - 1]:\n            return False\n    return True"]]}
{"task_id": "MBPP/58", "problem": [[0.9234124422073364, "    if isinstance(sublist, list):\n        if sublist == []:\n            return True\n        elif sublist == main_list:\n            return True\n        elif len(sublist) > len(main_list):\n            return False\n        else:\n            for i in range(len(main_list)):\n                if main_list[i] == sublist[0]:\n                    return is_sublist(main_list[i + 1:], sublist[1:])\n            return False\n    else:\n        return sublist in main_list"], [0.9234124422073364, "    if isinstance(sublist, list):\n        if sublist == []:\n            return True\n        elif sublist == main_list:\n            return True\n        elif len(sublist) > len(main_list):\n            return False\n        else:\n            for i in range(len(main_list)):\n                if main_list[i] == sublist[0]:\n                    return is_sublist(main_list[i + 1:], sublist[1:])\n            return False\n    else:\n        return sublist in main_list"], [0.9215701818466187, "        if sublist == []:\n            return True\n        elif sublist == main_list:\n            return True\n        elif len(sublist) > len(main_list):\n            return False\n        else:\n            for i in range(len(main_list)):\n                if main_list[i] == sublist[0]:\n                    return is_sublist(main_list[i + 1:], sublist[1:])\n            return False"], [0.9211695194244385, "    for i in range(len(lst1) - len(sublst) + 1):\n        if lst1[i:i + len(sublst)] == sublst:\n            return True\n    return False"], [0.9197482466697693, "    for i in range(len(lst1) - len(sublst) + 1):\n        if lst1[i:i + len(sublst)] == sublst:\n            return True"], [0.9197253584861755, "        elif sublist == main_list:\n            return True\n        elif len(sublist) > len(main_list):\n            return False\n        else:\n            for i in range(len(main_list)):\n                if main_list[i] == sublist[0]:\n                    return is_sublist(main_list[i + 1:], sublist[1:])\n            return False"], [0.9197019338607788, "    i, j = (0, 0)\n    n1, n2 = (len(sub_list), len(main_list))\n    while i < n1 and j < n2:\n        if sub_list[i] == main_list[j]:\n            i += 1\n        j += 1\n    return i == n1"], [0.9195061922073364, "    str_lst = ''.join(map(str, lst))\n    str_sublist = ''.join(map(str, sublist))\n    return str_sublist in str_lst"], [0.9163451790809631, "                if main_list[i] == sublist[0]:\n                    return is_sublist(main_list[i + 1:], sublist[1:])"], [0.9150938391685486, "        elif len(sublist) > len(main_list):\n            return False\n        else:\n            for i in range(len(main_list)):\n                if main_list[i] == sublist[0]:\n                    return is_sublist(main_list[i + 1:], sublist[1:])\n            return False"]]}
{"task_id": "MBPP/59", "problem": [[0.9101132154464722, "    len_first = len(lst[0])\n    return all((len(x) == len_first for x in lst))"], [0.9057382941246033, "    if not list_of_strings:\n        print('The list is empty.')\n    else:\n        string_length = len(list_of_strings[0])\n        all_equal_length = all((len(string) == string_length for string in list_of_strings))\n        if all_equal_length:\n            print('All strings in the list are of equal length.')\n        else:\n            print('Not all strings in the list are of equal length.')"], [0.9057382941246033, "    if not list_of_strings:\n        print('The list is empty.')\n    else:\n        string_length = len(list_of_strings[0])\n        all_equal_length = all((len(string) == string_length for string in list_of_strings))\n        if all_equal_length:\n            print('All strings in the list are of equal length.')\n        else:\n            print('Not all strings in the list are of equal length.')"], [0.9036808013916016, "    length = len(arr[0])\n    for n in arr:\n        if len(n) != length:\n            return False\n    return True"], [0.9035951495170593, "    string_length = len(string_list[0])\n    for string in string_list:\n        if len(string) != string_length:\n            return False\n    return True"], [0.9022980332374573, "        if all_equal_length:\n            print('All strings in the list are of equal length.')\n        else:\n            print('Not all strings in the list are of equal length.')"], [0.8978866934776306, "    if not lst:\n        return True\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True"], [0.8960908651351929, "    first_elem = arr[0]\n    is_equal = True\n    for elem in arr:\n        if elem != first_elem:\n            is_equal = False\n            break\n    return is_equal"], [0.8955456018447876, "    if len(arr) == 0:\n        return False\n    return all((arr[0] == x for x in arr))"], [0.8934072256088257, "    if len(lst) == 0:\n        return False\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True"]]}
{"task_id": "MBPP/60", "problem": []}
{"task_id": "MBPP/61", "problem": [[0.9086328744888306, "    root = int(sqrt(n))\n    return n == root * root"], [0.906577467918396, "    square_root = int(num ** 0.5)\n    return square_root * square_root == num"], [0.9064910411834717, "    for i in range(0, int(n ** 0.5) + 1):\n        for j in range(i, int(n ** 0.5) + 1):\n            if i * i + j * j == n:\n                return True\n    return False"], [0.9059733152389526, "    for i in range(int(math.sqrt(n)) + 1):\n        if math.isqrt(n - i * i) ** 2 == n - i * i:\n            return True"], [0.905969500541687, "    for i in range(int(math.sqrt(n)) + 1):\n        if math.isqrt(n - i * i) ** 2 == n - i * i:\n            return True\n    return False"], [0.9058382511138916, "    root = int(n ** 0.5)\n    return n == root * root"], [0.9058364629745483, "    square_root = math.sqrt(n)\n    return square_root.is_integer()"], [0.9058330059051514, "    for i in range(0, int(math.sqrt(n)) + 1):\n        for j in range(0, int(math.sqrt(n)) + 1):\n            if i * i + j * j == n:\n                return True\n    return False"], [0.9058234691619873, "    root = int(n ** 0.5)\n    return n == root * root"], [0.905735433101654, "    root = math.sqrt(n)\n    return n == int(root + 0.5) ** 2"]]}
{"task_id": "MBPP/62", "problem": [[0.9141456484794617, "    pattern = re.compile(delimiter, re.IGNORECASE)\n    return pattern.split(my_string)"], [0.9129692316055298, "    return re.split('|'.join(map(re.escape, delimiters)), s)"], [0.9129440784454346, "    return re.split('|'.join(map(re.escape, delimiters)), s)"], [0.9106648564338684, "    result = []\n    delimiter_stack = []\n    current_word = ''\n    for char in string:\n        if char in delimiters:\n            if not delimiter_stack:\n                result.append(current_word)\n                current_word = ''\n            else:\n                current_word += char\n        else:\n            current_word += char\n        if char in delimiters:\n            delimiter_stack.append(char)\n        elif delimiter_stack and char == delimiter_stack[-1]:\n            delimiter_stack.pop()\n    result.append(current_word)\n    return result"], [0.9091101884841919, "    return string.split(delimiter)"], [0.9091071486473083, "    return string.split(delimiter)"], [0.9091071486473083, "    return string.split(delimiter)"], [0.9090888500213623, "    return string.split(delimiter)"], [0.9090885519981384, "    return string.split(delimiter)"], [0.9081543684005737, "    splits = string.split(delimiter)\n    final_splits = []\n    for s in splits:\n        split_substrings = re.split(regex_pattern, s)\n        split_substrings = [x for x in split_substrings if x]\n        final_splits.append(split_substrings)\n    return final_splits"]]}
{"task_id": "MBPP/63", "problem": [[0.8983497619628906, "    result = []\n    for string, pattern in patterns:\n        if re.search(pattern, string):\n            result.append(True)\n        else:\n            result.append(False)\n    return result"], [0.89751136302948, "    if re.match(pattern, sequence):\n        return True\n    else:\n        return False"], [0.8970226049423218, "    pattern = re.compile('abbccd')\n    match = pattern.match(sequence)\n    if match:\n        return True\n    return False"], [0.896980345249176, "    pattern = re.compile('abbccd')\n    match = pattern.match(sequence)\n    if match:\n        return True\n    return False"], [0.8924723863601685, "    for string, pattern in patterns:\n        if re.search(pattern, string):\n            result.append(True)\n        else:\n            result.append(False)"], [0.8924547433853149, "    for pattern in patterns:\n        if code.count(pattern) > 1:\n            return False"], [0.8924459218978882, "    for pattern in patterns:\n        if code.count(pattern) > 1:\n            return False"], [0.8907196521759033, "    if pat.match(seq):\n        return True\n    else:\n        return False"], [0.890075147151947, "    for pattern in patterns:\n        if pattern in input_string:\n            found_patterns.append(pattern)"], [0.8882672190666199, "    found_patterns = []\n    for pattern in patterns:\n        if pattern in input_string:\n            found_patterns.append(pattern)\n    return found_patterns"]]}
{"task_id": "MBPP/64", "problem": [[0.9003798961639404, "    if not isinstance(k, int):\n        return \"Error: Argument 'k' should be an integer\"\n    if not all((isinstance(t, tuple) for t in tuples)):\n        return 'Error: All elements should be tuples'\n    indices = [i for i, t in enumerate(tuples) if k in t]\n    if not indices:\n        return f'No tuples found containing the number {k}'\n    return indices"], [0.8977481126785278, "    multiples = []\n    for n in arr:\n        if n % num == 0:\n            multiples.append(n)\n    return multiples"], [0.8973555564880371, "    multiples_dict = {}\n    for i in lst:\n        if i in multiples_dict:\n            multiples_dict[i] += 1\n        else:\n            multiples_dict[i] = 1\n    multiple_counts = {}\n    for element, count in multiples_dict.items():\n        if count % k == 0:\n            multiple_counts[element] = count // k\n    return multiple_counts"], [0.8961057662963867, "    divisible_numbers = []\n    for num in numbers:\n        if num % divisor == 0:\n            divisible_numbers.append(num)\n    return divisible_numbers"], [0.8960109949111938, "    if k == 0:\n        return 'Error: Division by zero is undefined'\n    count = 0\n    for i in arr:\n        if isinstance(i, list):\n            count += count_divisible_by_k(i, k)\n        elif isinstance(i, (int, float)):\n            if i % k == 0:\n                count += 1\n    return count"], [0.8958995938301086, "    sublist = []\n    for element in lst:\n        if element > threshold and element % divisor == 0:\n            sublist.append(element)\n    return sublist"], [0.8948439359664917, "    new_arr = []\n    for i in arr:\n        if i % divisor == 0:\n            new_arr.append(i)\n    return new_arr"], [0.8935140371322632, "    elements = []\n    for i in arr:\n        if i % number == 0:\n            elements.append(i)\n    return elements"], [0.8927046656608582, "    count = 0\n    if len(arr) == 0:\n        return count\n    for element in arr[0]:\n        if element % k == 0 and element % m == 1:\n            count += 1\n    return count + countDivisible(arr[1:], k, m)"], [0.8925551176071167, "    filtered_list = []\n    for num in input_list:\n        if num % criteria == 0:\n            filtered_list.append(num)\n    return filtered_list"]]}
{"task_id": "MBPP/65", "problem": [[0.9050391912460327, "    x1, y1, x2, y2 = map(int, rect.split())\n    return (x2 - x1) * (y2 - y1)"], [0.887770414352417, "    width = abs(x2 - x1)\n    height = abs(y2 - y1)\n    return width * height"], [0.8871716260910034, "    length = abs(x2 - x1)\n    width = abs(y2 - y1)\n    return length * width"], [0.8850581645965576, "    return [length * width for length, width in rectangle_pairs]"], [0.8850499391555786, "    return [length * width for length, width in rectangle_pairs]"], [0.8850207328796387, "    points = set()\n    for rectangle in coordinates:\n        for x in range(rectangle[0], rectangle[2]):\n            for y in range(rectangle[1], rectangle[3]):\n                points.add((x, y))\n    return len(points)"], [0.8846858739852905, "    if r > l and b > t:\n        return (r - l) * (b - t)\n    else:\n        return 0"], [0.8836591243743896, "    x1, y1 = rectangle[0]\n    x2, y2 = rectangle[1]\n    x3, y3 = rectangle[2]\n    x4, y4 = rectangle[3]\n    length = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    width = math.sqrt((x3 - x2) ** 2 + (y3 - y2) ** 2)\n    area = length * width\n    perimeter = 2 * (length + width)\n    return (area, perimeter)"], [0.8827654719352722, "    area_sum = 0\n    for rectangle in rectangles:\n        area_sum += rectangle['length'] * rectangle['width']\n    return area_sum"], [0.8809770345687866, "    squares = group.split()\n    total_area = sum((int(side) ** 2 for side in squares))\n    return total_area"]]}
{"task_id": "MBPP/66", "problem": [[0.8945975303649902, "    digits = [int(s) for s in string if s.isdigit()]\n    even_nums_sum = sum((d for d in digits if d % 2 == 0))\n    return (digits, even_nums_sum)"], [0.8923784494400024, "        if int(digit) % 2 == 0:\n            even_sum += int(digit)\n            even_count += 1\n        else:\n            odd_sum += int(digit)\n            odd_count += 1"], [0.8910857439041138, "        if int(digit) % 2 == 0:\n            even_count += 1\n            even_sum += int(digit)\n        else:\n            odd_count += 1\n            odd_sum += int(digit)"], [0.8894226551055908, "    numList = calculateFibonacci(n, m)\n    oddSum, evenSum, oddCount, evenCount = (0, 0, 0, 0)\n    for num in numList:\n        if num % 2 != 0 and oddCount < n:\n            oddSum += num\n            oddCount += 1\n        elif num % 2 == 0 and evenCount < m:\n            evenSum += num\n            evenCount += 1\n    difference = abs(oddSum - evenSum)\n    return (oddSum, evenSum, difference)"], [0.8889919519424438, "    diff = 0\n    evenSum = 0\n    for i in range(0, len(arr), 2):\n        evenSum += arr[i]\n    oddSum = 0\n    for i in range(1, len(arr), 2):\n        oddSum += arr[i]\n    diff = evenSum - oddSum\n    return abs(diff)"], [0.8885011672973633, "    numbers = nums.split(',')\n    odd_numbers = []\n    even_numbers = []\n    for num in numbers:\n        if int(num) % 2 == 0:\n            even_numbers.append(int(num))\n        else:\n            odd_numbers.append(int(num))\n    sum_odd = sum(odd_numbers)\n    sum_even = sum(even_numbers)\n    if sum_odd > sum_even:\n        return sum_odd\n    else:\n        return sum_even"], [0.8881651759147644, "    even_sum = 0\n    odd_sum = 0\n    for i in range(len(arr)):\n        if i % 2 == 0:\n            even_sum += arr[i]\n        else:\n            odd_sum += arr[i]\n    return abs(even_sum - odd_sum)"], [0.8881614208221436, "    even_sum = 0\n    odd_sum = 0\n    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):\n        if int(digit) % 2 == 0:\n            even_sum += int(digit)\n            even_count += 1\n        else:\n            odd_sum += int(digit)\n            odd_count += 1\n    return {'even': {'sum': even_sum, 'count': even_count}, 'odd': {'sum': odd_sum, 'count': odd_count}}"], [0.8879481554031372, "    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):\n        if digit.isdigit():\n            if int(digit) % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)"]]}
{"task_id": "MBPP/67", "problem": [[0.9048863649368286, "        if number & 1:\n            count += 1"], [0.9024717807769775, "    count = 0\n    for n in arr:\n        if n % 2 == 1:\n            count += 1\n    return count"], [0.901982307434082, "    odd_pairs = []\n    pair_count = 0\n    for i in range(len(lst) - 1):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) & 1:\n                pair_count += 1\n                odd_pairs.append((lst[i], lst[j]))\n    return (pair_count, odd_pairs)"], [0.9019408822059631, "    odd_pairs = []\n    pair_count = 0\n    for i in range(len(lst) - 1):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) & 1:\n                pair_count += 1\n                odd_pairs.append((lst[i], lst[j]))\n    return (pair_count, odd_pairs)"], [0.8993247747421265, "    limit = int(log2(n))\n    cnt = 0\n    for i in range(limit, -1, -1):\n        j = n - (1 << i)\n        if j < i:\n            break\n        cnt += sum_odd(min(i, j - i)) - sum_odd(i // 2)\n        cnt += sum_even(min(i - 1, j - i)) - sum_even((i - 1) // 2)\n    return cnt"], [0.8984699845314026, "    count = 0\n    for i in range(len(arr)):\n        if arr[i] % 2 != 0:\n            count = count + 1\n    return count"], [0.897388219833374, "        if n & 1:\n            count += 1"], [0.8968019485473633, "    count = 0\n    for num in arr:\n        if num % 2 != 0:\n            count += 1\n    return count"], [0.8967719078063965, "    for n in arr:\n        if n % 2 == 1:\n            count += 1"], [0.8967653512954712, "        if bitwise_and & 1:\n            count += 1"]]}
{"task_id": "MBPP/68", "problem": [[0.9106627702713013, "    if len(string) % 2 == 0:\n        print('The string is even.')\n    else:\n        print('The string is odd.')"], [0.9106627702713013, "    if len(string) % 2 == 0:\n        print('The string is even.')\n    else:\n        print('The string is odd.')"]]}
{"task_id": "MBPP/69", "problem": [[0.9239391684532166, "    if n < 0:\n        return 'Input must be a non-negative integer.'\n    tetra_list = [1, 4, 2, 6]\n    for i in range(4, n + 1):\n        if i % 2 == 0:\n            tetra_list.append(1 + i // 2)\n        elif i % 3 == 0:\n            tetra_list.append(tetra_list[i - 1] + tetra_list[i - 2])\n        else:\n            tetra_list.append(tetra_list[i - 1] + tetra_list[i - 2] + tetra_list[i - 3])\n    return tetra_list[:n + 1]"], [0.9172743558883667, "    for i in range(4, n + 1):\n        if i % 2 == 0:\n            tetra_list.append(1 + i // 2)\n        elif i % 3 == 0:\n            tetra_list.append(tetra_list[i - 1] + tetra_list[i - 2])\n        else:\n            tetra_list.append(tetra_list[i - 1] + tetra_list[i - 2] + tetra_list[i - 3])"], [0.9147508144378662, "    tetra_sequence = [0, 4, 2, 6, 3]\n    for i in range(5, n + 1):\n        if i % 2 == 0:\n            tetra_sequence.append(1 + i // 2)\n        elif i % 3 == 0:\n            tetra_sequence.append(tetra_sequence[i - 1] + tetra_sequence[i - 2])\n        else:\n            tetra_sequence.append(tetra_sequence[i - 1] + tetra_sequence[i - 2] + tetra_sequence[i - 3])\n    return tetra_sequence[1:n + 1]"], [0.9138253927230835, "        if i % 2 == 0:\n            tetra_sequence.append(1 + i // 2)\n        elif i % 3 == 0:\n            tetra_sequence.append(tetra_sequence[i - 1] + tetra_sequence[i - 2])\n        else:\n            tetra_sequence.append(tetra_sequence[i - 1] + tetra_sequence[i - 2] + tetra_sequence[i - 3])"], [0.9136544466018677, "    for i in range(5, n + 1):\n        if i % 2 == 0:\n            tetra_sequence.append(1 + i // 2)\n        elif i % 3 == 0:\n            tetra_sequence.append(tetra_sequence[i - 1] + tetra_sequence[i - 2])\n        else:\n            tetra_sequence.append(tetra_sequence[i - 1] + tetra_sequence[i - 2] + tetra_sequence[i - 3])"], [0.9106837511062622, "        if i % 2 == 0:\n            tetra_list.append(1 + i // 2)\n        elif i % 3 == 0:\n            tetra_list.append(tetra_list[i - 1] + tetra_list[i - 2])\n        else:\n            tetra_list.append(tetra_list[i - 1] + tetra_list[i - 2] + tetra_list[i - 3])"], [0.9058029651641846, "        elif i % 3 == 0:\n            tetra_sequence.append(tetra_sequence[i - 1] + tetra_sequence[i - 2])\n        else:\n            tetra_sequence.append(tetra_sequence[i - 1] + tetra_sequence[i - 2] + tetra_sequence[i - 3])"], [0.8944582939147949, "        elif i % 3 == 0:\n            tetra_list.append(tetra_list[i - 1] + tetra_list[i - 2])\n        else:\n            tetra_list.append(tetra_list[i - 1] + tetra_list[i - 2] + tetra_list[i - 3])"], [0.883368968963623, "    if n in memo:\n        return memo[n]\n    elif n == 0:\n        return 0\n    elif n == 1 or n == 2:\n        return 1\n    elif n < 0:\n        result = tribonacci(n + 3, memo) - tribonacci(n + 2, memo) - tribonacci(n + 1, memo)\n    else:\n        result = tribonacci(n - 1, memo) + tribonacci(n - 2, memo) + tribonacci(n - 3, memo)"], [0.8833537697792053, "    if n in memo:\n        return memo[n]\n    elif n == 0:\n        return 0\n    elif n == 1 or n == 2:\n        return 1\n    elif n < 0:\n        result = tribonacci(n + 3, memo) - tribonacci(n + 2, memo) - tribonacci(n + 1, memo)\n    else:\n        result = tribonacci(n - 1, memo) + tribonacci(n - 2, memo) + tribonacci(n - 3, memo)"]]}
{"task_id": "MBPP/70", "problem": [[0.8972415924072266, "    return zip(list1, list2)"], [0.8882050514221191, "    if len(tuple1) != len(tuple2):\n        return 'Error: The tuples do not have the same number of elements.'\n    else:\n        dictionary = {}\n        for i in range(len(tuple1)):\n            dictionary[tuple1[i]] = tuple2[i]\n        return dictionary"], [0.8882050514221191, "    if len(tuple1) != len(tuple2):\n        return 'Error: The tuples do not have the same number of elements.'\n    else:\n        dictionary = {}\n        for i in range(len(tuple1)):\n            dictionary[tuple1[i]] = tuple2[i]\n        return dictionary"], [0.8852648735046387, "    if len(t1) != len(t2):\n        raise ValueError('Tuples are not of equal length')\n    else:\n        combined_dict = dict(zip(t1, t2))\n        return json.dumps(combined_dict)"], [0.8852648735046387, "    if len(t1) != len(t2):\n        raise ValueError('Tuples are not of equal length')\n    else:\n        combined_dict = dict(zip(t1, t2))\n        return json.dumps(combined_dict)"], [0.8849730491638184, "    return [x for t in zip(list1, list2) for x in t]"], [0.8845043778419495, "    return list(zip(list1, list2))"], [0.8806685209274292, "    merged = ()\n    length = min(len(t1), len(t2))\n    for i in range(length):\n        merged += (t1[i],)\n        merged += (t2[i],)\n    return merged + t1[length:] + t2[length:]"], [0.8800736665725708, "    return [item for sublist in zip(list1, list2) for item in sublist]"], [0.8800665140151978, "    return [item for sublist in zip(list1, list2) for item in sublist]"]]}
{"task_id": "MBPP/71", "problem": [[0.9099823832511902, "    pi = 3.14159\n    volume = 4 / 3 * pi * radius ** 3\n    return volume"], [0.9080633521080017, "    volume = 4 / 3 * math.pi * math.pow(radius, 3)\n    return volume"], [0.9061641693115234, "    volume = 4 / 3 * 3.142 * radius ** 3\n    return round(volume, 2)"], [0.9059352874755859, "    volume = 4 / 3 * math.pi * radius ** 3\n    return volume"]]}
{"task_id": "MBPP/72", "problem": [[0.8926318883895874, "    elif not last_char.isalpha():\n        return 'Please input a string ending with a alphabet.'\n    else:\n        return chr(ord(last_char) + 1)"], [0.8915952444076538, "    for c in mystring:\n        new_str += chr(ord(c) + 1)"], [0.8907754421234131, "    new_str = ''\n    for c in mystring:\n        new_str += chr(ord(c) + 1)\n    return new_str"], [0.8905482292175293, "        if char.isalpha():\n            new_string += chr(ord(char) + 1)\n        elif char.isdigit():\n            new_string += chr(ord(char) + 1)\n        else:\n            new_string += char"], [0.8904914855957031, "    if original_string != '':\n        for char in original_string:\n            new_string += char\n        new_string += 'a'\n        print(new_string)\n    else:\n        print('String cannot be increased.')"], [0.889331042766571, "    new_string = ''\n    for char in string:\n        if char.isalpha():\n            new_string += chr(ord(char) + 1)\n        elif char.isdigit():\n            new_string += chr(ord(char) + 1)\n        else:\n            new_string += char\n    return new_string"], [0.8889539241790771, "    for char in string:\n        if char.isalpha():\n            new_string += chr(ord(char) + 1)\n        elif char.isdigit():\n            new_string += chr(ord(char) + 1)\n        else:\n            new_string += char"], [0.8885715007781982, "    word = word.strip()\n    count = 0\n    for char in word:\n        count += 1\n        if count == 3:\n            return char"], [0.8879324793815613, "    transformed_string = ''\n    for char in str:\n        char_int = ord(char)\n        if char_int == 122:\n            transformed_string += chr(97)\n        else:\n            transformed_string += chr(char_int + 1)\n    return transformed_string"], [0.8871617317199707, "    result = ''\n    for char in s:\n        result += chr(ord(char) + 1)\n    return result"]]}
{"task_id": "MBPP/73", "problem": [[0.9105169177055359, "    if n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return 2 * nth_value(n - 1)"], [0.9105169177055359, "    if n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return 2 * nth_value(n - 1)"], [0.9049450755119324, "    elif n == 2:\n        return 2\n    else:\n        return 2 * nth_value(n - 1)"], [0.9032402038574219, "    if n in [0, 1]:\n        return n"], [0.9026053547859192, "    if n <= 0:\n        raise ValueError('n should be greater than zero')\n    elif n == 1:\n        return 0\n    elif n <= 3:\n        return n - 1\n    else:\n        return 1"], [0.9026053547859192, "    if n <= 0:\n        raise ValueError('n should be greater than zero')\n    elif n == 1:\n        return 0\n    elif n <= 3:\n        return n - 1\n    else:\n        return 1"], [0.9006128311157227, "    elif n <= 3:\n        return n - 1\n    else:\n        return 1"], [0.9006028175354004, "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n)"], [0.9006028175354004, "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n)"], [0.8999742269515991, "    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Invalid input, please enter a positive whole number.')\n    seq = [0, 2]\n    while len(seq) < n:\n        new_term = seq[-1] + seq[-2]\n        seq.append(new_term)\n    return seq[-1]"]]}
{"task_id": "MBPP/74", "problem": [[0.9211633205413818, "    surface_area = 4 * math.pi * radius * radius\n    return surface_area"], [0.9203821420669556, "    surface_area = 4 * 3.14159 * radius ** 2\n    return round(surface_area, 2)"], [0.9036475419998169, "    pi = 3.14159\n    surface_area = 4 * pi * radius ** 2\n    volume = 4 / 3 * pi * radius ** 3\n    return (surface_area, volume)"], [0.9019544124603271, "    surface_area = 4 * math.pi * radius ** 2\n    volume = 4 / 3 * math.pi * radius ** 3\n    return (surface_area, volume)"], [0.8997478485107422, "    if not isinstance(radius, (int, float)):\n        raise TypeError('The radius must be a numeric value.')\n    elif radius < 0:\n        raise ValueError('The radius cannot be negative.')\n    surface_area = 4 * math.pi * radius ** 2\n    return round(surface_area, 2)"], [0.8990501165390015, "    if type(radius) != int or radius <= 0:\n        raise ValueError('Radius should be a positive integer')\n    surface_area = 4 * math.pi * radius ** 2\n    rounded_surface_area = round(surface_area, 2)\n    return rounded_surface_area"]]}
{"task_id": "MBPP/75", "problem": [[0.8995764255523682, "    while True:\n        hexagonal = n * (2 * n - 1)\n        if isPentagonal(hexagonal):\n            return hexagonal\n        n += 1"], [0.8932449817657471, "        if isPentagonal(hexagonal):\n            return hexagonal"], [0.8929467797279358, "    n = 144\n    while True:\n        hexagonal = n * (2 * n - 1)\n        if isPentagonal(hexagonal):\n            return hexagonal\n        n += 1\n    return None"], [0.8905327320098877, "        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4"], [0.8860144019126892, "    if type(n) != int or n < 0:\n        return 'ERROR: Invalid Input'\n    if n > 5000:\n        return 'ERROR: Input number too large'\n    if n in computed:\n        return computed[n]\n    computed[n] = n * (5 * n - 3) / 2 + heptagonal(n - 1)\n    return computed[n]"], [0.8776531219482422, "    while count < n:\n        pentagonal = x * (3 * x - 1) // 2\n        yield pentagonal\n        x += 2\n        count += 1"], [0.875400185585022, "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"], [0.875400185585022, "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"], [0.8750653266906738, "    if n == 1:\n        if sequence:\n            return [1]\n        else:\n            return 1\n    else:\n        previous_seq = nonagonal_calc(n - 1, sequence=True)\n        current_value = n * (7 * n - 5) // 2\n        if sequence:\n            return previous_seq + [current_value]\n        else:\n            return current_value"], [0.8744978904724121, "    if not isinstance(n, int) or n < 1:\n        return \"Warning: Invalid input. 'n' should be a positive integer.\"\n    x = 1\n    count = 0\n    while count < n:\n        pentagonal = x * (3 * x - 1) // 2\n        yield pentagonal\n        x += 2\n        count += 1"]]}
{"task_id": "MBPP/76", "problem": [[0.903810441493988, "    return {**dict1, **dict2, **dict3}"], [0.8861516118049622, "    dict3 = dict1.copy()\n    dict3.update(dict2)\n    return dict3"], [0.8857178688049316, "        elif key in dict1:\n            dict3[key] = dict1[key]\n        else:\n            dict3[key] = dict2[key]"]]}
{"task_id": "MBPP/77", "problem": [[0.9293187856674194, "    frequency = {}\n    for item in my_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency"], [0.9282239675521851, "    freq = {}\n    for element in lst:\n        if element in freq:\n            freq[element] += 1\n        else:\n            freq[element] = 1\n    return freq"], [0.9254363775253296, "    frequency_dict = {}\n    for element in lst:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict"], [0.9251856803894043, "    freq_dict = {}\n    for item in list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict"], [0.9238341450691223, "    for element in elements:\n        frequencies[element] = my_list.count(element)"], [0.9237633347511292, "    frequency = {}\n    for i in lst:\n        if i in frequency:\n            frequency[i] += 1\n        else:\n            frequency[i] = 1\n    return frequency"], [0.92364501953125, "    if not isinstance(lst, list):\n        raise TypeError('Input is not a list')\n    frequency = {}\n    for element in lst:\n        if not isinstance(element, (int, float)):\n            raise TypeError('List contains elements that are not numbers')\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency"], [0.9206636548042297, "    frequency_list = []\n    for item in my_list:\n        if item not in frequency_list:\n            frequency_list.append(item)\n    for i in range(0, len(frequency_list)):\n        frequency_list[i] = (frequency_list[i], my_list.count(frequency_list[i]))\n    return frequency_list"], [0.9193477630615234, "    if not input_list:\n        return {}\n    frequency_counter = Counter(input_list)\n    frequency_dict = dict(frequency_counter)\n    return frequency_dict"], [0.9180501699447632, "    for element in list:\n        if element in frequency_dict.keys():\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1"]]}
{"task_id": "MBPP/78", "problem": [[0.9046329259872437, "    closest_low = 0\n    for i in range(len(arr)):\n        if num > arr[i] > closest_low:\n            closest_low = arr[i]\n    return closest_low"], [0.901627779006958, "    while True:\n        n -= 1\n        if is_prime(n):\n            return n"], [0.901627779006958, "    while True:\n        n -= 1\n        if is_prime(n):\n            return n"], [0.9012535810470581, "    if n < 0:\n        return -1\n    elif n <= 1:\n        return 0\n    new_size = int(n / 0.5) + 1\n    return new_size - n"], [0.8997445106506348, "    for i in range(len(arr)):\n        if num > arr[i] > closest_low:\n            closest_low = arr[i]"], [0.8987901210784912, "            if l[mid] == n:\n                return n\n            elif l[mid] < n:\n                left = mid\n            else:\n                right = mid"], [0.8987013697624207, "    if n <= 2:\n        return -1\n    prime = n - 1\n    found = False\n    while not found:\n        if check_prime(prime) == True:\n            found = True\n        prime -= 1\n    return prime + 1"], [0.8965843915939331, "    for i in range(n, 0, -1):\n        if is_prime(i):\n            return i"], [0.8965843915939331, "    for i in range(n, 0, -1):\n        if is_prime(i):\n            return i"], [0.896420419216156, "    elif n >= l[-1]:\n        return l[-1]\n    else:\n        left, right = (0, len(l) - 1)\n        while left < right - 1:\n            mid = (left + right) // 2\n            if l[mid] == n:\n                return n\n            elif l[mid] < n:\n                left = mid\n            else:\n                right = mid\n        if l[right] - n <= n - l[left]:\n            return l[right]\n        else:\n            return l[left]"]]}
{"task_id": "MBPP/79", "problem": [[0.9385227560997009, "    word_list = text.split()\n    longest_word = max(word_list, key=len)\n    longest_word_length = len(longest_word)\n    return longest_word_length"], [0.9335407018661499, "    words = string.split()\n    longest_length = 0\n    for word in words:\n        if len(word) > longest_length:\n            longest_length = len(word)\n    return longest_length"], [0.9329982399940491, "    words = sentence.split()\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length"], [0.9329981803894043, "    words = sentence.split()\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length"], [0.9327255487442017, "    words = string.split()\n    longest_word_length = 0\n    for word in words:\n        if len(word) > longest_word_length:\n            longest_word_length = len(word)\n    return longest_word_length"], [0.9317890405654907, "    longest = 0\n    words = sentence.split()\n    for word in words:\n        if len(word) > longest:\n            longest = len(word)\n    return longest"], [0.9309384822845459, "    words = sentence.split()\n    longest_word = ''\n    for word in words:\n        if len(word) > len(longest_word):\n            longest_word = word\n    return len(longest_word)"], [0.9307042360305786, "    longest_word = max(words, key=len)\n    return longest_word"], [0.9299757480621338, "    longest_word = ''\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            longest_word = word\n            max_length = len(word)\n    return longest_word"], [0.9299694895744324, "    words = sentence.split(' ')\n    longest_word = 0\n    for word in words:\n        if len(word) > longest_word:\n            longest_word = len(word)\n    return longest_word"]]}
{"task_id": "MBPP/80", "problem": [[0.9352319240570068, "    for string in string_list:\n        if substring in string:\n            return True\n    return False"], [0.9309239387512207, "    for string in string_list:\n        if substring in string:\n            return True"], [0.9265003204345703, "    for item in lst:\n        if substring in item:\n            return True\n    return False"], [0.9230149984359741, "    for substring in substrings:\n        if substring in string:\n            return True\n    return False"], [0.9219099879264832, "    if substring in string:\n        return True\n    else:\n        return False"], [0.9219099879264832, "    if substring in string:\n        return True\n    else:\n        return False"], [0.9219086170196533, "    if substring in string:\n        return True\n    else:\n        return False"], [0.9219086170196533, "    if substring in string:\n        return True\n    else:\n        return False"], [0.92190021276474, "    if substring in string:\n        return True\n    else:\n        return False"], [0.92190021276474, "    if substring in string:\n        return True\n    else:\n        return False"]]}
{"task_id": "MBPP/81", "problem": [[0.8872003555297852, "    num = 1 / 2 * (math.sqrt(8 * x + 1) - 1)\n    return int(num) == num"], [0.8863439559936523, "    root = math.sqrt(num)\n    return root.is_integer()"], [0.886300802230835, "    root = math.sqrt(num)\n    return root.is_integer()"], [0.8833931684494019, "    return num % 4 == 0 or num % 6 == 0"], [0.8824251294136047, "    if number % 2 == 0:\n        return False\n    else:\n        return True"], [0.8824251294136047, "    if number % 2 == 0:\n        return False\n    else:\n        return True"], [0.882392168045044, "    if number % 2 == 0:\n        return False\n    else:\n        return True"], [0.882392168045044, "    if number % 2 == 0:\n        return False\n    else:\n        return True"], [0.8818081021308899, "    root = math.sqrt(n)\n    return n == int(root + 0.5) ** 2"], [0.8817868828773499, "    if number % 10 == 0:\n        return True\n    return False"]]}
{"task_id": "MBPP/82", "problem": [[0.9148586988449097, "    result = 1\n    for i in range(b):\n        result = result * a\n    return result"], [0.9120935201644897, "    return float('%.3f' % pow(a, b))"], [0.9108773469924927, "    return pow(num, power)"], [0.9108743071556091, "    return pow(num, power)"], [0.90727299451828, "    result = 1\n    if b >= 0:\n        for _ in range(b):\n            result *= a\n    else:\n        for _ in range(-b):\n            result /= a\n    return result"], [0.9058274030685425, "    sum_result = a + b\n    power_result = a ** b\n    return (sum_result, power_result)"], [0.9048712253570557, "    try:\n        float_number = float(number)\n    except ValueError:\n        return 'Error: The input is not a valid numerical value!'\n    return pow(float_number, power)"], [0.9035940766334534, "        for _ in range(b):\n            result *= a"], [0.9015156030654907, "    result = pow(number, power)\n    return float(result)"], [0.9014190435409546, "    elif a < 0:\n        return a * b\n    else:\n        return b ** 2"]]}
{"task_id": "MBPP/83", "problem": [[0.881722092628479, "    min_value = tpl[0]\n    for i in tpl:\n        if i < min_value:\n            min_value = i\n    return min_value"], [0.8817185163497925, "    min_value = tpl[0]\n    for i in tpl:\n        if i < min_value:\n            min_value = i\n    return min_value"], [0.8734389543533325, "    min_value = None\n    min_index = -1\n    for i in range(len(numbers)):\n        if min_value is None or numbers[i] > min_value:\n            min_value = numbers[i]\n            min_index = i\n    return (min_index, numbers[min_index])"], [0.872460663318634, "    if len(arr) == 0:\n        return (None, None)\n    min_value = arr[0]\n    min_index = 0\n    for i in range(1, len(arr)):\n        if arr[i] < min_value:\n            min_value = arr[i]\n            min_index = i\n    return (min_value, min_index)"], [0.8712706565856934, "    if len(tup_list) == 0:\n        return 'The tuple list is empty.'\n    if k > len(tup_list):\n        return 'K is greater than the size of list. Returning all records.'\n    tup_list.sort(key=lambda x: x[0])\n    return tup_list[:k]"], [0.8699585795402527, "    min_val = arr[0]\n    min_index = 0\n    for i, num in enumerate(arr):\n        if num < min_val:\n            min_val = num\n            min_index = i\n    return (min_val, min_index)"], [0.8692935705184937, "            if tuple_value < tuple_item:\n                index = i\n                break"], [0.8685747385025024, "    max_values = []\n    for tup in list_of_tuples:\n        max_values.append(max(tup))\n    return max_values"], [0.86780846118927, "            if value > minimum_value:\n                return (value, key)"], [0.8675603866577148, "    min_val = arr[0]\n    min_index = 0\n    for i in range(1, len(arr)):\n        if arr[i] < min_val:\n            min_val = arr[i]\n            min_index = i\n    return (min_val, min_index)"]]}
{"task_id": "MBPP/84", "problem": [[0.8956077098846436, "            if subsequence_length < min_length:\n                min_length = subsequence_length"], [0.8903441429138184, "    min_value = min(list1)\n    return min_value"], [0.8865119218826294, "    if minlength == n + 1:\n        print('Not Possible')\n    else:\n        print('Minimum length of subarray is: %d' % minlength)"], [0.8836588859558105, "    if len(lst) == 1:\n        return lst[0]\n    else:\n        return min(lst[0], find_minimum(lst[1:]))"], [0.8836588859558105, "    if len(lst) == 1:\n        return lst[0]\n    else:\n        return min(lst[0], find_minimum(lst[1:]))"], [0.8834091424942017, "    if isinstance(lst, list):\n        return min((recurs_min(sub) for sub in lst))\n    elif isinstance(lst, int):\n        return lst\n    else:\n        raise ValueError('Input list contains non-integer values')"], [0.8834091424942017, "    if isinstance(lst, list):\n        return min((recurs_min(sub) for sub in lst))\n    elif isinstance(lst, int):\n        return lst\n    else:\n        raise ValueError('Input list contains non-integer values')"], [0.8813356161117554, "    input_list = list(set(input_list))\n    return find_min(input_list)"], [0.8806067705154419, "        if len(sublist) != sublist_length:\n            return False"], [0.8804660439491272, "    if not lst:\n        return float('inf')\n    if isinstance(lst[0], list):\n        a = find_min(lst[0])\n    else:\n        a = lst[0]\n    b = find_min(lst[1:])\n    return a if a < b else b"]]}
{"task_id": "MBPP/85", "problem": [[0.9216490983963013, "    divisors = 0\n    for i in range(1, number + 1):\n        if number % i == 0:\n            divisors += 1\n    print('Number of divisors:', divisors)"], [0.9201942682266235, "    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count"], [0.9201762676239014, "    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count"], [0.9201656579971313, "    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count"], [0.9197947382926941, "    count = 0\n    for i in range(1, x + 1):\n        if x % i == 0:\n            count = count + 1\n    return count"], [0.9165308475494385, "    divisors = [i for i in range(1, n + 1) if n % i == 0]\n    return divisors"], [0.9165216684341431, "    divisors = [i for i in range(1, n + 1) if n % i == 0]\n    return divisors"], [0.9162620306015015, "    divisors = [i for i in range(1, int(n / 2) + 1) if n % i == 0]\n    divisors.append(n)\n    return divisors"], [0.9162578582763672, "    divisors = [i for i in range(1, int(n / 2) + 1) if n % i == 0]\n    divisors.append(n)\n    return divisors"], [0.9143408536911011, "    divisors = []\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisors.append(i)\n    return sum(divisors)"]]}
{"task_id": "MBPP/86", "problem": [[0.9047385454177856, "    freq_dict = {}\n    for item in list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict"], [0.9017285108566284, "    for i in range(0, len(frequency_list)):\n        frequency_list[i] = (frequency_list[i], my_list.count(frequency_list[i]))"], [0.9008973836898804, "    frequency_list = []\n    for item in my_list:\n        if item not in frequency_list:\n            frequency_list.append(item)\n    for i in range(0, len(frequency_list)):\n        frequency_list[i] = (frequency_list[i], my_list.count(frequency_list[i]))\n    return frequency_list"], [0.8994886875152588, "    frequency = {}\n    for item in my_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency"], [0.8993456363677979, "    frequency_dict = {}\n    for sublist in matrix:\n        if isinstance(sublist, list):\n            for item in sublist:\n                if isinstance(item, list):\n                    for subitem in item:\n                        frequency_dict[subitem] = frequency_dict.get(subitem, 0) + 1\n                else:\n                    frequency_dict[item] = frequency_dict.get(item, 0) + 1\n        else:\n            frequency_dict[sublist] = frequency_dict.get(sublist, 0) + 1\n    return frequency_dict"], [0.8993127346038818, "    frequency_dict = {}\n    for sublist in matrix:\n        if isinstance(sublist, list):\n            for item in sublist:\n                if isinstance(item, list):\n                    for subitem in item:\n                        frequency_dict[subitem] = frequency_dict.get(subitem, 0) + 1\n                else:\n                    frequency_dict[item] = frequency_dict.get(item, 0) + 1\n        else:\n            frequency_dict[sublist] = frequency_dict.get(sublist, 0) + 1\n    return frequency_dict"], [0.899026095867157, "    if not input_list:\n        return {}\n    frequency_counter = Counter(input_list)\n    frequency_dict = dict(frequency_counter)\n    return frequency_dict"], [0.8988651037216187, "    freq = {}\n    for element in lst:\n        if element in freq:\n            freq[element] += 1\n        else:\n            freq[element] = 1\n    return freq"], [0.8988641500473022, "    frequency_dict = dict(Counter(input_list))\n    return frequency_dict"], [0.8985060453414917, "    frequency = {}\n    for i in lst:\n        if i in frequency:\n            frequency[i] += 1\n        else:\n            frequency[i] = 1\n    return frequency"]]}
{"task_id": "MBPP/87", "problem": [[0.924433708190918, "    sum_list = 0\n    length_list = len(mylist)\n    for item in mylist:\n        sum_list += item\n    return sum_list / length_list"], [0.9233635663986206, "    s = 0\n    for i in my_list:\n        s += i\n    return s / len(my_list)"], [0.9232916831970215, "    total = sum(num_list)\n    length = len(num_list)\n    return total / length"], [0.9232696890830994, "    total = 0\n    for i in list:\n        total += i\n    return total / len(list)"], [0.92289799451828, "    product = 1\n    for i in list:\n        product *= i\n    return product ** (1.0 / len(list))"], [0.92289799451828, "    product = 1\n    for i in list:\n        product *= i\n    return product ** (1.0 / len(list))"], [0.9217953681945801, "    sum = 0\n    length = len(list)\n    for item in list:\n        sum += item\n    return sum / length"], [0.9213599562644958, "    total = 0\n    for num in input_list:\n        total += num\n    return total / len(input_list)"], [0.9210866689682007, "    total = 0\n    for num in list_of_numbers:\n        total += num\n    return total / len(list_of_numbers)"], [0.9210770726203918, "    total = 0\n    for num in list_of_numbers:\n        total += num\n    return total / len(list_of_numbers)"]]}
{"task_id": "MBPP/88", "problem": []}
{"task_id": "MBPP/89", "problem": [[0.9298737049102783, "    num = int(num)\n    num += 1\n    while not is_palindrome(str(num)):\n        num += 1\n    return num"], [0.9233894944190979, "    prime = N + 1\n    while True:\n        if is_palindrome(prime):\n            return prime\n        prime += 1"], [0.922540545463562, "    N += 1\n    while not is_palindrome(N):\n        N += 1\n    return N"], [0.9204354882240295, "    while not is_palindrome(N):\n        N += 1"], [0.9187624454498291, "    while not is_palindrome(str(num)):\n        num += 1"], [0.9157408475875854, "    num = int(n)\n    left = num - 1\n    right = num + 1\n    while True:\n        if is_palindrome(str(left)):\n            return left\n        if is_palindrome(str(right)):\n            return right\n        left -= 1\n        right += 1"], [0.9157384634017944, "    num = int(n)\n    left = num - 1\n    right = num + 1\n    while True:\n        if is_palindrome(str(left)):\n            return left\n        if is_palindrome(str(right)):\n            return right\n        left -= 1\n        right += 1"], [0.9136845469474792, "    while True:\n        if is_palindrome(prime):\n            return prime\n        prime += 1"], [0.9129340052604675, "    elif is_palindrome(n) and is_prime(n):\n        return n\n    else:\n        return find_largest_prime_palindrome(n - 1)"], [0.9085729718208313, "    if n == 100:\n        return n\n    elif is_palindrome(n) and is_prime(n):\n        return n\n    else:\n        return find_largest_prime_palindrome(n - 1)"]]}
{"task_id": "MBPP/90", "problem": [[0.9308001399040222, "    sorted_arr = sorted(arr)\n    return sorted_arr[k - 1]"], [0.9282589554786682, "    if k > len(arr):\n        return 'k is greater than the number of unique elements'\n    else:\n        return arr[k - 1]"], [0.9279881715774536, "    input_array.sort()\n    return input_array[k - 1]"], [0.9278619289398193, "    if k > len(arr):\n        return None\n    else:\n        sorted_arr = sorted(arr)\n        return sorted_arr[k - 1]"], [0.9278619289398193, "    if k > len(arr):\n        return None\n    else:\n        sorted_arr = sorted(arr)\n        return sorted_arr[k - 1]"], [0.9264690279960632, "    sorted_arr = sorted(arr)[::-1]\n    return sorted_arr[k - 1]"], [0.9264675378799438, "    sorted_arr = sorted(arr)[::-1]\n    return sorted_arr[k - 1]"], [0.9258804321289062, "    if k > len(arr):\n        return 'Error: k is out of bounds.'\n    else:\n        return arr[k - 1]"], [0.924019992351532, "    if k > len(arr) or k <= 0:\n        return None\n    for i in range(k):\n        min_element = arr[0]\n        min_index = 0\n        for j in range(1, len(arr)):\n            if arr[j] < min_element:\n                min_element = arr[j]\n                min_index = j\n        arr[min_index], arr[i] = (arr[i], arr[min_index])\n    return arr[k - 1]"], [0.923766553401947, "    if k > len(nums):\n        return 'k is bigger than the size of the list'\n    else:\n        return nums[k - 1]"]]}
{"task_id": "MBPP/91", "problem": [[0.9247964024543762, "    words = snake_case.split('_')\n    camel_case = words[0]\n    for word in words[1:]:\n        camel_case += word.capitalize()\n    return camel_case"], [0.9221047163009644, "    camel_case = ''\n    for word in str.split():\n        camel_case += word.capitalize()\n    return camel_case"]]}
{"task_id": "MBPP/92", "problem": [[0.8906870484352112, "    return math.factorial(m + n - 2) // (math.factorial(n - 1) * math.factorial(m - 1))"], [0.88893723487854, "    if n > m:\n        return 0"], [0.8876044750213623, "    if n > m:\n        return 'Error: n should be less than or equal to m.'"], [0.8875895738601685, "    if n > m:\n        return 'Error: n should be less than or equal to m.'"], [0.8862558603286743, "    if n == m:\n        return 1"], [0.8862354755401611, "    if n == m:\n        return 1"], [0.8832582235336304, "    if m > n:\n        return 0"], [0.8832582235336304, "    if m > n:\n        return 0"], [0.879114031791687, "    if (n, m) in memo:\n        return memo[n, m]"], [0.8791067600250244, "    if (n, m) in memo:\n        return memo[n, m]"]]}
{"task_id": "MBPP/93", "problem": [[0.904645562171936, "    for sublist in lists:\n        sublist.sort()"], [0.8916612267494202, "    for sublist in lists:\n        sublist.sort()\n    lists.sort(key=lambda x: x[0])\n    return lists"], [0.8882632255554199, "    sorted_list = sorted(list_of_strings)\n    return sorted_list"], [0.8878780603408813, "    sorted_list = sorted(list_of_strings, key=lambda str: str.lower())\n    return sorted_list"], [0.8874186277389526, "    list_of_strings.sort()\n    for string in list_of_strings:\n        print(string)"], [0.8868726491928101, "    sorted_sublists = [sorted(sublist, reverse=True) for sublist in lst]\n    sorted_lst = sorted(sorted_sublists, key=lambda x: min(x), reverse=True)\n    return sorted_lst"], [0.8864985704421997, "    strings_list = input_list\n    strings_list.sort(key=len)\n    return strings_list"], [0.8856813907623291, "    sorted_list = sorted(strings, key=len)\n    return sorted_list"], [0.8836424350738525, "    for sublist in arr:\n        bubble_sort(sublist)"], [0.8832833170890808, "    sortedList = [sorted(lst) for lst in lists]\n    sortedList.sort(key=len)\n    return sortedList"]]}
{"task_id": "MBPP/94", "problem": [[0.9040787220001221, "    true_sum: int = 0\n    false_sum: int = 0\n    for i in range(len(x)):\n        if isinstance(x[i], bool) and x[i] is True:\n            true_sum += 1\n        elif isinstance(x[i], bool) and x[i] is False:\n            false_sum += 1\n    return (true_sum, false_sum)"], [0.8972114324569702, "    count = 0\n    for l in ls:\n        if l == 1:\n            count += 1\n    return count"], [0.8912967443466187, "    count = 0\n    for i in my_list:\n        if i == char:\n            count += 1\n    return count"], [0.8910148739814758, "    true_sum: int = 0\n    false_sum: int = 0\n    for i in range(len(x)):\n        if isinstance(x[i], bool) and x[i] is True:\n            true_sum += 2\n        elif isinstance(x[i], bool) and x[i] is False:\n            false_sum += 2\n    return (true_sum, false_sum)"], [0.8909772634506226, "    true_sum: int = 0\n    false_sum: int = 0\n    for i in range(len(x)):\n        if isinstance(x[i], bool) and x[i] is True:\n            true_sum += 2\n        elif isinstance(x[i], bool) and x[i] is False:\n            false_sum += 2\n    return (true_sum, false_sum)"], [0.8908747434616089, "    count = 0\n    for i in lst:\n        if i == x:\n            count += 1\n    return count"], [0.8908746838569641, "    count = 0\n    for i in lst:\n        if i == x:\n            count += 1\n    return count"], [0.8905704617500305, "    count = sum((x % 1 != 0 for x in myList))\n    return count"], [0.8893463611602783, "    for i in range(len(x)):\n        if isinstance(x[i], bool) and x[i] is True:\n            true_sum += 1\n        elif isinstance(x[i], bool) and x[i] is False:\n            false_sum += 1"], [0.8890926837921143, "    count = 0\n    for i in input_list:\n        if i == element:\n            count += 1\n    return count"]]}
{"task_id": "MBPP/95", "problem": [[0.890766441822052, "    additions = []\n    for i in range(len(list1)):\n        additions.append(list1[i] + list2[i])\n    return additions"], [0.886352002620697, "    for element in list:\n        tupleList.append((element,))"], [0.8859602212905884, "    for i in range(len(list1)):\n        additions.append(list1[i] + list2[i])"], [0.8859531879425049, "    tupleList = []\n    for element in list:\n        tupleList.append((element,))\n    return tupleList"], [0.8848867416381836, "    return list_to_append + list_to_add"]]}
{"task_id": "MBPP/96", "problem": [[0.8800690174102783, "    hex_num = hex(num).lstrip('0x').upper()\n    count = hex_num.count('0')\n    return count"], [0.8791757822036743, "    my_int_in_hex = hex(my_int)[2:]\n    count = 0\n    index_list = []\n    for i in range(len(hex_string)):\n        if hex_string[i] == my_int_in_hex:\n            count += 1\n            index_list.append(i)\n    return (count, index_list)"], [0.8787362575531006, "    for i in range(len(hex_string)):\n        if hex_string[i] == my_int_in_hex:\n            count += 1\n            index_list.append(i)"], [0.8774327039718628, "    tally = 0\n    int_locations = []\n    for i, char in enumerate(hex_string):\n        if char == str(my_int):\n            tally += 1\n            int_locations.append(i)\n    return (tally, int_locations)"], [0.8752556443214417, "    hex_output = ''\n    for character in input_string:\n        ascii_val = ord(character)\n        hex_val = hex(ascii_val)[2:]\n        hex_output += hex_val + ' '\n    return hex_output.rstrip()"], [0.8744489550590515, "    counter_dict = {}\n    if start_number > 0:\n        while start_number >= 0:\n            counter_dict[start_number] = bin(start_number)[2:]\n            start_number -= 1\n    else:\n        while start_number <= 0:\n            counter_dict[start_number] = bin(start_number & 4294967295)[2:]\n            start_number += 1\n    return counter_dict"], [0.8738586902618408, "    decimal_num = int(hex_num, 16)\n    binary_num = bin(decimal_num)\n    return binary_num"], [0.873664915561676, "    my_int = str(my_int)\n    indices = [i for i, x in enumerate(hex_string) if x == my_int]\n    return (len(indices), indices)"]]}
{"task_id": "MBPP/97", "problem": []}
{"task_id": "MBPP/98", "problem": [[0.8900451064109802, "    return binary_string.count('1')"], [0.8857401609420776, "    for bit in binary_string:\n        if bit == '1':\n            count += 1"], [0.8850492238998413, "    count = 0\n    for bit in binary_string:\n        if bit == '1':\n            count += 1\n    return count"], [0.883312463760376, "    return binary.count('1')"], [0.880691647529602, "    result = 0\n    bit_place = 0\n    while n > 0:\n        if n & 1 == 1:\n            if bit_place % 2 == 0:\n                result += 1\n        n >>= 1\n        bit_place += 1\n    return result"], [0.8805960416793823, "    for char in binary_str:\n        if char == '1':\n            count += 1"], [0.8804523348808289, "    while n > 0:\n        if n & 1 == 1:\n            if bit_place % 2 == 0:\n                result += 1\n        n >>= 1\n        bit_place += 1"], [0.8781188726425171, "    for c in s:\n        count = count + 1 if c == '1' else 0\n        result = (result + count) % mod"], [0.8781005144119263, "    for c in s:\n        count = count + 1 if c == '1' else 0\n        result = (result + count) % mod"], [0.8779504299163818, "        if binaryNumber % 10 == 1:\n            count += 1"]]}
{"task_id": "MBPP/99", "problem": [[0.8904544711112976, "    arr.sort()\n    missing = []\n    for i in range(arr[0], arr[-1] + 1):\n        if i not in arr:\n            missing.append(i)\n    return missing"], [0.8894385099411011, "    number_set = set(numbers)\n    complete_set = set(range(min(numbers), max(numbers) + 1))\n    missing_numbers = complete_set - number_set\n    return list(missing_numbers)"], [0.8894097208976746, "    number_set = set(numbers)\n    complete_set = set(range(min(numbers), max(numbers) + 1))\n    missing_numbers = complete_set - number_set\n    return list(missing_numbers)"], [0.8893870115280151, "    return [x for x in range(lst[0], lst[-1] + 1) if x not in lst]"], [0.8893850445747375, "    return [x for x in range(lst[0], lst[-1] + 1) if x not in lst]"], [0.889354407787323, "    start = arr[0]\n    end = arr[len(arr) - 1]\n    result = []\n    for i in range(start, end + 1):\n        if i not in arr:\n            result.append(i)\n    return result"], [0.8855795860290527, "    ranges = []\n    numbers.sort()\n    start = numbers[0]\n    for i in range(1, len(numbers)):\n        if numbers[i] == numbers[i - 1] + 1:\n            continue\n        else:\n            ranges.append(list(range(start, numbers[i - 1] + 1)))\n            start = numbers[i]\n    ranges.append(list(range(start, numbers[-1] + 1)))\n    return ranges"], [0.8853608965873718, "    start = min(start_1, start_2)\n    end = max(end_1, end_2)\n    return list(range(start, end + 1))"], [0.8844737410545349, "    for i in range(arr[0], arr[-1] + 1):\n        if i not in arr:\n            missing.append(i)"], [0.8837907314300537, "    return list(range(start, end + 1))"]]}
{"task_id": "MBPP/100", "problem": [[0.9306983351707458, "    list1_flat = set(flatten(list1))\n    list2_flat = set(flatten(list2))\n    common = list1_flat.intersection(list2_flat)\n    return list(common)"], [0.9281349778175354, "    set1 = set(flatten(list1))\n    set2 = set(flatten(list2))\n    common_items = set1.intersection(set2)\n    return list(common_items)"], [0.9280052781105042, "    flat_list1 = flatten(list_one)\n    flat_list2 = flatten(list_two)\n    common_list = [value for value in flat_list1 if value in flat_list2]\n    return common_list"], [0.9266336560249329, "    list1 = flatten_list(list1)\n    list2 = flatten_list(list2)\n    common_items = []\n    for item in list1:\n        if item in list2 and item not in common_items:\n            common_items.append(item)\n    return common_items"], [0.9258133172988892, "    common_items = []\n    list1 = flatten_list(list1)\n    list2 = flatten_list(list2)\n    for item in list1:\n        if item in list2:\n            common_items.append(item)\n    return common_items"], [0.9212514162063599, "    list_of_sets = [set(lst) for lst in list_of_lists]\n    common_set = set.intersection(*list_of_sets)\n    common_list = list(common_set)\n    return common_list"], [0.9209737777709961, "    common = []\n    for value in list1:\n        if value in list2:\n            common.append(value)\n    return common"], [0.9209583401679993, "    common = []\n    for element1 in list1:\n        for element2 in list2:\n            if element1 == element2:\n                common.append(element1)\n    return common"], [0.9205236434936523, "    common = []\n    for item in list1:\n        if item in list2:\n            common.append(item)\n    return common"], [0.9204890131950378, "    common = []\n    for i in list1:\n        for j in list2:\n            if i == j:\n                common.append(i)\n    return common"]]}
{"task_id": "MBPP/101", "problem": [[0.9196661710739136, "    perimeter = 2 * math.pi * radius\n    return perimeter"], [0.9032785892486572, "    area = 3.14 * radius ** 2\n    perimeter = 2 * 3.14 * radius\n    return (area, perimeter)"], [0.9024999141693115, "    circumference = 2 * 3.14 * radius\n    return circumference"], [0.8975180983543396, "    return math.pi * cylinder['radius'] ** 2 * cylinder['height']"], [0.8966156244277954, "    pi = 3.14\n    return pi * radius ** 2 * height"], [0.8928848505020142, "    radius = ''.join(filter(str.isdigit, radius))\n    radius = float(radius)\n    circumference = 2 * math.pi * radius\n    return circumference"], [0.8923834562301636, "    pi = 3.14\n    circumference = 2 * pi * r\n    area = pi * r ** 2\n    return (circumference, area)"], [0.8918233513832092, "    approximation_pi = 3.14\n    circumference = 2 * approximation_pi * radius\n    return circumference"], [0.8914366960525513, "    circ = 2 * 3.14 * radius\n    return circ"], [0.8910186290740967, "    radius = ''.join(filter(str.isdigit, radius))\n    if not radius.isdigit():\n        return 'Error: Invalid radius input'\n    radius = float(radius)\n    circumference = 2 * math.pi * radius\n    return circumference"]]}
{"task_id": "MBPP/102", "problem": [[0.9220234751701355, "    try:\n        int(string)\n        return True\n    except ValueError:\n        return False"], [0.9220234751701355, "    try:\n        int(string)\n        return True\n    except ValueError:\n        return False"], [0.9215967059135437, "    for i in range(0, len(str)):\n        if str[i].isdigit() == False:\n            return False\n    return True"], [0.9170644283294678, "    try:\n        num = int(input)\n    except ValueError:\n        return False\n    return True"], [0.9165903925895691, "    try:\n        int(s)\n        return True\n    except ValueError:\n        return False"], [0.9165903925895691, "    try:\n        int(s)\n        return True\n    except ValueError:\n        return False"], [0.9157981872558594, "    for c in string:\n        if not c.isdigit():\n            return False\n    return True"], [0.9151633381843567, "    for i in range(0, len(str)):\n        if str[i].isdigit() == False:\n            return False"], [0.9145486950874329, "    for i in range(len(string)):\n        if not string[i].isdigit():\n            return False\n    return True"], [0.9139341115951538, "    pattern = '^[0-9]+$'\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False"]]}
{"task_id": "MBPP/103", "problem": [[0.9065843224525452, "    for i in range(0, len(frequency_list)):\n        frequency_list[i] = (frequency_list[i], my_list.count(frequency_list[i]))"], [0.9012141823768616, "    frequency_list = []\n    for item in my_list:\n        if item not in frequency_list:\n            frequency_list.append(item)\n    for i in range(0, len(frequency_list)):\n        frequency_list[i] = (frequency_list[i], my_list.count(frequency_list[i]))\n    return frequency_list"], [0.8946806788444519, "    word_freq_dict = {}\n    for word, freq in word_tuples:\n        if word in word_freq_dict:\n            word_freq_dict[word] += freq\n        else:\n            word_freq_dict[word] = freq\n    return word_freq_dict"], [0.8928815722465515, "    freq_dict = {}\n    for item in list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict"], [0.8916035294532776, "    frequency = {}\n    for item in my_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency"], [0.8911077976226807, "    freq = {}\n    for element in lst:\n        if element in freq:\n            freq[element] += 1\n        else:\n            freq[element] = 1\n    return freq"], [0.8907713294029236, "    frequency_dict = {}\n    for element in lst:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict"], [0.8898603320121765, "    frequency = {}\n    for i in lst:\n        if i in frequency:\n            frequency[i] += 1\n        else:\n            frequency[i] = 1\n    return frequency"], [0.8895935416221619, "    for item in list:\n        if item not in freq:\n            freq[item] = 1\n        else:\n            freq[item] += 1"], [0.8895878791809082, "    for item in list:\n        if item not in freq:\n            freq[item] = 1\n        else:\n            freq[item] += 1"]]}
{"task_id": "MBPP/104", "problem": [[0.9123679399490356, "    if dictionary:\n        for key, value in dictionary.items():\n            if isinstance(value, dict):\n                if check_empty_dict(value) == False:\n                    return False\n            else:\n                return False\n        return True\n    else:\n        return True"], [0.9123679399490356, "    if dictionary:\n        for key, value in dictionary.items():\n            if isinstance(value, dict):\n                if check_empty_dict(value) == False:\n                    return False\n            else:\n                return False\n        return True\n    else:\n        return True"], [0.9123556613922119, "    if dictionary:\n        for key, value in dictionary.items():\n            if isinstance(value, dict):\n                if check_empty_dict(value) == False:\n                    return False\n            else:\n                return False\n        return True\n    else:\n        return True"], [0.9123556613922119, "    if dictionary:\n        for key, value in dictionary.items():\n            if isinstance(value, dict):\n                if check_empty_dict(value) == False:\n                    return False\n            else:\n                return False\n        return True\n    else:\n        return True"], [0.9072432518005371, "        for key, value in dictionary.items():\n            if isinstance(value, dict):\n                if check_empty_dict(value) == False:\n                    return False\n            else:\n                return False"], [0.9072311520576477, "        for key, value in dictionary.items():\n            if isinstance(value, dict):\n                if check_empty_dict(value) == False:\n                    return False\n            else:\n                return False"], [0.9070345163345337, "    if isinstance(nested_list, list):\n        if not nested_list:\n            return True\n        else:\n            return all((check_empty_nested_list(sub_list) for sub_list in nested_list))\n    else:\n        return False"], [0.9070345163345337, "    if isinstance(nested_list, list):\n        if not nested_list:\n            return True\n        else:\n            return all((check_empty_nested_list(sub_list) for sub_list in nested_list))\n    else:\n        return False"], [0.9061027765274048, "    elif not input_dict:\n        return 'The dictionary is empty.'\n    else:\n        return 'The dictionary is not empty.'"], [0.9025170207023621, "        if not nested_list:\n            return True\n        else:\n            return all((check_empty_nested_list(sub_list) for sub_list in nested_list))"]]}
{"task_id": "MBPP/105", "problem": [[0.8866246938705444, "        elif isinstance(i, int):\n            if i < 0:\n                return 'Error: Negative number in tuple.'\n            else:\n                lst.append(math.factorial(i))\n        else:\n            return 'Error: Tuple contains non-integer element.'"], [0.8865193128585815, "    number = 0\n    for integer in list_of_ints:\n        number = number * 10 + integer\n    return number"], [0.8844189643859863, "    return int(''.join((str(e) for e in int_list)))"], [0.8835376501083374, "    if len(arr) == 0:\n        return 1\n    return eval('*'.join(map(str, arr)))"], [0.8831291198730469, "    for i in tup:\n        if isinstance(i, tuple):\n            result = factorial_tuple(i, lst)\n            if isinstance(result, str):\n                return result\n        else:\n            fact = factorial(i)\n            if fact is None:\n                return f\"Error: Invalid input '{i}' in tuple\"\n            else:\n                lst.append(fact)"], [0.8829628229141235, "            if not isinstance(i, int):\n                return 'Error: Non-integer input in tuple'"], [0.8823133707046509, "            if i < 0:\n                return 'Error: Negative number in tuple.'\n            else:\n                lst.append(math.factorial(i))"], [0.882286012172699, "    if not isinstance(t, tuple):\n        raise ValueError('The input should be a tuple.')\n    for element in t:\n        if not isinstance(element, int):\n            raise ValueError('All elements in the tuple should be integers.')\n    reversed_tuple = ()\n    for i in range(len(t) - 1, -1, -1):\n        reversed_tuple += (t[i],)\n    return reversed_tuple"], [0.8822718858718872, "    if not isinstance(t, tuple):\n        raise ValueError('The input should be a tuple.')\n    for element in t:\n        if not isinstance(element, int):\n            raise ValueError('All elements in the tuple should be integers.')\n    reversed_tuple = ()\n    for i in range(len(t) - 1, -1, -1):\n        reversed_tuple += (t[i],)\n    return reversed_tuple"], [0.882269024848938, "        if isinstance(i, tuple):\n            error_message = factorial_tuple(i, lst)\n            if error_message:\n                return error_message\n        elif isinstance(i, int):\n            if i < 0:\n                return 'Error: Negative number in tuple.'\n            else:\n                lst.append(math.factorial(i))\n        else:\n            return 'Error: Tuple contains non-integer element.'"]]}
{"task_id": "MBPP/106", "problem": [[0.915752649307251, "    float_list = []\n    for x in input_list:\n        try:\n            float_list.append(float(x))\n        except ValueError:\n            print(f\"Error: '{x}' cannot be converted to a float\")\n    return float_list"], [0.9034278392791748, "    for i in range(len(lst)):\n        try:\n            lst[i] = float(lst[i])\n        except ValueError:\n            continue"], [0.9016536474227905, "    for i in range(len(lst)):\n        if type(lst[i]) == str:\n            try:\n                lst[i] = float(lst[i])\n            except ValueError:\n                pass"], [0.9015383124351501, "    floats = []\n    for s in str_list:\n        floats.append(float(s))\n    return floats"], [0.900789201259613, "    for x in input_list:\n        try:\n            float_list.append(float(x))\n        except ValueError:\n            print(f\"Error: '{x}' cannot be converted to a float\")"], [0.9005160331726074, "    return [float(i) for i in list_]"], [0.8999524712562561, "    list_numbers = []\n    for x in list_strings:\n        a = float(x)\n        list_numbers.append(a)\n    return list_numbers"], [0.8925843238830566, "    for i in range(len(l)):\n        if type(l[i]) == str:\n            try:\n                l[i] = float(l[i])\n            except ValueError:\n                pass"], [0.8925673961639404, "    new_list = []\n    for item in lst:\n        try:\n            if isinstance(item, bool):\n                new_list.append(int(item))\n            else:\n                new_list.append(int(float(item)))\n        except (TypeError, ValueError):\n            new_list.append(-1)\n    return new_list"], [0.8925145864486694, "    for item in l:\n        if not isinstance(item, (int, float)):\n            try:\n                converted_list.append(float(item))\n            except (ValueError, TypeError):\n                converted_list.append(None)\n        else:\n            converted_list.append(item)"]]}
{"task_id": "MBPP/107", "problem": [[0.9168053269386292, "    return [char for char in string]"], [0.9141913652420044, "    char_list = []\n    for character in string:\n        char_list.append(character)\n    return char_list"], [0.9112480878829956, "    charList = []\n    for char in string:\n        charList.append(char)\n    return charList"], [0.9105046987533569, "    char_list = []\n    for char in string:\n        char_list.append(char)\n    return char_list"], [0.9103701710700989, "    l = []\n    for c in s:\n        l.append(c)\n    return l"], [0.9094976782798767, "    result = []\n    for character in string:\n        result.append(character)\n    return result"], [0.9093276262283325, "    return list(input_string)"], [0.9093194007873535, "    return list(input_string)"], [0.9093133807182312, "    return list(input_string)"], [0.9092049598693848, "    result = []\n    for i in range(len(string)):\n        result.append(string[i])\n    return result"]]}
{"task_id": "MBPP/108", "problem": [[0.9118441939353943, "    freq_count = [0] * len(array)\n    for i in range(len(array)):\n        if freq_count[array[i]] == 1:\n            return array[i]\n        else:\n            freq_count[array[i]] += 1\n    return None"], [0.9104114770889282, "    count = {}\n    for num in lst:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    for num in lst:\n        if count[num] == 1:\n            return num"], [0.9100409746170044, "    counts = Counter(arr)\n    for num in arr:\n        if counts[num] == 1:\n            return num\n    return None"], [0.908836305141449, "    number_count = {}\n    for num in arr:\n        if num not in number_count:\n            number_count[num] = 1\n        else:\n            number_count[num] += 1\n    for key, value in number_count.items():\n        if value == 1:\n            return key"], [0.9079709053039551, "    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    for num in arr:\n        if freq[num] == 1:\n            return num\n    return None"], [0.9079073667526245, "    for i in range(len(arr)):\n        for j in range(i, len(arr)):\n            if arr[i] < arr[j]:\n                arr[i], arr[j] = (arr[j], arr[i])\n    unique_elements = []\n    for num in arr:\n        if num not in unique_elements:\n            unique_elements.append(num)\n    if len(unique_elements) < 2:\n        return 'Error: Less than 2 unique elements'\n    else:\n        return unique_elements[1]"], [0.9077256917953491, "    dictionary = {}\n    for num in arr:\n        if num not in dictionary:\n            dictionary[num] = 1\n        else:\n            dictionary[num] += 1\n    for key, value in dictionary.items():\n        if value == 1:\n            return key"], [0.9073616862297058, "    counter = dict()\n    for num in A:\n        if num not in counter:\n            counter[num] = 1\n        else:\n            counter[num] += 1\n    for num in sorted(A, reverse=True):\n        if counter[num] == 1:\n            return num\n    return -1"], [0.9073085784912109, "    d = {}\n    for i in arr:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n    for key, value in d.items():\n        if value == 1:\n            return key\n    return -1"], [0.9064387083053589, "    count_dict = {}\n    for element in arr:\n        if element in count_dict:\n            count_dict[element] += 1\n        else:\n            count_dict[element] = 1\n    for element, count in count_dict.items():\n        if count == 1:\n            return arr.index(element)\n    return -1"]]}
{"task_id": "MBPP/109", "problem": [[0.9108669757843018, "    for pair in combinations(lst, 2):\n        product = pair[0] * pair[1]\n        if product > max_product:\n            max_product = product\n            max_pair = pair"], [0.9096786975860596, "    if len(lst) < 2:\n        return None\n    max_product = float('-inf')\n    max_pair = None\n    for pair in combinations(lst, 2):\n        product = pair[0] * pair[1]\n        if product > max_product:\n            max_product = product\n            max_pair = pair\n    return list(max_pair)"], [0.9071627855300903, "    max_product = float('-inf')\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] * lst[j] > max_product:\n                max_product = lst[i] * lst[j]\n                pair = (lst[i], lst[j])\n    return pair"], [0.9058259129524231, "    max_product = float('-inf')\n    max_lists = []\n    for lst in list_of_lists:\n        flat_list = list(flatten(lst))\n        if flat_list:\n            temp_product = float(product(flat_list))\n            if temp_product > max_product:\n                max_product = temp_product\n                max_lists = [flat_list]\n            elif temp_product == max_product:\n                max_lists.append(flat_list)\n    return (max_product, max_lists)"], [0.9057348966598511, "        if product > max_product:\n            max_product = product\n            max_pair = pair"], [0.9048483371734619, "    if not lst:\n        return []\n    possible_pairs = [[lst[i], lst[j]] for i in range(len(lst)) for j in range(i + 1, len(lst))]\n    products = [pair[0] * pair[1] for pair in possible_pairs]\n    max_product = max(products)\n    return [possible_pairs[i] for i in range(len(products)) if products[i] == max_product]"]]}
{"task_id": "MBPP/110", "problem": [[0.9250504374504089, "    found = False\n    for i in range(0, len(arr) - 2):\n        for j in range(i + 1, len(arr) - 1):\n            for k in range(j + 1, len(arr)):\n                if arr[i] + arr[j] + arr[k] == 0:\n                    print('Found triplets ' + str(arr[i]) + ', ' + str(arr[j]) + ', ' + str(arr[k]))\n                    found = True\n    if found == False:\n        print('No Triplets found')"], [0.9188776016235352, "                if array[i] + array[j] + array[k] == target_sum:\n                    triplets.append([array[i], array[j], array[k]])"], [0.9167721271514893, "    for i in range(0, len(arr) - 2):\n        for j in range(i + 1, len(arr) - 1):\n            for k in range(j + 1, len(arr)):\n                if arr[i] + arr[j] + arr[k] == 0:\n                    print('Found triplets ' + str(arr[i]) + ', ' + str(arr[j]) + ', ' + str(arr[k]))\n                    found = True"], [0.9159861207008362, "    array.sort()\n    triplets = []\n    for i in range(len(array)):\n        for j in range(i + 1, len(array)):\n            for k in range(j + 1, len(array)):\n                if array[i] + array[j] + array[k] == target_sum:\n                    triplets.append([array[i], array[j], array[k]])\n    return triplets"], [0.9154179096221924, "    triplets = []\n    n = len(array)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if array[i] + array[j] + array[k] == target:\n                    triplets.append((array[i], array[j], array[k]))\n    return triplets"], [0.9149442315101624, "            for k in range(j + 1, len(arr)):\n                if arr[i] + arr[j] + arr[k] == 0:\n                    print('Found triplets ' + str(arr[i]) + ', ' + str(arr[j]) + ', ' + str(arr[k]))\n                    found = True"], [0.9140879511833191, "    arr.sort()\n    triplets = []\n    for i in range(0, len(arr) - 2):\n        l = i + 1\n        r = len(arr) - 1\n        while l < r:\n            if arr[i] + arr[l] + arr[r] == sum:\n                triplets.append([arr[i], arr[l], arr[r]])\n                l += 1\n                r -= 1\n            elif arr[i] + arr[l] + arr[r] < sum:\n                l += 1\n            else:\n                r -= 1\n    return triplets"], [0.9140818119049072, "    for i in range(len(array)):\n        for j in range(i + 1, len(array)):\n            for k in range(j + 1, len(array)):\n                if array[i] + array[j] + array[k] == target_sum:\n                    triplets.append([array[i], array[j], array[k]])"]]}
{"task_id": "MBPP/111", "problem": [[0.8977925181388855, "    return findNthPolite(n)"], [0.8977662324905396, "    return findNthPolite(n)"], [0.8908370137214661, "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n)"], [0.8908370137214661, "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n)"], [0.8876878619194031, "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n) + nth_prime(n)"], [0.8876878619194031, "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n) + nth_prime(n)"], [0.8854479789733887, "    for i in range(2, n):\n        newNumber = prevNumber + currentNumber\n        prevNumber = currentNumber\n        currentNumber = newNumber"], [0.8853105306625366, "    count = 0\n    num1, num2 = (0, 1)\n    while count < n:\n        fib_num = num1 + num2\n        if is_prime(fib_num):\n            count += 1\n        num1, num2 = (num2, fib_num)\n    return num2"], [0.8851787447929382, "    if n == 1:\n        return 169"], [0.8848992586135864, "    if n in [0, 1]:\n        return n"]]}
{"task_id": "MBPP/112", "problem": [[0.9043622612953186, "    amicable_pairs = []\n    for i in range(2, n + 1):\n        divisors_sum = sum(find_divisors(i))\n        if i != divisors_sum and sum(find_divisors(divisors_sum)) == i:\n            if sorted([i, divisors_sum]) not in amicable_pairs:\n                amicable_pairs.append(sorted([i, divisors_sum]))\n    return amicable_pairs"], [0.8974796533584595, "    for i in range(2, n + 1):\n        divisors_sum = sum(find_divisors(i))\n        if i != divisors_sum and sum(find_divisors(divisors_sum)) == i:\n            if sorted([i, divisors_sum]) not in amicable_pairs:\n                amicable_pairs.append(sorted([i, divisors_sum]))"], [0.8925368189811707, "    aliquot_sum = 0\n    for i in range(1, number):\n        if number % i == 0:\n            aliquot_sum += i\n    return aliquot_sum"], [0.890262246131897, "            if sorted([i, divisors_sum]) not in amicable_pairs:\n                amicable_pairs.append(sorted([i, divisors_sum]))"], [0.8897556066513062, "    for number in range(limit + 1):\n        sum = sum + number"], [0.8896053433418274, "        if i != divisors_sum and sum(find_divisors(divisors_sum)) == i:\n            if sorted([i, divisors_sum]) not in amicable_pairs:\n                amicable_pairs.append(sorted([i, divisors_sum]))"], [0.8889552354812622, "    for i in range(1, number):\n        if number % i == 0:\n            sum += i"], [0.8886860609054565, "    sum = 0\n    for number in range(limit + 1):\n        sum = sum + number\n    return sum"], [0.8874677419662476, "    sum = n * (n + 1) / 2\n    return sum"], [0.887457549571991, "    sum_number = 0\n    for num in range(1, number + 1):\n        sum_number += num\n    return sum_number"]]}
{"task_id": "MBPP/113", "problem": [[0.8908109664916992, "    magnitude = abs(z)\n    angle = math.phase(z)\n    return (magnitude, angle)"], [0.8902772665023804, "    r = Abs(num)\n    theta = arg(num)\n    return complex(r * cos(theta), r * sin(theta))"], [0.888110876083374, "    real = magnitude * math.cos(angle)\n    imaginary = magnitude * math.sin(angle)\n    return (real, imaginary)"], [0.8866607546806335, "    abs_diff = abs(num1 - num2)\n    rad_angle = cmath.phase(num1) - cmath.phase(num2)\n    deg_angle = math.degrees(rad_angle)\n    return (abs_diff, deg_angle)"], [0.8745326399803162, "    return 180 - angle"], [0.8720937371253967, "    if imag == 0.0 and real == 0.0:\n        return complex_zero"], [0.8707728981971741, "        if num.is_Polar:\n            c_num = polarToComplex(num)\n        else:\n            c_num = cartesianToComplex(num)"], [0.8691363334655762, "    return x.imag"], [0.8685915470123291, "    if isinstance(c, complex):\n        return (c.real, c.imag)\n    return (c, 0)"], [0.8677178621292114, "    complex_num1 = complex(a1, b1)\n    complex_num2 = complex(a2, b2)\n    diff = complex_num1 - complex_num2\n    modulus = abs(diff)\n    return modulus"]]}
{"task_id": "MBPP/114", "problem": [[0.9054516553878784, "    for c in s:\n        if c == '1':\n            current_ones += 1\n            current_zeros = 0\n        else:\n            current_zeros += 1\n            current_ones = 0\n        max_ones = max(max_ones, current_ones)\n        max_zeros = max(max_zeros, current_zeros)"], [0.9054420590400696, "    for c in s:\n        if c == '1':\n            current_ones += 1\n            current_zeros = 0\n        else:\n            current_zeros += 1\n            current_ones = 0\n        max_ones = max(max_ones, current_ones)\n        max_zeros = max(max_zeros, current_zeros)"], [0.9033670425415039, "    max_len = 0\n    cur_len = 0\n    for bit in binary_str:\n        if bit == '1':\n            cur_len += 1\n        elif bit == '0':\n            if cur_len > max_len:\n                max_len = cur_len\n            cur_len = 0\n    return max_len"], [0.9028051495552063, "    maxLength = 0\n    count = 0\n    for i in range(len(inpString)):\n        if inpString[i] == '1':\n            count += 1\n        else:\n            if count > maxLength:\n                maxLength = count\n            count = 0\n    if count > maxLength:\n        maxLength = count\n    return maxLength"], [0.9004928469657898, "    for bit in binary_str:\n        if bit == '1':\n            cur_len += 1\n        elif bit == '0':\n            if cur_len > max_len:\n                max_len = cur_len\n            cur_len = 0"], [0.9004883766174316, "    for i in range(len(binary_string)):\n        if binary_string[i] == '0':\n            if start == -1:\n                start = i\n        elif start != -1:\n            length = i - start\n            if length > max_length:\n                max_start = start\n                max_length = length\n            start = -1"], [0.8991833925247192, "    max_score = 0\n    max_substrings = 0\n    for i in range(1, len(s)):\n        left = s[:i]\n        right = s[i:]\n        if '000' in left or '111' in left:\n            continue\n        score = left.count('0') + right.count('1')\n        substrings = right.split('0')\n        substrings = sum((1 for sub in substrings if sub.startswith('1') and sub.endswith('1')))\n        if score > max_score:\n            max_score = score\n            max_substrings = substrings\n        elif score == max_score:\n            max_substrings = max(max_substrings, substrings)\n    return [max_score, max_substrings]"], [0.8987106680870056, "    for char in s:\n        if char == '1':\n            current_count += 1\n            max_count = max(max_count, current_count)\n        else:\n            current_count = 0"], [0.8975120186805725, "        if char == '1':\n            current_count += 1\n            max_count = max(max_count, current_count)\n        else:\n            current_count = 0"], [0.8973971009254456, "        if bit == '1':\n            cur_len += 1\n        elif bit == '0':\n            if cur_len > max_len:\n                max_len = cur_len\n            cur_len = 0"]]}
{"task_id": "MBPP/115", "problem": [[0.8969346880912781, "    gcd = 1\n    for i in range(1, min(num1, num2) + 1):\n        if num1 % i == 0 and num2 % i == 0:\n            gcd = i\n    common_factors = [i for i in range(1, gcd + 1) if gcd % i == 0]\n    return common_factors"], [0.8958377838134766, "    gcd_value = math.gcd(a, b)\n    lcm_value = abs(a * b) / gcd_value\n    return (gcd_value, lcm_value)"], [0.895796537399292, "    gcd = 1\n    if num1 < num2:\n        small = num1\n    else:\n        small = num2\n    for i in range(1, small + 1):\n        if num1 % i == 0 and num2 % i == 0:\n            gcd = i\n    return gcd"], [0.8951839208602905, "    if num2 == 0:\n        return num1\n    return greatest_common_divisor(num2, num1 % num2)"], [0.8944165110588074, "    divisors = []\n    for i in range(1, min(a, b) + 1):\n        if a % i == 0 and b % i == 0:\n            divisors.append(i)\n    return len(divisors)"], [0.8935210108757019, "    lcm = math.lcm(a, b)\n    gcd = math.gcd(a, b)\n    return (lcm, gcd)"], [0.89250248670578, "    return math.gcd(n1, n2)"], [0.8916451930999756, "    smaller_number = min(A, B)\n    prime_factors = []\n    for i in range(2, int(math.sqrt(smaller_number)) + 1):\n        while smaller_number % i == 0:\n            prime_factors.append(i)\n            smaller_number //= i\n    if smaller_number > 1:\n        prime_factors.append(smaller_number)\n    largest_common_divisor = 1\n    for prime_factor in prime_factors:\n        if A % prime_factor == 0 and B % prime_factor == 0:\n            largest_common_divisor *= prime_factor\n    return largest_common_divisor"], [0.8913954496383667, "    smallest = min(A, B)\n    largest_divisor = 1\n    for i in range(1, smallest + 1):\n        if A % i == 0 and B % i == 0:\n            largest_divisor = i\n    return largest_divisor"]]}
{"task_id": "MBPP/116", "problem": [[0.9086955785751343, "    if y == 0:\n        return 0\n    if y < 0:\n        return -multiply(x, -y)\n    if x < 0:\n        return -multiply(-x, y)\n    if y % 1 != 0 or x % 1 != 0:\n        return float(x) * float(y)\n    if x > 1000000 or y > 1000000:\n        return x * y\n    return (x << int(y - 1).bit_length()) + multiply(x, y - (1 << int(y - 1).bit_length()))"]]}
{"task_id": "MBPP/117", "problem": [[0.9383945465087891, "    return [w for w in word_list if len(w) > n]"], [0.9340401887893677, "    return [word for word in words if len(word) >= n]"], [0.9312149882316589, "    for word in words:\n        if len(word) > n:\n            print(word)"], [0.9238461256027222, "    new_list = [word for word in word_list if len(word) > 5]\n    return new_list"], [0.9213696122169495, "    filtered_words = []\n    for word in words:\n        if len(word) > condition:\n            filtered_words.append(word)\n    return filtered_words"], [0.9191796183586121, "    words = text.split()\n    unique_words = set(words)\n    long_words = [word for word in unique_words if len(word) > n]\n    return long_words"], [0.9189049005508423, "    new_list = []\n    for word in lst:\n        if len(word) > 3:\n            new_list.append(word)\n    return new_list"], [0.9187384843826294, "    filtered_words = []\n    for word in words:\n        if len(word) > 5:\n            filtered_words.append(word)\n    return filtered_words"], [0.9184577465057373, "        if len(word) > n:\n            long_words.append(word)\n        else:\n            short_words.append(word)"], [0.9167727828025818, "    filtered_words = []\n    for word in words:\n        if len(word) > 3:\n            filtered_words.append(word)\n    return filtered_words"]]}
{"task_id": "MBPP/118", "problem": [[0.9014210104942322, "    while num <= n * n:\n        magic_square[i][j] = num\n        i -= 1\n        j += 1\n        if i < 0:\n            i = n - 1\n        if j >= n:\n            j = 0\n        if magic_square[i][j] != 0:\n            i += 1\n            j -= 1\n        num += 1"], [0.8981744050979614, "    magic_square = [[0] * n for _ in range(n)]\n    i = 0\n    j = n // 2\n    num = 1\n    while num <= n * n:\n        magic_square[i][j] = num\n        i -= 1\n        j += 1\n        if i < 0:\n            i = n - 1\n        if j >= n:\n            j = 0\n        if magic_square[i][j] != 0:\n            i += 1\n            j -= 1\n        num += 1\n    return magic_square"], [0.895277738571167, "    for row in magic_square:\n        print(' '.join((str(x).rjust(len(str(n * n))) for x in row)))"], [0.8923771381378174, "        if magic_square[i][j] != 0:\n            i += 1\n            j -= 1"], [0.891608715057373, "    while num <= n * n:\n        magic_square[i][j] = num\n        num += 1\n        newi, newj = ((i - 1) % n, (j + 1) % n)\n        if magic_square[newi][newj]:\n            i += 1\n        else:\n            i, j = (newi, newj)"], [0.8876791596412659, "    sum_value = calculate_sum(matrix)\n    return check_prime(sum_value)"], [0.8854791522026062, "    if sum((matrix[i][i] for i in range(size))) != magic_constant or sum((matrix[i][size - i - 1] for i in range(size))) != magic_constant:\n        return False"], [0.8845279812812805, "        if magic_square[newi][newj]:\n            i += 1\n        else:\n            i, j = (newi, newj)"], [0.8844475150108337, "    for i in range(size):\n        if sum(matrix[i]) != magic_constant or sum([row[i] for row in matrix]) != magic_constant:\n            return False"], [0.8840947151184082, "    matrix = [m[:] for m in matrix]\n    size = len(matrix)\n    magic_constant = sum(matrix[0])\n    for i in range(size):\n        if sum(matrix[i]) != magic_constant or sum([row[i] for row in matrix]) != magic_constant:\n            return False\n    if sum((matrix[i][i] for i in range(size))) != magic_constant or sum((matrix[i][size - i - 1] for i in range(size))) != magic_constant:\n        return False\n    return True"]]}
{"task_id": "MBPP/119", "problem": [[0.9411230087280273, "    counts = {}\n    for item in my_list:\n        if item in counts:\n            counts[item] += 1\n        else:\n            counts[item] = 1\n    max_frequency = 0\n    max_item = None\n    for item in counts:\n        if counts[item] > max_frequency:\n            max_frequency = counts[item]\n            max_item = item\n    return max_item"], [0.9380264282226562, "    max_count = 0\n    max_item = None\n    dict = {}\n    for item in list:\n        if item in dict:\n            dict[item] += 1\n        else:\n            dict[item] = 1\n    for key, value in dict.items():\n        if value > max_count:\n            max_count = value\n            max_item = key\n    return max_item"], [0.9375565052032471, "    frequency_dict = {}\n    max_count = 0\n    max_item = None\n    for item in input_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n        if frequency_dict[item] > max_count:\n            max_count = frequency_dict[item]\n            max_item = item\n    return (max_item, max_count)"], [0.9369833469390869, "    freq_dict = {}\n    for item in lst:\n        freq_dict[item] = freq_dict.get(item, 0) + 1\n    max_count = 0\n    max_item = lst[0]\n    for key, value in freq_dict.items():\n        if value > max_count:\n            max_count = value\n            max_item = key\n    return max_item"], [0.935531497001648, "    frequency = {}\n    most_frequent_item = None\n    max_frequency = 0\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n        if frequency[item] > max_frequency:\n            max_frequency = frequency[item]\n            most_frequent_item = item\n    return most_frequent_item"], [0.9352599382400513, "    max_frequency = 0\n    most_frequent_item = None\n    for item in input_list:\n        frequency = input_list.count(item)\n        if frequency > max_frequency:\n            max_frequency = frequency\n            most_frequent_item = item\n    return most_frequent_item"], [0.9343314170837402, "    max_count = -1\n    max_item = None\n    count = {}\n    for item in lst:\n        if item in count:\n            count[item] += 1\n        else:\n            count[item] = 1\n        if count[item] > max_count:\n            max_count = count[item]\n            max_item = item\n    return max_item"], [0.9338744282722473, "    frequency_dict = {}\n    for item in input_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    most_frequent_item = max(frequency_dict, key=frequency_dict.get)\n    return most_frequent_item"], [0.933148980140686, "    max_count = -1\n    max_item = None\n    counts = {}\n    for item in lst:\n        if item not in counts:\n            counts[item] = 0\n        counts[item] += 1\n        if counts[item] > max_count:\n            max_count = counts[item]\n            max_item = item\n    return max_item"], [0.9331010580062866, "    freq = {}\n    for item in list:\n        if item not in freq:\n            freq[item] = 1\n        else:\n            freq[item] += 1\n    max_freq = -1\n    for key in freq.keys():\n        if freq[key] > max_freq:\n            max_freq = freq[key]\n            res = key\n    return res"]]}
{"task_id": "MBPP/120", "problem": [[0.9315897226333618, "    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    reverse_string = ''\n    for char in reversed(string):\n        if char not in vowels:\n            reverse_string += char\n    return reverse_string"], [0.9278151988983154, "    vowels = 'aeiouAEIOU'\n    replaced = ''.join([char if c in vowels else c for c in string])\n    return replaced[::-1]"], [0.9271721839904785, "    vowels = ['a', 'e', 'i', 'o', 'u']\n    output_str = ''\n    for letter in input_str:\n        if letter not in vowels:\n            output_str += letter\n    return output_str[::-1]"], [0.9270474314689636, "    vowels = 'aeiouAEIOU'\n    result = ''\n    for char in string:\n        if char not in vowels:\n            result += char\n    return result[::-1]"], [0.9257559180259705, "    vowels = ['A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u']\n    output = ''\n    for char in string:\n        if char not in vowels:\n            output += char\n    return output[::-1]"], [0.9248135089874268, "    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    reversed_string = ''\n    for char in original_string[::-1]:\n        if char not in vowels:\n            reversed_string += char\n    return reversed_string"], [0.9244412779808044, "    vowels = reverse_vowels(paragraph, len(paragraph) - 1)\n    vowels = list(dict.fromkeys(vowels))\n    print(' '.join(vowels))"], [0.9238820672035217, "    vowels = ['a', 'e', 'i', 'o', 'u']\n    consonants = []\n    for char in string:\n        if char.lower() not in vowels and char.isalpha():\n            consonants.append(char)\n    consonants.reverse()\n    reversed_string = ''\n    consonant_index = 0\n    for char in string:\n        if char.lower() not in vowels and char.isalpha():\n            reversed_string += consonants[consonant_index]\n            consonant_index += 1\n        else:\n            reversed_string += char\n    return reversed_string"], [0.9226611852645874, "    vowels = ['a', 'e', 'i', 'o', 'u']\n    result = ''\n    for char in text:\n        if char.lower() in vowels:\n            result += char.lower()\n    return result[::-1]"], [0.9215604662895203, "    for char in reversed(string):\n        if char not in vowels:\n            reverse_string += char"]]}
{"task_id": "MBPP/121", "problem": [[0.9010260105133057, "    if not tup:\n        return 'Error: Tuple is empty.'"], [0.8996692299842834, "    if not tup:\n        return 'Error: Tuple is empty'"], [0.8980015516281128, "    if not input_tuple:\n        return 'Error: input is NULL or empty.'\n    str_list = []\n    for element in input_tuple:\n        if not isinstance(element, float):\n            return 'Error: all elements in the tuple should be floats.'\n        str_list.append(str(element))\n    result = '; '.join(str_list)\n    return result"], [0.8968623876571655, "    if tup == ():\n        return 'Error: Tuple is empty'"], [0.896592378616333, "    if not my_tuple:\n        return 'Error: Tuple is empty!'"], [0.8953713178634644, "    if not tup:\n        return 'Error: Input tuple is empty'"], [0.8953713178634644, "    if not tup:\n        return 'Error: Input tuple is empty'"], [0.8943520188331604, "    if type(tup) != tuple:\n        return 'Error: Not a tuple.'"], [0.8878452181816101, "    if len(tup) == 0:\n        return 'Error: Empty tuple'"], [0.8874856233596802, "    string = ','.join(map(str, lst))\n    return string"]]}
{"task_id": "MBPP/122", "problem": [[0.9149158000946045, "    negative_nums = [num for num in numbers if num < 0]\n    return (len(negative_nums), sum(negative_nums))"], [0.8992920517921448, "    neg_lst = []\n    for num in lst:\n        if num < 0:\n            neg_lst.append(num)\n    return neg_lst"], [0.8971871733665466, "    total = 0\n    negative_count = 0\n    for number in list_of_numbers:\n        total += int(number)\n        if number < 0:\n            negative_count += 1\n    return f'Result: {round(total)}, Negative numbers: {negative_count}'"], [0.8957844376564026, "    negative_elements = []\n    for x in my_list:\n        if x < 0:\n            negative_elements.append(x)\n    return negative_elements"], [0.8925778865814209, "    input_list = [1, -2, 3, -4, 5]\n    expected_output = [-2, -4]\n    assert negative(input_list) == expected_output"], [0.8903428316116333, "    square_list = negative_even_squares(lst)\n    return sum(square_list)"], [0.8897733688354492, "    for number in list_of_numbers:\n        total += int(number)\n        if number < 0:\n            negative_count += 1"], [0.8892818689346313, "    if isinstance(numbers[0], list):\n        return [[num for num in sublist if num < 0] for sublist in numbers]\n    else:\n        return [num for num in numbers if num < 0]"], [0.8892818689346313, "    if isinstance(numbers[0], list):\n        return [[num for num in sublist if num < 0] for sublist in numbers]\n    else:\n        return [num for num in numbers if num < 0]"], [0.8890563249588013, "    elif numbers[0] < 0:\n        return sum_positive_numbers(numbers[1:])\n    else:\n        return numbers[0] + sum_positive_numbers(numbers[1:])"]]}
{"task_id": "MBPP/123", "problem": [[0.8867087364196777, "    num_elements = len(arr)\n    if num_elements % 2 == 0:\n        print('The array has an even number of elements.')\n    else:\n        print('The array has an odd number of elements.')"], [0.8805287480354309, "    if result != -1:\n        return arr[result] % 2 != 0\n    else:\n        print('Number not found in the array')\n        return False"], [0.8786710500717163, "    odd_count, even_count = (0, 0)\n    for i in arr:\n        if i % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    print('Odd count : ', odd_count, 'Even count : ', even_count)"], [0.8785127401351929, "    if last_digit % 2 == 0:\n        return 'Even'\n    else:\n        return 'Odd'"], [0.8784864544868469, "    if not isinstance(large_number, str):\n        return 'Error: Input should be a string of digits'\n    if not large_number.isdigit():\n        return 'Error: Input should be all digits'\n    last_digit = int(large_number[-1])\n    if last_digit % 2 == 0:\n        return 'Even'\n    else:\n        return 'Odd'"], [0.8773033618927002, "    for num in arr:\n        if num % 2 == 0:\n            count_even += 1\n        else:\n            break"], [0.8771135807037354, "    result = binary_search(arr, num)\n    if result != -1:\n        return arr[result] % 2 != 0\n    else:\n        print('Number not found in the array')\n        return False"], [0.8770992755889893, "    odd_elements = [x for x in array if x % 2 == 1]\n    return (len(odd_elements) % 2 == 1, len(odd_elements), sum(odd_elements))"], [0.8753480911254883, "    odd_count = 0\n    for num in lst:\n        if num % 2 != 0:\n            odd_count += 1\n    return (odd_count, odd_count % 2 != 0)"]]}
{"task_id": "MBPP/124", "problem": [[0.9147540926933289, "    while True:\n        hexagonal = n * (2 * n - 1)\n        if isPentagonal(hexagonal):\n            return hexagonal\n        n += 1"], [0.9034406542778015, "    n = 144\n    while True:\n        hexagonal = n * (2 * n - 1)\n        if isPentagonal(hexagonal):\n            return hexagonal\n        n += 1\n    return None"], [0.9014877676963806, "        if isPentagonal(hexagonal):\n            return hexagonal"], [0.9000658392906189, "        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4"], [0.9000391960144043, "        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4"], [0.8954226970672607, "    if type(n) != int or n < 0:\n        return 'ERROR: Invalid Input'\n    if n > 5000:\n        return 'ERROR: Input number too large'\n    if n in computed:\n        return computed[n]\n    computed[n] = n * (5 * n - 3) / 2 + heptagonal(n - 1)\n    return computed[n]"], [0.8870831727981567, "    try:\n        assert isinstance(n, (int, float))\n        assert n >= 0\n        assert n == int(n)\n        return hex(int(n))\n    except AssertionError:\n        return 'Error: Invalid input. Please enter a non-negative integer.'"], [0.8870831727981567, "    try:\n        assert isinstance(n, (int, float))\n        assert n >= 0\n        assert n == int(n)\n        return hex(int(n))\n    except AssertionError:\n        return 'Error: Invalid input. Please enter a non-negative integer.'"], [0.8853275775909424, "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"], [0.8853275775909424, "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"]]}
{"task_id": "MBPP/125", "problem": [[0.9243404865264893, "    rate = 0.15\n    bill = kw_usage * rate\n    return bill"], [0.9217908382415771, "    bill = rate * consumption\n    print('Your total electricity bill is Rs. {}'.format(bill))"], [0.8981921672821045, "    one_off_fee = one_off\n    night_rate_fee = night_rate * total_kwh\n    standard_rate_fee = standard_rate * total_kwh\n    return one_off_fee + night_rate_fee + standard_rate_fee"], [0.8748081922531128, "    if 7 <= hour <= 10 or 16 <= hour <= 20:\n        basic_cost *= 1.15"], [0.8725548982620239, "    cost_per_minute = 0.35\n    total_cost = cost_per_minute * call_duration\n    return total_cost"], [0.8708776235580444, "    ELECTRICITY_EMISSIONS = 0.0005\n    GAS_EMISSIONS = 0.0053\n    VEHICLE_EMISSIONS = 0.00012\n    electricity_emissions = ELECTRICITY_EMISSIONS * electricity_consumption\n    gas_emissions = GAS_EMISSIONS * gas_consumption\n    vehicle_emissions = VEHICLE_EMISSIONS * mileage\n    total_emissions = (electricity_emissions + gas_emissions + vehicle_emissions) * 12 * num_people\n    total_emissions = total_emissions / 1000\n    return total_emissions"], [0.8708698153495789, "    ELECTRICITY_EMISSIONS = 0.0005\n    GAS_EMISSIONS = 0.0053\n    VEHICLE_EMISSIONS = 0.00012\n    electricity_emissions = ELECTRICITY_EMISSIONS * electricity_consumption\n    gas_emissions = GAS_EMISSIONS * gas_consumption\n    vehicle_emissions = VEHICLE_EMISSIONS * mileage\n    total_emissions = (electricity_emissions + gas_emissions + vehicle_emissions) * 12 * num_people\n    total_emissions = total_emissions / 1000\n    return total_emissions"], [0.8699816465377808, "    total_consumption = 0\n    for record in data:\n        total_consumption += record\n    average_consumption = total_consumption / len(data)\n    return average_consumption"], [0.8695898056030273, "    if order_total < 50:\n        return 'Order total does not meet the minimum amount required to avail of discounts.'\n    total_bill = order_total\n    if num_customers <= 5:\n        total_bill *= 0.95\n    elif num_customers <= 10:\n        total_bill *= 0.9\n    else:\n        total_bill *= 0.85\n    return round(total_bill, 2)"], [0.8682438731193542, "    elif num_customers <= 10:\n        total_bill *= 0.9\n    else:\n        total_bill *= 0.85"]]}
{"task_id": "MBPP/126", "problem": [[0.9053391218185425, "    count = 0\n    for num in list:\n        if num == 0:\n            count += 1\n    return count"], [0.8973792195320129, "    for num in list:\n        if num == 0:\n            count += 1"], [0.8919491171836853, "    binary = str(bin(n)[2:])\n    zeroes = binary.count('0')\n    ones = binary.count('1')\n    if ones == 0:\n        print('Cannot calculate the ratio with zero ones')\n        return None\n    return zeroes / ones"], [0.8908119797706604, "    count = 0\n    for i in arr:\n        if i != 0:\n            count += 1\n    return count"], [0.8885155916213989, "    nums = [n for n in nums if n > 0]\n    if len(nums) == 0:\n        return 0\n    total = 0\n    for num in nums:\n        total += 1 / num\n    return len(nums) / total"], [0.8883742690086365, "    for i in arr:\n        if i != 0:\n            count += 1"], [0.8871414661407471, "    if len(arr) == 0:\n        return 0\n    num_positive = 0\n    for num in arr:\n        if num > 0:\n            num_positive += 1\n    return num_positive / len(arr)"], [0.8865721821784973, "    if ones == 0:\n        print('Cannot calculate the ratio with zero ones')\n        return None"], [0.8838329315185547, "    arr.sort(reverse=True)\n    positive_count = 0\n    negative_count = 0\n    zero_count = 0\n    for number in arr:\n        category = classify_number(number)\n        if category == 'positive':\n            positive_count += 1\n        elif category == 'negative':\n            negative_count += 1\n        else:\n            zero_count += 1\n    print('Positive numbers: ', positive_count)\n    print('Negative numbers: ', negative_count)\n    print('Zeroes: ', zero_count)"], [0.8833995461463928, "    zero_count = 0\n    for row in matrix:\n        for num in row:\n            if strict_zero:\n                if num == 0:\n                    zero_count += 1\n            elif num == 0 or num == '' or num == '0' or (num == '-0') or (num == False):\n                zero_count += 1\n    return zero_count"]]}
{"task_id": "MBPP/127", "problem": [[0.9027656316757202, "    if num == 0:\n        print('False')\n    elif num == 1:\n        print('True')\n    else:\n        series = ''\n        while num > 0:\n            if num & 1:\n                series = 'True ' + series\n            else:\n                series = 'False ' + series\n            num = int(num / 2)\n        print(series)"], [0.9027656316757202, "    if num == 0:\n        print('False')\n    elif num == 1:\n        print('True')\n    else:\n        series = ''\n        while num > 0:\n            if num & 1:\n                series = 'True ' + series\n            else:\n                series = 'False ' + series\n            num = int(num / 2)\n        print(series)"], [0.9015612006187439, "    elif num == 1:\n        print('True')\n    else:\n        series = ''\n        while num > 0:\n            if num & 1:\n                series = 'True ' + series\n            else:\n                series = 'False ' + series\n            num = int(num / 2)\n        print(series)"], [0.9010086059570312, "    i = 1\n    while 2 ** i <= n:\n        if 2 ** i == n:\n            return True\n        i += 1\n    return False"], [0.8988006711006165, "    if num == 1:\n        return True\n    elif num < 1:\n        return False\n    else:\n        while num % 2 == 0:\n            num /= 2\n        return num == 1"], [0.8988006711006165, "    if num == 1:\n        return True\n    elif num < 1:\n        return False\n    else:\n        while num % 2 == 0:\n            num /= 2\n        return num == 1"], [0.8985408544540405, "    while num != 1:\n        if num % 2 != 0:\n            return False\n        num = num // 2"], [0.8985105752944946, "    while number > 1:\n        if number % 2 != 0:\n            return False\n        number //= 2"], [0.8977659940719604, "    if num == 0:\n        return False\n    while num != 1:\n        if num % 2 != 0:\n            return False\n        num = num // 2\n    return True"], [0.8977534770965576, "    return sorted(str(n)) in [sorted(str(1 << i)) for i in range(31)]"]]}
{"task_id": "MBPP/128", "problem": [[0.9331883192062378, "    circumference = 2 * 3.14 * radius\n    return circumference"], [0.9226394891738892, "    circumference = 3.14 * diameter\n    return circumference"], [0.9219996929168701, "    approximation_pi = 3.14\n    circumference = 2 * approximation_pi * radius\n    return circumference"], [0.9178048968315125, "    radius = ''.join(filter(str.isdigit, radius))\n    radius = float(radius)\n    circumference = 2 * math.pi * radius\n    return circumference"], [0.9116281867027283, "    radius = ''.join(filter(str.isdigit, radius))\n    if not radius.isdigit():\n        return 'Error: Invalid radius input'\n    radius = float(radius)\n    circumference = 2 * math.pi * radius\n    return circumference"], [0.9112057685852051, "    pi = 3.14\n    circumference = 2 * pi * r\n    area = pi * r ** 2\n    return (circumference, area)"], [0.9111831188201904, "    pi = 3.14\n    circumference = 2 * pi * r\n    area = pi * r ** 2\n    return (circumference, area)"], [0.9089893698692322, "    circ = 2 * 3.14 * radius\n    return circ"]]}
{"task_id": "MBPP/129", "problem": [[0.8925157189369202, "    singleton_list = []\n    for i in arr:\n        if arr.count(i) == 1:\n            singleton_list.append(i)\n    return singleton_list"], [0.8911830186843872, "    dic = {}\n    for el in lst:\n        if el in dic:\n            dic[el] += 1\n        else:\n            dic[el] = 1\n    return [k for k, v in dic.items() if v == 1]"], [0.8888763189315796, "    unpaired_element = []\n    for i in my_list:\n        if my_list.count(i) == 1:\n            unpaired_element.append(i)\n    return unpaired_element"], [0.8848763108253479, "    flattened = [item for sublist in array for item in sublist]\n    counter = Counter(flattened)\n    uniques = {k: v for k, v in counter.items() if v == 1}\n    return uniques"], [0.8837956786155701, "    for i in arr:\n        if arr.count(i) == 1:\n            singleton_list.append(i)"], [0.883663535118103, "        if e in element_counts and element_counts[e] == 1:\n            output.append(e)\n            del element_counts[e]"], [0.883639931678772, "        if e in element_counts and element_counts[e] == 1:\n            output.append(e)\n            del element_counts[e]"], [0.8830064535140991, "    extracted = []\n    unique_elements = set()\n    for element in lst:\n        if element not in unique_elements:\n            extracted.append(element)\n            unique_elements.add(element)\n        if len(extracted) == 3:\n            break\n    return extracted"], [0.8815646171569824, "    for element, count in counter.items():\n        if count == 1:\n            result.append(element)"], [0.8799132108688354, "    for i in my_list:\n        if my_list.count(i) == 1:\n            unpaired_element.append(i)"]]}
{"task_id": "MBPP/130", "problem": []}
{"task_id": "MBPP/131", "problem": [[0.9106860160827637, "    countA = Counter(groupA)\n    countB = Counter(groupB)\n    countC = Counter(groupC)\n    common = {}\n    for element in countA:\n        if element in countB and element in countC:\n            common[element] = (countA[element], countB[element], countC[element])\n    return common"], [0.9084304571151733, "    common_elements = []\n    for i in list1:\n        exists_list_2 = False\n        exists_list_3 = False\n        for j in list2:\n            if i == j:\n                exists_list_2 = True\n                break\n        if exists_list_2:\n            for k in list3:\n                if i == k:\n                    exists_list_3 = True\n                    break\n        if exists_list_2 and exists_list_3 and (i not in common_elements):\n            common_elements.append(i)\n    return common_elements"], [0.9061894416809082, "    for element in countA:\n        if element in countB and element in countC:\n            common[element] = (countA[element], countB[element], countC[element])"], [0.9045130014419556, "    common = []\n    for a, b, c in zip(l1, l2, l3):\n        if a == b == c:\n            common.append(a)\n    return common"], [0.9021159410476685, "    for i in list1:\n        exists_list_2 = False\n        exists_list_3 = False\n        for j in list2:\n            if i == j:\n                exists_list_2 = True\n                break\n        if exists_list_2:\n            for k in list3:\n                if i == k:\n                    exists_list_3 = True\n                    break\n        if exists_list_2 and exists_list_3 and (i not in common_elements):\n            common_elements.append(i)"], [0.8982482552528381, "    return (len(set(s1)), len(set(s2)), len(set(s3)))"], [0.8969337940216064, "    count = 0\n    for elem in list1:\n        if elem in list2:\n            count += list2.count(elem)\n    return count"], [0.8964918255805969, "    if len(list1) == len(list2) == len(list3):\n        merged_list = []\n        results = []\n        for i in range(len(list1)):\n            tuple_elem = (list1[i], list2[i], list3[i])\n            merged_list.append(tuple_elem)\n            results.append(len(list1[i]) * list2[i])\n        return (merged_list, results)\n    else:\n        raise ValueError('Lists do not have equal lengths.')"], [0.8964918255805969, "    if len(list1) == len(list2) == len(list3):\n        merged_list = []\n        results = []\n        for i in range(len(list1)):\n            tuple_elem = (list1[i], list2[i], list3[i])\n            merged_list.append(tuple_elem)\n            results.append(len(list1[i]) * list2[i])\n        return (merged_list, results)\n    else:\n        raise ValueError('Lists do not have equal lengths.')"], [0.8961509466171265, "    index1 = index2 = index3 = 0\n    common_elements = []\n    while index1 < len(list1) and index2 < len(list2) and (index3 < len(list3)):\n        if list1[index1] == list2[index2] == list3[index3]:\n            common_elements.append(list1[index1])\n            index1 += 1\n            index2 += 1\n            index3 += 1\n        else:\n            min_value = min(list1[index1], list2[index2], list3[index3])\n            if list1[index1] == min_value:\n                index1 += 1\n            if list2[index2] == min_value:\n                index2 += 1\n            if list3[index3] == min_value:\n                index3 += 1\n    return common_elements"]]}
{"task_id": "MBPP/132", "problem": [[0.8973737955093384, "    unique_lists = {}\n    for lst in lists:\n        if len(set(lst)) == 1 and len(lst) != 0:\n            frozen = frozenset(lst)\n            if frozen in unique_lists:\n                unique_lists[frozen] += 1\n            else:\n                unique_lists[frozen] = 1\n    return sum(unique_lists.values())"], [0.8955939412117004, "    count = 0\n    for _ in lst:\n        count += 1\n    return count"], [0.8955812454223633, "    count = 0\n    for _ in lst:\n        count += 1\n    return count"], [0.894436240196228, "    count = 0\n    for elem in lst:\n        count += 1\n    return count"], [0.8919609189033508, "    count = 0\n    for element in lst:\n        count = count + 1\n    return count"], [0.8914488554000854, "    count = 0\n    for element in lst:\n        count += 1\n    return count"], [0.8908356428146362, "    count = 0\n    for item in lst:\n        count += 1\n    return count"], [0.8904765844345093, "    count = 0\n    for element in nested_list:\n        if type(element) == list:\n            count += count_elements(element)\n        else:\n            count += 1\n    return count"], [0.8903590440750122, "    count = 0\n    for element in nested_list:\n        if type(element) is list:\n            count += count_elements(element)\n        else:\n            count += 1\n    return count"], [0.8902847766876221, "    lst = flatten(lst)\n    counts = dict()\n    for sublist in lst:\n        if isinstance(sublist, list):\n            sublist = tuple(flatten(sublist))\n        if isinstance(sublist, tuple):\n            counts[sublist] = counts.get(sublist, 0) + 1\n    return counts"]]}
{"task_id": "MBPP/133", "problem": [[0.9059621691703796, "    n = len(ints)\n    sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum += abs(ints[i] - ints[j])\n    return sum"], [0.9043521881103516, "    total = 0\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            total += abs(arr[i] - arr[j])\n    return total"], [0.9026889801025391, "    abs_diff_sum = 0\n    for i in range(len(arr) - 1):\n        abs_diff_sum += abs(arr[i] - arr[i + 1])\n    return abs_diff_sum"], [0.9003070592880249, "    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            total += abs(arr[i] - arr[j])"], [0.8961650729179382, "    for i in range(n):\n        for j in range(i + 1, n):\n            sum += abs(ints[i] - ints[j])"], [0.8946145176887512, "    for i in range(len(arr) - 1):\n        abs_diff_sum += abs(arr[i] - arr[i + 1])"], [0.8939578533172607, "        for j in range(i + 1, len(arr)):\n            total += abs(arr[i] - arr[j])"], [0.8917484879493713, "    n = len(a)\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += a[i] - a[j]\n    return ans"], [0.8911859393119812, "    sum_list1 = sum(list1)\n    sum_list2 = sum(list2)\n    return abs(sum_list1 - sum_list2)"], [0.8902713656425476, "        for j in range(i + 1, n):\n            sum += abs(ints[i] - ints[j])"]]}
{"task_id": "MBPP/134", "problem": [[0.9294489622116089, "    max_difference = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            diff = abs(arr[i] - arr[j])\n            if diff > max_difference:\n                max_difference = diff\n    return max_difference"], [0.9290218353271484, "    max_difference = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] - arr[i] > max_difference:\n                max_difference = arr[j] - arr[i]\n    return max_difference"], [0.9270819425582886, "    maxDifference = 0\n    for i in range(len(elementList)):\n        for j in range(i + 1, len(elementList)):\n            if elementList[j] - elementList[i] > maxDifference:\n                maxDifference = elementList[j] - elementList[i]\n    return maxDifference"], [0.9255038499832153, "    max_diff = 0\n    for i in range(0, len(arr)):\n        for j in range(i + 1, len(arr)):\n            diff = arr[j] - arr[i]\n            if diff > max_diff:\n                max_diff = diff\n    return max_diff"], [0.9254050850868225, "    max_difference = -float('inf')\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            diff = abs(arr[i] - arr[j])\n            if diff > max_difference:\n                max_difference = diff\n    return max_difference"], [0.9254024624824524, "    if len(arr) < 2:\n        return 0\n    min_value = arr[0]\n    max_value = arr[0]\n    max_diff = 0\n    for i in range(1, len(arr)):\n        if arr[i] < min_value:\n            min_value = arr[i]\n        elif arr[i] > max_value:\n            max_value = arr[i]\n        diff = max_value - min_value\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff"], [0.9227374196052551, "    max_diff = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            diff = abs(arr[i] - arr[j])\n            if diff > max_diff:\n                max_diff = diff\n    return max_diff"], [0.9226309061050415, "    maxDifference = 0\n    maxDifferencePair = ()\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            difference = abs(arr[i] - arr[j])\n            if difference > maxDifference:\n                maxDifference = difference\n                maxDifferencePair = (arr[i], arr[j])\n    return maxDifferencePair"], [0.9224757552146912, "    min_value = arr[0]\n    max_value = arr[0]\n    max_diff = 0\n    for num in arr:\n        if num < min_value:\n            min_value = num\n        if num > max_value:\n            max_value = num\n        if max_value - min_value > max_diff:\n            max_diff = max_value - min_value\n    return max_diff"], [0.9221924543380737, "    max_diff = 0\n    for i in range(0, len(arr) - 1):\n        diff = arr[i + 1] - arr[i]\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff"]]}
{"task_id": "MBPP/135", "problem": [[0.9438853859901428, "    total = 0\n    for char in string:\n        total += ord(char)\n    return total"], [0.9438703060150146, "    total = 0\n    for char in string:\n        total += ord(char)\n    return total"], [0.9393199682235718, "        for character in string:\n            total_ascii_value += ord(character)"], [0.9393161535263062, "        for character in string:\n            total_ascii_value += ord(character)"], [0.9391916990280151, "    sum_ascii = 0\n    for char in string:\n        sum_ascii += ord(char)\n    return sum_ascii"], [0.9315598011016846, "    ascii_sum = 0\n    for char in string:\n        if char.isalpha():\n            ascii_sum += ord(char)\n    return ascii_sum"], [0.931370735168457, "        for i in s:\n            ascii_val = ord(i)\n            print(f'ASCII value of {i} is {ascii_val}')\n            total_sum += ascii_val"], [0.9307945966720581, "    total_ascii_value = 0\n    for string in string_list:\n        for character in string:\n            total_ascii_value += ord(character)\n    return total_ascii_value"], [0.9307920932769775, "    total_ascii_value = 0\n    for string in string_list:\n        for character in string:\n            total_ascii_value += ord(character)\n    return total_ascii_value"], [0.9301753044128418, "    total_sum = 0\n    for s in strings:\n        for i in s:\n            ascii_val = ord(i)\n            print(f'ASCII value of {i} is {ascii_val}')\n            total_sum += ascii_val\n    return total_sum"]]}
{"task_id": "MBPP/136", "problem": [[0.9145236015319824, "    n = len(triangle)\n    for i in range(n - 2, -1, -1):\n        for j in range(i + 1):\n            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n    return triangle[0][0]"], [0.9084618091583252, "    size_triangle = range(len(triangle) - 1, -1, -1)\n    for i in size_triangle:\n        for j in range(i):\n            if triangle[i][j] > triangle[i][j + 1]:\n                triangle[i - 1][j] += triangle[i][j]\n            else:\n                triangle[i - 1][j] += triangle[i][j + 1]\n    return triangle[0][0]"], [0.9070276021957397, "        for j in range(i + 1):\n            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])"], [0.8987568616867065, "    for i in range(n - 2, -1, -1):\n        for j in range(i + 1):\n            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])"], [0.8960947394371033, "            if triangle[i][j] > triangle[i][j + 1]:\n                triangle[i - 1][j] += triangle[i][j]\n            else:\n                triangle[i - 1][j] += triangle[i][j + 1]"], [0.8937019109725952, "    sum_list = [sum(row) for row in arr]\n    max_element = max(sum_list)\n    return max_element"], [0.8928487300872803, "    rows = len(grid)\n    cols = len(grid[0])\n    max_sum = [[0] * cols for _ in range(rows)]\n    max_sum[0][0] = grid[0][0]\n    for j in range(1, cols):\n        max_sum[0][j] = max_sum[0][j - 1] + grid[0][j]\n    for i in range(1, rows):\n        max_sum[i][0] = max_sum[i - 1][0] + grid[i][0]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            max_sum[i][j] = max(max_sum[i - 1][j], max_sum[i][j - 1]) + grid[i][j]\n    return max_sum[rows - 1][cols - 1]"], [0.8913647532463074, "    if not triangle:\n        return\n    res = triangle[-1]\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            res[j] = min(res[j], res[j + 1]) + triangle[i][j]\n    return res[0]"], [0.8908165693283081, "    if index >= len(arr):\n        return 0\n    if index == 2:\n        return max(arr[index] + arr[index - 1] + arr[index - 2], 0)\n    return arr[index] + sum_of_first_three(arr, index + 1)"], [0.8905106782913208, "        for j in range(i):\n            if triangle[i][j] > triangle[i][j + 1]:\n                triangle[i - 1][j] += triangle[i][j]\n            else:\n                triangle[i - 1][j] += triangle[i][j + 1]"]]}
{"task_id": "MBPP/137", "problem": [[0.8963073492050171, "    return [num // 2, num % 2]"], [0.89063560962677, "    nums.sort()\n    n = len(nums)\n    first_part = []\n    second_part = []\n    sum_first_part = 0\n    sum_second_part = 0\n    for i in range(n - 1, -1, -1):\n        if sum_first_part >= 2 * sum_second_part:\n            second_part.append(nums[i])\n            sum_second_part += nums[i]\n        else:\n            first_part.append(nums[i])\n            sum_first_part += nums[i]\n    return (first_part, second_part)"], [0.8905006647109985, "    result = [[], []]\n    total = sum(list)\n    half = total // 2\n    count = 0\n    while half > 0:\n        if half >= list[count]:\n            result[0].append(list[count])\n            half -= list[count]\n        else:\n            result[1].append(list[count])\n        count += 1\n    return result"], [0.89002525806427, "    l.sort()\n    i = 0\n    j = len(l) - 1\n    left_sum = l[i]\n    right_sum = l[j]\n    while i < j:\n        if left_sum < right_sum:\n            i += 1\n            left_sum += l[i]\n        else:\n            j -= 1\n            right_sum += l[j]\n    return (l[:i + 1], l[i + 1:])"], [0.8875942230224609, "    while half > 0:\n        if half >= list[count]:\n            result[0].append(list[count])\n            half -= list[count]\n        else:\n            result[1].append(list[count])\n        count += 1"], [0.8872085809707642, "    numbers = [int(n) for n in inputString.split(',')]\n    total = sum(numbers)\n    if total % 2 != 0:\n        return 'The sum of these numbers is not even, so partition is not possible.'\n    else:\n        half = total // 2\n        partition1, partition2 = ([], [])\n        for number in sorted(numbers, reverse=True):\n            if sum(partition1) + number <= half:\n                partition1.append(number)\n            else:\n                partition2.append(number)\n        return (partition1, partition2)"], [0.8870041370391846, "    sum_arr = sum(arr)\n    half_sum = sum_arr // 2\n    current_sum = 0\n    left_index = 0\n    for index, value in enumerate(arr):\n        current_sum += value\n        if current_sum >= half_sum:\n            left_index = index\n            break\n    left_arr = arr[:left_index + 1]\n    right_arr = arr[left_index + 1:]\n    return (left_arr, right_arr)"], [0.8865015506744385, "    if total % 2 != 0:\n        return 'The sum of these numbers is not even, so partition is not possible.'\n    else:\n        half = total // 2\n        partition1, partition2 = ([], [])\n        for number in sorted(numbers, reverse=True):\n            if sum(partition1) + number <= half:\n                partition1.append(number)\n            else:\n                partition2.append(number)\n        return (partition1, partition2)"], [0.8849446773529053, "    first_half = arr[:len(arr) // 2]\n    second_half = arr[len(arr) // 2:]\n    return [first_half, second_half]"], [0.8840380907058716, "    length = len(numbers)\n    mid = length // 2\n    list_a = numbers[:mid]\n    list_b = numbers[mid:]\n    return (list_a, list_b)"]]}
{"task_id": "MBPP/138", "problem": [[0.9189908504486084, "    current_subsequence = [arr[0]]\n    longest_subsequence = [arr[0]]\n    for i in range(1, len(arr)):\n        if arr[i] == arr[i - 1] + 1:\n            current_subsequence.append(arr[i])\n        else:\n            if len(current_subsequence) > len(longest_subsequence):\n                longest_subsequence = current_subsequence\n            current_subsequence = [arr[i]]\n    if len(current_subsequence) > len(longest_subsequence):\n        longest_subsequence = current_subsequence\n    return longest_subsequence"], [0.9163687825202942, "    longest_start = longest_end = prev_start = 0\n    for i in range(1, len(arr)):\n        if arr[i - 1] - arr[i] != 1:\n            if i - prev_start > longest_end - longest_start:\n                longest_start, longest_end = (prev_start, i)\n            prev_start = i\n    if len(arr) - prev_start > longest_end - longest_start:\n        longest_start, longest_end = (prev_start, len(arr))\n    return arr[longest_start:longest_end]"], [0.9163607358932495, "    longest_start = longest_end = prev_start = 0\n    for i in range(1, len(arr)):\n        if arr[i - 1] - arr[i] != 1:\n            if i - prev_start > longest_end - longest_start:\n                longest_start, longest_end = (prev_start, i)\n            prev_start = i\n    if len(arr) - prev_start > longest_end - longest_start:\n        longest_start, longest_end = (prev_start, len(arr))\n    return arr[longest_start:longest_end]"], [0.9137048721313477, "    for i in range(len(arr)):\n        currentLength = 1\n        for j in range(i + 1, len(arr)):\n            if arr[j] - arr[j - 1] == 1:\n                currentLength += 1\n            else:\n                break\n        if currentLength > maxLength:\n            maxLength = currentLength"], [0.9121592044830322, "    for i in range(1, len(arr)):\n        if arr[i] == arr[i - 1] + 1:\n            current_subsequence.append(arr[i])\n        else:\n            if len(current_subsequence) > len(longest_subsequence):\n                longest_subsequence = current_subsequence\n            current_subsequence = [arr[i]]"], [0.9117479920387268, "    for i in range(len(arr) - 1):\n        if arr[i + 1] == arr[i] + 1:\n            length += 1\n        else:\n            max_length = max(max_length, length)\n            length = 0"], [0.9117177724838257, "    max_length = 0\n    cur_length = 1\n    for i in range(len(arr) - 1):\n        if arr[i] + 1 == arr[i + 1]:\n            cur_length += 1\n        else:\n            if cur_length > max_length:\n                max_length = cur_length\n            cur_length = 1\n    if cur_length > max_length:\n        max_length = cur_length\n    return max_length"], [0.9093934297561646, "        if arr[i] == arr[i - 1] + 1:\n            current_subsequence.append(arr[i])\n        else:\n            if len(current_subsequence) > len(longest_subsequence):\n                longest_subsequence = current_subsequence\n            current_subsequence = [arr[i]]"], [0.9089694619178772, "    arr_set = set(arr)\n    max_length = 0\n    max_subsequence = []\n    for num in arr:\n        if num - 1 not in arr_set:\n            current_length = 0\n            current_subsequence = []\n            while num in arr_set:\n                current_length += 1\n                current_subsequence.append(num)\n                num += 1\n            if current_length > max_length and len(current_subsequence) > 1:\n                max_length = current_length\n                max_subsequence = current_subsequence\n    return (max_length, max_subsequence)"], [0.908937931060791, "    longest_sequence = []\n    current_sequence = []\n    current_num = None\n    for num in sorted(arr):\n        if current_num is None or num == current_num + 1:\n            current_sequence.append(num)\n            current_num = num\n        else:\n            if len(current_sequence) > len(longest_sequence) or (len(current_sequence) == len(longest_sequence) and current_sequence[0] < longest_sequence[0]):\n                longest_sequence = current_sequence\n            current_sequence = [num]\n            current_num = num\n    if len(current_sequence) > len(longest_sequence) or (len(current_sequence) == len(longest_sequence) and current_sequence[0] < longest_sequence[0]):\n        longest_sequence = current_sequence\n    return longest_sequence"]]}
{"task_id": "MBPP/139", "problem": [[0.9099154472351074, "    fib_sequence = fibonacci(num)\n    return num in fib_sequence"], [0.9072612524032593, "    i = 0\n    while True:\n        fib = fibonacci(i)\n        if fib > n:\n            return False\n        if fib == n:\n            return True\n        i += 1"], [0.9054486751556396, "    fib_seq = fibonacci(n)\n    return num in fib_seq"], [0.9048270583152771, "    a, b = (0, 1)\n    while b < my_number:\n        a, b = (b, a + b)\n    return b == my_number"], [0.9022553563117981, "    while True:\n        fib = fibonacci(i)\n        if fib > n:\n            return False\n        if fib == n:\n            return True\n        i += 1"], [0.9012467265129089, "    if n == 0:\n        return False\n    else:\n        while y < n:\n            z = x + y\n            x = y\n            y = z\n        if y == n:\n            return True\n        else:\n            return False"], [0.9008376598358154, "    a, b = (0, 1)\n    while a <= n:\n        if a == n:\n            return True\n        a, b = (b, a + b)\n    return False"], [0.9001076221466064, "    a, b = (0, 1)\n    while b <= n:\n        if b == n:\n            return True\n        a, b = (b, a + b)\n    return False"], [0.9000237584114075, "    while True:\n        fib = x + y\n        if fib > n:\n            return False\n        if fib == n:\n            return True\n        x = y\n        y = fib"], [0.9000113606452942, "    while True:\n        fib = x + y\n        if fib > n:\n            return False\n        if fib == n:\n            return True\n        x = y\n        y = fib"]]}
{"task_id": "MBPP/140", "problem": [[0.9103204011917114, "    if type(num1) != int or type(num2) != int:\n        raise TypeError('Both inputs must be integers')\n    if num1 < 0 or num2 < 0:\n        raise ValueError('Both integers must be positive')\n    if num2 == 0:\n        raise ValueError('The second integer cannot be zero')\n    if num1 % num2 == 0:\n        return True\n    if num1 <= 1:\n        raise ValueError('The first integer cannot be a prime number')\n    sqrt_num1 = math.isqrt(num1)\n    for i in range(2, sqrt_num1 + 1):\n        if num1 % i == 0:\n            raise ValueError('The first integer cannot be a prime number')\n    return False"], [0.9083164930343628, "    if math.gcd(a, b) == 1:\n        print(f'{a} and {b} are co-prime numbers.')\n    else:\n        print(f'{a} and {b} are not co-prime numbers.')"], [0.9083164930343628, "    if math.gcd(a, b) == 1:\n        print(f'{a} and {b} are co-prime numbers.')\n    else:\n        print(f'{a} and {b} are not co-prime numbers.')"], [0.9074428677558899, "    if a % b == 0 or b % a == 0:\n        return False"], [0.9073474407196045, "    a = float(a)\n    b = float(b)\n    if a < 2 or b < 2:\n        return False\n    for i in range(2, int(max(a, b)) + 1):\n        if a % i == 0 or b % i == 0:\n            return False\n    return True"], [0.9068929553031921, "    prime_check = range(2, n)\n    for i in prime_check:\n        if n % i == 0:\n            return False\n    return True"], [0.9053330421447754, "    array_length = len(arr)\n    if is_prime(array_length):\n        return 'Prime'\n    else:\n        return 'Composite'"], [0.9035671949386597, "    if n < 2:\n        return (False, 0)\n    else:\n        factors = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                factors += 1\n        if factors == 2:\n            return (True, factors)\n        else:\n            return (False, factors)"], [0.9035671949386597, "    if n < 2:\n        return (False, 0)\n    else:\n        factors = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                factors += 1\n        if factors == 2:\n            return (True, factors)\n        else:\n            return (False, factors)"], [0.903214156627655, "    assert is_prime(4) == 'no'\n    assert is_prime(3) == 'yes'\n    assert is_prime(8) == 'no'"]]}
{"task_id": "MBPP/141", "problem": []}
{"task_id": "MBPP/142", "problem": [[0.8795247077941895, "        if fa * fc < 0:\n            b = (a + b) / 2\n        elif fc * fb < 0:\n            a = (a + b) / 2\n        else:\n            raise Exception('Trisection algorithm failed to converge.')"], [0.8790855407714844, "    elif det == 0:\n        return [(-b + det) / (2 * a)]\n    elif det > 0:\n        return [(-b + det) / (2 * a), (-b - det) / (2 * a)]"], [0.8777413368225098, "        elif fc * fb < 0:\n            a = (a + b) / 2\n        else:\n            raise Exception('Trisection algorithm failed to converge.')"], [0.8774886131286621, "    while b - a >= 0.01:\n        c = (a + b) / 2\n        if equation(c) == 0.0:\n            break\n        elif equation(c) * equation(a) < 0:\n            b = c\n        else:\n            a = c"], [0.8762322664260864, "    parabola_distance, error = integrate.quad(parabolic_distance, -4, 0, args=a)\n    straight_distance = sqrt(4 ** 2 + 3 ** 2)\n    return parabola_distance + straight_distance"], [0.8760577440261841, "    max_iterations = 1000\n    iteration = 0\n    while abs(b - a) > epsilon and iteration < max_iterations:\n        fa = f(a)\n        fc = f((a + b) / 2)\n        fb = f(b)\n        if abs(fa) < epsilon:\n            return a\n        if abs(fc) < epsilon:\n            return (a + b) / 2\n        if abs(fb) < epsilon:\n            return b\n        if fa * fc < 0:\n            b = (a + b) / 2\n        elif fc * fb < 0:\n            a = (a + b) / 2\n        else:\n            raise Exception('Trisection algorithm failed to converge.')\n        iteration += 1\n    return (a + b) / 2"], [0.8748914003372192, "    if equation(a) * equation(b) >= 0:\n        print('Invalid interval. The signs of the equation results for a and b should be opposite.')\n        return\n    c = a\n    while b - a >= 0.01:\n        c = (a + b) / 2\n        if equation(c) == 0.0:\n            break\n        elif equation(c) * equation(a) < 0:\n            b = c\n        else:\n            a = c\n    print('The value of root is : ', '%.4f' % c)"], [0.8746674060821533, "    discriminant = (b ** 2 - 4 * a * c) ** 0.5\n    x1 = (-b + discriminant) / (2 * a)\n    x2 = (-b - discriminant) / (2 * a)\n    return (x1, x2)"], [0.8739153146743774, "    x1 = (-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)\n    x2 = (-b - (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)\n    return (x1, x2)"], [0.873586893081665, "    if d >= 0:\n        sqrt_d = sqrt(d)\n        x1 = (-b + sqrt_d) / (2 * a)\n        x2 = (-b - sqrt_d) / (2 * a)\n        if x1 < x2:\n            return x1\n        else:\n            return x2\n    else:\n        return None"]]}
{"task_id": "MBPP/143", "problem": [[0.8952887058258057, "    extracted_elements = []\n    for i in range(3):\n        extracted_elements.append(lst[i])\n    return extracted_elements"], [0.8930913805961609, "    indices = []\n    for i in range(len(array)):\n        for j in range(len(array[i])):\n            if array[i][j] == element:\n                indices.append((i, j))\n    return indices"], [0.8846510052680969, "    for i in range(3):\n        extracted_elements.append(lst[i])"], [0.8840104341506958, "    flattened_list = []\n    for row in input_list:\n        for column in row:\n            flattened_list.append(column)\n    return flattened_list"], [0.8838620185852051, "    if len(my_list) < n:\n        return 'Error: List contains less than n elements'\n    elif isinstance(my_list[0], list):\n        return [x[2] for x in my_list if len(x) >= 3]\n    else:\n        return my_list[2]"], [0.8838620185852051, "    if len(my_list) < n:\n        return 'Error: List contains less than n elements'\n    elif isinstance(my_list[0], list):\n        return [x[2] for x in my_list if len(x) >= 3]\n    else:\n        return my_list[2]"], [0.8837563991546631, "    combined_list = []\n    for lst in list_data:\n        combined_list.append(lst[1])\n    return combined_list"], [0.8827648758888245, "    locations = []\n    for row_idx, row in enumerate(multi_dim_array):\n        for col_idx, col in enumerate(row):\n            if col == element:\n                locations.append((row_idx, col_idx))\n    return locations"], [0.8819323182106018, "    result = []\n    for i in list1:\n        if i in tuple1:\n            result.append(i)\n    return result"], [0.8817703723907471, "    column_index = t[1]\n    column_values = [row[column_index] for row in grid]\n    return column_values"]]}
{"task_id": "MBPP/144", "problem": [[0.8916226625442505, "    while n & mask:\n        n ^= mask\n        mask <<= 1"], [0.8858827352523804, "    while n:\n        parity ^= n & 1\n        n >>= 1"], [0.8858059048652649, "    parity = 0\n    while n:\n        parity ^= n & 1\n        n >>= 1\n    return parity"], [0.885300874710083, "    for num in a:\n        binary_num = bin(num)[2:]\n        transformed_num = num ^ num << 1 ^ num & num << 1 ^ num & num << 1 & num << 2\n        result.append(transformed_num)"], [0.8852225542068481, "    if n == 0:\n        return 0\n    else:\n        return n & 1 ^ check_parity(n >> 1)"], [0.8852225542068481, "    if n == 0:\n        return 0\n    else:\n        return n & 1 ^ check_parity(n >> 1)"], [0.8852190375328064, "    if n == 0:\n        return 0\n    else:\n        return n & 1 ^ check_parity(n >> 1)"], [0.8852190375328064, "    if n == 0:\n        return 0\n    else:\n        return n & 1 ^ check_parity(n >> 1)"], [0.8841120004653931, "        if num & 1 == 0:\n            even.append(num)\n        else:\n            odd.append(num)"], [0.8831467032432556, "    mask = 1\n    while n & mask:\n        n ^= mask\n        mask <<= 1\n    n ^= mask\n    return n"]]}
{"task_id": "MBPP/145", "problem": [[0.90758216381073, "    return [int(string) for string in strings]"], [0.9013752937316895, "    list_of_integers = []\n    for string in list_of_strings:\n        list_of_integers.append(int(string))\n    return list_of_integers"], [0.8999233841896057, "    return [int(i) for i in string_list]"], [0.895456075668335, "    return [str_to_int[val] for val in str_values.split(', ')]"], [0.8928995728492737, "    return [int(s, 0) for s in str_list]"], [0.8906060457229614, "    string_list = input_string.split()\n    return [int(item) for item in string_list]"], [0.889095664024353, "    return [int(x) for x in string.split(',')]"]]}
{"task_id": "MBPP/146", "problem": [[0.9112828969955444, "    if not list_to_encode:\n        return []\n    else:\n        tmp = []\n        tmp.append(list_to_encode[0])\n        tmp.append(1)\n        i = 1\n        while i < len(list_to_encode) and list_to_encode[i] == tmp[0]:\n            tmp[1] += 1\n            i += 1\n        return tmp + encodeList(list_to_encode[i:])"], [0.9112828969955444, "    if not list_to_encode:\n        return []\n    else:\n        tmp = []\n        tmp.append(list_to_encode[0])\n        tmp.append(1)\n        i = 1\n        while i < len(list_to_encode) and list_to_encode[i] == tmp[0]:\n            tmp[1] += 1\n            i += 1\n        return tmp + encodeList(list_to_encode[i:])"], [0.8976408243179321, "    compressed_list = []\n    count = 1\n    for index in range(1, len(original_list)):\n        if original_list[index] == original_list[index - 1]:\n            count += 1\n        else:\n            compressed_list.append(str(original_list[index - 1]) + 'x' + str(count))\n            count = 1\n    compressed_list.append(str(original_list[index]) + 'x' + str(count))\n    return compressed_list"], [0.8973993062973022, "    rle_arr = []\n    for word in arr:\n        encoded = ''\n        i = 0\n        while i < len(word):\n            count = 1\n            while i + 1 < len(word) and word[i] == word[i + 1]:\n                i += 1\n                count += 1\n            encoded += '{}{}'.format(word[i], count)\n            i += 1\n        rle_arr.append(encoded)\n    return rle_arr"], [0.895163357257843, "    for index in range(1, len(original_list)):\n        if original_list[index] == original_list[index - 1]:\n            count += 1\n        else:\n            compressed_list.append(str(original_list[index - 1]) + 'x' + str(count))\n            count = 1"], [0.8930303454399109, "        if original_list[index] == original_list[index - 1]:\n            count += 1\n        else:\n            compressed_list.append(str(original_list[index - 1]) + 'x' + str(count))\n            count = 1"], [0.8928057551383972, "    for word in arr:\n        encoded = ''\n        i = 0\n        while i < len(word):\n            count = 1\n            while i + 1 < len(word) and word[i] == word[i + 1]:\n                i += 1\n                count += 1\n            encoded += '{}{}'.format(word[i], count)\n            i += 1\n        rle_arr.append(encoded)"], [0.8904695510864258, "    compressed = []\n    count = 1\n    for i in range(1, len(string)):\n        if string[i] == string[i - 1]:\n            count += 1\n        else:\n            compressed.append((string[i - 1], count))\n            count = 1\n    compressed.append((string[-1], count))\n    return compressed"], [0.89016193151474, "    encoded_sequence = []\n    prev = None\n    count = 0\n    for num in sequence:\n        if prev is None:\n            prev = num\n            count = 1\n        elif num == prev:\n            count += 1\n        else:\n            encoded_sequence.append((prev, count))\n            prev = num\n            count = 1\n    encoded_sequence.append((prev, count))\n    return encoded_sequence"], [0.889673113822937, "        while i < len(list_to_encode) and list_to_encode[i] == tmp[0]:\n            tmp[1] += 1\n            i += 1"]]}
{"task_id": "MBPP/147", "problem": [[0.8977447748184204, "    count = {}\n    operations = 0\n    for num in nums:\n        if count.get(k - num, 0) > 0:\n            count[k - num] -= 1\n            operations += 1\n        else:\n            count[num] = count.get(num, 0) + 1\n    return operations"], [0.8977121114730835, "    count = {}\n    operations = 0\n    for num in nums:\n        if count.get(k - num, 0) > 0:\n            count[k - num] -= 1\n            operations += 1\n        else:\n            count[num] = count.get(num, 0) + 1\n    return operations"], [0.895022451877594, "    for query in queries:\n        operations = 0\n        for num in nums:\n            operations += abs(num - query)\n        answer.append(operations)"], [0.8938882350921631, "    answer = []\n    for query in queries:\n        operations = 0\n        for num in nums:\n            operations += abs(num - query)\n        answer.append(operations)\n    return answer"], [0.8914061784744263, "    min_step = 0\n    min_val = min(arr)\n    for i in range(len(arr)):\n        min_step += arr[i] - min_val\n    return min_step"], [0.8895947933197021, "        for num in nums:\n            operations += abs(num - query)"], [0.8879860639572144, "    frequency = {}\n    for char in string:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    max_frequency = max(frequency.values())\n    operations = 0\n    for char, count in frequency.items():\n        operations += abs(count - max_frequency)\n    return operations"], [0.8879366517066956, "    for num in nums:\n        if count.get(k - num, 0) > 0:\n            count[k - num] -= 1\n            operations += 1\n        else:\n            count[num] = count.get(num, 0) + 1"], [0.8878717422485352, "    for num in nums:\n        if count.get(k - num, 0) > 0:\n            count[k - num] -= 1\n            operations += 1\n        else:\n            count[num] = count.get(num, 0) + 1"], [0.8873194456100464, "    operations = 0\n    freq = {}\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n    max_freq = max(freq.values())\n    for char in freq:\n        operations += abs(freq[char] - max_freq)\n    return operations"]]}
{"task_id": "MBPP/148", "problem": [[0.889618456363678, "    if day < 1 or day > 31:\n        return 'Error: Invalid day'"], [0.8879398703575134, "        elif day > 28:\n            return 'Error: Invalid day'"], [0.886737585067749, "    if month < 1 or month > 12:\n        return 'No'"], [0.8859918117523193, "            if day > 29:\n                return 'Error: Invalid day'"], [0.885560154914856, "    if day < 1 or day > 31:\n        return 'No'"], [0.8848350644111633, "        if day > 365:\n            if year % 400 == 0 or (year % 4 == 0 and year % 100 != 0):\n                pass\n            else:\n                return 'Invalid Input: This year is not a leap year.'"], [0.8837194442749023, "        if day > 30:\n            return 'Invalid day'"], [0.8836448192596436, "        elif day > 28:\n            return 'No'"], [0.8834383487701416, "    year, month, day = date_string.split('-')\n    year = int(year)\n    month = int(month)\n    day = int(day)\n    if is_leap_year(year):\n        print('The year is a leap year.')\n    else:\n        print('The year is not a leap year.')"], [0.8823197484016418, "        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            if month == 2 and day > 29:\n                return 'Error: Invalid date for a leap year'\n            print(\"It's a leap year.\")\n        elif month == 2 and day > 28:\n            return 'Error: Invalid date for a non-leap year'"]]}
{"task_id": "MBPP/149", "problem": [[0.895685076713562, "    coefficients = equation.split()\n    x_coeff = int(coefficients[0][:-1])\n    y_coeff = int(coefficients[2][:-1])\n    value = int(coefficients[4])\n    if x_coeff == 0 and y_coeff == 0:\n        raise ValueError('Invalid equation!')\n    elif x_coeff == 0:\n        return [None, value // y_coeff]\n    elif y_coeff == 0:\n        return [value // x_coeff, None]\n    x = value * y_coeff // (x_coeff * y_coeff + y_coeff * y_coeff)\n    y = (value - x_coeff * x) // y_coeff\n    return [x, y]"], [0.8941934108734131, "    x = (c - b * y) / a\n    y = (c - a * x) / b\n    return (x, y)"], [0.8936694860458374, "    n1 = abs(n1)\n    n2 = abs(n2)\n    if n2 == 0:\n        return n1\n    while n2 != 0:\n        n1, n2 = (n2, n1 % n2)\n    _, x, y = gcd_extended(n1, n2)\n    if n1 == abs(n1):\n        x *= 1\n    else:\n        x *= -1\n    if n2 == abs(n2):\n        y *= 1\n    else:\n        y *= -1\n    return (n1, x, y)"], [0.8923079371452332, "    if n == 1:\n        return (a, b)"], [0.8911423087120056, "    if n2 == 0:\n        return (n1, 1, 0)\n    gcd, x1, y1 = gcd_extended(n2, n1 % n2)\n    x = y1\n    y = x1 - n1 // n2 * y1\n    return (gcd, x, y)"], [0.8892459869384766, "    y = N * Q / (P + Q)\n    x = N - y\n    return (int(x), int(y))"], [0.8887238502502441, "    m = 10 ** 14\n    if a > m or a == 0:\n        return\n    if not x or y % x == 0:\n        if m >= a * a and b >= 0:\n            c = a * a\n            if c not in grp:\n                grp[c] = []\n            grp[c].append([b, 1])\n    gen(s, n, x * s + y * a * n, x * a * n + y * s, x * m2 + a, y * m2)"], [0.8862934112548828, "    if x_coeff == 0 and y_coeff == 0:\n        raise ValueError('Invalid equation!')\n    elif x_coeff == 0:\n        return [None, value // y_coeff]\n    elif y_coeff == 0:\n        return [value // x_coeff, None]"], [0.8851673007011414, "    return (n * d + n, d)"], [0.8841900825500488, "    x = (e * d - b * f) / (a * d - b * c)\n    y = (a * f - e * c) / (a * d - b * c)\n    return (x, y)"]]}
{"task_id": "MBPP/150", "problem": [[0.9278622269630432, "    for item in list2:\n        if item in list1:\n            list1.remove(item)\n    return list1"], [0.9273253083229065, "    for i in list2:\n        list1.remove(i)\n    return list1"], [0.9242030382156372, "    for i in list2:\n        list1.remove(i)"], [0.9226995706558228, "    for item in list2:\n        if item in list1:\n            list1.remove(item)"], [0.9137451648712158, "    for item in list1:\n        if item in list_copy:\n            list_copy.remove(item)"], [0.912886381149292, "    return [value for value in list1 if value not in list2]"], [0.9118809700012207, "    common_elements = set()\n    for element in A:\n        if element in B:\n            common_elements.add(element)\n    for element in common_elements:\n        A.remove(element)\n    return A"], [0.91057288646698, "    new_list = []\n    for el in y:\n        if el != x:\n            new_list.append(el)\n    return new_list"], [0.9101628065109253, "    return [x for x in list_a if x not in list_b]"], [0.9099850654602051, "    temp = []\n    for i in list1:\n        if i not in list2:\n            temp.append(i)\n    return temp"]]}
{"task_id": "MBPP/151", "problem": [[0.914009690284729, "    if n % 2 == 0:\n        return n + sum_of_even_numbers(n - 2)"], [0.9128215312957764, "    return sum(range(1, 2 * n, 2))"], [0.9110780358314514, "    total = 0\n    x = 0\n    while x < n:\n        if x % 2 == 1:\n            total += x\n        x += 1\n    return total"], [0.9104390144348145, "    if x < 0:\n        return 'Invalid input'\n    else:\n        return x * (x + 4) + 5"], [0.9104390144348145, "    if x < 0:\n        return 'Invalid input'\n    else:\n        return x * (x + 4) + 5"], [0.9097909927368164, "    return sum(range(2, 2 * n + 1, 2))"], [0.9094822406768799, "    if n <= 0:\n        return 0\n    if n % 2 == 0:\n        return n + sum_of_even_numbers(n - 2)\n    return sum_of_even_numbers(n - 1)"], [0.90938401222229, "    total = 0\n    while n > 0:\n        total += n\n        n -= 1\n        if total > 10000:\n            print('The sum exceeded the limit!')\n            break\n    return total"], [0.9083687663078308, "    sum = 0\n    for i in range(0, n + 1, 2):\n        sum += i\n    return sum"], [0.9082404971122742, "    elif n % 2 == 0:\n        return sum_of_odd_numbers(n - 1)\n    else:\n        return n + sum_of_odd_numbers(n - 2)"]]}
{"task_id": "MBPP/152", "problem": [[0.9108258485794067, "    area = no_sides * length ** 2 / (4 * math.tan(math.pi / no_sides))\n    return area"], [0.9101088643074036, "    area = n * (math.pow(n, 2) - math.pow(n - 1, 2)) / 4 * math.pow(math.pi, 2)\n    return area"], [0.9090440273284912, "    if len(vertices) < 3:\n        raise InvalidRegularPolygonException('A polygon must have at least 3 vertices.')\n    n = len(vertices)\n    side_lengths = []\n    for i in range(n):\n        x1, y1 = vertices[i]\n        x2, y2 = vertices[(i + 1) % n]\n        side_length = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n        side_lengths.append(side_length)\n    if len(set(side_lengths)) > 1:\n        raise InvalidRegularPolygonException('Not all sides of the polygon are equal in length.')\n    s = side_lengths[0]\n    area = n * s ** 2 / (4 * math.tan(math.pi / n))\n    return area"], [0.9080967307090759, "    area = n * side ** 2 / (4 * math.tan(math.pi / n))\n    return area"], [0.9040303230285645, "    area = n * s ** 2 / (4 * math.tan(math.pi / n))\n    return area"], [0.9040258526802063, "    area = n * s ** 2 / (4 * math.tan(math.pi / n))\n    return area"], [0.9022042751312256, "    angle = 2 * math.pi / n\n    area = r ** 2 * math.sin(angle) / 2\n    return area"], [0.8974622488021851, "    return n_sides * side ** 2 / (4 * math.tan(math.pi / n_sides))"], [0.8962174654006958, "    side = 2 * radius * math.sin(math.pi / 5)\n    area = 5 / 4 * math.tan(math.pi / 5) * side ** 2\n    return area"], [0.890841007232666, "    l = math.sqrt((s / (2 * math.tan(math.pi / n))) ** 2 + h ** 2)\n    P = n * s\n    A = P * s / (4 * math.tan(math.pi / n))\n    surface_area = P * l / 2 + A\n    return surface_area"]]}
{"task_id": "MBPP/153", "problem": [[0.9196459054946899, "    if divisors_sum == n:\n        return True\n    else:\n        return False"], [0.9195737242698669, "    if divisor_sum == n:\n        return True\n    else:\n        return False"], [0.9167428016662598, "    if sum(divisors) == n:\n        return True\n    else:\n        return False"], [0.9131140112876892, "    divisors = []\n    for i in range(1, n):\n        if n % i == 0:\n            divisors.append(i)\n    if sum(divisors) == n:\n        return True\n    else:\n        return False"], [0.912571907043457, "    divisors_sum = 0\n    for i in range(1, n):\n        if n % i == 0:\n            divisors_sum += i\n    if divisors_sum == n:\n        return True\n    else:\n        return False"], [0.9123154282569885, "    if num == sum(divs):\n        return True\n    else:\n        return False"], [0.9101111888885498, "    sum_a = sum_of_proper_divisors(a)\n    sum_b = sum_of_proper_divisors(b)\n    if a == sum_b and b == sum_a:\n        return True\n    return False"], [0.9086025953292847, "    if num <= 1:\n        return False\n    divisors_sum = 1\n    sqrt_num = int(math.sqrt(num))\n    for i in range(2, sqrt_num + 1):\n        if num % i == 0:\n            divisors_sum += i\n            quotient = num // i\n            if quotient != i:\n                divisors_sum += quotient\n    return divisors_sum == num"], [0.9079660177230835, "    if num <= 0:\n        return False\n    divisor_sum = 0\n    for i in range(1, num):\n        if num % i == 0:\n            divisor_sum += i\n    return divisor_sum == num"], [0.9073898196220398, "    if num <= 0:\n        return False\n    divisors_sum = 0\n    for i in range(1, num):\n        if num % i == 0:\n            divisors_sum += i\n    return divisors_sum == num"]]}
{"task_id": "MBPP/154", "problem": [[0.9155515432357788, "    count = 0\n    for char in string:\n        if ord(char) >= 65 and ord(char) <= 90:\n            count += 1\n    return count"], [0.9155226945877075, "    count = 0\n    for char in string:\n        if ord(char) >= 65 and ord(char) <= 90:\n            count += 1\n    return count"], [0.9151763319969177, "    for char in string:\n        if ord(char) >= 65 and ord(char) <= 90:\n            count += 1"], [0.9151574969291687, "    for char in string:\n        if ord(char) >= 65 and ord(char) <= 90:\n            count += 1"], [0.9148004055023193, "    alphabet = string.ascii_lowercase\n    count = {}\n    for char in input_string:\n        if char.isalpha():\n            char = char.lower()\n            if char in count:\n                count[char] += 1\n            else:\n                count[char] = 1\n    return count"], [0.9135607481002808, "    uppercase_counts = {}\n    for char in text:\n        if char.isupper():\n            if char in uppercase_counts:\n                uppercase_counts[char] += 1\n            else:\n                uppercase_counts[char] = 1\n    return uppercase_counts"], [0.9129291772842407, "    dict_upper = {}\n    dict_lower = {}\n    for char in text:\n        if char.isalpha():\n            if char.isupper():\n                dict_upper[char] = dict_upper.get(char, 0) + 1\n            else:\n                dict_lower[char] = dict_lower.get(char, 0) + 1\n    return (dict_upper, dict_lower)"], [0.9127464294433594, "    if not character.isalpha():\n        return 'Error: Character must be an alphabet.'\n    count = 0\n    for char in string:\n        if char == character:\n            count += 1\n        elif char.lower() == character.lower():\n            count += 1\n    return count"], [0.9124030470848083, "    count_dict = {}\n    for char in input_string:\n        if char.isalpha():\n            char = char.lower()\n            if char in count_dict:\n                count_dict[char] += 1\n            else:\n                count_dict[char] = 1\n    return count_dict"], [0.9122942686080933, "        if char.isalpha():\n            if char.islower():\n                counts[ord(char) - ord('a')] += 1\n            else:\n                counts[ord(char) - ord('A')] += 1\n        else:\n            special_chars += char"]]}
{"task_id": "MBPP/155", "problem": [[0.9086575508117676, "    odd_pairs = []\n    pair_count = 0\n    for i in range(len(lst) - 1):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) & 1:\n                pair_count += 1\n                odd_pairs.append((lst[i], lst[j]))\n    return (pair_count, odd_pairs)"], [0.9086395502090454, "    odd_pairs = []\n    pair_count = 0\n    for i in range(len(lst) - 1):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) & 1:\n                pair_count += 1\n                odd_pairs.append((lst[i], lst[j]))\n    return (pair_count, odd_pairs)"], [0.9071584939956665, "    while xor:\n        count += xor & 1\n        xor >>= 1"], [0.9056244492530823, "        if x % 2 == 0:\n            count += 1"], [0.9011112451553345, "    while xor_result:\n        count += xor_result & 1\n        xor_result >>= 1"], [0.9007209539413452, "        if bitwise_and & 1:\n            count += 1"], [0.8975623846054077, "            if c % 2 == 0:\n                count += 1"], [0.8975623846054077, "            if c % 2 == 0:\n                count += 1"], [0.8975566625595093, "    count = 0\n    for x in arr:\n        if x % 2 == 0:\n            count += 1\n    return count"]]}
{"task_id": "MBPP/156", "problem": [[0.9266853332519531, "    return 2 ** int(np.ceil(np.log2(num)))"], [0.9158002138137817, "    while power <= n:\n        power *= 2"], [0.9120490550994873, "    p = 0\n    while 1 << p + 1 <= n:\n        p += 1\n    return p"], [0.9111161231994629, "    powers_of_two = [1]\n    current_power = 2\n    while current_power <= n:\n        powers_of_two.append(current_power)\n        current_power *= 2\n    return powers_of_two"], [0.9055273532867432, "    x = 1\n    while n > x:\n        x = x * 2 + 1\n    return x - n"], [0.9048742651939392, "    return math.ceil(math.log2(n))"], [0.9045950174331665, "    return math.log2(n) + 1"], [0.9039928913116455, "    log = 0\n    while n > 1:\n        n = n >> 1\n        log += 1\n    return log"], [0.9038912057876587, "    while current_power <= n:\n        powers_of_two.append(current_power)\n        current_power *= 2"], [0.9033330678939819, "    while p <= num:\n        p *= 2"]]}
{"task_id": "MBPP/157", "problem": [[0.9216140508651733, "    count = 0\n    for num in arr:\n        if num == given_number:\n            count += 1\n    return count"], [0.9198337197303772, "    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    if num in freq:\n        return freq[num]\n    else:\n        return 0"], [0.9189248085021973, "    count = 0\n    for n in arr:\n        if n == num:\n            count += 1\n    return count"], [0.9188922047615051, "    count = 0\n    for element in arr:\n        if element == num:\n            count += 1\n    return count"], [0.9187608361244202, "    count = 0\n    n = len(arr)\n    for i in range(0, n):\n        if x == arr[i]:\n            count += 1\n    return count"], [0.9183273315429688, "    count = 0\n    for n in inputArray:\n        if n == number:\n            count += 1\n    return count"], [0.918102502822876, "    count = 0\n    for i in range(len(arr)):\n        if x == arr[i]:\n            count = count + 1\n    return count"], [0.9177398085594177, "    count = 0\n    for num in arr:\n        if num == n:\n            count += 1\n    return count"], [0.9154573082923889, "    count_dict = {}\n    for i in arr:\n        if i in count_dict:\n            count_dict[i] += 1\n        else:\n            count_dict[i] = 1\n    print(f'The number {num} occurs {count_dict[num]} times')\n    return count_dict"], [0.9152041673660278, "    for num in arr:\n        if num == given_number:\n            count += 1"]]}
{"task_id": "MBPP/158", "problem": [[0.9290260076522827, "    if n not in pell_dict:\n        pell_dict[n] = 2 * pell(n - 1) + pell(n - 2)"], [0.9269787073135376, "    if n not in pell_dict:\n        pell_dict[n] = 2 * pell(n - 1) + pell(n - 2)\n    return pell_dict[n]"], [0.9249625205993652, "    for i in range(2, n + 1):\n        pell_numbers.append(2 * pell_numbers[i - 1] + pell_numbers[i - 2])"], [0.9249482750892639, "    for i in range(2, n + 1):\n        pell_numbers.append(2 * pell_numbers[i - 1] + pell_numbers[i - 2])"], [0.9009565711021423, "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n)"], [0.9009565711021423, "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n)"], [0.8978692293167114, "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n) + nth_prime(n)"], [0.8978692293167114, "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n) + nth_prime(n)"], [0.8970115780830383, "    if n < 1:\n        return 'Input must be a positive integer.'\n    if not ds_type in ['list', 'tuple', 'dictionary']:\n        return 'Invalid data structure type. Please choose list, tuple, or dictionary.'\n    pell_numbers = [0, 1]\n    for i in range(2, n + 1):\n        pell_numbers.append(2 * pell_numbers[i - 1] + pell_numbers[i - 2])\n    if ds_type == 'list':\n        return pell_numbers[:n + 1]\n    elif ds_type == 'tuple':\n        return tuple(pell_numbers[:n + 1])\n    elif ds_type == 'dictionary':\n        return {i: v for i, v in enumerate(pell_numbers[:n + 1])}"], [0.8969901204109192, "    if n < 1:\n        return 'Input must be a positive integer.'\n    if not ds_type in ['list', 'tuple', 'dictionary']:\n        return 'Invalid data structure type. Please choose list, tuple, or dictionary.'\n    pell_numbers = [0, 1]\n    for i in range(2, n + 1):\n        pell_numbers.append(2 * pell_numbers[i - 1] + pell_numbers[i - 2])\n    if ds_type == 'list':\n        return pell_numbers[:n + 1]\n    elif ds_type == 'tuple':\n        return tuple(pell_numbers[:n + 1])\n    elif ds_type == 'dictionary':\n        return {i: v for i, v in enumerate(pell_numbers[:n + 1])}"]]}
{"task_id": "MBPP/159", "problem": [[0.8953484296798706, "    try:\n        return sum(array[start:end + 1])\n    except IndexError:\n        print('Index out of range')\n    except TypeError:\n        print('Invalid input')\n    except Exception as e:\n        print('Error:', e)"], [0.8953484296798706, "    try:\n        return sum(array[start:end + 1])\n    except IndexError:\n        print('Index out of range')\n    except TypeError:\n        print('Invalid input')\n    except Exception as e:\n        print('Error:', e)"], [0.895315408706665, "    try:\n        return sum(array[start:end + 1])\n    except IndexError:\n        print('Index out of range')\n    except TypeError:\n        print('Invalid input')\n    except Exception as e:\n        print('Error:', e)"], [0.895315408706665, "    try:\n        return sum(array[start:end + 1])\n    except IndexError:\n        print('Index out of range')\n    except TypeError:\n        print('Invalid input')\n    except Exception as e:\n        print('Error:', e)"], [0.8933449983596802, "    if isinstance(start, int) and isinstance(end, int):\n        num_list = []\n        for num in range(start, end + 1):\n            num_list.append(num)\n        return sum(num_list)\n    else:\n        return 'Input values must be integers'"], [0.8933449983596802, "    if isinstance(start, int) and isinstance(end, int):\n        num_list = []\n        for num in range(start, end + 1):\n            num_list.append(num)\n        return sum(num_list)\n    else:\n        return 'Input values must be integers'"], [0.8928914666175842, "    sum = sum(range(num1, num2 + 1))\n    return sum"], [0.8923788070678711, "    sum = 0\n    for i in range(start, end + 1):\n        sum = sum + i\n    return sum"], [0.8895972967147827, "    sum = 0\n    for i in range(start, end + 1):\n        sum += i\n    return sum"], [0.8895923495292664, "    sum = 0\n    for i in range(start, end + 1):\n        sum += i\n    return sum"]]}
{"task_id": "MBPP/160", "problem": [[0.9000008702278137, "    if x < 7 or x > 15:\n        return 'Error: Input value is out of range.'\n    else:\n        perimeter = 5 * x\n        return perimeter"], [0.9000008702278137, "    if x < 7 or x > 15:\n        return 'Error: Input value is out of range.'\n    else:\n        perimeter = 5 * x\n        return perimeter"], [0.8985764980316162, "    if len(sides) != 5:\n        return 'Not a Pentagon'\n    else:\n        return sum(sides)"], [0.8985764980316162, "    if len(sides) != 5:\n        return 'Not a Pentagon'\n    else:\n        return sum(sides)"], [0.8766022324562073, "        if isPentagonal(hexagonal):\n            return hexagonal"], [0.8755061626434326, "    perimeter = 2 * math.pi * radius\n    return perimeter"], [0.871109664440155, "    while True:\n        hexagonal = n * (2 * n - 1)\n        if isPentagonal(hexagonal):\n            return hexagonal\n        n += 1"], [0.870651364326477, "    total_angles_octagon = 1080\n    sum_given_angles = angle1 + angle2 + angle3 + angle4 + angle5\n    return total_angles_octagon - sum_given_angles"], [0.8702915906906128, "    if not isinstance(side, (float, int)):\n        raise ValueError('The input should be a number')\n    return side / (2 * sin(pi / 5))"]]}
{"task_id": "MBPP/161", "problem": [[0.9073923826217651, "    count = 0\n    for item in lst:\n        if item == string:\n            count += 1\n    return count"], [0.9069690704345703, "    for item in lst:\n        if item == string:\n            count += 1"], [0.9054012894630432, "    occurrences = [0] * len(character_to_find)\n    inside_quotes = False\n    for char in given_string:\n        if char == '\"':\n            inside_quotes = not inside_quotes\n            continue\n        if not inside_quotes and char in character_to_find:\n            index = character_to_find.index(char)\n            occurrences[index] += 1\n    return occurrences"], [0.9045649766921997, "    for ch in string:\n        if ch == x:\n            count += 1"], [0.904428243637085, "    count = 0\n    for i in my_list:\n        if i == char:\n            count += 1\n    return count"], [0.9039754867553711, "    count = 0\n    for ch in string:\n        if ch == x:\n            count += 1\n    return count"], [0.903429388999939, "    for i in range(len(lst)):\n        if lst[i] == strr:\n            if first_occurrence == -1:\n                first_occurrence = i\n            last_occurrence = i"], [0.9030880928039551, "    for string in lst:\n        if target.lower() in string.lower():\n            print(string)\n            count += string.lower().count(target.lower())"], [0.902509868144989, "    for char in given_string:\n        if char == '\"':\n            inside_quotes = not inside_quotes\n            continue\n        if not inside_quotes and char in character_to_find:\n            index = character_to_find.index(char)\n            occurrences[index] += 1"], [0.9022717475891113, "    for i in my_list:\n        if i == char:\n            count += 1"]]}
{"task_id": "MBPP/162", "problem": [[0.9411763548851013, "    new_string = []\n    for char in string:\n        if char.isalnum() or char == ' ':\n            new_string.append(char)\n    return ''.join(new_string)"], [0.939583420753479, "    result = ''\n    for char in string:\n        if char.isalnum():\n            result += char\n    return result"], [0.9387665390968323, "    cleanedString = ''\n    for c in string:\n        if c.isalnum():\n            cleanedString += c\n    return cleanedString"], [0.9379321336746216, "    new_string = ''\n    for char in text:\n        if char.isalnum():\n            new_string += char\n    return new_string"], [0.9374183416366577, "    alphanumeric = ''\n    for character in str:\n        if character.isalnum():\n            alphanumeric += character\n    return alphanumeric"], [0.9352468252182007, "    special_characters = '!@#$%^&*()_-+={}[]|\\\\/:;\"\\'<>?,.~`'\n    new_string = ''\n    for char in string:\n        if char.isalnum():\n            new_string += char\n    return new_string"], [0.935107946395874, "    result = ''\n    for c in string:\n        if c.isalnum() or c == ' ':\n            result += c\n    return result"], [0.9343364834785461, "    alphanumeric = ''\n    for char in text:\n        if char.isalnum():\n            alphanumeric += char\n    return alphanumeric"], [0.9334827065467834, "    output_str = ''.join((char for char in input_str if char.isalnum() or char.isspace()))\n    return output_str"], [0.9330509901046753, "    for character in s:\n        if not character.isalnum():\n            s = s.replace(character, '')\n    return s"]]}
{"task_id": "MBPP/163", "problem": [[0.8952623605728149, "    for key, value in lst:\n        if key in dictionary:\n            dictionary[key].append(value)\n        else:\n            dictionary[key] = [value]"], [0.8872911334037781, "    out_dict = {}\n    for key, value in input_list:\n        if key in out_dict:\n            out_dict[key].append(value)\n        else:\n            out_dict[key] = [value]\n    return out_dict"], [0.8872718214988708, "    out_dict = {}\n    for key, value in input_list:\n        if key in out_dict:\n            out_dict[key].append(value)\n        else:\n            out_dict[key] = [value]\n    return out_dict"], [0.8844001293182373, "    groups = {}\n    for dictionary in lst:\n        if dictionary['name'] in groups:\n            groups[dictionary['name']].append(dictionary)\n        else:\n            groups[dictionary['name']] = [dictionary]\n    return groups"], [0.8820249438285828, "    for tup in list_of_tuples:\n        x, y = tup\n        if x not in result:\n            result[x] = [y]\n        else:\n            result[x].append(y)"], [0.8807780742645264, "    dictionary = {}\n    for key, value in lst:\n        if key in dictionary:\n            dictionary[key].append(value)\n        else:\n            dictionary[key] = [value]\n    dictionary = dict(sorted(dictionary.items(), key=lambda item: sum(item[1]), reverse=True))\n    return dictionary"], [0.8795404434204102, "    for key, value in input_list:\n        if key in out_dict:\n            out_dict[key].append(value)\n        else:\n            out_dict[key] = [value]"], [0.8795080184936523, "    for key, value in input_list:\n        if key in out_dict:\n            out_dict[key].append(value)\n        else:\n            out_dict[key] = [value]"], [0.8783106207847595, "    result = {}\n    for tup in list_of_tuples:\n        x, y = tup\n        if x not in result:\n            result[x] = [y]\n        else:\n            result[x].append(y)\n    return result"], [0.8730562925338745, "    for d in lst:\n        key = d[key1]\n        if key not in groups:\n            groups[key] = []\n        groups[key].append(d)"]]}
{"task_id": "MBPP/164", "problem": [[0.9279939532279968, "    stack = []\n    for char in parentheses:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0"], [0.9252262115478516, "    balance = 0\n    for char in string:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0"], [0.9242774248123169, "    stack = []\n    for char in string:\n        if char == '(':\n            stack.append('(')\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return stack == []"], [0.9231415390968323, "    stack = []\n    for char in input_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0"], [0.9229155778884888, "    stack = []\n    for char in input_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0"], [0.922761857509613, "    stack = []\n    for char in input_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack"], [0.9219396710395813, "    stack = []\n    for c in string:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0"], [0.9215385913848877, "    stack = []\n    for ch in input_string:\n        if ch == '(':\n            stack.append(ch)\n        elif ch == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack"], [0.9212367534637451, "    stack = []\n    for ch in string:\n        if ch == '(':\n            stack.append(ch)\n        elif ch == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                return False\n    return len(stack) == 0"], [0.9211243987083435, "    for char in string:\n        if char in parentheses.keys():\n            stack.append(char)\n        elif char in parentheses.values():\n            if len(stack) == 0 or parentheses[stack.pop()] != char:\n                return False"]]}
{"task_id": "MBPP/165", "problem": [[0.9182949662208557, "    perimeter = side1 + side2 + side3\n    return perimeter"], [0.9177484512329102, "    perimeter = l1 + l2 + l3\n    return perimeter"], [0.910682737827301, "    if side1 + side2 <= side3 or side1 + side3 <= side2 or side2 + side3 <= side1:\n        raise InvalidTriangleException('The lengths provided do not form a valid triangle.')\n    else:\n        perimeter = side1 + side2 + side3\n        return perimeter"], [0.910682737827301, "    if side1 + side2 <= side3 or side1 + side3 <= side2 or side2 + side3 <= side1:\n        raise InvalidTriangleException('The lengths provided do not form a valid triangle.')\n    else:\n        perimeter = side1 + side2 + side3\n        return perimeter"], [0.9069977402687073, "    perimeter = side1 + side2 + side3\n    perimeter = round(perimeter, 2)\n    return perimeter"], [0.9011543989181519, "    if side1 <= 0 or side2 <= 0 or side3 <= 0:\n        return 'Side lengths must be greater than 0.'\n    perimeter = side1 + side2 + side3\n    return perimeter"], [0.8933212757110596, "    if a + b <= c or a + c <= b or b + c <= a:\n        raise InvalidTriangleError('Invalid triangle: lengths do not form a valid triangle')\n    perimeter = a + b + c\n    s = perimeter / 2\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    return (perimeter, area)"], [0.8895595073699951, "    if side1 <= 0 or side2 <= 0 or side3 <= 0:\n        return -1\n    if side1 + side2 <= side3 or side2 + side3 <= side1 or side1 + side3 <= side2:\n        return -1\n    perimeter = side1 + side2 + side3\n    if side1 == side2 and side2 == side3:\n        triangle_type = 'equilateral'\n    elif side1 == side2 or side2 == side3 or side1 == side3:\n        triangle_type = 'isosceles'\n    else:\n        triangle_type = 'scalene'\n    return (triangle_type, perimeter)"], [0.889333188533783, "    if side1 == side2 or side2 == side3 or side1 == side3:\n        print('Isosceles triangle')\n        perimeter = side1 + side2 + side3\n        print('Perimeter:', perimeter)\n        return"], [0.8873046040534973, "    if a <= 0 or b <= 0 or c <= 0 or (a + b <= c) or (a + c <= b) or (b + c <= a):\n        raise ValueError('Invalid side lengths. They do not form a valid triangle.')\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    perimeter = a + b + c\n    is_right_angled = a ** 2 + b ** 2 == c ** 2 or a ** 2 + c ** 2 == b ** 2 or b ** 2 + c ** 2 == a ** 2\n    return (area, perimeter, is_right_angled)"]]}
{"task_id": "MBPP/166", "problem": [[0.8941998481750488, "    gcd_value = math.gcd(a, b)\n    lcm_value = abs(a * b) / gcd_value\n    return (gcd_value, lcm_value)"], [0.8931942582130432, "    num_list = [i for i in range(x, y + 1) if i % z == 0 and i % w == 0 and (i % 2 == 0)]\n    if not num_list:\n        return (-1, -1)\n    num_list.sort()\n    try:\n        return (num_list[-m], num_list[n - 1])\n    except IndexError:\n        return (-1, -1)"], [0.8921366930007935, "    lcm = math.lcm(a, b)\n    gcd = math.gcd(a, b)\n    return (lcm, gcd)"], [0.890631914138794, "    gcd = math.gcd(a, b)\n    lcm = abs(a * b) // gcd\n    return (lcm, gcd)"], [0.8883483409881592, "    largest_prime = -1\n    smallest_square = -1\n    for i in range(b, a - 1, -1):\n        if i % e == 0 and is_prime(i):\n            largest_prime = i\n            break\n    for i in range(c, f + 1):\n        if i % b == 0 and is_perfect_square(i):\n            smallest_square = i\n            break\n    return (largest_prime, smallest_square)"], [0.888211727142334, "    if a > b:\n        small = b\n    else:\n        small = a\n    for i in range(1, small + 1):\n        if a % i == 0 and b % i == 0:\n            gcd = i\n    lcm = int(a * b) / int(gcd)\n    return (gcd, lcm)"], [0.8876478672027588, "    min_val = float('inf')\n    max_val = float('-inf')\n    for num in lst:\n        if num >= rng[0] and num <= rng[1]:\n            if num < min_val and num % 3 == 0:\n                min_val = num\n            if num > max_val and is_prime(num):\n                max_val = num\n    return max_val if max_val > min_val else None"], [0.8831688761711121, "    gcd = math.gcd(a, b)\n    lcm = a * b // gcd\n    return lcm"], [0.882668137550354, "    if highest % lowest == 0:\n        return (highest, lowest)"], [0.8826587200164795, "    if highest % lowest == 0:\n        return (highest, lowest)"]]}
{"task_id": "MBPP/167", "problem": [[0.9034456014633179, "    for string in lst:\n        if target.lower() in string.lower():\n            print(string)\n            count += 1"], [0.9024444818496704, "    found = False\n    if str1.find(str2) != -1:\n        found = True\n    return found"], [0.9024286866188049, "    for string in lst:\n        if target.lower() in string.lower():\n            print(string)\n            count += string.lower().count(target.lower())"], [0.9024115204811096, "    if search in string:\n        return True\n    else:\n        return False"], [0.9024115204811096, "    if search in string:\n        return True\n    else:\n        return False"], [0.9018763303756714, "    for string in strings:\n        if target in string:\n            print(string)"], [0.9018763303756714, "    for string in strings:\n        if target in string:\n            print(string)"], [0.901218593120575, "    count = 0\n    for string in lst:\n        if target.lower() in string.lower():\n            print(string)\n            count += 1\n    return count"], [0.9001145362854004, "    for string in strings:\n        if search == string:\n            return True\n    return False"], [0.8997582793235779, "    for string in strings:\n        if search == string:\n            return True"]]}
{"task_id": "MBPP/168", "problem": [[0.8825111985206604, "    num = str(num)\n    digits = [int(x) for x in num]\n    return sum(digits) == 1"], [0.8824671506881714, "    sqrt = int(math.sqrt(num))\n    return sqrt * sqrt == num"], [0.8824599385261536, "    sqrt = int(math.sqrt(num))\n    return sqrt * sqrt == num"], [0.8824596405029297, "    sqrt = int(math.sqrt(num))\n    return sqrt * sqrt == num"], [0.8824478387832642, "    sqrt = int(math.sqrt(num))\n    return sqrt * sqrt == num"], [0.8821195960044861, "    if not isinstance(number, (int, float)) or number < 0:\n        return False\n    if number % 5 != 0:\n        return False\n    digits_sum = sum((int(digit) for digit in str(number) if digit.isdigit()))\n    if digits_sum % 3 != 0:\n        return False\n    number_str = str(number)\n    if number_str == number_str[::-1]:\n        return True\n    if isinstance(number, float):\n        decimal_part = number - int(number)\n        if decimal_part % 2 == 0:\n            return True\n    return False"], [0.8817116022109985, "    powersOfThree = [1, 3, 9, 27, 81, 243, 729, 2187, 6561, 19683, 59049, 177147, 531441, 1594323, 4782969, 14348907, 43046721, 129140163, 387420489, 1162261467]\n    return n in powersOfThree"], [0.8797844648361206, "    root = math.sqrt(num)\n    if int(root + 0.5) ** 2 == num:\n        return True\n    else:\n        return False"], [0.879473090171814, "    count = 0\n    while num != 0:\n        num //= 10\n        count += 1\n    return is_prime(count)"], [0.8792668581008911, "        if num >= 2 and num <= 6 and (num % 3 == 0):\n            return True\n        else:\n            return False"]]}
{"task_id": "MBPP/169", "problem": [[0.9179123640060425, "    degrees_to_radians = math.pi / 180.0\n    phi1 = (90.0 - lat1) * degrees_to_radians\n    phi2 = (90.0 - lat2) * degrees_to_radians\n    theta1 = long1 * degrees_to_radians\n    theta2 = long2 * degrees_to_radians\n    cos = math.sin(phi1) * math.sin(phi2) * math.cos(theta1 - theta2) + math.cos(phi1) * math.cos(phi2)\n    arc = math.acos(cos)\n    earth_radius_km = 6371\n    distance = arc * earth_radius_km\n    return distance"], [0.9178856611251831, "    R = 6373.0\n    lat1 = radians(lat1)\n    long1 = radians(long1)\n    lat2 = radians(lat2)\n    long2 = radians(long2)\n    dlon = long2 - long1\n    dlat = lat2 - lat1\n    a = sin(dlat / 2) ** 2 + cos(lat1) * cos(lat2) * sin(dlon / 2) ** 2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = R * c\n    return distance"], [0.9159469604492188, "    R = 6371\n    lat1_rad = math.radians(lat1)\n    long1_rad = math.radians(long1)\n    lat2_rad = math.radians(lat2)\n    long2_rad = math.radians(long2)\n    delta_lat = lat2_rad - lat1_rad\n    delta_long = long2_rad - long1_rad\n    a = math.sin(delta_lat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(delta_long / 2) ** 2\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n    distance = R * c\n    return round(distance, 2)"], [0.9140498042106628, "    R = 6371\n    dLat = math.radians(lat2 - lat1)\n    dLon = math.radians(lon2 - lon1)\n    lat1 = math.radians(lat1)\n    lat2 = math.radians(lat2)\n    a = math.sin(dLat / 2) * math.sin(dLat / 2) + math.sin(dLon / 2) * math.sin(dLon / 2) * math.cos(lat1) * math.cos(lat2)\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n    distance = R * c\n    return distance"], [0.9140160083770752, "    R = 6371\n    dLat = math.radians(lat2 - lat1)\n    dLon = math.radians(lon2 - lon1)\n    lat1 = math.radians(lat1)\n    lat2 = math.radians(lat2)\n    a = math.sin(dLat / 2) * math.sin(dLat / 2) + math.sin(dLon / 2) * math.sin(dLon / 2) * math.cos(lat1) * math.cos(lat2)\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n    distance = R * c\n    return distance"], [0.9131121635437012, "    R = 6373.0\n    lat1 = radians(lat1)\n    lon1 = radians(lon1)\n    lat2 = radians(lat2)\n    lon2 = radians(lon2)\n    dlon = lon2 - lon1\n    dlat = lat2 - lat1\n    a = sin(dlat / 2) ** 2 + cos(lat1) * cos(lat2) * sin(dlon / 2) ** 2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = R * c\n    return distance"], [0.9129574298858643, "    R = 6371\n    lat1_rad = math.radians(lat1)\n    lon1_rad = math.radians(lon1)\n    lat2_rad = math.radians(lat2)\n    lon2_rad = math.radians(lon2)\n    dlat = lat2_rad - lat1_rad\n    dlon = lon2_rad - lon1_rad\n    a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n    distance = R * c\n    return distance"], [0.9129302501678467, "    R = 6371.0\n    lat1_rad = math.radians(lat1)\n    lon1_rad = math.radians(lon1)\n    lat2_rad = math.radians(lat2)\n    lon2_rad = math.radians(lon2)\n    dlat = lat2_rad - lat1_rad\n    dlon = lon2_rad - lon1_rad\n    a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n    distance = R * c\n    return distance"], [0.9127559661865234, "    R = 6371.0\n    lat_rad1 = math.radians(lat1)\n    lon_rad1 = math.radians(lon1)\n    lat_rad2 = math.radians(lat2)\n    lon_rad2 = math.radians(lon2)\n    delta_lat = lat_rad2 - lat_rad1\n    delta_lon = lon_rad2 - lon_rad1\n    a = math.sin(delta_lat / 2) ** 2 + math.cos(lat_rad1) * math.cos(lat_rad2) * math.sin(delta_lon / 2) ** 2\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n    distance = R * c\n    return distance"], [0.9127269983291626, "    lat1, lon1 = p1\n    lat2, lon2 = p2\n    lat1 = math.radians(lat1)\n    lon1 = math.radians(lon1)\n    lat2 = math.radians(lat2)\n    lon2 = math.radians(lon2)\n    dlon = lon2 - lon1\n    dlat = lat2 - lat1\n    a = math.sin(dlat / 2) ** 2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2) ** 2\n    c = 2 * math.asin(math.sqrt(a))\n    r = 6371\n    return c * r"]]}
{"task_id": "MBPP/170", "problem": [[0.9348723888397217, "    prefix = strings[0]\n    for string in strings:\n        while not string.startswith(prefix):\n            if not prefix:\n                return ''\n            prefix = prefix[0:-1]\n    return prefix"], [0.9316796064376831, "    first_str = strings[0]\n    longest_prefix = ''\n    for i in range(len(first_str)):\n        current_prefix = first_str[:i]\n        flag = True\n        for string in strings[1:]:\n            if not string.startswith(current_prefix):\n                flag = False\n                break\n        if flag:\n            longest_prefix = current_prefix\n    return longest_prefix"], [0.9309231638908386, "    if len(strings) == 0:\n        return ''\n    longest_prefix = ''\n    first_string = strings[0]\n    for i in range(len(first_string)):\n        current_char = first_string[i]\n        for string in strings[1:]:\n            if i >= len(string) or string[i] != current_char:\n                return longest_prefix\n        longest_prefix += current_char\n    return longest_prefix"], [0.9306079149246216, "    if not strings:\n        return ''\n    prefix = strings[0]\n    for string in strings[1:]:\n        while string.startswith(prefix) is False:\n            prefix = prefix[:-1]\n        if prefix == '':\n            return ''\n    return prefix"], [0.9304405450820923, "    if not strings:\n        return ''\n    prefix = strings[0]\n    for i in range(1, len(strings)):\n        while strings[i].find(prefix) != 0:\n            prefix = prefix[:-1]\n            if not prefix:\n                return ''\n    return prefix"], [0.9304333329200745, "    if not strings:\n        return ''\n    prefix = strings[0]\n    for i in range(1, len(strings)):\n        while strings[i].find(prefix) != 0:\n            prefix = prefix[:-1]\n            if not prefix:\n                return ''\n    return prefix"], [0.9287176132202148, "    if len(strings) == 0:\n        return ''\n    prefix = strings[0]\n    for s in strings:\n        i = 0\n        while i < len(prefix) and i < len(s) and (s[i] == prefix[i]):\n            i += 1\n        prefix = prefix[:i]\n    return prefix"], [0.9275519251823425, "    LCprefix = ''\n    s1 = string_set[0]\n    s2 = string_set[1]\n    n1 = len(s1)\n    n2 = len(s2)\n    minimum = min(n1, n2)\n    for i in range(minimum):\n        if s1[i] == s2[i]:\n            LCprefix += s1[i]\n        else:\n            break\n    for j in range(2, len(string_set)):\n        curr_string = string_set[j]\n        curr_length = len(curr_string)\n        if LCprefix == '':\n            break\n        for k in range(len(LCprefix)):\n            if k == curr_length or LCprefix[k] != curr_string[k]:\n                LCprefix = LCprefix[:k]\n                break\n    return LCprefix"], [0.927394449710846, "    if len(strings) == 0:\n        return ''\n    prefix = strings[0]\n    for i in range(1, len(strings)):\n        j = 0\n        while j < len(prefix) and j < len(strings[i]) and (strings[i][j] == prefix[j]):\n            j += 1\n        prefix = prefix[:j]\n    return prefix"], [0.9229365587234497, "    prefix = ''\n    min_length = min([len(s) for s in strings])\n    for i in range(min_length):\n        current_char = strings[0][i]\n        for s in strings:\n            if s[i] != current_char:\n                return prefix\n        prefix += current_char\n    return prefix"]]}
{"task_id": "MBPP/171", "problem": [[0.9288910627365112, "    upper_count = 0\n    lower_count = 0\n    num_count = 0\n    special_count = 0\n    for char in string:\n        if char.isupper():\n            upper_count += 1\n        elif char.islower():\n            lower_count += 1\n        elif char.isnumeric():\n            num_count += 1\n        else:\n            special_count += 1\n    return (upper_count, lower_count, num_count, special_count)"], [0.9227678179740906, "    upper_case = 0\n    digits = 0\n    special_characters = 0\n    for character in string:\n        if character.isupper():\n            upper_case += 1\n        elif character.isdigit():\n            digits += 1\n        elif character.isalpha() or character.isspace():\n            continue\n        else:\n            special_characters += 1\n    return (upper_case, digits, special_characters)"], [0.9170250296592712, "    alpha = 0\n    num = 0\n    special = 0\n    upper = 0\n    for ch in string:\n        if ch.isalpha():\n            alpha += 1\n            if ch.isupper():\n                upper += 1\n        elif ch.isdigit():\n            num += 1\n        else:\n            special += 1\n    print('Number of alphabets :', alpha)\n    print('Number of numerical digits :', num)\n    print('Number of special characters :', special)\n    print('Number of uppercase letters :', upper)"], [0.9152882695198059, "    for char in string:\n        if char.isupper():\n            upper_count += 1\n        elif char.islower():\n            lower_count += 1\n        elif char.isnumeric():\n            num_count += 1\n        else:\n            special_count += 1"], [0.9137067794799805, "        elif char.islower():\n            lowercase += 1\n        elif char.isdigit():\n            numbers += 1\n        else:\n            special += 1"], [0.9129194021224976, "        if char.isupper():\n            uppercase += 1\n        elif char.islower():\n            lowercase += 1\n        elif char.isdigit():\n            numbers += 1\n        else:\n            special += 1"], [0.9124069213867188, "    elif not re.search('[a-zA-Z]', s):\n        return 'String does not have any alphabetical letter'\n    elif not re.search('[0-9]', s):\n        return 'String does not have any numerical digit'\n    elif not re.search('[!@#$%^&*(),.?\":{}|<>]', s):\n        return 'String does not have any special character'\n    else:\n        return 'Input meets all the conditions'"], [0.9119866490364075, "    uppercase = 0\n    digits = 0\n    for character in string:\n        if character.isupper():\n            uppercase += 1\n        elif character.isdigit():\n            digits += 1\n    results = {'Uppercase': uppercase, 'Digits': digits}\n    return results"], [0.9114462733268738, "        if char.isupper():\n            upper_count += 1\n        elif char.islower():\n            lower_count += 1\n        elif char.isnumeric():\n            num_count += 1\n        else:\n            special_count += 1"], [0.9111514091491699, "        if char.isupper():\n            uppercase_count += 1\n        elif char.islower():\n            lowercase_count += 1\n        elif char.isdigit():\n            digit_count += 1\n        elif char in '!@#$%^&*':\n            special_char_count += 1"]]}
{"task_id": "MBPP/172", "problem": [[0.9276938438415527, "    for num in arr:\n        diff = k - num\n        if diff in pairs:\n            pairs[diff, num] = 1\n        else:\n            pairs[num] = 1"], [0.9239600896835327, "    pairs = {}\n    for num in arr:\n        diff = k - num\n        if diff in pairs:\n            pairs[diff, num] = 1\n        else:\n            pairs[num] = 1\n    return pairs.keys()"], [0.9134511947631836, "    count = 0\n    for i in range(len(array)):\n        for j in range(i + 1, len(array)):\n            if (array[i] + array[j]) % k == 0:\n                count += 1\n    return count"], [0.9132266640663147, "    hashmap = dict()\n    count = 0\n    for i in range(0, len(arr)):\n        if arr[i] in hashmap:\n            count += 1\n        hashmap[arr[i] + k] = arr[i]\n    return count"], [0.9131980538368225, "    count = 0\n    for i in range(len(A)):\n        for j in range(len(A)):\n            if i == j:\n                continue\n            if A[i] + A[j] == k:\n                count += 1\n    return count"], [0.9123936295509338, "    pairs = []\n    dic = {}\n    for i in range(len(array)):\n        complement = k - array[i]\n        if complement in dic:\n            pairs.append([array[i], complement])\n        else:\n            dic[array[i]] = k - array[i]\n    return pairs"], [0.9123156070709229, "    seen = set()\n    pairs = []\n    for num in arr:\n        target = k - num\n        if target in seen:\n            pairs.append([num, target])\n        else:\n            seen.add(num)\n    return pairs"], [0.9116362929344177, "    freq_map = {}\n    count = 0\n    for num in nums:\n        count += freq_map.get(num - k, 0) + freq_map.get(num + k, 0)\n        freq_map[num] = freq_map.get(num, 0) + 1\n    return count"], [0.911630392074585, "    freq_map = {}\n    count = 0\n    for num in nums:\n        count += freq_map.get(num - k, 0) + freq_map.get(num + k, 0)\n        freq_map[num] = freq_map.get(num, 0) + 1\n    return count"], [0.9100845456123352, "    nums.sort()\n    count = 0\n    left, right = (0, 1)\n    while right < len(nums):\n        if nums[right] - nums[left] == k:\n            count += 1\n            left += 1\n            right += 1\n        elif nums[right] - nums[left] > k:\n            left += 1\n        else:\n            right += 1\n    return count"]]}
{"task_id": "MBPP/173", "problem": [[0.92888343334198, "    greater_than_num = []\n    for i in list_numbers:\n        if i > num:\n            greater_than_num.append(i)\n    return greater_than_num"], [0.9216736555099487, "    for i in list_numbers:\n        if i > num:\n            greater_than_num.append(i)"], [0.9191250801086426, "    res = []\n    for i in lst:\n        if i > num:\n            res.append(i)\n    return res"], [0.9171081185340881, "    result = []\n    for element in array:\n        if element >= number:\n            result.append(element)\n    return result"], [0.9132124781608582, "    result = []\n    for el in arr:\n        if el > threshold:\n            result.append(el)\n    return result"], [0.9128434658050537, "    return [n for n in lst if n > num]"], [0.9126511216163635, "    output_list = []\n    for element in input_list:\n        if element > input_target:\n            output_list.append(element)\n    output_list.sort()\n    return output_list"], [0.9126436710357666, "    res = []\n    for item in list_in:\n        if item >= given_num:\n            res.append(item)\n    return res"], [0.9124795198440552, "    return [x for x in arr if x > num]"], [0.9111655950546265, "    return [num for num in arr if num > x]"]]}
{"task_id": "MBPP/174", "problem": [[0.8687382936477661, "    parabola_distance, error = integrate.quad(parabolic_distance, -4, 0, args=a)\n    straight_distance = sqrt(4 ** 2 + 3 ** 2)\n    return parabola_distance + straight_distance"], [0.8686052560806274, "        if fa * fc < 0:\n            b = (a + b) / 2\n        elif fc * fb < 0:\n            a = (a + b) / 2\n        else:\n            raise Exception('Trisection algorithm failed to converge.')"], [0.8670088052749634, "    x = (c - b) / (a - b)\n    y = (5 - a * x) / b\n    return (x, y)"], [0.8668419122695923, "    elif det == 0:\n        return [(-b + det) / (2 * a)]\n    elif det > 0:\n        return [(-b + det) / (2 * a), (-b - det) / (2 * a)]"], [0.8664939403533936, "    a, b, c, d, e = coefficients\n    y = (-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)\n    return [-y + (y ** 2 - d / a) ** 0.5, -y - (y ** 2 - d / a) ** 0.5]"], [0.8661195635795593, "        elif fc * fb < 0:\n            a = (a + b) / 2\n        else:\n            raise Exception('Trisection algorithm failed to converge.')"], [0.8660566210746765, "    y_derivative = 5 - 2 * y\n    y_optimal = 5 / 2\n    x_optimal = (y_optimal ** 2 + 5 * y_optimal) / 6\n    y_optimal = 5 * x / 6\n    return (x_optimal, y_optimal)"], [0.8647657632827759, "    a = 1\n    b = -1\n    c = -2 * area\n    x = (-b + sqrt(b ** 2 - 4 * a * c)) / (2 * a)\n    return (round(x, 2), round(2 * x, 2))"], [0.8643580675125122, "    x = eq.split('=')[0]\n    constant = eq.split('=')[1]\n    coeff = x.split('+')[0]\n    if coeff[0] == '-':\n        coeff = -float(coeff[1:])\n    else:\n        coeff = float(coeff)\n    x_value = (float(constant) - float(coeff)) / (2 * coeff)\n    return x_value"], [0.8641891479492188, "    x = (e * d - b * f) / (a * d - b * c)\n    y = (a * f - e * c) / (a * d - b * c)\n    return (x, y)"]]}
{"task_id": "MBPP/175", "problem": [[0.9112012982368469, "    return re.search(word, string)"], [0.9048604965209961, "    pattern = 'hello.*world'\n    match = re.search(pattern, string, re.IGNORECASE)\n    if match:\n        return True\n    else:\n        return False"], [0.9039621353149414, "    pattern = '(?=.*hello)(?=.*world)'\n    return bool(re.search(pattern, string))"], [0.9023972749710083, "    pattern = '(?=.*hello)(?=.*world)'\n    if re.search(pattern, text):\n        return True\n    return False"], [0.900422215461731, "    pattern = '   \\' \\' \\' \\' \\'\\n /\\\\,/\"`\"`\"\\\\`\\\\ /\\\\,'\n    if pattern in input_string:\n        print(pattern)\n    else:\n        print('Pattern not found')"], [0.8998622298240662, "    pattern = '\\\\bhello\\\\b.*\\\\bworld\\\\b'\n    if re.search(pattern, input_string):\n        return True\n    else:\n        return False"], [0.8983629941940308, "    for string in string_array:\n        if re.search(query, string):\n            print(string)"], [0.8983629941940308, "    for string in string_array:\n        if re.search(query, string):\n            print(string)"], [0.8982324600219727, "    pattern = re.compile(substring, re.IGNORECASE)\n    match = re.search(pattern, string)\n    if match:\n        print('Found the substring at index', match.start())\n    else:\n        print('The substring was not found')"], [0.8967561721801758, "    pattern = '.*oo'\n    if re.search(pattern, text):\n        print('The pattern was found in the text!')\n    else:\n        print('The pattern was not found in the text!')"]]}
{"task_id": "MBPP/176", "problem": []}
{"task_id": "MBPP/177", "problem": [[0.9151316285133362, "    root = int(sqrt(n))\n    return n == root * root"], [0.9130526781082153, "    square_root = int(num ** 0.5)\n    return square_root * square_root == num"], [0.9127031564712524, "    root = int(n ** 0.5)\n    return n == root * root"], [0.9127001762390137, "    root = int(n ** 0.5)\n    return n == root * root"], [0.9120903015136719, "    square_root = math.sqrt(n)\n    return square_root.is_integer()"], [0.9119380712509155, "    return n == isqrt(n) ** 2"], [0.911934494972229, "    return n == isqrt(n) ** 2"], [0.9113731384277344, "    root = int(num ** 0.5)\n    return root ** 2 == num"], [0.9113380908966064, "    root = int(num ** 0.5)\n    return root ** 2 == num"], [0.9112712144851685, "    if num < 0:\n        return False\n    sqrt_num = math.sqrt(num)\n    return sqrt_num.is_integer()"]]}
{"task_id": "MBPP/178", "problem": [[0.9217358231544495, "    arr.sort()\n    smallest_missing = None\n    for i in range(len(arr)):\n        if arr[i] > 0:\n            if arr[i] != i + 1:\n                smallest_missing = i + 1\n                break\n    if smallest_missing is None:\n        smallest_missing = len(arr) + 1\n    return smallest_missing"], [0.918319821357727, "    sorted_arr = sorted(arr)\n    curr = sorted_arr[0]\n    for element in sorted_arr[1:]:\n        if element != curr + 1:\n            return curr + 1\n        else:\n            curr = element\n    return missing"], [0.9177628755569458, "    n = len(nums)\n    present = [False] * (n + 1)\n    for i in range(n):\n        if nums[i] > 0 and nums[i] <= n:\n            present[nums[i]] = True\n    for i in range(1, n + 1):\n        if not present[i]:\n            return i\n    return 'No positive number was found'"]]}
{"task_id": "MBPP/179", "problem": [[0.8911893367767334, "                if left <= point[0] <= right and down <= point[1] <= up:\n                    count += 1"], [0.8867088556289673, "            for point in points:\n                if left <= point[0] <= right and down <= point[1] <= up:\n                    count += 1"], [0.882758617401123, "    count = 0\n    startnum = complex(startnum)\n    endnum = complex(endnum)\n    re = startnum.real\n    while re <= endnum.real:\n        im = startnum.imag\n        while im <= endnum.imag:\n            num = complex(re, im)\n            if perfect_square(digit_sum(num.real)) and perfect_square(digit_sum(num.imag)):\n                count += 1\n            im += 1\n        re += 1\n    return count"], [0.8770949840545654, "        if x * x + y * y < 1.0:\n            inside += 1"], [0.8768942356109619, "    points = set()\n    for rectangle in coordinates:\n        for x in range(rectangle[0], rectangle[2]):\n            for y in range(rectangle[1], rectangle[3]):\n                points.add((x, y))\n    return len(points)"], [0.8752080202102661, "            if dx * dx + dy * dy <= query[2] * query[2]:\n                inside += 1"], [0.8751837611198425, "            if dx * dx + dy * dy <= query[2] * query[2]:\n                inside += 1"], [0.8749985694885254, "    count = 0\n    for i in range(start, end + 1):\n        if int(i ** 0.5) ** 2 == i:\n            count += 1\n    return count"], [0.8747801780700684, "    c = i = 0\n    while True:\n        i, sq = (i + 1, i ** n)\n        if sq in range(min_val, max_val + 1):\n            c += 1\n        if sq > max_val:\n            break\n    return c"], [0.8742026686668396, "    if r > l and b > t:\n        return (r - l) * (b - t)\n    else:\n        return 0"]]}
{"task_id": "MBPP/180", "problem": [[0.9089168906211853, "    elif month == 'April' or month == 'June' or month == 'September' or (month == 'November'):\n        return '30 days'\n    elif month == 'February':\n        return '28 or 29 days'\n    else:\n        return 'Invalid input'"], [0.9070520401000977, "    thirty_days_months = [4, 6, 9, 11]\n    if month in thirty_days_months:\n        return True\n    elif month == 2:\n        if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            return False\n        else:\n            return True\n    else:\n        return False"], [0.904664158821106, "    if month in thirty_days_months:\n        return True\n    elif month == 2:\n        if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            return False\n        else:\n            return True\n    else:\n        return False"], [0.9035012722015381, "    if month == 'January' or month == 'March' or month == 'May' or (month == 'July') or (month == 'August') or (month == 'October') or (month == 'December'):\n        return '31 days'\n    elif month == 'April' or month == 'June' or month == 'September' or (month == 'November'):\n        return '30 days'\n    elif month == 'February':\n        return '28 or 29 days'\n    else:\n        return 'Invalid input'"], [0.9035012722015381, "    if month == 'January' or month == 'March' or month == 'May' or (month == 'July') or (month == 'August') or (month == 'October') or (month == 'December'):\n        return '31 days'\n    elif month == 'April' or month == 'June' or month == 'September' or (month == 'November'):\n        return '30 days'\n    elif month == 'February':\n        return '28 or 29 days'\n    else:\n        return 'Invalid input'"], [0.8920319676399231, "    if month < 1 or month > 12:\n        return 'No'"], [0.8920059204101562, "    elif month == 'February':\n        return '28 or 29 days'\n    else:\n        return 'Invalid input'"], [0.8913607597351074, "    month_name = month_name.strip().lower()\n    if month_name == 'january':\n        print('Valid month name')\n    elif month_name == 'february':\n        print('Valid month name')\n    elif month_name == 'march':\n        print('Valid month name')\n    elif month_name == 'april':\n        print('Valid month name')\n    elif month_name == 'may':\n        print('Valid month name')\n    elif month_name == 'june':\n        print('Valid month name')\n    elif month_name == 'july':\n        print('Valid month name')\n    elif month_name == 'august':\n        print('Valid month name')\n    elif month_name == 'september':\n        print('Valid month name')\n    elif month_name == 'october':\n        print('Valid month name')\n    elif month_name == 'november':\n        print('Valid month name')\n    elif month_name == 'december':\n        print('Valid month name')\n    elif month_name == 'ramadan':\n        print('Valid month name')\n    elif month_name == 'tishrei':\n        print('Valid month name')\n    else:\n        print('Invalid month name')"], [0.8896359205245972, "    elif month_name == 'december':\n        print('Valid month name')\n    elif month_name == 'ramadan':\n        print('Valid month name')\n    elif month_name == 'tishrei':\n        print('Valid month name')\n    else:\n        print('Invalid month name')"], [0.8893728852272034, "    elif month_name == 'february':\n        print('Valid month name')\n    elif month_name == 'march':\n        print('Valid month name')\n    elif month_name == 'april':\n        print('Valid month name')\n    elif month_name == 'may':\n        print('Valid month name')\n    elif month_name == 'june':\n        print('Valid month name')\n    elif month_name == 'july':\n        print('Valid month name')\n    elif month_name == 'august':\n        print('Valid month name')\n    elif month_name == 'september':\n        print('Valid month name')\n    elif month_name == 'october':\n        print('Valid month name')\n    elif month_name == 'november':\n        print('Valid month name')\n    elif month_name == 'december':\n        print('Valid month name')\n    elif month_name == 'ramadan':\n        print('Valid month name')\n    elif month_name == 'tishrei':\n        print('Valid month name')\n    else:\n        print('Invalid month name')"]]}
{"task_id": "MBPP/181", "problem": [[0.9231870174407959, "    has_number = False\n    has_character = False\n    for ch in password:\n        if ch.isdigit():\n            has_number = True\n        elif ch.isalpha():\n            has_character = True\n    if has_character and has_number:\n        return True\n    else:\n        return False"], [0.9184505343437195, "    has_alphabet = False\n    has_number = False\n    for char in str:\n        if char.isalpha():\n            has_alphabet = True\n            if has_number:\n                return False\n        elif char.isnumeric():\n            has_number = True\n            if not has_alphabet:\n                return False\n    return has_alphabet and has_number"], [0.9099796414375305, "    elif not any((x.isdigit() for x in password)):\n        print('Password must contain at least 1 number')\n        return False"], [0.9099440574645996, "        elif char.isnumeric():\n            has_number = True\n            if not has_alphabet:\n                return False"], [0.909787118434906, "        if char.isalpha():\n            has_alphabet = True\n            if has_number:\n                return False\n        elif char.isnumeric():\n            has_number = True\n            if not has_alphabet:\n                return False"], [0.9080495238304138, "    if has_character and has_number:\n        return True\n    else:\n        return False"], [0.907291054725647, "    pattern = '\\\\ba.*\\\\d.*\\\\W\\\\b'\n    if re.search(pattern, s):\n        return True\n    else:\n        return False"], [0.9070485830307007, "    return any((letter.isdigit() for letter in password))"], [0.9066845774650574, "    for char in str:\n        if char.isalpha():\n            has_alphabet = True\n            if has_number:\n                return False\n        elif char.isnumeric():\n            has_number = True\n            if not has_alphabet:\n                return False"], [0.9060444831848145, "    for ch in password:\n        if ch.isdigit():\n            has_number = True\n        elif ch.isalpha():\n            has_character = True"]]}
{"task_id": "MBPP/182", "problem": [[0.9133357405662537, "    final_list = []\n    for num in input_list:\n        if num not in final_list:\n            final_list.append(num)\n    return tuple(final_list)"], [0.9067736864089966, "    result_set = set(input_tuple)\n    result_tuple = tuple(result_set)\n    return result_tuple"], [0.9012144207954407, "    seen = set()\n    duplicates = set()\n    for item in input_tuple:\n        if item in seen:\n            duplicates.add(item)\n        seen.add(item)\n    return (len(duplicates) > 0, duplicates)"], [0.9001868367195129, "    new_tuple = []\n    for i in value_in_tuple:\n        if i not in new_tuple:\n            new_tuple.append(i)\n    return tuple(new_tuple)"]]}
{"task_id": "MBPP/183", "problem": [[0.9256635904312134, "    decimal = 0\n    base = 1\n    while octal:\n        last_digit = octal % 10\n        octal = int(octal / 10)\n        decimal += last_digit * base\n        base = base * 8\n    return decimal"], [0.9255750775337219, "    octal_number = oct(decimal_number).replace('0o', '')\n    return octal_number"], [0.9238491058349609, "    decimal = int(octal_num, 8)\n    binary = bin(decimal).replace('0b', '')\n    return binary"], [0.9238311648368835, "    decimal = int(octal_num, 8)\n    binary = bin(decimal).replace('0b', '')\n    return binary"], [0.9236109852790833, "    binary_num = str(binary_num)\n    decimal = int(binary_num, 2)\n    octal_num = oct(decimal).replace('0o', '')\n    return octal_num"], [0.9146581888198853, "    octal, i = (0, 0)\n    while binary != 0:\n        octal += binary % 10 * pow(2, i)\n        binary //= 10\n        i += 1\n    return octal"], [0.9144826531410217, "    if octal == 0:\n        return 0\n    else:\n        last_digit = octal % 10\n        decimal = last_digit * 8 ** 0\n        binary = decimal_to_binary(decimal)\n        return binary + 10 * octal_to_binary(octal // 10)"], [0.9144826531410217, "    if octal == 0:\n        return 0\n    else:\n        last_digit = octal % 10\n        decimal = last_digit * 8 ** 0\n        binary = decimal_to_binary(decimal)\n        return binary + 10 * octal_to_binary(octal // 10)"], [0.9139244556427002, "    oct_num = oct(num)\n    print('The octal form of {} is {}'.format(num, oct_num))"], [0.9129446744918823, "    decimal = int(bin_str, 2)\n    octal_str = oct(decimal)[2:]\n    return octal_str"]]}
{"task_id": "MBPP/184", "problem": [[0.9191969633102417, "    if arr != sorted(arr):\n        raise ValueError('Array must be sorted')\n    start = 0\n    end = len(arr) - 1\n    while start <= end:\n        mid = (start + end) // 2\n        if arr[mid] == k:\n            return mid\n        elif k < arr[mid]:\n            end = mid - 1\n        else:\n            start = mid + 1\n    return None"], [0.9166233539581299, "    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            return i\n        elif arr[i] > x:\n            return -1\n    return -1"], [0.9154950976371765, "    low = 0\n    high = len(sorted_array) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if sorted_array[mid] < value:\n            low = mid + 1\n        elif sorted_array[mid] > value:\n            high = mid - 1\n        else:\n            return mid\n    return -1"], [0.9154828190803528, "    low = 0\n    high = len(sorted_array) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if sorted_array[mid] < value:\n            low = mid + 1\n        elif sorted_array[mid] > value:\n            high = mid - 1\n        else:\n            return mid\n    return -1"], [0.9152753353118896, "    list.sort()\n    first = 0\n    last = len(list) - 1\n    while first <= last:\n        mid = (first + last) // 2\n        if list[mid] == num:\n            while mid > 0 and list[mid - 1] == num:\n                mid -= 1\n            return mid\n        elif num < list[mid]:\n            last = mid - 1\n        else:\n            first = mid + 1\n    return 'Not found'"], [0.915206253528595, "    lower, upper = (0, len(array))\n    while lower < upper:\n        mid = lower + (upper - lower) // 2\n        if array[mid] <= target:\n            lower = mid + 1\n        else:\n            upper = mid\n    if lower - 1 >= 0 and array[lower - 1] == target:\n        return lower - 1\n    else:\n        return 'The element does not exist in the array'"], [0.9147289991378784, "    n = len(arr)\n    arr.sort()\n    for i in range(n):\n        print(arr[i], end=' ')\n    start = 0\n    end = n - 1\n    while start <= end:\n        mid = (start + end) // 2\n        if x == arr[mid]:\n            return mid\n        elif x > arr[mid]:\n            start = mid + 1\n        else:\n            end = mid - 1\n    return -1"], [0.9142650365829468, "    for i in range(0, n):\n        if sorted_ary[i] == target:\n            return i"], [0.9139108657836914, "    sorted_arr = sort_array(arr)\n    return binary_search(sorted_arr, 0, len(arr) - 1, x)"], [0.9136996865272522, "    first = 0\n    last = len(arr) - 1\n    found = False\n    while first <= last and (not found):\n        mid = (first + last) // 2\n        if arr[mid] == item:\n            found = True\n        elif item < arr[mid]:\n            last = mid - 1\n        else:\n            first = mid + 1\n    return found"]]}
{"task_id": "MBPP/185", "problem": [[0.8826910853385925, "    elif k < 1:\n        return input_list\n    else:\n        return input_list[:k - 1] + input_list[k:]"], [0.8798800706863403, "            if condition(i):\n                continue\n            else:\n                result.append(remove_tuples(i, condition))"], [0.8785513639450073, "    words = re.findall('\\\\b\\\\w+\\\\b', s)\n    result = [word for word in words if len(word) != k]\n    return ' '.join(result)"], [0.8781931400299072, "    new_tup = []\n    for elem in initial_tup:\n        if elem != tup_to_expunge:\n            new_tup.append(elem)\n    return tuple(new_tup)"], [0.8778737783432007, "                if not condition(item):\n                    result.append(remove_tuples(item, condition))"], [0.8778470754623413, "                if not condition(item):\n                    result.append(remove_tuples(item, condition))"], [0.8772312998771667, "    if k > len(tup_list):\n        return 'K is greater than the size of list. Returning all records.'"], [0.8760429620742798, "    for elem in initial_tup:\n        if elem != tup_to_expunge:\n            new_tup.append(elem)"], [0.8748827576637268, "    result = []\n    for item in t:\n        if isinstance(item, tuple):\n            try:\n                if not condition(item):\n                    result.append(remove_tuples(item, condition))\n            except Exception as e:\n                print(f'An error occurred: {str(e)}')\n        elif isinstance(item, list):\n            new_list = [i for i in item if not (isinstance(i, tuple) and condition(i))]\n            result.append(new_list)\n        elif isinstance(item, set):\n            new_set = {i for i in item if not (isinstance(i, tuple) and condition(i))}\n            result.append(new_set)\n        elif isinstance(item, dict):\n            new_dict = {k: v for k, v in item.items() if not (isinstance(v, tuple) and condition(v))}\n            result.append(new_dict)\n        else:\n            result.append(item)\n    return tuple(result)"], [0.8748722076416016, "    result = []\n    for item in t:\n        if isinstance(item, tuple):\n            try:\n                if not condition(item):\n                    result.append(remove_tuples(item, condition))\n            except Exception as e:\n                print(f'An error occurred: {str(e)}')\n        elif isinstance(item, list):\n            new_list = [i for i in item if not (isinstance(i, tuple) and condition(i))]\n            result.append(new_list)\n        elif isinstance(item, set):\n            new_set = {i for i in item if not (isinstance(i, tuple) and condition(i))}\n            result.append(new_set)\n        elif isinstance(item, dict):\n            new_dict = {k: v for k, v in item.items() if not (isinstance(v, tuple) and condition(v))}\n            result.append(new_dict)\n        else:\n            result.append(item)\n    return tuple(result)"]]}
{"task_id": "MBPP/186", "problem": [[0.9069257378578186, "    if not isinstance(t1, tuple) or not isinstance(t2, tuple):\n        return 'Error: Input is not a tuple!'\n    if len(t1) != len(t2):\n        return 'Error: Tuples are of different sizes!'\n    try:\n        t1 = tuple(map(float, t1))\n        t2 = tuple(map(float, t2))\n    except:\n        return 'Error: Tuple elements are not real numbers!'\n    if any((ele < 0 for ele in t2)):\n        return 'Error: Second Tuple contains negative values!'\n    return tuple(map(pow, t1, t2))"], [0.9069181680679321, "    if not isinstance(t1, tuple) or not isinstance(t2, tuple):\n        return 'Error: Input is not a tuple!'\n    if len(t1) != len(t2):\n        return 'Error: Tuples are of different sizes!'\n    try:\n        t1 = tuple(map(float, t1))\n        t2 = tuple(map(float, t2))\n    except:\n        return 'Error: Tuple elements are not real numbers!'\n    if any((ele < 0 for ele in t2)):\n        return 'Error: Second Tuple contains negative values!'\n    return tuple(map(pow, t1, t2))"], [0.8965576887130737, "        for x, y in zip(tuple1, tuple2):\n            if not isinstance(x, (int, float, complex, str, bool, tuple, list, type(None))) or not isinstance(y, (int, float, complex, str, bool, tuple, list, type(None))):\n                raise ValueError('Invalid input type')\n            numeric_x = convert_to_numeric(x)\n            numeric_y = convert_to_numeric(y)\n            if isinstance(numeric_y, (complex, tuple, list)) or numeric_y < 0:\n                raise ValueError('Exponent cannot be negative or complex')\n            if isinstance(numeric_x, tuple) or isinstance(numeric_y, tuple):\n                result_tuple.append(element_wise_exponentiation(numeric_x, numeric_y))\n            else:\n                result_tuple.append(numeric_x ** numeric_y)"], [0.8965511918067932, "        for x, y in zip(tuple1, tuple2):\n            if not isinstance(x, (int, float, complex, str, bool, tuple, list, type(None))) or not isinstance(y, (int, float, complex, str, bool, tuple, list, type(None))):\n                raise ValueError('Invalid input type')\n            numeric_x = convert_to_numeric(x)\n            numeric_y = convert_to_numeric(y)\n            if isinstance(numeric_y, (complex, tuple, list)) or numeric_y < 0:\n                raise ValueError('Exponent cannot be negative or complex')\n            if isinstance(numeric_x, tuple) or isinstance(numeric_y, tuple):\n                result_tuple.append(element_wise_exponentiation(numeric_x, numeric_y))\n            else:\n                result_tuple.append(numeric_x ** numeric_y)"], [0.8948987126350403, "            if isinstance(numeric_x, tuple) or isinstance(numeric_y, tuple):\n                result_tuple.append(element_wise_exponentiation(numeric_x, numeric_y))\n            else:\n                result_tuple.append(numeric_x ** numeric_y)"], [0.8948930501937866, "            if isinstance(numeric_x, tuple) or isinstance(numeric_y, tuple):\n                result_tuple.append(element_wise_exponentiation(numeric_x, numeric_y))\n            else:\n                result_tuple.append(numeric_x ** numeric_y)"], [0.8938877582550049, "    if len(list1) != len(list2):\n        raise ValueError('Input lists must have equal length')\n    result = []\n    for tuple1, tuple2 in zip(list1, list2):\n        if len(tuple1) != len(tuple2):\n            raise ValueError('Tuples in the same position must have equal length')\n        result_tuple = []\n        for x, y in zip(tuple1, tuple2):\n            if not isinstance(x, (int, float, complex, str, bool, tuple, list, type(None))) or not isinstance(y, (int, float, complex, str, bool, tuple, list, type(None))):\n                raise ValueError('Invalid input type')\n            numeric_x = convert_to_numeric(x)\n            numeric_y = convert_to_numeric(y)\n            if isinstance(numeric_y, (complex, tuple, list)) or numeric_y < 0:\n                raise ValueError('Exponent cannot be negative or complex')\n            if isinstance(numeric_x, tuple) or isinstance(numeric_y, tuple):\n                result_tuple.append(element_wise_exponentiation(numeric_x, numeric_y))\n            else:\n                result_tuple.append(numeric_x ** numeric_y)\n        result.append(tuple(result_tuple))\n    return result"], [0.8938555717468262, "    if len(list1) != len(list2):\n        raise ValueError('Input lists must have equal length')\n    result = []\n    for tuple1, tuple2 in zip(list1, list2):\n        if len(tuple1) != len(tuple2):\n            raise ValueError('Tuples in the same position must have equal length')\n        result_tuple = []\n        for x, y in zip(tuple1, tuple2):\n            if not isinstance(x, (int, float, complex, str, bool, tuple, list, type(None))) or not isinstance(y, (int, float, complex, str, bool, tuple, list, type(None))):\n                raise ValueError('Invalid input type')\n            numeric_x = convert_to_numeric(x)\n            numeric_y = convert_to_numeric(y)\n            if isinstance(numeric_y, (complex, tuple, list)) or numeric_y < 0:\n                raise ValueError('Exponent cannot be negative or complex')\n            if isinstance(numeric_x, tuple) or isinstance(numeric_y, tuple):\n                result_tuple.append(element_wise_exponentiation(numeric_x, numeric_y))\n            else:\n                result_tuple.append(numeric_x ** numeric_y)\n        result.append(tuple(result_tuple))\n    return result"], [0.8937057852745056, "    for tuple1, tuple2 in zip(list1, list2):\n        if len(tuple1) != len(tuple2):\n            raise ValueError('Tuples in the same position must have equal length')\n        result_tuple = []\n        for x, y in zip(tuple1, tuple2):\n            if not isinstance(x, (int, float, complex, str, bool, tuple, list, type(None))) or not isinstance(y, (int, float, complex, str, bool, tuple, list, type(None))):\n                raise ValueError('Invalid input type')\n            numeric_x = convert_to_numeric(x)\n            numeric_y = convert_to_numeric(y)\n            if isinstance(numeric_y, (complex, tuple, list)) or numeric_y < 0:\n                raise ValueError('Exponent cannot be negative or complex')\n            if isinstance(numeric_x, tuple) or isinstance(numeric_y, tuple):\n                result_tuple.append(element_wise_exponentiation(numeric_x, numeric_y))\n            else:\n                result_tuple.append(numeric_x ** numeric_y)\n        result.append(tuple(result_tuple))"], [0.8936902284622192, "    for tuple1, tuple2 in zip(list1, list2):\n        if len(tuple1) != len(tuple2):\n            raise ValueError('Tuples in the same position must have equal length')\n        result_tuple = []\n        for x, y in zip(tuple1, tuple2):\n            if not isinstance(x, (int, float, complex, str, bool, tuple, list, type(None))) or not isinstance(y, (int, float, complex, str, bool, tuple, list, type(None))):\n                raise ValueError('Invalid input type')\n            numeric_x = convert_to_numeric(x)\n            numeric_y = convert_to_numeric(y)\n            if isinstance(numeric_y, (complex, tuple, list)) or numeric_y < 0:\n                raise ValueError('Exponent cannot be negative or complex')\n            if isinstance(numeric_x, tuple) or isinstance(numeric_y, tuple):\n                result_tuple.append(element_wise_exponentiation(numeric_x, numeric_y))\n            else:\n                result_tuple.append(numeric_x ** numeric_y)\n        result.append(tuple(result_tuple))"]]}
{"task_id": "MBPP/187", "problem": [[0.8820161819458008, "    angle_C = math.radians(angle_C)\n    cos_C = math.cos(angle_C)\n    c = math.sqrt(a ** 2 + b ** 2 - 2 * a * b * cos_C)\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return area"], [0.8776544332504272, "    s = area / 3 ** 0.5\n    a = (4 * area / s) ** 0.5\n    b = s - a\n    return (a, b, s)"], [0.876303493976593, "    maximum_area = 0\n    max_triangle = None\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            for k in range(j + 1, len(points)):\n                area = calculate_area(points[i], points[j], points[k])\n                if area > maximum_area:\n                    maximum_area = area\n                    max_triangle = (points[i], points[j], points[k])\n    return max_triangle"], [0.8740177154541016, "                if area > maximum_area:\n                    maximum_area = area\n                    max_triangle = (points[i], points[j], points[k])"], [0.872928261756897, "    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            for k in range(j + 1, len(points)):\n                area = calculate_area(points[i], points[j], points[k])\n                if area > maximum_area:\n                    maximum_area = area\n                    max_triangle = (points[i], points[j], points[k])"], [0.8697078824043274, "            for k in range(j + 1, len(points)):\n                area = calculate_area(points[i], points[j], points[k])\n                if area > maximum_area:\n                    maximum_area = area\n                    max_triangle = (points[i], points[j], points[k])"], [0.8689854145050049, "    n = 1\n    while True:\n        l_section_area = n - math.pi / 4\n        triangle_area = 1 / 2 * 1 * (1 / n)\n        if triangle_area / l_section_area < 0.001:\n            return n\n        n += 1"], [0.8688182830810547, "    while True:\n        l_section_area = n - math.pi / 4\n        triangle_area = 1 / 2 * 1 * (1 / n)\n        if triangle_area / l_section_area < 0.001:\n            return n\n        n += 1"]]}
{"task_id": "MBPP/188", "problem": [[0.9149442911148071, "    p = 0\n    while 1 << p + 1 <= n:\n        p += 1\n    return p"], [0.9089426398277283, "    while power <= n:\n        power *= 2"], [0.9077281951904297, "    log = 0\n    while n > 1:\n        n = n >> 1\n        log += 1\n    return log"], [0.9070688486099243, "    if math.log2(n).is_integer():\n        return math.log2(n)\n    else:\n        return 'The number is not an exponent of two.'"], [0.9056826829910278, "    if not isinstance(n, int):\n        raise ValueError('Input must be an integer')\n    if math.log2(n).is_integer():\n        return math.log2(n)\n    else:\n        return 'The number is not an exponent of two.'"], [0.905211329460144, "    if N <= 1:\n        return 'N should be more than 1'\n    height = math.log(N, 2)\n    return int(height) + 1"], [0.9039895534515381, "    x = 1\n    while n > x:\n        x = x * 2 + 1\n    return x - n"], [0.9031598567962646, "    return 2 ** int(np.ceil(np.log2(num)))"], [0.9025833606719971, "    while p <= num:\n        p *= 2"], [0.9025511741638184, "    while p <= num:\n        p *= 2"]]}
{"task_id": "MBPP/189", "problem": [[0.9224262237548828, "    max_val = lst[0]\n    indices = []\n    for i in range(len(lst)):\n        if lst[i] > max_val:\n            max_val = lst[i]\n            indices = []\n        if lst[i] == max_val:\n            indices.append(i)\n    return indices"], [0.915312647819519, "    max_val = max(lst)\n    indices = [i for i, val in enumerate(lst) if val == max_val]\n    print('The greatest number is {} and its indices are {}'.format(max_val, indices))"], [0.9145034551620483, "    if len(num_list) == 0:\n        return []\n    max_val = num_list[0]\n    max_indices = [0]\n    for i in range(1, len(num_list)):\n        if num_list[i] > max_val:\n            max_val = num_list[i]\n            max_indices = [i]\n        elif num_list[i] == max_val:\n            max_indices.append(i)\n    return [(max_val, index) for index in max_indices]"], [0.9103996753692627, "    max_num = float('-inf')\n    max_indices = []\n    for i in range(len(arr)):\n        if arr[i] > max_num:\n            max_num = arr[i]\n            max_indices = [i]\n        elif arr[i] == max_num:\n            max_indices.append(i)\n    return max_indices"], [0.9077543616294861, "    if not nums:\n        return []\n    max_num = max(nums)\n    indices = [i for i, num in enumerate(nums) if num == max_num]\n    return indices"], [0.9043885469436646, "    max_num = lst[0]\n    max_index = [0]\n    for i in range(1, len(lst)):\n        if lst[i] > max_num:\n            max_num = lst[i]\n            max_index = [i]\n        elif lst[i] == max_num:\n            max_index.append(i)\n    return (max_num, max_index)"], [0.9036402702331543, "    if not array:\n        return 'Cannot find max value and indices in an empty array'\n    max_value = array[0]\n    indices = [0]\n    for i in range(1, len(array)):\n        if array[i] > max_value:\n            max_value = array[i]\n            indices = [i]\n        elif array[i] == max_value:\n            indices.append(i)\n    return (max_value, indices)"], [0.9023469686508179, "    for i in range(len(lst)):\n        if lst[i] > max_val:\n            max_val = lst[i]\n            indices = []\n        if lst[i] == max_val:\n            indices.append(i)"], [0.9006330966949463, "            if lst[i] > max_val:\n                max_val = lst[i]\n                max_idxs = [i]\n            elif lst[i] == max_val:\n                max_idxs.append(i)"], [0.9001829624176025, "        elif lst[i] > max_value:\n            max_value = lst[i]\n            max_indices = [i]\n        elif lst[i] == max_value:\n            max_indices.append(i)"]]}
{"task_id": "MBPP/190", "problem": [[0.921807050704956, "    first_elem = arr[0]\n    is_equal = True\n    for elem in arr:\n        if elem != first_elem:\n            is_equal = False\n            break\n    return is_equal"], [0.92140793800354, "    if not lst:\n        return True\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True"], [0.9205561876296997, "    for i in range(len(my_list)):\n        for j in range(i + 1, len(my_list)):\n            if my_list[i] != my_list[j]:\n                return False\n    return True"], [0.9194902181625366, "    if len(lst) == 0:\n        return False\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True"], [0.917996883392334, "    if len(lst) == 0:\n        return True\n    first_element = lst[0]\n    for i in range(1, len(lst)):\n        if lst[i] != first_element:\n            return False\n    return True"], [0.9154915809631348, "    if len(set(list_of_elements)) == 1:\n        return True\n    else:\n        return False"], [0.9154915809631348, "    if len(set(list_of_elements)) == 1:\n        return True\n    else:\n        return False"], [0.9098378419876099, "    if len(arr) == 0:\n        return False\n    return all((arr[0] == x for x in arr))"], [0.9078000783920288, "    for element in lst:\n        if element != first_element:\n            return False"], [0.9077636003494263, "    for element in lst:\n        if element != first_element:\n            return False"]]}
{"task_id": "MBPP/191", "problem": [[0.9170167446136475, "    new_str = ''\n    for ch in str:\n        if ord(ch) % 2 == 0:\n            new_str += ch\n    return new_str"], [0.9159996509552002, "    odd_position = ''\n    for i in range(len(string)):\n        if i % 2 == 0:\n            odd_position += string[i]\n    return odd_position"], [0.9085018634796143, "    result_string = ''\n    for i in range(0, len(string)):\n        if i % 2 == 0:\n            result_string += string[i]\n    return result_string"], [0.9077202081680298, "    result = ''\n    for i in range(len(string)):\n        if i % 2 == 0:\n            result += string[i]\n    return result"], [0.9067381620407104, "    words = sentence.split(' ')\n    even_index_words = [words[i] for i in range(len(words)) if i % 2 == 0]\n    return ' '.join(even_index_words)"]]}
{"task_id": "MBPP/192", "problem": [[0.9037507176399231, "    xorResult = x ^ y\n    dist = 0\n    while xorResult:\n        dist += xorResult & 1\n        xorResult >>= 1\n    return dist"], [0.9022668600082397, "    return bin(x ^ y).count('1')"], [0.9019761085510254, "    if len(string1) != len(string2):\n        return 'Error: The two binaries are of different length.'\n    count = 0\n    for i in range(len(string1)):\n        if string1[i] != string2[i]:\n            count += 1\n    return count"], [0.8996706008911133, "    count = 0\n    z = x ^ y\n    while z:\n        count += z & 1\n        z >>= 1\n    return count"], [0.8996378183364868, "    hammingDistance = 0\n    for i in range(len(s1)):\n        if s1[i] != s2[i]:\n            hammingDistance += 1\n    return hammingDistance"], [0.8980016112327576, "    distance = 0\n    for bit1, bit2 in zip(str1, str2):\n        if bit1 != bit2:\n            distance += 1\n    return distance"], [0.8976696133613586, "    if len(string1) != len(string2):\n        return 'The binary strings are not of equal length.'\n    diff_str = ''\n    for i in range(len(string1)):\n        if string1[i] != string2[i]:\n            diff_str += '1'\n        else:\n            diff_str += '0'\n    return (diff_str, int(diff_str, 2))"], [0.8974423408508301, "    xor_result = a ^ b\n    count = 0\n    while xor_result:\n        count += xor_result & 1\n        xor_result >>= 1\n    return count"]]}
{"task_id": "MBPP/193", "problem": [[0.9347700476646423, "    count = 0\n    for ch in string:\n        if ch == char:\n            count += 1\n    return count"], [0.9347653985023499, "    count = 0\n    for ch in string:\n        if ch == char:\n            count += 1\n    return count"], [0.9347640872001648, "    count = 0\n    for ch in string:\n        if ch == char:\n            count += 1\n    return count"], [0.9342246055603027, "    count = 0\n    for c in string:\n        if c == char:\n            count += 1\n    return count"], [0.9342195987701416, "    count = 0\n    for c in string:\n        if c == char:\n            count += 1\n    return count"], [0.9342179298400879, "    count = 0\n    for c in string:\n        if c == char:\n            count += 1\n    return count"], [0.9342175126075745, "    count = 0\n    for c in string:\n        if c == char:\n            count += 1\n    return count"], [0.9342132806777954, "    count = 0\n    for c in string:\n        if c == char:\n            count += 1\n    return count"], [0.9342131614685059, "    count = 0\n    for c in string:\n        if c == char:\n            count += 1\n    return count"], [0.9342123866081238, "    count = 0\n    for c in string:\n        if c == char:\n            count += 1\n    return count"]]}
{"task_id": "MBPP/194", "problem": [[0.884289026260376, "    inverted_array = list(reversed(input_array))\n    inversion_count = 0\n    for i in range(len(input_array)):\n        for j in range(i + 1, len(input_array)):\n            if input_array[i] > input_array[j]:\n                inversion_count += 1\n    return (inverted_array, inversion_count)"], [0.8842392563819885, "    if len(arr) <= 1:\n        return (arr, 0)\n    else:\n        middle = len(arr) // 2\n        left, left_inversions = count_inversions(arr[:middle])\n        right, right_inversions = count_inversions(arr[middle:])\n        result, split_inversions = merge_and_count_inversions(left, right)\n        return (result, left_inversions + right_inversions + split_inversions)"], [0.8842392563819885, "    if len(arr) <= 1:\n        return (arr, 0)\n    else:\n        middle = len(arr) // 2\n        left, left_inversions = count_inversions(arr[:middle])\n        right, right_inversions = count_inversions(arr[middle:])\n        result, split_inversions = merge_and_count_inversions(left, right)\n        return (result, left_inversions + right_inversions + split_inversions)"], [0.8769542574882507, "    inversion_count = 0\n    for i in range(0, len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inversion_count += 1\n    return inversion_count"], [0.8768625855445862, "    inversions = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inversions += 1\n    return inversions"], [0.8740116953849792, "    inversion_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inversion_count += 1\n    return inversion_count"], [0.8707958459854126, "    positions = [i for i, x in enumerate(input_tuple) if x == factor]\n    inverted_positions = positions[::-1]\n    output_list = list(input_tuple)\n    for pos, inverted_pos in zip(positions, inverted_positions):\n        output_list[inverted_pos] = output_list[pos]\n    return tuple(output_list)"], [0.8688803911209106, "    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inversions += 1"], [0.8684424161911011, "    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] < arr[i]:\n                inversions += 1"]]}
{"task_id": "MBPP/195", "problem": [[0.8919780254364014, "    merged = ()\n    length = min(len(t1), len(t2))\n    for i in range(length):\n        merged += (t1[i],)\n        merged += (t2[i],)\n    return merged + t1[length:] + t2[length:]"], [0.890863299369812, "    result = []\n    for inner_list in lst:\n        first = inner_list[0]\n        last = inner_list[-1]\n        result.append((first + last, first + last))\n    return result"], [0.8906599283218384, "    result = []\n    for tup in tuples:\n        value_sum = sum(tup)\n        if value_sum % 2 == 0:\n            result.append((tup[0] + 1, tup[1] + 1))\n        else:\n            result.append((tup[0] * 2, tup[1] * 2))\n    return result"], [0.8871270418167114, "    elif len(lst) == 2:\n        return [lst[0] + lst[1]]\n    else:\n        return [lst[0] + lst[1]] + lst[2:]"], [0.8860898017883301, "    if len(lst) == 1:\n        return lst\n    elif len(lst) == 2:\n        return [lst[0] + lst[1]]\n    else:\n        return [lst[0] + lst[1]] + lst[2:]"], [0.8852452039718628, "    return sorted(tuples, key=lambda x: len(x[0] + x[1]))"], [0.882056474685669, "    for a, b in tpl1:\n        for c, d in tpl2:\n            return (a + c, b + d)"], [0.882056474685669, "    for a, b in tpl1:\n        for c, d in tpl2:\n            return (a + c, b + d)"], [0.8819459676742554, "    for tup in tuples:\n        value_sum = sum(tup)\n        if value_sum % 2 == 0:\n            result.append((tup[0] + 1, tup[1] + 1))\n        else:\n            result.append((tup[0] * 2, tup[1] * 2))"], [0.881827712059021, "    transposed_lists = [j for i in zip(list1, list2) for j in i]\n    res = ' '.join(transposed_lists)\n    return res"]]}
{"task_id": "MBPP/196", "problem": []}
{"task_id": "MBPP/197", "problem": [[0.8953464031219482, "        if '{:.2f}'.format(dec) == str_num:\n            return True"], [0.891939640045166, "    s = ''.join(re.findall('\\\\d+\\\\.?\\\\d*', s.strip()))\n    try:\n        num = float(s)\n        if not ('.' in s and len(s) - s.index('.') - 1 == 2):\n            return False\n        else:\n            return 0 < num < 1000 and num % 10 != 0\n    except ValueError:\n        return False"], [0.8862907886505127, "    try:\n        num = float(s)\n        if not ('.' in s and len(s) - s.index('.') - 1 == 2):\n            return False\n        else:\n            return 0 < num < 1000 and num % 10 != 0\n    except ValueError:\n        return False"], [0.8839421272277832, "    try:\n        number = float(s)\n        if number <= 0 or number >= 1000:\n            return False\n        if s.count('.') == 1:\n            if len(s[s.index('.'):]) < 3:\n                return False\n        elif s.count('.') > 1:\n            return False\n        if not s.replace('.', '', 1).isdigit():\n            return False\n        return True\n    except ValueError:\n        return False"], [0.8839421272277832, "    try:\n        number = float(s)\n        if number <= 0 or number >= 1000:\n            return False\n        if s.count('.') == 1:\n            if len(s[s.index('.'):]) < 3:\n                return False\n        elif s.count('.') > 1:\n            return False\n        if not s.replace('.', '', 1).isdigit():\n            return False\n        return True\n    except ValueError:\n        return False"], [0.8839203119277954, "    if len(decimal_part) > 4:\n        return False"], [0.8839089870452881, "    try:\n        number = float(s)\n        if number <= 0 or number >= 1000:\n            return False\n        if s.count('.') == 1:\n            if len(s[s.index('.'):]) < 3:\n                return False\n        elif s.count('.') > 1:\n            return False\n        if not s.replace('.', '', 1).isdigit():\n            return False\n        return True\n    except ValueError:\n        return False"], [0.8839089870452881, "    try:\n        number = float(s)\n        if number <= 0 or number >= 1000:\n            return False\n        if s.count('.') == 1:\n            if len(s[s.index('.'):]) < 3:\n                return False\n        elif s.count('.') > 1:\n            return False\n        if not s.replace('.', '', 1).isdigit():\n            return False\n        return True\n    except ValueError:\n        return False"], [0.8837836980819702, "    str_num = '{:.2f}'.format(number)\n    for dec in decimals:\n        if '{:.2f}'.format(dec) == str_num:\n            return True\n    return False"], [0.8827961683273315, "    for dec in decimals:\n        if '{:.2f}'.format(dec) == str_num:\n            return True"]]}
{"task_id": "MBPP/198", "problem": [[0.8839859962463379, "    if len(heap) < 2:\n        raise ValueError('Heap needs to contain at least two elements.')\n    heap[-2] = new_value\n    i = len(heap) - 2\n    while i > 0 and heap[i] > heap[(i - 1) // 2]:\n        heap[i], heap[(i - 1) // 2] = (heap[(i - 1) // 2], heap[i])\n        i = (i - 1) // 2"], [0.8824151754379272, "    heap.append(item)\n    _siftup(heap, len(heap) - 1)"], [0.8806896209716797, "    element_index = arr.index(element)\n    arr[element_index], arr[len(arr) - 1] = (arr[len(arr) - 1], arr[element_index])\n    arr.pop()\n    min_heapify_down(arr, 0, len(arr))"], [0.8727225661277771, "    if left < n and heap[left] < heap[smallest]:\n        smallest = left"], [0.8724514245986938, "    if left < heap_size and array[left] < array[smallest]:\n        smallest = left"], [0.8724226951599121, "    if left < heap_size and array[left] < array[smallest]:\n        smallest = left"]]}
{"task_id": "MBPP/199", "problem": [[0.9121395945549011, "    pattern = '^[a-z]*$'\n    if re.match(pattern, string):\n        return True\n    else:\n        return False"], [0.912091076374054, "    pattern = '^[a-z]*$'\n    if re.match(pattern, string):\n        return True\n    else:\n        return False"], [0.9096029996871948, "    valid = True\n    for char in input_string:\n        if char.islower() or char.isdigit():\n            continue\n        else:\n            valid = False\n            break\n    return valid"], [0.9092162847518921, "    regex = re.compile('[a-zA-Z0-9]')\n    for c in input_string:\n        if not regex.match(c):\n            return False\n    return True"], [0.9050393104553223, "    pattern = '^[a-z]*$'\n    if re.fullmatch(pattern, text):\n        return True\n    else:\n        return False"], [0.9023756980895996, "    pattern = '^[a-zA-Z]+$'\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False"], [0.9023540019989014, "    pattern = '^[a-zA-Z]+$'\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False"], [0.9018173217773438, "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    if set(string.lower()) >= set(alphabet):\n        return True\n    else:\n        return False"], [0.9017292261123657, "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    for char in alphabet:\n        if char not in input_str.lower():\n            return False\n    return True"], [0.9009010791778564, "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    for char in alphabet:\n        if char not in string.lower():\n            return False\n    return True"]]}
{"task_id": "MBPP/200", "problem": [[0.9054456949234009, "    c1 = n.count('1')\n    c0 = n.count('0')\n    return [c1, c0]"], [0.9053494334220886, "    while bitwise_and > 0:\n        if bitwise_and & 1:\n            count += 1\n        bitwise_and = bitwise_and >> 1"], [0.9037184715270996, "        if bitwise_and & 1:\n            count += 1"], [0.9006763100624084, "        if n & 1 == 1:\n            if bit_place % 2 == 0:\n                result += 1"], [0.8980874419212341, "            if num & mask:\n                sum += 1"], [0.8973680734634399, "        for j in range(0, n):\n            if array[j] & 1 << i:\n                cnt += 1"], [0.896820068359375, "    result = []\n    result.append(x & y)\n    result.append(x | y)\n    result.append(x ^ y)\n    count_x = bin(x).count('1')\n    count_y = bin(y).count('1')\n    if count_x > count_y:\n        result.append('x has more set bits')\n    elif count_y > count_x:\n        result.append('y has more set bits')\n    return result"], [0.8963356614112854, "    return bin(x ^ y).count('1')"], [0.8959742188453674, "        if bit == '1':\n            count += 1"], [0.8954064249992371, "    count = 0\n    for i in range(left, right + 1):\n        bits = bin(i).count('1')\n        if is_prime(bits):\n            count += 1\n    return count"]]}
{"task_id": "MBPP/201", "problem": [[0.9258561134338379, "    if n <= 0:\n        return 'Invalid input! n should be a positive integer.'\n    else:\n        series_sum = sum([i ** 4 for i in range(1, n + 1)])\n        return series_sum"], [0.9258561134338379, "    if n <= 0:\n        return 'Invalid input! n should be a positive integer.'\n    else:\n        series_sum = sum([i ** 4 for i in range(1, n + 1)])\n        return series_sum"], [0.9157467484474182, "    for i in range(start, n + 1):\n        fourth_power = i ** 4\n        result += fourth_power\n        print(f'Adding {fourth_power}, Running Sum: {result}')"], [0.9149415493011475, "    if not isinstance(n, int) or n < 1:\n        return 'n should be a positive integer'\n    if not isinstance(start, int) or start > n:\n        return 'start should be an integer between 1 and n'\n    result = 0\n    for i in range(start, n + 1):\n        fourth_power = i ** 4\n        result += fourth_power\n        print(f'Adding {fourth_power}, Running Sum: {result}')\n    return result"], [0.9040007591247559, "    if n == 1:\n        return 1\n    else:\n        return (2 * n - 1) ** 4 + sum_of_fourth_power_of_odds(n - 1)"], [0.9040007591247559, "    if n == 1:\n        return 1\n    else:\n        return (2 * n - 1) ** 4 + sum_of_fourth_power_of_odds(n - 1)"], [0.8981248140335083, "    sum = 0\n    for i in range(1, n + 1):\n        sum += i ** 3\n    return sum"], [0.8981162309646606, "    sum = 0\n    for i in range(1, n + 1):\n        sum += i ** 3\n    return sum"], [0.8981099128723145, "    sum = 0\n    for i in range(1, n + 1):\n        sum += i ** 3\n    return sum"], [0.8969637155532837, "    for num in range(1, n + 1):\n        sum += num ** 3"]]}
{"task_id": "MBPP/202", "problem": []}
{"task_id": "MBPP/203", "problem": [[0.9342823028564453, "    radians = degrees * (3.14159 / 180)\n    return radians"], [0.9314454793930054, "    radians = degrees * math.pi / 180\n    return radians"], [0.9305425882339478, "    pi = 3.14159\n    radians = degrees * pi / 180\n    return radians"], [0.9221442937850952, "    degrees = math.degrees(radian)\n    return degrees"], [0.9159969687461853, "    radians = degree * math.pi / 180\n    return round(radians, 6)"], [0.9131208658218384, "    return degrees * (math.pi / 180)"], [0.9131108522415161, "    return degrees * (math.pi / 180)"], [0.9090397357940674, "    degrees = gradians * 0.9\n    return degrees"], [0.8995916247367859, "    degrees = arc_minutes / 60.0\n    radians = degrees * (math.pi / 180.0)\n    return radians"], [0.8994482159614563, "    return deg * (3.14 / 180)"]]}
{"task_id": "MBPP/204", "problem": [[0.8937097787857056, "    decoded_string = ''\n    repeat_count = 0\n    for char in encoded_string:\n        if char.isdigit():\n            repeat_count = repeat_count * 10 + int(char)\n        elif repeat_count == 0:\n            decoded_string += char\n        else:\n            decoded_string += char * repeat_count\n            repeat_count = 0\n    return decoded_string"], [0.8860042095184326, "    for char in encoded_string:\n        if char.isdigit():\n            repeat_count = repeat_count * 10 + int(char)\n        elif repeat_count == 0:\n            decoded_string += char\n        else:\n            decoded_string += char * repeat_count\n            repeat_count = 0"], [0.8841612339019775, "    if not list_to_encode:\n        return []\n    else:\n        tmp = []\n        tmp.append(list_to_encode[0])\n        tmp.append(1)\n        i = 1\n        while i < len(list_to_encode) and list_to_encode[i] == tmp[0]:\n            tmp[1] += 1\n            i += 1\n        return tmp + encodeList(list_to_encode[i:])"], [0.8841612339019775, "    if not list_to_encode:\n        return []\n    else:\n        tmp = []\n        tmp.append(list_to_encode[0])\n        tmp.append(1)\n        i = 1\n        while i < len(list_to_encode) and list_to_encode[i] == tmp[0]:\n            tmp[1] += 1\n            i += 1\n        return tmp + encodeList(list_to_encode[i:])"], [0.8836823105812073, "        if char.isdigit():\n            repeat_count = repeat_count * 10 + int(char)\n        elif repeat_count == 0:\n            decoded_string += char\n        else:\n            decoded_string += char * repeat_count\n            repeat_count = 0"], [0.8764582872390747, "    rle_arr = []\n    for word in arr:\n        encoded = ''\n        i = 0\n        while i < len(word):\n            count = 1\n            while i + 1 < len(word) and word[i] == word[i + 1]:\n                i += 1\n                count += 1\n            encoded += '{}{}'.format(word[i], count)\n            i += 1\n        rle_arr.append(encoded)\n    return rle_arr"], [0.8729104995727539, "        elif repeat_count == 0:\n            decoded_string += char\n        else:\n            decoded_string += char * repeat_count\n            repeat_count = 0"], [0.8723968267440796, "    for word in arr:\n        encoded = ''\n        i = 0\n        while i < len(word):\n            count = 1\n            while i + 1 < len(word) and word[i] == word[i + 1]:\n                i += 1\n                count += 1\n            encoded += '{}{}'.format(word[i], count)\n            i += 1\n        rle_arr.append(encoded)"], [0.8721544742584229, "        if i.isdigit():\n            count = i + count\n        else:\n            decoded += i * int(count)\n            count = ''"], [0.8721371293067932, "    compressed_list = []\n    count = 1\n    for index in range(1, len(original_list)):\n        if original_list[index] == original_list[index - 1]:\n            count += 1\n        else:\n            compressed_list.append(str(original_list[index - 1]) + 'x' + str(count))\n            count = 1\n    compressed_list.append(str(original_list[index]) + 'x' + str(count))\n    return compressed_list"]]}
{"task_id": "MBPP/205", "problem": [[0.9089339971542358, "    return set(list1).issubset(set(list2))"], [0.9005025029182434, "    return all((i in main_list for i in potential_sublist))"], [0.8992447853088379, "    str_lst = ''.join(map(str, lst))\n    str_sublist = ''.join(map(str, sublist))\n    return str_sublist in str_lst"], [0.8979660868644714, "    if isinstance(sublist, list):\n        if sublist == []:\n            return True\n        elif sublist == main_list:\n            return True\n        elif len(sublist) > len(main_list):\n            return False\n        else:\n            for i in range(len(main_list)):\n                if main_list[i] == sublist[0]:\n                    return is_sublist(main_list[i + 1:], sublist[1:])\n            return False\n    else:\n        return sublist in main_list"], [0.8979660868644714, "    if isinstance(sublist, list):\n        if sublist == []:\n            return True\n        elif sublist == main_list:\n            return True\n        elif len(sublist) > len(main_list):\n            return False\n        else:\n            for i in range(len(main_list)):\n                if main_list[i] == sublist[0]:\n                    return is_sublist(main_list[i + 1:], sublist[1:])\n            return False\n    else:\n        return sublist in main_list"], [0.897607684135437, "    return all((item in mainList for item in subList))"], [0.8953961133956909, "    sorted_list1 = sort_nested_list(list1)\n    sorted_list2 = sort_nested_list(list2)\n    return sorted_list1 == sorted_list2"], [0.8951948285102844, "    return set(set1).issubset(set(set2))"], [0.894730269908905, "    if len(list2) > len(list1):\n        return False\n    for item in list1:\n        if item not in list2:\n            return False\n    return True"], [0.8938250541687012, "        if sublist == []:\n            return True\n        elif sublist == main_list:\n            return True\n        elif len(sublist) > len(main_list):\n            return False\n        else:\n            for i in range(len(main_list)):\n                if main_list[i] == sublist[0]:\n                    return is_sublist(main_list[i + 1:], sublist[1:])\n            return False"]]}
{"task_id": "MBPP/206", "problem": [[0.9278151988983154, "    char_count = {}\n    for char in input_string:\n        if char in char_count:\n            return char\n        else:\n            char_count[char] = 1\n    return 'No duplicates found'"], [0.9239374995231628, "    for i, letter in enumerate(string):\n        if letter in letter_count:\n            return ('Index:', i)\n        else:\n            letter_count[letter] = 1"], [0.9230350255966187, "    letter_count = {}\n    for i, letter in enumerate(string):\n        if letter in letter_count:\n            return ('Index:', i)\n        else:\n            letter_count[letter] = 1\n    return ('Index:', -1)"], [0.9215813875198364, "    count_dict = {}\n    for i in range(len(input_str)):\n        if input_str[i] in count_dict:\n            count_dict[input_str[i]] += 1\n        else:\n            count_dict[input_str[i]] = 1\n    for key, value in count_dict.items():\n        if value == 1:\n            return (key, input_str.index(key))\n    return ('All characters are repeating', None)"], [0.9194490909576416, "    for char in s:\n        if s.count(char) > 1:\n            return char"], [0.9191107749938965, "    s = s[::-1]\n    for char in s:\n        if s.count(char) > 1:\n            return char\n    return 'None'"], [0.9189450740814209, "    seen_characters = set()\n    for c in s:\n        if c not in seen_characters:\n            seen_characters.add(c)\n        else:\n            return c\n    return None"], [0.9178426265716553, "    char_set = set()\n    for c in s:\n        if c in char_set:\n            return c\n        char_set.add(c)\n    return None"], [0.9176840782165527, "    char_freq = {}\n    for i in range(len(string)):\n        if string[i] in char_freq:\n            char_freq[string[i]] += 1\n        else:\n            char_freq[string[i]] = 1\n    for i in range(len(string)):\n        if char_freq[string[i]] == 1:\n            return (string[i], i)\n    return (None, -1)"], [0.9176840782165527, "    char_freq = {}\n    for i in range(len(string)):\n        if string[i] in char_freq:\n            char_freq[string[i]] += 1\n        else:\n            char_freq[string[i]] = 1\n    for i in range(len(string)):\n        if char_freq[string[i]] == 1:\n            return (string[i], i)\n    return (None, -1)"]]}
{"task_id": "MBPP/207", "problem": [[0.8935064077377319, "    operations = 0\n    current_bit = '0'\n    for bit in target:\n        if bit != current_bit:\n            operations += 1\n            current_bit = bit\n    return operations"], [0.893482506275177, "    operations = 0\n    current_bit = '0'\n    for bit in target:\n        if bit != current_bit:\n            operations += 1\n            current_bit = bit\n    return operations"], [0.8899919986724854, "    sum1, sum2 = (sum(nums1), sum(nums2))\n    if sum1 == sum2:\n        return 0\n    if sum1 < sum2:\n        nums1, nums2 = (nums2, nums1)\n    nums1.sort(reverse=True)\n    nums2.sort()\n    diff, operations, i, j = (abs(sum1 - sum2), 0, 0, 0)\n    while diff > 0 and (i < len(nums1) or j < len(nums2)):\n        option1 = nums1[i] - 1 if i < len(nums1) else 0\n        option2 = 6 - nums2[j] if j < len(nums2) else 0\n        if option1 > option2:\n            diff -= option1\n            i += 1\n        else:\n            diff -= option2\n            j += 1\n        operations += 1\n    return operations if diff == 0 else -1"], [0.8889824151992798, "        for num in nums:\n            operations += abs(num - query)"], [0.888308048248291, "    xor_value = start ^ goal\n    flips = 0\n    while xor_value:\n        flips += xor_value & 1\n        xor_value >>= 1\n    return flips"], [0.8881949782371521, "    elif diff < 0:\n        return b\n    else:\n        return 'Both numbers are equal.'"], [0.8872079253196716, "    if x == target:\n        return 0"], [0.8868248462677002, "    operations = 0\n    while target > startValue:\n        target = target // 2 if target % 2 == 0 else target + 1\n        operations += 1\n    return operations + startValue - target"], [0.883730947971344, "    for query in queries:\n        operations = 0\n        for num in nums:\n            operations += abs(num - query)\n        answer.append(operations)"], [0.8833310008049011, "    if isinstance(num1, (int, float)) and isinstance(num2, (int, float)):\n        if num1 < 0 and num2 < 0:\n            return max(abs(num1), abs(num2))\n        elif num1 % 2 == 0 and num2 % 2 == 0:\n            return max(num1 / 2, num2 / 2)\n        elif num1 % 2 != 0 and num2 % 2 != 0:\n            return max(num1 * 3 + 1, num2 * 3 + 1)\n        else:\n            return max(num1, num2) - min(num1, num2)\n    else:\n        return 'Error: Inputs must be numbers.'"]]}
{"task_id": "MBPP/208", "problem": [[0.8939972519874573, "    minValue = arr[0]\n    maxValue = arr[0]\n    for i in range(k):\n        if arr[i] > maxValue:\n            maxValue = arr[i]\n        if arr[i] < minValue:\n            minValue = arr[i]\n    return (minValue, maxValue)"], [0.8827095031738281, "    if len(tup_list) == 0:\n        return 'The tuple list is empty.'\n    if k > len(tup_list):\n        return 'K is greater than the size of list. Returning all records.'\n    tup_list.sort(key=lambda x: x[0])\n    return tup_list[:k]"], [0.8752431273460388, "    max_values = []\n    for tup in list_of_tuples:\n        max_values.append(max(tup))\n    return max_values"], [0.8744155168533325, "    max = list[0]\n    min = list[0]\n    for i in range(1, len(list)):\n        if list[i] > max:\n            max = list[i]\n        if list[i] < min:\n            min = list[i]\n    return (max, min)"], [0.8743972182273865, "    max = list[0]\n    min = list[0]\n    for i in range(1, len(list)):\n        if list[i] > max:\n            max = list[i]\n        if list[i] < min:\n            min = list[i]\n    return (max, min)"], [0.8731159567832947, "    min_ = my_list[0]\n    max_ = my_list[0]\n    for element in my_list:\n        if element < min_:\n            min_ = element\n        elif element > max_:\n            max_ = element\n    return (min_, max_)"], [0.8730686902999878, "    min_num = lst[0]\n    max_num = lst[0]\n    for num in lst[1:]:\n        if num < min_num:\n            min_num = num\n        if num > max_num:\n            max_num = num\n    return (min_num, max_num)"], [0.8728500604629517, "    max_element = lst[0]\n    min_element = lst[0]\n    for i in range(len(lst)):\n        if max_element < lst[i]:\n            max_element = lst[i]\n        if min_element > lst[i]:\n            min_element = lst[i]\n    return (max_element, min_element)"], [0.8727710247039795, "    max = list[0]\n    min = list[0]\n    for i in range(len(list)):\n        if list[i] > max:\n            max = list[i]\n        if list[i] < min:\n            min = list[i]\n    return (max, min)"], [0.8726423978805542, "    min_num = numbers[0]\n    max_num = numbers[0]\n    for num in numbers:\n        if num < min_num:\n            min_num = num\n        if num > max_num:\n            max_num = num\n    return (min_num, max_num)"]]}
{"task_id": "MBPP/209", "problem": [[0.9000027775764465, "    replacements = 0\n    new_line = []\n    for char in line:\n        if char in [' ', ',', '.']:\n            new_line.append(':')\n            replacements += 1\n        else:\n            new_line.append(char)\n    return (''.join(new_line), replacements)"], [0.8894240856170654, "    for char in line:\n        if char in [' ', ',', '.']:\n            new_line.append(':')\n            replacements += 1\n        else:\n            new_line.append(char)"], [0.8873562216758728, "        if char in [' ', ',', '.']:\n            new_line.append(':')\n            replacements += 1\n        else:\n            new_line.append(char)"], [0.8841404914855957, "    if len(parts) > n:\n        return substring.join(parts[:-1]) + replacement + substring.join(parts[-1:])"], [0.8819694519042969, "    return text.replace(' ', ':').replace(',', ':').replace('.', ':')"], [0.8818114995956421, "    words = string.split()\n    last_index = -1\n    capitalized_word = word.capitalize()\n    for i in range(len(words) - 1, -1, -1):\n        if words[i].lower() == word.lower() and words[i + 1] == ',':\n            words[i] = capitalized_word\n            last_index = i\n            break\n    if last_index != -1:\n        replaced_string = ' '.join(words)\n        return replaced_string\n    return string"], [0.876558244228363, "    output = ''\n    for char in string:\n        if char == ',':\n            output += char + ' '\n        else:\n            output += char\n    return output"], [0.8762739896774292, "    parts = original_string.split(substring, n)\n    if len(parts) > n:\n        return substring.join(parts[:-1]) + replacement + substring.join(parts[-1:])\n    return original_string"], [0.8736897706985474, "    try:\n        float_n = float(n)\n        if '.' in n:\n            int_part, dec_part = n.split('.')\n            return '{:,}'.format(int(float_n)) + '.' + dec_part\n        else:\n            return '{:,}'.format(int(n))\n    except ValueError:\n        return 'Invalid Input'"], [0.8736897706985474, "    try:\n        float_n = float(n)\n        if '.' in n:\n            int_part, dec_part = n.split('.')\n            return '{:,}'.format(int(float_n)) + '.' + dec_part\n        else:\n            return '{:,}'.format(int(n))\n    except ValueError:\n        return 'Invalid Input'"]]}
{"task_id": "MBPP/210", "problem": [[0.9249582290649414, "    evens = []\n    for i in list:\n        if i % 2 == 0:\n            evens.append(i)\n    if not evens:\n        return 'There are no even numbers in the list.'\n    else:\n        return min(evens)"], [0.9212262630462646, "    even_numbers = [number for number in input_list if number % 2 == 0]\n    return min(even_numbers) if even_numbers else None"], [0.9210383892059326, "    even_numbers = [num for num in lst if num % 2 == 0]\n    if even_numbers:\n        return min(even_numbers)\n    else:\n        return 'Element does not exist'"], [0.918404757976532, "    if type(lst) is not list:\n        return 'Error: The provided input is not a list!'\n    smallest_even = float('inf')\n    smallest_even_indices = []\n    for i in range(len(lst)):\n        if type(lst[i]) is not int:\n            return 'Error: List contains non-integer values!'\n        if lst[i] % 2 == 0 and lst[i] < smallest_even:\n            smallest_even = lst[i]\n            smallest_even_indices = [i]\n        elif lst[i] == smallest_even:\n            smallest_even_indices.append(i)\n    if smallest_even == float('inf'):\n        return 'No even number found!'\n    else:\n        return (smallest_even, smallest_even_indices)"], [0.9155980348587036, "    even_list = [num for num in lst if num % 2 == 0]\n    return min(even_list) if even_list else None"], [0.9142711758613586, "    if not evens:\n        return 'There are no even numbers in the list.'\n    else:\n        return min(evens)"], [0.9139925241470337, "    if even_numbers:\n        return min(even_numbers)\n    else:\n        return 'Element does not exist'"], [0.9138413071632385, "    even_numbers = sorted([num for num in numbers if num % 2 == 0])\n    if even_numbers:\n        return even_numbers[0]\n    else:\n        return None"], [0.9136892557144165, "    even_numbers = list(filter(lambda x: x % 2 == 0, numbers))\n    if not even_numbers:\n        print('There are no even numbers in the list.')\n        return None\n    return min(even_numbers)"], [0.9114737510681152, "    count_even = 0\n    for num in arr:\n        if num % 2 == 0:\n            count_even += 1\n        else:\n            break\n    return count_even"]]}
{"task_id": "MBPP/211", "problem": [[0.9053579568862915, "    for element in new_elements:\n        if type(element) != type(old_tuple[0]):\n            return False\n    return True"], [0.9041476845741272, "    types_set = set()\n    for item in input_list:\n        types_set.add(type(item))\n    return len(types_set) == len(input_list)"], [0.8989526629447937, "    if len(lst) == 0:\n        return True\n    first_type = type(lst[0])\n    return all((isinstance(i, first_type) for i in lst))"], [0.8987243175506592, "    for element in new_elements:\n        if type(element) != type(old_tuple[0]):\n            return False"], [0.8921175599098206, "    if len(lst) < 2:\n        return True\n    first_type = type(lst[0])\n    if first_type == list or first_type == dict:\n        first_type = check_same_data_type(lst[0])\n    for item in lst[1:]:\n        item_type = type(item)\n        if item_type == list or item_type == dict:\n            item_type = check_same_data_type(item)\n        if item_type != first_type:\n            return False\n    return True"], [0.8910931944847107, "        if type(element) != type(old_tuple[0]):\n            return False"], [0.8890680074691772, "    return all((isinstance(element, type) for element in elements))"], [0.8861453533172607, "    for item in lst[1:]:\n        item_type = type(item)\n        if item_type == list or item_type == dict:\n            item_type = check_same_data_type(item)\n        if item_type != first_type:\n            return False"], [0.8849244117736816, "    if not lst:\n        return True\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True"], [0.8836731910705566, "    if len(lst) == 0:\n        return False\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True"]]}
{"task_id": "MBPP/212", "problem": [[0.9086649417877197, "    for num in arr:\n        if count == 0:\n            majority = num\n            count = 1\n        elif num == majority:\n            count += 1\n        else:\n            count -= 1"], [0.9065130949020386, "    count = 0\n    majority = None\n    for num in arr:\n        if count == 0:\n            majority = num\n            count = 1\n        elif num == majority:\n            count += 1\n        else:\n            count -= 1\n    return majority"], [0.9025843143463135, "    length = len(arr)\n    count = {}\n    for i in arr:\n        if i not in count:\n            count[i] = 1\n        else:\n            count[i] += 1\n    max_count = max(count.values())\n    if max_count > length // 2:\n        majority_element = [key for key in count.keys() if count[key] == max_count]\n        return majority_element[0]\n    else:\n        return -1"], [0.9011974334716797, "        if count == 0:\n            majority = num\n            count = 1\n        elif num == majority:\n            count += 1\n        else:\n            count -= 1"], [0.8999193906784058, "    elem_count = {}\n    for elem in arr:\n        if elem not in elem_count:\n            elem_count[elem] = 0\n        elem_count[elem] += 1\n    max_count = 0\n    majority_element = None\n    for elem, freq in elem_count.items():\n        if freq > max_count:\n            max_count = freq\n            majority_element = elem\n    return majority_element"], [0.8992560505867004, "    maj_index = 0\n    count = 1\n    for i in range(1, len(arr)):\n        if arr[i] == arr[maj_index]:\n            count += 1\n        else:\n            count -= 1\n        if count == 0:\n            maj_index = i\n            count = 1\n    if count > len(arr) // 2:\n        return arr[maj_index]\n    else:\n        return None"], [0.8989195823669434, "        elif num == majority:\n            count += 1\n        else:\n            count -= 1"], [0.8970448970794678, "    sorted_lst = sorted(lst)\n    median = sorted_lst[len(sorted_lst) // 2]\n    if element >= median and element in lst:\n        return True\n    else:\n        return False"], [0.8964405655860901, "    for i in arr:\n        if i != majority:\n            return i"], [0.8951907157897949, "    if max_count > length // 2:\n        majority_element = [key for key in count.keys() if count[key] == max_count]\n        return majority_element[0]\n    else:\n        return -1"]]}
{"task_id": "MBPP/213", "problem": [[0.9172120690345764, "    count = 0\n    while number > 0:\n        if number & 1:\n            count += 1\n        number >>= 1\n    return count"], [0.9161561727523804, "    count = 0\n    while n != 0:\n        count += n & 1\n        n >>= 1\n    return count"], [0.9148305654525757, "    return bin(n).count('1')"], [0.9143856167793274, "    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"], [0.9143756628036499, "    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"], [0.9143679738044739, "    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"], [0.9142752885818481, "    count = 0\n    while n > 0:\n        if n & 1:\n            count += 1\n        n >>= 1\n    return count"], [0.9119019508361816, "    while n != 0:\n        count += n & 1\n        n >>= 1"], [0.9097832441329956, "    while number > 0:\n        if number & 1:\n            count += 1\n        number >>= 1"], [0.9086279273033142, "    count = 0\n    while n:\n        count ^= n & 1\n        n >>= 1\n    return count"]]}
{"task_id": "MBPP/214", "problem": [[0.9026049375534058, "    if len(arr) == 0:\n        return None\n    if len(arr) == 1:\n        return arr[0]\n    mid = len(arr) // 2\n    if mid > 0 and arr[mid - 1] > arr[mid]:\n        return arr[mid]\n    elif arr[mid + 1] < arr[mid]:\n        return arr[mid + 1]\n    elif arr[mid] > arr[0]:\n        return find_min_element(arr[0:mid])\n    else:\n        return find_min_element(arr[mid + 1:len(arr) - 1])"], [0.902469277381897, "    if len(arr) == 1:\n        return arr[0]\n    elif len(arr) == 2:\n        return min(arr[0], arr[1])\n    mid = len(arr) // 2\n    left_min = find_minimum(arr[:mid])\n    right_min = find_minimum(arr[mid:])\n    return min(left_min, right_min)"], [0.9018639326095581, "    elif arr[mid] > arr[0]:\n        return find_min_element(arr[0:mid])\n    else:\n        return find_min_element(arr[mid + 1:len(arr) - 1])"], [0.9010086059570312, "    n = len(arr)\n    if n == 1:\n        return arr[0]\n    mid = n // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    min_left = find_min(left_half)\n    min_right = find_min(right_half)\n    return min(min_left, min_right)"], [0.8992480039596558, "    left, right = (0, len(rotated) - 1)\n    while left < right:\n        mid = left + (right - left) // 2\n        if rotated[mid] > rotated[right]:\n            left = mid + 1\n        else:\n            right = mid\n    return rotated[left]"], [0.8979260325431824, "    if len(arr) == 1:\n        return arr[0]\n    if arr[0] < arr[-1]:\n        return arr[0]\n    mid = len(arr) // 2\n    if arr[mid] < arr[-1]:\n        return find_smallest_element(arr[:mid + 1])\n    return find_smallest_element(arr[mid + 1:])"], [0.8969062566757202, "    elif arr[mid + 1] < arr[mid]:\n        return arr[mid + 1]\n    elif arr[mid] > arr[0]:\n        return find_min_element(arr[0:mid])\n    else:\n        return find_min_element(arr[mid + 1:len(arr) - 1])"], [0.8968856334686279, "    while left < right:\n        mid = left + (right - left) // 2\n        if rotated[mid] > rotated[right]:\n            left = mid + 1\n        else:\n            right = mid"], [0.8968470692634583, "    minimum = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < minimum:\n            minimum = arr[i]\n    return minimum"], [0.8959910869598389, "        if rotated[mid] > rotated[right]:\n            left = mid + 1\n        else:\n            right = mid"]]}
{"task_id": "MBPP/215", "problem": [[0.9377486109733582, "    odd_position = ''\n    for i in range(len(string)):\n        if i % 2 == 0:\n            odd_position += string[i]\n    return odd_position"], [0.9261994361877441, "    new_str = ''\n    for ch in str:\n        if ord(ch) % 2 == 0:\n            new_str += ch\n    return new_str"], [0.92252516746521, "    result_string = ''\n    for i in range(0, len(string)):\n        if i % 2 == 0:\n            result_string += string[i]\n    return result_string"], [0.9222906231880188, "    result = ''\n    for i in range(len(string)):\n        if i % 2 == 0:\n            result += string[i]\n    return result"], [0.9213665723800659, "    result = ''\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result += str[i]\n    return result"], [0.9188176989555359, "    output = ''\n    for i in range(len(s)):\n        if i % 2 != 0:\n            pass\n        else:\n            output += s[i]\n    return output"], [0.917171835899353, "    words = sentence.split(' ')\n    even_index_words = [words[i] for i in range(len(words)) if i % 2 == 0]\n    return ' '.join(even_index_words)"], [0.9162158966064453, "    result = ''\n    for i in range(len(string)):\n        if i % 2 == 0:\n            result = result + string[i]\n    return result"], [0.9142429828643799, "    result = ''\n    for i in range(len(string)):\n        if i % 2 != 0:\n            result += string[i]\n    return result"], [0.9141232967376709, "    word_list = in_string.split()\n    out_list = []\n    for i in range(len(word_list)):\n        if i % 2 == 0:\n            out_list.append(word_list[i])\n    return out_list"]]}
{"task_id": "MBPP/216", "problem": [[0.9351513385772705, "    return min(num1, num2, num3)"], [0.9306831955909729, "    min_number = min(a, b, c)\n    return min_number"], [0.9229660630226135, "    min_value = a\n    if b < min_value:\n        min_value = b\n    if c < min_value:\n        min_value = c\n    return min_value"], [0.9226977229118347, "    return min(a, b, c)"], [0.9226962327957153, "    return min(a, b, c)"], [0.9226893186569214, "    return min(a, b, c)"], [0.922686755657196, "    return min(a, b, c)"], [0.922686755657196, "    return min(a, b, c)"], [0.916199803352356, "    smallest = num1\n    if smallest > num2:\n        smallest = num2\n    if smallest > num3:\n        smallest = num3\n    return smallest"], [0.9144186973571777, "    if a < b and a < c:\n        return min(b, c)\n    elif b < a and b < c:\n        return min(a, c)\n    return min(a, b)"]]}
{"task_id": "MBPP/217", "problem": [[0.8772255778312683, "    for flag in subset:\n        if not bitmask & flag:\n            return False\n    return True"], [0.8760645389556885, "    for num in my_list:\n        if num & mask != 0:\n            print(num)"], [0.8710764050483704, "    for flag in subset:\n        if not bitmask & flag:\n            return False"], [0.8704241514205933, "    return all((num == 0 for num in int_list))"], [0.8656423687934875, "    if int in range(...):\n        return not bool"], [0.8656423687934875, "    if int in range(...):\n        return not bool"], [0.8655660152435303, "    result = []\n    result.append(x & y)\n    result.append(x | y)\n    result.append(x ^ y)\n    count_x = bin(x).count('1')\n    count_y = bin(y).count('1')\n    if count_x > count_y:\n        result.append('x has more set bits')\n    elif count_y > count_x:\n        result.append('y has more set bits')\n    return result"], [0.8647620677947998, "    while mask & result == 0:\n        mask = mask << 1"], [0.8638074398040771, "        elif not (byte & mask1 and (not byte & mask2)):\n            return False"], [0.8635165095329285, "    sum = -(-num1 - num2)\n    within_range = sum - start & end - sum >> 31\n    return bool(within_range)"]]}
{"task_id": "MBPP/218", "problem": [[0.9379390478134155, "    negative_index = 0\n    for num in arr:\n        if num < 0:\n            temp = arr[negative_index]\n            arr[negative_index] = num\n            arr[arr.index(num)] = temp\n            negative_index += 1\n    return arr"], [0.937507152557373, "    negative_nums = []\n    positive_nums = []\n    for num in array:\n        if num < 0:\n            negative_nums.append(num)\n        else:\n            positive_nums.append(num)\n    return negative_nums + positive_nums"], [0.9352561235427856, "    positives = []\n    negatives = []\n    for x in arr:\n        if x < 0:\n            negatives.append(x)\n        else:\n            positives.append(x)\n    return positives + negatives"], [0.931486964225769, "    for num in arr:\n        if num < 0:\n            temp = arr[negative_index]\n            arr[negative_index] = num\n            arr[arr.index(num)] = temp\n            negative_index += 1"], [0.9267987012863159, "    negative = [i for i in array if i < 0]\n    positive = [i for i in array if i >= 0]\n    quickSort(negative, 0, len(negative) - 1)\n    quickSort(positive, 0, len(positive) - 1)\n    return negative[::-1] + positive"], [0.9260299205780029, "    j = -1\n    for i in range(len(arr)):\n        if arr[i] < 0:\n            j += 1\n            arr[i], arr[j] = (arr[j], arr[i])\n    return arr"], [0.9256386160850525, "    arr.sort()\n    newArr = []\n    start = 0\n    end = len(arr) - 1\n    while start <= end:\n        if arr[start] < 0:\n            newArr.append(arr[start])\n            start += 1\n        else:\n            newArr.append(arr[end])\n            end -= 1\n    return newArr"], [0.9222574830055237, "    positive_list = []\n    negative_list = []\n    for num in numbers:\n        if num < 0:\n            negative_list.append(num)\n        else:\n            positive_list.append(num)\n    return positive_list + negative_list"], [0.9208520650863647, "        if num < 0:\n            temp = arr[negative_index]\n            arr[negative_index] = num\n            arr[arr.index(num)] = temp\n            negative_index += 1"], [0.9193507432937622, "    n = len(arr)\n    left = 0\n    right = n - 1\n    while left < right:\n        while arr[left] < 0 and left < right:\n            left += 1\n        while arr[right] >= 0 and left < right:\n            right -= 1\n        if left < right:\n            arr[left], arr[right] = (arr[right], arr[left])\n            left += 1\n            right -= 1\n    return arr"]]}
{"task_id": "MBPP/219", "problem": [[0.9162598848342896, "    return string.replace(' ', character)"], [0.9162452220916748, "    return string.replace(' ', character)"], [0.9162402749061584, "    return string.replace(' ', character)"], [0.916231632232666, "    return string.replace(' ', character)"], [0.9110650420188904, "    result = ''\n    for char in string:\n        if char == ' ':\n            result += character\n        else:\n            result += char\n    return result"], [0.9051140546798706, "    outputString = ''\n    for c in inputString:\n        if c == character:\n            outputString += '_'\n        else:\n            outputString += c\n    return outputString"], [0.9007976055145264, "    new_string = ''\n    for char in input_string:\n        if char == ' ':\n            new_string += '*'\n        else:\n            new_string += char\n    return new_string"], [0.8999205827713013, "    new_str = ''\n    for c in str:\n        if c == char_to_be_replaced:\n            c = replacement_char\n        new_str += c\n    return new_str"], [0.8985050320625305, "    for char in string:\n        if char == ' ':\n            result += character\n        else:\n            result += char"], [0.8983389139175415, "    for c in inputString:\n        if c == character:\n            outputString += '_'\n        else:\n            outputString += c"]]}
{"task_id": "MBPP/220", "problem": [[0.8919818997383118, "    sum_list = [sum(row) for row in arr]\n    max_element = max(sum_list)\n    return max_element"], [0.8861929178237915, "    for i in range(len(arr)):\n        row_sum = sum(arr[i])\n        print('Sum of elements in row', i, ':', row_sum)\n    max_row = find_row_with_highest_sum(arr)\n    print('Row with highest sum:', max_row)"], [0.883316695690155, "    if right_sum > max_value:\n        max_value = right_sum"]]}
{"task_id": "MBPP/221", "problem": [[0.9070794582366943, "    sorted_dataset = sorted(dataset, key=lambda item: item['cost'], reverse=True)\n    return sorted_dataset[:n]"], [0.9070514440536499, "    sorted_dataset = sorted(dataset, key=lambda item: item['cost'], reverse=True)\n    return sorted_dataset[:n]"], [0.9029162526130676, "    if num > len(data):\n        print('The number of elements to be selected is greater than the number of elements in the list.')\n        return\n    result = sorted([(i, val) for i, val in enumerate(data)], key=lambda x: x[1], reverse=True)\n    return sorted(result[:num], key=lambda x: x[1], reverse=True)"], [0.902910590171814, "    if num > len(data):\n        print('The number of elements to be selected is greater than the number of elements in the list.')\n        return\n    result = sorted([(i, val) for i, val in enumerate(data)], key=lambda x: x[1], reverse=True)\n    return sorted(result[:num], key=lambda x: x[1], reverse=True)"], [0.9006518125534058, "    highest = heapq.nlargest(5, dataset)\n    lowest = heapq.nsmallest(5, dataset)\n    return (highest, lowest)"], [0.8980869054794312, "    B = sorted(A, reverse=True)\n    return B[:n]"], [0.8972790241241455, "    counts = {}\n    for element in data:\n        if element in counts:\n            counts[element] += 1\n        else:\n            counts[element] = 1\n    sorted_counts = sorted(counts.items(), key=lambda x: x[1])\n    return sorted_counts[-n][0]"], [0.8959881067276001, "    arr.sort()\n    top_n = arr[:n]\n    return top_n"], [0.8932051658630371, "    items = list(dict.values())[-n:]\n    items.reverse()\n    return items"], [0.8920648694038391, "    if n > len(lst):\n        return 'Error: n is larger than the number of elements in the list.'\n    else:\n        bubble_sort_desc(lst)\n        return lst[n - 1]"]]}
{"task_id": "MBPP/222", "problem": [[0.9011034965515137, "    if r1 < 0 or r2 < 0 or s < 0:\n        return 'Error: the radii and height must be positive numbers.'\n    lateral_surface_area = math.pi * (r1 + r2) * math.sqrt((r1 - r2) ** 2 + s ** 2)\n    return lateral_surface_area"], [0.8980379700660706, "    surface_area = 4 * 3.14159 * radius ** 2\n    return round(surface_area, 2)"], [0.8940110206604004, "    surface_area = 4 * math.pi * radius * radius\n    return surface_area"], [0.8910816311836243, "    return math.pi * cylinder['radius'] ** 2 * cylinder['height']"], [0.8909937143325806, "    result = []\n    for frustum in list_of_frustums:\n        r1, r2, l = frustum\n        if r1 < 0 or r2 < 0 or l < 0:\n            raise ValueError('Invalid values. Radii and height must be non-negative.')\n        else:\n            lateral_surface_area = math.pi * (r1 + r2) * math.sqrt((r2 - r1) ** 2 + l ** 2)\n            result.append(lateral_surface_area)\n    return result"], [0.8892340064048767, "        if r1 < 0 or r2 < 0 or l < 0:\n            raise ValueError('Invalid values. Radii and height must be non-negative.')\n        else:\n            lateral_surface_area = math.pi * (r1 + r2) * math.sqrt((r2 - r1) ** 2 + l ** 2)\n            result.append(lateral_surface_area)"], [0.8891229629516602, "    lateral_surface_area = 2 * l * h + b * h\n    total_surface_area = lateral_surface_area + 2 * l * b\n    return (lateral_surface_area, total_surface_area)"], [0.8885666131973267, "    r1 = frustum['r1']\n    r2 = frustum['r2']\n    h = frustum['h']\n    lateral_area = pi * (r1 + r2) * h\n    return round(lateral_area, 15)"], [0.8885608315467834, "    r1 = frustum['r1']\n    r2 = frustum['r2']\n    h = frustum['h']\n    lateral_area = pi * (r1 + r2) * h\n    return round(lateral_area, 15)"], [0.8885279893875122, "    r1 = frustum['r1']\n    r2 = frustum['r2']\n    h = frustum['h']\n    lateral_area = pi * (r1 + r2) * h\n    return round(lateral_area, 15)"]]}
{"task_id": "MBPP/223", "problem": [[0.8981045484542847, "    volume = side_length ** 3\n    return volume"], [0.8973275423049927, "    volume_one_cuboid = length * breadth * height\n    combined_volume = volume_one_cuboid * number_of_cuboids\n    return combined_volume"], [0.8972886800765991, "    cube_radius = pow(r, 3)\n    volume = 4 / 3 * math.pi * cube_radius\n    return volume"], [0.8970690965652466, "    volume = length ** 3\n    return volume"]]}
{"task_id": "MBPP/224", "problem": [[0.8977289795875549, "    even_set = set()\n    for num in numbers:\n        if num % 2 == 0:\n            even_set.add(num)\n    return even_set"], [0.8902865052223206, "    unique_even_numbers = set()\n    for num in numbers:\n        if num % 2 == 0:\n            unique_even_numbers.add(num)\n    return unique_even_numbers"], [0.8896710276603699, "        if arr[i] % 2 == 0:\n            arr[i] = 0"], [0.8896523118019104, "        if arr[i] % 2 == 0:\n            arr[i] = 0"], [0.8882796168327332, "    for i in range(len(arr)):\n        if arr[i] % 2 == 0:\n            arr[i] = 0"], [0.8882683515548706, "    for i in range(len(arr)):\n        if arr[i] % 2 == 0:\n            arr[i] = 0"], [0.8870211839675903, "    for i in range(len(arr)):\n        if arr[i] % 2 == 0:\n            arr[i] = 0\n    return arr"], [0.8870202898979187, "    for i in range(len(arr)):\n        if arr[i] % 2 == 0:\n            arr[i] = 0\n    return arr"], [0.8866353631019592, "        if num & 1 == 0:\n            even.append(num)\n        else:\n            odd.append(num)"], [0.8860903382301331, "    even_nums = []\n    for num in nums:\n        if num % 2 == 0:\n            even_nums.append(num)\n    return even_nums"]]}
{"task_id": "MBPP/225", "problem": [[0.8844745755195618, "    count = 0\n    for triangle in triangles:\n        if len(set(triangle)) == 1 and triangle.count(triangle[0]) >= 2:\n            count += 1\n    return count"], [0.8840988278388977, "    count = 0\n    m = B // 6\n    for i in range(m - 1, m + 2):\n        L = math.sqrt(3 * math.pow(i, 2) - 3 * i + 1)\n        count += 1 if L <= max_distance else 0\n    return count"], [0.8821601867675781, "        for x, count in enumerate(triangles):\n            if count == exactly:\n                return x"], [0.8795377016067505, "    for triangle in triangles:\n        if len(set(triangle)) == 1 and triangle.count(triangle[0]) >= 2:\n            count += 1"], [0.8778606653213501, "    return (a + b + c - max(a, b, c)) // 2"], [0.8771082162857056, "    return math.floor(n / math.sqrt(3))"], [0.8770555257797241, "    y_limit = exactly * 2\n    while True:\n        triangles = count_triples(y_limit)\n        for x, count in enumerate(triangles):\n            if count == exactly:\n                return x\n        y_limit += exactly"], [0.8760205507278442, "        if len(set(triangle)) == 1 and triangle.count(triangle[0]) >= 2:\n            count += 1"], [0.8755345940589905, "    for i in range(m - 1, m + 2):\n        L = math.sqrt(3 * math.pow(i, 2) - 3 * i + 1)\n        count += 1 if L <= max_distance else 0"], [0.875342071056366, "    while True:\n        triangles = count_triples(y_limit)\n        for x, count in enumerate(triangles):\n            if count == exactly:\n                return x\n        y_limit += exactly"]]}
{"task_id": "MBPP/226", "problem": [[0.8928461074829102, "    flattened_tuple1 = flatten(tuple1)\n    flattened_tuple2 = flatten(tuple2)\n    count_dict1 = {i: flattened_tuple1.count(i) for i in flattened_tuple1}\n    count_dict2 = {i: flattened_tuple2.count(i) for i in flattened_tuple2}\n    all_keys = set(list(count_dict1.keys()) + list(count_dict2.keys()))\n    dicts = {'tuple1': count_dict1, 'tuple2': count_dict2}\n    result = identify(all_keys, dicts)\n    return result"], [0.8917708396911621, "    result = {}\n    for i, element in enumerate(input_tuple):\n        if input_tuple.count(element) > 1:\n            if element not in result:\n                result[element] = {'first_index': input_tuple.index(element), 'last_index': len(input_tuple) - 1 - input_tuple[::-1].index(element)}\n    return result"], [0.8914268016815186, "    flatted_tuple1 = flatten(tuple1)\n    flatted_tuple2 = flatten(tuple2)\n    count_dict1 = {i: flatted_tuple1.count(i) for i in flatted_tuple1}\n    count_dict2 = {i: flatted_tuple2.count(i) for i in flatted_tuple2}\n    all_keys = set(list(count_dict1.keys()) + list(count_dict2.keys()))\n    dicts = {'tuple1': count_dict1, 'tuple2': count_dict2}\n    result = identify(all_keys, dicts)\n    return result"], [0.8909373879432678, "    for item, count in unique_t1.items():\n        result_dict[item] = (count, 'tuple1')"], [0.8899388313293457, "    for item, count in unique_t2.items():\n        result_dict[item] = (count, 'tuple2')"], [0.8883282542228699, "    counts = {x: example_list.count(x) for x in example_list}\n    count = 0\n    for key, value in counts.items():\n        if value > 1:\n            count += 1\n    return count"], [0.8873628973960876, "    seen = set()\n    duplicates = set()\n    for item in input_tuple:\n        if item in seen:\n            duplicates.add(item)\n        seen.add(item)\n    return (len(duplicates) > 0, duplicates)"], [0.8870044350624084, "    flat_t1 = flatten(t1)\n    flat_t2 = flatten(t2)\n    counter_t1 = Counter(flat_t1)\n    counter_t2 = Counter(flat_t2)\n    unique_t1 = counter_t1 - counter_t2\n    unique_t2 = counter_t2 - counter_t1\n    common = counter_t1 & counter_t2\n    result_dict = {}\n    for item, count in unique_t1.items():\n        result_dict[item] = (count, 'tuple1')\n    for item, count in unique_t2.items():\n        result_dict[item] = (count, 'tuple2')\n    for item, count in common.items():\n        result_dict[item] = ([(count, counter_t2[item])], 'both')\n    return result_dict"], [0.8861669898033142, "    count = {}\n    for i in t:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n    duplicates = {k: v for k, v in count.items() if v > 1}\n    return duplicates"], [0.886145293712616, "        if input_tuple.count(element) > 1:\n            if element not in result:\n                result[element] = {'first_index': input_tuple.index(element), 'last_index': len(input_tuple) - 1 - input_tuple[::-1].index(element)}"]]}
{"task_id": "MBPP/227", "problem": [[0.9085758328437805, "    substrings = set()\n    n = len(string)\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substrings.add(string[i:j])\n    return len(substrings)"], [0.9074306488037109, "    substrings = set()\n    for i in range(len(string)):\n        for j in range(i + 1, len(string) + 1):\n            substrings.add(string[i:j])\n    return len(substrings)"]]}
{"task_id": "MBPP/228", "problem": [[0.9029790163040161, "    eps = 1e-10\n    dp = [[0] * 110 for _ in range(110)]\n    cnt = [[0] * 110 for _ in range(110)]\n    dp[1][1] = 1\n    dp[2][1] = 2\n    dp[2][2] = 1\n    cnt[1][1] = 1\n    cnt[2][1] = 2\n    cnt[2][2] = 1\n    for i in range(3, 101):\n        dp[i][1] = i\n        cnt[i][1] = i\n        dp[i][2] = i - 1\n        cnt[i][2] = cnt[i - 1][2]\n        for j in range(3, min(i + 1, m + 1)):\n            for k in range(j, i + 1):\n                dp[i][j] += ((dp[k - 1][j - 1] + cnt[k - 1][j - 1]) * 2.0 + dp[i - 1][j] + cnt[i - 1][j]) / (i - j + 3) + 1e-10\n                cnt[i][j] += (cnt[k - 1][j - 1] + cnt[i - 1][j]) / (i - j + 3)\n    return dp[100][m]"], [0.8927455544471741, "        for k in range((n + 1) // 2, n):\n            T += comb(n, n // k) * comb(k - 2, 2)\n            T %= m"], [0.8913999795913696, "    for i in range(3, n + 1):\n        cache[i] = 2 * cache[i - 1] + cache[i - 2]\n        if m:\n            cache[i] %= m"], [0.8913949131965637, "    for i in range(3, n + 1):\n        cache[i] = 2 * cache[i - 1] + cache[i - 2]\n        if m:\n            cache[i] %= m"], [0.8911169171333313, "    for i in range(3, 101):\n        dp[i][1] = i\n        cnt[i][1] = i\n        dp[i][2] = i - 1\n        cnt[i][2] = cnt[i - 1][2]\n        for j in range(3, min(i + 1, m + 1)):\n            for k in range(j, i + 1):\n                dp[i][j] += ((dp[k - 1][j - 1] + cnt[k - 1][j - 1]) * 2.0 + dp[i - 1][j] + cnt[i - 1][j]) / (i - j + 3) + 1e-10\n                cnt[i][j] += (cnt[k - 1][j - 1] + cnt[i - 1][j]) / (i - j + 3)"], [0.8905423879623413, "    if m % 2 == 0:\n        return half ** 2 % MOD\n    else:\n        return half ** 2 * n % MOD"], [0.8898879289627075, "    memo = {}\n    total = 0\n    for n in range(0, N + 1):\n        for m in range(0, n + 1):\n            total = (total + h(m, n - m, memo)) % mod\n    return total"], [0.8897804617881775, "    mod = 1000000007\n    a, b, c, d = (6, 6, 3, 3)\n    while n > 1:\n        n -= 1\n        temp_a = a\n        temp_c = c\n        a = (a * 3 + b * 2) % mod\n        b = (temp_a * 2 + b * 2) % mod\n        c = (c * 3 + d * 2) % mod\n        d = (temp_c * 2 + d * 2) % mod\n    return b if m == 1 else (a + c) % mod"], [0.8891397714614868, "    fib = [0, 1]\n    for i in range(2, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2])\n    modulo_sequence = [x % m for x in fib]\n    return modulo_sequence"], [0.8878198266029358, "    dp = [[0] * n for _ in range(m)]\n    for i in range(m):\n        dp[i][0] = dp[i][1] = 0\n    for i in range(2, n):\n        dp[0][i] = dp[1][i] = 0\n    dp[2][0] = dp[2][1] = 1\n    for j in range(2, n):\n        dp[0][j] = dp[1][j] = 1\n    for i in range(2, m):\n        for j in range(2, n):\n            dp[i][j] = dp[i - 1][j - 2] + dp[i - 2][j - 1]\n            dp[i][j] += dp[i - 2][j - 2]\n    return dp[m - 1][n - 1]"]]}
{"task_id": "MBPP/229", "problem": [[0.9032500982284546, "    my_list[-1] = new_value\n    return my_list"], [0.9032223224639893, "    list1[-1:] = list2\n    return list1"], [0.8857401609420776, "    last3 = list[-3:]\n    del list[-3:]\n    list = last3 + list\n    return list"], [0.881003737449646, "    last_elements = []\n    for string in str_list:\n        last_elements.append(string[-1])\n    return last_elements"], [0.8807501792907715, "    lst[index] = new_element"], [0.8802359104156494, "    my_array[-1] = new_element\n    return my_array"], [0.8800912499427795, "    if not lst:\n        raise ValueError('List is empty, cannot remove last item')\n    lst.pop()\n    return lst"], [0.8797735571861267, "    original_list.append(new_element)\n    return original_list"], [0.8783474564552307, "        for item in lst:\n            new_lst.append(replace_element(item, old_element, new_element))"], [0.878273606300354, "    if len(lst) == 0:\n        print('Error: List is empty')\n        return\n    if len(lst) < 3:\n        print('Error: List does not have a third element')\n        return\n    if isinstance(lst[2], list):\n        if len(lst[2]) >= 3:\n            lst[2].pop(2)\n        else:\n            lst.pop(2)\n    else:\n        lst.pop(2)\n    print(lst)"]]}
{"task_id": "MBPP/230", "problem": [[0.8990818858146667, "    threeD = [[[0 for x in range(l)] for y in range(n)] for z in range(m)]\n    return threeD"], [0.8878787755966187, "    matrix = [[[0 for k in range(z)] for j in range(y)] for i in range(x)]\n    for i in range(x):\n        for j in range(y):\n            for k in range(z):\n                matrix[i][j][k] = random.randint(0, 100)\n    return matrix"], [0.8826615810394287, "    matrix = [[0 for x in range(3)] for y in range(3)]\n    return matrix"], [0.8820550441741943, "    for i in range(x):\n        for j in range(y):\n            for k in range(z):\n                matrix[i][j][k] = random.randint(0, 100)"], [0.8799110054969788, "    for row in range(5):\n        for col in range(5):\n            if row == 3 or col == 3:\n                print('*', end='')\n            else:\n                print(' ', end='')\n        print()"], [0.8799110054969788, "    for row in range(5):\n        for col in range(5):\n            if row == 3 or col == 3:\n                print('*', end='')\n            else:\n                print(' ', end='')\n        print()"], [0.8795843124389648, "            if row == 3 or col == 3:\n                print('*', end='')\n            else:\n                print(' ', end='')"], [0.8777943849563599, "    board = []\n    for _ in range(3):\n        row = []\n        for _ in range(3):\n            row.append(' ')\n        board.append(row)\n    return board"], [0.8776223659515381, "    array = [[[random.randint(-50, 50) for _ in range(z)] for _ in range(y)] for _ in range(x)]\n    for i in range(x):\n        for j in range(y):\n            for k in range(z):\n                if is_prime(array[i][j][k]) and array[i][j][k] > 0:\n                    array[i][j][k] *= -1\n    return array"], [0.8766086101531982, "    return [[L(i * j) for j in range(Y)] for i in range(X)]"]]}
{"task_id": "MBPP/231", "problem": [[0.9334859848022461, "    count = 0\n    for char in string:\n        count += 1\n    return count"], [0.9334847927093506, "    count = 0\n    for char in string:\n        count += 1\n    return count"], [0.9334838390350342, "    count = 0\n    for char in string:\n        count += 1\n    return count"], [0.9334826469421387, "    count = 0\n    for char in string:\n        count += 1\n    return count"], [0.9334813952445984, "    count = 0\n    for char in string:\n        count += 1\n    return count"], [0.9334801435470581, "    count = 0\n    for char in string:\n        count += 1\n    return count"], [0.9334733486175537, "    count = 0\n    for char in string:\n        count += 1\n    return count"], [0.9334732294082642, "    count = 0\n    for char in string:\n        count += 1\n    return count"], [0.9334689378738403, "    count = 0\n    for char in string:\n        count += 1\n    return count"], [0.9334643483161926, "    count = 0\n    for char in string:\n        count += 1\n    return count"]]}
{"task_id": "MBPP/232", "problem": []}
{"task_id": "MBPP/233", "problem": [[0.9220438599586487, "    if is_perfect_square(n):\n        root = math.sqrt(n)\n        next_square = (root + 1) ** 2\n        return int(next_square)\n    else:\n        return 'Number is not a perfect square'"], [0.9220438599586487, "    if is_perfect_square(n):\n        root = math.sqrt(n)\n        next_square = (root + 1) ** 2\n        return int(next_square)\n    else:\n        return 'Number is not a perfect square'"], [0.904050350189209, "    i = n + 1\n    while True:\n        if (i ** 0.5).is_integer():\n            return i\n        i += 1"], [0.8987727165222168, "    while True:\n        if (i ** 0.5).is_integer():\n            return i\n        i += 1"], [0.8977842330932617, "    while True:\n        if is_prime(x):\n            return x\n        x += 1"], [0.8973555564880371, "    if n * n < x:\n        n += 1"], [0.8970049619674683, "    if n <= 1:\n        return 4\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    i = n + 1\n    while True:\n        if i not in primes:\n            return i\n        i += 1"], [0.8969919681549072, "    if n <= 1:\n        return 4\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    i = n + 1\n    while True:\n        if i not in primes:\n            return i\n        i += 1"], [0.8969498872756958, "    next_num = number + 1\n    while True:\n        if is_prime(next_num):\n            return next_num\n        next_num += 1"], [0.8966305255889893, "    x = N + 1\n    while True:\n        if is_prime(x):\n            return x\n        x += 1"]]}
{"task_id": "MBPP/234", "problem": []}
{"task_id": "MBPP/235", "problem": [[0.9095678925514221, "    if abs(guess * guess - x) < 1e-06:\n        return guess\n    else:\n        return sqrt(x, guess if guess != 0.0 else 1.0)"], [0.9091467261314392, "    if n < 0:\n        raise Exception('Invalid input! Cannot compute square root of a negative number.')\n    elif n == 0 or n == 1:\n        return n\n    guess = n / 2.0\n    for _ in range(100000):\n        better_guess = (guess + n / guess) / 2.0\n        if abs(guess - better_guess) < 1e-08:\n            return round(better_guess, 8)\n        guess = better_guess\n    return guess"], [0.9062095284461975, "    if not isinstance(n, (int, float)):\n        return 'Error: Invalid input'\n    if n < 0:\n        return 'Error: Cannot calculate square root of a negative number'\n    if n == 0:\n        return 0\n    low, high = (0, n)\n    while low <= high:\n        mid = (low + high) / 2\n        square = mid * mid\n        if abs(square - n) < 0.0001:\n            return mid\n        elif square > n:\n            high = mid\n        else:\n            low = mid\n    return 'Error: Unable to calculate square root'"], [0.9041049480438232, "    if n < 0:\n        raise Exception('Invalid input! Cannot compute square root of a negative number.')\n    elif n == 0 or n == 1:\n        return n"], [0.9040594100952148, "    if abs(guess * guess - n) < 1e-05:\n        return guess\n    else:\n        better_guess = (guess + n / guess) / 2.0\n        return sqrt(n, better_guess)"], [0.9040594100952148, "    if abs(guess * guess - n) < 1e-05:\n        return guess\n    else:\n        better_guess = (guess + n / guess) / 2.0\n        return sqrt(n, better_guess)"], [0.9032343029975891, "    if x < 0:\n        raise ValueError('Cannot calculate square root of a negative number')\n    if x == 0:\n        return 0\n    y_n = x / 2\n    while True:\n        y_next = 0.5 * (y_n + x / y_n)\n        if abs(y_next - y_n) < precision:\n            return y_next\n        y_n = y_next"], [0.9027118682861328, "    if x < 0:\n        return sqrt(-x) + 'i'\n    if abs(guess * guess - x) < 1e-06:\n        return guess\n    else:\n        return sqrt(x, guess if guess != 0.0 else 1.0)"]]}
{"task_id": "MBPP/236", "problem": []}
{"task_id": "MBPP/237", "problem": [[0.9371569156646729, "    if n < 2:\n        return 1\n    else:\n        return 1 / n + harmonic_sum(n - 1)"], [0.9371569156646729, "    if n < 2:\n        return 1\n    else:\n        return 1 / n + harmonic_sum(n - 1)"], [0.9328620433807373, "    if n < 1:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return harmonic(n - 1) + 1 / n"], [0.9328620433807373, "    if n < 1:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return harmonic(n - 1) + 1 / n"], [0.927391529083252, "    elif n == 1:\n        return 1\n    else:\n        return harmonic(n - 1) + 1 / n"], [0.9046999216079712, "    elif n == 1:\n        return 1\n    else:\n        return harmonic(n - 1, m) + 1 / n ** m"], [0.9004483222961426, "    return sum([1 / i for i in range(1, n + 1)])"], [0.8980658054351807, "    elif m < 0:\n        raise ValueError('m must be greater than or equal to 0')\n    elif n == 1:\n        return 1\n    else:\n        return harmonic(n - 1, m) + 1 / n ** m"], [0.8970105051994324, "    seriesSum = 0\n    for num in range(1, n + 1):\n        seriesSum += 1 / num\n    return round(seriesSum, 2)"], [0.8944053649902344, "    if n <= 0:\n        raise ValueError('n must be greater than 0')\n    elif m < 0:\n        raise ValueError('m must be greater than or equal to 0')\n    elif n == 1:\n        return 1\n    else:\n        return harmonic(n - 1, m) + 1 / n ** m"]]}
{"task_id": "MBPP/238", "problem": [[0.9208112955093384, "    intersection = []\n    for num in array1:\n        if num in array2 and num not in intersection:\n            intersection.append(num)\n    return intersection"], [0.9199520349502563, "    set1 = set(array1)\n    set2 = set(array2)\n    intersection = []\n    for num in set1:\n        if num in set2:\n            intersection.append(num)\n    return intersection"], [0.9198405146598816, "    intersection = []\n    for element in arr1:\n        if element in arr2:\n            intersection.append(element)\n    return intersection"], [0.9188664555549622, "    intersection = []\n    for elem in arr1:\n        if elem in arr2:\n            intersection.append(elem)\n    return intersection"], [0.9172005653381348, "    intersection = [value for value in arr1 if value in arr2]\n    return intersection"], [0.9162406921386719, "    intersection = list(set(arr1) & set(arr2))\n    return sorted(intersection)"], [0.9150955677032471, "    intersection_arr = []\n    for item in arr1:\n        if item in arr2:\n            intersection_arr.append(item)\n    return intersection_arr"], [0.9149776101112366, "    arr1 = set(arr1)\n    arr2 = set(arr2)\n    intersection = list(arr1.intersection(arr2))\n    return intersection"], [0.9149653911590576, "    intersection = []\n    for item in arr1:\n        if item in arr2 and item not in intersection:\n            intersection.append(item)\n    return intersection"], [0.9140522480010986, "    set1 = set(arr1)\n    set2 = set(arr2)\n    intersection = set1 & set2\n    return list(intersection)"]]}
{"task_id": "MBPP/239", "problem": [[0.9259656667709351, "    count = 0\n    for i in tuple_input:\n        if isinstance(i, tuple):\n            count += count_occurrences(element, i)\n        elif i == element:\n            count += 1\n    return count"], [0.9183135032653809, "    count = 0\n    for item in lst:\n        if item == element:\n            count += 1\n    return count"], [0.9180148839950562, "    for i in tuple_input:\n        if isinstance(i, tuple):\n            count += count_occurrences(element, i)\n        elif i == element:\n            count += 1"], [0.9177379012107849, "    count = 0\n    for i in lst:\n        if i == element:\n            count += 1\n    return count"], [0.9173232316970825, "    count = 0\n    for element in lst:\n        if element == ele:\n            count += 1\n    return count"], [0.9161816835403442, "    count = 0\n    for i in input_list:\n        if i == element:\n            count += 1\n    return count"], [0.9140453934669495, "    count = 0\n    for element in lst:\n        if element == target:\n            count += 1\n    return count"], [0.9140329360961914, "    count = 0\n    for element in lst:\n        if element == target:\n            count += 1\n    return count"], [0.9119289517402649, "    count = 0\n    for i in arr:\n        if i == element:\n            count += 1\n    return count"], [0.9119173288345337, "    count = 0\n    for i in arr:\n        if i == element:\n            count += 1\n    return count"]]}
{"task_id": "MBPP/240", "problem": [[0.9018115997314453, "    lst.insert(0, element)\n    return lst"], [0.8902522325515747, "    list.insert(index, element)\n    return list"], [0.8886281251907349, "    lst.insert(2, element)\n    return lst"], [0.8877114057540894, "    result = [item for sublist in zip(lst[:-1], [element] * len(lst[:-1])) for item in sublist]\n    result.append(lst[-1])\n    return result"], [0.8868293762207031, "    arr.insert(0, element)\n    return arr"], [0.8856891989707947, "    list.insert(index, element)"], [0.8848106861114502, "    new_list = original_list[:]\n    new_list.insert(index, element)\n    return new_list"], [0.8845707178115845, "    if new_element in my_list:\n        raise ValueError('Element already exists.')\n    else:\n        my_list.insert(0, new_element)\n        return my_list"], [0.8845707178115845, "    if new_element in my_list:\n        raise ValueError('Element already exists.')\n    else:\n        my_list.insert(0, new_element)\n        return my_list"], [0.884566605091095, "    newArray = [None] * (len(array) + 1)\n    newArray[0] = newElement\n    for i in range(len(array)):\n        newArray[i + 1] = array[i]\n    return newArray"]]}
{"task_id": "MBPP/241", "problem": [[0.8854057788848877, "    polar_coordinates = []\n    for point in points:\n        x, y = point\n        radius = math.sqrt(x ** 2 + y ** 2)\n        angle = math.atan2(y, x)\n        polar_coordinates.append((radius, angle))\n    return polar_coordinates"], [0.8797130584716797, "    for point in points:\n        x, y = point\n        radius = math.sqrt(x ** 2 + y ** 2)\n        angle = math.atan2(y, x)\n        polar_coordinates.append((radius, angle))"], [0.8782651424407959, "    if isinstance(c, complex):\n        return (c.real, c.imag)"], [0.8777827024459839, "    rectangular_coordinates = []\n    for coord in polar_coordinates:\n        try:\n            if type(coord[0]) != int and type(coord[0]) != float:\n                raise ValueError('Radius value must be a number!')\n            if type(coord[1]) != int and type(coord[1]) != float:\n                raise ValueError('Angle value must be a number!')\n            if coord[0] < 0:\n                raise Exception('Radius value cannot be negative!')\n            x = coord[0] * math.cos(coord[1])\n            y = coord[0] * math.sin(coord[1])\n            rectangular_coordinates.append((x, y))\n        except Exception as e:\n            rectangular_coordinates.append(str(e))\n    return rectangular_coordinates"], [0.8775005340576172, "    if isinstance(c, complex):\n        return (c.real, c.imag)\n    return (c, 0)"], [0.8773822784423828, "    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    return (r, theta)"], [0.8772130012512207, "    rectangular_coords = []\n    for polar_coord in polar_coords:\n        try:\n            r, theta = polar_coord\n            if r < 0:\n                raise ValueError('Radius cannot be negative')\n            theta = math.radians(theta)\n            x = r * math.cos(theta)\n            y = r * math.sin(theta)\n            rectangular_coords.append((x, y))\n        except (ValueError, TypeError):\n            print(f'Inappropriate input: {polar_coord}. It should be (radius, angle) with radius >= 0.')\n    return rectangular_coords"], [0.8771995306015015, "    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    if x < 0:\n        theta += math.pi\n    return (r, theta)"], [0.8759313225746155, "    return complex(numbers[0], numbers[1])"], [0.8745381832122803, "    for coord in polar_coordinates:\n        try:\n            if type(coord[0]) != int and type(coord[0]) != float:\n                raise ValueError('Radius value must be a number!')\n            if type(coord[1]) != int and type(coord[1]) != float:\n                raise ValueError('Angle value must be a number!')\n            if coord[0] < 0:\n                raise Exception('Radius value cannot be negative!')\n            x = coord[0] * math.cos(coord[1])\n            y = coord[0] * math.sin(coord[1])\n            rectangular_coordinates.append((x, y))\n        except Exception as e:\n            rectangular_coordinates.append(str(e))"]]}
{"task_id": "MBPP/242", "problem": [[0.9096596240997314, "    if lst is None:\n        return 'Input is null'\n    freq_dict = {}\n    for i in lst:\n        if type(i) == int:\n            if i in freq_dict:\n                freq_dict[i] += 1\n            else:\n                freq_dict[i] = 1\n        else:\n            return 'Non-integer input detected.'\n    return freq_dict"], [0.9075377583503723, "    for ele in my_list:\n        count = 0\n        for e in my_list:\n            if ele == e:\n                count += 1\n        counts[ele] = count"], [0.9070431590080261, "    dict = {}\n    for val in myList:\n        if val in dict:\n            dict[val] += 1\n        else:\n            dict[val] = 1\n    return dict"], [0.904691219329834, "    counts = {}\n    for num in lst:\n        if num <= 0:\n            continue\n        counts[num] = counts.get(num, 0) + 1\n    return counts"], [0.904360830783844, "    count = 0\n    for num in lst:\n        if num == given_num:\n            count += 1\n    return count"], [0.9042684435844421, "    for i in lst:\n        if type(i) == int:\n            if i in freq_dict:\n                freq_dict[i] += 1\n            else:\n                freq_dict[i] = 1\n        else:\n            return 'Non-integer input detected.'"], [0.9040209054946899, "    for val in myList:\n        if val in dict:\n            dict[val] += 1\n        else:\n            dict[val] = 1"], [0.9035214185714722, "    counts = dict()\n    for item in lst:\n        if item in counts:\n            counts[item] += 1\n        else:\n            counts[item] = 1\n    return counts"], [0.9033882021903992, "    count = {}\n    for i in lst:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n    return count"], [0.9028307199478149, "    count_dict = {}\n    unique_nums = set()\n    for num in lst:\n        if num <= 0:\n            continue\n        if num not in unique_nums:\n            if num in count_dict:\n                count_dict[num] += 1\n            else:\n                count_dict[num] = 1\n            unique_nums.add(num)\n    return count_dict"]]}
{"task_id": "MBPP/243", "problem": [[0.9108384251594543, "    result = []\n    for string in array:\n        if string[0] == 'a' and string[-1] == 'e':\n            result.append(string)\n    return result if result else []"], [0.9097294211387634, "    output = []\n    for word in words:\n        if word[0] == 'a':\n            output.append(word)\n    return output"], [0.909494161605835, "    a_words = []\n    for word in words:\n        if word[0] == 'a':\n            a_words.append(word)\n    return a_words"], [0.9082584381103516, "    found_words = []\n    for word in words:\n        if 'a' in word:\n            found_words.append(word)\n    return found_words"], [0.90799880027771, "    for string in array:\n        if string[0] == 'a' and string[-1] == 'e':\n            result.append(string)"], [0.9045609831809998, "    for word in words:\n        if word[0] == 'a':\n            output.append(word)"], [0.9036945700645447, "    for word in words:\n        if word[0] == 'a':\n            a_words.append(word)"], [0.903549075126648, "        if string[0] == 'a' and string[-1] == 'e':\n            result.append(string)"], [0.9033178687095642, "    for word in words:\n        if 'a' in word:\n            found_words.append(word)"], [0.9015417695045471, "    result = []\n    for string in strings:\n        if string.startswith('a'):\n            result.append(string)\n    if len(result) == 0:\n        return []\n    return result"]]}
{"task_id": "MBPP/244", "problem": [[0.8970463275909424, "    combinations = []\n    for i in range(int1):\n        for j in range(int2):\n            for k in range(int3):\n                combinations.append([i, j, k])\n    return combinations"], [0.8884900808334351, "    for i in range(int1):\n        for j in range(int2):\n            for k in range(int3):\n                combinations.append([i, j, k])"], [0.8837122321128845, "            for k in range(int3):\n                combinations.append([i, j, k])"], [0.8831455707550049, "                for c4 in colors:\n                    combination = [c1, c2, c3, c4]\n                    if combination not in result:\n                        result.append(combination)"], [0.8822849988937378, "        for j in range(int2):\n            for k in range(int3):\n                combinations.append([i, j, k])"], [0.8802798986434937, "    if len(prefix) == n:\n        print(prefix)\n        return\n    if a < 2:\n        generate_strings(n, prefix + 'A', a + 1, b, c)\n    if b < 2:\n        generate_strings(n, prefix + 'B', a, b + 1, c)\n    if c < 2:\n        generate_strings(n, prefix + 'C', a, b, c + 1)"], [0.8790096640586853, "    combinations = list(itertools.combinations(numbers, 3))\n    permutations = [list(itertools.permutations(comb)) for comb in combinations]\n    return (combinations, permutations)"], [0.8763453960418701, "            for c3 in colors:\n                for c4 in colors:\n                    combination = [c1, c2, c3, c4]\n                    if combination not in result:\n                        result.append(combination)"], [0.8758497834205627, "    result = []\n    for i in range(len(a)):\n        for j in range(len(b)):\n            for k in range(len(c)):\n                result.append([a[i], b[j], c[k]])\n    return result"], [0.8756663799285889, "    letters = ['A', 'B', 'C']\n    length = 3\n    combinations = []\n    generate_combinations('', letters, length, combinations)\n    return combinations"]]}
{"task_id": "MBPP/245", "problem": [[0.9235280752182007, "    count = 0\n    for i in range(1, n + 1):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n        if is_prime:\n            count = count + 1\n    return count"], [0.9216600656509399, "    count = 0\n    if n > 2:\n        count += 1\n    for i in range(3, n + 1, 2):\n        prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            count += 1\n    return count"], [0.9215517640113831, "    count = 0\n    for m in range(2, num):\n        if check_primes(m) == True:\n            count += 1\n    return count"]]}
{"task_id": "MBPP/246", "problem": [[0.9103308916091919, "    first_num = int(input('Enter the first number: '))\n    second_num = int(input('Enter the second number: '))\n    first_num, second_num = (second_num, first_num)\n    print(first_num, second_num)"]]}
{"task_id": "MBPP/247", "problem": [[0.9093067049980164, "    count = 0\n    for num in lst:\n        if num % 2 != 0:\n            count += 1\n    return count"], [0.9080244898796082, "    count = 0\n    for i in lst:\n        if i % 2 != 0:\n            count += 1\n    return count"], [0.9068640470504761, "    even_count = 0\n    for num in list:\n        if num % 2 == 0:\n            even_count += 1\n    return even_count"], [0.9028475284576416, "    odd_list = []\n    for num in my_list:\n        if num % 2 != 0:\n            odd_list.append(num)\n    return odd_list"], [0.9012941718101501, "    count = 0\n    for num in lst:\n        if num % 2 == 0:\n            count += 1\n    return count"], [0.900352954864502, "    odd_list = []\n    for number in original_list:\n        if number % 2 != 0:\n            odd_list.append(number)\n    return odd_list"], [0.8998689651489258, "    count = 0\n    for num in number_list:\n        if num % 2 == 0:\n            count += 1\n    return count"], [0.8996005058288574, "    count = 0\n    for num in input_list:\n        if num % 2 == 0:\n            count += 1\n    return count"], [0.8967082500457764, "    count = 0\n    for i in range(len(arr)):\n        if arr[i] % 2 != 0:\n            count = count + 1\n    return count"], [0.8964639902114868, "    odd_sum = 0\n    odd_count = 0\n    odd_numbers = []\n    for num in args:\n        if num > 0 and num % 2 != 0:\n            odd_sum += num\n            odd_count += 1\n            odd_numbers.append(num)\n    return (odd_sum, odd_count, odd_numbers)"]]}
{"task_id": "MBPP/248", "problem": [[0.8892108201980591, "    max_values = []\n    for tup in list_of_tuples:\n        max_values.append(max(tup))\n    return max_values"], [0.8865551352500916, "    return (max(list1), max(list2)) if max(list1) != max(list2) else (sorted(list1)[-2], max(list2)) if max(list1) == max(list2) else (max(list1), sorted(list2)[-2])"], [0.8864699602127075, "    return (max(num1, num2), min(num1, num2))"], [0.8859754800796509, "    if max1 > max2:\n        return max1\n    else:\n        return max2"], [0.8859539031982422, "    return max(num1, num2)"], [0.8859539031982422, "    return max(num1, num2)"], [0.8859534859657288, "    return max(num1, num2)"], [0.8859385848045349, "    return max(num1, num2)"], [0.8858762383460999, "    elif len(my_list) == 2:\n        return max(my_list[0], my_list[1])"], [0.8845216035842896, "    return max(num_1, num_2)"]]}
{"task_id": "MBPP/249", "problem": [[0.8919532895088196, "    if n <= 2:\n        return prime_list[n - 1]"]]}
{"task_id": "MBPP/250", "problem": [[0.9000197649002075, "    for pair1, pair2 in zip(tuples1, tuples2):\n        if len(pair1) != len(pair2):\n            return 'Error: Corresponding tuples should be of same length.'\n        temp = []\n        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)\n        result.append(tuple(temp))"], [0.9000146389007568, "    for pair1, pair2 in zip(tuples1, tuples2):\n        if len(pair1) != len(pair2):\n            return 'Error: Corresponding tuples should be of same length.'\n        temp = []\n        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)\n        result.append(tuple(temp))"], [0.8965746164321899, "    result = []\n    for pair in pair_list:\n        try:\n            result.append(pair[0] / pair[1])\n        except ZeroDivisionError:\n            result.append('Error: Division by Zero')\n    return result"], [0.8965680003166199, "    result = []\n    for pair in pair_list:\n        try:\n            result.append(pair[0] / pair[1])\n        except ZeroDivisionError:\n            result.append('Error: Division by Zero')\n    return result"], [0.8945704698562622, "    if len(t1) != len(t2):\n        return 'Error: tuples are not the same size'\n    else:\n        result = []\n        for i in range(len(t1)):\n            if t2[i] == 0:\n                return f'Error: division by zero in position {i}'\n            else:\n                result.append(t1[i] % t2[i])\n        return tuple(result)"], [0.8945704698562622, "    if len(t1) != len(t2):\n        return 'Error: tuples are not the same size'\n    else:\n        result = []\n        for i in range(len(t1)):\n            if t2[i] == 0:\n                return f'Error: division by zero in position {i}'\n            else:\n                result.append(t1[i] % t2[i])\n        return tuple(result)"], [0.894566535949707, "    if len(t1) != len(t2):\n        return 'Error: tuples are not the same size'\n    else:\n        result = []\n        for i in range(len(t1)):\n            if t2[i] == 0:\n                return f'Error: division by zero in position {i}'\n            else:\n                result.append(t1[i] % t2[i])\n        return tuple(result)"], [0.894566535949707, "    if len(t1) != len(t2):\n        return 'Error: tuples are not the same size'\n    else:\n        result = []\n        for i in range(len(t1)):\n            if t2[i] == 0:\n                return f'Error: division by zero in position {i}'\n            else:\n                result.append(t1[i] % t2[i])\n        return tuple(result)"], [0.8920450210571289, "    for pair in pair_list:\n        try:\n            result.append(pair[0] / pair[1])\n        except ZeroDivisionError:\n            result.append('Error: Division by Zero')"], [0.8920421600341797, "    for pair in pair_list:\n        try:\n            result.append(pair[0] / pair[1])\n        except ZeroDivisionError:\n            result.append('Error: Division by Zero')"]]}
{"task_id": "MBPP/251", "problem": [[0.9071854948997498, "    part1 = lst[:size]\n    part2 = lst[size:]\n    return (part1, part2)"], [0.8958134055137634, "    length = len(lst)\n    mid = length // 2\n    first_half = lst[:mid]\n    second_half = lst[mid:]\n    return (first_half, second_half)"], [0.8895401954650879, "    size = len(lst)\n    split_index = size // 2\n    return (lst[:split_index], lst[split_index:])"], [0.8868935108184814, "    half = len(lst) // 2\n    return (lst[:half], lst[half:])"], [0.8868851661682129, "    half = len(lst) // 2\n    return (lst[:half], lst[half:])"], [0.8868235349655151, "    new_list1 = []\n    new_list2 = []\n    if type(k) == float:\n        k = round(k)\n    length1 = len(list1)\n    length2 = len(list2)\n    if not list1 and (not list2):\n        return [k]\n    elif k >= length1 or k >= length2:\n        new_list1 = list1[::-1]\n        new_list2 = list2[::-1]\n    elif k < 0:\n        new_list1 = list1[:k] + list1[k + 1:]\n        new_list2 = list2[:k] + list2[k + 1:]\n    elif k == 0:\n        new_list1 = list1\n        new_list2 = list2\n    else:\n        new_list1 = list1[:k] + list1[k + 1:]\n        new_list2 = list2[:k] + list2[k + 1:]\n    return (new_list1, new_list2)"], [0.8848313689231873, "    length = len(data)\n    midpoint = length // 2\n    first_half = data[:midpoint]\n    second_half = data[midpoint:]\n    return (first_half, second_half)"], [0.8846242427825928, "    mid = len(my_list) // 2\n    left_half = my_list[:mid]\n    right_half = my_list[mid:]\n    return (left_half, right_half)"], [0.8842469453811646, "    length = len(numbers)\n    mid = length // 2\n    list_a = numbers[:mid]\n    list_b = numbers[mid:]\n    return (list_a, list_b)"]]}
{"task_id": "MBPP/252", "problem": []}
{"task_id": "MBPP/253", "problem": [[0.9030285477638245, "    years = days / 365\n    return years"], [0.89225834608078, "    return years * 365"], [0.8915209174156189, "    currentYear = datetime.datetime.now().year\n    if birthYear < 1900 or birthYear > currentYear:\n        return 'Invalid birth year'\n    days_in_year = 365.25\n    age_in_days = (currentYear - birthYear) * days_in_year\n    return age_in_days"], [0.891497015953064, "        elif age_split[1] == 'years':\n            converted_age = int(age_split[0])\n        elif age_split[1] == 'weeks':\n            converted_age = int(age_split[0]) / 52\n        elif age_split[1] == 'days':\n            converted_age = int(age_split[0]) / 365"], [0.8895629644393921, "        if age_split[1] == 'months':\n            converted_age = int(age_split[0]) / 12\n        elif age_split[1] == 'years':\n            converted_age = int(age_split[0])\n        elif age_split[1] == 'weeks':\n            converted_age = int(age_split[0]) / 52\n        elif age_split[1] == 'days':\n            converted_age = int(age_split[0]) / 365"], [0.8880550861358643, "        elif age_split[1] == 'weeks':\n            converted_age = int(age_split[0]) / 52\n        elif age_split[1] == 'days':\n            converted_age = int(age_split[0]) / 365"], [0.8878421187400818, "            if age < 0:\n                raise ValueError(\"Age can't be a negative number. Please enter a valid age.\")"], [0.8876283168792725, "    return 15.9 - 0.983 * age"], [0.8874281644821167, "    converted_ages = []\n    for age in ages:\n        age_split = age.split(' ')\n        if age_split[1] == 'months':\n            converted_age = int(age_split[0]) / 12\n        elif age_split[1] == 'years':\n            converted_age = int(age_split[0])\n        elif age_split[1] == 'weeks':\n            converted_age = int(age_split[0]) / 52\n        elif age_split[1] == 'days':\n            converted_age = int(age_split[0]) / 365\n        converted_ages.append(converted_age)\n    return converted_ages"], [0.8870894908905029, "    for age in ages:\n        age_split = age.split(' ')\n        if age_split[1] == 'months':\n            converted_age = int(age_split[0]) / 12\n        elif age_split[1] == 'years':\n            converted_age = int(age_split[0])\n        elif age_split[1] == 'weeks':\n            converted_age = int(age_split[0]) / 52\n        elif age_split[1] == 'days':\n            converted_age = int(age_split[0]) / 365\n        converted_ages.append(converted_age)"]]}
{"task_id": "MBPP/254", "problem": [[0.9106076955795288, "    newlist = []\n    indices = list(range(0, len(mylist), n))\n    for start in indices:\n        end = start + n\n        newlist.append(mylist[start:end])\n    return newlist"], [0.9018875360488892, "    list_of_lists = [my_list[i * n:(i + 1) * n] for i in range((len(my_list) + n - 1) // n)]\n    return list_of_lists"], [0.8978022336959839, "    sub_lsts = []\n    for item in lst:\n        sub_lsts.append([item[i:i + n] for i in range(0, len(item), n)])\n    return sub_lsts"], [0.8963726758956909, "    for start in indices:\n        end = start + n\n        newlist.append(mylist[start:end])"], [0.8939786553382874, "    return [lst[i:i + n] for i in range(0, len(lst), n)]"], [0.8939608931541443, "    return [lst[i:i + n] for i in range(0, len(lst), n)]"], [0.8939602971076965, "    return [lst[i:i + n] for i in range(0, len(lst), n)]"], [0.8924298286437988, "    return [l[i:i + n] for i in range(0, len(l), n)]"], [0.8913612961769104, "    for idx, i in enumerate(lst):\n        if idx % n != 0:\n            lst[idx] = l[idx]"], [0.8911393880844116, "    length = len(text) // n\n    return [text[i:i + length] for i in range(0, len(text), length)]"]]}
{"task_id": "MBPP/255", "problem": [[0.8968866467475891, "    lateral_surface_area = 2 * l * h + b * h\n    total_surface_area = lateral_surface_area + 2 * l * b\n    return (lateral_surface_area, total_surface_area)"], [0.8905869722366333, "    surface_area = 6 * length ** 2\n    volume = length ** 3\n    return (surface_area, volume)"], [0.8903260231018066, "    surface_area = 2 * l * w + 2 * l * h + 2 * w * h\n    return surface_area"], [0.8896922469139099, "    surface_area = 6 * edge_length ** 2\n    return surface_area"], [0.8869248032569885, "    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area"], [0.8869073987007141, "    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area"]]}
{"task_id": "MBPP/256", "problem": [[0.9249922037124634, "    odd_numbers = [2 * i + 1 for i in range(n)]\n    squared_odd_numbers = [x ** 2 for x in odd_numbers]\n    total_sum = sum(squared_odd_numbers)\n    return total_sum"]]}
{"task_id": "MBPP/257", "problem": [[0.8863199949264526, "    return findNthPolite(n)"], [0.8863160610198975, "    return findNthPolite(n)"], [0.8857041001319885, "    if n > 0 and n <= len(sequence):\n        return sequence[n - 1]\n    else:\n        return 'Invalid input for n.'"], [0.8857041001319885, "    if n > 0 and n <= len(sequence):\n        return sequence[n - 1]\n    else:\n        return 'Invalid input for n.'"], [0.8850569725036621, "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n)"], [0.8850569725036621, "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n)"], [0.88226318359375, "    for i in range(n):\n        row = ['*'] * stars_per_row\n        print(' '.join(row))"], [0.8816499710083008, "    if nth < 1:\n        return 'Error: input should be a positive integer'"], [0.881319522857666, "    elif n == 2:\n        return 2\n    else:\n        return 2 * nth_value(n - 1)"], [0.8801995515823364, "    for i in range(n):\n        num_consecutive_stars = min(i + 1, n - i, num_stars)\n        for j in range(num_consecutive_stars):\n            print('*', end=' ')\n        print()"]]}
{"task_id": "MBPP/258", "problem": [[0.932205319404602, "    char = input('Enter a character: ')\n    ascii_value = ord(char)\n    print(f\"The ASCII value of '{char}' is {ascii_value}\")"], [0.9260550737380981, "    ascii_code = ord(character)\n    return ascii_code"], [0.9120573997497559, "    return ord(char)"], [0.9120404720306396, "    return ord(char)"], [0.9120267033576965, "    return ord(char)"], [0.91200190782547, "    return ord(char)"], [0.9077188968658447, "    return ord(character)"], [0.907706618309021, "    return ord(character)"], [0.9074543714523315, "    return ord(char) - ord('a')"], [0.903347373008728, "    character = chr(ascii_code)\n    return character"]]}
{"task_id": "MBPP/259", "problem": []}
{"task_id": "MBPP/260", "problem": []}
{"task_id": "MBPP/261", "problem": [[0.8832985162734985, "    extracted_elements = []\n    for i in range(3):\n        extracted_elements.append(lst[i])\n    return extracted_elements"], [0.8758921027183533, "    if len(tup_list) == 0:\n        return 'The tuple list is empty.'\n    if k > len(tup_list):\n        return 'K is greater than the size of list. Returning all records.'\n    tup_list.sort(key=lambda x: x[0])\n    return tup_list[:k]"], [0.8740485906600952, "    for i in range(3):\n        extracted_elements.append(lst[i])"], [0.8719848990440369, "    if not isinstance(input_list, list):\n        return 'Error: Input must be a list.'\n    elif not input_list:\n        return 'Error: Input list is empty.'\n    else:\n        last_element = input_list[-1]\n        mutated_list = input_list[:-1]\n        return (mutated_list, last_element)"], [0.8719848990440369, "    if not isinstance(input_list, list):\n        return 'Error: Input must be a list.'\n    elif not input_list:\n        return 'Error: Input list is empty.'\n    else:\n        last_element = input_list[-1]\n        mutated_list = input_list[:-1]\n        return (mutated_list, last_element)"], [0.870297908782959, "        if element not in tuple1:\n            tuple1.insert(0, element)"], [0.8684549331665039, "    elif not input_list:\n        return 'Error: Input list is empty.'\n    else:\n        last_element = input_list[-1]\n        mutated_list = input_list[:-1]\n        return (mutated_list, last_element)"], [0.8678683042526245, "    if n > len(lst):\n        return 'invalid'\n    elif n == 0:\n        return []\n    else:\n        return lst[-n:]"], [0.8678683042526245, "    if n > len(lst):\n        return 'invalid'\n    elif n == 0:\n        return []\n    else:\n        return lst[-n:]"], [0.8671479225158691, "    new_lst = []\n    for i in range(len(lst) - 1, -1, -1):\n        new_lst.append(lst[i])\n    return tuple(new_lst)"]]}
{"task_id": "MBPP/262", "problem": [[0.8910036087036133, "    return np.subtract(x, y)"], [0.8898276090621948, "        elif t1 <= t2:\n            yield (t1 - t2)\n        else:\n            raise ValueError('Element in first tuple is less than corresponding element in second tuple')"], [0.8887817859649658, "        elif t1 >= t2:\n            yield (t1 - t2)\n        else:\n            raise ValueError('Element in first tuple is less than corresponding element in second tuple')"], [0.8822159767150879, "    paired_elements = zip(List1, List2)\n    List3 = []\n    for pair in paired_elements:\n        List3.append(pair[0] - pair[1])\n    return List3"], [0.8818223476409912, "    if len(arr_a) != len(arr_b):\n        return 'Arrays are of unequal lengths.'\n    else:\n        return [a - b for a, b in zip(arr_a, arr_b)]"], [0.8818223476409912, "    if len(arr_a) != len(arr_b):\n        return 'Arrays are of unequal lengths.'\n    else:\n        return [a - b for a, b in zip(arr_a, arr_b)]"], [0.8818029761314392, "    if len(arr_a) != len(arr_b):\n        return 'Arrays are of unequal lengths.'\n    else:\n        return [a - b for a, b in zip(arr_a, arr_b)]"], [0.8818029761314392, "    if len(arr_a) != len(arr_b):\n        return 'Arrays are of unequal lengths.'\n    else:\n        return [a - b for a, b in zip(arr_a, arr_b)]"], [0.8817217350006104, "    entry = []\n    for i in range(len(v1)):\n        entry.append(v1[i] - v2[i])\n    return entry"], [0.8810002207756042, "    validate_inputs(*args)\n    result = args[0]\n    for num in args[1:]:\n        result -= num\n    return result"]]}
{"task_id": "MBPP/263", "problem": []}
{"task_id": "MBPP/264", "problem": [[0.9037023782730103, "    if index != -1:\n        arr.pop(index)\n        return arr\n    else:\n        return -1"], [0.9007002115249634, "    last_instance = None\n    for i in range(len(array)):\n        if array[i] == element:\n            last_instance = i\n    if last_instance is None:\n        return 'Element not found in the array'\n    else:\n        return last_instance"], [0.8994283676147461, "    last_index = -1\n    for i in range(len(arr)):\n        if arr[i] == num:\n            last_index = i\n    return last_index"], [0.897632896900177, "    index = -1\n    for i in range(len(arr)):\n        if arr[i] == element:\n            index = i\n            break\n    if index != -1:\n        arr.pop(index)\n        return arr\n    else:\n        return -1"], [0.8961472511291504, "    idx = arr.index(element)\n    arr.pop(idx)\n    return arr"], [0.8959569931030273, "    last_index = -1\n    for idx, elem in enumerate(arr):\n        if elem == number:\n            last_index = idx\n    return last_index"], [0.894050657749176, "    n = len(arr)\n    last_occurrence = -1\n    for i in range(n):\n        if arr[i] == target:\n            last_occurrence = i\n    return last_occurrence"], [0.8933663368225098, "    for i in range(len(arr) - 1, -1, -1):\n        if arr[i] == item:\n            return i\n    return -1"], [0.8933612704277039, "    for i in range(len(arr) - 1, -1, -1):\n        if arr[i] == item:\n            return i\n    return -1"], [0.8933597803115845, "    for i in range(len(array)):\n        if array[i] == element:\n            last_instance = i"]]}
{"task_id": "MBPP/265", "problem": [[0.9098232984542847, "    volume = math.pi * radius ** 2 * height\n    return volume"], [0.9035979509353638, "    return math.pi * cylinder['radius'] ** 2 * cylinder['height']"], [0.9003052711486816, "    volume = 4 / 3 * 3.142 * radius ** 3\n    return round(volume, 2)"], [0.8999472856521606, "    pi = 3.14\n    return pi * radius ** 2 * height"], [0.8997466564178467, "    volume = math.pi * R ** 2 * L\n    return volume"], [0.899258553981781, "    total_volume = 0\n    for cylinder in cylinders:\n        radius = cylinder['radius']\n        height = cylinder['height']\n        volume = math.pi * radius ** 2 * height\n        total_volume += volume\n    return total_volume"], [0.8992551565170288, "    pi = 3.14159\n    volume = 4 / 3 * pi * radius ** 3\n    return volume"], [0.899254560470581, "    total_volume = 0\n    for cylinder in cylinders:\n        radius = cylinder['radius']\n        height = cylinder['height']\n        volume = math.pi * radius ** 2 * height\n        total_volume += volume\n    return total_volume"], [0.8983006477355957, "    if r <= 0 or h <= 0:\n        return 'Radius and Height must be greater than zero.'\n    l = math.sqrt(r ** 2 + h ** 2)\n    return math.pi * r * l"], [0.8982836008071899, "    if r <= 0 or h <= 0:\n        return 'Radius and Height must be greater than zero.'\n    l = math.sqrt(r ** 2 + h ** 2)\n    return math.pi * r * l"]]}
{"task_id": "MBPP/266", "problem": [[0.9115277528762817, "    filtered_dict = {}\n    if filter_by == 'keys':\n        for key in keys_or_values:\n            if key in dict_to_filter.keys():\n                filtered_dict[key] = dict_to_filter[key]\n    elif filter_by == 'values':\n        for key, value in dict_to_filter.items():\n            if value in keys_or_values:\n                filtered_dict[key] = value\n    else:\n        print('The filter_by input is invalid.')\n    return filtered_dict"], [0.9099503755569458, "    elif filter_by == 'values':\n        for key, value in dict_to_filter.items():\n            if value in keys_or_values:\n                filtered_dict[key] = value\n    else:\n        print('The filter_by input is invalid.')"], [0.9040811061859131, "    if filter_by == 'keys':\n        for key in keys_or_values:\n            if key in dict_to_filter.keys():\n                filtered_dict[key] = dict_to_filter[key]\n    elif filter_by == 'values':\n        for key, value in dict_to_filter.items():\n            if value in keys_or_values:\n                filtered_dict[key] = value\n    else:\n        print('The filter_by input is invalid.')"], [0.9031630158424377, "    filtered_values = [value for value in dictionary.values() if 5 < value < 9]\n    sorted_values = sorted(filtered_values)\n    return sorted_values"], [0.8996064066886902, "            if value in keys_or_values:\n                filtered_dict[key] = value"], [0.896740734577179, "    filtered_dict = {}\n    for key, value in dictionary.items():\n        if key in criteria:\n            filtered_dict[key] = value\n    return filtered_dict"], [0.8946236968040466, "        for key, value in dict_to_filter.items():\n            if value in keys_or_values:\n                filtered_dict[key] = value"], [0.894199550151825, "        for key in keys_or_values:\n            if key in dict_to_filter.keys():\n                filtered_dict[key] = dict_to_filter[key]"], [0.8941418528556824, "    filtered_dict = {key: value for key, value in input_dict.items() if value.startswith('g')}\n    return filtered_dict"], [0.8934551477432251, "            if key in dict_to_filter.keys():\n                filtered_dict[key] = dict_to_filter[key]"]]}
{"task_id": "MBPP/267", "problem": [[0.8841193318367004, "    count = 0\n    for i in tuple_input:\n        if isinstance(i, tuple):\n            count += count_occurrences(element, i)\n        elif i == element:\n            count += 1\n    return count"], [0.8815112113952637, "    for i in tuple_input:\n        if isinstance(i, tuple):\n            count += count_occurrences(element, i)\n        elif i == element:\n            count += 1"], [0.879615068435669, "    if count == 0:\n        return (-1, count)\n    else:\n        index = lst.index(item)\n        return (index, count)"], [0.8788689970970154, "    count = 0\n    for item in lst:\n        if item > number:\n            count += 1\n    return count"], [0.8786522150039673, "    count = 0\n    for element in list:\n        if element > x:\n            count += 1\n    return count"], [0.8785920143127441, "    position = T.find(q)\n    count = T.count(q)\n    return (position, count)"], [0.8785139918327332, "    for element in list:\n        if element > x:\n            count += 1"], [0.8781731724739075, "    count = 0\n    for elem in lst:\n        if elem <= maximum_value:\n            count += 1\n    return count"], [0.8780033588409424, "    count = 0\n    for element in arr:\n        if element > target:\n            count += 1\n    return count"], [0.8777231574058533, "    count = 0\n    for num in lst:\n        if num > value:\n            count += 1\n    return count"]]}
{"task_id": "MBPP/268", "problem": [[0.8948100805282593, "        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4"], [0.8947908282279968, "        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4"], [0.8862782120704651, "    if n in memory:\n        return memory[n]\n    if n < 1 or n > 1000 or (not isinstance(n, int)):\n        return 'Invalid input'\n    elif n == 1:\n        return 1\n    else:\n        memory[n] = n * (7 * n - 5) // 2\n        return nonagonal(n - 1, memory)"], [0.8862671852111816, "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"], [0.8862671852111816, "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"], [0.8862640857696533, "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"], [0.8862640857696533, "    if isinstance(n, int) and n > 0:\n        if n == 1:\n            return 1\n        else:\n            return nth_nonagonal(n - 1) + 7 * n - 4\n    else:\n        raise ValueError('Input must be a positive integer')"], [0.8856913447380066, "    if not isinstance(n, int) or n <= 0:\n        return 'Invalid Input'\n    if n > 1000:\n        return 'Cannot calculate for numbers > 1000'\n    if n == 1:\n        if sequence:\n            return [1]\n        else:\n            return 1\n    else:\n        previous_seq = nonagonal_calc(n - 1, sequence=True)\n        current_value = n * (7 * n - 5) // 2\n        if sequence:\n            return previous_seq + [current_value]\n        else:\n            return current_value"], [0.8846306800842285, "    if n < 1 or n > 1000 or (not isinstance(n, int)):\n        return 'Invalid input'\n    elif n == 1:\n        return 1\n    else:\n        memory[n] = n * (7 * n - 5) // 2\n        return nonagonal(n - 1, memory)"], [0.884617030620575, "    if type(n) != int or n < 0:\n        return 'ERROR: Invalid Input'\n    if n > 5000:\n        return 'ERROR: Input number too large'\n    if n in computed:\n        return computed[n]\n    computed[n] = n * (5 * n - 3) / 2 + heptagonal(n - 1)\n    return computed[n]"]]}
{"task_id": "MBPP/269", "problem": [[0.9066569805145264, "    if result != -1:\n        print('Element is present at index', str(result))\n    else:\n        print('Element is not present in array')"], [0.9046139717102051, "    for i in range(len(array)):\n        if array[i] == search_element:\n            return i\n    return -1"]]}
{"task_id": "MBPP/270", "problem": [[0.9367316365242004, "    unique_list = []\n    for i in my_list:\n        if i not in unique_list:\n            unique_list.append(i)\n    if len(unique_list) == len(my_list):\n        return True\n    else:\n        return False"], [0.9336757659912109, "    unique_list = []\n    for elem in lst:\n        if elem not in unique_list:\n            unique_list.append(elem)\n    if len(lst) == len(unique_list):\n        return True\n    else:\n        return False"], [0.9249272346496582, "    if len(unique_list) == len(my_list):\n        return True\n    else:\n        return False"], [0.9234593510627747, "    unique_list = list(dict.fromkeys(list))\n    return len(list) == len(unique_list)"], [0.9221532940864563, "    if len(lst) == len(unique_list):\n        return True\n    else:\n        return False"], [0.921165943145752, "    unique_set = set()\n    for i in li:\n        if i not in unique_set:\n            unique_set.add(i)\n        else:\n            return True\n    return False"], [0.9204325079917908, "    seen = set()\n    for element in my_list:\n        if element in seen:\n            return False\n        seen.add(element)\n    return True"], [0.9177873730659485, "    n = len(lst)\n    unique_elements = set()\n    for i in range(n):\n        if lst[i] in unique_elements:\n            return False\n        unique_elements.add(lst[i])\n    return True"], [0.913994550704956, "    if len(input_list) == len(set(input_list)):\n        return 'The list is characterized by uniqueness, there are no duplicate values.'\n    else:\n        return 'The list contains repetitive elements.'"], [0.913994550704956, "    if len(input_list) == len(set(input_list)):\n        return 'The list is characterized by uniqueness, there are no duplicate values.'\n    else:\n        return 'The list contains repetitive elements.'"]]}
{"task_id": "MBPP/271", "problem": [[0.9013996124267578, "    try:\n        return [a - b for a, b in zip(list1, list2)]\n    except Exception as e:\n        print('An error occurred:', e)"], [0.9013996124267578, "    try:\n        return [a - b for a, b in zip(list1, list2)]\n    except Exception as e:\n        print('An error occurred:', e)"], [0.9010075330734253, "    try:\n        result = [a - b for a, b in zip(list1, list2)]\n    except TypeError as err:\n        return f'Error: Lists must contain only numbers. {err}'"], [0.8991479277610779, "    if len(list1) != len(list2):\n        return 'Error: Lists are not of the same length.'\n    try:\n        result = [a - b for a, b in zip(list1, list2)]\n    except TypeError as err:\n        return f'Error: Lists must contain only numbers. {err}'\n    return result"], [0.8983710408210754, "    paired_elements = zip(List1, List2)\n    List3 = []\n    for pair in paired_elements:\n        List3.append(pair[0] - pair[1])\n    return List3"], [0.89823317527771, "    result = [a + b for a, b in zip(list1, list2)]\n    return result"], [0.898220419883728, "    result = [a + b for a, b in zip(list1, list2)]\n    return result"], [0.8980156183242798, "    return [multiply(x, y) for x, y in zip(list1, list2)]"], [0.8966836929321289, "    return [a + b for a, b in zip(list1, list2)]"], [0.8966687917709351, "    return [a + b for a, b in zip(list1, list2)]"]]}
{"task_id": "MBPP/272", "problem": [[0.8908730745315552, "    for i in range(1, 10):\n        if count[i] > 0 and count[i] == count[i - 1]:\n            return True"], [0.890342116355896, "    digital_roots = [digital_root(num) for num in lst]\n    return all((digital_roots[i] <= digital_roots[i + 1] for i in range(len(digital_roots) - 1)))"], [0.8871026039123535, "    if distinct_digits < 2:\n        return False"], [0.8866664171218872, "    count = string.count(char)\n    if count == digit:\n        return True\n    else:\n        return False"], [0.8848637342453003, "        if sorted(digits) == list(range(min(digits), max(digits) + 1)):\n            return True"], [0.884585976600647, "    count = [0] * 10\n    for c in s:\n        count[int(c)] += 1\n    for i in range(1, 10):\n        if count[i] > 0 and count[i] == count[i - 1]:\n            return True\n    return False"], [0.8841819763183594, "    if count == digit:\n        return True\n    else:\n        return False"], [0.8825011253356934, "    for c in num:\n        if not c.isdigit():\n            raise ValueError('Non-numeric character found.')\n    for i in range(len(num) - 1):\n        if num[i] > num[i + 1]:\n            return False\n    return True"], [0.8817811012268066, "        if digit in unique_digits:\n            return False"], [0.8815326690673828, "    for value in frequency_counter.values():\n        if value > 3:\n            return False"]]}
{"task_id": "MBPP/273", "problem": [[0.9033188819885254, "    string_length = len(string_list[0])\n    for string in string_list:\n        if len(string) != string_length:\n            return False\n    return True"], [0.8995363712310791, "    if not list_of_strings:\n        print('The list is empty.')\n    else:\n        string_length = len(list_of_strings[0])\n        all_equal_length = all((len(string) == string_length for string in list_of_strings))\n        if all_equal_length:\n            print('All strings in the list are of equal length.')\n        else:\n            print('Not all strings in the list are of equal length.')"], [0.8995363712310791, "    if not list_of_strings:\n        print('The list is empty.')\n    else:\n        string_length = len(list_of_strings[0])\n        all_equal_length = all((len(string) == string_length for string in list_of_strings))\n        if all_equal_length:\n            print('All strings in the list are of equal length.')\n        else:\n            print('Not all strings in the list are of equal length.')"], [0.8895975947380066, "    if not lst:\n        return True\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True"], [0.8886514902114868, "    if len(lst) == 0:\n        return False\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True"], [0.8886175751686096, "        if all_equal_length:\n            print('All strings in the list are of equal length.')\n        else:\n            print('Not all strings in the list are of equal length.')"], [0.885779857635498, "    for s in str_list:\n        if s.lower() != s:\n            return False\n    return True"], [0.8855278491973877, "    if len(lst) == 0:\n        return True\n    first_element = lst[0]\n    for i in range(1, len(lst)):\n        if lst[i] != first_element:\n            return False\n    return True"], [0.8852776288986206, "    for i in range(len(my_list)):\n        for j in range(i + 1, len(my_list)):\n            if my_list[i] != my_list[j]:\n                return False\n    return True"], [0.885048508644104, "    for string in string_list:\n        if len(string) != string_length:\n            return False"]]}
{"task_id": "MBPP/274", "problem": [[0.9024074077606201, "    if re.search(pattern, s):\n        return True\n    else:\n        return \"Error: The string does not contain 'a' followed by any characters, ending in 'b'.\""], [0.894310474395752, "    if string.count('a') < 2:\n        return False\n    if 'b' not in string or 'c' not in string:\n        return False\n    if string.index('b') > string.index('c'):\n        return False\n    return True"], [0.8910571932792664, "    pattern = 'Ab?c'\n    return re.match(pattern, s) is not None"], [0.8908705711364746, "    if not isinstance(s, str):\n        return 'Error: Input is not a string.'\n    pattern = 'a.*b$'\n    if re.search(pattern, s):\n        return True\n    else:\n        return \"Error: The string does not contain 'a' followed by any characters, ending in 'b'.\""], [0.8883770108222961, "    pattern = '^.*a{2}.*$'\n    if re.match(pattern, string):\n        return True\n    else:\n        return False"], [0.888206422328949, "    regex = '^.*a.*b.*c.*$'\n    match = re.search(regex, s)\n    if match:\n        return True\n    return False"], [0.8870445489883423, "    if string.count('a') < 2:\n        return False\n    if string.count('b') != 1:\n        return False\n    if string.count('c') == 0 or string.count('d') == 0:\n        return False\n    if 'bd' in string:\n        return False\n    if string.index('c') > string.index('d'):\n        return False\n    return True"], [0.8865867853164673, "    if input_string[0] == 'a' and input_string[-1] == 'b':\n        return True\n    else:\n        return False"], [0.8865867853164673, "    if input_string[0] == 'a' and input_string[-1] == 'b':\n        return True\n    else:\n        return False"], [0.8848963379859924, "    matches = re.findall('abbb', input_str)\n    return len(matches) > 0"]]}
{"task_id": "MBPP/275", "problem": [[0.9156724214553833, "    for i in range(len(arr) * min(2, k)):\n        max_ending_here = max(arr[i % len(arr)], max_ending_here + arr[i % len(arr)])\n        max_sum = max(max_sum, max_ending_here)"], [0.9140724539756775, "    max_sum = 0\n    start, end = (0, k - 1)\n    while end < len(array):\n        sub_array = array[start:end + 1]\n        new_sum = sum(sub_array)\n        if new_sum > max_sum:\n            max_sum = new_sum\n        start += 1\n        end += 1\n    return max_sum"], [0.9087518453598022, "    mod = 10 ** 9 + 7\n    n = len(arr)\n    max_sum, max_left, max_right = (0, 0, 0)\n    total_sum = sum(arr)\n    temp_sum = 0\n    for i in range(n):\n        temp_sum += arr[i]\n        max_sum = max(max_sum, temp_sum)\n        temp_sum = max(0, temp_sum)\n        max_left = max(max_left, temp_sum)\n    temp = total_sum\n    for i in range(n - 1, -1, -1):\n        temp -= arr[i]\n        max_right = max(max_right, temp)\n    ans = max(max_sum, max_left + max_right + total_sum * (k - 2), 0)\n    return ans % mod"], [0.9087285995483398, "    if len(arr) < k:\n        return 0\n    max_sum = 0\n    sum = 0\n    for i in range(k):\n        sum += arr[i]\n    max_sum = sum\n    i = 0\n    j = k\n    while j < len(arr):\n        sum = sum - arr[i] + arr[j]\n        if sum > max_sum:\n            max_sum = sum\n        i += 1\n        j += 1\n    return max_sum"], [0.9084204435348511, "    for i in range(0, k):\n        max_sum += arr[i]"], [0.9076988697052002, "            if sum(arr[i:i + m]) * k > sum(max_m) * k or (sum(arr[i:i + m]) * k == sum(max_m) * k and arr[i - m:i] > max_m):\n                max_m = arr[i:i + m]"], [0.9071744084358215, "    while i < len(arr) - m * k + 1:\n        if all((arr[i + j] == arr[i + j + m] for j in range(m * (k - 1)))):\n            if sum(arr[i:i + m]) * k > sum(max_m) * k or (sum(arr[i:i + m]) * k == sum(max_m) * k and arr[i - m:i] > max_m):\n                max_m = arr[i:i + m]\n            i += m * k - 1\n        i += 1"], [0.9064028263092041, "    max_m = [-1] * m\n    i = 0\n    while i < len(arr) - m * k + 1:\n        if all((arr[i + j] == arr[i + j + m] for j in range(m * (k - 1)))):\n            if sum(arr[i:i + m]) * k > sum(max_m) * k or (sum(arr[i:i + m]) * k == sum(max_m) * k and arr[i - m:i] > max_m):\n                max_m = arr[i:i + m]\n            i += m * k - 1\n        i += 1\n    return (sum(max_m) > -1, max_m)"], [0.9062168598175049, "    for i in range(len(arr) - k + 1):\n        curr_sum = 0\n        for j in range(i, i + k):\n            curr_sum += arr[j]\n        max_sum = max(max_sum, curr_sum)"], [0.9061333537101746, "    max_sum = 0\n    current_sum = 0\n    for i in range(k):\n        current_sum += arr[i]\n    max_sum = current_sum\n    for i in range(k, len(arr)):\n        current_sum = current_sum - arr[i - k] + arr[i]\n        max_sum = max(max_sum, current_sum)\n    return max_sum"]]}
{"task_id": "MBPP/276", "problem": []}
{"task_id": "MBPP/277", "problem": [[0.8938065767288208, "    count = 0\n    for i in arr:\n        if i >= 0 and is_prime(i) and (i == num):\n            count += 1\n    return count"], [0.8853530287742615, "    A = [(modPow(2, i, N + 1), i) for i in range(1, N + 1)]\n    A.sort()\n    inv = 0\n    bit = [0] * (N + 1)\n    for _, i in A:\n        x = i\n        while x > 0:\n            inv += bit[x]\n            x -= x & -x\n        x = i\n        while x <= N:\n            bit[x] += 1\n            x += x & -x\n    return inv"], [0.8838062286376953, "    for i in arr:\n        if i >= 0 and is_prime(i) and (i == num):\n            count += 1"], [0.882923424243927, "            while q <= n:\n                primePowerCount[q] += 1\n                q *= p"], [0.8794403076171875, "    count = 0\n    for x in arr:\n        is_prime = True\n        for i in range(2, x):\n            if x % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            count += 1\n    return count"], [0.8791124820709229, "    lcm = 1\n    for prime, freq in zip(primes, freqs):\n        lcm = lcm * pow(prime, freq, MOD) % MOD\n    result = lcm * modInv(x) % MOD\n    return result"], [0.877967894077301, "    for num in arr:\n        if num < 0:\n            num = abs(num)\n        if is_prime(num):\n            count += 1"], [0.8769206404685974, "    count = 0\n    for num in arr:\n        if is_prime(num):\n            count += 1\n    return count"], [0.8769165873527527, "    count = 0\n    for num in arr:\n        if is_prime(num):\n            count += 1\n    return count"], [0.8769161105155945, "    count = 0\n    for num in arr:\n        if is_prime(num):\n            count += 1\n    return count"]]}
{"task_id": "MBPP/278", "problem": [[0.9020766019821167, "    count = 0\n    while year > 0:\n        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            count += 1\n        year -= 1\n    return count"], [0.901099681854248, "    if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n        return 366\n    else:\n        return 365"], [0.901099681854248, "    if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n        return 366\n    else:\n        return 365"], [0.8983266949653625, "        if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            count += 1"], [0.898200273513794, "        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            count += 1"], [0.8957658410072327, "        elif year % 100 == 0:\n            return 28\n        elif year % 4 == 0:\n            return 29\n        else:\n            return 28"], [0.8957074880599976, "    from datetime import date\n    start_date = date(year, 1, 1)\n    today = date.today()\n    numofdays = (today - start_date).days\n    return 365 - numofdays"], [0.8955879211425781, "    leap_years = 0\n    for y in range(1582, year + 1):\n        if y % 4 == 0 and y % 100 != 0 or y % 400 == 0:\n            leap_years += 1\n    return leap_years"], [0.894985556602478, "        if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            totalDays += 1"], [0.8932164311408997, "    while year > 0:\n        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            count += 1\n        year -= 1"]]}
{"task_id": "MBPP/279", "problem": [[0.9170675873756409, "    for sublist in list:\n        maxLength = max(maxLength, len(sublist))"], [0.9140346646308899, "    max_count = 0\n    result = []\n    for item in lst:\n        length_item = len(item)\n        if length_item > max_count:\n            max_count = length_item\n            result = [item]\n        elif length_item == max_count:\n            result.append(item)\n    return result"], [0.9128992557525635, "    max_sum = None\n    max_list = None\n    for lst in list_of_lists:\n        if max_sum is None or sum(lst) > max_sum:\n            max_sum = sum(lst)\n            max_list = lst\n    return max_list"], [0.9123244285583496, "    max_length = -1\n    index = -1\n    for i in range(len(lst)):\n        if len(lst[i]) > max_length:\n            max_length = len(lst[i])\n            index = i\n    return (max_length, index)"], [0.9103139638900757, "    for lst in [list1, list2, list3]:\n        cur_num_elm = max([len(s) for s in lst])\n        if cur_num_elm > max_num_elm:\n            max_num_elm = cur_num_elm"], [0.9083154201507568, "    max_length = max((len(sublist) for sublist in lst))\n    index_of_longest = next((i for i, sublist in enumerate(lst) if len(sublist) == max_length))\n    return (max_length, index_of_longest)"], [0.9076851606369019, "    for item in lst:\n        length_item = len(item)\n        if length_item > max_count:\n            max_count = length_item\n            result = [item]\n        elif length_item == max_count:\n            result.append(item)"], [0.9072137475013733, "    max_unique = 0\n    max_list = []\n    for l in nested_list:\n        if len(set(l)) > max_unique:\n            max_unique = len(set(l))\n            max_list = l\n    return max_list"], [0.9053839445114136, "    for lst in list_of_lists:\n        if max_sum is None or sum(lst) > max_sum:\n            max_sum = sum(lst)\n            max_list = lst"], [0.9053548574447632, "    return max(list1, key=len)"]]}
{"task_id": "MBPP/280", "problem": [[0.8940953016281128, "    colors = [2, 3, 4]\n    sums = [1] + [0] * n\n    for color in colors:\n        for j in range(color, n + 1):\n            sums[j] += sums[j - color]\n    return sums[n] - 1"], [0.8864284157752991, "    if n == 0:\n        return 0\n    elif n == 1:\n        return k\n    else:\n        same = [0] * n\n        diff = [0] * n\n        same[0] = k\n        same[1] = k\n        diff[0] = k\n        diff[1] = (k - 1) * k\n        for i in range(2, n):\n            same[i] = diff[i - 1]\n            diff[i] = (k - 1) * (same[i - 1] + diff[i - 1])\n        return same[n - 1] + diff[n - 1]"], [0.8864284157752991, "    if n == 0:\n        return 0\n    elif n == 1:\n        return k\n    else:\n        same = [0] * n\n        diff = [0] * n\n        same[0] = k\n        same[1] = k\n        diff[0] = k\n        diff[1] = (k - 1) * k\n        for i in range(2, n):\n            same[i] = diff[i - 1]\n            diff[i] = (k - 1) * (same[i - 1] + diff[i - 1])\n        return same[n - 1] + diff[n - 1]"], [0.8838192224502563, "    if n <= 1:\n        return 1\n    else:\n        return math.factorial(2 * n) // (math.factorial(n + 1) * math.factorial(n))"], [0.8838192224502563, "    if n <= 1:\n        return 1\n    else:\n        return math.factorial(2 * n) // (math.factorial(n + 1) * math.factorial(n))"], [0.883818507194519, "    if n <= 1:\n        return 1\n    else:\n        return math.factorial(2 * n) // (math.factorial(n + 1) * math.factorial(n))"], [0.883818507194519, "    if n <= 1:\n        return 1\n    else:\n        return math.factorial(2 * n) // (math.factorial(n + 1) * math.factorial(n))"], [0.8830320835113525, "    if k < n or k < 0:\n        return 0\n    return fact[n] * invfact[k] * invfact[n - k] % MOD"], [0.8825972676277161, "    elif n == 1:\n        return k\n    else:\n        same = [0] * n\n        diff = [0] * n\n        same[0] = k\n        same[1] = k\n        diff[0] = k\n        diff[1] = (k - 1) * k\n        for i in range(2, n):\n            same[i] = diff[i - 1]\n            diff[i] = (k - 1) * (same[i - 1] + diff[i - 1])\n        return same[n - 1] + diff[n - 1]"], [0.8825619220733643, "    ways_to_paint_rows = 2 ** num_rows\n    ways_to_paint_columns = 2 ** num_columns\n    total_ways = ways_to_paint_rows * ways_to_paint_columns\n    return total_ways"]]}
{"task_id": "MBPP/281", "problem": [[0.917977511882782, "    quotient = num1 / num2\n    remainder = num1 % num2\n    print('The quotient is:', quotient)\n    print('The remainder is:', remainder)\n    return quotient"], [0.908411979675293, "    quotient = num1 // num2\n    remainder = num1 % num2\n    return (quotient, remainder)"], [0.9083957672119141, "    quotient = num1 // num2\n    remainder = num1 % num2\n    return (quotient, remainder)"], [0.9066479206085205, "    quotient = a // b\n    remainder = a % b\n    print('Quotient:', quotient)\n    print('Remainder:', remainder)"], [0.9044547080993652, "    quotient = num1 // num2\n    remainder = num1 % num2\n    print(f'{num1} divided by {num2} is {quotient} with a remainder of {remainder}')\n    return quotient"], [0.904443085193634, "    quotient = num1 // num2\n    remainder = num1 % num2\n    print(f'{num1} divided by {num2} is {quotient} with a remainder of {remainder}')\n    return quotient"], [0.9036740064620972, "    quotient = num1 // num2\n    remainder = num1 % num2\n    print('The answer is {} with a remainder of {}.'.format(quotient, remainder))"], [0.9025429487228394, "    quotient = x / y\n    remainder = x % y\n    return (quotient, remainder)"], [0.9024113416671753, "    if b == 0:\n        return 'undefined'\n    quotient = 0\n    while a >= b:\n        a -= b\n        quotient += 1\n    return quotient"], [0.9024025797843933, "    if b == 0:\n        return 'undefined'\n    quotient = 0\n    while a >= b:\n        a -= b\n        quotient += 1\n    return quotient"]]}
{"task_id": "MBPP/282", "problem": [[0.8919987678527832, "    if side1 + side2 <= side3 or side2 + side3 <= side1 or side1 + side3 <= side2:\n        raise ValueError('Invalid triangle: sum of any two sides is not greater than the third side')\n    if side1 <= 0 or side2 <= 0 or side3 <= 0:\n        raise ValueError('Invalid triangle: sides cannot be zero or negative')\n    if side1 == 0:\n        missing_side = math.sqrt(side3 ** 2 - side2 ** 2)\n    elif side2 == 0:\n        missing_side = math.sqrt(side3 ** 2 - side1 ** 2)\n    else:\n        missing_side = math.sqrt(side1 ** 2 + side2 ** 2)\n    return round(missing_side)"], [0.8915107250213623, "    sides = [side1, side2, side3]\n    sides.sort()\n    if sides[0] + sides[1] <= sides[2]:\n        raise ValueError('Invalid triangle')\n    if sides[0] ** 2 + sides[1] ** 2 != sides[2] ** 2:\n        raise ValueError('Not a right triangle')\n    missing_side = (sides[0] ** 2 + sides[1] ** 2) ** 0.5\n    return missing_side"], [0.8858010768890381, "    elif side1 + side2 <= side1 or side1 + side2 <= side2 or side1 + side1 <= side2:\n        print('Invalid input. These sides do not form a valid triangle')\n        return None\n    else:\n        height = side2 * math.sin(math.radians(angle))\n        return height"], [0.8826761841773987, "    elif side2 == 0:\n        missing_side = math.sqrt(side3 ** 2 - side1 ** 2)\n    else:\n        missing_side = math.sqrt(side1 ** 2 + side2 ** 2)"], [0.8823167681694031, "    angle_radians = math.radians(angle)\n    height = opposite_side_length * math.sin(angle_radians)\n    return height"], [0.8822988271713257, "    elif side_b ** 2 + side_c ** 2 == side_a ** 2:\n        return math.sqrt(side_b ** 2 + side_c ** 2)\n    else:\n        raise ValueError('The given sides do not satisfy the Pythagorean theorem')"], [0.8809611797332764, "    if side1 == side2:\n        raise InvalidTriangleException('The given sides do not form a right triangle.')"], [0.8807372450828552, "    if angle <= 0 or angle >= 180:\n        print('Invalid input. Please enter a valid angle')\n        return None\n    elif side1 <= 0 or side2 <= 0:\n        print('Invalid input. Please enter valid sides')\n        return None\n    elif side1 + side2 <= side1 or side1 + side2 <= side2 or side1 + side1 <= side2:\n        print('Invalid input. These sides do not form a valid triangle')\n        return None\n    else:\n        height = side2 * math.sin(math.radians(angle))\n        return height"], [0.8807372450828552, "    if angle <= 0 or angle >= 180:\n        print('Invalid input. Please enter a valid angle')\n        return None\n    elif side1 <= 0 or side2 <= 0:\n        print('Invalid input. Please enter valid sides')\n        return None\n    elif side1 + side2 <= side1 or side1 + side2 <= side2 or side1 + side1 <= side2:\n        print('Invalid input. These sides do not form a valid triangle')\n        return None\n    else:\n        height = side2 * math.sin(math.radians(angle))\n        return height"], [0.8797630667686462, "    elif side_a ** 2 + side_c ** 2 == side_b ** 2:\n        return math.sqrt(side_a ** 2 + side_c ** 2)\n    elif side_b ** 2 + side_c ** 2 == side_a ** 2:\n        return math.sqrt(side_b ** 2 + side_c ** 2)\n    else:\n        raise ValueError('The given sides do not satisfy the Pythagorean theorem')"]]}
{"task_id": "MBPP/283", "problem": [[0.9102327823638916, "    max_value = input_list[0]\n    for value in input_list:\n        if value > max_value:\n            max_value = value\n    return max_value"], [0.9102317690849304, "    max_value = input_list[0]\n    for value in input_list:\n        if value > max_value:\n            max_value = value\n    return max_value"], [0.9102190732955933, "    max_value = input_list[0]\n    for value in input_list:\n        if value > max_value:\n            max_value = value\n    return max_value"], [0.9097464084625244, "    max_value = 0\n    for element in list:\n        if element > max_value:\n            max_value = element\n    return max_value"], [0.9088153839111328, "    max_value = None\n    no_numeric_values = True\n    for el in arr:\n        if type(el) == int or type(el) == float:\n            no_numeric_values = False\n            if max_value is None or el > max_value:\n                max_value = el\n    if no_numeric_values:\n        return 'No numerical values found.'\n    else:\n        return max_value"], [0.9087114334106445, "    maximum = 0\n    for num in list:\n        if num > maximum:\n            maximum = num\n    return maximum"], [0.9085575342178345, "    max_item = list[0]\n    for item in list:\n        if item > max_item:\n            max_item = item\n    return max_item"], [0.9083346128463745, "        for value in lst:\n            try:\n                if not maximum:\n                    maximum = value\n                elif value > maximum:\n                    maximum = value\n            except TypeError:\n                return 'Error: List contains non-comparable types.'"], [0.9077091217041016, "    max_value = l[0]\n    for n in l:\n        if n > max_value:\n            max_value = n\n    return max_value"], [0.9071829319000244, "    max = list[0]\n    for a in list:\n        if a > max:\n            max = a\n    return max"]]}
{"task_id": "MBPP/284", "problem": [[0.9269799590110779, "    divisors = [i for i in range(1, num) if num % i == 0]\n    return sum(divisors)"], [0.9211775660514832, "    divisors = []\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisors.append(i)\n    return sum(divisors)"], [0.9145058989524841, "    divisor_sum = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisor_sum += i\n    return divisor_sum"], [0.9134545922279358, "    if n <= 1:\n        return 0\n    sum_divisors = 1\n    for i in range(2, int(n / 2) + 1):\n        if n % i == 0:\n            sum_divisors += i\n    return sum_divisors"], [0.9118098020553589, "    divisors_sum = 0\n    for i in range(1, num):\n        if num % i == 0:\n            divisors_sum += i\n    return divisors_sum"], [0.911483883857727, "    divisors = [i for i in range(1, n + 1) if n % i == 0]\n    return divisors"], [0.911480724811554, "    divisors = [i for i in range(1, n + 1) if n % i == 0]\n    return divisors"], [0.9092029333114624, "    sum_divisors = 0\n    for i in range(1, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if i != num and (not is_prime(i)):\n                sum_divisors += i\n            if i != num and i != num // i and (not is_prime(num // i)):\n                sum_divisors += num // i\n    return sum_divisors"]]}
{"task_id": "MBPP/285", "problem": [[0.9263496398925781, "    inversions = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inversions += 1\n    return inversions"], [0.9253156185150146, "    inversion_count = 0\n    for i in range(0, len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inversion_count += 1\n    return inversion_count"], [0.9231417179107666, "    inversion_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inversion_count += 1\n    return inversion_count"], [0.9153294563293457, "    if len(arr) <= 1:\n        return (arr, 0)\n    else:\n        middle = len(arr) // 2\n        left, left_inversions = count_inversions(arr[:middle])\n        right, right_inversions = count_inversions(arr[middle:])\n        result, split_inversions = merge_and_count_inversions(left, right)\n        return (result, left_inversions + right_inversions + split_inversions)"], [0.9153294563293457, "    if len(arr) <= 1:\n        return (arr, 0)\n    else:\n        middle = len(arr) // 2\n        left, left_inversions = count_inversions(arr[:middle])\n        right, right_inversions = count_inversions(arr[middle:])\n        result, split_inversions = merge_and_count_inversions(left, right)\n        return (result, left_inversions + right_inversions + split_inversions)"], [0.9122133255004883, "    inverted_array = list(reversed(input_array))\n    inversion_count = 0\n    for i in range(len(input_array)):\n        for j in range(i + 1, len(input_array)):\n            if input_array[i] > input_array[j]:\n                inversion_count += 1\n    return (inverted_array, inversion_count)"], [0.9102210402488708, "    if start >= end:\n        return 0\n    mid = (start + end) // 2\n    inversions = merge_sort(nums, start, mid, temp) + merge_sort(nums, mid + 1, end, temp)\n    i, j = (start, mid + 1)\n    while i <= mid and j <= end:\n        if nums[i] <= nums[j]:\n            i += 1\n        else:\n            inversions += mid - i + 1\n            j += 1\n    merge(nums, start, mid, end, temp)\n    return inversions"], [0.9102131128311157, "    if start >= end:\n        return 0\n    mid = (start + end) // 2\n    inversions = merge_sort(nums, start, mid, temp) + merge_sort(nums, mid + 1, end, temp)\n    i, j = (start, mid + 1)\n    while i <= mid and j <= end:\n        if nums[i] <= nums[j]:\n            i += 1\n        else:\n            inversions += mid - i + 1\n            j += 1\n    merge(nums, start, mid, end, temp)\n    return inversions"], [0.9088349342346191, "    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count"], [0.9078990817070007, "    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] < arr[i]:\n                inversions += 1"]]}
{"task_id": "MBPP/286", "problem": [[0.918831467628479, "    flattened_list = []\n    for item in nested_list:\n        if type(item) == list:\n            flattened_list += item\n        else:\n            flattened_list.append(item)\n    return flattened_list"], [0.9169492125511169, "    if not nested_list:\n        return []\n    first_list, remaining_lists = (nested_list[0], nested_list[1:])\n    flat_list = []\n    for element in first_list:\n        flat_list.append(element)\n    return flat_list + flatten_list(remaining_lists)"], [0.9168915152549744, "    if not nested_list:\n        return []\n    first_list, remaining_lists = (nested_list[0], nested_list[1:])\n    flat_list = []\n    for element in first_list:\n        flat_list.append(element)\n    return flat_list + flatten_list(remaining_lists)"], [0.916506290435791, "    flattened_list = []\n    for sublist in nested_list:\n        for item in sublist:\n            flattened_list.append(item)\n    return flattened_list"], [0.9165045619010925, "    flattened_list = []\n    for sublist in nested_list:\n        for item in sublist:\n            flattened_list.append(item)\n    return flattened_list"], [0.9155434370040894, "    flat_list = []\n    for sublist in nested_list:\n        for item in sublist:\n            flat_list.append(item)\n    return flat_list"], [0.9150062799453735, "    output = []\n    for i in nested_list:\n        if isinstance(i, list):\n            output.extend(flattenList(i))\n        else:\n            output.append(i)\n    return output"], [0.915000319480896, "    output = []\n    for i in nested_list:\n        if isinstance(i, list):\n            output.extend(flattenList(i))\n        else:\n            output.append(i)\n    return output"]]}
{"task_id": "MBPP/287", "problem": [[0.9161186218261719, "    for item in list1:\n        if item in list2:\n            result.append(item)\n        if isinstance(item, list):\n            nested_result = find_overlapping_elements(item, list2)\n            result.extend(nested_result)"], [0.9151726961135864, "    result = []\n    for item in list1:\n        if item in list2:\n            result.append(item)\n        if isinstance(item, list):\n            nested_result = find_overlapping_elements(item, list2)\n            result.extend(nested_result)\n    return result"], [0.9145150184631348, "    count = 0\n    for sub_list in nested_list:\n        for elem in sub_list:\n            if elem == item:\n                count += 1\n    return count"], [0.9113320112228394, "    found = False\n    for i in range(len(nested_list)):\n        for j in range(len(nested_list[i])):\n            if nested_list[i][j] == target:\n                found = True\n                return (target, i, j)\n    if not found:\n        return 'Value not found'"], [0.9110997915267944, "    for i in range(len(nested_list)):\n        for j in range(len(nested_list[i])):\n            if nested_list[i][j] == target:\n                found = True\n                return (target, i, j)"], [0.9097486734390259, "    for sub_list in nested_list:\n        for elem in sub_list:\n            if elem == item:\n                count += 1"], [0.9097052812576294, "    list3 = [value for value in list1 if value in list2]\n    return list3"], [0.9093407988548279, "    flat_list1 = flatten(list_one)\n    flat_list2 = flatten(list_two)\n    common_list = [value for value in flat_list1 if value in flat_list2]\n    return common_list"], [0.9087589979171753, "    lst3 = [value for value in lst1 if value in lst2]\n    return lst3"], [0.9085926413536072, "    temp_list = []\n    for element in list1:\n        if element in list2:\n            temp_list.append(element)\n    return temp_list"]]}
{"task_id": "MBPP/288", "problem": [[0.9038277864456177, "    max_values = []\n    for tup in list_of_tuples:\n        max_values.append(max(tup))\n    return max_values"], [0.8954051733016968, "    for tup in list_of_tuples:\n        max_values.append(max(tup))"], [0.883834183216095, "    max_values = {}\n    for item in input_list:\n        group = item['group']\n        value = item['value']\n        if group not in max_values or value > max_values[group]:\n            max_values[group] = value\n    output_list = [{'group': group, 'max_value': value} for group, value in max_values.items()]\n    return output_list"], [0.8824976682662964, "    if isinstance(args[0], tuple):\n        return [max(t) for t in args]\n    else:\n        return max(args)"], [0.8824868202209473, "    if isinstance(args[0], tuple):\n        return [max(t) for t in args]\n    else:\n        return max(args)"], [0.8789302110671997, "    max_value = 0\n    for element in list:\n        if element > max_value:\n            max_value = element\n    return max_value"], [0.8781439065933228, "    maximum = 0\n    for num in list:\n        if num > maximum:\n            maximum = num\n    return maximum"], [0.8777869343757629, "    if len(list) == 0:\n        return None\n    max = list[0]\n    for i in range(1, len(list)):\n        if list[i] > max:\n            max = list[i]\n    return max"], [0.8770224452018738, "    max = list[0]\n    for a in list:\n        if a > max:\n            max = a\n    return max"], [0.8766415119171143, "    max = list[0]\n    for i in list:\n        if i > max:\n            max = i\n    return max"]]}
{"task_id": "MBPP/289", "problem": [[0.9089908599853516, "    sum = 0\n    for i in range(1, n + 1):\n        term = math.pow(2, i) / math.factorial(i)\n        sum += term\n    return sum"], [0.9063689112663269, "    if n <= 1:\n        return 1\n    else:\n        return math.factorial(2 * n) // (math.factorial(n + 1) * math.factorial(n))"], [0.9063689112663269, "    if n <= 1:\n        return 1\n    else:\n        return math.factorial(2 * n) // (math.factorial(n + 1) * math.factorial(n))"], [0.9063622951507568, "    if n <= 1:\n        return 1\n    else:\n        return math.factorial(2 * n) // (math.factorial(n + 1) * math.factorial(n))"], [0.9063622951507568, "    if n <= 1:\n        return 1\n    else:\n        return math.factorial(2 * n) // (math.factorial(n + 1) * math.factorial(n))"], [0.9059543609619141, "    dp = [[0] * 1024 for _ in range(11)]\n    dp[0][0] = 1\n    for i in range(10):\n        mask = 1 << i\n        for j in range(n + 1):\n            for f in range(1024):\n                if dp[j][f] == 0:\n                    continue\n                for k in range(10):\n                    if f & 1 << k != 0:\n                        continue\n                    if i * 2 == j and k == 0:\n                        continue\n                    nf = f | 1 << k\n                    dp[j + 1 if k % 2 == 0 else j][nf] += dp[j][f]\n    return sum((dp[i][1023] for i in range(n // 2 * 2 + 1, n + 1)))"], [0.9056851863861084, "    for i in range(1, n + 1):\n        term = math.pow(2, i) / math.factorial(i)\n        sum += term"], [0.9048875570297241, "    for i in range(n):\n        count += countBinaryTrees(i) * countBinaryTrees(n - i - 1)"], [0.9048705101013184, "    for i in range(1, n + 1):\n        for j in range(2 * n + 1):\n            if j - 1 >= 0:\n                dp[i][j] += dp[i - 1][j - 1]\n            if j + 1 <= 2 * n:\n                dp[i][j] += dp[i - 1][j + 1]"], [0.9041309356689453, "    sum = 0\n    fact = math.factorial(n)\n    for i in range(n + 1):\n        if i % 2 == 0:\n            sum += fact / math.factorial(i)\n        else:\n            sum -= fact / math.factorial(i)\n    return int(sum)"]]}
{"task_id": "MBPP/290", "problem": [[0.9230877757072449, "    for value in dictionary.values():\n        depth = 1 + find_max_depth(value)\n        max_depth = max(max_depth, depth)"], [0.9201183915138245, "    if not isinstance(dictionary, dict):\n        return 0\n    max_depth = 0\n    for value in dictionary.values():\n        depth = 1 + find_max_depth(value)\n        max_depth = max(max_depth, depth)\n    return max_depth"], [0.9150459170341492, "    if isinstance(d, dict):\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)"], [0.914048969745636, "    if isinstance(d, dict):\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\n    return 0"], [0.9038162231445312, "    for k, v in dictionary.items():\n        if isinstance(v, dict):\n            new_path = f'{path}/{k}'\n            new_level, max_level, max_path = max_depth(v, new_path, level + 1, max_level, max_path)\n            if new_level > max_level:\n                max_level = new_level\n                max_path = new_path\n        elif level > max_level:\n            max_level = level\n            max_path = path\n    return (level, max_level, max_path)"], [0.9007081389427185, "    keys = len(d)\n    for k, v in d.items():\n        if isinstance(v, dict):\n            keys += count_keys(v, depth + 1)\n    return keys"], [0.9006878137588501, "    keys = len(d)\n    for k, v in d.items():\n        if isinstance(v, dict):\n            keys += count_keys(v, depth + 1)\n    return keys"], [0.8984403610229492, "    for k, v in dictionary.items():\n        if isinstance(v, dict):\n            new_path = f'{path}/{k}'\n            new_level, max_level, max_path = max_depth(v, new_path, level + 1, max_level, max_path)\n            if new_level > max_level:\n                max_level = new_level\n                max_path = new_path\n        elif level > max_level:\n            max_level = level\n            max_path = path"], [0.8971502184867859, "    if not isinstance(d, dict):\n        return (depth, 0, [])\n    depth += 1\n    key_count = len(d)\n    value_types = set((type(v) for v in d.values()))\n    inner_depth, inner_key_count, inner_value_types = (0, 0, set())\n    for v in d.values():\n        if isinstance(v, dict):\n            id, ikc, ivt = analyze_dict(v, depth)\n            inner_depth = max(inner_depth, id)\n            inner_key_count += ikc\n            inner_value_types = inner_value_types.union(ivt)\n        elif isinstance(v, list):\n            for item in v:\n                if isinstance(item, dict):\n                    id, ikc, ivt = analyze_dict(item, depth)\n                    inner_depth = max(inner_depth, id)\n                    inner_key_count += ikc\n                    inner_value_types = inner_value_types.union(ivt)\n    value_types = value_types.union(inner_value_types)\n    return (max(depth, inner_depth), key_count + inner_key_count, value_types)"], [0.8971405029296875, "    if not isinstance(d, dict):\n        return (depth, 0, [])\n    depth += 1\n    key_count = len(d)\n    value_types = set((type(v) for v in d.values()))\n    inner_depth, inner_key_count, inner_value_types = (0, 0, set())\n    for v in d.values():\n        if isinstance(v, dict):\n            id, ikc, ivt = analyze_dict(v, depth)\n            inner_depth = max(inner_depth, id)\n            inner_key_count += ikc\n            inner_value_types = inner_value_types.union(ivt)\n        elif isinstance(v, list):\n            for item in v:\n                if isinstance(item, dict):\n                    id, ikc, ivt = analyze_dict(item, depth)\n                    inner_depth = max(inner_depth, id)\n                    inner_key_count += ikc\n                    inner_value_types = inner_value_types.union(ivt)\n    value_types = value_types.union(inner_value_types)\n    return (max(depth, inner_depth), key_count + inner_key_count, value_types)"]]}
{"task_id": "MBPP/291", "problem": [[0.9006671905517578, "    binary = bin(n)[2:]\n    return len(binary) - binary.find('1')"], [0.8937824964523315, "    return number.bit_length() - 1"], [0.8921354413032532, "        if not bit_vector & 1 << i:\n            return i + 1"], [0.8909868001937866, "    binary = bin(num)[2:]\n    count = 0\n    for bit in reversed(binary):\n        if bit == '0':\n            count += 1\n        else:\n            break\n    return count"], [0.8902969360351562, "    binary = bin(n)[2:]\n    index_of_last_one = -1\n    max_gap = 0\n    for i in range(len(binary)):\n        if binary[i] == '1':\n            if index_of_last_one >= 0:\n                gap = i - index_of_last_one - 1\n                max_gap = max(max_gap, gap)\n            index_of_last_one = i\n    return max_gap"], [0.8902767896652222, "    binary = bin(n)[2:]\n    index_of_last_one = -1\n    max_gap = 0\n    for i in range(len(binary)):\n        if binary[i] == '1':\n            if index_of_last_one >= 0:\n                gap = i - index_of_last_one - 1\n                max_gap = max(max_gap, gap)\n            index_of_last_one = i\n    return max_gap"], [0.887858510017395, "    return bin(n).count('1')"], [0.886387288570404, "    for count in highest_bit:\n        result = max(result, count)"], [0.8859133720397949, "    p = 0\n    while 1 << p + 1 <= n:\n        p += 1\n    return p"], [0.8855503797531128, "    result = 0\n    highest_bit = [0] * 32\n    for num in nums:\n        for j in range(32):\n            if num & 1 << j:\n                highest_bit[j] += 1\n    for count in highest_bit:\n        result = max(result, count)\n    return result + 31"]]}
{"task_id": "MBPP/292", "problem": [[0.8840997219085693, "    if count1 == count2:\n        return True\n    else:\n        return False"], [0.8823354840278625, "    if s1_count == s2_count:\n        return True\n    else:\n        return False"], [0.8796061277389526, "    if str1_count == str2_count:\n        return True\n    else:\n        return False"], [0.8786142468452454, "    if count_dict1 != count_dict2:\n        return False"], [0.876702606678009, "    return Counter(list1) == Counter(list2)"], [0.8756668567657471, "    return Counter(lst1) == Counter(lst2)"], [0.8756529092788696, "    return Counter(lst1) == Counter(lst2)"], [0.8751487731933594, "    equal_count = 0\n    equal_positions = []\n    if len(arr1) != len(arr2):\n        return (False, equal_count)\n    for i in range(len(arr1)):\n        if arr1[i] == arr2[i]:\n            equal_count += 1\n            equal_positions.append(i)\n    return (False if equal_count != len(arr1) else True, equal_count, equal_positions)"], [0.8743799924850464, "    if count1 == count2:\n        return True"], [0.8740088939666748, "    try:\n        g1type = next(iter(group1))\n        for item in group1:\n            if type(item) != type(g1type):\n                raise ValueError('All elements in each group must be the same type')\n        for item in group2:\n            if type(item) != type(g1type):\n                raise ValueError('All elements in each group must be the same type')\n        if len(set(group1)) != len(group1):\n            raise ValueError('Group1 contains repeated items')\n        for item in group1:\n            if item not in group2:\n                return False\n        return True\n    except ValueError as ve:\n        print('An exception occurred: ', ve)\n    except Exception as e:\n        print('An exception occurred: ', e)"]]}
{"task_id": "MBPP/293", "problem": [[0.9071388840675354, "    for i in range(N):\n        rotated_list.append(given_list[(i + K) % len_given_lst])"], [0.903816819190979, "    num_of_rotations = k % len(arr)\n    arr = arr[num_of_rotations:] + arr[:num_of_rotations]\n    return arr"], [0.9027888774871826, "    n = len(arr)\n    d = d % n\n    rotated_arr = arr[-d:] + arr[:-d]\n    return rotated_arr"], [0.900787353515625, "    if rotation == 0:\n        return arr\n    rotation = -rotation % len(arr)\n    return array_rotate(arr, rotation)"], [0.8997993469238281, "    if not arr or rotation == 0:\n        return arr\n    rotation = rotation % len(arr)\n    if rotation < 0:\n        rotation += len(arr)\n    arr[:rotation], arr[rotation:] = (arr[-rotation:], arr[:-rotation])\n    return arr"], [0.8991291522979736, "    if rotation < 0:\n        rotation += len(arr)"], [0.8989643454551697, "    if not given_list:\n        return []\n    rotated_list = []\n    len_given_lst = len(given_list)\n    for i in range(N):\n        rotated_list.append(given_list[(i + K) % len_given_lst])\n    return rotated_list"], [0.8978017568588257, "    if k > 1:\n        rotate(arr, k - 1)"], [0.8966304659843445, "    length = len(arr)\n    rotation = k % length\n    rotated_arr = []\n    for i in range(length):\n        new_pos = (i + rotation) % length\n        if not wrap and new_pos >= length:\n            continue\n        rotated_arr.append(arr[new_pos])\n    return rotated_arr"], [0.8963457942008972, "    for i in range(k):\n        rotated_list = [rotated_list[-1]] + rotated_list[:-1]"]]}
{"task_id": "MBPP/294", "problem": [[0.8925397396087646, "    matching_words = [word for word in words_list if query in word]\n    return matching_words"], [0.8923183679580688, "    for word in words:\n        if pattern.search(word):\n            matched_words.append(word)"], [0.8923114538192749, "    for word in words:\n        if pattern.search(word):\n            matched_words.append(word)"], [0.8892611265182495, "    return [item for item in word_list if word1 in item and word2 in item]"], [0.8887100219726562, "    words = words.strip()\n    word_list = words.split()\n    if len(word_list) < 3:\n        return 'Input string must contain at least three words'\n    last_word = word_list[-1]\n    second_last_word = word_list[-2]\n    return (second_last_word, last_word)"], [0.8877663016319275, "    for word in words:\n        if word[0] == letter:\n            matches.append(word)"], [0.8858890533447266, "    words = open('words.txt').read().splitlines()\n    if word in words:\n        return word\n    else:\n        suggestions = []\n        for w in words:\n            if re.search(word[0], w):\n                if re.search(word[1], w):\n                    if re.search(word[2], w):\n                        suggestions.append(w)\n        return suggestions"], [0.8851797580718994, "    extracted_words = []\n    for word in word_list:\n        if word[0] == given_letter:\n            extracted_words.append(word)\n    return extracted_words"], [0.885050892829895, "    for word in words:\n        if word[0] == char and word[-1] == char:\n            print(word)\n            print(word.upper())"], [0.8845800161361694, "    found_words = []\n    for word in words:\n        if 'a' in word:\n            found_words.append(word)\n    return found_words"]]}
{"task_id": "MBPP/295", "problem": [[0.9029334783554077, "            if arr[i] > arr[j] and max_sum[i] < max_sum[j] + arr[i]:\n                max_sum[i] = max_sum[j] + arr[i]"], [0.8990116119384766, "        if max_sum_ending_here > max_sum:\n            max_sum = max_sum_ending_here"], [0.8985146880149841, "        if max_so_far < max_till_here:\n            max_so_far = max_till_here"], [0.8981460332870483, "    if i == len(arr):\n        return 0\n    sum_of_largest = findSum(arr, i + 1)\n    if i == 0 or arr[i] > sum_of_largest:\n        return arr[i] + sum_of_largest\n    else:\n        return sum_of_largest"], [0.8979414701461792, "    for i in range(n):\n        max_sum[i] = arr[i]"], [0.8966784477233887, "        if max_ending_so_far < max_ending_here:\n            max_ending_so_far = max_ending_here\n            end = i"], [0.8965380191802979, "    for i in range(1, len(arr)):\n        temp = max_sum_incl\n        max_sum_incl = max(max_sum_excl + arr[i], max_sum_incl)\n        max_sum_excl = temp"], [0.8964583277702332, "    if i == 0 or arr[i] > sum_of_largest:\n        return arr[i] + sum_of_largest\n    else:\n        return sum_of_largest"], [0.8959110975265503, "        for j in range(i, n):\n            max_ending_here += arr[j]\n            if max_sum_so_far < max_ending_here:\n                max_sum_so_far = max_ending_here"], [0.8955981135368347, "        for j in range(i, n):\n            curr_sum = curr_sum + arr[j]\n            max_sum = max(max_sum, curr_sum)"]]}
{"task_id": "MBPP/296", "problem": [[0.8699681758880615, "    return tuple[-4:-2]"], [0.8645063638687134, "    if type(tup) != tuple:\n        return 'Error: Not a tuple.'"], [0.8643205165863037, "    if not tup:\n        return 'Error: Tuple is empty.'"]]}
{"task_id": "MBPP/297", "problem": [[0.8975734114646912, "    max_product = float('-inf')\n    max_lists = []\n    for lst in list_of_lists:\n        if len(lst) != 0:\n            product = 1\n            for num in lst:\n                product *= num\n            product = round(product, 2)\n            if product == max_product:\n                max_lists.append(lst)\n            elif product > max_product:\n                max_lists = [lst]\n                max_product = product\n    return (max_product, max_lists)"], [0.8968391418457031, "    products_list = []\n    for lst in list_of_lists:\n        product = 1\n        for num in lst:\n            product *= num\n        products_list.append(round(product, 2))\n    max_product = max(products_list)\n    max_lists = [list_of_lists[i] for i in range(len(list_of_lists)) if products_list[i] == max_product]\n    return (max_lists, max_product)"], [0.8960877060890198, "    max_product = float('-inf')\n    max_lists = []\n    for lst in list_of_lists:\n        product = 1\n        for num in lst:\n            product *= num\n        if product > max_product:\n            max_product = product\n            max_lists = [lst]\n        elif product == max_product:\n            max_lists.append(lst)\n    return (max_product, max_lists)"], [0.8957583904266357, "    max_product = float('-inf')\n    max_lists = []\n    for lst in list_of_lists:\n        flat_list = list(flatten(lst))\n        if flat_list:\n            temp_product = float(product(flat_list))\n            if temp_product > max_product:\n                max_product = temp_product\n                max_lists = [flat_list]\n            elif temp_product == max_product:\n                max_lists.append(flat_list)\n    return (max_product, max_lists)"], [0.8934485912322998, "    for lst in list_of_lists:\n        product = 1\n        for num in lst:\n            product *= num\n        if product > max_product:\n            max_product = product\n            max_list = lst"], [0.8934305310249329, "    for lst in list_of_lists:\n        product = 1\n        for num in lst:\n            product *= num\n        if product > max_product:\n            max_product = product\n            max_list = lst"]]}
{"task_id": "MBPP/298", "problem": [[0.9238356351852417, "    if a > b:\n        max = a\n    else:\n        max = b\n    return max"], [0.9213209748268127, "    return max(num1, num2)"], [0.9213182926177979, "    return max(num1, num2)"], [0.9213182926177979, "    return max(num1, num2)"], [0.921317458152771, "    return max(num1, num2)"], [0.9201641082763672, "    max_val = num1 if num1 > num2 else num2\n    return max_val"], [0.9184246063232422, "    if a > b:\n        max = a\n    else:\n        max = b"], [0.9175087809562683, "    return max(num_1, num_2)"]]}
{"task_id": "MBPP/299", "problem": [[0.8945112824440002, "    return ast.literal_eval(tup_string)"], [0.8907776474952698, "    l = data.split(',')\n    return tuple([int(c) for c in l])"], [0.8852329254150391, "    decoded_substrings = encoded_string.split('_')\n    return tuple(decoded_substrings)"], [0.8842546343803406, "    result_tuple = (input_string, input_list)\n    return result_tuple"], [0.8837692737579346, "    if type(tup) != tuple:\n        return 'Error: Not a tuple.'"], [0.8833184242248535, "    if not my_tuple:\n        return 'Error: Tuple is empty!'"], [0.8818891048431396, "        if tuple is None:\n            return 'Error: Input is NULL'"], [0.8804237842559814, "    givenstring = givenstring[1:-1]\n    a = givenstring.split('),(')\n    result = []\n    for i in a:\n        b = list(map(int, i.split(',')))\n        result.append((b[0], b[-1]))\n    return result"], [0.8798706531524658, "    if not input_tuple:\n        return 'Error: input is NULL or empty.'\n    str_list = []\n    for element in input_tuple:\n        if not isinstance(element, float):\n            return 'Error: all elements in the tuple should be floats.'\n        str_list.append(str(element))\n    result = '; '.join(str_list)\n    return result"], [0.8780602216720581, "    if not tup:\n        return 'Error: Input tuple is empty'"]]}
{"task_id": "MBPP/300", "problem": [[0.894234836101532, "    least_bit = num & -num\n    small_num = num + least_bit\n    num = num ^ small_num\n    num = num >> 2\n    small_num = small_num | num\n    return small_num"], [0.8854205012321472, "    for i in range(32):\n        if set_count <= 0:\n            break\n        if num2 & 1 << i:\n            x |= 1 << i\n            set_count -= 1"], [0.8848912715911865, "    while num > mask:\n        mask = mask << 1 | 1"], [0.8844310641288757, "            if carry == 0:\n                result |= 1 << i\n            else:\n                carry = 1"], [0.8836376667022705, "            if carry == 1:\n                result |= 1 << i\n            else:\n                carry = 1"], [0.8824334144592285, "    binary = bin(num)\n    binary = binary[2:]\n    reversed_binary = binary[::-1]\n    return reversed_binary + '1'"], [0.8822283148765564, "        if not bit_vector & 1 << i:\n            return i + 1"], [0.8806533813476562, "    mask = 1\n    while num > mask:\n        mask = mask << 1 | 1\n    return num ^ mask"], [0.8798533082008362, "    return integer & ~(integer - 1)"], [0.8798494338989258, "    set_count = bin(num2).count('1')\n    x = 0\n    for i in range(32):\n        if set_count <= 0:\n            break\n        if num2 & 1 << i:\n            x |= 1 << i\n            set_count -= 1\n    return x ^ num1"]]}
{"task_id": "MBPP/301", "problem": [[0.8953503370285034, "    volume = math.pi * radius ** 2 * height\n    return volume"], [0.8932390809059143, "    return 1 / 3 * math.pi * cone['radius'] ** 2 * cone['height']"], [0.8888678550720215, "    base_area = math.pi * base_radius ** 2\n    top_area = math.pi * top_radius ** 2\n    average_radius = (base_radius + top_radius) / 2\n    volume = 1 / 3 * math.pi * height * (base_area + top_area + math.sqrt(base_area * top_area))\n    return volume"], [0.8849292993545532, "    for cone in cones:\n        cone = fix_dict(cone)\n        cone['volume'] = calc_cone_volume(cone)"], [0.8823152780532837, "    step = 0.001\n    volume = 0\n    for x in range(int(radius * 1000)):\n        height = math.sqrt(radius ** 2 - (x / 1000) ** 2)\n        area = math.pi * (x / 1000) ** 2\n        volume += area * step\n    return round(volume)"], [0.8808399438858032, "    volume = 4 / 3 * 3.142 * radius ** 3\n    return round(volume, 2)"], [0.8806363344192505, "    if r <= 0 or h <= 0:\n        return 'Invalid input: Radius and height must be greater than zero.'\n    l = math.sqrt(math.pow(r, 2) + math.pow(h, 2))\n    lsa = math.pi * r * l\n    volume = 1 / 3 * math.pi * math.pow(r, 2) * h\n    return (round(lsa, 2), round(volume, 2))"]]}
{"task_id": "MBPP/302", "problem": [[0.9239857196807861, "    positive_nums = []\n    for n in lst:\n        if n > 0:\n            positive_nums.append(n)\n    return positive_nums"], [0.9216195940971375, "    positive_integers = []\n    for num in input_list:\n        if num > 0:\n            positive_integers.append(num)\n    return positive_integers"], [0.9195581674575806, "    positive_list = []\n    for num in input_list:\n        if num > 0:\n            positive_list.append(num)\n    positive_list.sort()\n    return positive_list"], [0.9181566834449768, "    positive_arr = [i for i in arr if i > 0]\n    return positive_arr"], [0.9151839017868042, "    count = 0\n    for num in nums:\n        if num > 0:\n            count += 1\n    print('Number of positive numbers:', count)"], [0.9146947860717773, "    positive_nums = []\n    for num in nums:\n        if num > 0:\n            positive_nums.append(num)\n    return positive_nums"], [0.9130035638809204, "    for num in input_list:\n        if num > 0:\n            positive_list.append(num)"], [0.9107552170753479, "        if num > 0:\n            positive_list.append(num)"], [0.910711407661438, "    input_list = [1, -2, 3, -4, 5]\n    expected_output = [1, 3, 5]\n    assert positive(input_list) == expected_output"], [0.9091719388961792, "    result = []\n    for num in lst:\n        if num > 0:\n            result.append(num)\n    return result"]]}
{"task_id": "MBPP/303", "problem": [[0.9043250679969788, "    if len(arr) == 0:\n        return 0\n    return max(arr[0] + max_no_adjacent_sum(arr[2:]), max_no_adjacent_sum(arr[1:]))"], [0.9035758972167969, "    if len(arr) == 0:\n        return 0\n    elif len(arr) == 1:\n        return arr[0]\n    else:\n        return max(arr[0] + max_non_adjacent_sum(arr[2:]), max_non_adjacent_sum(arr[1:]))"], [0.9035758972167969, "    if len(arr) == 0:\n        return 0\n    elif len(arr) == 1:\n        return arr[0]\n    else:\n        return max(arr[0] + max_non_adjacent_sum(arr[2:]), max_non_adjacent_sum(arr[1:]))"], [0.901362955570221, "    elif len(arr) == 1:\n        return arr[0]\n    else:\n        return max(arr[0] + max_non_adjacent_sum(arr[2:]), max_non_adjacent_sum(arr[1:]))"], [0.8941925764083862, "    rows = len(test_array)\n    cols = len(test_array[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = test_array[0][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + test_array[0][j]\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + test_array[i][0]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + test_array[i][j]\n    max_sum = float('-inf')\n    for i in range(rows):\n        for j in range(cols):\n            if dp[i][j] > max_sum and test_array[i][j] % 2 != 0 and (dp[i][j] % 2 == 0):\n                max_sum = dp[i][j]\n    return max_sum"], [0.8914965391159058, "    solutions = []\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            solutions.append(numbers[i] + numbers[j])\n    return max(solutions)"]]}
{"task_id": "MBPP/304", "problem": [[0.9094440937042236, "    max_length = 0\n    result = []\n    for word in words:\n        if len(word) % 2 == 0:\n            if len(word) > max_length:\n                max_length = len(word)\n                result = [word]\n            elif len(word) == max_length:\n                result.append(word)\n    return result"], [0.9069963693618774, "    for word in words:\n        if len(word) % 2 == 0:\n            if len(word) > max_length:\n                max_length = len(word)\n                result = [word]\n            elif len(word) == max_length:\n                result.append(word)"], [0.9065079689025879, "        if len(word) % 2 == 0:\n            if len(word) > max_length:\n                max_length = len(word)\n                result = [word]\n            elif len(word) == max_length:\n                result.append(word)"], [0.9027483463287354, "    even_word_list = [word for word in word_list if len(word) % 2 == 0]\n    even_word_list.sort(key=lambda x: (-len(x), x))\n    return even_word_list"]]}
{"task_id": "MBPP/305", "problem": [[0.9235326051712036, "    last_index = -1\n    for idx, elem in enumerate(arr):\n        if elem == number:\n            last_index = idx\n    return last_index"], [0.9194340109825134, "    n = len(arr)\n    last_occurrence = -1\n    for i in range(n):\n        if arr[i] == target:\n            last_occurrence = i\n    return last_occurrence"], [0.9186785221099854, "    i = n\n    while i >= 0:\n        if x == arr[i]:\n            return i\n        i -= 1\n    return -1"], [0.9183606505393982, "    last_index = -1\n    for i in range(len(arr)):\n        if arr[i] == num:\n            last_index = i\n    return last_index"], [0.918204128742218, "    for i in range(len(arr) - 1, -1, -1):\n        if arr[i] == num:\n            return i\n    return -1"], [0.9178721904754639, "    for i in range(len(arr) - 1, -1, -1):\n        if arr[i] == num:\n            return i"], [0.9176520109176636, "    left, right = (0, len(nums) - 1)\n    last_occurrence = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            last_occurrence = mid\n            left = mid + 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return last_occurrence"], [0.917064368724823, "    n = len(arr)\n    arr.sort()\n    for i in range(n):\n        print(arr[i], end=' ')\n    start = 0\n    end = n - 1\n    while start <= end:\n        mid = (start + end) // 2\n        if x == arr[mid]:\n            return mid\n        elif x > arr[mid]:\n            start = mid + 1\n        else:\n            end = mid - 1\n    return -1"], [0.9170512557029724, "    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            return i\n        elif arr[i] > x:\n            return -1\n    return -1"], [0.91658616065979, "    lower_bound = 0\n    upper_bound = len(array) - 1\n    index = -1\n    while lower_bound <= upper_bound:\n        midpoint = (lower_bound + upper_bound) // 2\n        if array[midpoint] < x:\n            lower_bound = midpoint + 1\n        elif array[midpoint] > x:\n            upper_bound = midpoint - 1\n        else:\n            index = midpoint\n            break\n    return index"]]}
{"task_id": "MBPP/306", "problem": [[0.9111336469650269, "    if not list_to_encode:\n        return []\n    else:\n        tmp = []\n        tmp.append(list_to_encode[0])\n        tmp.append(1)\n        i = 1\n        while i < len(list_to_encode) and list_to_encode[i] == tmp[0]:\n            tmp[1] += 1\n            i += 1\n        return tmp + encodeList(list_to_encode[i:])"], [0.9111336469650269, "    if not list_to_encode:\n        return []\n    else:\n        tmp = []\n        tmp.append(list_to_encode[0])\n        tmp.append(1)\n        i = 1\n        while i < len(list_to_encode) and list_to_encode[i] == tmp[0]:\n            tmp[1] += 1\n            i += 1\n        return tmp + encodeList(list_to_encode[i:])"], [0.8987751007080078, "    rle_arr = []\n    for word in arr:\n        encoded = ''\n        i = 0\n        while i < len(word):\n            count = 1\n            while i + 1 < len(word) and word[i] == word[i + 1]:\n                i += 1\n                count += 1\n            encoded += '{}{}'.format(word[i], count)\n            i += 1\n        rle_arr.append(encoded)\n    return rle_arr"], [0.8985769748687744, "    compressed_list = []\n    count = 1\n    for index in range(1, len(original_list)):\n        if original_list[index] == original_list[index - 1]:\n            count += 1\n        else:\n            compressed_list.append(str(original_list[index - 1]) + 'x' + str(count))\n            count = 1\n    compressed_list.append(str(original_list[index]) + 'x' + str(count))\n    return compressed_list"], [0.8961231112480164, "    encoded_sequence = []\n    prev = None\n    count = 0\n    for num in sequence:\n        if prev is None:\n            prev = num\n            count = 1\n        elif num == prev:\n            count += 1\n        else:\n            encoded_sequence.append((prev, count))\n            prev = num\n            count = 1\n    encoded_sequence.append((prev, count))\n    return encoded_sequence"], [0.8947285413742065, "    for index in range(1, len(original_list)):\n        if original_list[index] == original_list[index - 1]:\n            count += 1\n        else:\n            compressed_list.append(str(original_list[index - 1]) + 'x' + str(count))\n            count = 1"], [0.8937875032424927, "        while i < len(list_to_encode) and list_to_encode[i] == tmp[0]:\n            tmp[1] += 1\n            i += 1"], [0.8927516341209412, "        elif num == prev:\n            count += 1\n        else:\n            encoded_sequence.append((prev, count))\n            prev = num\n            count = 1"], [0.8927125930786133, "        if original_list[index] == original_list[index - 1]:\n            count += 1\n        else:\n            compressed_list.append(str(original_list[index - 1]) + 'x' + str(count))\n            count = 1"], [0.8926655054092407, "    for word in arr:\n        encoded = ''\n        i = 0\n        while i < len(word):\n            count = 1\n            while i + 1 < len(word) and word[i] == word[i + 1]:\n                i += 1\n                count += 1\n            encoded += '{}{}'.format(word[i], count)\n            i += 1\n        rle_arr.append(encoded)"]]}
{"task_id": "MBPP/307", "problem": [[0.8892291784286499, "    for cuboid in cuboids:\n        cuboid.sort()\n    cuboids.sort(reverse=True)\n    dp = [0] * len(cuboids)\n    for i in range(len(cuboids)):\n        dp[i] = cuboids[i][2]\n        for j in range(i):\n            if cuboids[i][0] <= cuboids[j][0] and cuboids[i][1] <= cuboids[j][1] and (cuboids[i][2] <= cuboids[j][2]):\n                dp[i] = max(dp[i], dp[j] + cuboids[i][2])\n    return max(dp)"], [0.887913703918457, "    cuboids = [sorted(cuboid) for cuboid in cuboids]\n    cuboids.sort()\n    n = len(cuboids)\n    dp = [0] * n\n    ans = 0\n    for i, cuboid in enumerate(cuboids):\n        dp[i] = cuboid[2]\n        for j in range(i):\n            if all((cuboids[j][k] <= cuboid[k] for k in range(3))):\n                dp[i] = max(dp[i], dp[j] + cuboid[2])\n        ans = max(ans, dp[i])\n    return ans"], [0.8879114389419556, "    cuboids = [sorted(cuboid) for cuboid in cuboids]\n    cuboids.sort()\n    n = len(cuboids)\n    dp = [0] * n\n    ans = 0\n    for i, cuboid in enumerate(cuboids):\n        dp[i] = cuboid[2]\n        for j in range(i):\n            if all((cuboids[j][k] <= cuboid[k] for k in range(3))):\n                dp[i] = max(dp[i], dp[j] + cuboid[2])\n        ans = max(ans, dp[i])\n    return ans"], [0.8819690346717834, "    volume_one_cuboid = length * breadth * height\n    combined_volume = volume_one_cuboid * number_of_cuboids\n    return combined_volume"], [0.8819513320922852, "    volume = side ** 2 * height / 3\n    return volume"], [0.8810411691665649, "        for j in range(i, num_of_cubes):\n            curr_area = i * j\n            max_area = max(max_area, curr_area)"], [0.8797812461853027, "    max_sum = -np.inf\n    for i in range(arr.shape[0]):\n        for j in range(arr.shape[1]):\n            for k in range(arr.shape[2]):\n                for x in range(i, arr.shape[0]):\n                    for y in range(j, arr.shape[1]):\n                        for z in range(k, arr.shape[2]):\n                            subarray = arr[i:x + 1, j:y + 1, k:z + 1]\n                            curr_sum = np.sum(subarray)\n                            max_sum = max(max_sum, curr_sum)\n    return max_sum"], [0.8795156478881836, "    for i in range(len(cuboids)):\n        dp[i] = cuboids[i][2]\n        for j in range(i):\n            if cuboids[i][0] <= cuboids[j][0] and cuboids[i][1] <= cuboids[j][1] and (cuboids[i][2] <= cuboids[j][2]):\n                dp[i] = max(dp[i], dp[j] + cuboids[i][2])"]]}
{"task_id": "MBPP/308", "problem": [[0.9219121932983398, "    if not isinstance(input_string, str):\n        raise TypeError('Input should be of string type.')\n    five_letter_substrings = re.findall('\\\\b[a-z]{5}\\\\b', input_string)\n    return five_letter_substrings"], [0.9179354310035706, "    words = sentence.split()\n    output_words = []\n    for word in words:\n        if len(word) == 5:\n            output_words.append(word)\n    return output_words"], [0.9155082702636719, "    words = text.split()\n    five_letter_words = [word for word in words if len(word) == 5]\n    unique_words = list(set(five_letter_words))\n    return unique_words"], [0.9154930114746094, "    words = text.split()\n    five_letter_words = [word for word in words if len(word) == 5]\n    unique_words = list(set(five_letter_words))\n    return unique_words"], [0.915280818939209, "    counter = 0\n    for word in sentence.split():\n        if len(word) == 5:\n            counter += 1\n    return counter"], [0.9134427309036255, "    new_words = []\n    for word in words:\n        if len(word) == 5:\n            new_words.append(word)\n    return new_words"], [0.9085899591445923, "    for word in sentence.split():\n        if len(word) == 5:\n            counter += 1"], [0.9084779620170593, "    for word in words:\n        if len(word) == 5:\n            new_words.append(word)"], [0.907443642616272, "    words = input_string.split()\n    result = [word for word in words if len(word) >= 5]\n    return result"], [0.9060120582580566, "        if len(word) == 5:\n            counter += 1"]]}
{"task_id": "MBPP/309", "problem": [[0.9374189376831055, "    sum_of_squares = sum((i ** 2 for i in range(1, n + 1)))\n    square_of_sum = sum(range(1, n + 1)) ** 2\n    return square_of_sum - sum_of_squares"], [0.9318081140518188, "    sum_of_squares = 0\n    square_of_sum = 0\n    for i in range(1, n + 1):\n        sum_of_squares += i * i\n    for i in range(1, n + 1):\n        square_of_sum += i\n    square_of_sum *= square_of_sum\n    return square_of_sum - sum_of_squares"], [0.9202255010604858, "    sum_squares = 0\n    for i in range(1, n + 1):\n        sum_squares += i ** 2\n    return sum_squares"], [0.9180890321731567, "    squares = [i * i for i in range(1, n + 1)]\n    return sum(squares)"], [0.9159029722213745, "    return sum([i ** 2 for i in range(n)])"], [0.9142385721206665, "    return sum([i ** 2 for i in range(1, n + 1)])"], [0.9142077565193176, "    return sum([i ** 2 for i in range(1, n + 1)])"], [0.9133290648460388, "    if not isinstance(n, int) or n < 1:\n        return 'Error: Input should be a natural number.'\n    sum_of_cubes = sum([i ** 3 for i in range(1, n + 1)])\n    sum_of_numbers = sum([i for i in range(1, n + 1)])\n    return sum_of_cubes - sum_of_numbers"], [0.9128888249397278, "    s = 0\n    for i in range(1, n + 1):\n        s += i ** 2\n    return s"], [0.9122418165206909, "    sum = 0\n    for i in range(1, n + 1):\n        sum += i ** 2\n    return sum"]]}
{"task_id": "MBPP/310", "problem": [[0.8743110299110413, "    binary_number = []\n    while decimal_number > 0:\n        binary_number.append(decimal_number % 2)\n        decimal_number = decimal_number // 2\n    binary_list = binary_number[::-1]\n    binary = int(''.join(map(str, binary_list)))\n    print(binary)"], [0.8731635808944702, "    if n in memo:\n        num = memo[n]\n        return (num, 'Even' if num % 10 % 2 == 0 else 'Odd')"], [0.8720459938049316, "    number_py = '{}'.format(number)\n    print('The Python equivalent of {} is {}'.format(number, number_py))"], [0.8717199563980103, "    if number == 0 or number == 1:\n        return number"], [0.8710536360740662, "    index = math.ceil((math.sqrt(8 * math.pow(10, n - 1) + 1) - 1) / 2)\n    triang_num = index * (index + 1) // 2\n    return (index, triang_num)"], [0.8705670833587646, "    elif 9 <= number < 20:\n        return number * 2\n    else:\n        return number / 2"], [0.8704663515090942, "    if num < 4:\n        return num\n    else:\n        return remainder(num - 4)"], [0.8704663515090942, "    if num < 4:\n        return num\n    else:\n        return remainder(num - 4)"], [0.8693276643753052, "    return findNthPolite(n)"], [0.8692986369132996, "    return number % 10"]]}
{"task_id": "MBPP/311", "problem": [[0.9151965975761414, "    smallest_value = min(valores)\n    indices = [index for index, value in enumerate(valores) if value == smallest_value]\n    return indices"], [0.9112508296966553, "    smallest_number = array[0]\n    smallest_indices = []\n    for i in range(len(array)):\n        if array[i] < smallest_number:\n            smallest_number = array[i]\n            smallest_indices = [i]\n        elif array[i] == smallest_number:\n            smallest_indices.append(i)\n    return smallest_indices"], [0.904434323310852, "    min_num = lst[0]\n    min_index = [0]\n    for i in range(1, len(lst)):\n        if lst[i] < min_num:\n            min_num = lst[i]\n            min_index = [i]\n        elif lst[i] == min_num:\n            min_index.append(i)\n    return (min_num, min_index)"], [0.9044251441955566, "    min_num = lst[0]\n    min_index = [0]\n    for i in range(1, len(lst)):\n        if lst[i] < min_num:\n            min_num = lst[i]\n            min_index = [i]\n        elif lst[i] == min_num:\n            min_index.append(i)\n    return (min_num, min_index)"], [0.901186466217041, "    minimum = min(list_of_nums)\n    return list_of_nums.index(minimum)"], [0.8967891335487366, "            if arr:\n                return arr.index(min(arr))\n            else:\n                return -1"], [0.8955212831497192, "    if len(arr) == 0:\n        return (None, [])\n    min_element = arr[0]\n    indices = [0]\n    for i in range(1, len(arr)):\n        if arr[i] < min_element:\n            min_element = arr[i]\n            indices = [i]\n        elif arr[i] == min_element:\n            indices.append(i)\n    return (min_element, indices)"], [0.8941119909286499, "    min_index = 0\n    for index, num in enumerate(lst):\n        if num < lst[min_index]:\n            min_index = index\n    return min_index"], [0.8939988613128662, "    for i in range(1, len(lst)):\n        if lst[i] < min_num:\n            min_num = lst[i]\n            min_index = [i]\n        elif lst[i] == min_num:\n            min_index.append(i)"], [0.8939705491065979, "    for i in range(1, len(lst)):\n        if lst[i] < min_num:\n            min_num = lst[i]\n            min_index = [i]\n        elif lst[i] == min_num:\n            min_index.append(i)"]]}
{"task_id": "MBPP/312", "problem": [[0.9162280559539795, "    positives = []\n    negatives = []\n    for x in arr:\n        if x < 0:\n            negatives.append(x)\n        else:\n            positives.append(x)\n    return positives + negatives"], [0.9143736362457275, "    negative_nums = []\n    positive_nums = []\n    for num in array:\n        if num < 0:\n            negative_nums.append(num)\n        else:\n            positive_nums.append(num)\n    return negative_nums + positive_nums"], [0.9102942943572998, "    negative_index = 0\n    for num in arr:\n        if num < 0:\n            temp = arr[negative_index]\n            arr[negative_index] = num\n            arr[arr.index(num)] = temp\n            negative_index += 1\n    return arr"], [0.9096435904502869, "    n = len(input_array)\n    positive_array = []\n    negative_array = []\n    for i in range(n):\n        if input_array[i] < 0:\n            negative_array.append(input_array[i])\n        else:\n            positive_array.append(input_array[i])\n    negative_array = sorted(negative_array)[::-1]\n    positive_array = sorted(positive_array)\n    output_array = []\n    for i in range(len(positive_array)):\n        output_array.append(negative_array[i])\n        output_array.append(positive_array[i])\n    return output_array"], [0.9089261293411255, "    arr.sort()\n    newArr = []\n    start = 0\n    end = len(arr) - 1\n    while start <= end:\n        if arr[start] < 0:\n            newArr.append(arr[start])\n            start += 1\n        else:\n            newArr.append(arr[end])\n            end -= 1\n    return newArr"], [0.9085788726806641, "    positive = []\n    negative = []\n    for num in arr:\n        if num >= 0:\n            positive.append(num)\n        else:\n            negative.append(num)\n    reordered_array = negative + positive\n    difference = sum(positive) - sum(list(map(abs, negative)))\n    return (reordered_array, difference)"], [0.9045096039772034, "    for num in arr:\n        if num < 0:\n            temp = arr[negative_index]\n            arr[negative_index] = num\n            arr[arr.index(num)] = temp\n            negative_index += 1"], [0.9042820930480957, "    negs_and_zeros = [x for x in arr if x <= 0]\n    positives = [x for x in arr if x > 0]\n    if not positives:\n        return 'Cannot reverse the order of the given integers'\n    pos_counter = len(positives) - 1\n    output_arr = []\n    for x in arr:\n        if x > 0:\n            output_arr.append(positives[pos_counter])\n            pos_counter -= 1\n        else:\n            output_arr.append(x)\n    return output_arr"], [0.9034132957458496, "    positive_list = []\n    negative_list = []\n    for num in numbers:\n        if num < 0:\n            negative_list.append(num)\n        else:\n            positive_list.append(num)\n    return positive_list + negative_list"], [0.9025518894195557, "    j = -1\n    for i in range(len(arr)):\n        if arr[i] < 0:\n            j += 1\n            arr[i], arr[j] = (arr[j], arr[i])\n    return arr"]]}
{"task_id": "MBPP/313", "problem": [[0.8961158394813538, "    odd_indices_elements = tpl[1::2]\n    even_elements = list(filter(lambda x: x % 2 == 0, odd_indices_elements))\n    return sum(even_elements)"], [0.8882273435592651, "    total = 0\n    for i in tuples:\n        if isinstance(i, tuple):\n            total += cumul_sum(i)\n        elif isinstance(i, (int, float)):\n            total += i\n        elif isinstance(i, complex):\n            total += i.real\n    return total"], [0.8852452039718628, "    total = 0\n    for t in tuples:\n        total += sum(t)\n    return total"], [0.8847355842590332, "    total_sum = 0\n    for lst in args:\n        if not isinstance(lst, list):\n            return 'Error: Input is not a list'\n        if len(lst) % 2 == 0:\n            return 'Error: List length is not odd'\n        for i in range(1, len(lst), 2):\n            total_sum += lst[i]\n    return total_sum"], [0.8847249746322632, "    if isinstance(tup, tuple):\n        return sum(tup)"], [0.8847112655639648, "    if isinstance(tup, tuple):\n        return sum(tup)\n    return tup"], [0.8841356039047241, "    for i in tuples:\n        if isinstance(i, tuple):\n            total += cumul_sum(i)\n        elif isinstance(i, (int, float)):\n            total += i\n        elif isinstance(i, complex):\n            total += i.real"], [0.8837227821350098, "    total = 0\n    for item in tuples:\n        if isinstance(item, tuple):\n            total += cumulative_sum(item)\n        elif isinstance(item, (int, float)):\n            total += item\n    return total"], [0.8837196230888367, "    total = 0\n    for item in tuples:\n        if isinstance(item, tuple):\n            total += cumulative_sum(item)\n        elif isinstance(item, (int, float)):\n            total += item\n    return total"], [0.8809247016906738, "    uniques = set()\n    for pair in lst:\n        uniques.update(pair)\n    total_sum = sum(uniques)\n    return total_sum"]]}
{"task_id": "MBPP/314", "problem": [[0.8979538679122925, "    import math\n    if n <= 0:\n        return 0\n    x = int(math.sqrt(n))\n    return 0 if x * x < n else x"], [0.8979423642158508, "    import math\n    if n <= 0:\n        return 0\n    x = int(math.sqrt(n))\n    return 0 if x * x < n else x"], [0.8968091607093811, "    low = 0\n    high = number\n    while low <= high:\n        mid = low + (high - low) // 2\n        mid_square = mid ** 2\n        if mid_square == number:\n            return mid\n        elif mid_square < number:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return low"], [0.8953293561935425, "    left, right = (0, x)\n    while left <= right:\n        mid = (left + right) // 2\n        square = mid * mid\n        if square <= x:\n            left = mid + 1\n        elif square > x:\n            right = mid - 1\n    return left - 1"], [0.894295334815979, "    root = math.sqrt(N)\n    if int(root + 0.5) ** 2 == N:\n        return int(root)\n    else:\n        return 'Error: The provided number is not a perfect square'"], [0.8931659460067749, "        elif square > n:\n            high = mid\n        else:\n            low = mid"], [0.8926758766174316, "    low = 0\n    high = number\n    while low <= high:\n        mid = int((low + high) / 2)\n        guess = mid * mid\n        if guess > number:\n            high = mid - 1\n        elif guess < number:\n            low = mid + 1\n        else:\n            return mid\n    return 'Square root of the number is not an integer.'"], [0.8922221660614014, "    left = 0\n    right = number\n    epsilon = 1e-05\n    while right - left > epsilon:\n        mid = (left + right) / 2\n        if mid * mid < number:\n            left = mid\n        else:\n            right = mid\n    return left"], [0.8921483159065247, "    squares = []\n    for i in range(int(math.sqrt(target))):\n        squares.append(i * i)\n    return squares"], [0.8919885158538818, "    low = 0\n    high = number\n    while low <= high:\n        mid = (low + high) // 2\n        mid_squared = mid * mid\n        if mid_squared == number:\n            return mid\n        elif mid_squared < number:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False"]]}
{"task_id": "MBPP/315", "problem": [[0.9399528503417969, "    counts = {}\n    max_count = 0\n    most_common = ''\n    for string in strings:\n        if string in counts:\n            counts[string] += 1\n        else:\n            counts[string] = 1\n        if counts[string] > max_count:\n            max_count = counts[string]\n            most_common = string\n    return most_common"], [0.9344704151153564, "    str_freq_map = defaultdict(int)\n    for string in strings:\n        str_freq_map[string] += 1\n    max_count = 0\n    for key, value in str_freq_map.items():\n        if value > max_count:\n            max_count = value\n    max_strings = []\n    for key, value in str_freq_map.items():\n        if value == max_count:\n            max_strings.append(key)\n    return max_strings"], [0.9338503479957581, "    frequency = {}\n    for string in strings:\n        string = string.strip().lower()\n        frequency[string] = frequency.get(string, 0) + 1\n    max_frequency = max(frequency.values())\n    most_frequent = [string for string, freq in frequency.items() if freq == max_frequency]\n    return most_frequent"], [0.929656982421875, "    string_list = string.split()\n    word_dict = {}\n    for word in string_list:\n        word_dict[word] = word_dict.get(word, 0) + 1\n    max_count = 0\n    most_common_word = None\n    for word, count in word_dict.items():\n        if count > max_count:\n            max_count = count\n            most_common_word = word\n    return most_common_word"], [0.9296181797981262, "    count_map = {}\n    for word in word_list:\n        if word in count_map:\n            count_map[word] += 1\n        else:\n            count_map[word] = 1\n    most_common = None\n    max_count = 0\n    for word, count in count_map.items():\n        if count > max_count:\n            most_common = word\n            max_count = count\n    return most_common"], [0.9288218021392822, "    occur_dict = {}\n    for word in array:\n        if word in occur_dict:\n            occur_dict[word] += 1\n        else:\n            occur_dict[word] = 1\n    most_frequent = max(occur_dict, key=lambda key: occur_dict[key])\n    return most_frequent"], [0.928709864616394, "    char_count = {}\n    max_char = ''\n    max_count = 0\n    for string in strings:\n        for char in string:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n            if char_count[char] > max_count:\n                max_count = char_count[char]\n                max_char = char\n    return max_char"], [0.9281851053237915, "    frequency_counter = Counter(strings)\n    max_frequency = max(frequency_counter.values())\n    most_frequent_strings = [string for string, frequency in frequency_counter.items() if frequency == max_frequency]\n    return most_frequent_strings"], [0.9281601309776306, "    max_count = 0\n    frequent_string = ''\n    for i in my_list:\n        if my_list.count(i) > max_count:\n            max_count = my_list.count(i)\n            frequent_string = i\n    return frequent_string"], [0.9279617667198181, "    word_count = {}\n    for word in words:\n        if word in word_count:\n            word_count[word] += 1\n        else:\n            word_count[word] = 1\n    most_common_word = ''\n    most_common_word_count = 0\n    for word, count in word_count.items():\n        if count > most_common_word_count:\n            most_common_word_count = count\n            most_common_word = word\n    return most_common_word"]]}
{"task_id": "MBPP/316", "problem": [[0.9217894077301025, "    if side1 == side2 or side1 == side3 or side2 == side3:\n        print('Isosceles triangle')\n        return"], [0.9141618013381958, "        elif a == b or b == c or c == a:\n            triangle_type = 'Isosceles'\n        else:\n            triangle_type = 'Scalene'"], [0.9136861562728882, "    if side1 == side2 or side2 == side3 or side1 == side3:\n        print('Isosceles triangle')\n        perimeter = side1 + side2 + side3\n        print('Perimeter:', perimeter)\n        return"], [0.9128994941711426, "    if a == b == c:\n        triangle_type = 'Equilateral'\n    elif a != b and b != c and (a != c):\n        triangle_type = 'Scalene'\n    else:\n        triangle_type = 'Isosceles'"], [0.9116708636283875, "    elif a == b or b == c or a == c:\n        return 'Isosceles triangle'\n    else:\n        return 'Scalene triangle'"], [0.9113380908966064, "    elif a != b and b != c and (a != c):\n        triangle_type = 'Scalene'\n    else:\n        triangle_type = 'Isosceles'"], [0.9113006591796875, "        elif a != b != c != a:\n            return 'Scalene triangle'\n        else:\n            return 'Isosceles triangle'"], [0.9096251130104065, "    elif A == B or B == C or A == C:\n        return 'Isosceles Triangle'\n    else:\n        return 'Scalene Triangle'"], [0.9094160199165344, "    elif x == y or y == z or x == z:\n        return 'Isosceles Triangle'\n    else:\n        return 'Scalene Triangle'"], [0.9066342115402222, "    elif side1 == side2 or side2 == side3 or side1 == side3:\n        triangle_type = 'isosceles'\n    else:\n        triangle_type = 'scalene'"]]}
{"task_id": "MBPP/317", "problem": [[0.9152937531471252, "    d = deque(l)\n    d.rotate(n)\n    return list(d)"], [0.9145890474319458, "    d = deque(l)\n    d.rotate(-n)\n    return list(d)"], [0.9047300815582275, "    rotated_list = my_list[n:] + my_list[:n]\n    return rotated_list"]]}
{"task_id": "MBPP/318", "problem": [[0.907742977142334, "    negative_nums = [num for num in numbers if num < 0]\n    return (len(negative_nums), sum(negative_nums))"], [0.9048395156860352, "    negative_elements = []\n    for x in my_list:\n        if x < 0:\n            negative_elements.append(x)\n    return negative_elements"], [0.9048157930374146, "    neg_lst = []\n    for num in lst:\n        if num < 0:\n            neg_lst.append(num)\n    return neg_lst"], [0.9015836715698242, "    return [num for num in int_list if num < 0]"], [0.900581955909729, "    for number in list_of_numbers:\n        total += int(number)\n        if number < 0:\n            negative_count += 1"], [0.9005563259124756, "    for x in my_list:\n        if x < 0:\n            negative_elements.append(x)"], [0.8995165824890137, "    counter = 0\n    for row in arr:\n        for val in row:\n            if val < 0:\n                counter += 1\n    return counter"], [0.8964903354644775, "    input_list = [1, -2, 3, -4, 5]\n    expected_output = [-2, -4]\n    assert negative(input_list) == expected_output"], [0.8961271047592163, "    count = 0\n    for num in nums:\n        if num > 0:\n            count += 1\n    print('Number of positive numbers:', count)"], [0.8948377370834351, "    count = 0\n    for num in list:\n        if num == 0:\n            count += 1\n    return count"]]}
{"task_id": "MBPP/319", "problem": [[0.9069947600364685, "    three_letter_words = []\n    for word in words:\n        if len(word) == 3:\n            three_letter_words.append(word)\n    return three_letter_words"], [0.9043104648590088, "    count = 0\n    for word in words:\n        if len(word) == 3:\n            count += 1\n    print(count)"], [0.9024871587753296, "    words = sentence.split()\n    four_char_words = [word for word in words if len(word) == 4]\n    return four_char_words"], [0.8995828032493591, "    if not isinstance(input_string, str):\n        raise TypeError('Input should be of string type.')\n    five_letter_substrings = re.findall('\\\\b[a-z]{5}\\\\b', input_string)\n    return five_letter_substrings"], [0.8994929790496826, "    for word in list_of_words:\n        if len(word) == 3:\n            return word"], [0.8991397619247437, "    for word in words:\n        if len(word) == 3:\n            count += 1"], [0.8991326093673706, "    for word in words:\n        if len(word) == 3:\n            count += 1"], [0.898695707321167, "    words = s.split()\n    four_letter_words = []\n    for word in words:\n        if len(word) == 4:\n            four_letter_words.append(word)\n    return four_letter_words"], [0.8981306552886963, "    words = sentence.split(' ')\n    count = 0\n    for word in words:\n        if len(word) == 3:\n            count += 1\n    return count"], [0.8979859352111816, "    words = text.split(' ')\n    result = []\n    for w in words:\n        if len(w) == 3:\n            result.append(w)\n    return result"]]}
{"task_id": "MBPP/320", "problem": [[0.9142201542854309, "    binary = bin(num)[2:]\n    count = 0\n    for bit in reversed(binary):\n        if bit == '0':\n            count += 1\n        else:\n            break\n    return count"], [0.913561224937439, "    return bin(n).count('1')"], [0.9083808064460754, "    count = 0\n    while number > 0:\n        if number & 1:\n            count += 1\n        number >>= 1\n    return count"], [0.9079480767250061, "    count = 0\n    while n != 0:\n        count += n & 1\n        n >>= 1\n    return count"], [0.9070040583610535, "    count = 0\n    while n > 0:\n        if n & 1:\n            count += 1\n        n >>= 1\n    return count"], [0.9058170318603516, "    count = 0\n    while x != 0:\n        x &= x - 1\n        count += 1\n    return count"], [0.9056382179260254, "    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"], [0.9056257009506226, "    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"], [0.9056229591369629, "    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"], [0.9055025577545166, "    count = 0\n    while n:\n        count ^= n & 1\n        n >>= 1\n    return count"]]}
{"task_id": "MBPP/321", "problem": [[0.939676821231842, "    frequency = {}\n    for character in string:\n        if character in frequency.keys():\n            frequency[character] += 1\n        else:\n            frequency[character] = 1\n    return frequency"], [0.9390703439712524, "    frequency = {}\n    for character in string:\n        if character in frequency:\n            frequency[character] += 1\n        else:\n            frequency[character] = 1\n    return frequency"], [0.9358752965927124, "    frequency = {}\n    for char in string:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency"], [0.9358750581741333, "    frequency = {}\n    for char in string:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency"], [0.935870885848999, "    frequency = {}\n    for char in string:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency"], [0.935869574546814, "    frequency = {}\n    for char in string:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency"], [0.9339723587036133, "    charCount = {}\n    for character in string:\n        if character in charCount.keys():\n            charCount[character] += 1\n        else:\n            charCount[character] = 1\n    print(charCount)"], [0.9338772296905518, "    character_count = {}\n    for char in string:\n        if char in character_count:\n            character_count[char] += 1\n        else:\n            character_count[char] = 1\n    return character_count"], [0.9338714480400085, "    count = {}\n    for char in string:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n    return count"], [0.9338630437850952, "    character_count = {}\n    for char in string:\n        if char in character_count:\n            character_count[char] += 1\n        else:\n            character_count[char] = 1\n    return character_count"]]}
{"task_id": "MBPP/322", "problem": [[0.9096310138702393, "    sorted_list = []\n    for sub_list in three_d_list:\n        sorted_sub_list = sorted(sub_list, key=itemgetter(2))\n        sorted_list.append(sorted_sub_list)\n    return sorted_list"], [0.9068228006362915, "    for sublist in arr:\n        sublist.sort(key=criterion)"], [0.9060438275337219, "    for sub_list in three_d_list:\n        sorted_sub_list = sorted(sub_list, key=itemgetter(2))\n        sorted_list.append(sorted_sub_list)"], [0.9058963656425476, "    for sublist in lists:\n        sublist.sort()"], [0.9055600166320801, "    for sublist in lists:\n        sublist.sort()\n    lists.sort(key=lambda x: x[0])\n    return lists"], [0.901868462562561, "    for i in range(len(sublist)):\n        for j in range(i + 1, len(sublist)):\n            if sublist[i] < sublist[j]:\n                sublist[i], sublist[j] = (sublist[j], sublist[i])"], [0.8998138904571533, "    for sublist in arr:\n        bubble_sort(sublist)\n    arr.sort(key=lambda x: x[0])"], [0.8994925618171692, "    myList.sort(key=lambda x: x[1])\n    print('The sorted list in ascending order is:')\n    for i in range(len(myList)):\n        print(myList[i])"], [0.8987829089164734, "            if sublist[i] < sublist[j]:\n                sublist[i], sublist[j] = (sublist[j], sublist[i])"], [0.8976512551307678, "    for i in range(len(sublist) - 1):\n        for j in range(len(sublist) - 1 - i):\n            if sublist[j] < sublist[j + 1]:\n                sublist[j], sublist[j + 1] = (sublist[j + 1], sublist[j])"]]}
{"task_id": "MBPP/323", "problem": [[0.9082813858985901, "    if a + b <= c or a + c <= b or b + c <= a:\n        return 'Not a valid triangle'\n    if a == b and b == c:\n        return 'Equilateral triangle'\n    if a != b and b != c and (a != c):\n        return 'Scalene triangle'\n    return 'Isosceles triangle'"], [0.907282829284668, "    if a + b <= c or a + c <= b or b + c <= a:\n        return 'Not a valid triangle'"], [0.9072633981704712, "    if a + b <= c or a + c <= b or b + c <= a:\n        return 'Not a valid triangle'"], [0.9072525501251221, "    if a + b <= c or a + c <= b or b + c <= a:\n        return 'Not a valid triangle'"], [0.9072473645210266, "    if a + b <= c or a + c <= b or b + c <= a:\n        return 'Not a valid triangle'"], [0.9065604209899902, "    if side1 + side2 > side3 and side1 + side3 > side2 and (side2 + side3 > side1):\n        return True\n    else:\n        return False"], [0.9065604209899902, "    if side1 + side2 > side3 and side1 + side3 > side2 and (side2 + side3 > side1):\n        return True\n    else:\n        return False"], [0.9062168598175049, "    if side1 + side2 <= side3 or side1 + side3 <= side2 or side2 + side3 <= side1:\n        return 'Invalid triangle. The given sides do not satisfy the triangle inequality theorem.'"], [0.905632734298706, "    if a + b <= c or a + c <= b or b + c <= a:\n        return 'Invalid triangle: sum of any two sides must be greater than the third side'"], [0.9047684669494629, "    a = side1 + side2\n    b = side1 + side3\n    c = side2 + side3\n    if a > side3 and b > side2 and (c > side1):\n        return True\n    else:\n        return False"]]}
{"task_id": "MBPP/324", "problem": [[0.887149453163147, "    first_term = sum / (ratio ** terms - 1)\n    progression = [first_term * ratio ** n for n in range(terms)]\n    return progression"], [0.8870410919189453, "    sum = a * (1 - r ** n) / (1 - r)\n    if 300 <= sum <= 1200:\n        print(f'The sum of the geometric progression is: {sum}.')\n        print('Terms of the geometric progression:')\n        for i in range(n):\n            term = a * r ** i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of the geometric progression is not within the valid range, but {sum}.')"], [0.8860856294631958, "    sum = a * (1 - r ** n) / (1 - r)\n    if 300 <= sum <= 1200:\n        print(f'Sum of geometric progression: {sum}.')\n        print('Terms of geometric progression:')\n        for i in range(n):\n            term = a * r ** i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of geometric progression is not within valid range, but {sum}.')"], [0.8798912763595581, "    sum = n * (n + 1) / 2\n    return sum"], [0.8795408606529236, "    if 300 <= sum <= 1200:\n        print(f'Sum of geometric progression: {sum}.')\n        print('Terms of geometric progression:')\n        for i in range(n):\n            term = a * r ** i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of geometric progression is not within valid range, but {sum}.')"], [0.8792863488197327, "    sum = n * (n + 1) // 2\n    return sum"], [0.8792717456817627, "    sum = n * (n + 1) // 2\n    return sum"], [0.8790835738182068, "    if 300 <= sum <= 1200:\n        print(f'The sum of the geometric progression is: {sum}.')\n        print('Terms of the geometric progression:')\n        for i in range(n):\n            term = a * r ** i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of the geometric progression is not within the valid range, but {sum}.')"]]}
{"task_id": "MBPP/325", "problem": [[0.9054312109947205, "        elif day > 28:\n            return 'No'"], [0.901270866394043, "    elif month == 'April' or month == 'June' or month == 'September' or (month == 'November'):\n        return '30 days'\n    elif month == 'February':\n        return '28 or 29 days'\n    else:\n        return 'Invalid input'"], [0.900823712348938, "    elif month == 'February':\n        return '28 or 29 days'\n    else:\n        return 'Invalid input'"], [0.8989176750183105, "    if month < 1 or month > 12:\n        return 'No'"], [0.8982325792312622, "    if month == 'January' or month == 'March' or month == 'May' or (month == 'July') or (month == 'August') or (month == 'October') or (month == 'December'):\n        return '31 days'\n    elif month == 'April' or month == 'June' or month == 'September' or (month == 'November'):\n        return '30 days'\n    elif month == 'February':\n        return '28 or 29 days'\n    else:\n        return 'Invalid input'"], [0.8982325792312622, "    if month == 'January' or month == 'March' or month == 'May' or (month == 'July') or (month == 'August') or (month == 'October') or (month == 'December'):\n        return '31 days'\n    elif month == 'April' or month == 'June' or month == 'September' or (month == 'November'):\n        return '30 days'\n    elif month == 'February':\n        return '28 or 29 days'\n    else:\n        return 'Invalid input'"], [0.8966712951660156, "    thirty_days_months = [4, 6, 9, 11]\n    if month in thirty_days_months:\n        return True\n    elif month == 2:\n        if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            return False\n        else:\n            return True\n    else:\n        return False"], [0.8950591087341309, "    if month in thirty_days_months:\n        return True\n    elif month == 2:\n        if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            return False\n        else:\n            return True\n    else:\n        return False"], [0.8950203657150269, "    elif month_name == 'february':\n        print('Valid month name')\n    elif month_name == 'march':\n        print('Valid month name')\n    elif month_name == 'april':\n        print('Valid month name')\n    elif month_name == 'may':\n        print('Valid month name')\n    elif month_name == 'june':\n        print('Valid month name')\n    elif month_name == 'july':\n        print('Valid month name')\n    elif month_name == 'august':\n        print('Valid month name')\n    elif month_name == 'september':\n        print('Valid month name')\n    elif month_name == 'october':\n        print('Valid month name')\n    elif month_name == 'november':\n        print('Valid month name')\n    elif month_name == 'december':\n        print('Valid month name')\n    elif month_name == 'ramadan':\n        print('Valid month name')\n    elif month_name == 'tishrei':\n        print('Valid month name')\n    else:\n        print('Invalid month name')"], [0.8948881030082703, "    elif month_name == 'december':\n        print('Valid month name')\n    elif month_name == 'ramadan':\n        print('Valid month name')\n    elif month_name == 'tishrei':\n        print('Valid month name')\n    else:\n        print('Invalid month name')"]]}
{"task_id": "MBPP/326", "problem": [[0.8962345719337463, "    return word.endswith(letter)"], [0.8931328058242798, "    for char in string.punctuation:\n        if word.endswith(char):\n            word = word[:-1]\n            punct_end = char"], [0.8907458782196045, "    if s.endswith('. ' + word[::-1]):\n        s = s[:len(s) - (len(word) + 2)] + '. ' + word[0].upper() + word[1:len(word)][::-1]"], [0.890393853187561, "        if word.endswith(char):\n            word = word[:-1]\n            punct_end = char"], [0.8857123255729675, "    words = sentence.split()\n    last_word = words[-1]\n    return last_word"], [0.8855892419815063, "    text = text.replace(' ', '')\n    lexical_units = re.findall('\\\\w+|[^\\\\w\\\\s]', text)\n    last_three_units = lexical_units[-3:]\n    end_pattern = ''.join(last_three_units)\n    return end_pattern"], [0.8846853971481323, "            if specific_endings.fullmatch(word):\n                specific_end.append(word)"], [0.8834476470947266, "        if not word[-1].isalpha():\n            punc = word[-1]\n            word = word[:-1]"], [0.8834319710731506, "        if word[-1] in '!.?,;:':\n            punctuation = word[-1]\n            word = word[:-1]"], [0.8829079270362854, "    words = sentence.split()\n    return words[-1]"]]}
{"task_id": "MBPP/327", "problem": [[0.9106730222702026, "            if substr[0] == substr[-1]:\n                count += 1"], [0.9092268943786621, "    count = 0\n    for s in lst:\n        if len(s) >= 2 and s[0] == s[-1]:\n            count += 1\n    return count"], [0.9068357348442078, "    for s in lst:\n        if len(s) >= 2 and s[0] == s[-1]:\n            count += 1"], [0.9063618183135986, "    count = 0\n    for i in range(len(input_str)):\n        for j in range(i + 1, len(input_str) + 1):\n            substr = input_str[i:j]\n            if substr[0] == substr[-1]:\n                count += 1\n    return count"], [0.9037280678749084, "    for i in range(len(input_str)):\n        for j in range(i + 1, len(input_str) + 1):\n            substr = input_str[i:j]\n            if substr[0] == substr[-1]:\n                count += 1"]]}
{"task_id": "MBPP/328", "problem": [[0.891208827495575, "    max_num = arr[0]\n    n = len(arr)\n    for i in range(1, n):\n        if arr[i] > max_num:\n            max_num = arr[i]\n    div_num = 1\n    for i in range(2, max_num + 1):\n        div_flag = True\n        for j in range(n):\n            if arr[j] % i != 0:\n                div_flag = False\n        if div_flag:\n            div_num = i\n    return div_num"], [0.8903428316116333, "    n = len(nums)\n    if n < 2:\n        return nums[0]\n    max_div = 0\n    for i in range(n - 1):\n        num = nums[i]\n        for j in range(i + 1, n):\n            if num % nums[j] == 0 and nums[j] > max_div:\n                max_div = nums[j]\n                break\n    return max_div"]]}
{"task_id": "MBPP/329", "problem": [[0.911083459854126, "    if len(arr) < 3:\n        return sum(arr)\n    smallest_nums = [float('inf')] * 3\n    for num in arr:\n        if num < smallest_nums[2]:\n            smallest_nums = sorted(smallest_nums[:-1] + [num])\n    return sum(smallest_nums)"], [0.9083112478256226, "    numbers.sort(reverse=True)\n    return sum(numbers[:3])"], [0.9019894599914551, "    unique_numbers = set()\n    counts = {}\n    for num in lst:\n        if num not in unique_numbers:\n            unique_numbers.add(num)\n            counts[num] = 1\n        else:\n            counts[num] += 1\n    sum = 0\n    count = 0\n    for num in lst:\n        if num in unique_numbers and counts[num] > 0:\n            sum += num\n            counts[num] -= 1\n            count += 1\n            if count == 3:\n                break\n    return sum"], [0.9010679721832275, "        if sum(three_smallest) < min_sum:\n            min_sum = sum(three_smallest)\n            min_elements = three_smallest\n            min_list = lst"], [0.9007588028907776, "    for lst in lsts:\n        three_smallest = find_three_smallest(lst)\n        if sum(three_smallest) < min_sum:\n            min_sum = sum(three_smallest)\n            min_elements = three_smallest\n            min_list = lst"], [0.8999713063240051, "    sequence.sort(reverse=True)\n    sum_of_largest = sum(sequence[:3])\n    return sum_of_largest"], [0.8987894058227539, "    numbers = [num for num in numbers if num >= 0]\n    numbers.sort(reverse=True)\n    largest_sum = 0\n    largest_numbers = []\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            for k in range(j + 1, len(numbers)):\n                current_sum = numbers[i] + numbers[j] + numbers[k]\n                if current_sum > largest_sum:\n                    largest_sum = current_sum\n                    largest_numbers = [numbers[i], numbers[j], numbers[k]]\n    return largest_numbers"], [0.8985854387283325, "    prime_numbers = []\n    for num in lst:\n        if is_prime(num):\n            prime_numbers.append(num)\n            if len(prime_numbers) == 3:\n                break\n    return sum(prime_numbers)"], [0.8984644412994385, "    lowest_sum = numbers[0] + numbers[1]\n    for i in range(len(numbers) - 1):\n        for j in range(i + 1, len(numbers)):\n            current_sum = numbers[i] + numbers[j]\n            if current_sum < lowest_sum:\n                lowest_sum = current_sum\n    return lowest_sum"], [0.8959980607032776, "    min_list = []\n    min_values = [float('inf')] * 3\n    for n1, n2, n3 in zip(numbers1, numbers2, numbers3):\n        min_values[0] = min(min_values[0], n1)\n        min_values[1] = min(min_values[1], n2)\n        min_values[2] = min(min_values[2], n3)\n        min_list.append(min(min_values))\n    return min_list"]]}
{"task_id": "MBPP/330", "problem": [[0.8885668516159058, "    tuple_order = sorted(tuples, key=lambda x: x[1])\n    return tuple_order"]]}
{"task_id": "MBPP/331", "problem": [[0.9049253463745117, "    sets = [set(arr) for arr in arrays]\n    common_elements = set.intersection(*sets)\n    return sorted(common_elements)"], [0.9025726914405823, "    if not arrays:\n        return []\n    intersection = set(arrays[0])\n    for arr in arrays[1:]:\n        intersection = intersection.intersection(set(arr))\n    return list(intersection)"], [0.899342954158783, "    arr3 = arr1 + arr2\n    arr4 = []\n    for i in range(min(arr3), max(arr3) + 1):\n        if i in arr3:\n            arr4.append(i)\n    return arr4"], [0.897758960723877, "    common_elements = set(list_of_arrays[0])\n    for array in list_of_arrays:\n        common_elements.intersection_update(array)\n    return list(common_elements)"], [0.8976299166679382, "    for arr in arrays[1:]:\n        intersection = intersection.intersection(set(arr))"], [0.896993100643158, "    common_elements = set(list1).intersection(list2)\n    return [element for element in common_elements if range_values[0] <= element <= range_values[1]]"], [0.8967557549476624, "    result = set()\n    for array in arrays:\n        result = result.symmetric_difference(set(array))\n    return list(result)"], [0.8964403867721558, "    result = []\n    i, j = (0, 0)\n    while i < len(firstList) and j < len(secondList):\n        start = max(firstList[i][0], secondList[j][0])\n        end = min(firstList[i][1], secondList[j][1])\n        if start <= end:\n            result.append([start, end])\n        if firstList[i][1] < secondList[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result"], [0.8959094882011414, "    return [min(array) for array in arrays]"], [0.8948372006416321, "    for array in list_of_arrays:\n        common_elements.intersection_update(array)"]]}
{"task_id": "MBPP/332", "problem": [[0.9129759073257446, "    uppercase = 0\n    digits = 0\n    for character in string:\n        if character.isupper():\n            uppercase += 1\n        elif character.isdigit():\n            digits += 1\n    results = {'Uppercase': uppercase, 'Digits': digits}\n    return results"], [0.906787097454071, "    for character in string:\n        if character.isupper():\n            uppercase += 1\n        elif character.isdigit():\n            digits += 1"], [0.9027115106582642, "    digit = 0\n    letters = 0\n    space = 0\n    other = 0\n    for i in x:\n        if i.isalpha():\n            letters += 1\n        elif i.isdigit():\n            digit += 1\n        elif i.isspace():\n            space += 1\n        else:\n            other += 1\n    return (digit, letters, space, other)"], [0.9010061025619507, "    upper_case = 0\n    digits = 0\n    special_characters = 0\n    for character in string:\n        if character.isupper():\n            upper_case += 1\n        elif character.isdigit():\n            digits += 1\n        elif character.isalpha() or character.isspace():\n            continue\n        else:\n            special_characters += 1\n    return (upper_case, digits, special_characters)"], [0.900554895401001, "    num_letter = 0\n    num_digit = 0\n    num_other = 0\n    for c in s:\n        if c.isalpha():\n            num_letter += 1\n        elif c.isdigit():\n            num_digit += 1\n        else:\n            num_other += 1\n    return (num_letter, num_digit, num_other)"], [0.8990458846092224, "    count = 0\n    for c in string:\n        if c.isalpha():\n            count += 1\n    return count"], [0.8977795839309692, "    for i in x:\n        if i.isalpha():\n            letters += 1\n        elif i.isdigit():\n            digit += 1\n        elif i.isspace():\n            space += 1\n        else:\n            other += 1"], [0.8977285623550415, "        elif c.islower():\n            counts['lower'] += 1\n        elif c.isdigit():\n            counts['digits'] += 1\n        else:\n            counts['others'] += 1"], [0.8967324495315552, "    alphabetic_count = 0\n    numeric_count = 0\n    special_character_count = 0\n    for ch in s:\n        if ch.isalpha():\n            alphabetic_count += 1\n        elif ch.isdigit():\n            numeric_count += 1\n        elif ch.isspace() == False:\n            special_character_count += 1\n    return (alphabetic_count, numeric_count, special_character_count)"], [0.8960608243942261, "        if c.isalpha():\n            num_letter += 1\n        elif c.isdigit():\n            num_digit += 1\n        else:\n            num_other += 1"]]}
{"task_id": "MBPP/333", "problem": [[0.9063969850540161, "    if (end - start) % 2 == 0 and start % 2 == 0 and (end % 2 == 0):\n        print('Warning: The given range does not contain any odd numbers.')\n        return"], [0.90202796459198, "    odd_list = []\n    for i in range(x, y):\n        if i % 2 != 0:\n            odd_list.append(i)\n    return odd_list"], [0.897747278213501, "    for i in range(start, end + 1):\n        if i % 2 == 1:\n            count += 1\n            total += i"], [0.897638201713562, "    count = 0\n    for i in range(m, n + 1):\n        if i % 2 == 0:\n            count += 1\n    return count"], [0.8950865268707275, "    count = 0\n    for i in range(2, max, 2):\n        count += 1\n    return count"]]}
{"task_id": "MBPP/334", "problem": [[0.9281967282295227, "    unique_numbers = list(set(numbers))\n    unique_numbers.sort()\n    if len(unique_numbers) < 2:\n        print('Error - at least two unique numbers are required')\n        return\n    difference = unique_numbers[-2] - unique_numbers[1]\n    return difference"], [0.9281955361366272, "    unique_numbers = list(set(numbers))\n    unique_numbers.sort()\n    if len(unique_numbers) < 2:\n        print('Error - at least two unique numbers are required')\n        return\n    difference = unique_numbers[-2] - unique_numbers[1]\n    return difference"], [0.9163123965263367, "    for i in range(len(my_list)):\n        for j in range(i + 1, len(my_list)):\n            current_diff = my_list[j] - my_list[i]\n            if current_diff < min_diff:\n                min_diff = current_diff"], [0.9154350757598877, "    maxDifference = 0\n    for i in range(len(elementList)):\n        for j in range(i + 1, len(elementList)):\n            if elementList[j] - elementList[i] > maxDifference:\n                maxDifference = elementList[j] - elementList[i]\n    return maxDifference"], [0.9103949069976807, "    if len(lst) < 2:\n        return 'The list must contain at least two elements'\n    else:\n        return lst[0] - lst[1]"], [0.9103949069976807, "    if len(lst) < 2:\n        return 'The list must contain at least two elements'\n    else:\n        return lst[0] - lst[1]"], [0.9083720445632935, "    try:\n        differences = [array[i + 1] - array[i] for i in range(len(array) - 1)]\n        return differences\n    except (TypeError, IndexError):\n        return 'The list should contain only integers.'"], [0.9076511263847351, "    max_difference = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] - arr[i] > max_difference:\n                max_difference = arr[j] - arr[i]\n    return max_difference"], [0.9072052240371704, "    if not isinstance(array, list):\n        return 'Invalid data type, should be list.'\n    try:\n        differences = [array[i + 1] - array[i] for i in range(len(array) - 1)]\n        return differences\n    except (TypeError, IndexError):\n        return 'The list should contain only integers.'"], [0.9067050218582153, "        for j in range(i + 1, len(my_list)):\n            current_diff = my_list[j] - my_list[i]\n            if current_diff < min_diff:\n                min_diff = current_diff"]]}
{"task_id": "MBPP/335", "problem": [[0.9011739492416382, "    e = 0\n    for i in range(n):\n        e += 1 / math.factorial(i)\n    return e"], [0.9011700749397278, "    e = 0\n    for i in range(n):\n        e += 1 / math.factorial(i)\n    return e"], [0.9011697769165039, "    e = 0\n    for i in range(n):\n        e += 1 / math.factorial(i)\n    return e"], [0.8988808393478394, "    for i in range(n):\n        e += 1 / math.factorial(i)"], [0.8988775014877319, "    for i in range(n):\n        e += 1 / math.factorial(i)"], [0.898867666721344, "    for i in range(n):\n        e += 1 / math.factorial(i)"], [0.8897983431816101, "    E = 0\n    for d in range(day, 0, -1):\n        E = 1 + E * d / (d + 1)\n    return E"], [0.8897509574890137, "    if k > n:\n        return 0"], [0.8897470235824585, "    if k > n:\n        return 0"], [0.8888038396835327, "    e = 1\n    factorial = 1\n    term = 1\n    n = 1\n    while abs(term - e) > 0.0001:\n        term *= n\n        factorial *= n\n        e += term / factorial\n        n += 1\n    return round(e, 4)"]]}
{"task_id": "MBPP/336", "problem": [[0.9050391912460327, "    x1, y1, x2, y2 = map(int, rect.split())\n    return (x2 - x1) * (y2 - y1)"], [0.887770414352417, "    width = abs(x2 - x1)\n    height = abs(y2 - y1)\n    return width * height"], [0.8871716260910034, "    length = abs(x2 - x1)\n    width = abs(y2 - y1)\n    return length * width"], [0.8850581645965576, "    return [length * width for length, width in rectangle_pairs]"], [0.8850499391555786, "    return [length * width for length, width in rectangle_pairs]"], [0.8850207328796387, "    points = set()\n    for rectangle in coordinates:\n        for x in range(rectangle[0], rectangle[2]):\n            for y in range(rectangle[1], rectangle[3]):\n                points.add((x, y))\n    return len(points)"], [0.8846858739852905, "    if r > l and b > t:\n        return (r - l) * (b - t)\n    else:\n        return 0"], [0.8836591243743896, "    x1, y1 = rectangle[0]\n    x2, y2 = rectangle[1]\n    x3, y3 = rectangle[2]\n    x4, y4 = rectangle[3]\n    length = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    width = math.sqrt((x3 - x2) ** 2 + (y3 - y2) ** 2)\n    area = length * width\n    perimeter = 2 * (length + width)\n    return (area, perimeter)"], [0.8827654719352722, "    area_sum = 0\n    for rectangle in rectangles:\n        area_sum += rectangle['length'] * rectangle['width']\n    return area_sum"], [0.8809770345687866, "    squares = group.split()\n    total_area = sum((int(side) ** 2 for side in squares))\n    return total_area"]]}
{"task_id": "MBPP/337", "problem": [[0.8874465823173523, "            if vals[i - 1] <= j:\n                include = 1 + dp[i - 1][j - vals[i - 1]]\n                exclude = dp[i - 1][j]\n                if include < exclude:\n                    dp[i][j] = include\n                    count[i][j] = count[i - 1][j - vals[i - 1]]\n                elif include == exclude:\n                    dp[i][j] = include\n                    count[i][j] = count[i - 1][j] + count[i - 1][j - vals[i - 1]]\n                else:\n                    dp[i][j] = exclude\n                    count[i][j] = count[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n                count[i][j] = count[i - 1][j]"], [0.886070728302002, "    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if vals[i - 1] <= j:\n                include = 1 + dp[i - 1][j - vals[i - 1]]\n                exclude = dp[i - 1][j]\n                if include < exclude:\n                    dp[i][j] = include\n                    count[i][j] = count[i - 1][j - vals[i - 1]]\n                elif include == exclude:\n                    dp[i][j] = include\n                    count[i][j] = count[i - 1][j] + count[i - 1][j - vals[i - 1]]\n                else:\n                    dp[i][j] = exclude\n                    count[i][j] = count[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n                count[i][j] = count[i - 1][j]"], [0.8837681412696838, "        for j in range(1, target + 1):\n            if vals[i - 1] <= j:\n                include = 1 + dp[i - 1][j - vals[i - 1]]\n                exclude = dp[i - 1][j]\n                if include < exclude:\n                    dp[i][j] = include\n                    count[i][j] = count[i - 1][j - vals[i - 1]]\n                elif include == exclude:\n                    dp[i][j] = include\n                    count[i][j] = count[i - 1][j] + count[i - 1][j - vals[i - 1]]\n                else:\n                    dp[i][j] = exclude\n                    count[i][j] = count[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n                count[i][j] = count[i - 1][j]"]]}
{"task_id": "MBPP/338", "problem": [[0.9071922898292542, "    if set(binary_string) == {'0'} or set(binary_string) == {'1'}:\n        return True\n    else:\n        return False"], [0.9071922898292542, "    if set(binary_string) == {'0'} or set(binary_string) == {'1'}:\n        return True\n    else:\n        return False"], [0.9033008217811584, "    if not set(binary).issubset({'0', '1'}):\n        return 'Error: Input is not a valid binary number'"], [0.9033005237579346, "    if not set(binary).issubset({'0', '1'}):\n        return 'Error: Input is not a valid binary number'"], [0.902240514755249, "    for char in input_string:\n        if char not in '01':\n            return False\n    return True"], [0.9014414548873901, "    if not binary_string or not all((char in ('0', '1') for char in binary_string)):\n        return 'Invalid binary string'"], [0.8994331955909729, "    return all([digit in '01' for digit in binary])"], [0.8990226984024048, "    binary = str(binary)\n    if set(binary) == {'0', '1'} or set(binary) == {'0'} or set(binary) == {'1'}:\n        return int(binary, 2)\n    else:\n        return 'Error: Invalid binary number. A binary number consists only of 0s and 1s.'"], [0.8990123271942139, "    binary = str(binary)\n    if set(binary) == {'0', '1'} or set(binary) == {'0'} or set(binary) == {'1'}:\n        return int(binary, 2)\n    else:\n        return 'Error: Invalid binary number. A binary number consists only of 0s and 1s.'"], [0.8979071974754333, "    if set(binary) == {'0', '1'} or set(binary) == {'0'} or set(binary) == {'1'}:\n        return int(binary, 2)\n    else:\n        return 'Error: Invalid binary number. A binary number consists only of 0s and 1s.'"]]}
{"task_id": "MBPP/339", "problem": [[0.8992804288864136, "    char_counts = {}\n    for char in string:\n        if char in char_counts:\n            char_counts[char] += 1\n        else:\n            char_counts[char] = 1\n    max_occurrence = max(char_counts.values())\n    min_operations = len(string) - max_occurrence\n    return min_operations"], [0.8959312438964844, "    res = ''\n    for ch in string:\n        if string.count(ch) < 2:\n            res += ch\n    return res"], [0.8958011865615845, "    final_string = ''\n    last_char = ''\n    for char in string:\n        if char != last_char:\n            final_string += char\n            last_char = char\n    return final_string"], [0.8958011865615845, "    final_string = ''\n    last_char = ''\n    for char in string:\n        if char != last_char:\n            final_string += char\n            last_char = char\n    return final_string"], [0.893768846988678, "    s_new = ''\n    for letter in s:\n        if letter != char:\n            s_new += letter\n    return s_new"], [0.8933515548706055, "    result = ''\n    last_seen = None\n    for char in string:\n        if char != last_seen:\n            result += char\n            last_seen = char\n    return result"], [0.892844557762146, "    modified_string = string[0]\n    removed_dict = collections.defaultdict(int)\n    for i in range(1, len(string)):\n        if string[i] != string[i - 1]:\n            modified_string += string[i]\n        else:\n            removed_dict[string[i]] += 1\n    freq_map = collections.Counter(modified_string)\n    modified_string = ''.join([char for char, _ in freq_map.most_common()])\n    return (modified_string, removed_dict)"], [0.8920766711235046, "    lowercase_letters = [char for char in string if char.islower()]\n    result = ''\n    for char in string:\n        if char.islower() and lowercase_letters.count(char) > 1:\n            lowercase_letters.remove(char)\n            if lowercase_letters.count(char) > 1:\n                lowercase_letters.remove(char)\n                result += char\n        else:\n            result += char\n    return result"], [0.8919939994812012, "    longest_string = ''\n    temp_string = ''\n    for c in input_string:\n        if c == temp_string[-1:]:\n            temp_string += c\n        else:\n            if len(temp_string) > len(longest_string):\n                longest_string = temp_string\n            temp_string = c\n        if len(temp_string) > len(longest_string):\n            longest_string = temp_string\n    return input_string.replace(longest_string, '')"], [0.8917051553726196, "    result = ''\n    previous = None\n    for c in s:\n        if c != previous:\n            result += c\n        previous = c\n    return result"]]}
{"task_id": "MBPP/340", "problem": [[0.9171279072761536, "    if k > len(arr):\n        return 'k is greater than the number of unique elements'\n    else:\n        return arr[k - 1]"], [0.9147320985794067, "        if counter != k:\n            i += 1\n            counter += 1\n        else:\n            return arr1[i]"], [0.9107274413108826, "    while i < len(arr1):\n        if counter != k:\n            i += 1\n            counter += 1\n        else:\n            return arr1[i]"], [0.9091753959655762, "    while j < len(arr2):\n        if counter != k:\n            j += 1\n            counter += 1\n        else:\n            return arr2[j]"], [0.9082303047180176, "        if counter != k:\n            j += 1\n            counter += 1\n        else:\n            return arr2[j]"], [0.9055565595626831, "    max_value = max(arr)\n    primes = sieve_of_eratosthenes(max_value)\n    count = 0\n    for num in arr:\n        if num in primes:\n            count += 1\n            if count == k:\n                return num\n    return None"], [0.9054495096206665, "    freq = {}\n    for el in arr:\n        if el in freq:\n            freq[el] += 1\n        else:\n            freq[el] = 1\n    sorted_freq = sorted(freq.items(), key=lambda kv: kv[1], reverse=True)\n    return sorted_freq[k - 1][0]"], [0.9051671624183655, "    unique_elements = purge_and_sort(arr)\n    if len(unique_elements) < k:\n        return None\n    else:\n        return unique_elements[k - 1]"], [0.9039590358734131, "    sorted_arr = sorted(arr)\n    return sorted_arr[k - 1]"], [0.9031983017921448, "    frequencies = {}\n    for element in array:\n        if element not in frequencies:\n            frequencies[element] = 1\n        else:\n            frequencies[element] += 1\n    frequencies_list = list(frequencies.keys())\n    frequencies_list.sort(reverse=True, key=lambda x: frequencies[x])\n    return frequencies_list[k - 1]"]]}
{"task_id": "MBPP/341", "problem": [[0.9298058152198792, "    s = set()\n    for character in string:\n        if character in s:\n            return False\n        else:\n            s.add(character)\n    return True"], [0.9288877844810486, "    unique_chars = set()\n    for char in input_str:\n        if char in unique_chars:\n            return False\n        else:\n            unique_chars.add(char)\n    return True"], [0.9280253648757935, "    unique_set = set()\n    for char in string:\n        unique_set.add(char)\n        if len(unique_set) != len(string):\n            return False\n    return True"], [0.9274674654006958, "    characters = set()\n    for char in string:\n        if char in characters:\n            return False\n        characters.add(char)\n    return True"], [0.9272761940956116, "    unique_chars = set()\n    for char in string:\n        if char in unique_chars:\n            return False\n        unique_chars.add(char)\n    return True"], [0.9272613525390625, "    unique_chars = set()\n    for char in string:\n        if char in unique_chars:\n            return False\n        unique_chars.add(char)\n    return True"], [0.9267724752426147, "    chars = set()\n    for char in string:\n        if char in chars:\n            return False\n        else:\n            chars.add(char)\n    return True"], [0.9267706871032715, "    chars = set()\n    for char in string:\n        if char in chars:\n            return False\n        else:\n            chars.add(char)\n    return True"], [0.9267686605453491, "    chars = set()\n    for char in string:\n        if char in chars:\n            return False\n        else:\n            chars.add(char)\n    return True"], [0.9264460802078247, "    char_set = set()\n    for char in string:\n        if char in char_set:\n            return False\n        else:\n            char_set.add(char)\n    return True"]]}
{"task_id": "MBPP/342", "problem": [[0.8834726214408875, "    result = []\n    for i in nested_list:\n        if type(i) is list:\n            i = remove_element(i, target)\n            if i:\n                result.append(i)\n        elif i != target:\n            result.append(i)\n    return result"], [0.8823752403259277, "    return [i[:column] + i[column + 1:] for i in L]"], [0.8792706727981567, "    count = 0\n    new_list = []\n    for sublist in nested_list:\n        if isinstance(sublist, list):\n            count += remove_number(sublist, num)\n        elif sublist == num:\n            count += 1\n        else:\n            new_list.append(sublist)\n    nested_list.clear()\n    nested_list.extend(new_list)\n    return count"], [0.8785142302513123, "    result = []\n    for item in nested_list:\n        if isinstance(item, list):\n            new_list = remove_string(item, target)\n            if new_list:\n                result.append(new_list)\n        elif item != target:\n            result.append(item)\n    return result"], [0.8784527778625488, "                for r in range(len(matrix)):\n                    del matrix[r][col]"], [0.8767305612564087, "    for i in nested_list:\n        if type(i) is list:\n            i = remove_element(i, target)\n            if i:\n                result.append(i)\n        elif i != target:\n            result.append(i)"], [0.8755645751953125, "    col = 0\n    while col < len(matrix[0]):\n        for row in matrix:\n            if type(row[col]) is data_type:\n                for r in range(len(matrix)):\n                    del matrix[r][col]\n                break\n        col += 1\n    return matrix"], [0.8735175132751465, "    if not arr:\n        return arr\n    num_rows = len(arr)\n    num_cols = len(arr[0])\n    if index[0] < 0 or index[0] >= num_rows or index[1] < 0 or (index[1] >= num_cols):\n        return arr\n    del arr[index[0]][index[1]]\n    for row in arr:\n        if len(row) > num_cols:\n            row.pop()\n    for i in range(num_rows):\n        if len(arr[i]) > index[1]:\n            del arr[i][index[1]]\n    return arr"], [0.8726242184638977, "    for item in nested_list:\n        if isinstance(item, list):\n            new_list = remove_string(item, target)\n            if new_list:\n                result.append(new_list)\n        elif item != target:\n            result.append(item)"], [0.8722707629203796, "    del my_list[index]\n    return my_list"]]}
{"task_id": "MBPP/343", "problem": [[0.8867039680480957, "    return first_term + (n - 1) * common_difference"], [0.885954737663269, "        if arr[1] - arr[0] > 0:\n            return 'Array is sorted in ascending order and forms an arithmetic progression'\n        else:\n            return 'Array is sorted in descending order and forms an arithmetic progression'"], [0.8829948306083679, "    first_term = sum / (ratio ** terms - 1)\n    progression = [first_term * ratio ** n for n in range(terms)]\n    return progression"], [0.8825080394744873, "    if len(arr) < 2:\n        return 'The array should have at least two numbers for finding a sequence.'\n    else:\n        diff = arr[1] - arr[0]\n        for i in range(2, len(arr)):\n            if arr[i] - arr[i - 1] != diff:\n                return 'The given input does not form an arithmetic sequence.'\n        return 'The difference of the arithmetic sequence is: ' + str(diff)"], [0.8825080394744873, "    if len(arr) < 2:\n        return 'The array should have at least two numbers for finding a sequence.'\n    else:\n        diff = arr[1] - arr[0]\n        for i in range(2, len(arr)):\n            if arr[i] - arr[i - 1] != diff:\n                return 'The given input does not form an arithmetic sequence.'\n        return 'The difference of the arithmetic sequence is: ' + str(diff)"], [0.878061830997467, "    if is_arithmetic:\n        if arr[1] - arr[0] > 0:\n            return 'Array is sorted in ascending order and forms an arithmetic progression'\n        else:\n            return 'Array is sorted in descending order and forms an arithmetic progression'"], [0.8775228261947632, "    words = sentence.split()\n    if len(words) < 3:\n        return 'Not enough terms to determine the sequence type.'\n    diff = int(words[1]) - int(words[0])\n    is_arithmetic = True\n    for i in range(2, len(words)):\n        if int(words[i]) - int(words[i - 1]) != diff:\n            is_arithmetic = False\n            break\n    if is_arithmetic:\n        return 'The given sequence is an arithmetic sequence.'\n    return 'The given sequence does not match any known sequence type.'"], [0.8773363828659058, "    geometric_sequence = [first_term]\n    for _ in range(1, total_terms):\n        next_term = geometric_sequence[-1] * common_ratio\n        geometric_sequence.append(next_term)\n    return geometric_sequence"], [0.8773350119590759, "            if arr[i] - arr[i - 1] != diff:\n                return 'The given input does not form an arithmetic sequence.'"], [0.8773090839385986, "    geometric_sequence = [first_term]\n    for _ in range(1, total_terms):\n        next_term = geometric_sequence[-1] * common_ratio\n        geometric_sequence.append(next_term)\n    return geometric_sequence"]]}
{"task_id": "MBPP/344", "problem": [[0.8915395736694336, "    return math.pi * r ** 2"], [0.8907272219657898, "    if r < 0:\n        raise ValueError('Radius cannot be negative. Please provide a non-negative input.')\n    PI = 3.14159\n    return PI * r ** 2"], [0.8896843194961548, "    num_points = 2 * r + 1\n    return num_points ** 2"], [0.8889362215995789, "    return 3.14 * r * r"], [0.8884133696556091, "    PI = 3.1415\n    area = PI * r ** 2\n    return area"], [0.886036217212677, "    PI = 3.14159\n    return 2 * PI * r"], [0.885539174079895, "    for perimeter in range(4, limit + 1):\n        count += perimeter // 4 - 1"], [0.8853281736373901, "    integer_part = int(radius)\n    decimal_part = radius - integer_part\n    area_integer_part = 3.14159 * integer_part * integer_part\n    area_decimal_part = 3.14159 * decimal_part * decimal_part\n    return area_integer_part + area_decimal_part"], [0.8848083019256592, "    angle = 2 * math.pi / n\n    area = r ** 2 * math.sin(angle) / 2\n    return area"], [0.8846059441566467, "    if r < 1:\n        return 0"]]}
{"task_id": "MBPP/345", "problem": [[0.888831615447998, "    angle = math.acos((b ** 2 + c ** 2 - a ** 2) / (2 * b * c))\n    return math.degrees(angle)"], [0.8881014585494995, "    if side1 + side2 <= side3 or side2 + side3 <= side1 or side3 + side1 <= side2:\n        return 'Error: Invalid triangle'\n    numerator = side1 ** 2 + side2 ** 2 - side3 ** 2\n    denominator = 2 * side1 * side2\n    angle_rad = math.acos(numerator / denominator)\n    angle_deg = math.degrees(angle_rad)\n    return angle_deg"], [0.8776828050613403, "    if a + b <= angle_C or a + angle_C <= b or b + angle_C <= a:\n        return 'Error: Invalid triangle'\n    angle_C_rad = math.radians(angle_C)\n    area = 0.5 * a * b * math.sin(angle_C_rad)\n    return area"], [0.8773301839828491, "    if a + b <= angle_C or a + angle_C <= b or b + angle_C <= a:\n        return 'Error: Invalid triangle'"], [0.8763822913169861, "    x1, _, _ = point1\n    x2, _, _ = point2\n    distance = calculate_distance(point1, point2)\n    angle = math.acos((x2 - x1) / distance) * (180 / math.pi)\n    return round(angle, 2)"], [0.8757878541946411, "    if angle <= 0 or angle >= 180:\n        print('Invalid input. Please enter a valid angle')\n        return None\n    elif side1 <= 0 or side2 <= 0:\n        print('Invalid input. Please enter valid sides')\n        return None\n    elif side1 + side2 <= side1 or side1 + side2 <= side2 or side1 + side1 <= side2:\n        print('Invalid input. These sides do not form a valid triangle')\n        return None\n    else:\n        height = side2 * math.sin(math.radians(angle))\n        return height"], [0.8757878541946411, "    if angle <= 0 or angle >= 180:\n        print('Invalid input. Please enter a valid angle')\n        return None\n    elif side1 <= 0 or side2 <= 0:\n        print('Invalid input. Please enter valid sides')\n        return None\n    elif side1 + side2 <= side1 or side1 + side2 <= side2 or side1 + side1 <= side2:\n        print('Invalid input. These sides do not form a valid triangle')\n        return None\n    else:\n        height = side2 * math.sin(math.radians(angle))\n        return height"], [0.8753628730773926, "    elif side1 + side2 <= side1 or side1 + side2 <= side2 or side1 + side1 <= side2:\n        print('Invalid input. These sides do not form a valid triangle')\n        return None\n    else:\n        height = side2 * math.sin(math.radians(angle))\n        return height"], [0.8744105100631714, "    elif angle > 90 and angle < 180:\n        return 'Obtuse angle'\n    elif angle == 180:\n        return 'Straight angle'"], [0.873150110244751, "    elif angle == 90:\n        return 'Right angle'\n    elif angle > 90 and angle < 180:\n        return 'Obtuse angle'\n    elif angle == 180:\n        return 'Straight angle'"]]}
{"task_id": "MBPP/346", "problem": [[0.9015679955482483, "    max_values = []\n    for tup in list_of_tuples:\n        max_values.append(max(tup))\n    return max_values"], [0.8920714855194092, "    for tup in list_of_tuples:\n        max_values.append(max(tup))"], [0.8915171027183533, "    if isinstance(args[0], tuple):\n        return [max(t) for t in args]\n    else:\n        return max(args)"], [0.891493558883667, "    if isinstance(args[0], tuple):\n        return [max(t) for t in args]\n    else:\n        return max(args)"], [0.8821685314178467, "    max_elmt = l[0]\n    for x in l:\n        if x > max_elmt:\n            max_elmt = x\n    return max_elmt"], [0.8808093070983887, "    max_val = data[0]\n    for num in data:\n        if num > max_val:\n            max_val = num\n    return max_val"], [0.8802366852760315, "    max = lst[0]\n    for i in range(1, len(lst)):\n        if lst[i] > max:\n            max = lst[i]\n    return max"], [0.8799280524253845, "    max_val = float('-inf')\n    for element in elements:\n        if element > max_val:\n            max_val = element\n    return max_val"], [0.8793745040893555, "    max = lst[0]\n    for i in range(1, len(lst)):\n        if max < lst[i]:\n            max = lst[i]\n    return max"], [0.8793474435806274, "    max = list1[0]\n    for item in list1:\n        if item > max:\n            max = item\n    return max"]]}
{"task_id": "MBPP/347", "problem": [[0.8973081111907959, "    if not isinstance(tuples1, list) or not isinstance(tuples2, list):\n        return 'Error: Both inputs should be lists.'\n    if len(tuples1) != len(tuples2):\n        return 'Error: Both lists should be of same length.'\n    for t in tuples1 + tuples2:\n        if not isinstance(t, tuple):\n            return 'Error: All elements of input lists should be tuples.'\n        if not all((isinstance(i, int) for i in t)):\n            return 'Error: All elements of the tuples should be integers.'\n    result = []\n    for pair1, pair2 in zip(tuples1, tuples2):\n        if len(pair1) != len(pair2):\n            return 'Error: Corresponding tuples should be of same length.'\n        temp = []\n        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)\n        result.append(tuple(temp))\n    return result"], [0.8972752094268799, "    if not isinstance(tuples1, list) or not isinstance(tuples2, list):\n        return 'Error: Both inputs should be lists.'\n    if len(tuples1) != len(tuples2):\n        return 'Error: Both lists should be of same length.'\n    for t in tuples1 + tuples2:\n        if not isinstance(t, tuple):\n            return 'Error: All elements of input lists should be tuples.'\n        if not all((isinstance(i, int) for i in t)):\n            return 'Error: All elements of the tuples should be integers.'\n    result = []\n    for pair1, pair2 in zip(tuples1, tuples2):\n        if len(pair1) != len(pair2):\n            return 'Error: Corresponding tuples should be of same length.'\n        temp = []\n        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)\n        result.append(tuple(temp))\n    return result"], [0.8966490030288696, "        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)"], [0.8966314792633057, "        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)"], [0.8964904546737671, "    for pair1, pair2 in zip(tuples1, tuples2):\n        if len(pair1) != len(pair2):\n            return 'Error: Corresponding tuples should be of same length.'\n        temp = []\n        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)\n        result.append(tuple(temp))"], [0.896453857421875, "    for pair1, pair2 in zip(tuples1, tuples2):\n        if len(pair1) != len(pair2):\n            return 'Error: Corresponding tuples should be of same length.'\n        temp = []\n        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)\n        result.append(tuple(temp))"], [0.8964347243309021, "    if len(list1) != len(list2):\n        return 'Error: Lists are not of the same length.'\n    result = []\n    for tup1, tup2 in zip(list1, list2):\n        if not isinstance(tup1, tuple) or not isinstance(tup2, tuple):\n            return 'Error: One or more elements is not a tuple.'\n        if len(tup1) != len(tup2):\n            return 'Error: Tuples are of different lengths.'\n        temp_result = []\n        for num1, num2 in zip(tup1, tup2):\n            if not isinstance(num1, int) or not isinstance(num2, int):\n                return 'Error: one or more elements is not an integer.'\n            if num2 == 0:\n                return 'Error: Cannot divide by zero.'\n            temp_result.append(num1 % num2)\n        result.append(tuple(temp_result))\n    return result"], [0.8959391713142395, "    results = []\n    for pair in pairs:\n        try:\n            result = pair[0] % pair[1]\n            results.append(result)\n        except ZeroDivisionError:\n            results.append('Error: Division by 0')\n        except Exception as e:\n            results.append('Error: ' + str(e))\n    return results"], [0.895575761795044, "    if len(list1) != len(list2):\n        return 'Error: Lists are of different lengths.'\n    result = []\n    for tup1, tup2 in zip(list1, list2):\n        if not isinstance(tup1, tuple) or not isinstance(tup2, tuple):\n            return 'Error: One or more elements is not a tuple.'\n        if len(tup1) != len(tup2):\n            return 'Error: Tuples are of different lengths.'\n        temp_result = []\n        for num1, num2 in zip(tup1, tup2):\n            if not isinstance(num1, int) or not isinstance(num2, int):\n                return 'Error: One or more elements is not an integer.'\n            if num2 == 0:\n                return 'Error: Cannot divide by zero.'\n            temp_result.append(num1 % num2)\n        result.append(tuple(temp_result))\n    return result"], [0.8941052556037903, "    sum1 = sum(list1)\n    sum2 = sum(list2)\n    sum3 = sum(list3)\n    return [sum1 % sum3, sum2 % sum3]"]]}
{"task_id": "MBPP/348", "problem": [[0.9032968282699585, "    if math.isqrt(discriminant) ** 2 == discriminant:\n        if (math.isqrt(discriminant) - 1) % 2 == 0:\n            return True"], [0.8957987427711487, "    elif discriminant == 0:\n        root = -b / (2 * a)\n        return root\n    else:\n        return 'No real roots exist.'"], [0.8951984643936157, "        if (math.isqrt(discriminant) - 1) % 2 == 0:\n            return True"], [0.8941447734832764, "    elif discriminant == 0:\n        root = -b / (2 * a)\n        return root\n    else:\n        return 'No real roots'"], [0.8937087059020996, "    elif discriminant == 0:\n        root = -b / (2 * a)\n        return root\n    else:\n        return 'No real solutions'"], [0.8925884962081909, "    elif d == 0:\n        root = -b / (2 * a)\n        return root\n    else:\n        return 'No real roots found'"], [0.8923331499099731, "    elif discriminant == 0:\n        return -b / (2 * a)\n    else:\n        return 'No real roots'"], [0.8920682668685913, "    elif discriminant == 0:\n        root = -b / (2 * a)\n        return (root,)\n    else:\n        return 'No real roots'"], [0.8914880752563477, "    elif discriminant == 0:\n        nature = 'One real root (a perfect square)'\n        x = -b / (2 * a)\n        return (x, discriminant, nature)\n    else:\n        nature = 'No real roots (two complex roots)'\n        return (None, None, discriminant, nature)"], [0.8911606669425964, "    elif d == 0:\n        return (-b / (2 * a), -b / (2 * a))\n    else:\n        x1 = (-b + d ** 0.5) / (2 * a)\n        x2 = (-b - d ** 0.5) / (2 * a)\n        return (x1, x2)"]]}
{"task_id": "MBPP/349", "problem": [[0.8876668810844421, "    elif n == 2:\n        return 2\n    else:\n        return 2 * nth_value(n - 1)"], [0.8871955871582031, "    if n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return 2 * nth_value(n - 1)"], [0.8871955871582031, "    if n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return 2 * nth_value(n - 1)"], [0.8869332075119019, "    for i in range(2, n):\n        lucas_numbers.append(lucas_numbers[i - 1] + lucas_numbers[i - 2])"], [0.8869186639785767, "    for i in range(2, n):\n        lucas_numbers.append(lucas_numbers[i - 1] + lucas_numbers[i - 2])"], [0.8862873315811157, "    return findNthPolite(n)"], [0.8862812519073486, "    return findNthPolite(n)"], [0.8856824636459351, "    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"], [0.8856819868087769, "    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"], [0.8856805562973022, "    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"]]}
{"task_id": "MBPP/350", "problem": [[0.9174323081970215, "    if not isinstance(l, list):\n        return l\n    else:\n        return [x for x in filter(None, map(remove_empty_lists, l))]"], [0.9174323081970215, "    if not isinstance(l, list):\n        return l\n    else:\n        return [x for x in filter(None, map(remove_empty_lists, l))]"], [0.8957036137580872, "    for lst in lists:\n        result.append([item for item in lst if item not in items_to_remove])"], [0.8954580426216125, "    new_lst = []\n    for li in lst:\n        if li:\n            new_lst.append(li)\n    return new_lst"], [0.8922361135482788, "    return [s for s in list_of_strings if s != '']"], [0.8861379623413086, "    if not list_of_lists:\n        return []"], [0.8859582543373108, "    result = []\n    for string in lst:\n        if string:\n            result.append(string)\n    return result"], [0.885840117931366, "            for item in lst:\n                is_empty, count_empty = check_empty_lists(item, already_checked)\n                empty_list_count += count_empty\n                all_empty = all_empty and is_empty"], [0.8858386278152466, "            for item in lst:\n                is_empty, count_empty = check_empty_lists(item, already_checked)\n                empty_list_count += count_empty\n                all_empty = all_empty and is_empty"], [0.8855952024459839, "    i = 0\n    while i < len(lst):\n        if lst[i] == '':\n            lst.pop(i)\n        else:\n            i += 1\n    return lst"]]}
{"task_id": "MBPP/351", "problem": [[0.9432665109634399, "    max_count = 0\n    max_item = None\n    dict = {}\n    for item in list:\n        if item in dict:\n            dict[item] += 1\n        else:\n            dict[item] = 1\n    for key, value in dict.items():\n        if value > max_count:\n            max_count = value\n            max_item = key\n    return max_item"], [0.9393873810768127, "    max_count = -1\n    max_item = None\n    count = {}\n    for item in lst:\n        if item in count:\n            count[item] += 1\n        else:\n            count[item] = 1\n        if count[item] > max_count:\n            max_count = count[item]\n            max_item = item\n    return max_item"], [0.9393411874771118, "    counts = {}\n    for item in my_list:\n        if item in counts:\n            counts[item] += 1\n        else:\n            counts[item] = 1\n    max_frequency = 0\n    max_item = None\n    for item in counts:\n        if counts[item] > max_frequency:\n            max_frequency = counts[item]\n            max_item = item\n    return max_item"], [0.9384042024612427, "    freq_dict = {}\n    for item in lst:\n        freq_dict[item] = freq_dict.get(item, 0) + 1\n    max_count = 0\n    max_item = lst[0]\n    for key, value in freq_dict.items():\n        if value > max_count:\n            max_count = value\n            max_item = key\n    return max_item"], [0.9377303719520569, "    count = {}\n    for item in input_list:\n        if item in count:\n            count[item] += 1\n        else:\n            count[item] = 1\n    maxCount = 0\n    maxItem = None\n    for item in count:\n        if count[item] > maxCount:\n            maxCount = count[item]\n            maxItem = item\n    return maxItem"], [0.9370357990264893, "    max_count = 0\n    max_ele = list[0]\n    for i in list:\n        freq = list.count(i)\n        if freq > max_count:\n            max_count = freq\n            max_ele = i\n    return max_ele"], [0.9367878437042236, "    max_count = -1\n    max_item = None\n    counts = {}\n    for item in lst:\n        if item not in counts:\n            counts[item] = 0\n        counts[item] += 1\n        if counts[item] > max_count:\n            max_count = counts[item]\n            max_item = item\n    return max_item"], [0.9365628361701965, "    max_count = 0\n    max_item = lst[0]\n    for i in lst:\n        count = 1\n        for j in lst:\n            if j == i:\n                count += 1\n        if count >= max_count:\n            max_count = count\n            max_item = i\n    return max_item"], [0.935855507850647, "    frequency_dict = {}\n    max_count = 0\n    max_item = None\n    for item in input_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n        if frequency_dict[item] > max_count:\n            max_count = frequency_dict[item]\n            max_item = item\n    return (max_item, max_count)"], [0.9352418184280396, "    count = 0\n    max_element = 0\n    for element in lst:\n        curr_count = lst.count(element)\n        if curr_count > count:\n            count = curr_count\n            max_element = element\n    return max_element"]]}
{"task_id": "MBPP/352", "problem": [[0.8957962989807129, "    for i in range(len(arr)):\n        arr[i] = arr[i] + k\n    return arr"], [0.8918623924255371, "    for i in range(len(arr)):\n        arr[i] = arr[i] + k"], [0.8830235004425049, "    return [element * k for element in myList]"], [0.8811910152435303, "        for c, d in tpl2:\n            return (a + c, b + d)"], [0.8798644542694092, "    new_tuple = (element,) + old_tuple\n    return new_tuple"], [0.879858136177063, "    new_tuple = (element,) + old_tuple\n    return new_tuple"], [0.8743429183959961, "    for i in lst:\n        add = add + i"], [0.8740453124046326, "    for a, b in tpl1:\n        for c, d in tpl2:\n            return (a + c, b + d)"], [0.8740453124046326, "    for a, b in tpl1:\n        for c, d in tpl2:\n            return (a + c, b + d)"], [0.8740138411521912, "    filtered_elements = [x for x in a if x < b]\n    multiplied_elements = [x * fact for x in filtered_elements]\n    return tuple(multiplied_elements)"]]}
{"task_id": "MBPP/353", "problem": [[0.9150879979133606, "    n = len(S)\n    no_of_zeros = S.count('0')\n    no_of_ones = n - no_of_zeros\n    dp = [0] * (n + 1)\n    min_flips = no_of_zeros\n    ones_left = 0\n    zeros_left = no_of_zeros\n    for i in range(1, n + 1):\n        if S[i - 1] == '0':\n            zeros_left -= 1\n        else:\n            ones_left += 1\n        dp[i] = min(ones_left + zeros_left, dp[i - 1] + (1 if S[i - 1] == '1' else 0))\n        if dp[i] < min_flips:\n            min_flips = dp[i]\n    return min_flips"], [0.9137851595878601, "    flipCount, oneCount = (0, 0)\n    for c in s:\n        if c == '1':\n            oneCount += 1\n        else:\n            flipCount = min(flipCount + 1, oneCount)\n    return flipCount"], [0.9137313365936279, "    flips = 0\n    prev = '0'\n    for bulb in target:\n        if bulb != prev:\n            flips += 1\n            prev = bulb\n    return flips"], [0.9092686176300049, "    zeroCount = s.count('0')\n    oneCount = len(s) - zeroCount\n    if abs(zeroCount - oneCount) > 1:\n        return -1\n    swaps1 = swaps2 = 0\n    for i, c in enumerate(s):\n        if i % 2 == 0 and c != '0':\n            swaps1 += 1\n        if i % 2 == 1 and c != '1':\n            swaps1 += 1\n    swaps1 = swaps1 // 2\n    for i, c in enumerate(s):\n        if i % 2 == 0 and c != '1':\n            swaps2 += 1\n        if i % 2 == 1 and c != '0':\n            swaps2 += 1\n    swaps2 = swaps2 // 2\n    if zeroCount == oneCount:\n        return min(swaps1, swaps2)\n    return swaps2 if zeroCount > oneCount else swaps1"], [0.9092422127723694, "    zeroCount = s.count('0')\n    oneCount = len(s) - zeroCount\n    if abs(zeroCount - oneCount) > 1:\n        return -1\n    swaps1 = swaps2 = 0\n    for i, c in enumerate(s):\n        if i % 2 == 0 and c != '0':\n            swaps1 += 1\n        if i % 2 == 1 and c != '1':\n            swaps1 += 1\n    swaps1 = swaps1 // 2\n    for i, c in enumerate(s):\n        if i % 2 == 0 and c != '1':\n            swaps2 += 1\n        if i % 2 == 1 and c != '0':\n            swaps2 += 1\n    swaps2 = swaps2 // 2\n    if zeroCount == oneCount:\n        return min(swaps1, swaps2)\n    return swaps2 if zeroCount > oneCount else swaps1"], [0.9070776700973511, "    for c in s:\n        if c == '1':\n            oneCount += 1\n        else:\n            flipCount = min(flipCount + 1, oneCount)"], [0.905449390411377, "    count_a, count_b = (0, 0)\n    for i, c in enumerate(s):\n        if i % 2 == 0:\n            if c == '0':\n                count_a += 1\n            else:\n                count_b += 1\n        elif c == '0':\n            count_b += 1\n        else:\n            count_a += 1\n    return min(count_a, count_b)"], [0.9044026136398315, "    for i in range(1, n + 1):\n        if S[i - 1] == '0':\n            zeros_left -= 1\n        else:\n            ones_left += 1\n        dp[i] = min(ones_left + zeros_left, dp[i - 1] + (1 if S[i - 1] == '1' else 0))\n        if dp[i] < min_flips:\n            min_flips = dp[i]"], [0.9039394855499268, "        if c == '1':\n            oneCount += 1\n        else:\n            flipCount = min(flipCount + 1, oneCount)"], [0.9030253887176514, "    for i, c in enumerate(s):\n        if i % 2 == 0 and c != '0':\n            swaps1 += 1\n        if i % 2 == 1 and c != '1':\n            swaps1 += 1"]]}
{"task_id": "MBPP/354", "problem": [[0.925600528717041, "    while digits != 0:\n        digits //= 10\n        count += 1"], [0.9255355596542358, "    count = 0\n    while number > 0:\n        number = number // 10\n        count = count + 1\n    return count"], [0.922988772392273, "    count = 0\n    while number != 0:\n        number = number // 10\n        count += 1\n    return count"], [0.9224833250045776, "    count = 0\n    while number != 0:\n        count = count + 1\n        number = number // 10\n    return count"], [0.922024130821228, "    count = 0\n    while n > 0:\n        n = n // 10\n        count += 1\n    return count"], [0.9215047359466553, "    count = 0\n    while n != 0:\n        n //= 10\n        count += 1\n    return count"], [0.9214829802513123, "    while number > 0:\n        number = number // 10\n        count = count + 1"], [0.9213654398918152, "    if type(num) != int:\n        return 'Error: Invalid input'\n    if num < 0:\n        num = -num\n    if num == 0:\n        return 1\n    count = 0\n    while num > 0:\n        num //= 10\n        count += 1\n    return count"], [0.9203535318374634, "    while number != 0:\n        count = count + 1\n        number = number // 10"], [0.9193726778030396, "    number = abs(number)\n    num_digits = len(str(number))\n    return num_digits"]]}
{"task_id": "MBPP/355", "problem": [[0.9313703775405884, "    max_product = float('-inf')\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] * lst[j] > max_product:\n                max_product = lst[i] * lst[j]\n                pair = (lst[i], lst[j])\n    return pair"], [0.9281654953956604, "    if len(lst) < 2:\n        return None\n    max_product = float('-inf')\n    max_pair = None\n    for pair in combinations(lst, 2):\n        product = pair[0] * pair[1]\n        if product > max_product:\n            max_product = product\n            max_pair = pair\n    return list(max_pair)"], [0.9255377054214478, "    max_product = 0\n    max_elems = [0, 0]\n    for i in range(len(arr)):\n        left_elem = arr[i]\n        for j in range(i + 1, len(arr)):\n            right_elem = arr[j]\n            product = left_elem * right_elem\n            if product > max_product:\n                max_product = product\n                max_elems = [left_elem, right_elem]\n    return (max_product, max_elems)"], [0.9253742694854736, "    for pair in combinations(lst, 2):\n        product = pair[0] * pair[1]\n        if product > max_product:\n            max_product = product\n            max_pair = pair"], [0.9242330193519592, "    if len(array) < 2:\n        return None\n    max_product = array[0] * array[1]\n    max_pair = (array[0], array[1])\n    for i in range(len(array)):\n        for j in range(i + 1, len(array)):\n            product = array[i] * array[j]\n            if product > max_product:\n                max_product = product\n                max_pair = (array[i], array[j])\n    return list(max_pair)"], [0.9187819957733154, "    if not lst:\n        return []\n    possible_pairs = [[lst[i], lst[j]] for i in range(len(lst)) for j in range(i + 1, len(lst))]\n    products = [pair[0] * pair[1] for pair in possible_pairs]\n    max_product = max(products)\n    return [possible_pairs[i] for i in range(len(products)) if products[i] == max_product]"], [0.9173946380615234, "    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] * lst[j] > max_product:\n                max_product = lst[i] * lst[j]\n                pair = (lst[i], lst[j])"], [0.9152670502662659, "    max_product = float('-inf')\n    for i in range(len(array) - 1):\n        for j in range(i + 1, len(array)):\n            if array[i] * array[j] > max_product:\n                max_product = array[i] * array[j]\n    return max_product"], [0.9147515296936035, "    n = len(arr)\n    max_product = float('-inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            product = arr[i] * arr[j]\n            if product > max_product:\n                max_product = product\n    return max_product"], [0.9146967530250549, "            if lst[i] * lst[j] > max_product:\n                max_product = lst[i] * lst[j]\n                pair = (lst[i], lst[j])"]]}
{"task_id": "MBPP/356", "problem": [[0.926216185092926, "    if not root:\n        return True\n    lh = get_height(root.left)\n    rh = get_height(root.right)\n    if abs(lh - rh) <= 1 and is_balanced(root.left) is True and (is_balanced(root.right) is True):\n        return True\n    return False"], [0.9256664514541626, "    is_balanced = True\n    if root is None:\n        is_balanced = True\n    elif abs(get_height(root.left) - get_height(root.right)) > 1:\n        is_balanced = False\n    else:\n        is_balanced = is_balanced_tree(root.left) and is_balanced_tree(root.right)\n    return is_balanced"], [0.9247052669525146, "    if node is None:\n        return True\n    lh = tree_height(node.left) - 1\n    rh = tree_height(node.right) - 1\n    if abs(lh - rh) >= 2:\n        return False\n    return is_balanced(node.left) and is_balanced(node.right)"], [0.9235826730728149, "    if root is None:\n        return True\n    lh = height(root.left)\n    rh = height(root.right)\n    if abs(lh - rh) <= 1 and isBalanced(root.left) and isBalanced(root.right):\n        return True\n    return False"], [0.9232327938079834, "    lh = height(root.left)\n    rh = height(root.right)\n    if abs(lh - rh) <= 1 and isBalanced(root.left) and isBalanced(root.right):\n        return True\n    return False"], [0.9227253794670105, "    if root is None:\n        return True\n    left_height = is_balanced(root.left)\n    right_height = is_balanced(root.right)\n    if abs(left_height - right_height) <= 1 and is_balanced(root.left) and is_balanced(root.right):\n        return True\n    return False"], [0.9220752716064453, "    if root is None:\n        is_balanced = True\n    elif abs(get_height(root.left) - get_height(root.right)) > 1:\n        is_balanced = False\n    else:\n        is_balanced = is_balanced_tree(root.left) and is_balanced_tree(root.right)"], [0.9220166206359863, "    if root is None:\n        return True\n    lh = height(root.left)\n    rh = height(root.right)\n    if abs(lh - rh) <= 1 and isBalanced(root.left) is True and (isBalanced(root.right) is True):\n        return True\n    return False"], [0.9215182065963745, "    if root == None:\n        return True\n    leftHeight = height(root.left)\n    rightHeight = height(root.right)\n    if abs(leftHeight - rightHeight) < 2 and is_balanced(root.left) is True and (is_balanced(root.right) is True):\n        return True\n    return False"], [0.9212579727172852, "    elif abs(get_height(root.left) - get_height(root.right)) > 1:\n        is_balanced = False\n    else:\n        is_balanced = is_balanced_tree(root.left) and is_balanced_tree(root.right)"]]}
{"task_id": "MBPP/357", "problem": []}
{"task_id": "MBPP/358", "problem": [[0.9163185954093933, "    lateral_surface_area = 2 * l * h + b * h\n    total_surface_area = lateral_surface_area + 2 * l * b\n    return (lateral_surface_area, total_surface_area)"], [0.9079416990280151, "    surface_area = 2 * l * w + 2 * l * h + 2 * w * h\n    return surface_area"], [0.903471827507019, "    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area"], [0.9034465551376343, "    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area"], [0.8953275680541992, "    triangular_faces = 2 * 0.5 * b * h\n    rectangular_faces = 2 * b * L + h * L\n    total_surface_area = triangular_faces + rectangular_faces\n    return total_surface_area"], [0.8949223756790161, "    surface_area = 2 * (height * width + width * depth + height * depth)\n    return surface_area"], [0.8946269750595093, "    surface_area = 6 * length ** 2\n    volume = length ** 3\n    return (surface_area, volume)"], [0.8943910598754883, "    try:\n        if len(cuboid) != 3:\n            raise ValueError('Input list must contain exactly three elements.')\n        l, b, h = cuboid\n        if not all((isinstance(val, (int, float)) for val in cuboid)):\n            raise ValueError('All elements in the input list must be numeric.')\n        aggregate_surface = 2 * (l * b + b * h + l * h)\n        return aggregate_surface\n    except ValueError as error:\n        print(str(error))\n        return None"], [0.8943910598754883, "    try:\n        if len(cuboid) != 3:\n            raise ValueError('Input list must contain exactly three elements.')\n        l, b, h = cuboid\n        if not all((isinstance(val, (int, float)) for val in cuboid)):\n            raise ValueError('All elements in the input list must be numeric.')\n        aggregate_surface = 2 * (l * b + b * h + l * h)\n        return aggregate_surface\n    except ValueError as error:\n        print(str(error))\n        return None"], [0.8930947780609131, "    if r1 < 0 or r2 < 0 or s < 0:\n        return 'Error: the radii and height must be positive numbers.'\n    lateral_surface_area = math.pi * (r1 + r2) * math.sqrt((r1 - r2) ** 2 + s ** 2)\n    return lateral_surface_area"]]}
{"task_id": "MBPP/359", "problem": []}
{"task_id": "MBPP/360", "problem": [[0.9342241287231445, "    sorted_arr = sorted(arr)\n    curr = sorted_arr[0]\n    for element in sorted_arr[1:]:\n        if element != curr + 1:\n            return curr + 1\n        else:\n            curr = element\n    return missing"], [0.9288812875747681, "    arr.sort()\n    smallest_missing = None\n    for i in range(len(arr)):\n        if arr[i] > 0:\n            if arr[i] != i + 1:\n                smallest_missing = i + 1\n                break\n    if smallest_missing is None:\n        smallest_missing = len(arr) + 1\n    return smallest_missing"], [0.9219193458557129, "    arr.sort()\n    for i in range(len(arr)):\n        if arr[i] != i + 1:\n            return i + 1\n    return arr[-1] + 1"], [0.9184635877609253, "    n = len(arr)\n    max_val = arr[0]\n    max_index = 0\n    for i in range(1, n):\n        if arr[i] > max_val:\n            max_val = arr[i]\n            max_index = i\n    expected = list(range(max_val + 1))\n    for num in expected:\n        if num not in arr:\n            return num\n    return expected[max_index + 1]"], [0.9182337522506714, "    for element in sorted_arr[1:]:\n        if element != curr + 1:\n            return curr + 1\n        else:\n            curr = element"], [0.9166531562805176, "    arr.sort()\n    for i in range(len(arr) - 1):\n        if arr[i + 1] - arr[i] != 1:\n            return arr[i] + 1"], [0.9162753820419312, "    for i in range(n - 1):\n        expected_num = arr[i] + 1\n        if arr[i + 1] != expected_num:\n            return expected_num"], [0.9161456823348999, "    s = set()\n    for i in arr:\n        s.add(i)\n    for i in range(1, len(arr) + 1):\n        if i not in s:\n            return i\n    return len(arr) + 1"], [0.9159139394760132, "    arr.sort()\n    for i in range(len(arr)):\n        if arr[i + 1] - arr[i] != 1:\n            return arr[i] + 1"]]}
{"task_id": "MBPP/361", "problem": []}
{"task_id": "MBPP/362", "problem": [[0.9170449376106262, "    volume_one_cuboid = length * breadth * height\n    combined_volume = volume_one_cuboid * number_of_cuboids\n    return combined_volume"], [0.9009014368057251, "    volume = length * breadth * height\n    return volume"], [0.9008681774139404, "    volume = length * breadth * height\n    return volume"], [0.9001426100730896, "    volume = side_length ** 3\n    return volume"], [0.899128794670105, "    area = 2 * (length * width + length * height + width * height)\n    volume = length * width * height\n    return (area, volume)"], [0.8960750102996826, "    volume = 4 / 3 * math.pi * math.pow(radius, 3)\n    return volume"], [0.8953557014465332, "    if length <= 0 or width <= 0 or height <= 0:\n        raise ValueError('All the dimensions should be non-zero positive numbers.')\n    else:\n        return length * width * height"], [0.8953557014465332, "    if length <= 0 or width <= 0 or height <= 0:\n        raise ValueError('All the dimensions should be non-zero positive numbers.')\n    else:\n        return length * width * height"], [0.8947422504425049, "    cube_radius = pow(r, 3)\n    volume = 4 / 3 * math.pi * cube_radius\n    return volume"], [0.8940451741218567, "    box_x = box_coordinates[0].split()\n    box_y = box_coordinates[1].split()\n    box_z = box_coordinates[2].split()\n    length = abs(float(box_x[1]) - float(box_x[0]))\n    width = abs(float(box_y[1]) - float(box_y[0]))\n    height = abs(float(box_z[1]) - float(box_z[0]))\n    volume = length * width * height\n    return volume"]]}
{"task_id": "MBPP/363", "problem": [[0.9333562254905701, "    string = ''.join(set(string))\n    for perm in permutations(string):\n        print(''.join(perm))"], [0.9327049255371094, "        for i, char in enumerate(string):\n            for perm in print_permutations(string[:i] + string[i + 1:]):\n                print(char + perm)"], [0.9258118867874146, "    if len(string) == 1:\n        print(string)\n    else:\n        for i, char in enumerate(string):\n            for perm in print_permutations(string[:i] + string[i + 1:]):\n                print(char + perm)"], [0.9258118867874146, "    if len(string) == 1:\n        print(string)\n    else:\n        for i, char in enumerate(string):\n            for perm in print_permutations(string[:i] + string[i + 1:]):\n                print(char + perm)"], [0.9250695705413818, "    for perm in permutations(string):\n        print(''.join(perm))"], [0.9239763617515564, "    perms = itertools.permutations(string)\n    for p in perms:\n        print(''.join(p))"], [0.9239472150802612, "            for perm in print_permutations(string[:i] + string[i + 1:]):\n                print(char + perm)"], [0.9229736924171448, "    _print_permutations_helper('', s)"], [0.9216327667236328, "    length = len(string)\n    stack = ['']\n    visited = [False] * length\n    while stack:\n        current = stack.pop()\n        if len(current) == length:\n            print(current)\n        else:\n            for i in range(length):\n                if not visited[i]:\n                    visited[i] = True\n                    stack.append(current + string[i])\n                    visited[i] = False"], [0.920768141746521, "        for char in string:\n            for perm in permutations(string.replace(char, '')):\n                perm_list.append(char + perm)"]]}
{"task_id": "MBPP/364", "problem": [[0.908858597278595, "    return round(n / 5) * 5"], [0.9071648120880127, "    return round(num / 10) * 10"], [0.8967028856277466, "    scaled_number = number * factor\n    rounded_number = int(scaled_number * 10 + 0.5) // 10\n    return rounded_number"], [0.8958010673522949, "    return int(math.ceil(n / 5)) * 5"], [0.8919054269790649, "    if round_down:\n        return int(number // 1)\n    else:\n        return int(number // 1) + 1 if number % 1 != 0 else int(number)"], [0.8915045261383057, "        if round_down:\n            return int(number // 1)\n        else:\n            return round(number)"], [0.891381025314331, "    if round_down:\n        return int(number)\n    elif number < 0:\n        return int(number) if number == int(number) else int(number) - 1\n    else:\n        return int(number) if number == int(number) else int(number) + 1"], [0.891381025314331, "    if round_down:\n        return int(number)\n    elif number < 0:\n        return int(number) if number == int(number) else int(number) - 1\n    else:\n        return int(number) if number == int(number) else int(number) + 1"], [0.8910702466964722, "    correction = 0.5 if n >= 0 else -0.5\n    return int(n / precision + correction) * precision"], [0.8899271488189697, "    return int(math.ceil(x / 10.0)) * 10"]]}
{"task_id": "MBPP/365", "problem": [[0.9037469625473022, "    seen = set()\n    duplicates = set()\n    for item in input_tuple:\n        if item in seen:\n            duplicates.add(item)\n        seen.add(item)\n    return (len(duplicates) > 0, duplicates)"], [0.897684633731842, "    new_tuple = []\n    for i in value_in_tuple:\n        if i not in new_tuple:\n            new_tuple.append(i)\n    return tuple(new_tuple)"], [0.89742112159729, "    final_list = []\n    for num in input_list:\n        if num not in final_list:\n            final_list.append(num)\n    return tuple(final_list)"], [0.8933796882629395, "    seen = set()\n    result = []\n    for tup in tups:\n        if tup not in seen:\n            result.append(tup)\n            seen.add(tup)\n    return result"], [0.8933761119842529, "    result_set = set(input_tuple)\n    result_tuple = tuple(result_set)\n    return result_tuple"], [0.8903636336326599, "    max_val = max(lst)\n    seen = set()\n    for i in range(len(lst)):\n        if lst[i] in seen:\n            lst[i] = max_val\n        else:\n            seen.add(lst[i])\n    return lst"], [0.8899749517440796, "    for item in input_tuple:\n        if item in seen:\n            duplicates.add(item)\n        seen.add(item)"], [0.8887690305709839, "    list_ = list(tup)\n    if item in list_:\n        list_.remove(item)\n    return tuple(list_)"], [0.8882445693016052, "    seen = set()\n    for dic in lst:\n        dic_copy = dic.copy()\n        for key, value in dic.items():\n            if value in seen:\n                del dic_copy[key]\n            else:\n                seen.add(value)\n        dic.clear()\n        dic.update(dic_copy)\n    return lst"], [0.8881539106369019, "    new_tup = []\n    for elem in initial_tup:\n        if elem != tup_to_expunge:\n            new_tup.append(elem)\n    return tuple(new_tup)"]]}
{"task_id": "MBPP/366", "problem": [[0.9238282442092896, "    result = ''\n    for c in string:\n        if c != char:\n            result += c\n    return result"], [0.9234418869018555, "    new_string = ''\n    for char in input_string:\n        if char != character_to_remove:\n            new_string += char\n    return new_string"], [0.9228833317756653, "    newString = ''\n    for ch in s:\n        if ch != character:\n            newString += ch\n    return newString"], [0.9211516976356506, "    res = ''\n    for i in range(len(string)):\n        if string[i] != char:\n            res += string[i]\n    return res"], [0.9201617240905762, "    new_string = given_string.replace(character, '')\n    return new_string"], [0.9188644289970398, "    new_string = string.replace(char, '')\n    return new_string"], [0.9188631176948547, "    new_string = ''\n    for char in string:\n        if char != remove_char:\n            new_string += char\n    return new_string"], [0.9179937839508057, "    modified_string = ''\n    for c in input_string:\n        if c != char:\n            modified_string += c\n    return modified_string"], [0.9160890579223633, "    output = ''\n    for c in sentence:\n        if c != char:\n            output += c\n    return output"], [0.9154477119445801, "    string_list = list(string)\n    for i in string_list:\n        if i == char:\n            string_list.remove(i)\n    string = ''.join(string_list)\n    return string"]]}
{"task_id": "MBPP/367", "problem": [[0.9130551815032959, "    first_element = arr[0]\n    for i in range(len(arr) - 1):\n        arr[i] = arr[i + 1]\n    arr[len(arr) - 1] = first_element"], [0.9107397198677063, "    first = arr[0]\n    for i in range(len(arr) - 1):\n        arr[i] = arr[i + 1]\n    arr[len(arr) - 1] = first"], [0.9100664854049683, "    if not lst:\n        return lst\n    last_element = lst.pop()\n    lst.insert(0, last_element)\n    return lst"], [0.908858060836792, "    temp = arr[0]\n    for i in range(len(arr) - 1):\n        arr[i] = arr[i + 1]\n    arr[-1] = temp\n    return arr"], [0.9088411331176758, "    temp = arr[0]\n    for i in range(len(arr) - 1):\n        arr[i] = arr[i + 1]\n    arr[-1] = temp\n    return arr"], [0.9088402390480042, "    temp = arr[0]\n    for i in range(len(arr) - 1):\n        arr[i] = arr[i + 1]\n    arr[-1] = temp\n    return arr"], [0.9087079167366028, "    if len(lst) < 2:\n        return lst\n    second_last = lst[-2]\n    for i in range(len(lst) - 2, 0, -1):\n        lst[i] = lst[i - 1]\n    lst[0] = second_last\n    return lst"], [0.90638267993927, "    temp = arr[0]\n    for i in range(len(arr) - 1):\n        arr[i] = arr[i + 1]\n    arr[len(arr) - 1] = temp"], [0.9057836532592773, "    temp = arr[0]\n    for i in range(len(arr) - 1):\n        arr[i] = arr[i + 1]\n    arr[len(arr) - 1] = temp\n    return arr"], [0.9038094878196716, "    if len(lst) < 2:\n        return lst\n    second_to_last = lst[-2]\n    for i in range(len(lst) - 1, 0, -1):\n        lst[i] = lst[i - 1]\n    lst[0] = second_to_last\n    return lst"]]}
{"task_id": "MBPP/368", "problem": [[0.9170222282409668, "    surface_area = 2 * l * w + 2 * l * h + 2 * w * h\n    return surface_area"], [0.914268970489502, "    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area"], [0.9142458438873291, "    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area"], [0.912955641746521, "    surface_area = 2 * (height * width + width * depth + height * depth)\n    return surface_area"], [0.9064940810203552, "    surface_area = 6 * length ** 2\n    volume = length ** 3\n    return (surface_area, volume)"], [0.9052767157554626, "    surface_area = 6 * edge_length ** 2\n    return surface_area"]]}
{"task_id": "MBPP/369", "problem": []}
{"task_id": "MBPP/370", "problem": []}
{"task_id": "MBPP/371", "problem": [[0.8795488476753235, "    if rotation_angle == 0:\n        return 'Rotation angle cannot be zero'\n    if target_angle == 0:\n        return 0\n    return (target_angle + rotation_angle - 1) // rotation_angle"], [0.87885582447052, "    if arr == arr[::-1]:\n        return 0"], [0.8784613609313965, "        elif A[i] != x:\n            rotations_a += 1\n        elif B[i] != x:\n            rotations_b += 1"], [0.8759481906890869, "    for j in range(len(arr)):\n        new_arr = arr[j:] + arr[:j]\n        if is_sorted(new_arr):\n            return j"], [0.8756191730499268, "    if rotation == 0:\n        return arr\n    rotation = -rotation % len(arr)\n    return array_rotate(arr, rotation)"], [0.874979555606842, "    n = len(arr)\n    minimum = n\n    for i in range(n):\n        diff = 0\n        for j in range(n):\n            if arr[(i + j) % n] != arr[j]:\n                diff += 1\n        minimum = min(diff, minimum)\n    return minimum"], [0.8745362758636475, "    for i in range(len(nums)):\n        if nums[i] > nums[(i + 1) % len(nums)]:\n            count += 1"], [0.8736210465431213, "    if arr[0] <= arr[n - 1]:\n        return 0"], [0.8734915256500244, "        elif B[i] != x:\n            rotations_b += 1"], [0.8728507161140442, "    rotations_a = rotations_b = 0\n    for i in range(n):\n        if A[i] != x and B[i] != x:\n            return -1\n        elif A[i] != x:\n            rotations_a += 1\n        elif B[i] != x:\n            rotations_b += 1\n    return min(rotations_a, rotations_b)"]]}
{"task_id": "MBPP/372", "problem": [[0.8929789662361145, "    while n & mask:\n        n ^= mask\n        mask <<= 1"], [0.8903815746307373, "    mask = 1\n    while num > mask:\n        mask = mask << 1 | 1\n    return num ^ mask"], [0.8885180950164795, "    odd_list = []\n    for number in original_list:\n        if number % 2 != 0:\n            odd_list.append(number)\n    return odd_list"], [0.8883726596832275, "    while n:\n        parity ^= n & 1\n        n >>= 1"], [0.8878854513168335, "    odd_nums = []\n    for num in nums:\n        if num % 2 != 0:\n            odd_nums.append(num)\n    return odd_nums"], [0.8868136405944824, "    odd_nums = [num for num in arr if num % 2 == 1]\n    return odd_nums"], [0.8868030309677124, "    parity = 0\n    while n:\n        parity ^= n & 1\n        n >>= 1\n    return parity"], [0.8865936398506165, "    for num in a:\n        binary_num = bin(num)[2:]\n        transformed_num = num ^ num << 1 ^ num & num << 1 ^ num & num << 1 & num << 2\n        result.append(transformed_num)"], [0.8859759569168091, "    sum = 0\n    for num in numbers:\n        sum += num & 1 ^ 1 and num\n    return sum"], [0.8858523964881897, "    mask = 1\n    while n & mask:\n        n ^= mask\n        mask <<= 1\n    n ^= mask\n    return n"]]}
{"task_id": "MBPP/373", "problem": [[0.9126608371734619, "    frequency = {}\n    for item in array:\n        frequency[item] = frequency.get(item, 0) + 1\n    least_frequent_number = min(frequency, key=frequency.get)\n    return least_frequent_number"], [0.909953236579895, "    freq = dict()\n    for element in arr:\n        if element not in freq:\n            freq[element] = 0\n        freq[element] += 1\n    min_element = None\n    min_count = float('inf')\n    for element, count in freq.items():\n        if count < min_count:\n            min_element = element\n            min_count = count\n    return min_element"], [0.9076372385025024, "    frequency = Counter(arr)\n    min_freq = min(frequency.values())\n    min_freq_nums = [num for num, freq in frequency.items() if freq == min_freq]\n    return min_freq_nums"], [0.905138373374939, "    count_table = {el: lst.count(el) for el in lst}\n    min_freq = min(count_table.values())\n    min_freq_elements = [k for k, v in count_table.items() if v == min_freq]\n    return min_freq_elements[0]"], [0.904748260974884, "    freq_num = Counter(arr).most_common(1)[0][0]\n    return freq_num"], [0.9041352868080139, "        if i < min_val:\n            min_val = i\n            frequency[min_val] = lst.count(min_val)"], [0.9022012948989868, "    count = Counter(lst)\n    return min(count.items(), key=lambda x: x[1])[0]"], [0.9017931222915649, "    counter = Counter(array)\n    freq = counter.most_common(1)[0]\n    return freq[0]"], [0.9001501798629761, "    counter = collections.Counter(lst)\n    return min(counter, key=counter.get)"], [0.8995397090911865, "    element_count = {}\n    for element in arr:\n        if element in element_count:\n            element_count[element] += 1\n        else:\n            element_count[element] = 1\n    least_common_element = None\n    least_common_count = float('inf')\n    for element, count in element_count.items():\n        if count < least_common_count:\n            least_common_element = element\n            least_common_count = count\n    return least_common_element"]]}
{"task_id": "MBPP/374", "problem": [[0.892249584197998, "    elif n == 2:\n        return 2\n    else:\n        return 2 * nth_value(n - 1)"], [0.8913031220436096, "    if n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return 2 * nth_value(n - 1)"], [0.8913031220436096, "    if n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return 2 * nth_value(n - 1)"], [0.8902877569198608, "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n)"], [0.8902877569198608, "    if is_prime(n):\n        return nth_prime(n)\n    else:\n        return fib(n)"], [0.8893864750862122, "    if n not in pell_dict:\n        pell_dict[n] = 2 * pell(n - 1) + pell(n - 2)"], [0.8889271020889282, "    if n not in pell_dict:\n        pell_dict[n] = 2 * pell(n - 1) + pell(n - 2)\n    return pell_dict[n]"], [0.8885908126831055, "    if n < 4:\n        return padovan[:n]\n    else:\n        for i in range(3, n):\n            next_val = padovan[i - 2] + padovan[i - 3]\n            padovan.append(next_val)\n        return padovan"], [0.8877418637275696, "    elif n == 2:\n        return 1\n    else:\n        return fibonacci_number(n - 1) + fibonacci_number(n - 2)"], [0.8874779939651489, "    if n == 1:\n        return 1\n    else:\n        return nth_lucas(n - 1) + nth_lucas(n - 2)"]]}
{"task_id": "MBPP/375", "problem": [[0.9130901098251343, "    open_brackets = 0\n    swaps = 0\n    for c in s:\n        if c == '[':\n            open_brackets += 1\n        elif open_brackets == 0:\n            swaps += 1\n            open_brackets += 1\n        else:\n            open_brackets -= 1\n    return swaps"], [0.9086722731590271, "    for c in s:\n        if c == '[':\n            open_brackets += 1\n        elif open_brackets == 0:\n            swaps += 1\n            open_brackets += 1\n        else:\n            open_brackets -= 1"], [0.9018416404724121, "        if c == '[':\n            open_brackets += 1\n        elif open_brackets == 0:\n            swaps += 1\n            open_brackets += 1\n        else:\n            open_brackets -= 1"], [0.897976279258728, "        elif open_brackets == 0:\n            swaps += 1\n            open_brackets += 1\n        else:\n            open_brackets -= 1"], [0.8947635889053345, "    count_round = count_curly = count_square = 0\n    stack = []\n    for bracket in string:\n        stack.append(bracket)\n        if len(stack) < 2:\n            continue\n        if stack[-2] == '(' and stack[-1] == ')':\n            count_round += 1\n            stack = stack[:-2]\n        elif stack[-2] == '[' and stack[-1] == ']':\n            count_square += 1\n            stack = stack[:-2]\n        elif stack[-2] == '{' and stack[-1] == '}':\n            count_curly += 1\n            stack = stack[:-2]\n    return (count_round, count_square, count_curly)"], [0.8946185111999512, "    ending_brackets = 0\n    for i in string:\n        if i == ')':\n            ending_brackets += 1\n    return ending_brackets"], [0.8911243677139282, "    stack = []\n    invalid_count = 0\n    for char in string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                invalid_count += 1\n    invalid_count += len(stack)\n    return invalid_count"], [0.8884943723678589, "    count = 0\n    stack = []\n    for c in string:\n        if c == '(' or c == '{':\n            stack.append(c)\n        elif c == ')' or c == '}':\n            if stack:\n                stack.pop()\n        elif not stack and c == char:\n            count += 1\n    return count"], [0.8847668766975403, "    count = 0\n    stack = []\n    for c in input_string:\n        if c == '(':\n            stack.append(c)\n        elif c == ')' and stack:\n            stack.pop()\n        elif c == char and len(stack) == 1:\n            count += 1\n    return count"], [0.8845423460006714, "    stack = []\n    count = 0\n    for p in s:\n        if p == '(':\n            stack.append(p)\n        elif p == ')':\n            if stack:\n                stack.pop()\n            else:\n                count += 1\n    count += len(stack)\n    return count"]]}
{"task_id": "MBPP/376", "problem": [[0.939914345741272, "    decimal_number = int(hex_number, 16)\n    if decimal_number % 2 == 0:\n        print(f'The hex number {hex_number} is Even.')\n    else:\n        print(f'The hex number {hex_number} is Odd.')"], [0.9399102926254272, "    decimal_number = int(hex_number, 16)\n    if decimal_number % 2 == 0:\n        print(f'The hex number {hex_number} is Even.')\n    else:\n        print(f'The hex number {hex_number} is Odd.')"], [0.9355310201644897, "    if decimal_number % 2 == 0:\n        print(f'The hex number {hex_number} is Even.')\n    else:\n        print(f'The hex number {hex_number} is Odd.')"], [0.9354998469352722, "    if decimal_number % 2 == 0:\n        print(f'The hex number {hex_number} is Even.')\n    else:\n        print(f'The hex number {hex_number} is Odd.')"], [0.9292422533035278, "    decimal_num = int(num, 16)\n    if decimal_num % 2 == 0:\n        return 'Even'\n    else:\n        return 'Odd'"], [0.9167020916938782, "    hex_to_dec_map = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15, 'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 'f': 15}\n    last_hex_digit = hex_string[-1]\n    last_dec_digit = hex_to_dec_map[last_hex_digit]\n    odd_or_even = 'EVEN' if last_dec_digit % 2 == 0 else 'ODD'\n    return (odd_or_even, last_dec_digit)"], [0.9091389179229736, "    if len(string) % 2 == 0:\n        print('The string is even.')\n    else:\n        print('The string is odd.')"], [0.9091389179229736, "    if len(string) % 2 == 0:\n        print('The string is even.')\n    else:\n        print('The string is odd.')"], [0.9031129479408264, "    elif int(num) & 1 == 0:\n        return 'Even'\n    else:\n        return 'Odd'"]]}
{"task_id": "MBPP/377", "problem": [[0.9246453046798706, "    p = 0\n    while 1 << p + 1 <= n:\n        p += 1\n    return p"], [0.9171430468559265, "    while power <= n:\n        power *= 2"], [0.9170946478843689, "    return math.ceil(math.log2(n))"], [0.9167031049728394, "    if math.log2(n).is_integer():\n        return math.log2(n)\n    else:\n        return 'The number is not an exponent of two.'"], [0.9162672758102417, "    log = 0\n    while n > 1:\n        n = n >> 1\n        log += 1\n    return log"], [0.9161534905433655, "    if not isinstance(n, int):\n        raise ValueError('Input must be an integer')\n    if math.log2(n).is_integer():\n        return math.log2(n)\n    else:\n        return 'The number is not an exponent of two.'"], [0.9150974154472351, "    while n % 2 == 0:\n        n //= 2"], [0.9150974154472351, "    while n % 2 == 0:\n        n //= 2"], [0.9146157503128052, "    return math.log2(n) + 1"], [0.9132301211357117, "    x = 1\n    while n > x:\n        x = x * 2 + 1\n    return x - n"]]}
{"task_id": "MBPP/378", "problem": [[0.9490318894386292, "    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"], [0.9490318894386292, "    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"], [0.9490266442298889, "    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"], [0.9490266442298889, "    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"], [0.949022650718689, "    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"], [0.949022650718689, "    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"], [0.9490146040916443, "    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"], [0.9490146040916443, "    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"], [0.9490138292312622, "    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"], [0.9490138292312622, "    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)"]]}
{"task_id": "MBPP/379", "problem": [[0.8939078450202942, "    output_string = []\n    words = input_string.split()\n    for word in words:\n        output_string.append(prefix + word)\n    return ' '.join(output_string)"], [0.8924462795257568, "    if not isinstance(prepend_str, str) or not isinstance(end_str, str):\n        raise ValueError('First and third arguments must be strings.')\n    if not isinstance(l, list):\n        raise ValueError('Second argument must be a list.')\n    result = []\n    for i in l:\n        if isinstance(i, str):\n            result.append(prepend_str + i + end_str)\n        else:\n            raise ValueError('Elements in the list must be strings.')\n    return result"], [0.8917300701141357, "    new_list_of_strings = []\n    for string in list_of_strings:\n        new_string = string + string[0]\n        new_list_of_strings.append(new_string)\n    return new_list_of_strings"], [0.890588104724884, "    modified_list = []\n    for item in lst:\n        modified_list.append(str(num) + item)\n    return modified_list"], [0.8885721564292908, "    lst.insert(0, element)\n    return lst"], [0.8853902816772461, "    new_list = [add_string + str(item) for item in list(list_string)]\n    return new_list"], [0.885117769241333, "    return [x + string for x in my_list]"], [0.8841792941093445, "    return [x + char for x in my_list]"], [0.8841226100921631, "    words = string.split(' ')\n    result = []\n    for word in words:\n        result.append(prefix + word)\n    return ' '.join(result)"], [0.8827763199806213, "    if new_element in my_list:\n        raise ValueError('Element already exists.')\n    else:\n        my_list.insert(0, new_element)\n        return my_list"]]}
{"task_id": "MBPP/380", "problem": [[0.9198483228683472, "    nested_dict = {}\n    for l1, l2, l3 in zip(list1, list2, list3):\n        if isinstance(l3, (list, tuple)) and (not isinstance(l3, str)):\n            l3 = {i: v for i, v in enumerate(l3)}\n        nested_dict[l1] = {l2: l3}\n    return nested_dict"], [0.912442147731781, "    for l1, l2, l3 in zip(list1, list2, list3):\n        if isinstance(l3, (list, tuple)) and (not isinstance(l3, str)):\n            l3 = {i: v for i, v in enumerate(l3)}\n        nested_dict[l1] = {l2: l3}"], [0.9120149612426758, "                for j in range(len(list_one[i])):\n                    nested_dict[j] = (list_one[i][j], list_two[i][j])"], [0.9120149612426758, "                for j in range(len(list_one[i])):\n                    nested_dict[j] = (list_one[i][j], list_two[i][j])"], [0.9115512371063232, "    nested_dict = {}\n    for item in lst:\n        key, value, inner_item = item\n        nested_dict[key] = {value: {inner_item[0]: inner_item[1]}}\n    return nested_dict"], [0.9091472625732422, "                for j in range(min(len(list_one[i]), len(list_two[i]))):\n                    nested_dict[j] = (list_one[i][j], list_two[i][j])"], [0.9082778692245483, "    for key, value in nested_dict.items():\n        if isinstance(value, list):\n            nested_dict[key] = convert_nested_list_to_dict(value)\n    return nested_dict"], [0.9061629176139832, "    nested_dict = {}\n    for item in nested_list:\n        key = item[0]\n        value = item[1]\n        if isinstance(value, dict):\n            nested_dict[key] = convert_nested_dict(value)\n        else:\n            nested_dict[key] = value\n    return nested_dict"], [0.9057766795158386, "    if len(keys) != len(values):\n        return 'Error: Inconsistent lengths of keys or values.'\n    nested_dict = {k[0]: {k[1]: v[1]} for k, v in zip(keys, values)}\n    return nested_dict"], [0.9057608842849731, "    if len(keys) != len(values):\n        return 'Error: Inconsistent lengths of keys or values.'\n    nested_dict = {k[0]: {k[1]: v[1]} for k, v in zip(keys, values)}\n    return nested_dict"]]}
{"task_id": "MBPP/381", "problem": [[0.8997747898101807, "        if sum % 5 == 0:\n            return sum"], [0.8954272270202637, "    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    fib_n_minus_1 = fibonacci_sum(n - 1)\n    fib_n_minus_2 = fibonacci_sum(n - 2)\n    current_fib = fib_n_minus_1 + fib_n_minus_2\n    if current_fib % 5 == 0:\n        return fib_n_minus_1 + fib_n_minus_2\n    else:\n        return current_fib + fib_n_minus_1 + fib_n_minus_2"], [0.8941035866737366, "    power_of_x = [x ** (i + 1) for i in range(5)]\n    return sum(power_of_x)"], [0.8926419019699097, "    elif n % 2 == 0:\n        b = 2 ** (n.bit_length() - 1)\n        return 3 * A(n // 2) + 5 * A(n - b)\n    else:\n        return A(n // 2)"], [0.8919816613197327, "    max_sum = current_sum = 0\n    max_sum = max(max_sum, current_sum)\n    max_sum = max(max_sum, current_sum)\n    max_sum = max(max_sum, current_sum)\n    max_sum = max(max_sum, current_sum)\n    max_sum = max(max_sum, current_sum)\n    max_sum = max(max_sum, current_sum)\n    return max_sum"], [0.8898497223854065, "    if n == 0:\n        return 0\n    nums = [0] * (n + 1)\n    nums[1] = 1\n    for i in range(2, n + 1):\n        nums[i] = nums[i // 2] if i % 2 == 0 else nums[i // 2] + nums[i // 2 + 1]\n    return max(nums)"], [0.888695240020752, "        if num % 5 == 0:\n            return num"], [0.8886136412620544, "    while n >= 5:\n        n //= 5\n        count += n"], [0.8885824680328369, "    while n >= 5:\n        n //= 5\n        count += n"], [0.8885804414749146, "    while n >= 5:\n        n //= 5\n        count += n"]]}
{"task_id": "MBPP/382", "problem": [[0.9074091911315918, "    max_len = 0\n    longest_string = ''\n    for string in list:\n        if len(string) > max_len:\n            max_len = len(string)\n            longest_string = string\n    print(longest_string)"], [0.9047771692276001, "    return max(list, key=len)"], [0.9020928144454956, "    longest_string = ''\n    for word in list1:\n        if len(word) > len(longest_string):\n            longest_string = word\n    return longest_string"], [0.9003983736038208, "    max_length = -1\n    index = -1\n    for i in range(len(lst)):\n        if len(lst[i]) > max_length:\n            max_length = len(lst[i])\n            index = i\n    return (max_length, index)"], [0.8998948931694031, "    if not names:\n        return ([], 'The list is empty.')\n    lengths = [len(name) for name in names]\n    max_length = max(lengths)\n    longest_names = [name for name in names if len(name) == max_length]\n    if len(longest_names) > 1:\n        result = 'The longest names are ' + ', '.join(longest_names) + ' with a length of ' + str(max_length) + '.'\n    else:\n        result = 'The longest name is ' + longest_names[0] + ' with a length of ' + str(max_length) + '.'\n    return (lengths, result)"], [0.8991974592208862, "    max_sum = None\n    max_list = None\n    for lst in list_of_lists:\n        if max_sum is None or sum(lst) > max_sum:\n            max_sum = sum(lst)\n            max_list = lst\n    return max_list"], [0.8991069197654724, "    return max(list1, key=len)"], [0.8988555669784546, "    for sublist in list:\n        maxLength = max(maxLength, len(sublist))"], [0.8983852863311768, "    longest = max(input_list, key=len)\n    return longest"], [0.8983702659606934, "    longest = max(input_list, key=len)\n    return longest"]]}
{"task_id": "MBPP/383", "problem": [[0.8926525115966797, "    distinct_elements = []\n    for element in collection:\n        if isinstance(element, tuple):\n            if element not in distinct_elements:\n                distinct_elements.append(element)\n    return distinct_elements"], [0.8894618153572083, "    for element in collection:\n        if isinstance(element, tuple):\n            if element not in distinct_elements:\n                distinct_elements.append(element)"], [0.8892388939857483, "    seen = set()\n    duplicates = set()\n    for item in input_tuple:\n        if item in seen:\n            duplicates.add(item)\n        seen.add(item)\n    return (len(duplicates) > 0, duplicates)"], [0.8886123895645142, "        if isinstance(element, tuple):\n            if element not in distinct_elements:\n                distinct_elements.append(element)"], [0.8882184028625488, "        if is_distinct(i):\n            count += 1"], [0.8856731653213501, "    distinct_list = []\n    for item in lst:\n        if item not in distinct_list:\n            distinct_list.append(item)\n    return distinct_list"], [0.8855116367340088, "        if element not in distinct_list:\n            distinct_list.append(element)"], [0.885132908821106, "    for i in my_list:\n        if i not in distinct_list:\n            distinct_list.append(i)"], [0.8847313523292542, "    if len(tup) == len(set(tup)):\n        return False\n    else:\n        return True"], [0.8847313523292542, "    if len(tup) == len(set(tup)):\n        return False\n    else:\n        return True"]]}
{"task_id": "MBPP/384", "problem": [[0.935464084148407, "    d = {}\n    for ch in s:\n        if ch in d:\n            d[ch] += 1\n        else:\n            d[ch] = 1\n    for ch in s:\n        if d[ch] == 1:\n            return ch\n    return 'All characters are repeating'"], [0.9346743822097778, "    char_count = {}\n    for char in reversed(input_string):\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in reversed(input_string):\n        if char_count[char] == 1:\n            return char\n    return 'All are Repeated'"]]}
{"task_id": "MBPP/385", "problem": [[0.923841118812561, "    if len(string) < 2:\n        return False\n    return string[0] == string[-1]"], [0.9086869955062866, "    output_list = []\n    for string in input_list:\n        if string[0] == string[-1]:\n            output_list.append(string)\n    return output_list"], [0.9086869955062866, "    output_list = []\n    for string in input_list:\n        if string[0] == string[-1]:\n            output_list.append(string)\n    return output_list"], [0.9033020734786987, "    word_list = my_string.split()\n    for word in word_list:\n        if word[0] != word[-1]:\n            return False\n    return True"], [0.9031336307525635, "    my_string = ''.join((char for char in input_str if char not in string.punctuation))\n    words = my_string.split()\n    count = 0\n    for word in words:\n        if word[0].lower() == word[-1].lower():\n            count += 1\n    return (count == len(words), count)"], [0.9028763771057129, "    input_string = input_string.lower()\n    start = 0\n    end = len(input_string) - 1\n    while start < end:\n        while not input_string[start].isalnum():\n            start += 1\n            if start >= end:\n                break\n        while not input_string[end].isalnum():\n            end -= 1\n            if start >= end:\n                break\n        if input_string[start] != input_string[end]:\n            return False\n        start += 1\n        end -= 1\n    return True"], [0.9028581380844116, "    exclude_chars = set(exclude_chars) if exclude_chars else set()\n    for word in input_string.split():\n        if any((ch in exclude_chars for ch in word)):\n            continue\n        if word[0] != word[-1]:\n            return False\n    return True"], [0.9018889665603638, "    for string in input_list:\n        if string[0] == string[-1]:\n            output_list.append(string)"], [0.9018620848655701, "    for string in input_list:\n        if string[0] == string[-1]:\n            output_list.append(string)"], [0.9018408060073853, "    cleaned_arr = [str(elem).lower() for elem in arr if str(elem).isalnum()]\n    length = len(cleaned_arr)\n    if length % 2 == 1:\n        middle_index = length // 2\n        left = cleaned_arr[:middle_index]\n        right = cleaned_arr[middle_index + 1:]\n    else:\n        left = cleaned_arr[:length // 2]\n        right = cleaned_arr[length // 2:]\n    if left and all((elem == left[0] for elem in left)) and all((elem == right[0] for elem in right)):\n        return True\n    return False"]]}
{"task_id": "MBPP/386", "problem": [[0.9354052543640137, "    elif num3 > num2:\n        median = num2\n    elif num3 > num1:\n        median = num3\n    else:\n        median = num1"], [0.9337091445922852, "    elif num3 > num1:\n        median = num3\n    else:\n        median = num1"], [0.931890070438385, "        if num3 > num1:\n            median = num1\n        elif num3 > num2:\n            median = num3\n        else:\n            median = num2"], [0.9298149347305298, "    numbers = [a, b, c]\n    numbers.sort()\n    median_index = len(numbers) // 2\n    return numbers[median_index]"], [0.9275199174880981, "    if num1 > num2:\n        if num3 > num1:\n            median = num1\n        elif num3 > num2:\n            median = num3\n        else:\n            median = num2\n    elif num3 > num2:\n        median = num2\n    elif num3 > num1:\n        median = num3\n    else:\n        median = num1"], [0.9274661540985107, "        elif num3 > num2:\n            median = num3\n        else:\n            median = num2"], [0.926321268081665, "    if num1 > num2:\n        if num3 > num1:\n            median = num1\n        elif num3 > num2:\n            median = num3\n        else:\n            median = num2\n    elif num3 > num2:\n        median = num2\n    elif num3 > num1:\n        median = num3\n    else:\n        median = num1\n    return median"], [0.9215506315231323, "    elif b <= a <= c or c <= a <= b:\n        median = a\n    else:\n        median = c"], [0.9214219450950623, "    if a <= b <= c or c <= b <= a:\n        median = b\n    elif b <= a <= c or c <= a <= b:\n        median = a\n    else:\n        median = c\n    return median"], [0.9211783409118652, "    if a <= b <= c or c <= b <= a:\n        median = b\n    elif b <= a <= c or c <= a <= b:\n        median = a\n    else:\n        median = c"]]}
{"task_id": "MBPP/387", "problem": []}
{"task_id": "MBPP/388", "problem": [[0.8992046117782593, "    xor_result = boolean1 ^ boolean2\n    binary_representation = format(int(xor_result), '01b')\n    return (xor_result, binary_representation)"], [0.8945474624633789, "    result = []\n    for i in range(len(a)):\n        result.append(a[i] ^ b[i])\n    return result"], [0.8945187330245972, "    a_int = int(a, 2)\n    b_int = int(b, 2)\n    xor_result = a_int ^ b_int\n    return format(xor_result, 'b')"], [0.8904866576194763, "    a = int(a, 2)\n    b = int(b, 2)\n    result = a ^ b\n    return format(result, 'b')"], [0.8895264267921448, "    for i in range(len(a)):\n        result.append(a[i] ^ b[i])"], [0.8888170719146729, "    xor_result = int(a, 2) ^ int(b, 2)\n    xor_result_str = format(xor_result, 'b').zfill(len(a))\n    return xor_result_str"], [0.8886802792549133, "    n = max(len(num1), len(num2))\n    num1 = num1.zfill(n)\n    num2 = num2.zfill(n)\n    num1 = int(num1, 2)\n    num2 = int(num2, 2)\n    xor_result = num1 ^ num2\n    xor_binary = bin(xor_result)[2:].zfill(n)\n    xor_list = [int(bit) for bit in xor_binary]\n    return xor_list"], [0.8881639242172241, "    result = []\n    for i in range(len(a)):\n        bit_a = int(a[i])\n        bit_b = int(b[i])\n        xor_result = bit_a ^ bit_b\n        result.append(str(xor_result))\n    return result"], [0.8876113295555115, "    bitwise_and = a & b\n    bitwise_or = a | b\n    bitwise_xor = a ^ b\n    return [bitwise_and, bitwise_or, bitwise_xor]"], [0.8835170865058899, "    bin1 = bin(int(num1, 16))[2:].zfill(4)\n    bin2 = bin(int(num2, 16))[2:].zfill(4)\n    aggregate = 0\n    for b1, b2 in zip(bin1, bin2):\n        xorResult = int(b1) ^ int(b2)\n        aggregate += xorResult\n    return aggregate"]]}
{"task_id": "MBPP/389", "problem": [[0.9134389162063599, "    frequency_list = []\n    for item in my_list:\n        if item not in frequency_list:\n            frequency_list.append(item)\n    for i in range(0, len(frequency_list)):\n        frequency_list[i] = (frequency_list[i], my_list.count(frequency_list[i]))\n    return frequency_list"], [0.9047050476074219, "    counter = Counter(input_list)\n    unique_elements = list(OrderedDict.fromkeys(input_list))\n    output_list = [(element, counter[element]) for element in unique_elements]\n    return output_list"], [0.9044874310493469, "    freq_dict = {}\n    for item in list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict"], [0.9039968252182007, "    unique_elements = []\n    element_frequency = {}\n    for num in list_of_nums:\n        if num not in unique_elements:\n            unique_elements.append(num)\n            element_frequency[num] = 1\n        else:\n            element_frequency[num] += 1\n    return (unique_elements, element_frequency)"], [0.9036407470703125, "    for i in range(0, len(frequency_list)):\n        frequency_list[i] = (frequency_list[i], my_list.count(frequency_list[i]))"], [0.9026572704315186, "    frequency = {}\n    for item in my_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency"], [0.9025712013244629, "    lst = flatten(lst)\n    counts = dict()\n    for sublist in lst:\n        if isinstance(sublist, list):\n            sublist = tuple(flatten(sublist))\n        if isinstance(sublist, tuple):\n            counts[sublist] = counts.get(sublist, 0) + 1\n    return counts"], [0.9018157124519348, "    count_obj = Counter(input_tuple)\n    my_dict = dict(count_obj)\n    unique_dict = {key: 1 for key in my_dict.keys()}\n    return (unique_dict, my_dict)"], [0.9017921686172485, "    count_obj = Counter(input_tuple)\n    my_dict = dict(count_obj)\n    unique_dict = {key: 1 for key in my_dict.keys()}\n    return (unique_dict, my_dict)"], [0.90166175365448, "    lst = [tuple(flatten(sublist)) for sublist in lst if isinstance(sublist, list)]\n    return {t: lst.count(t) for t in set(lst)}"]]}
{"task_id": "MBPP/390", "problem": [[0.8935002684593201, "    for a, b in tpl1:\n        for c, d in tpl2:\n            return (a + c, b + d)"], [0.8935002684593201, "    for a, b in tpl1:\n        for c, d in tpl2:\n            return (a + c, b + d)"], [0.8911552429199219, "    additions = []\n    for i in range(len(list1)):\n        additions.append(list1[i] + list2[i])\n    return additions"], [0.8900386095046997, "        for c, d in tpl2:\n            return (a + c, b + d)"], [0.8887782096862793, "    sum = 0\n    for sub_list in nested_list:\n        for element in sub_list:\n            sum += element\n    return sum"], [0.8887152671813965, "    result = [x + y for x, y in zip(arr1, arr2)]\n    return result"], [0.8885400295257568, "    for i in tuples:\n        if isinstance(i, tuple):\n            cum_sum = recursive_sum(i, cum_sum)\n        elif isinstance(i, (int, float)):\n            cum_sum += i\n    return cum_sum"], [0.88801109790802, "    result = []\n    for i in range(len(arr1)):\n        result.append([])\n        for j in range(len(arr1[0])):\n            result[i].append(arr1[i][j] + arr2[i][j])\n    return result"], [0.8879587650299072, "    result = []\n    for row1, row2 in zip(matrix1, matrix2):\n        result_row = []\n        for element1, element2 in zip(row1, row2):\n            result_row.append(element1 + element2)\n        result.append(result_row)\n    return result"], [0.8867958784103394, "    total = 0\n    for sublist in nested_list:\n        for item in sublist:\n            total += item\n    return total"]]}
{"task_id": "MBPP/391", "problem": [[0.8920645713806152, "    while r > 0:\n        num = num % p * (n % p) % p\n        n -= 1\n        r -= 1"], [0.8919825553894043, "    num = 1\n    while r > 0:\n        num = num % p * (n % p) % p\n        n -= 1\n        r -= 1\n    den = 1\n    r = 7\n    while r > 0:\n        den = den % p * (r % p) % p\n        r -= 1\n    den_inv = modInverse(den, p)\n    return num * den_inv % p"], [0.8900355696678162, "    elif n == 1:\n        return 1 % m"], [0.890030026435852, "    elif n == 1:\n        return 1 % m"], [0.8894479274749756, "    return power(n, p - 2, p)"], [0.8871378898620605, "    for i in range(k):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p"], [0.8838740587234497, "    dp = [0] * (p + 1)\n    dp[0] = 1\n    for i in range(1, p + 1):\n        dp[i] = dp[i - 1] * i % q\n    return dp[p]"], [0.883350133895874, "    if r == 0:\n        return int(n == 0)"], [0.883350133895874, "    if r == 0:\n        return int(n == 0)"], [0.8831297159194946, "    while r > 0:\n        den = den % p * (r % p) % p\n        r -= 1"]]}
{"task_id": "MBPP/392", "problem": [[0.9374516010284424, "    pattern = re.compile('http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\\\\\\\(\\\\\\\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+')\n    match = re.match(pattern, url)\n    if match:\n        print('The URL is valid.')\n    else:\n        print('The URL is invalid.')"], [0.9341697692871094, "    if re.match(regex, raw_url) is None:\n        print('Invalid URL')\n    else:\n        print('Valid URL')"], [0.9341510534286499, "    if re.match(regex, raw_url) is None:\n        print('Invalid URL')\n    else:\n        print('Valid URL')"], [0.9338212013244629, "    if pattern.match(url):\n        print('URL is valid')\n    else:\n        print('URL is invalid')"], [0.9331731796264648, "    pattern = re.compile(\"https://www\\\\.[a-z0-9.-]+\\\\.com(/[a-z0-9-._~:/?#@[\\\\\\\\\\\\]!$&\\\\'()*+,;=.]+)*\")\n    if pattern.match(url):\n        print('URL is valid')\n    else:\n        print('URL is invalid')"], [0.9321190118789673, "    if match:\n        print('The URL is valid.')\n    else:\n        print('The URL is invalid.')"], [0.9298532605171204, "    if is_valid_url(url):\n        print('URL is valid.')\n    else:\n        print('URL is not valid.')"], [0.9298514127731323, "    if is_valid_url(url):\n        print('URL is valid.')\n    else:\n        print('URL is not valid.')"], [0.9279637336730957, "    regex = '(?i)\\\\b((?:[a-z][\\\\w-]+:(?:/{1,3}|[a-z0-9%])|www\\\\d{0,3}[.]|[a-z0-9.\\\\-]+[.][a-z]{2,4}/)(?:[^\\\\s()<>]+|\\\\(([^\\\\s()<>]+|(\\\\([^\\\\s()<>]+\\\\)))*\\\\))+(?:\\\\(([^\\\\s()<>]+|(\\\\([^\\\\s()<>]+\\\\)))*\\\\)|[^\\\\s`!()\\\\[\\\\]{};:\\'\\\\\".,<>?\u00ab\u00bb\u201c\u201d\u2018\u2019]))'\n    if re.search(regex, url):\n        return True\n    else:\n        return False"], [0.9268497228622437, "    if not regex.match(url):\n        return (False, 'Invalid URL format.')"]]}
{"task_id": "MBPP/393", "problem": [[0.9251693487167358, "    return min(num1, num2)"], [0.9067959785461426, "    min_number = min(a, b, c)\n    return min_number"], [0.9067547917366028, "    if num1 < num2:\n        return num1\n    else:\n        return num2"], [0.9067547917366028, "    if num1 < num2:\n        return num1\n    else:\n        return num2"], [0.9067513346672058, "    if num1 < num2:\n        return num1\n    else:\n        return num2"], [0.9067513346672058, "    if num1 < num2:\n        return num1\n    else:\n        return num2"], [0.906746506690979, "    if num1 < num2:\n        return num1\n    else:\n        return num2"], [0.906746506690979, "    if num1 < num2:\n        return num1\n    else:\n        return num2"], [0.9067151546478271, "    return min(a, b)"], [0.9067145586013794, "    return min(a, b)"]]}
{"task_id": "MBPP/394", "problem": [[0.9079071283340454, "    if check_presence:\n        return element in my_tuple\n    else:\n        return element not in my_tuple"], [0.9079071283340454, "    if check_presence:\n        return element in my_tuple\n    else:\n        return element not in my_tuple"], [0.9026461839675903, "    if not lst:\n        return False\n    for num in lst:\n        if num == element:\n            return True\n    return False"], [0.9009613394737244, "    if element in lst:\n        return True\n    else:\n        return False"], [0.9009613394737244, "    if element in lst:\n        return True\n    else:\n        return False"], [0.8992576599121094, "    if element in lst:\n        return 'Exists'\n    else:\n        return 'Does not exist'"], [0.8992576599121094, "    if element in lst:\n        return 'Exists'\n    else:\n        return 'Does not exist'"], [0.89921635389328, "    if element in lst:\n        return 'Exists'\n    else:\n        return 'Does not exist'"], [0.89921635389328, "    if element in lst:\n        return 'Exists'\n    else:\n        return 'Does not exist'"], [0.898626446723938, "    if element in mylist:\n        return True\n    return False"]]}
{"task_id": "MBPP/395", "problem": [[0.913273811340332, "    parity = 0\n    while n:\n        parity ^= n & 1\n        n >>= 1\n    return parity"], [0.9110813736915588, "    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    power = 1\n    while power <= n:\n        power *= 2\n    power /= 2\n    return 1 - parity(n - power)"], [0.9100512266159058, "    if n == 0:\n        return 0\n    else:\n        return n & 1 ^ check_parity(n >> 1)"], [0.9100512266159058, "    if n == 0:\n        return 0\n    else:\n        return n & 1 ^ check_parity(n >> 1)"], [0.9100314378738403, "    if n == 0:\n        return 0\n    else:\n        return n & 1 ^ check_parity(n >> 1)"], [0.9100314378738403, "    if n == 0:\n        return 0\n    else:\n        return n & 1 ^ check_parity(n >> 1)"], [0.9097632169723511, "    while n:\n        parity ^= n & 1\n        n >>= 1"], [0.9064509272575378, "    num = abs(num)\n    if num - int(num) != 0:\n        return 'Number is not an integer'\n    elif int(num) & 1 == 0:\n        return 'Even'\n    else:\n        return 'Odd'"], [0.9064494371414185, "    num = abs(num)\n    if num - int(num) != 0:\n        return 'Number is not an integer'\n    elif int(num) & 1 == 0:\n        return 'Even'\n    else:\n        return 'Odd'"], [0.9028930068016052, "    elif int(num) & 1 == 0:\n        return 'Even'\n    else:\n        return 'Odd'"]]}
{"task_id": "MBPP/396", "problem": [[0.9104344844818115, "    num_str = str(n)\n    num_permutations = sorted(set((int(''.join(p)) for p in permutations(num_str))))\n    index = num_permutations.index(n)\n    if index + 1 < len(num_permutations) and num_permutations[index + 1] <= 2 ** 31 - 1:\n        return num_permutations[index + 1]\n    return -1"], [0.901959240436554, "    n = len(num)\n    first_half = num[:(n + 1) // 2]\n    candidates = sorted(set((int(''.join(p)) for p in permutations(first_half))))\n    for c in candidates:\n        c_str = str(c)\n        second_half = c_str[::-1]\n        if n % 2 == 1:\n            second_half = second_half[1:]\n        candidate_str = c_str + second_half\n        if candidate_str > num:\n            return candidate_str\n    return ''"], [0.9019523859024048, "    n = len(num)\n    first_half = num[:(n + 1) // 2]\n    candidates = sorted(set((int(''.join(p)) for p in permutations(first_half))))\n    for c in candidates:\n        c_str = str(c)\n        second_half = c_str[::-1]\n        if n % 2 == 1:\n            second_half = second_half[1:]\n        candidate_str = c_str + second_half\n        if candidate_str > num:\n            return candidate_str\n    return ''"], [0.8988716006278992, "    num_str = str(number)\n    sorted_digits = sorted(num_str, reverse=True)\n    max_num = int(''.join(sorted_digits))\n    return max_num"], [0.8980096578598022, "    n_str = [c for c in str(n)]\n    i = len(n_str) - 1\n    while i > 0:\n        if n_str[i] < n_str[i - 1]:\n            n_str[i - 1] = chr(ord(n_str[i - 1]) - 1)\n            for j in range(i, len(n_str)):\n                n_str[j] = '9'\n        i -= 1\n    return int(''.join(n_str))"], [0.8965716361999512, "    digits = [int(d) for d in str(n)]\n    perm_digits = list(permutations(digits))\n    perm_numbers = sorted([int(''.join(map(str, perm))) for perm in perm_digits])\n    cnt = 0\n    for x in perm_numbers:\n        if x > n and x <= 2 ** 31 - 1:\n            if cnt == 0:\n                smallest_greater = x\n            cnt += 1\n    if cnt == 0:\n        return (-1, 0)\n    else:\n        permutation_cnt = factorial(len(digits)) // (2 * factorial(len(digits) - 2)) - 1\n        return (smallest_greater, min(permutation_cnt, cnt - 1))"], [0.8965632915496826, "    digits = [int(d) for d in str(n)]\n    perm_digits = list(permutations(digits))\n    perm_numbers = sorted([int(''.join(map(str, perm))) for perm in perm_digits])\n    cnt = 0\n    for x in perm_numbers:\n        if x > n and x <= 2 ** 31 - 1:\n            if cnt == 0:\n                smallest_greater = x\n            cnt += 1\n    if cnt == 0:\n        return (-1, 0)\n    else:\n        permutation_cnt = factorial(len(digits)) // (2 * factorial(len(digits) - 2)) - 1\n        return (smallest_greater, min(permutation_cnt, cnt - 1))"], [0.8946132659912109, "    digits = [int(i) for i in str(num)]\n    digits.sort(reverse=True)\n    largest = 0\n    for i in digits:\n        largest = largest * 10 + i\n    return largest"], [0.8939120769500732, "    num_str = list(str(num))\n    last = {int(v): i for i, v in enumerate(num_str)}\n    for i, v in enumerate(num_str):\n        for d in range(9, int(v), -1):\n            if last.get(d, -1) > i:\n                num_str[i], num_str[last[d]] = (num_str[last[d]], num_str[i])\n                return int(''.join(num_str))\n    return num"], [0.8906576633453369, "    for i, v in enumerate(num_str):\n        for d in range(9, int(v), -1):\n            if last.get(d, -1) > i:\n                num_str[i], num_str[last[d]] = (num_str[last[d]], num_str[i])\n                return int(''.join(num_str))"]]}
{"task_id": "MBPP/397", "problem": [[0.9012144804000854, "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for n1 in nums1:\n        for n2 in nums2:\n            if len(heap) < k:\n                heapq.heappush(heap, (-n1 - n2, [n1, n2]))\n            elif n1 + n2 < -heap[0][0]:\n                heapq.heappop(heap)\n                heapq.heappush(heap, (-n1 - n2, [n1, n2]))\n    return [pair for _, pair in heap]"], [0.8998153805732727, "    i = 0\n    j = 0\n    counter = 1\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j] and counter != k:\n            i += 1\n            counter += 1\n        elif arr2[j] < arr1[i] and counter != k:\n            j += 1\n            counter += 1\n        else:\n            return min(arr1[i], arr2[j])\n    while i < len(arr1):\n        if counter != k:\n            i += 1\n            counter += 1\n        else:\n            return arr1[i]\n    while j < len(arr2):\n        if counter != k:\n            j += 1\n            counter += 1\n        else:\n            return arr2[j]"], [0.8979055285453796, "        elif arr2[j] < arr1[i] and counter != k:\n            j += 1\n            counter += 1\n        else:\n            return min(arr1[i], arr2[j])"], [0.8979001045227051, "    pairs = []\n    list1.sort()\n    list2.sort()\n    i = 0\n    j = len(list2) - 1\n    while i < len(list1) and j >= 0:\n        num1 = list1[i]\n        num2 = list2[j]\n        current_sum = num1 + num2\n        if current_sum == k:\n            if abs(num1 - num2) >= threshold:\n                pairs.append((num1, num2))\n            i += 1\n            j -= 1\n        elif current_sum < k:\n            i += 1\n        else:\n            j -= 1\n    return sorted(pairs, key=lambda x: sum(x))"], [0.8973088264465332, "    pairs = []\n    for num1 in list1:\n        for num2 in list2:\n            if num1 != num2 and abs(num1 - num2) >= threshold and (num1 + num2 == k):\n                pairs.append((num1, num2))\n    return pairs"], [0.8951384425163269, "        if arr1[i] < arr2[j] and counter != k:\n            i += 1\n            counter += 1\n        elif arr2[j] < arr1[i] and counter != k:\n            j += 1\n            counter += 1\n        else:\n            return min(arr1[i], arr2[j])"], [0.8938764333724976, "    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j] and counter != k:\n            i += 1\n            counter += 1\n        elif arr2[j] < arr1[i] and counter != k:\n            j += 1\n            counter += 1\n        else:\n            return min(arr1[i], arr2[j])"], [0.8937983512878418, "    for num1 in list1:\n        for num2 in list2:\n            if num1 != num2 and abs(num1 - num2) >= threshold and (num1 + num2 == k):\n                pairs.append((num1, num2))"], [0.8937508463859558, "    merged_array = sorted(A + B)\n    return merged_array[k - 1]"], [0.8926255702972412, "    if not nums1 or not nums2:\n        return []\n    heap = [(nums1[i] + nums2[0], i, 0) for i in range(min(k, len(nums1)))]\n    heapq.heapify(heap)\n    result = []\n    while k > 0 and heap:\n        s, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n        k -= 1\n    return result"]]}
{"task_id": "MBPP/398", "problem": [[0.8975342512130737, "    pair_product = []\n    for i in range(len(arr) - 1):\n        pair_product.append(((arr[i], arr[i + 1]), arr[i] * arr[i + 1]))\n    min_product = min(pair_product, key=lambda x: x[1])\n    return min_product"], [0.8954095840454102, "    products = []\n    for pair in pairs:\n        product = pair[0] * pair[1]\n        products.append(product)\n    return products"], [0.891959547996521, "        if product < min_product:\n            min_product = product"], [0.8907710909843445, "    if len(lst) < 2:\n        return None\n    max_product = float('-inf')\n    max_pair = None\n    for pair in combinations(lst, 2):\n        product = pair[0] * pair[1]\n        if product > max_product:\n            max_product = product\n            max_pair = pair\n    return list(max_pair)"], [0.889107346534729, "    max_product = float('-inf')\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] * lst[j] > max_product:\n                max_product = lst[i] * lst[j]\n                pair = (lst[i], lst[j])\n    return pair"], [0.8876655101776123, "    for pair in combinations(lst, 2):\n        product = pair[0] * pair[1]\n        if product > max_product:\n            max_product = product\n            max_pair = pair"]]}
{"task_id": "MBPP/399", "problem": [[0.9059010744094849, "    min_value = lst[0]\n    for value in lst:\n        if value < min_value:\n            min_value = value\n    return min_value"], [0.9047254920005798, "    minValue = list[0]\n    for i in range(1, len(list)):\n        if list[i] < minValue:\n            minValue = list[i]\n    return minValue"], [0.9045851230621338, "    min_value = float('inf')\n    for arg in args:\n        if arg < min_value:\n            min_value = arg\n    return min_value"], [0.9020658135414124, "    min_val = list[0]\n    for num in list:\n        if num < min_val:\n            min_val = num\n    return min_val"], [0.9020485281944275, "    min_val = list[0]\n    for num in list:\n        if num < min_val:\n            min_val = num\n    return min_val"], [0.9010846614837646, "    try:\n        nums = [abs(num) for num in test_list if type(num) == float or type(num) == int]\n        if len(nums) == 0:\n            return None\n        else:\n            return min(nums)\n    except ValueError:\n        print('Error: List contains invalid values.')\n    except Exception as e:\n        print(f'An error occurred: {e}')"], [0.9010846614837646, "    try:\n        nums = [abs(num) for num in test_list if type(num) == float or type(num) == int]\n        if len(nums) == 0:\n            return None\n        else:\n            return min(nums)\n    except ValueError:\n        print('Error: List contains invalid values.')\n    except Exception as e:\n        print(f'An error occurred: {e}')"], [0.9009236097335815, "    integers = []\n    for arg in args:\n        if isinstance(arg, int):\n            integers.append(arg)\n    if len(integers) == 0:\n        raise Exception('No integers were provided')\n    else:\n        return min(integers)"], [0.9009088277816772, "    integers = []\n    for arg in args:\n        if isinstance(arg, int):\n            integers.append(arg)\n    if len(integers) == 0:\n        raise Exception('No integers were provided')\n    else:\n        return min(integers)"], [0.8998000621795654, "    min_val = input_list[0]\n    for i in range(1, len(input_list)):\n        if input_list[i] < min_val:\n            min_val = input_list[i]\n    return min_val"]]}
{"task_id": "MBPP/400", "problem": [[0.9128379821777344, "    camel_case = ''\n    for word in str.split():\n        camel_case += word.capitalize()\n    return camel_case"], [0.9124648571014404, "    words = snake_case.split('_')\n    camel_case = words[0]\n    for word in words[1:]:\n        camel_case += word.capitalize()\n    return camel_case"]]}
{"task_id": "MBPP/401", "problem": [[0.9250654578208923, "    odd_list = []\n    for num in my_list:\n        if num % 2 != 0:\n            odd_list.append(num)\n    return odd_list"], [0.9242225885391235, "    odd_list = []\n    for number in original_list:\n        if number % 2 != 0:\n            odd_list.append(number)\n    return odd_list"], [0.9222505688667297, "    if not input_list:\n        return 'Input list is empty.'\n    odd_numbers = []\n    for num in input_list:\n        if num % 2 != 0:\n            odd_numbers.append(num)\n    return odd_numbers"], [0.9191235899925232, "    odd_numbers = [num for num in arr if num % 2 != 0]\n    return odd_numbers"], [0.9169495105743408, "    odd_nums = []\n    for num in lst:\n        if num % 2 != 0:\n            odd_nums.append(num)\n    print(odd_nums)"], [0.9162485003471375, "    odd_set = set()\n    for num in lst:\n        if num % 2 != 0:\n            odd_set.add(num)\n    return list(odd_set)"], [0.9156351089477539, "    new_list = []\n    for num in lst:\n        if num % 2 == 0:\n            new_list.append(num)\n    return new_list"], [0.9154279232025146, "    output_list = []\n    for num in input_list:\n        if num % 2 != 0:\n            output_list.append(num)\n    return output_list"]]}
{"task_id": "MBPP/402", "problem": [[0.8945306539535522, "    return [item[n] for item in list_of_lists]"], [0.8762083053588867, "    output_list = []\n    for element in input_list:\n        try:\n            output_list.append(element[index])\n        except IndexError:\n            output_list.append('')\n    return output_list"], [0.8759928941726685, "    elif len(lst) < 5:\n        return 'Error: The list does not have a fifth element.'\n    else:\n        return str(lst[4])"], [0.8745317459106445, "    if len(lst) == 0:\n        return 'Error: The list is empty.'\n    elif len(lst) < 5:\n        return 'Error: The list does not have a fifth element.'\n    else:\n        return str(lst[4])"], [0.8745317459106445, "    if len(lst) == 0:\n        return 'Error: The list is empty.'\n    elif len(lst) < 5:\n        return 'Error: The list does not have a fifth element.'\n    else:\n        return str(lst[4])"], [0.8733774423599243, "    count = 0\n    for i in lst:\n        if isinstance(i, tuple):\n            for j in i:\n                check_number(j)\n                count += 1\n                if count == pos:\n                    return j\n        else:\n            check_number(i)\n            count += 1\n            if count == pos:\n                return i\n    raise ValueError('Position out of range')"], [0.8726248145103455, "    if n > len(lst):\n        return 'Error: n is larger than the number of elements in the list.'\n    else:\n        bubble_sort_desc(lst)\n        return lst[n - 1]"], [0.8726248145103455, "    if n > len(lst):\n        return 'Error: n is larger than the number of elements in the list.'\n    else:\n        bubble_sort_desc(lst)\n        return lst[n - 1]"], [0.8720104098320007, "    if not all((isinstance(t, tuple) for t in tuples)):\n        raise TypeError('All input items must be of type tuple.')\n    elif not isinstance(k, int):\n        raise TypeError('The search key must be an integer.')\n    indices = [i for i, t in enumerate(tuples) if k in t]\n    if not indices:\n        return f\"The integer '{k}' was not found in any tuple.\"\n    else:\n        return indices"], [0.8719978332519531, "    if not all((isinstance(t, tuple) for t in tuples)):\n        raise TypeError('All input items must be of type tuple.')\n    elif not isinstance(k, int):\n        raise TypeError('The search key must be an integer.')\n    indices = [i for i, t in enumerate(tuples) if k in t]\n    if not indices:\n        return f\"The integer '{k}' was not found in any tuple.\"\n    else:\n        return indices"]]}
{"task_id": "MBPP/403", "problem": [[0.9187721014022827, "    for i in lst:\n        if i == value:\n            print('Value is found!')\n            return True\n    print('Value is not found!')\n    return False"], [0.911652147769928, "    for i in lst:\n        if i == value:\n            print('Value is found!')\n            return True"], [0.9113297462463379, "    for elem in arr:\n        if elem == value:\n            return True\n    return False"], [0.9112720489501953, "    for num in arr:\n        if num == value:\n            return True\n    return False"], [0.9106285572052002, "    for i in arr:\n        if i == value:\n            return True\n    return False"], [0.9101925492286682, "    for i in arr:\n        if i == value:\n            return True"], [0.9096227884292603, "    for value in arr:\n        if value == search:\n            return True\n    return False"], [0.9085280895233154, "    for elem in arr:\n        if elem == value:\n            return True"], [0.908448338508606, "    for item in lst:\n        if item == value:\n            return True\n    return False"], [0.9084229469299316, "    found = False\n    for i in range(len(array)):\n        if array[i] == value:\n            found = True\n            break\n    return found"]]}
{"task_id": "MBPP/404", "problem": [[0.9311325550079346, "    max_product = float('-inf')\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] * lst[j] > max_product:\n                max_product = lst[i] * lst[j]\n                pair = (lst[i], lst[j])\n    return pair"], [0.9272819757461548, "    max_product = 0\n    max_elems = [0, 0]\n    for i in range(len(arr)):\n        left_elem = arr[i]\n        for j in range(i + 1, len(arr)):\n            right_elem = arr[j]\n            product = left_elem * right_elem\n            if product > max_product:\n                max_product = product\n                max_elems = [left_elem, right_elem]\n    return (max_product, max_elems)"], [0.9254513382911682, "    if len(array) < 2:\n        return None\n    max_product = array[0] * array[1]\n    max_pair = (array[0], array[1])\n    for i in range(len(array)):\n        for j in range(i + 1, len(array)):\n            product = array[i] * array[j]\n            if product > max_product:\n                max_product = product\n                max_pair = (array[i], array[j])\n    return list(max_pair)"], [0.921266496181488, "    if len(lst) < 2:\n        return None\n    max_product = float('-inf')\n    max_pair = None\n    for pair in combinations(lst, 2):\n        product = pair[0] * pair[1]\n        if product > max_product:\n            max_product = product\n            max_pair = pair\n    return list(max_pair)"], [0.9198688268661499, "    nums.sort(reverse=True)\n    max_product = 0\n    result_pair = ()\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n                result_pair = (min(nums[i], nums[j]), max(nums[i], nums[j]))\n    return result_pair"], [0.917944073677063, "    for pair in combinations(lst, 2):\n        product = pair[0] * pair[1]\n        if product > max_product:\n            max_product = product\n            max_pair = pair"], [0.9177537560462952, "    for i in range(len(array)):\n        for j in range(i + 1, len(array)):\n            product = array[i] * array[j]\n            if product > max_product:\n                max_product = product\n                max_pair = (array[i], array[j])"], [0.9167314767837524, "    lst.sort()\n    product_1 = lst[0] * lst[1]\n    product_2 = lst[-1] * lst[-2]\n    if product_1 > product_2:\n        return [lst[0], lst[1]]\n    else:\n        return [lst[-1], lst[-2]]"], [0.9163618087768555, "    max_prod = None\n    result = None\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if max_prod is None or nums[i] * nums[j] > max_prod:\n                max_prod = nums[i] * nums[j]\n                result = [nums[i], nums[j]]\n    return result"], [0.9163587093353271, "    max_prod = None\n    result = None\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if max_prod is None or nums[i] * nums[j] > max_prod:\n                max_prod = nums[i] * nums[j]\n                result = [nums[i], nums[j]]\n    return result"]]}
{"task_id": "MBPP/405", "problem": [[0.8996219635009766, "    if index >= len(arr):\n        return 0\n    if index == 2:\n        return max(arr[index] + arr[index - 1] + arr[index - 2], 0)\n    return arr[index] + sum_of_first_three(arr, index + 1)"], [0.8988720178604126, "    for num in nums:\n        dp = [max(dp[i], num + dp[(i - num) % 3]) for i in range(3)]"], [0.8963720202445984, "    max1 = max(a, b)\n    max2 = max(b, c)\n    if max1 > max2:\n        return max1 + max2\n    else:\n        return max2 + max(max2, a)"], [0.8962657451629639, "    dp = [0, float('-inf'), float('-inf')]\n    for num in nums:\n        dp = [max(dp[i], num + dp[(i - num) % 3]) for i in range(3)]\n    return dp[0]"], [0.8949109315872192, "    lst.sort()\n    running_sum = 0\n    for i in range(len(lst)):\n        running_sum += lst[i]\n    if running_sum % 3 == 0:\n        return running_sum\n    return largestMultipleOf3(lst[:-1])"], [0.894342303276062, "    if len(arr) == 0:\n        return 0\n    return max(arr[0] + max_no_adjacent_sum(arr[2:]), max_no_adjacent_sum(arr[1:]))"], [0.8937054872512817, "    dp = [0, 0, 0]\n    for num in nums:\n        temp = dp[:]\n        for s in temp:\n            dp[(s + num) % 3] = max(dp[(s + num) % 3], s + num)\n    return dp[0]"], [0.8936946392059326, "    dp = [0, 0, 0]\n    for num in nums:\n        temp = dp[:]\n        for s in temp:\n            dp[(s + num) % 3] = max(dp[(s + num) % 3], s + num)\n    return dp[0]"], [0.8933225870132446, "    total_sum = 0\n    for i in range(len(array)):\n        if array[i] % 3 == 0:\n            for j in range(i + 1, len(array) + 1):\n                current_sum = sum(array[i:j])\n                if current_sum <= limit:\n                    total_sum = max(total_sum, current_sum)\n                else:\n                    break\n    return total_sum"], [0.8932834267616272, "    elements = []\n    for i in range(len(lst) - 2):\n        for j in range(i + 1, len(lst) - 1):\n            for k in range(j + 1, len(lst)):\n                elements.append(lst[i] + lst[j] + lst[k])\n    return max(elements)"]]}
{"task_id": "MBPP/406", "problem": [[0.8976683616638184, "    list_of_sets = [set(lst) for lst in list_of_lists]\n    common_set = set.intersection(*list_of_sets)\n    common_list = list(common_set)\n    return common_list"], [0.8955215215682983, "    if not lists:\n        return []\n    common_elements = lists[0]\n    for lst in lists[1:]:\n        common_elements = [elem for elem in common_elements if elem in lst]\n    return common_elements"], [0.8947149515151978, "    minimum_length = min([len(array) for array in arrays])\n    common_elements = []\n    for i in range(minimum_length):\n        element = arrays[0][i]\n        if all((array[i] == element for array in arrays)):\n            common_elements.append(element)\n    return common_elements"], [0.8930193781852722, "    result = []\n    for i in list1:\n        if i in tuple1:\n            result.append(i)\n    return result"], [0.8923964500427246, "    try:\n        result = []\n        for sub_list in lists:\n            if sub_list:\n                first = sub_list[0]\n                if all((elem == first for elem in sub_list)):\n                    result.append(first)\n                else:\n                    result.append(None)\n            else:\n                result.append(None)\n        return result\n    except TypeError:\n        return 'Error: The list elements should be of the same data types.'"], [0.8923964500427246, "    try:\n        result = []\n        for sub_list in lists:\n            if sub_list:\n                first = sub_list[0]\n                if all((elem == first for elem in sub_list)):\n                    result.append(first)\n                else:\n                    result.append(None)\n            else:\n                result.append(None)\n        return result\n    except TypeError:\n        return 'Error: The list elements should be of the same data types.'"], [0.8917306661605835, "    if len(lists) < 2:\n        return []\n    common_elements = set(lists[0])\n    for lst in lists[1:]:\n        common_elements.intersection_update(lst)\n    return list(common_elements)"], [0.8914738893508911, "    common = []\n    for i in lst1:\n        for j in lst2:\n            if i == j:\n                common.append(i)\n                break\n    return common"], [0.8914262652397156, "    common_elements = set(list_of_arrays[0])\n    for array in list_of_arrays:\n        common_elements.intersection_update(array)\n    return list(common_elements)"], [0.8913644552230835, "    commons = []\n    for i in range(len(list_of_lists)):\n        commons = list(set(commons).intersection(list_of_lists[i]))\n    return commons"]]}
{"task_id": "MBPP/407", "problem": [[0.9076236486434937, "    for sublist in list:\n        maxLength = max(maxLength, len(sublist))"], [0.9056767821311951, "            elif end - start + 1 == max_length:\n                max_sublists.append((start, end))"], [0.9031011462211609, "            if sub_length > max_length:\n                max_length = sub_length\n                max_string = sub_string"], [0.9007863998413086, "                if len(sublist) > len(longest):\n                    longest = sublist"], [0.9005072712898254, "    distinct_numbers = set(sequence)\n    count_flag = 0\n    max_seq_len = 0\n    max_seq_number = 0\n    for number in distinct_numbers:\n        current_count_flag = 0\n        current_seq_len = 0\n        for num in sequence:\n            if number == num:\n                current_count_flag += 1\n                current_seq_len += 1\n                if current_count_flag > count_flag:\n                    count_flag = current_count_flag\n                    max_seq_len = current_seq_len\n                    max_seq_number = number\n    return (max_seq_len, max_seq_number)"], [0.8998709321022034, "    max_length = max((len(sublist) for sublist in lst))\n    index_of_longest = next((i for i, sublist in enumerate(lst) if len(sublist) == max_length))\n    return (max_length, index_of_longest)"]]}
{"task_id": "MBPP/408", "problem": [[0.9055952429771423, "    rounded_list = [round(x, 2) for x in my_list]\n    return rounded_list"], [0.9054630994796753, "    total = 0\n    count = 0\n    for num in lst:\n        total += num\n        count += 1\n    average = total / count\n    decimal_part = average - int(average)\n    if decimal_part < 0.5:\n        rounded_average = int(average)\n    else:\n        rounded_average = int(average) + 1\n    return rounded_average"], [0.899018406867981, "    total_sum = 0\n    for number in numbers:\n        total_sum += number\n    mean = total_sum / len(numbers)\n    mean_rounded = round(mean, 2)\n    return mean_rounded"], [0.8989114761352539, "    sum = 0\n    for x in list:\n        sum += x\n    return sum"], [0.8988152742385864, "    total = 0\n    for num in lst:\n        total += num\n    return round(total / len(lst), 2)"], [0.898614764213562, "    for num in numbers:\n        if not isinstance(num, int) or num < 0:\n            raise ValueError('All numbers must be positive integers')\n    sum_result = sum(numbers)\n    rounded_sum = round(sum_result)\n    return rounded_sum"], [0.8984681963920593, "    return sum([num * 2 for num in myList])"], [0.8977084755897522, "    rounded_array = []\n    for num in arr:\n        rounded_num = int(num)\n        if num - rounded_num > 0.5:\n            rounded_num += 1\n        rounded_array.append(rounded_num)\n    return rounded_array"], [0.8965084552764893, "    result = 0\n    for num in myList:\n        result += num ** 2\n    return result"], [0.896458625793457, "    total = sum(args)\n    average = total / len(args)\n    return average * len(args)"]]}
{"task_id": "MBPP/409", "problem": []}
{"task_id": "MBPP/410", "problem": [[0.9028024673461914, "    result = []\n    for i in numbers:\n        result.append(i)\n        result.append(delimiter)\n    return result[:-1]"], [0.9012223482131958, "    result = []\n    for i in range(len(numbers)):\n        result.append(numbers[i])\n        if i != len(numbers) - 1:\n            result.append(delimiter)\n    return result"], [0.9012015461921692, "    result = []\n    for i in range(len(numbers)):\n        result.append(numbers[i])\n        if i != len(numbers) - 1:\n            result.append(delimiter)\n    return result"], [0.9011498689651489, "    result = []\n    for i in numbers:\n        result.append(i)\n        result.append(delimeter)\n    return result[:-1]"], [0.9008184671401978, "    return delimiter.join(strings)"], [0.900645911693573, "    return delimiter.join(string_list)"], [0.9001262784004211, "    return delimiter.join(list_of_strings)"], [0.8995329141616821, "    result = []\n    for i in numbers:\n        result += [i, delimeter]\n    return result[:-1]"], [0.8993621468544006, "    return delimiter.join(list_str)"], [0.898192286491394, "    result = []\n    for i, num in enumerate(numbers):\n        if i > 0:\n            result.append(delimeter)\n        result.append(num)\n    return result"]]}
{"task_id": "MBPP/411", "problem": [[0.9013606309890747, "    natural_numbers = [i for i in range(1, n + 1)]\n    sum_numbers = sum(natural_numbers)\n    average = sum_numbers / n\n    squares = [(i - average) ** 2 for i in natural_numbers]\n    std_dev = math.sqrt(sum(squares) / n)\n    return (sum_numbers, average, std_dev)"], [0.9004225134849548, "    if not isinstance(n, int) or n < 1:\n        return 'Error: Input should be a natural number.'\n    sum_of_cubes = sum([i ** 3 for i in range(1, n + 1)])\n    sum_of_numbers = sum([i for i in range(1, n + 1)])\n    return sum_of_cubes - sum_of_numbers"], [0.9004167318344116, "    if not isinstance(n, int) or n < 1:\n        return 'Error: Input should be a natural number.'\n    sum_of_cubes = sum([i ** 3 for i in range(1, n + 1)])\n    sum_of_numbers = sum([i for i in range(1, n + 1)])\n    return sum_of_cubes - sum_of_numbers"], [0.8981722593307495, "    primes = []\n    for i in range(1, n + 1):\n        if is_prime(i):\n            primes.append(i)\n    sum_of_cubes = sum([prime ** 3 for prime in primes])\n    return sum_of_cubes"], [0.8966090679168701, "    cubes_array = []\n    for i in range(1, n + 1):\n        cubes_array.append(i ** 3)\n    return cubes_array"], [0.8955418467521667, "    if n <= 0:\n        return 'n must be a positive integer.'\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if is_prime(num):\n            primes.append(num)\n        num += 1\n    sum_of_cubes = sum([prime ** 3 for prime in primes])\n    return sum_of_cubes"], [0.8952248096466064, "    sum = 0\n    for i in range(len(arr)):\n        arr[i] = arr[i] ** 3\n        sum += arr[i]\n    average = round(sum / len(arr))\n    return average"], [0.8943583965301514, "    if not isinstance(n, int) or n < 0:\n        raise ValueError('Input must be a positive integer')\n    sum_of_cubes = 0\n    for num in range(2, n + 1, 2):\n        sum_of_cubes += num ** 3\n    return sum_of_cubes"], [0.8927483558654785, "    if n < 0:\n        raise ValueError('Input cannot be a negative number.')\n    if n == 0:\n        return 0\n    else:\n        return n ** 3 + sum_cubes(n - 1)"], [0.8920141458511353, "    if n == 0:\n        return 0\n    else:\n        return n ** 3 + sum_cubes(n - 1)"]]}
{"task_id": "MBPP/412", "problem": [[0.919744610786438, "    rows, cols = (len(mine), len(mine[0]))\n    dp = [[[-1 for _ in range(cols)] for _ in range(cols)] for _ in range(rows)]\n    return maxGold(mine, dp, 0, 0, cols - 1)"], [0.9190274477005005, "    rows, cols = (len(mine), len(mine[0]))\n    dp = [[[-1 for _ in range(cols)] for __ in range(cols)] for ___ in range(rows)]\n    return maxGold(mine, dp, 0, 0, cols - 1)"], [0.8842380046844482, "    x2 = x1 + y2 - y1\n    cols = len(m[0])\n    if y1 < 0 or y1 >= cols or y2 < 0 or (y2 >= cols):\n        return float('-inf')\n    if dp[x1][y1][y2] != -1:\n        return dp[x1][y1][y2]\n    if x1 == len(m) - 1:\n        return m[x1][y1] + (y1 != y2) * m[x2][y2]\n    ans = float('-inf')\n    for new_y1 in [y1 - 1, y1, y1 + 1]:\n        for new_y2 in [y2 - 1, y2, y2 + 1]:\n            ans = max(ans, maxGold(m, dp, x1 + 1, new_y1, new_y2))\n    dp[x1][y1][y2] = ans + m[x1][y1] + (y1 != y2) * m[x2][y2]\n    return dp[x1][y1][y2]"], [0.8842297792434692, "    x2 = x1 + y2 - y1\n    cols = len(m[0])\n    if y1 < 0 or y1 >= cols or y2 < 0 or (y2 >= cols):\n        return float('-inf')\n    if dp[x1][y1][y2] != -1:\n        return dp[x1][y1][y2]\n    if x1 == len(m) - 1:\n        return m[x1][y1] + (y1 != y2) * m[x2][y2]\n    ans = float('-inf')\n    for new_y1 in [y1 - 1, y1, y1 + 1]:\n        for new_y2 in [y2 - 1, y2, y2 + 1]:\n            ans = max(ans, maxGold(m, dp, x1 + 1, new_y1, new_y2))\n    dp[x1][y1][y2] = ans + m[x1][y1] + (y1 != y2) * m[x2][y2]\n    return dp[x1][y1][y2]"], [0.8821479678153992, "        for new_y2 in [y2 - 1, y2, y2 + 1]:\n            ans = max(ans, maxGold(m, dp, x1 + 1, new_y1, new_y2))"], [0.882144570350647, "        for new_y2 in [y2 - 1, y2, y2 + 1]:\n            ans = max(ans, maxGold(m, dp, x1 + 1, new_y1, new_y2))"], [0.8810227513313293, "            if collected_treasures == sum((row.count('T') for row in grid)):\n                return (collected_treasures, True)"], [0.8805058002471924, "    for new_y1 in [y1 - 1, y1, y1 + 1]:\n        for new_y2 in [y2 - 1, y2, y2 + 1]:\n            ans = max(ans, maxGold(m, dp, x1 + 1, new_y1, new_y2))"], [0.8804555535316467, "    for new_y1 in [y1 - 1, y1, y1 + 1]:\n        for new_y2 in [y2 - 1, y2, y2 + 1]:\n            ans = max(ans, maxGold(m, dp, x1 + 1, new_y1, new_y2))"], [0.8748303651809692, "        if grid[y][x] == 'T':\n            treasure_count -= 1\n        elif grid[y][x] == 'X':\n            return False"]]}
{"task_id": "MBPP/413", "problem": [[0.8838933706283569, "    last_elements = []\n    for string in str_list:\n        last_elements.append(string[-1])\n    return last_elements"], [0.8806674480438232, "    last_chars = []\n    for string in strings:\n        last_char = string[len(string) - 1]\n        last_chars.append(last_char)\n    return last_chars"], [0.8770732879638672, "    third_chars = ''\n    for word in lst:\n        third_chars += word[2]\n    return third_chars"], [0.8769996166229248, "    error_free_list = [w for w in tup if isinstance(w, str) and len(w) > 1]\n    sorted_tuple = tuple(sorted(error_free_list, key=lambda x: x[-2:]))\n    if error_free_list == list(sorted_tuple):\n        print('List is sorted.')\n    else:\n        print('List was not sorted, but is now sorted.')\n    return sorted_tuple"], [0.8768606185913086, "    return tuple[-4:-2]"], [0.8750303387641907, "    try:\n        print(colors[-3])\n    except IndexError:\n        print('Tuple is too small to have a third last item')"], [0.8750303387641907, "    try:\n        print(colors[-3])\n    except IndexError:\n        print('Tuple is too small to have a third last item')"], [0.8732538819313049, "    words = words.strip()\n    word_list = words.split()\n    if len(word_list) < 3:\n        return 'Input string must contain at least three words'\n    last_word = word_list[-1]\n    second_last_word = word_list[-2]\n    return (second_last_word, last_word)"], [0.8724638819694519, "    extracted_elements = []\n    for i in range(3):\n        extracted_elements.append(lst[i])\n    return extracted_elements"], [0.8719297051429749, "    result = []\n    for string in arr:\n        string = string.strip()\n        words = string.split()\n        if len(words) == 0:\n            result.append(('', ''))\n        elif len(words) == 1:\n            result.append((words[0], words[0]))\n        else:\n            result.append((words[0], words[-1]))\n    return result"]]}
{"task_id": "MBPP/414", "problem": [[0.9258114099502563, "    count = 0\n    for sub_list in nested_list:\n        for elem in sub_list:\n            if elem == item:\n                count += 1\n    return count"], [0.9201257824897766, "    for sub_list in nested_list:\n        for elem in sub_list:\n            if elem == item:\n                count += 1"], [0.9194061756134033, "    item_count = 0\n    sublist_count = 0\n    for i in lst:\n        if isinstance(i, list):\n            sublist_item_count, sublist_sublist_count = count_item_and_sublists(i, item)\n            item_count += sublist_item_count\n            if sublist_item_count > 0:\n                sublist_count += 1\n        elif i == item:\n            item_count += 1\n    return (item_count, sublist_count)"], [0.9193915724754333, "    item_count = 0\n    sublist_count = 0\n    for i in lst:\n        if isinstance(i, list):\n            sublist_item_count, sublist_sublist_count = count_item_and_sublists(i, item)\n            item_count += sublist_item_count\n            if sublist_item_count > 0:\n                sublist_count += 1\n        elif i == item:\n            item_count += 1\n    return (item_count, sublist_count)"], [0.9186366200447083, "    count = 0\n    for element in lst:\n        if element == ele:\n            count += 1\n    return count"], [0.9178998470306396, "    count = 0\n    for i in lst:\n        if i == element:\n            count += 1\n    return count"], [0.9176596403121948, "    count = 0\n    for item in lst:\n        if item == element:\n            count += 1\n    return count"], [0.9171748757362366, "    count = 0\n    for i in input_list:\n        if i == element:\n            count += 1\n    return count"], [0.9166999459266663, "    count = 0\n    for element in lst:\n        if element == target:\n            count += 1\n    return count"], [0.9166976809501648, "    count = 0\n    for element in lst:\n        if element == target:\n            count += 1\n    return count"]]}
{"task_id": "MBPP/415", "problem": []}
{"task_id": "MBPP/416", "problem": [[0.9228528141975403, "    splitted_date = date.split('-')\n    reformatted_date = splitted_date[::-1]\n    return '-'.join(reformatted_date)"], [0.9180665016174316, "    dateList = inputDate.split('-')\n    newFormat = dateList[1] + '-' + dateList[0] + '-' + dateList[2]\n    return newFormat"], [0.9086997509002686, "    date_list = date.split('/')\n    new_date = date_list[2] + '-' + date_list[0] + '-' + date_list[1]\n    return new_date"], [0.907657265663147, "    date_list = date.split('/')\n    return date_list[2] + '/' + date_list[0] + '/' + date_list[1]"], [0.9023263454437256, "    date_list = date.split('/')\n    date_list.reverse()\n    return '-'.join(date_list)"], [0.9017375111579895, "    datetime_obj = datetime.strptime(input_date, '%Y-%m-%d')\n    reformatted_date = datetime_obj.strftime(desired_format)\n    return reformatted_date"], [0.9013948440551758, "    date = datetime.strptime(date_string, '%m/%d/%Y')\n    converted_date = date.strftime('%d-%m-%Y')\n    return converted_date"], [0.8993747234344482, "    try:\n        date_object = datetime.strptime(date_string, '%m-%d-%Y')\n        formatted_date = date_object.strftime('%d/%m/%Y')\n        return formatted_date\n    except ValueError:\n        return \"Invalid Date Format. Please provide the date in 'mm-dd-yyyy' format.\""], [0.8993747234344482, "    try:\n        date_object = datetime.strptime(date_string, '%m-%d-%Y')\n        formatted_date = date_object.strftime('%d/%m/%Y')\n        return formatted_date\n    except ValueError:\n        return \"Invalid Date Format. Please provide the date in 'mm-dd-yyyy' format.\""], [0.8987125158309937, "    datetime_object = datetime.strptime(date, '%Y-%m-%d')\n    formatted_date = datetime_object.strftime(format)\n    return formatted_date"]]}
{"task_id": "MBPP/417", "problem": []}
{"task_id": "MBPP/418", "problem": [[0.8881223201751709, "    for a, b in tpl1:\n        for c, d in tpl2:\n            return (a + c, b + d)"], [0.8881223201751709, "    for a, b in tpl1:\n        for c, d in tpl2:\n            return (a + c, b + d)"], [0.8826452493667603, "    for pair1, pair2 in zip(tuples1, tuples2):\n        if len(pair1) != len(pair2):\n            return 'Error: Corresponding tuples should be of same length.'\n        temp = []\n        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)\n        result.append(tuple(temp))"], [0.8826451301574707, "    for pair1, pair2 in zip(tuples1, tuples2):\n        if len(pair1) != len(pair2):\n            return 'Error: Corresponding tuples should be of same length.'\n        temp = []\n        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)\n        result.append(tuple(temp))"], [0.8825404644012451, "    filtered_elements = [x for x in a if x < b]\n    multiplied_elements = [x * fact for x in filtered_elements]\n    return tuple(multiplied_elements)"], [0.8801529407501221, "    if not isinstance(tuples1, list) or not isinstance(tuples2, list):\n        return 'Error: Both inputs should be lists.'\n    if len(tuples1) != len(tuples2):\n        return 'Error: Both lists should be of same length.'\n    for t in tuples1 + tuples2:\n        if not isinstance(t, tuple):\n            return 'Error: All elements of input lists should be tuples.'\n        if not all((isinstance(i, int) for i in t)):\n            return 'Error: All elements of the tuples should be integers.'\n    result = []\n    for pair1, pair2 in zip(tuples1, tuples2):\n        if len(pair1) != len(pair2):\n            return 'Error: Corresponding tuples should be of same length.'\n        temp = []\n        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)\n        result.append(tuple(temp))\n    return result"], [0.8801481127738953, "    if not isinstance(tuples1, list) or not isinstance(tuples2, list):\n        return 'Error: Both inputs should be lists.'\n    if len(tuples1) != len(tuples2):\n        return 'Error: Both lists should be of same length.'\n    for t in tuples1 + tuples2:\n        if not isinstance(t, tuple):\n            return 'Error: All elements of input lists should be tuples.'\n        if not all((isinstance(i, int) for i in t)):\n            return 'Error: All elements of the tuples should be integers.'\n    result = []\n    for pair1, pair2 in zip(tuples1, tuples2):\n        if len(pair1) != len(pair2):\n            return 'Error: Corresponding tuples should be of same length.'\n        temp = []\n        for a, b in zip(pair1, pair2):\n            if b == 0:\n                return 'Error: Cannot perform modulo operation with denominator zero.'\n            temp.append(a % b)\n        result.append(tuple(temp))\n    return result"], [0.8799483776092529, "    if len(t1) != len(t2):\n        return 'Error: tuples are not the same size'\n    else:\n        result = []\n        for i in range(len(t1)):\n            if t2[i] == 0:\n                return f'Error: division by zero in position {i}'\n            else:\n                result.append(t1[i] % t2[i])\n        return tuple(result)"], [0.8799483776092529, "    if len(t1) != len(t2):\n        return 'Error: tuples are not the same size'\n    else:\n        result = []\n        for i in range(len(t1)):\n            if t2[i] == 0:\n                return f'Error: division by zero in position {i}'\n            else:\n                result.append(t1[i] % t2[i])\n        return tuple(result)"], [0.8799260258674622, "    if len(t1) != len(t2):\n        return 'Error: tuples are not the same size'\n    else:\n        result = []\n        for i in range(len(t1)):\n            if t2[i] == 0:\n                return f'Error: division by zero in position {i}'\n            else:\n                result.append(t1[i] % t2[i])\n        return tuple(result)"]]}
{"task_id": "MBPP/419", "problem": [[0.8768070340156555, "    parabola_distance, error = integrate.quad(parabolic_distance, -4, 0, args=a)\n    straight_distance = sqrt(4 ** 2 + 3 ** 2)\n    return parabola_distance + straight_distance"], [0.8742564916610718, "    discriminant = (b ** 2 - 4 * a * c) ** 0.5\n    x1 = (-b + discriminant) / (2 * a)\n    x2 = (-b - discriminant) / (2 * a)\n    return (x1, x2)"], [0.8733948469161987, "    discriminant = b ** 2 - 4 * a * c\n    sqrt_discriminant = math.sqrt(discriminant)\n    x_c = (-b + sqrt_discriminant) / (2 * a)\n    x_d = (-b - sqrt_discriminant) / (2 * a)\n    return (x_c, x_d)"], [0.8733106255531311, "    discriminant = b ** 2 - 4 * a * c\n    x1 = 2 * c / (-b + discriminant ** 0.5)\n    x2 = (-b - discriminant ** 0.5) / (2 * a)\n    return (x1, x2)"], [0.8730329871177673, "    x = eq.split('=')[0]\n    constant = eq.split('=')[1]\n    coeff = x.split('+')[0]\n    if coeff[0] == '-':\n        coeff = -float(coeff[1:])\n    else:\n        coeff = float(coeff)\n    x_value = (float(constant) - float(coeff)) / (2 * coeff)\n    return x_value"], [0.8723846673965454, "    d = b * b - 4 * a * c\n    sol1 = (-b - math.sqrt(d)) / (2 * a)\n    sol2 = (-b + math.sqrt(d)) / (2 * a)\n    return (sol1, sol2)"], [0.8719675540924072, "    d = b ** 2 - 4 * a * c\n    if d >= 0:\n        sqrt_d = sqrt(d)\n        x1 = (-b + sqrt_d) / (2 * a)\n        x2 = (-b - sqrt_d) / (2 * a)\n        if x1 < x2:\n            return x1\n        else:\n            return x2\n    else:\n        return None"], [0.8716009855270386, "    if d >= 0:\n        sqrt_d = sqrt(d)\n        x1 = (-b + sqrt_d) / (2 * a)\n        x2 = (-b - sqrt_d) / (2 * a)\n        if x1 < x2:\n            return x1\n        else:\n            return x2\n    else:\n        return None"], [0.8713162541389465, "    discriminant = b ** 2 - 4 * a * c\n    d = math.sqrt(discriminant)\n    x1 = (-b + d) / (2 * a)\n    x2 = (-b - d) / (2 * a)\n    return (x1, x2)"], [0.8711724281311035, "    x1 = (-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)\n    x2 = (-b - (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)\n    return (x1, x2)"]]}
{"task_id": "MBPP/420", "problem": [[0.9336414337158203, "    for element in list1:\n        if element in list2:\n            return True"], [0.9336302280426025, "    for element in list1:\n        if element in list2:\n            return True"], [0.9322137832641602, "    for element in list1:\n        if element in list2:\n            return True\n    return False"], [0.9322114586830139, "    for element in list1:\n        if element in list2:\n            return True\n    return False"], [0.9292051792144775, "    result = False\n    for x in list1:\n        for y in list2:\n            if x == y:\n                result = True\n                return result\n    return result"], [0.9276831150054932, "    set1 = set(flatten(list1))\n    set2 = set(flatten(list2))\n    if set1.intersection(set2):\n        return True\n    else:\n        return False"], [0.9276036024093628, "    for x in list1:\n        for y in list2:\n            if x == y:\n                result = True\n                return result"], [0.9233754873275757, "    return len(set(a).intersection(set(b))) > 0"], [0.9198169708251953, "    for x in list2:\n        if x not in list1:\n            return False"], [0.9191113710403442, "    set_L = set(L)\n    set_M = set(M)\n    return len(set_L.intersection(set_M)) > 0"]]}
{"task_id": "MBPP/421", "problem": []}
{"task_id": "MBPP/422", "problem": [[0.906704306602478, "    greater_than_num = []\n    for i in list_numbers:\n        if i > num:\n            greater_than_num.append(i)\n    return greater_than_num"], [0.9041910171508789, "    for i in list_numbers:\n        if i > num:\n            greater_than_num.append(i)"], [0.8942075967788696, "    result = []\n    for element in array:\n        if element >= number:\n            result.append(element)\n    return result"], [0.8931131362915039, "    for element in array:\n        if element >= number:\n            result.append(element)"], [0.8902426958084106, "        if len(greater_than_six) == 0:\n            return 'There are no elements greater than 6 in the array.'"], [0.8899906277656555, "    for i in range(len(input_array)):\n        if input_array[i] == num:\n            return True\n    return False"], [0.8895407319068909, "        if i > num:\n            greater_than_num.append(i)"], [0.8894605040550232, "    for i in range(len(input_array)):\n        if input_array[i] == num:\n            return True"], [0.8892250061035156, "    for element in array:\n        if element == number:\n            return True\n    return False"], [0.8884693384170532, "    if isinstance(num1, int) and isinstance(num2, int):\n        if num1 > num2:\n            return True\n        else:\n            return False\n    else:\n        raise ValueError('Error: Invalid input. Please provide two integers as input.')"]]}
{"task_id": "MBPP/423", "problem": [[0.9043151140213013, "    if re.search(pattern, s):\n        return True\n    else:\n        return \"Error: The string does not contain 'a' followed by any characters, ending in 'b'.\""], [0.9014219045639038, "    if not isinstance(s, str):\n        return 'Error: Input is not a string.'\n    pattern = 'a.*b$'\n    if re.search(pattern, s):\n        return True\n    else:\n        return \"Error: The string does not contain 'a' followed by any characters, ending in 'b'.\""], [0.8924802541732788, "    state = 0\n    a_count = 0\n    b_count = 0\n    for c in input_string:\n        if c == 'a':\n            a_count += 1\n            if state == 0:\n                state = 1\n        if c == 'b':\n            b_count += 1\n            if state == 1 and b_count < a_count + 1:\n                state = 2\n            elif state == 1 and b_count == a_count + 1:\n                state = 3\n    if state == 2:\n        return True\n    else:\n        return False"], [0.8902738690376282, "    pattern = 'Ab?c'\n    return re.match(pattern, s) is not None"], [0.8877813816070557, "    return re.fullmatch('(a{1}b{2})*', s) is not None"], [0.8874160051345825, "    if input_string[0] == 'a' and input_string[-1] == 'b':\n        return True\n    else:\n        return False"], [0.8874160051345825, "    if input_string[0] == 'a' and input_string[-1] == 'b':\n        return True\n    else:\n        return False"], [0.8873597979545593, "    if string[0] == 'a':\n        return True\n    else:\n        return False"], [0.8873597979545593, "    if string[0] == 'a':\n        return True\n    else:\n        return False"], [0.886468231678009, "        if len(string) > 1 and string[1] == 'a':\n            return True"]]}
{"task_id": "MBPP/424", "problem": [[0.9163995385169983, "    if not isinstance(n, int):\n        raise ValueError('Input must be an integer.')\n    if n < 0:\n        n = -n\n    least_digit = n % 10\n    print('The least significant digit of', n, 'is', least_digit)\n    return least_digit"], [0.908065676689148, "    return number % 10"], [0.9080569744110107, "    return number % 10"], [0.8955068588256836, "    size = 1\n    length = 9\n    start = 1\n    while n > length * size:\n        n -= length * size\n        size += 1\n        length *= 10\n        start *= 10\n    start += (n - 1) // size\n    s = str(start)\n    return int(s[(n - 1) % size])"], [0.8943317532539368, "    last_two_digits = int(str(number)[-2:])\n    return last_two_digits"], [0.8939772248268127, "    last_five_string = str(num)[-5:]\n    return int(last_five_string)"], [0.8932912349700928, "    str_num = str(num)\n    dot_position = str_num.index('.')\n    digit = int(str_num[dot_position - 1])\n    return digit"], [0.8875688314437866, "    last_digit_a = abs(a) % 10\n    last_digit_b = abs(b) % 10\n    return last_digit_a * last_digit_b"], [0.8859934210777283, "    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n        while factorial % 10 == 0:\n            factorial //= 10\n        factorial %= 1000000000\n    return factorial % 10"], [0.8859586715698242, "    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n        while factorial % 10 == 0:\n            factorial //= 10\n        factorial %= 1000000000\n    return factorial % 10"]]}
{"task_id": "MBPP/425", "problem": [[0.9230663180351257, "    neg_lst = []\n    for num in lst:\n        if num < 0:\n            neg_lst.append(num)\n    return neg_lst"], [0.9136425852775574, "    negative_elements = []\n    for x in my_list:\n        if x < 0:\n            negative_elements.append(x)\n    return negative_elements"], [0.9093806743621826, "    for num in lst:\n        if num < 0:\n            neg_lst.append(num)"], [0.9081904888153076, "    for x in my_list:\n        if x < 0:\n            negative_elements.append(x)"], [0.9077621102333069, "    return [num for num in int_list if num < 0]"], [0.9075359106063843, "    for num in reversed(negative_numbers):\n        print(num)"], [0.905633270740509, "    return [num for num in numbers if num < 0]"], [0.905633270740509, "    return [num for num in numbers if num < 0]"], [0.9056185483932495, "    return [num for num in numbers if num < 0]"], [0.9039652943611145, "    input_list = [1, -2, 3, -4, 5]\n    expected_output = [-2, -4]\n    assert negative(input_list) == expected_output"]]}
{"task_id": "MBPP/426", "problem": [[0.9163827896118164, "    new_str = ''\n    for ch in str:\n        if ord(ch) % 2 == 0:\n            new_str += ch\n    return new_str"], [0.9142084121704102, "    odd_position = ''\n    for i in range(len(string)):\n        if i % 2 == 0:\n            odd_position += string[i]\n    return odd_position"], [0.9049525260925293, "    for ch in str:\n        if ord(ch) % 2 == 0:\n            new_str += ch"], [0.9017974138259888, "    string = string.strip()\n    string = string.translate(str.maketrans('', '', string.punctuation))\n    modified_string = ''\n    for index, char in enumerate(string):\n        if index % 2 == 0:\n            modified_string += char\n    return modified_string"], [0.900408148765564, "    result = ''\n    for i in range(len(string)):\n        if i % 2 == 0:\n            result += string[i]\n    return result"], [0.8999687433242798, "    result_string = ''\n    for i in range(0, len(string)):\n        if i % 2 == 0:\n            result_string += string[i]\n    return result_string"], [0.8999316692352295, "    result = ''\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result += str[i]\n    return result"], [0.8991248607635498, "        if ord(ch) % 2 == 0:\n            new_str += ch"], [0.8959899544715881, "    punctuations = string.punctuation\n    modified_string = ''\n    for i, char in enumerate(s):\n        if char in punctuations:\n            continue\n        if i % 2 == 0:\n            modified_string += char\n    return modified_string"]]}
{"task_id": "MBPP/427", "problem": [[0.891808032989502, "    for item, count in unique_t2.items():\n        result_dict[item] = (count, 'tuple2')"]]}
{"task_id": "MBPP/428", "problem": [[0.9190174341201782, "    number = 0\n    for integer in list_of_ints:\n        number = number * 10 + integer\n    return number"], [0.9088359475135803, "    my_integer = int(''.join(map(str, my_list)))\n    return my_integer"], [0.904827892780304, "    for integer in list_of_ints:\n        number = number * 10 + integer"], [0.9019628763198853, "    return int(''.join((str(e) for e in int_list)))"], [0.9007604718208313, "    final_int = 0\n    concat_numbers = ''\n    for num in numbers:\n        concat_numbers = concat_numbers + str(num)\n    if int(concat_numbers) > 2 ** 32:\n        return False\n    else:\n        final_int = int(concat_numbers)\n    return final_int"], [0.8992285132408142, "    sum = 0\n    for num in integers:\n        sum += num\n    return sum"], [0.8985792398452759, "    return sum(int_list)"], [0.8984619379043579, "    result = 0\n    multiplier = 1\n    for i in range(len(my_list) - 1, -1, -1):\n        result += my_list[i] * multiplier\n        multiplier *= 10\n    return result"], [0.8963093757629395, "    number = 0\n    for i in range(len(lst)):\n        number = number * 10 + lst[i]\n    return number"], [0.8961597681045532, "    list_of_integers = []\n    for string in list_of_strings:\n        list_of_integers.append(int(string))\n    return list_of_integers"]]}
{"task_id": "MBPP/429", "problem": [[0.8897740840911865, "    adjectives = []\n    for word in text.split():\n        if word.endswith('ly') or word.endswith('ful'):\n            adjectives.append(word)\n    return adjectives"], [0.881717324256897, "            elif speech1_words[i] == 'Adjective':\n                categories['Adjectives'].append(word)"], [0.881627082824707, "            if re.search('\\\\bfrantically\\\\b', sentence):\n                context = 'adverb'\n            elif re.search('\\\\bfrantic\\\\b', sentence) and re.search('\\\\bnoun\\\\b', sentence):\n                context = 'noun'\n            else:\n                context = 'adjective'"], [0.8806859254837036, "    for word in text.split():\n        if word.endswith('ly') or word.endswith('ful'):\n            adjectives.append(word)"], [0.8794457912445068, "    words = word_tokenize(sentence)\n    pos_tags = pos_tag(words)\n    return pos_tags"], [0.8777009844779968, "    nouns = []\n    verbs = []\n    for word in words:\n        if word.endswith('ing'):\n            verbs.append(word)\n        else:\n            nouns.append(word)\n    return (nouns, verbs)"], [0.8773678541183472, "            elif speech1_words[i] == 'Verb':\n                categories['Verbs'].append(word)\n            elif speech1_words[i] == 'Adjective':\n                categories['Adjectives'].append(word)"], [0.8772282600402832, "    words = []\n    for sentence in sentences:\n        words += word_tokenize(sentence)\n    pos_tags = pos_tag(words)\n    return pos_tags"], [0.8769931793212891, "    positions = {}\n    for word in words:\n        matches = re.finditer('\\\\b' + word + '\\\\b', s)\n        positions[word] = [match.start() for match in matches]\n    return positions"], [0.8769848346710205, "    positions = {}\n    for word in words:\n        matches = re.finditer('\\\\b' + word + '\\\\b', s)\n        positions[word] = [match.start() for match in matches]\n    return positions"]]}
{"task_id": "MBPP/430", "problem": [[0.9021205902099609, "    surface_area = 6 * edge_length ** 2\n    return surface_area"], [0.8992398977279663, "    surface_area = 2 * l * w + 2 * l * h + 2 * w * h\n    return surface_area"], [0.8990668058395386, "    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area"], [0.8990501165390015, "    surface_area = 2 * (length * breadth + breadth * height + height * length)\n    return surface_area"], [0.898038923740387, "    surface_area = 6 * length ** 2\n    volume = length ** 3\n    return (surface_area, volume)"], [0.8977260589599609, "    surface_area = 2 * (height * width + width * depth + height * depth)\n    return surface_area"]]}
{"task_id": "MBPP/431", "problem": [[0.8987486362457275, "    if not positive_numbers:\n        return 0\n    else:\n        return sum(positive_numbers) / len(positive_numbers)"], [0.8981221914291382, "    if len(poss) == 0:\n        return 'N/A - No positive numbers'\n    elif 0 in lst:\n        return 'Infinite'\n    else:\n        return len(poss) / sum([1 / x for x in poss])"], [0.8979179859161377, "    poss = [x for x in lst if x > 0]\n    if len(poss) == 0:\n        return 'N/A - No positive numbers'\n    elif 0 in lst:\n        return 'Infinite'\n    else:\n        return len(poss) / sum([1 / x for x in poss])"], [0.89738529920578, "    if len(arr) == 0:\n        return 0\n    num_positive = 0\n    for num in arr:\n        if num > 0:\n            num_positive += 1\n    return num_positive / len(arr)"], [0.8969530463218689, "    size = len(numbers)\n    sum = 0\n    for index in range(size):\n        sum = sum + 1 / numbers[index]\n    return size / sum"], [0.896763026714325, "    for num in nums:\n        if num <= 0:\n            print('A non-positive number', num, 'ignored.')\n            continue\n        sum += 1 / num\n        n += 1"], [0.8964741230010986, "    positive_count = 0\n    sum_of_positives = 0\n    max_positive = float('-inf')\n    min_positive = float('inf')\n    for number in numbers:\n        if number > 0:\n            positive_count += 1\n            sum_of_positives += number\n            max_positive = max(max_positive, number)\n            min_positive = min(min_positive, number)\n    if positive_count > 0:\n        average_of_positives = sum_of_positives / positive_count\n    else:\n        average_of_positives = 0\n    return (positive_count, average_of_positives, max_positive, min_positive)"], [0.8959785103797913, "    positive_numbers = [num for num in numbers if num > 0]\n    if not positive_numbers:\n        return 0\n    return sum(positive_numbers) / len(positive_numbers)"], [0.895946204662323, "    positive_numbers = [num for num in numbers if num > 0]\n    if not positive_numbers:\n        return 0\n    return sum(positive_numbers) / len(positive_numbers)"], [0.8952301740646362, "    positive_numbers = [num for num in numbers if num > 0]\n    if not positive_numbers:\n        return 0\n    else:\n        return sum(positive_numbers) / len(positive_numbers)"]]}
{"task_id": "MBPP/432", "problem": [[0.9302290081977844, "    if len(arr) == 0:\n        return 'Array is empty.'\n    largest_negative = float('-inf')\n    for num in arr:\n        if num < 0 and num > largest_negative:\n            largest_negative = num\n    if largest_negative == float('-inf'):\n        return 'No negative numbers found.'\n    else:\n        return largest_negative"], [0.9187099933624268, "    if largest_negative == float('-inf'):\n        return 'No negative numbers found.'\n    else:\n        return largest_negative"], [0.9185189008712769, "    n = float('-inf')\n    for num in array:\n        if num < 0 and num > n:\n            n = num\n    return n"], [0.9058876633644104, "    for num in arr:\n        if num < 0 and num > largest_negative:\n            largest_negative = num"], [0.9045251607894897, "    if not lst:\n        return 'Error: List cannot be empty.'\n    lst = [int(num) for num in lst if num >= 0]\n    if not lst:\n        return 'Error: Negative numbers are not allowed.'\n    largest_num = max(lst)\n    return largest_num"], [0.8985317945480347, "    for i in range(len(numbers)):\n        if numbers[i] < 0:\n            return (numbers[i], i)\n    return 'No negative numbers found'"], [0.8983945846557617, "    neg_lst = []\n    for num in lst:\n        if num < 0:\n            neg_lst.append(num)\n    return neg_lst"], [0.8970557451248169, "    max_num = 0\n    for num in arr:\n        if num < 0:\n            return 'Error: Negative numbers are not allowed.'\n        if num > max_num:\n            max_num = num\n    return max_num"], [0.8959384560585022, "    for num in lst:\n        if num < 0:\n            neg_lst.append(num)"], [0.8951942920684814, "        if num < 0 and num > largest_negative:\n            largest_negative = num"]]}
{"task_id": "MBPP/433", "problem": [[0.871926486492157, "    elif k < 1:\n        return input_list\n    else:\n        return input_list[:k - 1] + input_list[k:]"], [0.8672958612442017, "    words = s.split()\n    return ' '.join(words[:k])"], [0.8672958612442017, "    words = s.split()\n    return ' '.join(words[:k])"], [0.8659970760345459, "    for k, trim in queries:\n        trimmed_indices = [(i, int(n[-trim:])) for i, n in enumerate(nums)]\n        trimmed_indices.sort(key=lambda x: (x[1], x[0]))\n        answer.append(trimmed_indices[k - 1][0])"], [0.8648576140403748, "            if condition(i):\n                continue\n            else:\n                result.append(remove_tuples(i, condition))"], [0.8648388385772705, "            if condition(i):\n                continue\n            else:\n                result.append(remove_tuples(i, condition))"], [0.8648022413253784, "    answer = []\n    indices = list(enumerate(map(int, nums)))\n    indices.sort(key=lambda x: (x[1], x[0]))\n    for k, trim in queries:\n        trimmed_indices = [(i, int(n[-trim:])) for i, n in enumerate(nums)]\n        trimmed_indices.sort(key=lambda x: (x[1], x[0]))\n        answer.append(trimmed_indices[k - 1][0])\n    return answer"], [0.861985445022583, "    filtered_tuples = filter(func, tuples)\n    for tuple in filtered_tuples:\n        print(tuple)"], [0.8612033128738403, "    arr.sort()\n    return arr[:-k]"], [0.8598513603210449, "    filtered_elements = [x for x in a if x < b]\n    multiplied_elements = [x * fact for x in filtered_elements]\n    return tuple(multiplied_elements)"]]}
{"task_id": "MBPP/434", "problem": [[0.9073447585105896, "    if not isinstance(num_tuple, tuple):\n        return 'Error: The input must be a tuple.'\n    result = []\n    for i in range(len(num_tuple) - 1):\n        result.append(num_tuple[i] * num_tuple[i + 1])\n    return tuple(result)"], [0.905329167842865, "    if not isinstance(t, tuple):\n        return 'Error: Input must be a tuple'\n    res = []\n    for i in range(len(t) - 1):\n        res.append(t[i] * t[i + 1])\n    return tuple(res)"], [0.9053083658218384, "    if not isinstance(t, tuple):\n        return 'Error: Input must be a tuple'\n    res = []\n    for i in range(len(t) - 1):\n        res.append(t[i] * t[i + 1])\n    return tuple(res)"], [0.9009976387023926, "    list3 = [x * y for x, y in zip(list1, list2)]\n    return list3"], [0.9008083343505859, "    if not isinstance(input_tuple, tuple):\n        return 'Error: Input is not a tuple'\n    return tuple((input_tuple[i] * input_tuple[i + 1] for i in range(len(input_tuple) - 1)))"], [0.900806188583374, "    if not isinstance(input_tuple, tuple):\n        return 'Error: Input is not a tuple'\n    return tuple((input_tuple[i] * input_tuple[i + 1] for i in range(len(input_tuple) - 1)))"], [0.9007627964019775, "    if not isinstance(input_tuple, tuple):\n        return 'Error: Input is not a tuple'\n    if len(input_tuple) < 2:\n        return ()\n    return tuple((input_tuple[i] * input_tuple[i + 1] for i in range(len(input_tuple) - 1)))"], [0.9007625579833984, "    if not isinstance(input_tuple, tuple):\n        return 'Error: Input is not a tuple'\n    if len(input_tuple) < 2:\n        return ()\n    return tuple((input_tuple[i] * input_tuple[i + 1] for i in range(len(input_tuple) - 1)))"], [0.9005312919616699, "    multiply_list = []\n    for i in list1:\n        for j in list2:\n            multiply_list.append(i * j)\n    return multiply_list"], [0.8997116088867188, "    if len(arr1) != len(arr2):\n        return 'Arrays are not of the same length! Cannot perform operation.'\n    result = [i * j for i, j in zip(arr1, arr2)]\n    return result"]]}
{"task_id": "MBPP/435", "problem": [[0.9118024110794067, "    output_dict = {}\n    for item in input_tuple:\n        output_dict[item] = output_dict.get(item, 0) + 1\n    return output_dict"], [0.9101438522338867, "    count_dict = {element: 0 for element in elements}\n    for ele in lst:\n        if ele in count_dict:\n            count_dict[ele] += 1\n    return count_dict"], [0.9090218544006348, "    elements = {}\n    for element in lst:\n        if element in elements:\n            elements[element] += 1\n        else:\n            elements[element] = 1\n    return elements"], [0.9064193964004517, "    count_obj = Counter(input_tuple)\n    my_dict = dict(count_obj)\n    unique_dict = {key: 1 for key in my_dict.keys()}\n    return (unique_dict, my_dict)"], [0.9064175486564636, "    count_obj = Counter(input_tuple)\n    my_dict = dict(count_obj)\n    unique_dict = {key: 1 for key in my_dict.keys()}\n    return (unique_dict, my_dict)"], [0.90436851978302, "    lst = [tuple(flatten(sublist)) for sublist in lst if isinstance(sublist, list)]\n    return {t: lst.count(t) for t in set(lst)}"], [0.9036709070205688, "    count_dict = {}\n    count_occurrences(nested_list, count_dict)\n    return count_dict"], [0.9032517671585083, "    count = {}\n    for i in lst:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n    return count"], [0.9032120108604431, "    counts = dict()\n    for item in lst:\n        if item in counts:\n            counts[item] += 1\n        else:\n            counts[item] = 1\n    return counts"], [0.9028807282447815, "    count = 0\n    for i in tuple_input:\n        if isinstance(i, tuple):\n            count += count_occurrences(element, i)\n        elif i == element:\n            count += 1\n    return count"]]}
{"task_id": "MBPP/436", "problem": [[0.9254691004753113, "    cubes = []\n    for num in numbers:\n        cubes.append(num ** 3)\n    return cubes"], [0.919926106929779, "    cube_numbers = []\n    for num in numbers:\n        cube = num ** 3\n        cube_numbers.append(cube)\n    return cube_numbers"], [0.9177121520042419, "    output_list = []\n    for num in input_list:\n        output_list.append(num ** 3)\n    return output_list"], [0.9149312973022461, "    output_list = []\n    for i in input_list:\n        output_list.append(i ** 3)\n    return output_list"], [0.9113405346870422, "    for num in numbers:\n        cubes.append(num ** 3)"], [0.909206748008728, "    return [i ** 3 for i in lst]"], [0.9079571962356567, "    for num in numbers:\n        cube = num ** 3\n        cube_numbers.append(cube)"], [0.907659113407135, "    result = []\n    for n in numbers:\n        result.append(n ** 3)\n    return result"], [0.9071755409240723, "    new_lst = []\n    for item in lst:\n        if not isinstance(item, int):\n            continue\n        elif item < 0:\n            continue\n        else:\n            new_lst.append(item ** 3)\n    return new_lst"], [0.9056129455566406, "    unique_numbers = list(set(numbers))\n    cubes = [num ** 3 for num in unique_numbers]\n    return cubes"]]}
{"task_id": "MBPP/437", "problem": [[0.8895450234413147, "    return sum(primes)"], [0.8895249366760254, "    return sum(primes)"]]}
{"task_id": "MBPP/438", "problem": [[0.904704749584198, "    if point1 == point2 or point1 == point3 or point2 == point3:\n        return False"], [0.9026561379432678, "    if point1 == point2 or point1 == point3 or point2 == point3:\n        return False\n    vector1 = [point2[i] - point1[i] for i in range(3)]\n    vector2 = [point3[i] - point1[i] for i in range(3)]\n    cross_product = [vector1[(i + 1) % 3] * vector2[(i + 2) % 3] - vector1[(i + 2) % 3] * vector2[(i + 1) % 3] for i in range(3)]\n    if all((c == 0 for c in cross_product)):\n        return False\n    return True"], [0.8962662816047668, "    for i in range(len(points) - 2):\n        for j in range(i + 1, len(points) - 1):\n            for k in range(j + 1, len(points)):\n                side1 = calculate_distance(points[i], points[j])\n                side2 = calculate_distance(points[j], points[k])\n                side3 = calculate_distance(points[k], points[i])\n                if is_triangle(side1, side2, side3):\n                    return True\n    return False"], [0.8958702087402344, "    x1, y1 = Point1\n    x2, y2 = Point2\n    x3, y3 = Point3\n    area = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2)\n    return area"], [0.8948938846588135, "    p1, p2, p3 = points\n    if p1 == [0, 0] or p2 == [0, 0] or p3 == [0, 0]:\n        return (False, 0)\n    if (p2[0] - p1[0]) * (p3[1] - p1[1]) == (p3[0] - p1[0]) * (p2[1] - p1[1]):\n        return (False, 0)\n    else:\n        d12 = math.sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2)\n        d23 = math.sqrt((p3[0] - p2[0]) ** 2 + (p3[1] - p2[1]) ** 2)\n        return (True, round(d12 + d23, 2))"], [0.8944434523582458, "    if a + b <= c or a + c <= b or b + c <= a:\n        return 'Not a valid triangle'\n    if a == b and b == c:\n        return 'Equilateral triangle'\n    if a != b and b != c and (a != c):\n        return 'Scalene triangle'\n    return 'Isosceles triangle'"], [0.8929462432861328, "    if a + b > c and a + c > b and (b + c > a):\n        return True"], [0.8929151296615601, "    if a + b > c and a + c > b and (b + c > a):\n        return True"], [0.8926610946655273, "                if is_triangle(side1, side2, side3):\n                    return True"], [0.8925926089286804, "    if a + b <= c or a + c <= b or b + c <= a:\n        return False\n    if a + b > c and a + c > b and (b + c > a):\n        return True\n    return False"]]}
{"task_id": "MBPP/439", "problem": [[0.885992169380188, "    result = []\n    for string in strings:\n        if len(string) >= length:\n            result.append(string)\n    return result"], [0.8841390013694763, "    if size > len(string):\n        return 'Error: substring size is greater than string length.'"], [0.8824304938316345, "    for count in range(1, size):\n        current = ''\n        for x in random.sample(alpha, random.randint(min_length, max_length)):\n            current += x\n        strings.append(current)"], [0.8824125528335571, "    return [s for s in strings if len(s) > n]"], [0.8817259669303894, "    alpha = 'abcdefghijklmnopqrstuvwxyz'\n    min_length = 3\n    max_length = 8\n    strings = []\n    for count in range(1, size):\n        current = ''\n        for x in random.sample(alpha, random.randint(min_length, max_length)):\n            current += x\n        strings.append(current)\n    return strings"], [0.8816459774971008, "    for string in strings:\n        if len(string) >= length:\n            result.append(string)"], [0.8815313577651978, "    return [string for string in strings if len(string) == length]"], [0.8802922964096069, "    extracted_elements = []\n    for i in range(3):\n        extracted_elements.append(lst[i])\n    return extracted_elements"], [0.8796381950378418, "    split_list = []\n    for i in range(0, len(string), sz):\n        split_list.append(string[i:i + sz])\n    return split_list"], [0.8790945410728455, "    desiredStringList = []\n    for string in stringList:\n        if len(string) > desiredLength:\n            desiredStringList.append(string)\n    return desiredStringList"]]}
{"task_id": "MBPP/440", "problem": [[0.912913978099823, "    result = []\n    for character in string:\n        if character != ' ':\n            result.append(character)\n    return ''.join(result)"], [0.9103294014930725, "    new_string = ''\n    for char in string:\n        if char != ' ':\n            new_string += char\n    return new_string"], [0.9102904796600342, "    new_string = ''\n    for char in string:\n        if char != ' ':\n            new_string += char\n    return new_string"], [0.9099464416503906, "    result = ''\n    for char in given_string:\n        if char != ' ':\n            result += char\n    return result"], [0.9095306992530823, "    new_str = ''\n    for char in str:\n        if char != ' ':\n            new_str += char\n    return new_str"], [0.9089391231536865, "    new_str = ''\n    for letter in str:\n        if letter != ' ':\n            new_str = new_str + letter\n    return new_str"]]}
{"task_id": "MBPP/441", "problem": [[0.8845697641372681, "    loss_percentage = (expenses - revenue) / revenue * 100\n    return round(loss_percentage, 2)"], [0.8807976245880127, "    if amount == 0:\n        return 0"], [0.8807945251464844, "    if amount == 0:\n        return 0"], [0.8807939291000366, "    if amount == 0:\n        return 0"], [0.8807799816131592, "    if amount == 0:\n        return 0"], [0.8754151463508606, "    if cost == 0 and profit > 0:\n        return profit"], [0.8732509613037109, "    if total > target_number:\n        return 'win'\n    else:\n        return 'loss'"], [0.87313312292099, "            if amount < 0:\n                return 'Invalid operation encountered.'"], [0.8700846433639526, "    return amount / total * 100"], [0.8699232935905457, "    if total_amount < 0:\n        print('Invalid total amount!')\n        return None"]]}
{"task_id": "MBPP/442", "problem": []}
{"task_id": "MBPP/443", "problem": [[0.8885781764984131, "    pattern = re.compile('a.*Z')\n    return pattern.findall(text)"], [0.8863974213600159, "    regexp = 'ba[r|z|d]'\n    if re.search(regexp, word):\n        return True\n    return False"], [0.8853644132614136, "    locations = [m.start() for m in re.finditer('zy{2,}', input_string.lower())]\n    if not locations:\n        return \"Sequence 'z' followed by minimum two 'y's does not appear in the text.\"\n    else:\n        return locations"], [0.8834999203681946, "    pattern = '^a[A-Za-z0-9]*Z$'\n    match = re.match(pattern, s)\n    if match:\n        print(f'The string {s} matches the pattern')\n    else:\n        print(f'The string {s} does not match the pattern')"], [0.881903886795044, "    match = re.search('z[yY]{2,}', s, re.IGNORECASE)\n    if match:\n        return match.start()\n    else:\n        return -1"], [0.8818187117576599, "    if not locations:\n        return \"Sequence 'z' followed by minimum two 'y's does not appear in the text.\"\n    else:\n        return locations"], [0.8815743923187256, "    pattern = 'a.*[0-9].*Z'\n    matches = re.findall(pattern, text)\n    return matches"], [0.8812440037727356, "    if match:\n        print('Valid word')\n    else:\n        print('Invalid word')"], [0.8812144994735718, "    return re.search(word, string)"], [0.8791967034339905, "    pattern = '^abc.*xyz$'\n    if re.match(pattern, string):\n        return True\n    return False"]]}
{"task_id": "MBPP/444", "problem": [[0.9050912261009216, "    thirty_days_months = [4, 6, 9, 11]\n    if month in thirty_days_months:\n        return True\n    elif month == 2:\n        if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            return False\n        else:\n            return True\n    else:\n        return False"], [0.9014586210250854, "    if month in thirty_days_months:\n        return True\n    elif month == 2:\n        if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            return False\n        else:\n            return True\n    else:\n        return False"], [0.8948206305503845, "    if month < 1 or month > 12:\n        return 'No'"], [0.8908665180206299, "    if month == 'January' or month == 'March' or month == 'May' or (month == 'July') or (month == 'August') or (month == 'October') or (month == 'December'):\n        return '31 days'\n    elif month == 'April' or month == 'June' or month == 'September' or (month == 'November'):\n        return '30 days'\n    elif month == 'February':\n        return '28 or 29 days'\n    else:\n        return 'Invalid input'"], [0.8908665180206299, "    if month == 'January' or month == 'March' or month == 'May' or (month == 'July') or (month == 'August') or (month == 'October') or (month == 'December'):\n        return '31 days'\n    elif month == 'April' or month == 'June' or month == 'September' or (month == 'November'):\n        return '30 days'\n    elif month == 'February':\n        return '28 or 29 days'\n    else:\n        return 'Invalid input'"], [0.8869708776473999, "    elif month == 'April' or month == 'June' or month == 'September' or (month == 'November'):\n        return '30 days'\n    elif month == 'February':\n        return '28 or 29 days'\n    else:\n        return 'Invalid input'"], [0.8859248757362366, "    if day < 1 or day > 31:\n        return 'No'"], [0.8841612935066223, "    if day < 1 or day > 31:\n        return False"], [0.8832229971885681, "    if month in [2, 4, 6, 9, 11]:\n        return 30"], [0.8823087811470032, "    if month in [4, 6, 9, 11]:\n        return 30"]]}
{"task_id": "MBPP/445", "problem": [[0.9245067834854126, "    reversed_list = []\n    for string in list_of_strings:\n        reversed_list.append(string[::-1])\n    return reversed_list"], [0.9218053817749023, "    revList = []\n    for string in list:\n        revList.append(string[::-1])\n    return revList"], [0.9216699004173279, "    return [s[::-1] for s in list_of_strings]"], [0.9198617935180664, "    reversed_strings = []\n    for string in strings:\n        reversed_strings.append(string[::-1])\n    return reversed_strings"], [0.9194384813308716, "    reversed_strings = []\n    for string in strings:\n        reversed_string = string[::-1]\n        reversed_strings.append(reversed_string)\n    reversed_list = reversed(reversed_strings)\n    return list(reversed_list)"], [0.9171274900436401, "    for string in list_of_strings:\n        reversed_list.append(string[::-1])"], [0.9161072969436646, "    reversed_list = []\n    for string in input_list:\n        reversed_string = string[::-1]\n        reversed_list.append(reversed_string)\n    return reversed_list"], [0.9146242141723633, "    if len(strings) == 0:\n        return\n    strings[0] = strings[0][::-1]\n    reverse_strings(strings[1:])"], [0.9124729037284851, "    for string in strings:\n        print(string[::-1])"], [0.9124729037284851, "    for string in strings:\n        print(string[::-1])"]]}
{"task_id": "MBPP/446", "problem": [[0.897953450679779, "            if subsequence_length < min_length:\n                min_length = subsequence_length"], [0.8953614234924316, "                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring"], [0.8945786952972412, "    if minlength == n + 1:\n        print('Not Possible')\n    else:\n        print('Minimum length of subarray is: %d' % minlength)"], [0.8930480480194092, "    min_value = min(list1)\n    return min_value"], [0.8881316781044006, "    input_list = list(set(input_list))\n    return find_min(input_list)"], [0.8879355192184448, "    shortest_words = []\n    min_length = len(words_list[0])\n    for word in words_list:\n        if len(word) < min_length:\n            min_length = len(word)\n            shortest_words = [word]\n        elif len(word) == min_length:\n            shortest_words.append(word)\n    return shortest_words"]]}
{"task_id": "MBPP/447", "problem": [[0.9093777537345886, "    area = length * width\n    return area"], [0.9093619585037231, "    area = length * width\n    return area"], [0.9086649417877197, "    area = width * height\n    return area"]]}
{"task_id": "MBPP/448", "problem": [[0.9096239805221558, "    uppercase_letters = []\n    for char in string:\n        if char.isupper():\n            uppercase_letters.append(char.lower())\n    return uppercase_letters"], [0.9065970778465271, "    return ''.join([char for char in my_string if char.isupper()])"], [0.9064533710479736, "    return ''.join([c for c in string if not c.isupper()])"], [0.9022455215454102, "    pattern = '[aeiouAEIOU]'\n    result = re.sub(pattern, '', string)\n    return result"], [0.9017557501792908, "    newStr = ''\n    for i in range(len(my_string)):\n        if my_string[i] != 'c' and my_string[i] != 'C':\n            newStr += my_string[i]\n    return newStr"], [0.900752604007721, "    char = char.lower()\n    modified_string = ''\n    i = 0\n    while i < len(string):\n        current_char = string[i].lower()\n        if current_char == char:\n            i += 1\n        else:\n            modified_string += string[i]\n            i += 1\n    return modified_string"], [0.9007343649864197, "    new_string = ''\n    for char in original_string:\n        if char.isupper():\n            new_string += char\n    if len(new_string) > 5 and any((char in string.punctuation for char in new_string)):\n        return new_string\n    return 'No such string exists'"], [0.8988962173461914, "    words = sentence.split()\n    new_words = []\n    for word in words:\n        if len(word) > 4:\n            new_words.append(re.sub('(?!^)[A-Za-z]', '', word))\n        else:\n            new_words.append(word)\n    return ' '.join(new_words)"], [0.898874044418335, "    output = ''\n    for char in input:\n        output += char.upper()\n    return output"], [0.8984107971191406, "    result = ''\n    for char in string:\n        result += chr(ord(char) - 32)\n    return result"]]}
{"task_id": "MBPP/449", "problem": [[0.8925334215164185, "    if not x:\n        return 'List is empty, cannot access first element.'\n    else:\n        return x[0]"], [0.8925334215164185, "    if not x:\n        return 'List is empty, cannot access first element.'\n    else:\n        return x[0]"], [0.8911629915237427, "                if all((elem == first for elem in sub_list)):\n                    result.append(first)\n                else:\n                    result.append(None)"], [0.8892512917518616, "    if not nested_list:\n        return []\n    first_list, remaining_lists = (nested_list[0], nested_list[1:])\n    flat_list = []\n    for element in first_list:\n        flat_list.append(element)\n    return flat_list + flatten_list(remaining_lists)"], [0.8892464637756348, "    if not nested_list:\n        return []\n    first_list, remaining_lists = (nested_list[0], nested_list[1:])\n    flat_list = []\n    for element in first_list:\n        flat_list.append(element)\n    return flat_list + flatten_list(remaining_lists)"], [0.8881439566612244, "        for sub_list in lists:\n            if sub_list:\n                first = sub_list[0]\n                if all((elem == first for elem in sub_list)):\n                    result.append(first)\n                else:\n                    result.append(None)\n            else:\n                result.append(None)"], [0.887656569480896, "    elif len(lst) == 0:\n        return 'Error: The list is empty.'\n    else:\n        return lst[0]"], [0.8875497579574585, "    for element in first_list:\n        flat_list.append(element)"], [0.8875055313110352, "    for element in first_list:\n        flat_list.append(element)"], [0.884954571723938, "    last_elements = []\n    for string in str_list:\n        last_elements.append(string[-1])\n    return last_elements"]]}
{"task_id": "MBPP/450", "problem": [[0.9476606845855713, "    count = 0\n    for c in string:\n        if c.isupper():\n            count += 1\n    return count"], [0.9471309185028076, "    count = 0\n    for char in string:\n        if char.isupper():\n            count += 1\n    return count"], [0.9471287727355957, "    count = 0\n    for char in string:\n        if char.isupper():\n            count += 1\n    return count"], [0.9447680115699768, "    count = 0\n    for i in range(len(string)):\n        if string[i].isupper():\n            count += 1\n    return count"], [0.9397033452987671, "    uppercase_count = 0\n    for char in my_str:\n        if char.isupper():\n            uppercase_count += 1\n    return uppercase_count"], [0.9368977546691895, "    chars = [c for c in string if c.isupper()]\n    return len(chars)"], [0.9361090660095215, "    uppercase_chars = [char for char in string if char.isupper()]\n    return len(uppercase_chars)"], [0.9356614351272583, "    count = 0\n    for letter in sentence:\n        if letter.isupper():\n            count += 1\n    return count"], [0.9356536865234375, "    uppercaseCount = 0\n    for l in myStr:\n        if l.isupper():\n            uppercaseCount += 1\n    return uppercaseCount"], [0.932588517665863, "    for char in string:\n        if char.isupper():\n            count += 1"]]}
{"task_id": "MBPP/451", "problem": [[0.9189703464508057, "    all_combinations = []\n    for r in range(1, len(elements) + 1):\n        all_combinations.extend(list(combinations(elements, r)))\n    return [list(comb) for comb in all_combinations]"], [0.9175745844841003, "    combinations = []\n    for r in range(1, len(input_list) + 1):\n        for subset in itertools.combinations(input_list, r):\n            combinations.append(list(subset))\n    return combinations"], [0.9157172441482544, "    for combination in all_combinations(list_of_numbers[1:]):\n        combinations.append(combination)\n        combinations.append([list_of_numbers[0]] + combination)"], [0.9155226945877075, "    result = []\n    for r in range(1, len(input_list) + 1):\n        combinations = [list(comb) for comb in itertools.combinations(input_list, r)]\n        result.extend(combinations)\n    return result"], [0.9139996767044067, "    result = []\n    for i in range(len(items)):\n        for comb in combinations(items[i + 1:]):\n            result.append([items[i]] + comb)\n    if result == []:\n        result = [items]\n    return result"], [0.9132816195487976, "    unique_lst = list(set(lst))\n    combinations = []\n    for r in range(1, len(unique_lst) + 1):\n        combinations.extend(list(itertools.combinations(unique_lst, r)))\n    return combinations"], [0.9132431745529175, "    comb_list = []\n    for subset in itertools.combinations(input_list, len(input_list)):\n        comb_list.append(subset)\n    return comb_list"], [0.9131875038146973, "    return [comb for r in range(len(lst) + 1) for comb in itertools.combinations(lst, r)]"], [0.9130813479423523, "        for subset in itertools.combinations(input_list, r):\n            combinations.append(list(subset))"], [0.9125500917434692, "    if len(list_of_numbers) == 0:\n        return []\n    if len(list_of_numbers) == 1:\n        return [list_of_numbers]\n    combinations = []\n    for combination in all_combinations(list_of_numbers[1:]):\n        combinations.append(combination)\n        combinations.append([list_of_numbers[0]] + combination)\n    return combinations"]]}
{"task_id": "MBPP/452", "problem": [[0.9195914268493652, "    arr = np.array(arr).flatten().tolist()\n    max_product = 0\n    max_subset = None\n    for L in range(0, len(arr) + 1):\n        for subset in itertools.combinations(arr, L):\n            product = find_product(list(subset))\n            if product > max_product:\n                max_product = product\n                max_subset = subset\n    return (max_product, max_subset)"]]}
{"task_id": "MBPP/453", "problem": [[0.897168755531311, "    if len(arr) == 0:\n        return False\n    return all((arr[0] == x for x in arr))"], [0.8898068070411682, "    first_elem = arr[0]\n    is_equal = True\n    for elem in arr:\n        if elem != first_elem:\n            is_equal = False\n            break\n    return is_equal"], [0.8881235122680664, "    elif all((x == arr[0] for x in arr)):\n        return True\n    else:\n        return False"], [0.8881117105484009, "    for i in dictionary.values():\n        if i != 0:\n            return False"], [0.884279727935791, "    if not lst:\n        return True\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True"], [0.8838211297988892, "    if len(lst) == 0:\n        return False\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True"], [0.8826813697814941, "    for i in range(len(my_list)):\n        for j in range(i + 1, len(my_list)):\n            if my_list[i] != my_list[j]:\n                return False\n    return True"], [0.8819684982299805, "    if all((value == 0 for value in dict1.values())):\n        return True"], [0.8813706636428833, "    for key, value in dict1.items():\n        if key not in dict2 or dict2[key] != value:\n            return False\n    return True"], [0.8800814151763916, "    if len(lst) == 0:\n        return True\n    first_element = lst[0]\n    for i in range(1, len(lst)):\n        if lst[i] != first_element:\n            return False\n    return True"]]}
{"task_id": "MBPP/454", "problem": [[0.8968591690063477, "            if isinstance(item, dict) and (not item):\n                dictionary.remove(item)\n            elif isinstance(item, list) and (not any(item)):\n                dictionary.remove(item)"], [0.8914474844932556, "            elif isinstance(item, list) and (not any(item)):\n                dictionary.remove(item)"], [0.8887366056442261, "            if isinstance(item, dict) and (not item):\n                nested_dict.remove(item)"], [0.886551022529602, "    return {k: v for k, v in my_dict.items() if v}"], [0.8831729292869568, "        for key, value in dictionary.items():\n            if isinstance(value, dict):\n                if check_empty_dict(value) == False:\n                    return False\n            else:\n                return False"], [0.8831636905670166, "        for key, value in dictionary.items():\n            if isinstance(value, dict):\n                if check_empty_dict(value) == False:\n                    return False\n            else:\n                return False"], [0.8831562995910645, "    new_dict = {}\n    for k, v in dictionary.items():\n        if k == key:\n            continue\n        else:\n            new_dict[k] = v\n    return new_dict"], [0.8831527233123779, "    if key in dictionary:\n        del dictionary[key]\n    return dictionary"], [0.882783055305481, "    for key, value in theDict.items():\n        if not value:\n            print(f'The list {key} is empty.')\n            continue\n        stuff = []\n        for d in value:\n            if d != ' ':\n                stuff.append(d)\n                print(d)\n                theDict[key] = stuff\n    return theDict"], [0.882696270942688, "            if isinstance(dictionary[key], dict) and (not dictionary[key]):\n                del dictionary[key]\n            elif isinstance(dictionary[key], list) and (not any(dictionary[key])):\n                del dictionary[key]"]]}
{"task_id": "MBPP/455", "problem": [[0.9345149993896484, "    n = len(arr)\n    if n == 1:\n        return arr[0]\n    mid = n // 2\n    if arr[mid] > arr[mid - 1] and arr[mid] > arr[mid + 1]:\n        return arr[mid]\n    elif arr[mid - 1] > arr[mid]:\n        return find_peak(arr[:mid])\n    else:\n        return find_peak(arr[mid + 1:])"], [0.9260571002960205, "    if arr[mid] > arr[mid - 1] and arr[mid] > arr[mid + 1]:\n        return arr[mid]\n    elif arr[mid - 1] > arr[mid]:\n        return find_peak(arr[:mid])\n    else:\n        return find_peak(arr[mid + 1:])"], [0.9255742430686951, "    elif arr[mid - 1] > arr[mid]:\n        return find_peak(arr[:mid])\n    else:\n        return find_peak(arr[mid + 1:])"], [0.9200321435928345, "    highest_peak = arr[0]\n    for i in range(1, len(arr)):\n        highest_peak = max(highest_peak, arr[i])\n    return highest_peak"], [0.90463787317276, "    if len(arr) == 1:\n        return arr[0]\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    max_left = find_max(left_half)\n    max_right = find_max(right_half)\n    return max(max_left, max_right)"], [0.9035400748252869, "    highest_peak = elevations[0]\n    highest_peak_index = 0\n    for i in range(1, len(elevations)):\n        if elevations[i] >= highest_peak:\n            highest_peak = elevations[i]\n            highest_peak_index = i\n    return highest_peak_index"], [0.9034762382507324, "    return find_max(arr, 0, len(arr) - 1)"], [0.9026440382003784, "    peak_indices = []\n    for i in range(1, len(lst) - 1):\n        if lst[i] > lst[i - 1] and lst[i] > lst[i + 1]:\n            peak_indices.append(i)\n    num_peaks = len(peak_indices)\n    return (num_peaks, peak_indices)"], [0.9021828174591064, "    supreme = array[0]\n    for i in array:\n        if i > supreme:\n            supreme = i\n    return supreme"], [0.9020195603370667, "    highest_peak_index = 0\n    highest_peak_height = elevations[0]\n    for i in range(1, len(elevations)):\n        if elevations[i] > highest_peak_height:\n            highest_peak_index = i\n            highest_peak_height = elevations[i]\n        elif elevations[i] == highest_peak_height:\n            highest_peak_index = i\n    return highest_peak_index"]]}
{"task_id": "MBPP/456", "problem": [[0.9353828430175781, "    octal_number = oct(decimal_number).replace('0o', '')\n    return octal_number"], [0.9271662831306458, "    binary_num = str(binary_num)\n    decimal = int(binary_num, 2)\n    octal_num = oct(decimal).replace('0o', '')\n    return octal_num"], [0.9231677055358887, "    decimal = int(octal_num, 8)\n    binary = bin(decimal).replace('0b', '')\n    return binary"], [0.9231560230255127, "    decimal = int(octal_num, 8)\n    binary = bin(decimal).replace('0b', '')\n    return binary"], [0.9230923652648926, "    oct_num = oct(num)\n    print('The octal form of {} is {}'.format(num, oct_num))"], [0.9153474569320679, "    decimal = int(binary_num, 2)\n    return oct(decimal)[2:]"], [0.915035605430603, "    decimal = 0\n    base = 1\n    while octal:\n        last_digit = octal % 10\n        octal = int(octal / 10)\n        decimal += last_digit * base\n        base = base * 8\n    return decimal"], [0.9147788286209106, "    decimal = int(bin_str, 2)\n    octal_str = oct(decimal)[2:]\n    return octal_str"], [0.9132139086723328, "    if octal == 0:\n        return 0\n    else:\n        last_digit = octal % 10\n        decimal = last_digit * 8 ** 0\n        binary = decimal_to_binary(decimal)\n        return binary + 10 * octal_to_binary(octal // 10)"], [0.9132139086723328, "    if octal == 0:\n        return 0\n    else:\n        last_digit = octal % 10\n        decimal = last_digit * 8 ** 0\n        binary = decimal_to_binary(decimal)\n        return binary + 10 * octal_to_binary(octal // 10)"]]}
{"task_id": "MBPP/457", "problem": [[0.9069518446922302, "    max_product = float('-inf')\n    for window_start in range(len(arr)):\n        prod = 1\n        for window_end in range(window_start, len(arr)):\n            prod *= arr[window_end]\n            max_product = max(prod, max_product)\n    return max_product"], [0.9046496152877808, "    for num in max_sublist:\n        product *= num"], [0.9046326875686646, "    for num in max_sublist:\n        product *= num"], [0.9035239219665527, "    for window_start in range(len(arr)):\n        prod = 1\n        for window_end in range(window_start, len(arr)):\n            prod *= arr[window_end]\n            max_product = max(prod, max_product)"], [0.9033311009407043, "    max_product = float('-inf')\n    max_positive = float('-inf')\n    max_negative = 0\n    for num in arr:\n        if num >= max_positive:\n            max_product = num * max_positive\n        elif num < max_negative:\n            max_product = num * max_negative\n        if num < 0 and abs(num) > abs(max_negative):\n            max_negative = num\n        elif num > 0 and num <= max_positive:\n            max_positive = num\n    return max_product"], [0.9024168252944946, "    for num in arr:\n        if num >= max_positive:\n            max_product = num * max_positive\n        elif num < max_negative:\n            max_product = num * max_negative\n        if num < 0 and abs(num) > abs(max_negative):\n            max_negative = num\n        elif num > 0 and num <= max_positive:\n            max_positive = num"], [0.9023601412773132, "    n = len(arr)\n    max_end = [0] * n\n    seq = [''] * n\n    max_end[0] = arr[0]\n    seq[0] = str(arr[0])\n    max_product_so_far = float('-inf')\n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                if max_end[j] * arr[i] > max_end[i]:\n                    max_end[i] = max_end[j] * arr[i]\n                    seq[i] = seq[j] + ' ' + str(arr[i])\n        max_product_so_far = max(max_product_so_far, max_end[i]) if max_end[i] else max_product_so_far\n    idx = max_end.index(max_product_so_far)\n    print('The maximum product is ' + str(max_product_so_far))\n    print('The sequence is ' + str(seq[idx]))"], [0.9019322991371155, "    max_combo = []\n    value = 1\n    for x in arr:\n        value = value * x\n        max_combo.append(value)\n    return max_combo"]]}
{"task_id": "MBPP/458", "problem": []}
{"task_id": "MBPP/459", "problem": [[0.9097073078155518, "    for a, b in tpl1:\n        for c, d in tpl2:\n            return (a + c, b + d)"], [0.9097073078155518, "    for a, b in tpl1:\n        for c, d in tpl2:\n            return (a + c, b + d)"], [0.8991755247116089, "        for c, d in tpl2:\n            return (a + c, b + d)"], [0.8974776268005371, "    results = []\n    for n1 in list1:\n        for n2 in list2:\n            results.append(n1 + n2)\n    return results"], [0.8974767923355103, "    results = []\n    for n1 in list1:\n        for n2 in list2:\n            results.append(n1 + n2)\n    return results"], [0.8954542279243469, "    for i in tuples:\n        if isinstance(i, tuple):\n            cum_sum = recursive_sum(i, cum_sum)\n        elif isinstance(i, (int, float)):\n            cum_sum += i\n    return cum_sum"], [0.8946802616119385, "    additions = []\n    for i in range(len(list1)):\n        additions.append(list1[i] + list2[i])\n    return additions"], [0.8931264281272888, "    result = []\n    for tup in tuples:\n        value_sum = sum(tup)\n        if value_sum % 2 == 0:\n            result.append((tup[0] + 1, tup[1] + 1))\n        else:\n            result.append((tup[0] * 2, tup[1] * 2))\n    return result"], [0.8924336433410645, "    total = 0\n    for t in tuples:\n        total += sum(t)\n    return total"], [0.8912053108215332, "    total = 0\n    for i in tuples:\n        if isinstance(i, tuple):\n            total += cumul_sum(i)\n        elif isinstance(i, (int, float)):\n            total += i\n        elif isinstance(i, complex):\n            total += i.real\n    return total"]]}
{"task_id": "MBPP/460", "problem": [[0.8980403542518616, "    if n == 0:\n        return \"Error: 'n' must not be zero.\"\n    else:\n        return sum(set((x for x in array if x % n == 0)))"], [0.8980403542518616, "    if n == 0:\n        return \"Error: 'n' must not be zero.\"\n    else:\n        return sum(set((x for x in array if x % n == 0)))"], [0.8979998230934143, "    if n == 0:\n        return \"Error: 'n' must not be zero.\"\n    else:\n        return sum(set((x for x in array if x % n == 0)))"], [0.8979998230934143, "    if n == 0:\n        return \"Error: 'n' must not be zero.\"\n    else:\n        return sum(set((x for x in array if x % n == 0)))"], [0.8943204879760742, "    quotient = n1 // n2\n    remainder = n1 - n2 * quotient\n    return remainder"], [0.8930365443229675, "    number_list = []\n    for i in range(len(arr)):\n        if arr[i] % n == 0:\n            number_list.append(arr[i])\n    return number_list"], [0.8913953304290771, "    result = 0\n    i = 0\n    while i < len(array):\n        result += array[i]\n        i += n\n    return result"], [0.8903977870941162, "    for num in array:\n        result = result * num % mod"], [0.8903887867927551, "    for num in array:\n        result = result * num % mod"], [0.8897864818572998, "        for i in range(len(arr)):\n            arr[i] += quotient\n            if remainder > 0:\n                arr[i] += 1\n                remainder -= 1"]]}
{"task_id": "MBPP/461", "problem": [[0.9053342342376709, "    arr.sort()\n    for i in range(len(arr) - 1):\n        if arr[i + 1] - arr[i] == 1:\n            return True\n    return False"], [0.9030659198760986, "    if len(input_list) <= 1:\n        return True\n    for index, item in enumerate(input_list[1:]):\n        if item - input_list[index] != 1:\n            return False\n    return True"], [0.9028716087341309, "    count = 0\n    for i in range(0, len(arr)):\n        if i + 1 < len(arr) and arr[i] + 1 == arr[i + 1]:\n            count += 1\n    if count > 0:\n        return True\n    else:\n        return False"], [0.9017377495765686, "    for i in range(len(arr) - 1):\n        if arr[i] + 1 == arr[i + 1]:\n            return True\n    return False"], [0.9017150402069092, "    for i in range(len(arr) - 1):\n        if arr[i] + 1 == arr[i + 1]:\n            return True"], [0.9008446931838989, "    for i in range(len(arr) - 1):\n        if arr[i + 1] - arr[i] == 1:\n            return True"], [0.9000803232192993, "    if len(arr) == 0:\n        return True\n    arr.sort()\n    for i in range(len(arr) - 1):\n        if arr[i] + 1 != arr[i + 1]:\n            return False\n    return True"], [0.8969259262084961, "    diff = lst[1] - lst[0]\n    for index in range(len(lst) - 1):\n        if not lst[index + 1] - lst[index] == diff:\n            return False\n    return True"], [0.8967772126197815, "    if not nums:\n        return False\n    nums.sort()\n    for i in range(1, len(nums)):\n        if nums[i] != nums[i - 1] + 1:\n            return False\n    return True"], [0.8964623808860779, "    arr.sort()\n    for i in range(len(arr) - 1):\n        if arr[i + 1] - arr[i] != 1:\n            return False\n    return True"]]}
{"task_id": "MBPP/462", "problem": [[0.9018163681030273, "    sets = map(set, lists)\n    intersection = reduce(set.intersection, sets)\n    return sorted(intersection)"], [0.9009712338447571, "    list_of_sets = [set(lst) for lst in list_of_lists]\n    common_set = set.intersection(*list_of_sets)\n    common_list = list(common_set)\n    return common_list"], [0.8990825414657593, "    common_elements = set(list_of_arrays[0])\n    for array in list_of_arrays:\n        common_elements.intersection_update(array)\n    return list(common_elements)"], [0.8980200290679932, "    intersection_list = []\n    for elem1 in my_list1:\n        for elem2 in my_list2:\n            if isinstance(elem1, (list, tuple)) and isinstance(elem2, (list, tuple)):\n                if intersection(elem1, elem2, cmp_func):\n                    intersection_list.append(elem1)\n                    break\n            elif not isinstance(elem1, (list, tuple)) and (not isinstance(elem2, (list, tuple))):\n                if cmp_func(elem1, elem2) == 0:\n                    intersection_list.append(elem1)\n                    break\n    return intersection_list"], [0.8975239992141724, "    intersection_list = list(set(list1) & set(list2))\n    return intersection_list"], [0.8971045017242432, "    result = []\n    for i in list1:\n        if i in tuple1:\n            result.append(i)\n    return result"], [0.8966907858848572, "    intersection = list(set(list1) & set(list2))\n    return intersection"], [0.8966842293739319, "    intersection = list(set(list1) & set(list2))\n    return intersection"], [0.895997166633606, "    set1 = set(input_list1)\n    set2 = set(input_list2)\n    return list(set1.intersection(set2))"], [0.895891547203064, "    common_items = set1.intersection(set2)\n    intersection_list = [item for item in set1 if item in common_items]\n    return intersection_list"]]}
{"task_id": "MBPP/463", "problem": [[0.9183146953582764, "    modified_string = input_string.replace(char_to_replace, replacement_char)\n    return modified_string"], [0.9163460731506348, "    new_string = ''\n    for char in string:\n        if char == c1:\n            new_string += c2\n        else:\n            new_string += char\n    return new_string"], [0.9147973656654358, "    new_string = ''\n    for char in string:\n        if char == old_char:\n            new_string += new_char\n        else:\n            new_string += char\n    return new_string"]]}
{"task_id": "MBPP/464", "problem": [[0.8978530168533325, "    sorted_dict = {}\n    for key, value in sorted(dictionary.items(), key=lambda item: item[1]):\n        sorted_dict[key] = value\n    return sorted_dict"], [0.8978281021118164, "    sorted_dict = {}\n    for key, value in sorted(dictionary.items(), key=lambda item: item[1]):\n        sorted_dict[key] = value\n    return sorted_dict"], [0.897257387638092, "    inv_dict = {v: k for k, v in my_dict.items()}\n    sorted_dict = dict(sorted(inv_dict.items(), key=lambda item: item[1], reverse=True))\n    return sorted_dict"], [0.897246778011322, "    inv_dict = {v: k for k, v in my_dict.items()}\n    sorted_dict = dict(sorted(inv_dict.items(), key=lambda item: item[1], reverse=True))\n    return sorted_dict"], [0.8970383405685425, "    sorted_dict = {key: value for key, value in sorted(dic.items(), key=lambda x: x[1], reverse=True)}\n    return sorted_dict"], [0.8969306945800781, "    sorted_count = {}\n    sorted_keys = sorted(word_count, key=word_count.get, reverse=True)\n    for key in sorted_keys:\n        sorted_count[key] = word_count[key]\n    return sorted_count"], [0.8964529633522034, "    return {k: v for k, v in sorted(in_dict.items(), key=lambda item: item[1])}"], [0.8956137895584106, "    list_of_tuples = []\n    for key, value in d.items():\n        list_of_tuples.append((key, value))\n    sorted_list = sorted(list_of_tuples, key=lambda x: x[1], reverse=True)\n    sorted_dict = {}\n    for tup in sorted_list:\n        sorted_dict[tup[0]] = tup[1]\n    return sorted_dict"], [0.8954296112060547, "    for key, value in sorted(dictionary.items(), key=lambda item: item[1]):\n        sorted_dict[key] = value"], [0.8954163789749146, "    for key, value in sorted(dictionary.items(), key=lambda item: item[1]):\n        sorted_dict[key] = value"]]}
{"task_id": "MBPP/465", "problem": [[0.9189164638519287, "    min_val = min(lst)\n    max_val = max(lst)\n    summation = min_val + max_val\n    return summation"], [0.9136742949485779, "    smallest_number = min(arr)\n    largest_number = max(arr)\n    return (smallest_number, largest_number)"], [0.9105253219604492, "    smallest = array[0]\n    largest = array[0]\n    for element in array:\n        if element > largest:\n            largest = element\n        elif element < smallest:\n            smallest = element\n    return (smallest, largest)"], [0.9098802804946899, "    largest = array[0]\n    smallest = array[0]\n    for num in array:\n        if num > largest:\n            largest = num\n        if num < smallest:\n            smallest = num\n    return (largest, smallest)"], [0.9086695313453674, "    arr.sort()\n    smallest = arr[0]\n    largest = arr[-1]\n    return (smallest, largest)"], [0.9086560010910034, "    arr.sort()\n    smallest = arr[0]\n    largest = arr[-1]\n    return (smallest, largest)"], [0.9066898822784424, "    max_value = max(array)\n    min_value = min(array)\n    return (max_value, min_value)"], [0.9059833288192749, "    maximum = array[0]\n    minimum = array[0]\n    for i in range(1, len(array)):\n        if array[i] > maximum:\n            maximum = array[i]\n        if array[i] < minimum:\n            minimum = array[i]\n    return (maximum, minimum)"], [0.90562903881073, "    min_value = array[0]\n    max_value = array[0]\n    for num in array:\n        if num < min_value:\n            min_value = num\n        if num > max_value:\n            max_value = num\n    return (min_value, max_value)"], [0.9055924415588379, "    max_val = array[0]\n    min_val = array[0]\n    for i in range(1, len(array)):\n        if array[i] > max_val:\n            max_val = array[i]\n        elif array[i] < min_val:\n            min_val = array[i]\n    return (max_val, min_val)"]]}
{"task_id": "MBPP/466", "problem": [[0.9230091571807861, "    new_string = ''\n    for letter in string:\n        new_string += letter.lower()\n    return new_string"], [0.9211143255233765, "    lowercase_string = ''\n    for char in string:\n        lowercase_string += char.lower()\n    return lowercase_string"], [0.9210901260375977, "    lowercase_string = ''\n    for char in string:\n        lowercase_string += char.lower()\n    return lowercase_string"], [0.9196560382843018, "    result = []\n    for char in string:\n        result.append(char.lower())\n    return result"], [0.9107272624969482, "    new_string = ''\n    for char in string:\n        if char.isalpha():\n            new_string += char.lower()\n        else:\n            new_string += char\n    return new_string"], [0.9105239510536194, "    for char in string:\n        lowercase_string += char.lower()"], [0.9105066061019897, "    for char in string:\n        lowercase_string += char.lower()"], [0.9073437452316284, "    char_list = list(s)\n    lower_char_list = [char.lower() for char in char_list]\n    result = ''.join(lower_char_list)\n    return result"], [0.9060888290405273, "    for letter in string:\n        new_string += letter.lower()"], [0.9054855108261108, "    new_string = ''\n    for char in string:\n        if char.islower():\n            new_string += char\n    return new_string"]]}
{"task_id": "MBPP/467", "problem": [[0.9142673015594482, "    lower_string_to_remove = string_to_remove.lower()\n    lower_string_to_modify = string_to_modify.lower()\n    words = string_to_modify.split()\n    modified_words = [word for word in words if word.lower() != lower_string_to_remove]\n    modified_string = ' '.join(modified_words)\n    return modified_string"], [0.9134592413902283, "    char = char.lower()\n    modified_string = ''\n    i = 0\n    while i < len(string):\n        current_char = string[i].lower()\n        if current_char == char:\n            i += 1\n        else:\n            modified_string += string[i]\n            i += 1\n    return modified_string"], [0.9118690490722656, "    lowercase_remove = string_to_remove.lower()\n    lowercase_modify = string_to_modify.lower()\n    words = lowercase_modify.split()\n    modified_words = [word.replace(lowercase_remove, '') if lowercase_remove in word else word for word in words]\n    modified_string = ' '.join(modified_words)\n    return modified_string"], [0.9114977121353149, "    newStr = ''\n    for i in range(len(my_string)):\n        if my_string[i] != 'c' and my_string[i] != 'C':\n            newStr += my_string[i]\n    return newStr"], [0.9095652103424072, "    modified_string = ''\n    character = character.lower()\n    for char in string:\n        char = char.lower()\n        if char != character:\n            modified_string += char\n    return modified_string"], [0.9088517427444458, "    new_string = ''\n    for char in string:\n        if char.lower() != letter.lower():\n            new_string += char\n    return new_string"], [0.9079815149307251, "    if not string:\n        return ''\n    chars = set(chars.lower())\n    return ''.join((char for char in string if char.lower() not in chars))"], [0.907717227935791, "    new_string = ''\n    for char in string:\n        if char.islower():\n            new_string += char\n    return new_string"], [0.9073032140731812, "    words = string.split()\n    words_without_target = []\n    for word in words:\n        if word.lower() != target.lower():\n            words_without_target.append(word)\n    return ' '.join(words_without_target)"], [0.9017653465270996, "    modified_string = ''\n    prev_char = ''\n    for char in input_string:\n        if char.lower() != prev_char.lower():\n            modified_string += char\n        prev_char = char\n    return modified_string"]]}
{"task_id": "MBPP/468", "problem": [[0.9074149131774902, "    if not isinstance(n, int):\n        raise ValueError('Input must be an integer.')\n    if n < 0:\n        n = -n\n    least_digit = n % 10\n    print('The least significant digit of', n, 'is', least_digit)\n    return least_digit"], [0.8998205065727234, "    str_num = str(num)\n    dot_position = str_num.index('.')\n    digit = int(str_num[dot_position - 1])\n    return digit"], [0.8947345018386841, "    return number % 10"], [0.8947299718856812, "    return number % 10"], [0.8927299976348877, "    size = 1\n    length = 9\n    start = 1\n    while n > length * size:\n        n -= length * size\n        size += 1\n        length *= 10\n        start *= 10\n    start += (n - 1) // size\n    s = str(start)\n    return int(s[(n - 1) % size])"], [0.8922419548034668, "    if number < 10:\n        return number\n    else:\n        sum = 0\n        for digit in str(number):\n            sum += int(digit)\n        return digital_root(sum)"], [0.8922419548034668, "    if number < 10:\n        return number\n    else:\n        sum = 0\n        for digit in str(number):\n            sum += int(digit)\n        return digital_root(sum)"], [0.8914586305618286, "    result = round(int(n))\n    result = abs(result)\n    digit_sum = 0\n    while result != 0:\n        digit_sum += result % 10\n        result //= 10\n    return digit_sum"], [0.8910597562789917, "    x = max(min(x, 1000), 1)\n    return x % 10"], [0.8883470296859741, "    while number > 0:\n        number = number // 10\n        count = count + 1"]]}
{"task_id": "MBPP/469", "problem": [[0.9414565563201904, "    max_char = ''\n    max_count = 0\n    for char in string:\n        if string.count(char) > max_count:\n            max_char = char\n            max_count = string.count(char)\n    return max_char"], [0.9371678829193115, "    counts = dict()\n    max = -1\n    character = ''\n    for char in string:\n        if char in counts:\n            counts[char] += 1\n        else:\n            counts[char] = 1\n        if counts[char] > max:\n            max = counts[char]\n            character = char\n    return character"], [0.9369763731956482, "    char_dict = {char: 0 for char in string}\n    for char in string:\n        char_dict[char] += 1\n    max_char = max(char_dict, key=lambda x: char_dict[x])\n    return max_char"], [0.935565173625946, "    charDict = dict()\n    for char in string:\n        if char in charDict:\n            charDict[char] += 1\n        else:\n            charDict[char] = 1\n    maximumOccurChar = max(charDict, key=charDict.get)\n    return maximumOccurChar"], [0.9335705637931824, "    char_counter = {}\n    for char in string:\n        if char in char_counter:\n            char_counter[char] += 1\n        else:\n            char_counter[char] = 1\n    max_char = ''\n    max_appearance = 0\n    for char, count in char_counter.items():\n        if count > max_appearance:\n            max_appearance = count\n            max_char = char\n    return max_char"], [0.933295726776123, "    character_dict = {}\n    for char in string:\n        if char not in character_dict:\n            character_dict[char] = 1\n        else:\n            character_dict[char] += 1\n    max_frequency = 0\n    max_frequency_char = ''\n    for char in character_dict:\n        if character_dict[char] > max_frequency:\n            max_frequency = character_dict[char]\n            max_frequency_char = char\n    return max_frequency_char"], [0.9331784248352051, "    frequencies = {}\n    for char in string:\n        if char in frequencies:\n            frequencies[char] += 1\n        else:\n            frequencies[char] = 1\n    max_frequency = 0\n    max_char = ''\n    for key, value in frequencies.items():\n        if value > max_frequency:\n            max_frequency = value\n            max_char = key\n    return max_char"], [0.9326947927474976, "    char_freq = {}\n    for char in string:\n        if char in char_freq.keys():\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n    max_freq = 0\n    max_char = None\n    for char, freq in char_freq.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_char = char\n    return max_char"], [0.9326860904693604, "    for char in string:\n        if string.count(char) > max_count:\n            max_char = char\n            max_count = string.count(char)"], [0.9323473572731018, "    frequency = {}\n    max_count = 0\n    max_char = ''\n    for char in input_str:\n        if char in frequency:\n            frequency[char] += 1\n            if frequency[char] > max_count:\n                max_count = frequency[char]\n                max_char = char\n        else:\n            frequency[char] = 1\n    return max_char"]]}
{"task_id": "MBPP/470", "problem": [[0.9218895435333252, "        if sum(subset) == target:\n            return True"], [0.9205999970436096, "    elements = set(arr)\n    for elem in arr:\n        if sum_val - elem in elements:\n            return True\n    return False"], [0.9201769828796387, "    subset = [[False for i in range(sum + 1)] for i in range(n + 1)]\n    for i in range(n + 1):\n        subset[i][0] = True\n    for i in range(1, sum + 1):\n        subset[0][i] = False\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            if j < set[i - 1]:\n                subset[i][j] = subset[i - 1][j]\n            if j >= set[i - 1]:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - set[i - 1]]\n    return subset[n][sum]"], [0.9163861870765686, "    if sum == 0:\n        return True\n    if len(nums) == 0:\n        return False\n    if nums[0] > sum:\n        return isSubsetSum(nums[1:], sum)\n    return isSubsetSum(nums[1:], sum - nums[0]) or isSubsetSum(nums[1:], sum)"], [0.9162642955780029, "    hash_map = dict()\n    for i in arr:\n        if sum - i in hash_map:\n            return True\n        hash_map[i] = True\n    return False"], [0.9161450266838074, "    s = sum(partial)\n    if s == target:\n        return True\n    if s > target:\n        return False\n    for i, n in enumerate(numbers):\n        remaining = numbers[i + 1:]\n        if subset_sum(remaining, target, partial + [n]):\n            return True\n    return False"], [0.9158010482788086, "    n = len(arr)\n    for i in range(1 << n):\n        summation = 0\n        for j in range(n):\n            if i & 1 << j > 0:\n                summation += arr[j]\n        if summation == x:\n            return True\n    return False"], [0.915441632270813, "    if target_sum == 0:\n        return True\n    if target_sum != 0 and len(arr) == 0:\n        return False\n    if arr[-1] > target_sum:\n        return subset_sum(arr[:-1], target_sum)\n    return subset_sum(arr[:-1], target_sum) or subset_sum(arr[:-1], target_sum - arr[-1])"], [0.915367841720581, "        if sum(sublist) == target:\n            return True"], [0.9146016836166382, "            if sum(sublist) == target:\n                return True"]]}
{"task_id": "MBPP/471", "problem": [[0.8995695114135742, "    word_list = re.findall('\\\\b\\\\w+\\\\b', s)\n    uppercase_words = []\n    for word in word_list:\n        if word.isupper():\n            uppercase_words.append(word)\n    return uppercase_words"], [0.8977210521697998, "    return re.findall('[A-Z][^A-Z]*', s)"], [0.8976884484291077, "    reg_ex = '\\\\b(?!([A-Z])\\\\1{2})[A-Z]{3}[a-z]{2}\\\\b'\n    matches = re.findall(reg_ex, input_text)\n    return matches if matches else 'No Match Found'"], [0.8956635594367981, "    uppercase_letters = []\n    for i in range(len(string) - 1):\n        if string[i].isupper() and string[i + 1].islower():\n            uppercase_letters.append(string[i])\n    lowercase_letters = set(string.lower()) - set(string.upper())\n    lowercase_letters = sorted(lowercase_letters, reverse=True)\n    for lowercase in lowercase_letters:\n        for uppercase in uppercase_letters:\n            if lowercase in string and lowercase in uppercase.lower():\n                print(uppercase)"], [0.8951238393783569, "    pattern = re.compile('a.*Z')\n    return pattern.findall(text)"], [0.8942325115203857, "    pattern = '[A-Z][a-z]*\\\\s[A-Z][a-z]*'\n    matches = re.findall(pattern, s)\n    return matches"], [0.8939275741577148, "    pattern_ab = '\\\\b(?:[A-Z][^A-Z]*){4}\\\\b'\n    matches_ab = re.findall(pattern_ab, text)\n    pattern_cd = '\\\\b(?:[C][D]){4}\\\\b'\n    matches_cd = re.findall(pattern_cd, text)\n    return matches_ab + matches_cd"], [0.8939201831817627, "    pattern_ab = '\\\\b(?:[A-Z][^A-Z]*){4}\\\\b'\n    matches_ab = re.findall(pattern_ab, text)\n    pattern_cd = '\\\\b(?:[C][D]){4}\\\\b'\n    matches_cd = re.findall(pattern_cd, text)\n    return matches_ab + matches_cd"], [0.8932271003723145, "    regex = '\\\\b[aA]\\\\w*\\\\b'\n    matches = re.findall(regex, s)\n    return list(set(matches))"], [0.8926858901977539, "    uppercase_chars = []\n    for char in string:\n        if char.isupper():\n            uppercase_chars.append(char)\n    return uppercase_chars"]]}
{"task_id": "MBPP/472", "problem": [[0.903806746006012, "    factor = 0\n    for i in range(1, int(x / 2 + 1)):\n        if x % i == 0:\n            factor = i\n    return factor"], [0.9010803699493408, "    while x > factor:\n        if x % factor == 0:\n            x //= factor\n        else:\n            factor += 1"], [0.9007782340049744, "    factor = 2\n    while x > factor:\n        if x % factor == 0:\n            x //= factor\n        else:\n            factor += 1\n    return factor"], [0.8999850153923035, "    for y in range(x - 1, 0, -1):\n        if y % 5 == 0:\n            return y"], [0.8999850153923035, "    for y in range(x - 1, 0, -1):\n        if y % 5 == 0:\n            return y"], [0.8994198441505432, "    found = False\n    num = 1\n    while found == False:\n        for i in range(1, n + 1):\n            if num % i != 0:\n                break\n            elif i == n:\n                found = True\n        num += 1\n    return num - 1"], [0.8965368866920471, "    for i in range(1, x + 1):\n        factorial *= i"], [0.8965246081352234, "    for i in range(1, x + 1):\n        factorial *= i"], [0.8963506817817688, "    if num < 0 or not float(num).is_integer():\n        return None\n    fact = 1\n    i = 1\n    while fact < num:\n        i += 1\n        fact *= i\n    return i if fact == num else None"], [0.8959037065505981, "    for num in range(bound, 0, -1):\n        if num % divisor == 0:\n            return num"]]}
{"task_id": "MBPP/473", "problem": [[0.8978985548019409, "                if not condition(item):\n                    result.append(remove_tuples(item, condition))"], [0.8978775143623352, "                if not condition(item):\n                    result.append(remove_tuples(item, condition))"], [0.8953763246536255, "    if len(tuples1) != len(tuples2):\n        return 'Error: Both lists should be of same length.'"], [0.8953601717948914, "    if len(tuples1) != len(tuples2):\n        return 'Error: Both lists should be of same length.'"], [0.8951473236083984, "            if condition(i):\n                continue\n            else:\n                result.append(remove_tuples(i, condition))"], [0.8951447010040283, "            if condition(i):\n                continue\n            else:\n                result.append(remove_tuples(i, condition))"], [0.8942548036575317, "    result = []\n    for i in list1:\n        if i in tuple1:\n            result.append(i)\n    return result"], [0.8928543329238892, "    for i in list2:\n        list1.remove(i)\n    return list1"], [0.892550528049469, "    new_tuple = ()\n    for element in tuple_input:\n        if element != target_element:\n            new_tuple += (element,)\n    return new_tuple"], [0.8925207853317261, "    for item in list2:\n        if item in list1:\n            list1.remove(item)\n    return list1"]]}
{"task_id": "MBPP/474", "problem": [[0.9351138472557068, "    max_palindrome = 0\n    for item in arr:\n        temp = str(item)\n        if temp == temp[::-1] and max_palindrome < item:\n            max_palindrome = item\n    return max_palindrome"], [0.9305518865585327, "    max_length = -1\n    max_index = -1\n    for i in range(len(arr)):\n        if is_palindrome(arr[i]):\n            length = len(str(arr[i]))\n            if length > max_length:\n                max_length = length\n                max_index = i\n    return max_index"], [0.9302127957344055, "    return max((num for num in numbers if is_palindrome(num)))"], [0.9291932582855225, "    palindromes = [num for num in numbers if str(num) == str(num)[::-1]]\n    if palindromes:\n        return max(palindromes)\n    else:\n        return 'No Palindrome Found'"]]}
{"task_id": "MBPP/475", "problem": [[0.8944272398948669, "    return comb(n, k) * p ** k * (1 - p) ** (n - k)"], [0.8916677236557007, "    return factorial(n) / (factorial(x) * factorial(n - x)) * p ** x * (1 - p) ** (n - x)"], [0.8906259536743164, "    return np.random.binomial(n, p)"], [0.8872653245925903, "    total_outcomes = 2 ** n\n    heads_outcomes = total_outcomes / 2\n    probability_of_heads = heads_outcomes / total_outcomes\n    return probability_of_heads"], [0.8865346908569336, "    der = derangement(n)\n    fact = factorial(n)\n    prob = der / fact\n    return prob"], [0.8858386278152466, "    num_outcomes = 6\n    num_favorable = 1\n    probability = num_favorable / num_outcomes\n    return probability"], [0.8838527202606201, "    perm_val = perm(n, r)\n    rFactorial = factorial(r)\n    answer = perm_val / rFactorial\n    return answer"], [0.8818659782409668, "    num_outcomes = 2\n    if event == outcome_1:\n        probability = 1 / num_outcomes\n    elif event == outcome_2:\n        probability = 1 / num_outcomes\n    else:\n        probability = 0\n    return probability"], [0.8812416791915894, "    for i in range(n):\n        probability *= count[i] / n"]]}
{"task_id": "MBPP/476", "problem": []}
{"task_id": "MBPP/477", "problem": [[0.8997561931610107, "    regular_area = calculate_area_regular_pentagon(radius)\n    original_side_length = 2 * radius * math.sin(math.pi / 5)\n    delta_length = updated_side_length - original_side_length\n    height_change = delta_length * math.cos(math.pi / 5)\n    base_change = delta_length * math.sin(math.pi / 5)\n    area_change = height_change * base_change\n    new_area = regular_area + area_change\n    return new_area"], [0.8968299031257629, "    if len(sides) != 5:\n        return 'Not a Pentagon'\n    else:\n        return sum(sides)"], [0.8968299031257629, "    if len(sides) != 5:\n        return 'Not a Pentagon'\n    else:\n        return sum(sides)"], [0.8955419063568115, "    side = 2 * radius * math.sin(math.pi / 5)\n    area = 5 / 4 * math.tan(math.pi / 5) * side ** 2\n    return area"], [0.8775953054428101, "    distance = math.sqrt((x - 1) ** 2 + (y + 2) ** 2)\n    angle = math.atan2(y + 2, x - 1)\n    x_axis_angle = math.acos(distance / 5)\n    area = 0.5 * x_axis_angle * 25\n    return area"], [0.8775913119316101, "    distance = math.sqrt((x - 1) ** 2 + (y + 2) ** 2)\n    angle = math.atan2(y + 2, x - 1)\n    x_axis_angle = math.acos(distance / 5)\n    area = 0.5 * x_axis_angle * 25\n    return area"], [0.8750711679458618, "        if isPentagonal(hexagonal):\n            return hexagonal"], [0.8747114539146423, "    elif len(sides) == 5:\n        a, b, c, d, e = sides\n        area = 0.25 * math.sqrt(5 * (5 + 2 * math.sqrt(5))) * a ** 2\n        return area\n    else:\n        return None"], [0.8742310404777527, "    if x < 7 or x > 15:\n        return 'Error: Input value is out of range.'\n    else:\n        perimeter = 5 * x\n        return perimeter"]]}
{"task_id": "MBPP/478", "problem": [[0.9236997365951538, "    largest_num = max(lst)\n    freq = lst.count(largest_num)\n    return (largest_num, freq)"], [0.923690915107727, "    largest_num = max(lst)\n    freq = lst.count(largest_num)\n    return (largest_num, freq)"], [0.9214847683906555, "    max_val = max(arr)\n    freq = arr.count(max_val)\n    return [max_val, freq]"], [0.9173345565795898, "    frequency_counter = {}\n    for num in array:\n        if num in frequency_counter:\n            frequency_counter[num] += 1\n        else:\n            frequency_counter[num] = 1\n    max_element = None\n    max_occurrence = 0\n    for num, frequency in frequency_counter.items():\n        if frequency > max_occurrence:\n            max_element = num\n            max_occurrence = frequency\n    return (max_element, max_occurrence)"], [0.9158741235733032, "    frequencies = {}\n    highest_frequency = 0\n    for element in array:\n        if element not in frequencies:\n            frequencies[element] = 1\n        else:\n            frequencies[element] += 1\n        if frequencies[element] > highest_frequency:\n            highest_frequency = frequencies[element]\n    return highest_frequency"], [0.9136241674423218, "    if not arr:\n        raise ValueError('Array is Empty')\n    maxValue = None\n    count = 0\n    for i in arr:\n        if not isinstance(i, int):\n            raise ValueError('Non-integer element found in array')\n        elif maxValue is None or i > maxValue:\n            maxValue = i\n            count = 1\n        elif i == maxValue:\n            count += 1\n    return (maxValue, count)"], [0.9126977324485779, "    counter_dict = {}\n    for val in array:\n        if val in counter_dict:\n            counter_dict[val] += 1\n        else:\n            counter_dict[val] = 1\n    max_count = 0\n    frequent_val = 0\n    for key, val in counter_dict.items():\n        if val > max_count:\n            max_count = val\n            frequent_val = key\n    return frequent_val"], [0.9126263856887817, "    frequency_count = {}\n    for num in array:\n        if num in frequency_count:\n            frequency_count[num] += 1\n        else:\n            frequency_count[num] = 1\n    most_frequent_num = max(frequency_count, key=frequency_count.get)\n    frequency = frequency_count[most_frequent_num]\n    return (most_frequent_num, frequency)"], [0.9125851392745972, "    if not my_list:\n        return 'The list is empty.'\n    max_value = max(my_list)\n    max_count = my_list.count(max_value)\n    return (max_value, max_count)"], [0.910697877407074, "    freq = {}\n    max = arr[0]\n    for i in arr:\n        if i in freq:\n            freq[i] += 1\n        else:\n            freq[i] = 1\n    for key, value in freq.items():\n        if value > max:\n            max = value\n            max_element = key\n        else:\n            max = max\n            max_element = max_element\n    return max_element"]]}
{"task_id": "MBPP/479", "problem": [[0.8769857287406921, "    seen = set()\n    pairs = []\n    for item in lst:\n        if -item in seen:\n            pairs.append([-item, item])\n        else:\n            seen.add(item)\n    return pairs"], [0.8762705326080322, "    pairs = []\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            pair = (lst[i], lst[j])\n            pairs.append(pair)\n    return pairs"], [0.8746640682220459, "    if right is None:\n        right = len(sequence) - 1\n    if pairs is None:\n        pairs = []\n    if left >= right:\n        return pairs\n    try:\n        if not isinstance(sequence[left], int) or not isinstance(sequence[right], int):\n            raise ValueError\n    except ValueError:\n        print('Invalid input: sequence should only contain integers')\n        return\n    if sequence[left] == sequence[right]:\n        pair = (sequence[left], sequence[right])\n        if pair not in pairs:\n            pairs.append(pair)\n    return check_symmetrical_pairs(sequence, left + 1, right - 1, pairs)"], [0.8746151328086853, "    set_dict = {}\n    for first, second in tuple_list:\n        key = str(first) + str(second)\n        if key not in set_dict:\n            set_dict[key] = (first, second)\n    return list(set_dict.values())"], [0.8725658655166626, "    unique_tuples = []\n    for tup in tuple_list:\n        if tup not in unique_tuples:\n            unique_tuples.append(tup)\n    return unique_tuples"], [0.8723528981208801, "    for first, second in tuple_list:\n        key = str(first) + str(second)\n        if key not in set_dict:\n            set_dict[key] = (first, second)"], [0.8718807697296143, "    rows = {}\n    for i in range(len(matrix)):\n        row = tuple(matrix[i])\n        reversed_row = tuple(reversed(matrix[i]))\n        if reversed_row in rows:\n            symmetric_pair = (rows[reversed_row], i)\n            return symmetric_pair\n        else:\n            rows[row] = i\n    return None"], [0.8713879585266113, "                if pair not in result and pair[::-1] not in result:\n                    result.append(pair)"], [0.8710337281227112, "    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            pair = (lst[i], lst[j])\n            pairs.append(pair)"], [0.8708565831184387, "    result = []\n    for x in range(len(list1)):\n        for y in range(x + 1, len(list1)):\n            result.append((list1[x], list1[y]))\n    return result"]]}
{"task_id": "MBPP/480", "problem": [[0.8986003994941711, "    sum = a * (1 - r ** n) / (1 - r)\n    if 300 <= sum <= 1200:\n        print(f'The sum of the geometric progression is: {sum}.')\n        print('Terms of the geometric progression:')\n        for i in range(n):\n            term = a * r ** i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of the geometric progression is not within the valid range, but {sum}.')"], [0.897592306137085, "    sum = a * (1 - r ** n) / (1 - r)\n    if 300 <= sum <= 1200:\n        print(f'Sum of geometric progression: {sum}.')\n        print('Terms of geometric progression:')\n        for i in range(n):\n            term = a * r ** i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of geometric progression is not within valid range, but {sum}.')"], [0.8894367218017578, "    if 300 <= sum <= 1200:\n        print(f'The sum of the geometric progression is: {sum}.')\n        print('Terms of the geometric progression:')\n        for i in range(n):\n            term = a * r ** i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of the geometric progression is not within the valid range, but {sum}.')"], [0.8882490396499634, "    if 300 <= sum <= 1200:\n        print(f'Sum of geometric progression: {sum}.')\n        print('Terms of geometric progression:')\n        for i in range(n):\n            term = a * r ** i\n            print(term)\n    else:\n        print(f'Invalid input! The sum of geometric progression is not within valid range, but {sum}.')"], [0.8857979774475098, "    total_sum = 0\n    for i in range(n):\n        total_sum += a * r ** i\n    return total_sum"], [0.8839496970176697, "    first_term = sum / (ratio ** terms - 1)\n    progression = [first_term * ratio ** n for n in range(terms)]\n    return progression"], [0.8836376667022705, "    for i in range(1, n + 1):\n        sum = sum + a * r ** (i - 1)"], [0.8829231858253479, "    sum = 0\n    for i in range(1, n + 1):\n        sum = sum + a * r ** (i - 1)\n    return sum"]]}
{"task_id": "MBPP/481", "problem": [[0.9196231961250305, "    sorted_arr = sort_array(arr)\n    return binary_search(sorted_arr, 0, len(arr) - 1, x)"]]}
{"task_id": "MBPP/482", "problem": [[0.8758910894393921, "    x_coordinates = []\n    y_coordinates = []\n    for i in x:\n        x_coordinates.append(i * 2)\n    for i in y:\n        y_coordinates.append(i * 2)\n    for i in x:\n        x_coordinates.append(i + 1 / 2)\n    for i in y:\n        y_coordinates.append(i + 1 / 2)\n    return (x_coordinates, y_coordinates)"], [0.8597870469093323, "        for y in range(0, 6):\n            if 4 * x + 5 * y == 20:\n                return (x, y)"], [0.8587017059326172, "    if x == 0 and y == 0:\n        return [[(0, 0)]]"], [0.8586322069168091, "    flat_list = []\n    for sublist in grid:\n        for item in sublist:\n            flat_list.append(item)\n    return flat_list"], [0.8554824590682983, "    matrix = [[0] * 6 for _ in range(6)]\n    top, bottom, left, right = (0, 5, 0, 5)\n    num = 0\n    while True:\n        for i in range(left, right + 1):\n            matrix[top][i] = given_list[num]\n            num += 1\n        top += 1\n        if num == len(given_list):\n            break\n        for i in range(top, bottom + 1):\n            matrix[i][right] = given_list[num]\n            num += 1\n        right -= 1\n        if num == len(given_list):\n            break\n        for i in range(right, left - 1, -1):\n            matrix[bottom][i] = given_list[num]\n            num += 1\n        bottom -= 1\n        if num == len(given_list):\n            break\n        for i in range(bottom, top - 1, -1):\n            matrix[i][left] = given_list[num]\n            num += 1\n        left += 1\n        if num == len(given_list):\n            break\n    return matrix"], [0.8546197414398193, "        if isPentagonal(hexagonal):\n            return hexagonal"], [0.8539493680000305, "    for sublist in grid:\n        for item in sublist:\n            flat_list.append(item)"], [0.8535880446434021, "    for x in range(0, 6):\n        for y in range(0, 6):\n            if 4 * x + 5 * y == 20:\n                return (x, y)"], [0.8525515794754028, "    transformed_coordinates = []\n    for x, y in coordinates:\n        transformed_x = x + y\n        transformed_y = x - y\n        transformed_coordinates.append((transformed_x, transformed_y))\n    return transformed_coordinates"], [0.852170467376709, "    result = []\n    for i in range(0, 6):\n        result.append(i)\n    return result"]]}
{"task_id": "MBPP/483", "problem": [[0.9122368693351746, "    return int(binary, 2)"], [0.9122310876846313, "    return int(binary, 2)"], [0.9122243523597717, "    return int(binary, 2)"], [0.9055978655815125, "    result = 0\n    for i in range(len(binary)):\n        digit = int(binary[i])\n        result += digit * 2 ** (len(binary) - 1 - i)\n    return result"], [0.9045217633247375, "    return int(binary_string, 2)"], [0.9045217633247375, "    return int(binary_string, 2)"], [0.9045071005821228, "    return int(binary_string, 2)"], [0.9045028686523438, "    return int(binary_string, 2)"], [0.9041098952293396, "    return int(binaryNum, 2)"], [0.9024234414100647, "    result = 0\n    for char in binary_str:\n        result = result * 2 + int(char)\n    return result"]]}
{"task_id": "MBPP/484", "problem": [[0.9082229137420654, "    char = char.lower()\n    modified_string = ''\n    i = 0\n    while i < len(string):\n        current_char = string[i].lower()\n        if current_char == char:\n            i += 1\n        else:\n            modified_string += string[i]\n            i += 1\n    return modified_string"], [0.9066455364227295, "    lower_string_to_remove = string_to_remove.lower()\n    lower_string_to_modify = string_to_modify.lower()\n    words = string_to_modify.split()\n    modified_words = [word for word in words if word.lower() != lower_string_to_remove]\n    modified_string = ' '.join(modified_words)\n    return modified_string"], [0.9064370393753052, "    new_string = ''\n    for char in string:\n        if char.islower():\n            new_string += char\n    return new_string"], [0.9053918123245239, "    lowercase_remove = string_to_remove.lower()\n    lowercase_modify = string_to_modify.lower()\n    words = lowercase_modify.split()\n    modified_words = [word.replace(lowercase_remove, '') if lowercase_remove in word else word for word in words]\n    modified_string = ' '.join(modified_words)\n    return modified_string"], [0.904608964920044, "    newStr = ''\n    for i in range(len(my_string)):\n        if my_string[i] != 'c' and my_string[i] != 'C':\n            newStr += my_string[i]\n    return newStr"], [0.9045653343200684, "    pattern = '[aeiouAEIOU]'\n    result = re.sub(pattern, '', string)\n    return result"], [0.9035202860832214, "    modified_string = ''\n    character = character.lower()\n    for char in string:\n        char = char.lower()\n        if char != character:\n            modified_string += char\n    return modified_string"], [0.9008005857467651, "    new_string = ''\n    for char in string:\n        if char.lower() != letter.lower():\n            new_string += char\n    return new_string"], [0.9000781774520874, "    modified_string = ''\n    prev_char = ''\n    for char in input_string:\n        if char.lower() != prev_char.lower():\n            modified_string += char\n        prev_char = char\n    return modified_string"], [0.8999751210212708, "    if not string:\n        return ''\n    chars = set(chars.lower())\n    return ''.join((char for char in string if char.lower() not in chars))"]]}
{"task_id": "MBPP/485", "problem": [[0.9023327827453613, "    smallest = float('inf')\n    count = 0\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n        count += 1\n        if count == 4:\n            break\n    return smallest"], [0.8978906869888306, "    heap = []\n    for item in data:\n        heapq.heappush(heap, item)\n    return heap"], [0.895767092704773, "    for num in arr:\n        heapq.heappush(min_heap, num)"], [0.895635187625885, "    for num in lst:\n        heapq.heappush(maxHeap, num)"], [0.8945479393005371, "    min_heap = []\n    for val in values:\n        heapq.heappush(min_heap, val)\n    optimized_values = []\n    while min_heap:\n        value = heapq.heappop(min_heap)\n        optimized_values.append(value)\n    return optimized_values"], [0.8944986462593079, "        for num in l:\n            heapq.heappush(min_heap, num)"], [0.8937249779701233, "    for item in data:\n        heapq.heappush(heap, item)"], [0.8901100158691406, "    smallest = float('inf')\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest"], [0.8899234533309937, "    sorted_list = heapq.nsmallest(n, lst)\n    return sorted_list[k - 1]"], [0.8899157047271729, "    heapq.heapify(arr)\n    return arr"]]}
{"task_id": "MBPP/486", "problem": [[0.8994513750076294, "    surface_area = 4 * 3.14159 * radius ** 2\n    return round(surface_area, 2)"], [0.8977165818214417, "    surface_area = 4 * math.pi * radius * radius\n    return surface_area"], [0.8936299681663513, "    return 1 / 3 * math.pi * cone['radius'] ** 2 * cone['height']"], [0.8928835391998291, "    surface_area = b * b + 4 * b * h / 2\n    return surface_area"], [0.8890383839607239, "    surface_area = 3.14 * radius * (radius + (height ** 2 + radius ** 2) ** 0.5)\n    volume = 3.14 * radius ** 2 * (height / 3)\n    return (surface_area, volume)"], [0.8871985673904419, "    if not (isinstance(radius, (int, float)) and isinstance(height, (int, float))):\n        raise TypeError('Radius and height should be numbers.')\n    if radius < 0 or height < 0:\n        raise ValueError('Radius and height should be non-negative.')\n    radius = float(radius)\n    height = float(height)\n    surface_area = 2 * math.pi * radius * (radius + height)\n    if surface_area.is_integer():\n        return int(surface_area)\n    return surface_area"]]}
{"task_id": "MBPP/487", "problem": [[0.9152926206588745, "    if num1 == 0:\n        return num2\n    elif num2 == 0:\n        return num1\n    else:\n        return gcd(num2, num1 % num2)"], [0.9152926206588745, "    if num1 == 0:\n        return num2\n    elif num2 == 0:\n        return num1\n    else:\n        return gcd(num2, num1 % num2)"], [0.9141192436218262, "    if a == 0:\n        gcd = b\n    elif b == 0:\n        gcd = a\n    else:\n        while b != 0:\n            temp = b\n            b = a % b\n            a = temp\n        gcd = a\n    return gcd"], [0.9136336445808411, "    if a > b:\n        return getGCD(a - b, b)"], [0.9135406613349915, "    if a > b:\n        return gcd(a % b, b)"], [0.9132487773895264, "    if a > b:\n        return findGCD(a - b, b)"], [0.9130440354347229, "    assert gcd(1, 1) == 1\n    assert gcd(12, 18) == 6\n    assert gcd(15, 5) == 5\n    assert gcd(21, 14) == 7"], [0.912553071975708, "    if a % b == 0:\n        return b\n    elif b % a == 0:\n        return a\n    if a > b:\n        return gcd(a % b, b)\n    else:\n        return gcd(a, b % a)"], [0.9122949838638306, "    if x == 0 or y == 0:\n        return 0\n    if x == y:\n        return x\n    if x > y:\n        return gcd(x - y, y)\n    else:\n        return gcd(x, y - x)"], [0.9120299220085144, "    if a > b:\n        return gcd(a - b, b)"]]}
{"task_id": "MBPP/488", "problem": [[0.9199844002723694, "    circumference = 3.14 * diameter\n    return circumference"], [0.9094131588935852, "    radius = diameter / 2\n    area = math.pi * radius ** 2\n    return area"], [0.9068028330802917, "    if diameter <= 0:\n        return 0\n    radius = diameter / 2\n    circumference = 2 * 3.14159 * radius\n    area = circumference * radius / 2\n    return area"], [0.906118631362915, "    circumference = 2 * 3.14 * radius\n    return circumference"], [0.9043095707893372, "    if diameter <= 0:\n        return 0"], [0.9030133485794067, "    perimeter = 2 * math.pi * radius\n    return perimeter"], [0.9025262594223022, "    area = 3.14 * radius ** 2\n    perimeter = 2 * 3.14 * radius\n    return (area, perimeter)"], [0.9021718502044678, "    area = math.pi * radius ** 2\n    circumference = 2 * math.pi * radius\n    return (area, circumference)"], [0.9021651744842529, "    area = math.pi * radius ** 2\n    circumference = 2 * math.pi * radius\n    return (area, circumference)"], [0.902045726776123, "    radius = ''.join(filter(str.isdigit, radius))\n    radius = float(radius)\n    circumference = 2 * math.pi * radius\n    return circumference"]]}
{"task_id": "MBPP/489", "problem": [[0.9185154438018799, "    output = ''\n    for item in input_list:\n        output = output + item\n    return output"], [0.9171593189239502, "    result = ''\n    for string in list_of_strings:\n        result += string\n    return result"], [0.9168969988822937, "    final_string = ''\n    for string in input_list:\n        final_string += string\n    return final_string"], [0.9150952100753784, "    final_string = ''\n    for string in list1:\n        final_string += string\n    return final_string"], [0.9100347757339478, "    result = ''\n    for item in string_list:\n        result += item\n    return result"], [0.9067379832267761, "    joinedString = ''\n    for word in givenList:\n        joinedString += word + separator\n    return joinedString.strip(separator)"], [0.9063740372657776, "    result = ''\n    for s in str_list:\n        result += s\n    return result"], [0.9049974083900452, "    result = ''\n    for idx, element in enumerate(input_list):\n        try:\n            result += ' ' + str(element) if idx != 0 else str(element)\n        except TypeError:\n            print('Error: Element not a string')\n    return result"], [0.9031162261962891, "    if type(lst) != list:\n        return 'Invalid input. Please provide a list of strings.'\n    elif not all((isinstance(item, str) for item in lst)):\n        return 'Invalid input. The list should only contain string items.'\n    else:\n        return ', '.join(lst)"], [0.9031162261962891, "    if type(lst) != list:\n        return 'Invalid input. Please provide a list of strings.'\n    elif not all((isinstance(item, str) for item in lst)):\n        return 'Invalid input. The list should only contain string items.'\n    else:\n        return ', '.join(lst)"]]}
{"task_id": "MBPP/490", "problem": [[0.9082554578781128, "    if num2 == 0:\n        return num1\n    return greatest_common_divisor(num2, num1 % num2)"], [0.9040430188179016, "    gcd = 1\n    if num1 < num2:\n        small = num1\n    else:\n        small = num2\n    for i in range(1, small + 1):\n        if num1 % i == 0 and num2 % i == 0:\n            gcd = i\n    return gcd"], [0.9032904505729675, "    smallest = min(A, B)\n    largest_divisor = 1\n    for i in range(1, smallest + 1):\n        if A % i == 0 and B % i == 0:\n            largest_divisor = i\n    return largest_divisor"], [0.9030650854110718, "    gcd_value = math.gcd(a, b)\n    lcm_value = abs(a * b) / gcd_value\n    return (gcd_value, lcm_value)"], [0.9029293060302734, "    if N1 < N2:\n        smaller = N1\n    else:\n        smaller = N2\n    largest_common_factor = -1\n    for i in range(1, R + 1):\n        if N1 % i == 0 and N2 % i == 0:\n            largest_common_factor = i\n    return largest_common_factor"], [0.9025648832321167, "    if not isinstance(num1, int) or not isinstance(num2, int) or num1 == 0 or (num2 == 0):\n        return 'Error: Both the inputs have to be non-zero integers!'\n    elif num1 > num2:\n        if num1 % num2 == 0:\n            return num2\n        else:\n            return highest_common_factor(num2, num1 % num2)\n    elif num2 % num1 == 0:\n        return num1\n    else:\n        return highest_common_factor(num1, num2 % num1)"], [0.9025648832321167, "    if not isinstance(num1, int) or not isinstance(num2, int) or num1 == 0 or (num2 == 0):\n        return 'Error: Both the inputs have to be non-zero integers!'\n    elif num1 > num2:\n        if num1 % num2 == 0:\n            return num2\n        else:\n            return highest_common_factor(num2, num1 % num2)\n    elif num2 % num1 == 0:\n        return num1\n    else:\n        return highest_common_factor(num1, num2 % num1)"]]}
{"task_id": "MBPP/491", "problem": [[0.9145887494087219, "    a = abs(a)\n    b = abs(b)\n    if a == 0 or b == 0:\n        return 'Error: Zero is not allowed as an input'\n    greater = max(a, b)\n    smaller = min(a, b)\n    remainder = greater % smaller\n    return remainder"], [0.9115035533905029, "    quotient = n1 // n2\n    remainder = n1 - n2 * quotient\n    return remainder"], [0.9090949296951294, "    quotient = num1 / num2\n    remainder = num1 % num2\n    print('The quotient is:', quotient)\n    print('The remainder is:', remainder)\n    return quotient"], [0.9061474204063416, "    quotient = a // b\n    remainder = a % b\n    print('Quotient:', quotient)\n    print('Remainder:', remainder)"], [0.9040065407752991, "    return num1 % num2"], [0.9039971232414246, "    return num1 % num2"], [0.8991758227348328, "    quotient = num1 // num2\n    remainder = num1 % num2\n    return (quotient, remainder)"], [0.8991524577140808, "    quotient = num1 // num2\n    remainder = num1 % num2\n    return (quotient, remainder)"], [0.8989434242248535, "    sum_ab = a + b\n    remainder = sum_ab % c\n    return remainder"], [0.8988810181617737, "    if num < 4:\n        return num\n    else:\n        return remainder(num - 4)"]]}
{"task_id": "MBPP/492", "problem": [[0.9115899205207825, "    output_list = []\n    for i in range(len(input_list) - 1):\n        sum = input_list[i] + input_list[i + 1]\n        output_list.append(sum)\n    return output_list"], [0.9070519208908081, "    for i in range(len(input_list) - 1):\n        sum = input_list[i] + input_list[i + 1]\n        output_list.append(sum)"], [0.9024835228919983, "    if len(given_list) == 1:\n        return given_list[0]\n    else:\n        return given_list[0] + sum_list(given_list[1:])"], [0.9024835228919983, "    if len(given_list) == 1:\n        return given_list[0]\n    else:\n        return given_list[0] + sum_list(given_list[1:])"], [0.9017415046691895, "    res = [list[0]]\n    for i in range(1, len(list)):\n        new_num = res[i - 1] + list[i]\n        res.append(new_num)\n    return res"], [0.901199460029602, "    if not nums:\n        return 0\n    return nums[0] + sum_list(nums[1:])"], [0.9006571173667908, "    sum_list = []\n    for i in range(len(original_list)):\n        if i == len(original_list) - 1:\n            continue\n        sum_list.append(original_list[i] + original_list[i + 1])\n    return sum_list"], [0.8996374607086182, "    if len(lst) == 1:\n        return lst[0]\n    else:\n        return lst[0] + add_recursively(lst[1:])"], [0.8996374607086182, "    if len(lst) == 1:\n        return lst[0]\n    else:\n        return lst[0] + add_recursively(lst[1:])"], [0.8990497589111328, "    for i in my_list:\n        sum += i\n        new_list.append(sum)"]]}
{"task_id": "MBPP/493", "problem": [[0.9257227182388306, "    sum = 0\n    for i in range(1, n + 1):\n        sum += i ** 3\n    return sum"], [0.9257173538208008, "    sum = 0\n    for i in range(1, n + 1):\n        sum += i ** 3\n    return sum"], [0.925716757774353, "    sum = 0\n    for i in range(1, n + 1):\n        sum += i ** 3\n    return sum"], [0.9254683256149292, "    if not isinstance(n, int) or n < 1:\n        return 'Error: Input should be a natural number.'\n    sum_of_cubes = sum([i ** 3 for i in range(1, n + 1)])\n    sum_of_numbers = sum([i for i in range(1, n + 1)])\n    return sum_of_cubes - sum_of_numbers"], [0.9254670143127441, "    if not isinstance(n, int) or n < 1:\n        return 'Error: Input should be a natural number.'\n    sum_of_cubes = sum([i ** 3 for i in range(1, n + 1)])\n    sum_of_numbers = sum([i for i in range(1, n + 1)])\n    return sum_of_cubes - sum_of_numbers"], [0.924963653087616, "    sum = 0\n    for num in range(1, n + 1):\n        sum += num ** 3\n    return sum"], [0.9241547584533691, "    sum = 0\n    for i in range(n + 1):\n        sum += i ** 3\n    return sum"], [0.9226182699203491, "    if n < 0:\n        raise ValueError('Input cannot be a negative number.')\n    if n == 0:\n        return 0\n    else:\n        return n ** 3 + sum_cubes(n - 1)"], [0.9220935702323914, "    if n == 0:\n        return 0\n    else:\n        return n ** 3 + sum_cubes(n - 1)"], [0.9196638464927673, "    result = 0\n    for i in range(1, n + 1):\n        result += i ** 3\n    return result"]]}
{"task_id": "MBPP/494", "problem": [[0.9229710102081299, "        for item in array:\n            if item == 0:\n                count_zero += 1\n            else:\n                new_array.append(move_zeros(item))"], [0.9229710102081299, "        for item in array:\n            if item == 0:\n                count_zero += 1\n            else:\n                new_array.append(move_zeros(item))"], [0.9212918877601624, "    num_zeros = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[num_zeros], nums[i] = (nums[i], nums[num_zeros])\n            num_zeros += 1\n    return nums"], [0.9163033962249756, "    j = 0\n    for i in range(len(arr)):\n        if arr[i] != 0:\n            arr[j] = arr[i]\n            j += 1\n    for i in range(j, len(arr)):\n        arr[i] = 0"], [0.9160104393959045, "    for i in range(len(nums)):\n        if nums[i] == 0:\n            nums.append(nums.pop(i))"], [0.9150182008743286, "    j = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[j] = nums[i]\n            j += 1\n    for k in range(j, len(nums)):\n        nums[k] = 0"]]}
{"task_id": "MBPP/495", "problem": [[0.909854531288147, "    perm_val = perm(n, r)\n    rFactorial = factorial(r)\n    answer = perm_val / rFactorial\n    return answer"], [0.9069410562515259, "    coefficient = []\n    for k in range(n + 1):\n        coefficient.append(int(math.factorial(n) / (math.factorial(k) * math.factorial(n - k))))\n    return coefficient"], [0.9054787158966064, "    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"], [0.9054750204086304, "    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"], [0.9054486751556396, "    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"], [0.9042795896530151, "    return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))"], [0.9035031795501709, "    return math.comb(n, k)"], [0.9028823375701904, "    if n < k:\n        return 'Invalid input: n should be greater than or equal to k'\n    elif k == 0 or k == n:\n        return 1\n    else:\n        numerator = 1\n        denominator = 1\n        for i in range(1, min(k, n - k) + 1):\n            numerator *= n - i + 1\n            denominator *= i\n        return numerator // denominator"], [0.9028823375701904, "    if n < k:\n        return 'Invalid input: n should be greater than or equal to k'\n    elif k == 0 or k == n:\n        return 1\n    else:\n        numerator = 1\n        denominator = 1\n        for i in range(1, min(k, n - k) + 1):\n            numerator *= n - i + 1\n            denominator *= i\n        return numerator // denominator"], [0.9009940028190613, "    permutations = 1\n    for i in range(1, n + 1):\n        permutations *= i\n    return permutations"]]}
{"task_id": "MBPP/496", "problem": [[0.9155696630477905, "    filtered_words = []\n    for word in words:\n        if word not in filter_list:\n            filtered_words.append(word)\n    return filtered_words"], [0.9081203937530518, "    new_words = []\n    for word in words:\n        if 't' not in word:\n            new_words.append(word)\n    return new_words"], [0.9079705476760864, "    clean_sentence = [word for word in sentence.split(' ') if word not in words]\n    return ' '.join(clean_sentence)"], [0.9033728837966919, "    words = string.split()\n    words_without_target = []\n    for word in words:\n        if word.lower() != target.lower():\n            words_without_target.append(word)\n    return ' '.join(words_without_target)"], [0.9003111720085144, "    words = s.replace(',', '').split()\n    return [word for word in words if word != target]"], [0.9003031253814697, "    words = s.replace(',', '').split()\n    return [word for word in words if word != target]"], [0.9001098871231079, "    lst = str.split()\n    lst2 = []\n    for c in lst:\n        if c != word:\n            lst2.append(c)\n    return ' '.join(lst2)"]]}
{"task_id": "MBPP/497", "problem": [[0.9294617176055908, "    if l1 == l2:\n        print('The lists are exactly the same including the order.')\n    else:\n        print('The lists are not exactly the same including the order.')"], [0.922024667263031, "    return set(list1) == set(list2)"], [0.9220180511474609, "    return set(list1) == set(list2)"], [0.9220178127288818, "    return set(list1) == set(list2)"], [0.9220141172409058, "    return set(list1) == set(list2)"], [0.9220134019851685, "    return set(list1) == set(list2)"], [0.9202070236206055, "    if set1 == set2:\n        print('The lists contain the same unique elements regardless of the order.')"], [0.9197033643722534, "    if list1 == list2:\n        return True\n    else:\n        return False"], [0.9196954369544983, "    if list1 == list2:\n        return True\n    else:\n        return False"], [0.9196401834487915, "    if set1 == set2 and l1 != l2:\n        print('The lists contain the same elements but in a different order.')"]]}
{"task_id": "MBPP/498", "problem": []}
{"task_id": "MBPP/499", "problem": [[0.9187495708465576, "    if k <= 1:\n        return 0\n    l = 0\n    count = 0\n    product = 1\n    for r in range(len(nums)):\n        product *= nums[r]\n        while product >= k:\n            product /= nums[l]\n            l += 1\n        count += r - l + 1\n    return count"], [0.9180477857589722, "    if k <= 1:\n        return 0\n    prod = 1\n    count = 0\n    left = 0\n    for right in range(len(nums)):\n        prod *= nums[right]\n        while prod >= k:\n            prod /= nums[left]\n            left += 1\n        count += right - left + 1\n    return count"], [0.9180430173873901, "    if k <= 1:\n        return 0\n    prod = 1\n    count = 0\n    left = 0\n    for right in range(len(nums)):\n        prod *= nums[right]\n        while prod >= k:\n            prod /= nums[left]\n            left += 1\n        count += right - left + 1\n    return count"], [0.9122673273086548, "    for r in range(len(nums)):\n        product *= nums[r]\n        while product >= k:\n            product /= nums[l]\n            l += 1\n        count += r - l + 1"], [0.9086107015609741, "    for right in range(len(nums)):\n        prod *= nums[right]\n        while prod >= k:\n            prod /= nums[left]\n            left += 1\n        count += right - left + 1"], [0.9085885286331177, "    for right in range(len(nums)):\n        prod *= nums[right]\n        while prod >= k:\n            prod /= nums[left]\n            left += 1\n        count += right - left + 1"], [0.9056630730628967, "        for j in range(i, n):\n            product *= arr[j]\n            if product > 0:\n                count += 1"], [0.9042388200759888, "    count = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            if product > 0:\n                count += 1\n    return count"], [0.8999318480491638, "    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            if product > 0:\n                count += 1"], [0.8963116407394409, "        while product >= k:\n            product /= nums[l]\n            l += 1"]]}
